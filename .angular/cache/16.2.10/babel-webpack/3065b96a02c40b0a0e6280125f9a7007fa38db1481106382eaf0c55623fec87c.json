{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { InjectionToken } from '@angular/core';\nimport { Md5 } from 'ts-md5/dist/md5';\nimport { timeout } from 'rxjs/operators';\nimport { CoreApp } from '@services/app';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreLoginError } from '@classes/errors/loginerror';\nimport { makeSingleton, Translate, Http } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { APP_SCHEMA, SCHEMA_VERSIONS_TABLE_SCHEMA, SITES_TABLE_NAME, SCHEMA_VERSIONS_TABLE_NAME } from '@services/database/sites';\nimport { CoreArray } from '../singletons/array';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreSitesFactory } from './sites-factory';\nimport { CoreText } from '@singletons/text';\nimport { CoreLoginHelper } from '@features/login/services/login-helper';\nimport { CoreErrorWithOptions } from '@classes/errors/errorwithoptions';\nimport { CoreAjaxError } from '@classes/errors/ajaxerror';\nimport { CoreSitePlugins } from '@features/siteplugins/services/siteplugins';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport { asyncInstance } from '../utils/async-instance';\nimport { CoreConfig } from './config';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUserGuestSupportConfig } from '@features/user/classes/support/guest-support-config';\nimport { CoreLang } from '@services/lang';\nimport { CoreNative } from '@features/native/services/native';\nimport { CoreContentLinksHelper } from '@features/contentlinks/services/contentlinks-helper';\nimport { CoreAutoLogoutType, CoreAutoLogout } from '@features/autologout/services/autologout';\nimport { CoreCacheManager } from '@services/cache-manager';\nimport { firstValueFrom } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport const CORE_SITE_SCHEMAS = new InjectionToken('CORE_SITE_SCHEMAS');\nexport const CORE_SITE_CURRENT_SITE_ID_CONFIG = 'current_site_id';\n/*\n * Service to manage and interact with sites.\n * It allows creating tables in the databases of all sites. Each service or component should be responsible of creating\n * their own database tables calling the registerCoreSiteSchema method.\n*/\nexport class CoreSitesProvider {\n  constructor(siteSchemas) {\n    this.sessionRestored = false;\n    this.sites = {};\n    this.siteSchemasMigration = {};\n    this.siteSchemas = {};\n    this.pluginsSiteSchemas = {};\n    this.siteTables = {};\n    this.schemasTables = {};\n    this.sitesTable = asyncInstance();\n    this.logger = CoreLogger.getInstance('CoreSitesProvider');\n    this.siteSchemas = CoreArray.flatten(siteSchemas !== null && siteSchemas !== void 0 ? siteSchemas : []).reduce((siteSchemas, schema) => {\n      siteSchemas[schema.name] = schema;\n      return siteSchemas;\n    }, this.siteSchemas);\n  }\n  /**\n   * Initialize.\n   */\n  initialize() {\n    var _this = this;\n    CoreEvents.on(CoreEvents.SITE_DELETED, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        siteId\n      }) {\n        if (!siteId || !(siteId in _this.siteTables)) {\n          return;\n        }\n        yield Promise.all(Object.values(_this.siteTables[siteId]).map(promisedTable => promisedTable.then(table => table.destroy())));\n        delete _this.siteTables[siteId];\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    CoreCacheManager.registerInvalidateListener(() => this.invalidateCaches());\n  }\n  /**\n   * Initialize database.\n   */\n  initializeDatabase() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield CoreApp.createTablesFromSchema(APP_SCHEMA);\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      const sitesTable = new CoreDatabaseTableProxy({\n        cachingStrategy: CoreDatabaseCachingStrategy.Eager\n      }, CoreApp.getDB(), SITES_TABLE_NAME);\n      yield sitesTable.initialize();\n      _this2.sitesTable.setInstance(sitesTable);\n    })();\n  }\n  /**\n   * Get site table.\n   *\n   * @param tableName Site table name.\n   * @param options Options to configure table initialization.\n   * @returns Site table.\n   */\n  getSiteTable(tableName, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _options$siteId;\n      const siteId = (_options$siteId = options.siteId) !== null && _options$siteId !== void 0 ? _options$siteId : _this3.getCurrentSiteId();\n      if (!(siteId in _this3.siteTables)) {\n        _this3.siteTables[siteId] = {};\n      }\n      if (!(tableName in _this3.siteTables[siteId])) {\n        var _options$database, _options$config;\n        const promisedTable = _this3.siteTables[siteId][tableName] = new CorePromisedValue();\n        const database = (_options$database = options.database) !== null && _options$database !== void 0 ? _options$database : yield _this3.getSiteDb(siteId);\n        const table = new CoreDatabaseTableProxy((_options$config = options.config) !== null && _options$config !== void 0 ? _options$config : {}, database, tableName, options.primaryKeyColumns);\n        options.onDestroy && table.addListener({\n          onDestroy: options.onDestroy\n        });\n        yield table.initialize();\n        promisedTable.resolve(table);\n      }\n      return _this3.siteTables[siteId][tableName];\n    })();\n  }\n  /**\n   * Get the demo data for a certain \"name\" if it is a demo site.\n   *\n   * @param name Name of the site to check.\n   * @returns Site data if it's a demo site, undefined otherwise.\n   */\n  getDemoSiteData(name) {\n    const demoSites = CoreConstants.CONFIG.demo_sites;\n    name = name.toLowerCase();\n    if (demoSites !== undefined && demoSites[name] !== undefined) {\n      return demoSites[name];\n    }\n  }\n  /**\n   * Check if a site is valid and if it has specifics settings for authentication (like force to log in using the browser).\n   * It will test both protocols if the first one fails: http and https.\n   *\n   * @param siteUrl URL of the site to check.\n   * @param protocol Protocol to use first.\n   * @returns A promise resolved when the site is checked.\n   */\n  checkSite(siteUrl, protocol = 'https://') {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // The formatURL function adds the protocol if is missing.\n      siteUrl = CoreUrlUtils.formatURL(siteUrl);\n      if (!CoreUrlUtils.isHttpURL(siteUrl)) {\n        throw new CoreError(Translate.instant('core.login.invalidsite'));\n      }\n      if (!CoreNetwork.isOnline()) {\n        throw new CoreNetworkError();\n      }\n      try {\n        return yield _this4.checkSiteWithProtocol(siteUrl, protocol);\n      } catch (error) {\n        // Do not continue checking if a critical error happened.\n        if (error.critical) {\n          throw error;\n        }\n        // Retry with the other protocol.\n        protocol = protocol == 'https://' ? 'http://' : 'https://';\n        try {\n          return yield _this4.checkSiteWithProtocol(siteUrl, protocol);\n        } catch (secondError) {\n          if (secondError.critical) {\n            throw secondError;\n          }\n          // Site doesn't exist. Return the error message.\n          if (CoreTextUtils.getErrorMessageFromError(error)) {\n            throw error;\n          } else if (CoreTextUtils.getErrorMessageFromError(secondError)) {\n            throw secondError;\n          } else {\n            throw new CoreError(Translate.instant('core.sitenotfoundhelp'));\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Helper function to check if a site is valid and if it has specifics settings for authentication.\n   *\n   * @param siteUrl URL of the site to check.\n   * @param protocol Protocol to use.\n   * @returns A promise resolved when the site is checked.\n   */\n  checkSiteWithProtocol(siteUrl, protocol) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var _config;\n      // Now, replace the siteUrl with the protocol.\n      siteUrl = siteUrl.replace(/^https?:\\/\\//i, protocol);\n      // Create a temporary site to fetch site info.\n      const temporarySite = CoreSitesFactory.makeUnauthenticatedSite(siteUrl);\n      let config;\n      try {\n        config = yield temporarySite.getPublicConfig();\n      } catch (error) {\n        const treatedError = yield _this5.treatGetPublicConfigError(temporarySite.getURL(), error);\n        if (treatedError.critical) {\n          throw treatedError; // App received a WS error, stop.\n        }\n        // Try to add or remove 'www'.\n        temporarySite.setURL(CoreUrlUtils.addOrRemoveWWW(temporarySite.getURL()));\n        try {\n          config = yield temporarySite.getPublicConfig();\n        } catch (secondError) {\n          const treatedSecondError = yield _this5.treatGetPublicConfigError(temporarySite.getURL(), secondError);\n          if (treatedSecondError.critical) {\n            throw treatedSecondError; // App received a WS error, stop.\n          }\n          // App didn't receive a WS response, probably cannot connect. Prioritize first error if it's valid.\n          if (CoreTextUtils.getErrorMessageFromError(error)) {\n            throw error;\n          } else {\n            throw secondError;\n          }\n        }\n      }\n      // Check that the user can authenticate.\n      if (!config.enablewebservices) {\n        throw _this5.createCannotConnectLoginError(config.httpswwwroot || config.wwwroot, {\n          supportConfig: new CoreUserGuestSupportConfig(temporarySite, config),\n          errorcode: 'webservicesnotenabled',\n          errorDetails: Translate.instant('core.login.webservicesnotenabled'),\n          critical: true\n        });\n      }\n      if (!config.enablemobilewebservice) {\n        throw _this5.createCannotConnectLoginError(config.httpswwwroot || config.wwwroot, {\n          supportConfig: new CoreUserGuestSupportConfig(temporarySite, config),\n          errorcode: 'mobileservicesnotenabled',\n          errorDetails: Translate.instant('core.login.mobileservicesnotenabled'),\n          critical: true\n        });\n      }\n      if (config.maintenanceenabled) {\n        let message = Translate.instant('core.sitemaintenance');\n        if (config.maintenancemessage) {\n          message += config.maintenancemessage;\n        }\n        throw new CoreLoginError({\n          message,\n          critical: true\n        });\n      }\n      siteUrl = temporarySite.getURL();\n      return {\n        siteUrl,\n        code: ((_config = config) === null || _config === void 0 ? void 0 : _config.typeoflogin) || 0,\n        service: CoreConstants.CONFIG.wsservice,\n        config\n      };\n    })();\n  }\n  /**\n   * Create an error to be thrown when it isn't possible to login to a site.\n   *\n   * @param siteUrl Site Url.\n   * @param options Error options.\n   * @returns Cannot connect error.\n   */\n  createCannotConnectLoginError(siteUrl, options) {\n    var _this$currentSite;\n    return new CoreLoginError(_objectSpread(_objectSpread({}, options), {}, {\n      message: !this.isLoggedIn() && siteUrl === null ? Translate.instant('core.sitenotfoundhelp') : Translate.instant('core.siteunavailablehelp', {\n        site: siteUrl !== null && siteUrl !== void 0 ? siteUrl : (_this$currentSite = this.currentSite) === null || _this$currentSite === void 0 ? void 0 : _this$currentSite.siteUrl\n      })\n    }));\n  }\n  /**\n   * Treat an error returned by getPublicConfig in checkSiteWithProtocol. Converts the error to a CoreLoginError.\n   *\n   * @param siteUrl Site URL.\n   * @param error Error returned.\n   * @returns Promise resolved with the treated error.\n   */\n  treatGetPublicConfigError(siteUrl, error) {\n    return _asyncToGenerator(function* () {\n      var _error$errorDetails;\n      if (error instanceof CoreAjaxError || !('errorcode' in error)) {\n        // The WS didn't return data, probably cannot connect.\n        return new CoreLoginError({\n          title: Translate.instant('core.cannotconnect'),\n          message: Translate.instant('core.siteunavailablehelp', {\n            site: siteUrl\n          }),\n          errorcode: 'publicconfigfailed',\n          errorDetails: error.message || '',\n          critical: false // Allow fallback to http if siteUrl uses https.\n        });\n      }\n      // Service supported but an error happened. Return error.\n      const options = {\n        critical: true,\n        title: Translate.instant('core.cannotconnect'),\n        message: Translate.instant('core.siteunavailablehelp', {\n          site: siteUrl\n        }),\n        errorcode: error.errorcode,\n        supportConfig: error.supportConfig,\n        errorDetails: (_error$errorDetails = error.errorDetails) !== null && _error$errorDetails !== void 0 ? _error$errorDetails : error.message\n      };\n      if (error.errorcode === 'codingerror') {\n        // This could be caused by a redirect. Check if it's the case.\n        const redirect = yield CoreUtils.checkRedirect(siteUrl);\n        options.message = Translate.instant('core.siteunavailablehelp', {\n          site: siteUrl\n        });\n        if (redirect) {\n          options.errorcode = 'sitehasredirect';\n          options.errorDetails = Translate.instant('core.login.sitehasredirect');\n          options.critical = false; // Keep checking fallback URLs.\n        }\n      } else if (error.errorcode === 'invalidrecord') {\n        // WebService not found, site not supported.\n        options.message = Translate.instant('core.siteunavailablehelp', {\n          site: siteUrl\n        });\n        options.errorcode = 'invalidmoodleversion';\n        options.errorDetails = Translate.instant('core.login.invalidmoodleversion', {\n          $a: CoreSite.MINIMUM_MOODLE_VERSION\n        });\n      } else if (error.errorcode === 'redirecterrordetected') {\n        options.critical = false; // Keep checking fallback URLs.\n      }\n\n      return new CoreLoginError(options);\n    })();\n  }\n  /**\n   * Gets a user token from the server.\n   *\n   * @param siteUrl The site url.\n   * @param username User name.\n   * @param password Password.\n   * @param service Service to use. If not defined, it will be searched in memory.\n   * @param retry Whether we are retrying with a prefixed URL.\n   * @returns A promise resolved when the token is retrieved.\n   */\n  getUserToken(siteUrl, username, password, service, retry) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreNetwork.isOnline()) {\n        throw new CoreNetworkError();\n      }\n      service = service || CoreConstants.CONFIG.wsservice;\n      const lang = yield CoreLang.getCurrentLanguage(\"lms\" /* CoreLangFormat.LMS */);\n      const params = {\n        username,\n        password,\n        service\n      };\n      const loginUrl = `${siteUrl}/login/token.php?lang=${lang}`;\n      let data;\n      try {\n        data = yield firstValueFrom(Http.post(loginUrl, params).pipe(timeout(CoreWS.getRequestTimeout())));\n      } catch (error) {\n        var _this6$currentSite;\n        throw new CoreError(_this6.isLoggedIn() ? Translate.instant('core.siteunavailablehelp', {\n          site: (_this6$currentSite = _this6.currentSite) === null || _this6$currentSite === void 0 ? void 0 : _this6$currentSite.siteUrl\n        }) : Translate.instant('core.sitenotfoundhelp'));\n      }\n      if (data === undefined) {\n        var _this6$currentSite2;\n        throw new CoreError(_this6.isLoggedIn() ? Translate.instant('core.siteunavailablehelp', {\n          site: (_this6$currentSite2 = _this6.currentSite) === null || _this6$currentSite2 === void 0 ? void 0 : _this6$currentSite2.siteUrl\n        }) : Translate.instant('core.sitenotfoundhelp'));\n      }\n      if (data.token !== undefined) {\n        return {\n          token: data.token,\n          siteUrl,\n          privateToken: data.privatetoken\n        };\n      }\n      if (data.error === undefined) {\n        throw new CoreError(Translate.instant('core.login.invalidaccount'));\n      }\n      // We only allow one retry (to avoid loops).\n      if (!retry && data.errorcode == 'requirecorrectaccess') {\n        siteUrl = CoreUrlUtils.addOrRemoveWWW(siteUrl);\n        return _this6.getUserToken(siteUrl, username, password, service, true);\n      }\n      if (data.errorcode == 'missingparam') {\n        // It seems the server didn't receive all required params, it could be due to a redirect.\n        const redirect = yield CoreUtils.checkRedirect(loginUrl);\n        if (redirect) {\n          throw _this6.createCannotConnectLoginError(siteUrl, {\n            supportConfig: yield CoreUserGuestSupportConfig.forSite(siteUrl),\n            errorcode: 'sitehasredirect',\n            errorDetails: Translate.instant('core.login.sitehasredirect')\n          });\n        }\n      }\n      throw _this6.createCannotConnectLoginError(siteUrl, {\n        supportConfig: yield CoreUserGuestSupportConfig.forSite(siteUrl),\n        errorcode: data.errorcode,\n        errorDetails: data.error\n      });\n    })();\n  }\n  /**\n   * Add a new site to the site list and authenticate the user in this site.\n   *\n   * @param siteUrl The site url.\n   * @param token User's token.\n   * @param privateToken User's private token.\n   * @param login Whether to login the user in the site. Defaults to true.\n   * @param oauthId OAuth ID. Only if the authentication was using an OAuth method.\n   * @returns A promise resolved with siteId when the site is added and the user is authenticated.\n   */\n  newSite(siteUrl, token, privateToken = '', login = true, oauthId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof login !== 'boolean') {\n        login = true;\n      }\n      // Validate the site.\n      const authSite = CoreSitesFactory.makeAuthenticatedSite(siteUrl, token, {\n        privateToken\n      });\n      let isNewSite = true;\n      try {\n        const info = yield authSite.fetchSiteInfo();\n        const result = _this7.isValidMoodleVersion(info);\n        if (result !== CoreSitesProvider.VALID_VERSION) {\n          return _this7.treatInvalidAppVersion(result);\n        }\n        const siteId = _this7.createSiteID(info.siteurl, info.username);\n        // Check if the site already exists.\n        const storedSite = yield CoreUtils.ignoreErrors(_this7.getSite(siteId));\n        let site;\n        if (storedSite) {\n          // Site already exists.\n          isNewSite = false;\n          site = storedSite;\n          site.setToken(token);\n          site.setPrivateToken(privateToken);\n          site.setInfo(info);\n          site.setOAuthId(oauthId);\n          site.setLoggedOut(false);\n        } else {\n          // New site, set site ID and info.\n          isNewSite = true;\n          site = CoreSitesFactory.makeSite(siteId, siteUrl, token, {\n            info,\n            privateToken\n          });\n          site.setOAuthId(oauthId);\n          // Create database tables before login and before any WS call.\n          yield _this7.migrateSiteSchemas(site);\n        }\n        // Try to get the site config.\n        let config;\n        try {\n          config = yield _this7.getSiteConfig(site);\n        } catch (error) {\n          // Ignore errors if it's not a new site, we'll use the config already stored.\n          if (isNewSite) {\n            throw error;\n          }\n        }\n        if (config !== undefined) {\n          site.setConfig(config);\n        }\n        // Add site to sites list.\n        yield _this7.addSite(siteId, siteUrl, token, info, privateToken, config, oauthId);\n        _this7.sites[siteId] = site;\n        if (login) {\n          _this7.currentSite = site;\n          // Store session.\n          yield _this7.login(siteId);\n        } else if (_this7.currentSite && _this7.currentSite.getId() == siteId) {\n          // Current site has just been updated, trigger the event.\n          CoreEvents.trigger(CoreEvents.SITE_UPDATED, info, siteId);\n        }\n        CoreEvents.trigger(CoreEvents.SITE_ADDED, info, siteId);\n        return siteId;\n      } catch (error) {\n        // Error invaliddevice is returned by Workplace server meaning the same as connecttoworkplaceapp.\n        if (error && error.errorcode == 'invaliddevice') {\n          return _this7.treatInvalidAppVersion(CoreSitesProvider.WORKPLACE_APP);\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Having the result of isValidMoodleVersion, it treats the error message to be shown.\n   *\n   * @param result Result returned by isValidMoodleVersion function.\n   * @param siteId If site is already added, it will invalidate the token.\n   * @returns A promise rejected with the error info.\n   */\n  treatInvalidAppVersion(result, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      let errorCode;\n      let errorKey;\n      let translateParams = {};\n      switch (result) {\n        case CoreSitesProvider.MOODLE_APP:\n          errorKey = 'core.login.connecttomoodleapp';\n          errorCode = 'connecttomoodleapp';\n          break;\n        case CoreSitesProvider.WORKPLACE_APP:\n          errorKey = 'core.login.connecttoworkplaceapp';\n          errorCode = 'connecttoworkplaceapp';\n          break;\n        default:\n          errorCode = 'invalidmoodleversion';\n          errorKey = 'core.login.invalidmoodleversion';\n          translateParams = {\n            $a: CoreSite.MINIMUM_MOODLE_VERSION\n          };\n      }\n      if (siteId) {\n        yield _this8.setSiteLoggedOut(siteId);\n      }\n      throw new CoreLoginError({\n        message: Translate.instant(errorKey, translateParams),\n        errorcode: errorCode,\n        loggedOut: true\n      });\n    })();\n  }\n  /**\n   * Create a site ID based on site URL and username.\n   *\n   * @param siteUrl The site url.\n   * @param username Username.\n   * @returns Site ID.\n   */\n  createSiteID(siteUrl, username) {\n    return Md5.hashAsciiStr(siteUrl + username);\n  }\n  /**\n   * Visit a site link.\n   *\n   * @param url URL to handle.\n   * @param options Behaviour options.\n   * @param options.siteId Site Id.\n   * @param options.username Username related with the URL. E.g. in 'http://myuser@m.com', url would be 'http://m.com' and\n   *                 the username 'myuser'. Don't use it if you don't want to filter by username.\n   * @param options.checkRoot Whether to check if the URL is the root URL of a site.\n   * @param options.openBrowserRoot Whether to open in browser if it's root URL and it belongs to current site.\n   */\n  visitLink(url, options = {}) {\n    return _asyncToGenerator(function* () {\n      const treated = yield CoreContentLinksHelper.handleLink(url, options.username, options.checkRoot, options.openBrowserRoot);\n      if (treated) {\n        return;\n      }\n      const site = options.siteId ? yield CoreSites.getSite(options.siteId) : CoreSites.getCurrentSite();\n      yield site === null || site === void 0 ? void 0 : site.openInBrowserWithAutoLogin(url);\n    })();\n  }\n  /**\n   * Check for the minimum required version.\n   *\n   * @param info Site info.\n   * @returns Either VALID_VERSION, WORKPLACE_APP, MOODLE_APP or INVALID_VERSION.\n   */\n  isValidMoodleVersion(info) {\n    if (!info) {\n      return CoreSitesProvider.INVALID_VERSION;\n    }\n    // Try to validate by version.\n    if (info.version) {\n      const version = parseInt(info.version, 10);\n      if (!isNaN(version)) {\n        if (version >= CoreSite.MOODLE_RELEASES[CoreSite.MINIMUM_MOODLE_VERSION]) {\n          return this.validateWorkplaceVersion(info);\n        }\n      }\n    }\n    // We couldn't validate by version number. Let's try to validate by release number.\n    const release = this.getReleaseNumber(info.release || '');\n    if (release) {\n      if (release >= CoreSite.MINIMUM_MOODLE_VERSION) {\n        return this.validateWorkplaceVersion(info);\n      }\n    }\n    // Couldn't validate it.\n    return CoreSitesProvider.INVALID_VERSION;\n  }\n  /**\n   * Check if needs to be redirected to specific Workplace App or general Moodle App.\n   *\n   * @param info Site info.\n   * @returns Either VALID_VERSION, WORKPLACE_APP or MOODLE_APP.\n   */\n  validateWorkplaceVersion(info) {\n    const isWorkplace = !!info.functions && info.functions.some(func => func.name == 'tool_program_get_user_programs');\n    const isWPEnabled = this.isWorkplaceEnabled();\n    if (!isWPEnabled && isWorkplace) {\n      return CoreSitesProvider.WORKPLACE_APP;\n    }\n    if (isWPEnabled && !isWorkplace) {\n      return CoreSitesProvider.MOODLE_APP;\n    }\n    return CoreSitesProvider.VALID_VERSION;\n  }\n  /**\n   * Check if the app is workplace enabled.\n   *\n   * @returns If the app is workplace enabled.\n   */\n  isWorkplaceEnabled() {\n    return false;\n  }\n  /**\n   * Returns the release number from site release info.\n   *\n   * @param rawRelease Raw release info text.\n   * @returns Release number or empty.\n   */\n  getReleaseNumber(rawRelease) {\n    const matches = rawRelease.match(/^\\d+(\\.\\d+(\\.\\d+)?)?/);\n    if (matches) {\n      return matches[0];\n    }\n    return '';\n  }\n  /**\n   * Returns the major release number from site release info.\n   *\n   * @param rawRelease Raw release info text.\n   * @returns Major release number or empty.\n   */\n  getMajorReleaseNumber(rawRelease) {\n    const matches = rawRelease.match(/^\\d+(\\.\\d+)?/);\n    if (matches) {\n      return matches[0];\n    }\n    return '';\n  }\n  /**\n   * Saves a site in local DB.\n   *\n   * @param id Site ID.\n   * @param siteUrl Site URL.\n   * @param token User's token in the site.\n   * @param info Site's info.\n   * @param privateToken User's private token.\n   * @param config Site config (from tool_mobile_get_config).\n   * @param oauthId OAuth ID. Only if the authentication was using an OAuth method.\n   * @returns Promise resolved when done.\n   */\n  addSite(id, siteUrl, token, info, privateToken = '', config, oauthId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      const site = {\n        id,\n        siteUrl,\n        token: '',\n        info: info ? JSON.stringify(info) : undefined,\n        privateToken: '',\n        config: config ? JSON.stringify(config) : undefined,\n        loggedOut: 0,\n        oauthId\n      };\n      promises.push(_this9.sitesTable.insert(site));\n      promises.push(_this9.storeTokensInSecureStorage(id, token, privateToken));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Check the app for a site and show a download dialogs if necessary.\n   *\n   * @param config Config object of the site.\n   */\n  checkApplication(config) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      yield _this10.checkRequiredMinimumVersion(config);\n    })();\n  }\n  /**\n   * Check the required minimum version of the app for a site and shows a download dialog.\n   *\n   * @param config Config object of the site.\n   * @returns Resolved with if meets the requirements, rejected otherwise.\n   */\n  checkRequiredMinimumVersion(config) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (!config || !config.tool_mobile_minimumversion) {\n        return;\n      }\n      const requiredVersion = _this11.convertVersionName(config.tool_mobile_minimumversion);\n      const appVersion = _this11.convertVersionName(CoreConstants.CONFIG.versionname);\n      if (requiredVersion > appVersion) {\n        const storesConfig = {\n          android: config.tool_mobile_androidappid,\n          ios: config.tool_mobile_iosappid,\n          mobile: config.tool_mobile_setuplink || 'https://download.moodle.org/mobile/',\n          default: config.tool_mobile_setuplink\n        };\n        const siteId = _this11.getCurrentSiteId();\n        const downloadUrl = CoreApp.getAppStoreUrl(storesConfig);\n        let promise;\n        if (downloadUrl != null) {\n          // Do not block interface.\n          promise = CoreDomUtils.showConfirm(Translate.instant('core.updaterequireddesc', {\n            $a: config.tool_mobile_minimumversion\n          }), Translate.instant('core.updaterequired'), Translate.instant('core.download'), Translate.instant(siteId ? 'core.mainmenu.logout' : 'core.cancel')).then(() => CoreUtils.openInBrowser(downloadUrl, {\n            showBrowserWarning: false\n          })).catch(() => {\n            // Do nothing.\n          });\n        } else {\n          // Do not block interface.\n          promise = CoreDomUtils.showAlert(Translate.instant('core.updaterequired'), Translate.instant('core.updaterequireddesc', {\n            $a: config.tool_mobile_minimumversion\n          })).then(alert => alert.onWillDismiss());\n        }\n        promise.finally(() => {\n          if (siteId) {\n            // Logout the currentSite and expire the token.\n            _this11.logout();\n            _this11.setSiteLoggedOut(siteId);\n          }\n        });\n        throw new CoreError('Current app version is lower than required version.');\n      }\n    })();\n  }\n  /**\n   * Convert version name to numbers.\n   *\n   * @param name Version name (dot separated).\n   * @returns Version translated to a comparable number.\n   */\n  convertVersionName(name) {\n    let version = 0;\n    const parts = name.split('-')[0].split('.', 3);\n    parts.forEach(num => {\n      version = version * 100 + Number(num);\n    });\n    if (parts.length < 3) {\n      version = version * Math.pow(100, 3 - parts.length);\n    }\n    return version;\n  }\n  /**\n   * Login a user to a site from the list of sites.\n   *\n   * @param siteId ID of the site to load.\n   * @param redirectData Data of the path/url to open once authenticated if logged out. If not defined, site initial page.\n   * @returns Promise resolved with true if site is loaded, resolved with false if cannot login.\n   */\n  loadSite(siteId, redirectData) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      _this12.logger.debug(`Load site ${siteId}`);\n      const site = yield _this12.getSite(siteId);\n      const siteUrlAllowed = yield CoreLoginHelper.isSiteUrlAllowed(site.getURL(), false);\n      if (!siteUrlAllowed) {\n        throw new CoreErrorWithOptions(Translate.instant('core.login.sitenotallowed'));\n      }\n      _this12.currentSite = site;\n      if (site.isLoggedOut()) {\n        // Logged out, trigger session expired event and stop.\n        CoreEvents.trigger(CoreEvents.SESSION_EXPIRED, redirectData || {}, site.getId());\n        return false;\n      }\n      _this12.login(siteId);\n      // Get some data in background, don't block the UI.\n      _this12.getPublicConfigAndCheckApplication(site);\n      _this12.updateSiteInfo(siteId);\n      return true;\n    })();\n  }\n  /**\n   * Get site public config and check if app can access the site.\n   *\n   * @param site Site.\n   * @returns Promise resolved when done.\n   */\n  getPublicConfigAndCheckApplication(site) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const config = yield site.getPublicConfig({\n          readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */\n        });\n\n        yield _this13.checkApplication(config);\n      } catch (_unused2) {\n        // Ignore errors, maybe the user is offline.\n      }\n    })();\n  }\n  /**\n   * Get current site or undefined if none.\n   *\n   * @returns Current site or undefined if none.\n   */\n  getCurrentSite() {\n    return this.currentSite;\n  }\n  /**\n   * Get current site or fail if none.\n   *\n   * @returns Current site.\n   */\n  getRequiredCurrentSite() {\n    if (!this.currentSite) {\n      throw new CoreError('You aren\\'t authenticated in any site.');\n    }\n    return this.currentSite;\n  }\n  /**\n   * Get the site home ID of the current site.\n   *\n   * @returns Current site home ID.\n   */\n  getCurrentSiteHomeId() {\n    if (this.currentSite) {\n      return this.currentSite.getSiteHomeId();\n    } else {\n      return 1;\n    }\n  }\n  /**\n   * Get current site ID.\n   *\n   * @returns Current site ID.\n   */\n  getCurrentSiteId() {\n    if (this.currentSite) {\n      return this.currentSite.getId();\n    } else {\n      return '';\n    }\n  }\n  /**\n   * Get current site User ID.\n   *\n   * @returns Current site User ID.\n   */\n  getCurrentSiteUserId() {\n    var _this$currentSite2;\n    return ((_this$currentSite2 = this.currentSite) === null || _this$currentSite2 === void 0 ? void 0 : _this$currentSite2.getUserId()) || 0;\n  }\n  /**\n   * Check if the user is logged in a site.\n   *\n   * @returns Whether the user is logged in a site.\n   */\n  isLoggedIn() {\n    return this.currentSite !== undefined && this.currentSite.token !== undefined && this.currentSite.token != '';\n  }\n  /**\n   * Delete a site from the sites list.\n   *\n   * @param siteId ID of the site to delete.\n   * @returns Promise to be resolved when the site is deleted.\n   */\n  deleteSite(siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      var _CoreNative$plugin;\n      _this14.logger.debug(`Delete site ${siteId}`);\n      if (_this14.currentSite !== undefined && _this14.currentSite.id == siteId) {\n        _this14.logout();\n      }\n      const site = yield _this14.getSite(siteId);\n      yield site.deleteDB();\n      // Site DB deleted, now delete the app from the list of sites.\n      delete _this14.sites[siteId];\n      // DB remove shouldn't fail, but we'll go ahead even if it does.\n      yield CoreUtils.ignoreErrors(_this14.sitesTable.deleteByPrimaryKey({\n        id: siteId\n      }));\n      // Site deleted from sites list, now delete the folder.\n      yield site.deleteFolder();\n      yield CoreUtils.ignoreErrors((_CoreNative$plugin = CoreNative.plugin('secureStorage')) === null || _CoreNative$plugin === void 0 ? void 0 : _CoreNative$plugin.deleteCollection(siteId));\n      CoreEvents.trigger(CoreEvents.SITE_DELETED, site, siteId);\n    })();\n  }\n  /**\n   * Check if there are sites stored.\n   *\n   * @returns Promise resolved with true if there are sites and false if there aren't.\n   */\n  hasSites() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const isEmpty = yield _this15.sitesTable.isEmpty();\n      return !isEmpty;\n    })();\n  }\n  /**\n   * Returns a site object.\n   *\n   * @param siteId The site ID. If not defined, current site (if available).\n   * @returns Promise resolved with the site.\n   */\n  getSite(siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      if (!siteId) {\n        if (_this16.currentSite) {\n          return _this16.currentSite;\n        }\n        throw new CoreError('No current site found.');\n      }\n      if (_this16.currentSite && _this16.currentSite.getId() === siteId) {\n        return _this16.currentSite;\n      }\n      if (_this16.sites[siteId] !== undefined) {\n        return _this16.sites[siteId];\n      }\n      // Retrieve and create the site.\n      let record;\n      try {\n        record = yield _this16.loadSiteTokens(yield _this16.sitesTable.getOneByPrimaryKey({\n          id: siteId\n        }));\n      } catch (_unused3) {\n        throw new CoreError('SiteId not found.');\n      }\n      try {\n        return yield _this16.addSiteFromSiteListEntry(record);\n      } catch (_unused4) {\n        throw new CoreError('Site database installation or update failed.');\n      }\n    })();\n  }\n  /**\n   * Get a site directly from the database, without using any optimizations.\n   *\n   * @param siteId Site id.\n   * @returns Site.\n   */\n  getSiteFromDB(siteId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const db = CoreApp.getDB();\n      try {\n        const record = yield db.getRecord(SITES_TABLE_NAME, {\n          id: siteId\n        });\n        return _this17.makeSiteFromSiteListEntry(record);\n      } catch (_unused5) {\n        throw new CoreError('SiteId not found');\n      }\n    })();\n  }\n  /**\n   * Finds a site with a certain URL. It will return the first site found.\n   *\n   * @param siteUrl The site URL.\n   * @returns Promise resolved with the site.\n   */\n  getSiteByUrl(siteUrl) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const data = yield _this18.loadSiteTokens(yield _this18.sitesTable.getOne({\n        siteUrl\n      }));\n      return _this18.addSiteFromSiteListEntry(data);\n    })();\n  }\n  /**\n   * Gets the public type config for a site with the given url.\n   *\n   * @param siteUrl The site URL.\n   * @returns Promise resolved with public config or null.\n   */\n  getPublicSiteConfigByUrl(siteUrl) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield _this19.getSiteByUrl(siteUrl);\n      return site.getPublicConfig({\n        readingStrategy: 0 /* CoreSitesReadingStrategy.ONLY_CACHE */\n      });\n    })();\n  }\n  /**\n   * Create a site from an entry of the sites list DB. The new site is added to the list of \"cached\" sites: this.sites.\n   *\n   * @param entry Site list entry.\n   * @returns Promised resolved with the created site.\n   */\n  addSiteFromSiteListEntry(entry) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      if (_this20.sites[entry.id] !== undefined) {\n        return _this20.sites[entry.id];\n      }\n      // Parse info and config.\n      const site = _this20.makeSiteFromSiteListEntry(entry);\n      yield _this20.migrateSiteSchemas(site);\n      // Set site after migrating schemas, or a call to getSite could get the site while tables are being created.\n      _this20.sites[entry.id] = site;\n      return site;\n    })();\n  }\n  /**\n   * Make a site instance from a database entry.\n   *\n   * @param entry Site database entry.\n   * @returns Site.\n   */\n  makeSiteFromSiteListEntry(entry) {\n    const info = entry.info ? CoreTextUtils.parseJSON(entry.info) : undefined;\n    const config = entry.config ? CoreTextUtils.parseJSON(entry.config) : undefined;\n    const site = CoreSitesFactory.makeSite(entry.id, entry.siteUrl, entry.token, {\n      info,\n      privateToken: entry.privateToken,\n      config,\n      loggedOut: entry.loggedOut == 1\n    });\n    site.setOAuthId(entry.oauthId || undefined);\n    return site;\n  }\n  /**\n   * Returns if the site is the current one.\n   *\n   * @param site Site object or siteId to be compared. If not defined, use current site.\n   * @returns Whether site or siteId is the current one.\n   */\n  isCurrentSite(site) {\n    if (!site || !this.currentSite) {\n      return !!this.currentSite;\n    }\n    const siteId = typeof site == 'object' ? site.getId() : site;\n    return this.currentSite.getId() === siteId;\n  }\n  /**\n   * Returns the database object of a site.\n   *\n   * @param siteId The site ID. If not defined, current site (if available).\n   * @returns Promise resolved with the database.\n   */\n  getSiteDb(siteId) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield _this21.getSite(siteId);\n      return site.getDb();\n    })();\n  }\n  /**\n   * Returns the site home ID of a site.\n   *\n   * @param siteId The site ID. If not defined, current site (if available).\n   * @returns Promise resolved with site home ID.\n   */\n  getSiteHomeId(siteId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield _this22.getSite(siteId);\n      return site.getSiteHomeId();\n    })();\n  }\n  /**\n   * Get the list of sites stored.\n   *\n   * @param ids IDs of the sites to get. If not defined, return all sites.\n   * @returns Promise resolved when the sites are retrieved.\n   */\n  getSites(ids) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this23.sitesTable.getMany();\n      return _this23.siteDBRecordsToBasicInfo(sites, ids);\n    })();\n  }\n  /**\n   * Convert sites DB records to site basic info.\n   *\n   * @param sites DB records.\n   * @param ids IDs of sites to return, undefined to return them all.\n   * @returns Sites basic info.\n   */\n  siteDBRecordsToBasicInfo(sites, ids) {\n    return _asyncToGenerator(function* () {\n      const formattedSites = [];\n      yield Promise.all(sites.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (site) {\n          if (!ids || ids.indexOf(site.id) > -1) {\n            const siteInfo = site.info ? CoreTextUtils.parseJSON(site.info) : undefined;\n            const siteInstance = CoreSitesFactory.makeSite(site.id, site.siteUrl, site.token, {\n              info: siteInfo\n            });\n            const siteName = yield siteInstance.getSiteName();\n            const basicInfo = {\n              id: site.id,\n              userId: siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.userid,\n              siteUrl: site.siteUrl,\n              siteUrlWithoutProtocol: site.siteUrl.replace(/^https?:\\/\\//, '').toLowerCase(),\n              fullname: siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.fullname,\n              firstname: siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.firstname,\n              lastname: siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.lastname,\n              siteName,\n              userpictureurl: siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.userpictureurl,\n              siteHomeId: (siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.siteid) || 1,\n              loggedOut: !!site.loggedOut,\n              info: siteInfo\n            };\n            formattedSites.push(basicInfo);\n          }\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      return formattedSites;\n    })();\n  }\n  /**\n   * Get the list of sites stored, sorted by sitename, URL and fullname.\n   *\n   * @param ids IDs of the sites to get. If not defined, return all sites.\n   * @returns Promise resolved when the sites are retrieved.\n   */\n  getSortedSites(ids) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this24.getSites(ids);\n      // Sort sites by site name, url and then fullname.\n      sites.sort((a, b) => {\n        var _a$fullname, _b$fullname;\n        // First compare by site name.\n        let textA = CoreTextUtils.cleanTags(a.siteName).toLowerCase().trim();\n        let textB = CoreTextUtils.cleanTags(b.siteName).toLowerCase().trim();\n        let compare = textA.localeCompare(textB);\n        if (compare !== 0) {\n          return compare;\n        }\n        // If site name is the same, use site url without the protocol.\n        compare = a.siteUrlWithoutProtocol.localeCompare(b.siteUrlWithoutProtocol);\n        if (compare !== 0) {\n          return compare;\n        }\n        // Finally use fullname.\n        textA = ((_a$fullname = a.fullname) === null || _a$fullname === void 0 ? void 0 : _a$fullname.toLowerCase().trim()) || '';\n        textB = ((_b$fullname = b.fullname) === null || _b$fullname === void 0 ? void 0 : _b$fullname.toLowerCase().trim()) || '';\n        return textA.localeCompare(textB);\n      });\n      return sites;\n    })();\n  }\n  /**\n   * Get the list of IDs of sites stored and not logged out.\n   *\n   * @returns Promise resolved when the sites IDs are retrieved.\n   */\n  getLoggedInSitesIds() {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this25.sitesTable.getMany({\n        loggedOut: 0\n      });\n      return sites.map(site => site.id);\n    })();\n  }\n  /**\n   * Get the list of IDs of sites stored.\n   *\n   * @returns Promise resolved when the sites IDs are retrieved.\n   */\n  getSitesIds() {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this26.sitesTable.getMany();\n      return sites.map(site => site.id);\n    })();\n  }\n  /**\n   * Get instances of all stored sites.\n   *\n   * @returns Promise resolved when the sites are retrieved.\n   */\n  getSitesInstances() {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const siteIds = yield _this27.getSitesIds();\n      return Promise.all(siteIds.map(siteId => _this27.getSite(siteId)));\n    })();\n  }\n  /**\n   * Login the user in a site.\n   *\n   * @param siteId ID of the site the user is accessing.\n   * @returns Promise resolved when current site is stored.\n   */\n  login(siteId) {\n    return _asyncToGenerator(function* () {\n      yield CoreConfig.set(CORE_SITE_CURRENT_SITE_ID_CONFIG, siteId);\n      CoreEvents.trigger(CoreEvents.LOGIN, {}, siteId);\n    })();\n  }\n  /**\n   * Logout the user.\n   *\n   * @param options Logout options.\n   * @returns Promise resolved when the user is logged out.\n   */\n  logout(options = {}) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this28.currentSite) {\n        return;\n      }\n      const promises = [];\n      const siteConfig = _this28.currentSite.getStoredConfig();\n      const siteId = _this28.currentSite.getId();\n      _this28.currentSite = undefined;\n      if (options.forceLogout || siteConfig && siteConfig.tool_mobile_forcelogout == '1') {\n        promises.push(_this28.setSiteLoggedOut(siteId));\n      }\n      promises.push(_this28.removeStoredCurrentSite());\n      yield CoreUtils.ignoreErrors(Promise.all(promises));\n      if (options.removeAccount) {\n        yield CoreSites.deleteSite(siteId);\n      }\n      CoreEvents.trigger(CoreEvents.LOGOUT, {}, siteId);\n    })();\n  }\n  /**\n   * Logout the user if authenticated to open a page/url in another site.\n   *\n   * @param siteId Site that will be opened after logout.\n   * @param redirectData Page/url to open after logout.\n   * @returns Promise resolved with boolean: true if app will be reloaded after logout.\n   */\n  logoutForRedirect(siteId, redirectData) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this29.currentSite) {\n        return false;\n      }\n      if (CoreSitePlugins.hasSitePluginsLoaded) {\n        // The site has site plugins so the app will be restarted. Store the data and logout.\n        CoreApp.storeRedirect(siteId, redirectData);\n      }\n      yield _this29.logout();\n      return CoreSitePlugins.hasSitePluginsLoaded;\n    })();\n  }\n  /**\n   * Restores the session to the previous one so the user doesn't has to login everytime the app is started.\n   *\n   * @returns Promise resolved if a session is restored.\n   */\n  restoreSession() {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      yield _this30.handleAutoLogout();\n      if (_this30.sessionRestored) {\n        return Promise.reject(new CoreError('Session already restored.'));\n      }\n      _this30.sessionRestored = true;\n      try {\n        const siteId = yield _this30.getStoredCurrentSiteId();\n        _this30.logger.debug(`Restore session in site ${siteId}`);\n        yield _this30.loadSite(siteId);\n      } catch (_unused6) {\n        // No current session.\n      }\n    })();\n  }\n  /**\n   * Handle auto logout by checking autologout type and time if its required.\n   */\n  handleAutoLogout() {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreUtils.ignoreErrors(_asyncToGenerator(function* () {\n        const siteId = yield _this31.getStoredCurrentSiteId();\n        const site = yield _this31.getSite(siteId);\n        const autoLogoutType = Number(site.getStoredConfig('tool_mobile_autologout'));\n        const autoLogoutTime = Number(site.getStoredConfig('tool_mobile_autologouttime'));\n        if (!autoLogoutType || autoLogoutType === CoreAutoLogoutType.NEVER || !site.id) {\n          return;\n        }\n        if (autoLogoutType === CoreAutoLogoutType.CUSTOM) {\n          yield CoreAutoLogout.handleSessionClosed(autoLogoutTime, site);\n          return;\n        }\n        yield CoreAutoLogout.handleAppClosed(site);\n      })());\n    })();\n  }\n  /**\n   * Mark a site as logged out so the user needs to authenticate again.\n   *\n   * @param siteId ID of the site.\n   * @param isLoggedOut True if logged out and needs to authenticate again, false otherwise.\n   * @returns Promise resolved when done.\n   */\n  setSiteLoggedOut(siteId, isLoggedOut = true) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield _this32.getSite(siteId);\n      site.setLoggedOut(isLoggedOut);\n      yield _this32.sitesTable.update({\n        loggedOut: isLoggedOut ? 1 : 0\n      }, {\n        id: siteId\n      });\n    })();\n  }\n  /**\n   * Unset current site.\n   */\n  unsetCurrentSite() {\n    this.currentSite = undefined;\n  }\n  /**\n   * Updates a site's token.\n   *\n   * @param siteUrl Site's URL.\n   * @param username Username.\n   * @param token User's new token.\n   * @param privateToken User's private token.\n   * @returns A promise resolved when the site is updated.\n   */\n  updateSiteToken(siteUrl, username, token, privateToken = '') {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      const siteId = _this33.createSiteID(siteUrl, username);\n      yield _this33.updateSiteTokenBySiteId(siteId, token, privateToken);\n      yield _this33.login(siteId);\n    })();\n  }\n  /**\n   * Updates a site's token using siteId.\n   *\n   * @param siteId Site Id.\n   * @param token User's new token.\n   * @param privateToken User's private token.\n   * @returns A promise resolved when the site is updated.\n   */\n  updateSiteTokenBySiteId(siteId, token, privateToken = '') {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield _this34.getSite(siteId);\n      site.token = token;\n      site.privateToken = privateToken;\n      site.setLoggedOut(false); // Token updated means the user authenticated again, not logged out anymore.\n      const promises = [];\n      const newData = {\n        token: '',\n        privateToken: '',\n        loggedOut: 0\n      };\n      promises.push(_this34.sitesTable.update(newData, {\n        id: siteId\n      }));\n      promises.push(_this34.storeTokensInSecureStorage(siteId, token, privateToken));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Updates a site's info.\n   *\n   * @param siteId Site's ID.\n   * @returns A promise resolved when the site is updated.\n   */\n  updateSiteInfo(siteId) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield _this35.getSite(siteId);\n      try {\n        const info = yield site.fetchSiteInfo();\n        site.setInfo(info);\n        const versionCheck = _this35.isValidMoodleVersion(info);\n        if (versionCheck != CoreSitesProvider.VALID_VERSION) {\n          // The Moodle version is not supported, reject.\n          return _this35.treatInvalidAppVersion(versionCheck, site.getId());\n        }\n        // Try to get the site config.\n        let config;\n        try {\n          config = yield _this35.getSiteConfig(site);\n        } catch (_unused7) {\n          // Error getting config, keep the current one.\n        }\n        const newValues = {\n          info: JSON.stringify(info),\n          loggedOut: site.isLoggedOut() ? 1 : 0\n        };\n        if (config !== undefined) {\n          site.setConfig(config);\n          newValues.config = JSON.stringify(config);\n        }\n        try {\n          yield _this35.sitesTable.update(newValues, {\n            id: siteId\n          });\n        } finally {\n          CoreEvents.trigger(CoreEvents.SITE_UPDATED, info, siteId);\n        }\n      } catch (_unused8) {\n        // Ignore that we cannot fetch site info. Probably the auth token is invalid.\n      }\n    })();\n  }\n  /**\n   * Updates a site's info.\n   *\n   * @param siteUrl Site's URL.\n   * @param username Username.\n   * @returns A promise to be resolved when the site is updated.\n   */\n  updateSiteInfoByUrl(siteUrl, username) {\n    const siteId = this.createSiteID(siteUrl, username);\n    return this.updateSiteInfo(siteId);\n  }\n  /**\n   * Get the site IDs a URL belongs to.\n   * Someone can have more than one account in the same site, that's why this function returns an array of IDs.\n   *\n   * @param url URL to check.\n   * @param prioritize True if it should prioritize current site. If the URL belongs to current site then it won't\n   *                   check any other site, it will only return current site.\n   * @param username If set, it will return only the sites where the current user has this username.\n   * @returns Promise resolved with the site IDs (array).\n   */\n  getSiteIdsFromUrl(url, prioritize, username) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      // If prioritize is true, check current site first.\n      if (prioritize && _this36.currentSite && _this36.currentSite.containsUrl(url)) {\n        var _this36$currentSite;\n        if (!username || ((_this36$currentSite = _this36.currentSite) === null || _this36$currentSite === void 0 || (_this36$currentSite = _this36$currentSite.getInfo()) === null || _this36$currentSite === void 0 ? void 0 : _this36$currentSite.username) === username) {\n          return [_this36.currentSite.getId()];\n        }\n      }\n      // Check if URL has http(s) protocol.\n      if (!url.match(/^https?:\\/\\//i)) {\n        // URL doesn't have http(s) protocol. Check if it has any protocol.\n        if (CoreUrlUtils.isAbsoluteURL(url)) {\n          // It has some protocol. Return empty array.\n          return [];\n        }\n        // No protocol, probably a relative URL. Return current site.\n        if (_this36.currentSite) {\n          return [_this36.currentSite.getId()];\n        }\n        return [];\n      }\n      try {\n        const siteEntries = yield _this36.sitesTable.getMany();\n        const ids = [];\n        yield Promise.all(siteEntries.map( /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (site) {\n            site = yield _this36.loadSiteTokens(site);\n            yield _this36.addSiteFromSiteListEntry(site);\n            if (_this36.sites[site.id].containsUrl(url)) {\n              var _this36$sites$site$id;\n              if (!username || ((_this36$sites$site$id = _this36.sites[site.id].getInfo()) === null || _this36$sites$site$id === void 0 ? void 0 : _this36$sites$site$id.username) === username) {\n                ids.push(site.id);\n              }\n            }\n          });\n          return function (_x3) {\n            return _ref4.apply(this, arguments);\n          };\n        }()));\n        return ids;\n      } catch (_unused9) {\n        // Shouldn't happen.\n        return [];\n      }\n    })();\n  }\n  /**\n   * Get the site ID stored in DB as current site.\n   *\n   * @returns Promise resolved with the site ID.\n   */\n  getStoredCurrentSiteId() {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      yield _this37.migrateCurrentSiteLegacyTable();\n      return CoreConfig.get(CORE_SITE_CURRENT_SITE_ID_CONFIG);\n    })();\n  }\n  /**\n   * Remove current site stored in DB.\n   *\n   * @returns Promise resolved when done.\n   */\n  removeStoredCurrentSite() {\n    return _asyncToGenerator(function* () {\n      yield CoreConfig.delete(CORE_SITE_CURRENT_SITE_ID_CONFIG);\n    })();\n  }\n  /**\n   * Get the public config of a certain site.\n   *\n   * @param siteUrl URL of the site.\n   * @returns Promise resolved with the public config.\n   */\n  getSitePublicConfig(siteUrl) {\n    const temporarySite = CoreSitesFactory.makeUnauthenticatedSite(siteUrl);\n    return temporarySite.getPublicConfig();\n  }\n  /**\n   * Get site config.\n   *\n   * @param site The site to get the config.\n   * @returns Promise resolved with config if available.\n   */\n  getSiteConfig(site) {\n    return _asyncToGenerator(function* () {\n      return site.getConfig(undefined, true);\n    })();\n  }\n  /**\n   * Check if a certain feature is disabled in a site.\n   *\n   * @param name Name of the feature to check.\n   * @param siteId The site ID. If not defined, current site (if available).\n   * @returns Promise resolved with true if disabled.\n   */\n  isFeatureDisabled(name, siteId) {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield _this38.getSite(siteId);\n      return site.isFeatureDisabled(name);\n    })();\n  }\n  /**\n   * Check if a WS is available in the current site, if any.\n   *\n   * @param method WS name.\n   * @returns Whether the WS is available.\n   */\n  wsAvailableInCurrentSite(method) {\n    const site = this.getCurrentSite();\n    return site ? site.wsAvailable(method) : false;\n  }\n  /**\n   * Register a site schema in current site.\n   * This function is meant for site plugins to create DB tables in current site. Tables created from within the app\n   * should use the registerCoreSiteSchema method instead.\n   *\n   * @param schema The schema to register.\n   * @returns Promise resolved when done.\n   */\n  registerSiteSchema(schema) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this39.currentSite) {\n        return;\n      }\n      try {\n        // Site has already been created, apply the schema directly.\n        const schemas = {};\n        schemas[schema.name] = schema;\n        // Apply it to the specified site only.\n        schema.siteId = _this39.currentSite.getId();\n        yield _this39.applySiteSchemas(_this39.currentSite, schemas);\n      } finally {\n        _this39.pluginsSiteSchemas[schema.name] = schema;\n      }\n    })();\n  }\n  /**\n   * Install and upgrade all the registered schemas and tables.\n   *\n   * @param site Site.\n   * @returns Promise resolved when done.\n   */\n  migrateSiteSchemas(site) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      if (!site.id) {\n        return;\n      }\n      const siteId = site.id;\n      if (_this40.siteSchemasMigration[siteId] !== undefined) {\n        return _this40.siteSchemasMigration[siteId];\n      }\n      _this40.logger.debug(`Migrating all schemas of ${siteId}`);\n      // First create tables not registerd with name/version.\n      const promise = site.getDb().createTableFromSchema(SCHEMA_VERSIONS_TABLE_SCHEMA).then(() => _this40.applySiteSchemas(site, _this40.siteSchemas));\n      _this40.siteSchemasMigration[siteId] = promise;\n      return promise.finally(() => {\n        delete _this40.siteSchemasMigration[siteId];\n      });\n    })();\n  }\n  /**\n   * Install and upgrade the supplied schemas for a certain site.\n   *\n   * @param site Site.\n   * @param schemas Schemas to migrate.\n   * @returns Promise resolved when done.\n   */\n  applySiteSchemas(site, schemas) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      // Fetch installed versions of the schema.\n      const records = yield _this41.getSiteSchemasTable(site).getMany();\n      const versions = {};\n      records.forEach(record => {\n        versions[record.name] = record.version;\n      });\n      const promises = [];\n      for (const name in schemas) {\n        const schema = schemas[name];\n        const oldVersion = versions[name] || 0;\n        if (oldVersion >= schema.version || schema.siteId && site.getId() != schema.siteId) {\n          // Version already applied or the schema shouldn't be registered to this site.\n          continue;\n        }\n        _this41.logger.debug(`Migrating schema '${name}' of ${site.id} from version ${oldVersion} to ${schema.version}`);\n        promises.push(_this41.applySiteSchema(site, schema, oldVersion));\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Install and upgrade the supplied schema for a certain site.\n   *\n   * @param site Site.\n   * @param schema Schema to migrate.\n   * @param oldVersion Old version of the schema.\n   * @returns Promise resolved when done.\n   */\n  applySiteSchema(site, schema, oldVersion) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      if (!site.id) {\n        return;\n      }\n      const db = site.getDb();\n      if (schema.tables) {\n        yield db.createTablesFromSchema(schema.tables);\n      }\n      if (schema.install && oldVersion == 0) {\n        yield schema.install(db, site.id);\n      }\n      if (schema.migrate && oldVersion > 0) {\n        yield schema.migrate(db, oldVersion, site.id);\n      }\n      // Set installed version.\n      yield _this42.getSiteSchemasTable(site).insert({\n        name: schema.name,\n        version: schema.version\n      });\n    })();\n  }\n  /**\n   * Check if a URL is the root URL of any of the stored sites.\n   *\n   * @param url URL to check.\n   * @param username Username to check.\n   * @returns Promise resolved with site to use and the list of sites that have\n   *         the URL. Site will be undefined if it isn't the root URL of any stored site.\n   */\n  isStoredRootURL(url, username) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      // Check if the site is stored.\n      const siteIds = yield _this43.getSiteIdsFromUrl(url, true, username);\n      const result = {\n        siteIds\n      };\n      if (!siteIds.length) {\n        return result;\n      }\n      // If more than one site is returned it usually means there are different users stored. Use any of them.\n      const site = yield _this43.getSite(siteIds[0]);\n      const siteUrl = CoreText.removeEndingSlash(CoreUrlUtils.removeProtocolAndWWW(site.getURL()));\n      const treatedUrl = CoreText.removeEndingSlash(CoreUrlUtils.removeProtocolAndWWW(url));\n      if (siteUrl == treatedUrl) {\n        result.site = site;\n      }\n      return result;\n    })();\n  }\n  /**\n   * Returns the Site Schema names that can be cleared on space storage.\n   *\n   * @param site The site that will be cleared.\n   * @returns Name of the site schemas.\n   */\n  getSiteTableSchemasToClear(site) {\n    let reset = [];\n    const schemas = Object.values(this.siteSchemas).concat(Object.values(this.pluginsSiteSchemas));\n    schemas.forEach(schema => {\n      if (schema.canBeCleared && (!schema.siteId || site.getId() == schema.siteId)) {\n        reset = reset.concat(schema.canBeCleared);\n      }\n    });\n    return reset;\n  }\n  /**\n   * Returns presets for a given reading strategy.\n   *\n   * @param strategy Reading strategy.\n   * @returns PreSets options object.\n   */\n  getReadingStrategyPreSets(strategy) {\n    switch (strategy) {\n      case 1 /* CoreSitesReadingStrategy.PREFER_CACHE */:\n        return {\n          omitExpires: true\n        };\n      case 0 /* CoreSitesReadingStrategy.ONLY_CACHE */:\n        return {\n          omitExpires: true,\n          forceOffline: true\n        };\n      case 3 /* CoreSitesReadingStrategy.PREFER_NETWORK */:\n        return {\n          getFromCache: false\n        };\n      case 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */:\n        return {\n          getFromCache: false,\n          emergencyCache: false\n        };\n      case 4 /* CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE */:\n        return {\n          updateInBackground: true,\n          getFromCache: true,\n          saveToCache: true\n        };\n      default:\n        return {};\n    }\n  }\n  /**\n   * Returns site info found on the backend.\n   *\n   * @param search Searched text.\n   * @returns Site info list.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  findSites(search) {\n    return _asyncToGenerator(function* () {\n      return [];\n    })();\n  }\n  /**\n   * Check whether a site is using a default image or not.\n   *\n   * @param site Site info.\n   * @returns Whether the site is using a default image.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  hasDefaultImage(site) {\n    return false;\n  }\n  /**\n   * Migrate the legacy current_site table.\n   */\n  migrateCurrentSiteLegacyTable() {\n    return _asyncToGenerator(function* () {\n      if (yield CoreConfig.has('current_site_migrated')) {\n        // Already migrated.\n        return;\n      }\n      try {\n        const db = CoreApp.getDB();\n        const {\n          siteId\n        } = yield db.getRecord('current_site');\n        yield CoreConfig.set(CORE_SITE_CURRENT_SITE_ID_CONFIG, siteId);\n        yield CoreApp.deleteTableSchema('current_site');\n        yield db.dropTable('current_site');\n      } catch (_unused10) {\n        // There was no current site, silence the error.\n      } finally {\n        yield CoreConfig.set('current_site_migrated', 1);\n      }\n    })();\n  }\n  /**\n   * Get schemas table for the given site.\n   *\n   * @param site Site.\n   * @returns Scehmas Table.\n   */\n  getSiteSchemasTable(site) {\n    var _this$schemasTables$s;\n    const siteId = site.getId();\n    this.schemasTables[siteId] = (_this$schemasTables$s = this.schemasTables[siteId]) !== null && _this$schemasTables$s !== void 0 ? _this$schemasTables$s : asyncInstance(() => this.getSiteTable(SCHEMA_VERSIONS_TABLE_NAME, {\n      siteId: siteId,\n      database: site.getDb(),\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.Eager\n      },\n      primaryKeyColumns: ['name'],\n      onDestroy: () => delete this.schemasTables[siteId]\n    }));\n    return this.schemasTables[siteId];\n  }\n  /**\n   * Move all tokens stored in DB to a secure storage.\n   */\n  moveTokensToSecureStorage() {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this44.sitesTable.getMany();\n      yield Promise.all(sites.map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (site) {\n          if (!site.token && !site.privateToken) {\n            return; // Tokens are empty, no need to treat them.\n          }\n\n          try {\n            yield _this44.storeTokensInSecureStorage(site.id, site.token, site.privateToken);\n          } catch (_unused11) {\n            _this44.logger.error('Error storing tokens in secure storage for site ' + site.id);\n          }\n        });\n        return function (_x4) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n      // Remove tokens from DB even if they couldn't be stored in secure storage.\n      yield _this44.sitesTable.update({\n        token: '',\n        privateToken: ''\n      });\n    })();\n  }\n  /**\n   * Get tokens from secure storage.\n   *\n   * @param siteId Site ID.\n   * @returns Stored tokens.\n   */\n  getTokensFromSecureStorage(siteId) {\n    return _asyncToGenerator(function* () {\n      var _CoreNative$plugin2, _result$token, _result$privateToken;\n      const result = yield (_CoreNative$plugin2 = CoreNative.plugin('secureStorage')) === null || _CoreNative$plugin2 === void 0 ? void 0 : _CoreNative$plugin2.get(['token', 'privateToken'], siteId);\n      return {\n        token: (_result$token = result === null || result === void 0 ? void 0 : result.token) !== null && _result$token !== void 0 ? _result$token : '',\n        privateToken: (_result$privateToken = result === null || result === void 0 ? void 0 : result.privateToken) !== null && _result$privateToken !== void 0 ? _result$privateToken : undefined\n      };\n    })();\n  }\n  /**\n   * Store tokens in secure storage.\n   *\n   * @param siteId Site ID.\n   * @param token Site token.\n   * @param privateToken Site private token.\n   */\n  storeTokensInSecureStorage(siteId, token, privateToken) {\n    return _asyncToGenerator(function* () {\n      var _CoreNative$plugin3;\n      yield (_CoreNative$plugin3 = CoreNative.plugin('secureStorage')) === null || _CoreNative$plugin3 === void 0 ? void 0 : _CoreNative$plugin3.store({\n        token: token,\n        privateToken: privateToken !== null && privateToken !== void 0 ? privateToken : ''\n      }, siteId);\n    })();\n  }\n  /**\n   * Given a site, load its tokens if needed.\n   *\n   * @param site Site data.\n   * @returns Site with tokens loaded.\n   */\n  loadSiteTokens(site) {\n    var _this45 = this;\n    return _asyncToGenerator(function* () {\n      if (site.token) {\n        return site;\n      }\n      const tokens = yield _this45.getTokensFromSecureStorage(site.id);\n      return _objectSpread(_objectSpread({}, site), tokens);\n    })();\n  }\n  /**\n   * Invalidate all sites cache.\n   */\n  invalidateCaches() {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this46.getSites();\n      yield Promise.all(sites.map(site => CoreSitesFactory.makeSite(site.id, site.siteUrl, '')).map(site => site.invalidateCaches()));\n    })();\n  }\n}\n_class = CoreSitesProvider;\n// Constants to validate a site version.\n_class.WORKPLACE_APP = 3;\n_class.MOODLE_APP = 2;\n_class.VALID_VERSION = 1;\n_class.INVALID_VERSION = -1;\n_class.fac = function CoreSitesProvider_Factory(t) {\n  return new (t || _class)(i0.inject(CORE_SITE_SCHEMAS, 8));\n};\n_class.prov = /*@__PURE__*/i0.defineInjectable({\n  token: _class,\n  factory: _class.fac,\n  providedIn: 'root'\n});\nexport const CoreSites = makeSingleton(CoreSitesProvider);","map":{"version":3,"names":["InjectionToken","Md5","timeout","CoreApp","CoreEvents","CoreWS","CoreDomUtils","CoreTextUtils","CoreUrlUtils","CoreUtils","CoreConstants","CoreSite","CoreError","CoreLoginError","makeSingleton","Translate","Http","CoreLogger","APP_SCHEMA","SCHEMA_VERSIONS_TABLE_SCHEMA","SITES_TABLE_NAME","SCHEMA_VERSIONS_TABLE_NAME","CoreArray","CoreNetworkError","CoreSitesFactory","CoreText","CoreLoginHelper","CoreErrorWithOptions","CoreAjaxError","CoreSitePlugins","CorePromisedValue","CoreDatabaseCachingStrategy","CoreDatabaseTableProxy","asyncInstance","CoreConfig","CoreNetwork","CoreUserGuestSupportConfig","CoreLang","CoreNative","CoreContentLinksHelper","CoreAutoLogoutType","CoreAutoLogout","CoreCacheManager","firstValueFrom","CORE_SITE_SCHEMAS","CORE_SITE_CURRENT_SITE_ID_CONFIG","CoreSitesProvider","constructor","siteSchemas","sessionRestored","sites","siteSchemasMigration","pluginsSiteSchemas","siteTables","schemasTables","sitesTable","logger","getInstance","flatten","reduce","schema","name","initialize","_this","on","SITE_DELETED","_ref","_asyncToGenerator","siteId","Promise","all","Object","values","map","promisedTable","then","table","destroy","_x","apply","arguments","registerInvalidateListener","invalidateCaches","initializeDatabase","_this2","createTablesFromSchema","_unused","cachingStrategy","Eager","getDB","setInstance","getSiteTable","tableName","options","_this3","_options$siteId","getCurrentSiteId","_options$database","_options$config","database","getSiteDb","config","primaryKeyColumns","onDestroy","addListener","resolve","getDemoSiteData","demoSites","CONFIG","demo_sites","toLowerCase","undefined","checkSite","siteUrl","protocol","_this4","formatURL","isHttpURL","instant","isOnline","checkSiteWithProtocol","error","critical","secondError","getErrorMessageFromError","_this5","_config","replace","temporarySite","makeUnauthenticatedSite","getPublicConfig","treatedError","treatGetPublicConfigError","getURL","setURL","addOrRemoveWWW","treatedSecondError","enablewebservices","createCannotConnectLoginError","httpswwwroot","wwwroot","supportConfig","errorcode","errorDetails","enablemobilewebservice","maintenanceenabled","message","maintenancemessage","code","typeoflogin","service","wsservice","_this$currentSite","_objectSpread","isLoggedIn","site","currentSite","_error$errorDetails","title","redirect","checkRedirect","$a","MINIMUM_MOODLE_VERSION","getUserToken","username","password","retry","_this6","lang","getCurrentLanguage","params","loginUrl","data","post","pipe","getRequestTimeout","_this6$currentSite","_this6$currentSite2","token","privateToken","privatetoken","forSite","newSite","login","oauthId","_this7","authSite","makeAuthenticatedSite","isNewSite","info","fetchSiteInfo","result","isValidMoodleVersion","VALID_VERSION","treatInvalidAppVersion","createSiteID","siteurl","storedSite","ignoreErrors","getSite","setToken","setPrivateToken","setInfo","setOAuthId","setLoggedOut","makeSite","migrateSiteSchemas","getSiteConfig","setConfig","addSite","getId","trigger","SITE_UPDATED","SITE_ADDED","WORKPLACE_APP","_this8","errorCode","errorKey","translateParams","MOODLE_APP","setSiteLoggedOut","loggedOut","hashAsciiStr","visitLink","url","treated","handleLink","checkRoot","openBrowserRoot","CoreSites","getCurrentSite","openInBrowserWithAutoLogin","INVALID_VERSION","version","parseInt","isNaN","MOODLE_RELEASES","validateWorkplaceVersion","release","getReleaseNumber","isWorkplace","functions","some","func","isWPEnabled","isWorkplaceEnabled","rawRelease","matches","match","getMajorReleaseNumber","id","_this9","promises","JSON","stringify","push","insert","storeTokensInSecureStorage","checkApplication","_this10","checkRequiredMinimumVersion","_this11","tool_mobile_minimumversion","requiredVersion","convertVersionName","appVersion","versionname","storesConfig","android","tool_mobile_androidappid","ios","tool_mobile_iosappid","mobile","tool_mobile_setuplink","default","downloadUrl","getAppStoreUrl","promise","showConfirm","openInBrowser","showBrowserWarning","catch","showAlert","alert","onWillDismiss","finally","logout","parts","split","forEach","num","Number","length","Math","pow","loadSite","redirectData","_this12","debug","siteUrlAllowed","isSiteUrlAllowed","isLoggedOut","SESSION_EXPIRED","getPublicConfigAndCheckApplication","updateSiteInfo","_this13","readingStrategy","_unused2","getRequiredCurrentSite","getCurrentSiteHomeId","getSiteHomeId","getCurrentSiteUserId","_this$currentSite2","getUserId","deleteSite","_this14","_CoreNative$plugin","deleteDB","deleteByPrimaryKey","deleteFolder","plugin","deleteCollection","hasSites","_this15","isEmpty","_this16","record","loadSiteTokens","getOneByPrimaryKey","_unused3","addSiteFromSiteListEntry","_unused4","getSiteFromDB","_this17","db","getRecord","makeSiteFromSiteListEntry","_unused5","getSiteByUrl","_this18","getOne","getPublicSiteConfigByUrl","_this19","entry","_this20","parseJSON","isCurrentSite","_this21","getDb","_this22","getSites","ids","_this23","getMany","siteDBRecordsToBasicInfo","formattedSites","_ref2","indexOf","siteInfo","siteInstance","siteName","getSiteName","basicInfo","userId","userid","siteUrlWithoutProtocol","fullname","firstname","lastname","userpictureurl","siteHomeId","siteid","_x2","getSortedSites","_this24","sort","a","b","_a$fullname","_b$fullname","textA","cleanTags","trim","textB","compare","localeCompare","getLoggedInSitesIds","_this25","getSitesIds","_this26","getSitesInstances","_this27","siteIds","set","LOGIN","_this28","siteConfig","getStoredConfig","forceLogout","tool_mobile_forcelogout","removeStoredCurrentSite","removeAccount","LOGOUT","logoutForRedirect","_this29","hasSitePluginsLoaded","storeRedirect","restoreSession","_this30","handleAutoLogout","reject","getStoredCurrentSiteId","_unused6","_this31","autoLogoutType","autoLogoutTime","NEVER","CUSTOM","handleSessionClosed","handleAppClosed","_this32","update","unsetCurrentSite","updateSiteToken","_this33","updateSiteTokenBySiteId","_this34","newData","_this35","versionCheck","_unused7","newValues","_unused8","updateSiteInfoByUrl","getSiteIdsFromUrl","prioritize","_this36","containsUrl","_this36$currentSite","getInfo","isAbsoluteURL","siteEntries","_ref4","_this36$sites$site$id","_x3","_unused9","_this37","migrateCurrentSiteLegacyTable","get","delete","getSitePublicConfig","getConfig","isFeatureDisabled","_this38","wsAvailableInCurrentSite","method","wsAvailable","registerSiteSchema","_this39","schemas","applySiteSchemas","_this40","createTableFromSchema","_this41","records","getSiteSchemasTable","versions","oldVersion","applySiteSchema","_this42","tables","install","migrate","isStoredRootURL","_this43","removeEndingSlash","removeProtocolAndWWW","treatedUrl","getSiteTableSchemasToClear","reset","concat","canBeCleared","getReadingStrategyPreSets","strategy","omitExpires","forceOffline","getFromCache","emergencyCache","updateInBackground","saveToCache","findSites","search","hasDefaultImage","has","deleteTableSchema","dropTable","_unused10","_this$schemasTables$s","moveTokensToSecureStorage","_this44","_ref5","_unused11","_x4","getTokensFromSecureStorage","_CoreNative$plugin2","_result$token","_result$privateToken","_CoreNative$plugin3","store","_this45","tokens","_this46","_class","i0","inject","factory","fac","providedIn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/sites.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { Md5 } from 'ts-md5/dist/md5';\nimport { timeout } from 'rxjs/operators';\n\nimport { CoreApp, CoreStoreConfig } from '@services/app';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport {\n    CoreSite,\n    CoreSiteConfig,\n} from '@classes/sites/site';\nimport { SQLiteDB, SQLiteDBRecordValues, SQLiteDBTableSchema } from '@classes/sqlitedb';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreLoginError, CoreLoginErrorOptions } from '@classes/errors/loginerror';\nimport { makeSingleton, Translate, Http } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport {\n    APP_SCHEMA,\n    SCHEMA_VERSIONS_TABLE_SCHEMA,\n    SITES_TABLE_NAME,\n    SCHEMA_VERSIONS_TABLE_NAME,\n    SiteDBEntry,\n    SchemaVersionsDBEntry,\n} from '@services/database/sites';\nimport { CoreArray } from '../singletons/array';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreRedirectPayload } from './navigator';\nimport { CoreSitesFactory } from './sites-factory';\nimport { CoreText } from '@singletons/text';\nimport { CoreLoginHelper } from '@features/login/services/login-helper';\nimport { CoreErrorWithOptions } from '@classes/errors/errorwithoptions';\nimport { CoreAjaxError } from '@classes/errors/ajaxerror';\nimport { CoreAjaxWSError } from '@classes/errors/ajaxwserror';\nimport { CoreSitePlugins } from '@features/siteplugins/services/siteplugins';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CoreDatabaseConfiguration, CoreDatabaseTable } from '@classes/database/database-table';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport { asyncInstance, AsyncInstance } from '../utils/async-instance';\nimport { CoreConfig } from './config';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUserGuestSupportConfig } from '@features/user/classes/support/guest-support-config';\nimport { CoreLang, CoreLangFormat } from '@services/lang';\nimport { CoreNative } from '@features/native/services/native';\nimport { CoreContentLinksHelper } from '@features/contentlinks/services/contentlinks-helper';\nimport { CoreAutoLogoutType, CoreAutoLogout } from '@features/autologout/services/autologout';\nimport { CoreCacheManager } from '@services/cache-manager';\nimport { CoreSiteInfo, CoreSiteInfoResponse, CoreSitePublicConfigResponse } from '@classes/sites/unauthenticated-site';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\nimport { firstValueFrom } from 'rxjs';\n\nexport const CORE_SITE_SCHEMAS = new InjectionToken<CoreSiteSchema[]>('CORE_SITE_SCHEMAS');\nexport const CORE_SITE_CURRENT_SITE_ID_CONFIG = 'current_site_id';\n\n/*\n * Service to manage and interact with sites.\n * It allows creating tables in the databases of all sites. Each service or component should be responsible of creating\n * their own database tables calling the registerCoreSiteSchema method.\n*/\n@Injectable({ providedIn: 'root' })\nexport class CoreSitesProvider {\n\n    // Constants to validate a site version.\n    protected static readonly WORKPLACE_APP = 3;\n    protected static readonly MOODLE_APP = 2;\n    protected static readonly VALID_VERSION = 1;\n    protected static readonly INVALID_VERSION = -1;\n\n    protected logger: CoreLogger;\n    protected sessionRestored = false;\n    protected currentSite?: CoreSite;\n    protected sites: { [s: string]: CoreSite } = {};\n    protected siteSchemasMigration: { [siteId: string]: Promise<void> } = {};\n    protected siteSchemas: { [name: string]: CoreRegisteredSiteSchema } = {};\n    protected pluginsSiteSchemas: { [name: string]: CoreRegisteredSiteSchema } = {};\n    protected siteTables: Record<string, Record<string, CorePromisedValue<CoreDatabaseTable>>> = {};\n    protected schemasTables: Record<string, AsyncInstance<CoreDatabaseTable<SchemaVersionsDBEntry, 'name'>>> = {};\n    protected sitesTable = asyncInstance<CoreDatabaseTable<SiteDBEntry>>();\n\n    constructor(@Optional() @Inject(CORE_SITE_SCHEMAS) siteSchemas: CoreSiteSchema[][] | null) {\n        this.logger = CoreLogger.getInstance('CoreSitesProvider');\n        this.siteSchemas = CoreArray.flatten(siteSchemas ?? []).reduce(\n            (siteSchemas, schema) => {\n                siteSchemas[schema.name] = schema;\n\n                return siteSchemas;\n            },\n            this.siteSchemas,\n        );\n    }\n\n    /**\n     * Initialize.\n     */\n    initialize(): void {\n        CoreEvents.on(CoreEvents.SITE_DELETED, async ({ siteId }) => {\n            if (!siteId || !(siteId in this.siteTables)) {\n                return;\n            }\n\n            await Promise.all(\n                Object\n                    .values(this.siteTables[siteId])\n                    .map(promisedTable => promisedTable.then(table => table.destroy())),\n            );\n\n            delete this.siteTables[siteId];\n        });\n\n        CoreCacheManager.registerInvalidateListener(() => this.invalidateCaches());\n    }\n\n    /**\n     * Initialize database.\n     */\n    async initializeDatabase(): Promise<void> {\n        try {\n            await CoreApp.createTablesFromSchema(APP_SCHEMA);\n        } catch {\n            // Ignore errors.\n        }\n\n        const sitesTable = new CoreDatabaseTableProxy<SiteDBEntry>(\n            { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            CoreApp.getDB(),\n            SITES_TABLE_NAME,\n        );\n\n        await sitesTable.initialize();\n\n        this.sitesTable.setInstance(sitesTable);\n    }\n\n    /**\n     * Get site table.\n     *\n     * @param tableName Site table name.\n     * @param options Options to configure table initialization.\n     * @returns Site table.\n     */\n    async getSiteTable<\n        DBRecord extends SQLiteDBRecordValues,\n        PrimaryKeyColumn extends keyof DBRecord\n    >(\n        tableName: string,\n        options: Partial<{\n            siteId: string;\n            config: Partial<CoreDatabaseConfiguration>;\n            database: SQLiteDB;\n            primaryKeyColumns: PrimaryKeyColumn[];\n            onDestroy(): void;\n        }> = {},\n    ): Promise<CoreDatabaseTable<DBRecord, PrimaryKeyColumn>> {\n        const siteId = options.siteId ?? this.getCurrentSiteId();\n\n        if (!(siteId in this.siteTables)) {\n            this.siteTables[siteId] = {};\n        }\n\n        if (!(tableName in this.siteTables[siteId])) {\n            const promisedTable = this.siteTables[siteId][tableName] = new CorePromisedValue();\n            const database = options.database ?? await this.getSiteDb(siteId);\n            const table = new CoreDatabaseTableProxy<DBRecord, PrimaryKeyColumn>(\n                options.config ?? {},\n                database,\n                tableName,\n                options.primaryKeyColumns,\n            );\n\n            options.onDestroy && table.addListener({ onDestroy: options.onDestroy });\n\n            await table.initialize();\n\n            promisedTable.resolve(table as unknown as CoreDatabaseTable);\n        }\n\n        return this.siteTables[siteId][tableName] as unknown as Promise<CoreDatabaseTable<DBRecord, PrimaryKeyColumn>>;\n    }\n\n    /**\n     * Get the demo data for a certain \"name\" if it is a demo site.\n     *\n     * @param name Name of the site to check.\n     * @returns Site data if it's a demo site, undefined otherwise.\n     */\n    getDemoSiteData(name: string): CoreSitesDemoSiteData | undefined {\n        const demoSites = CoreConstants.CONFIG.demo_sites;\n        name = name.toLowerCase();\n\n        if (demoSites !== undefined && demoSites[name] !== undefined) {\n            return demoSites[name];\n        }\n    }\n\n    /**\n     * Check if a site is valid and if it has specifics settings for authentication (like force to log in using the browser).\n     * It will test both protocols if the first one fails: http and https.\n     *\n     * @param siteUrl URL of the site to check.\n     * @param protocol Protocol to use first.\n     * @returns A promise resolved when the site is checked.\n     */\n    async checkSite(siteUrl: string, protocol: string = 'https://'): Promise<CoreSiteCheckResponse> {\n        // The formatURL function adds the protocol if is missing.\n        siteUrl = CoreUrlUtils.formatURL(siteUrl);\n\n        if (!CoreUrlUtils.isHttpURL(siteUrl)) {\n            throw new CoreError(Translate.instant('core.login.invalidsite'));\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            throw new CoreNetworkError();\n        }\n\n        try {\n            return await this.checkSiteWithProtocol(siteUrl, protocol);\n        } catch (error) {\n            // Do not continue checking if a critical error happened.\n            if (error.critical) {\n                throw error;\n            }\n\n            // Retry with the other protocol.\n            protocol = protocol == 'https://' ? 'http://' : 'https://';\n\n            try {\n                return await this.checkSiteWithProtocol(siteUrl, protocol);\n            } catch (secondError) {\n                if (secondError.critical) {\n                    throw secondError;\n                }\n\n                // Site doesn't exist. Return the error message.\n                if (CoreTextUtils.getErrorMessageFromError(error)) {\n                    throw error;\n                } else if (CoreTextUtils.getErrorMessageFromError(secondError)) {\n                    throw secondError;\n                } else {\n                    throw new CoreError(Translate.instant('core.sitenotfoundhelp'));\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper function to check if a site is valid and if it has specifics settings for authentication.\n     *\n     * @param siteUrl URL of the site to check.\n     * @param protocol Protocol to use.\n     * @returns A promise resolved when the site is checked.\n     */\n    async checkSiteWithProtocol(siteUrl: string, protocol: string): Promise<CoreSiteCheckResponse> {\n        // Now, replace the siteUrl with the protocol.\n        siteUrl = siteUrl.replace(/^https?:\\/\\//i, protocol);\n\n        // Create a temporary site to fetch site info.\n        const temporarySite = CoreSitesFactory.makeUnauthenticatedSite(siteUrl);\n        let config: CoreSitePublicConfigResponse | undefined;\n\n        try {\n            config = await temporarySite.getPublicConfig();\n        } catch (error) {\n            const treatedError = await this.treatGetPublicConfigError(temporarySite.getURL(), error);\n            if (treatedError.critical) {\n                throw treatedError; // App received a WS error, stop.\n            }\n\n            // Try to add or remove 'www'.\n            temporarySite.setURL(CoreUrlUtils.addOrRemoveWWW(temporarySite.getURL()));\n\n            try {\n                config = await temporarySite.getPublicConfig();\n            } catch (secondError) {\n                const treatedSecondError = await this.treatGetPublicConfigError(temporarySite.getURL(), secondError);\n                if (treatedSecondError.critical) {\n                    throw treatedSecondError; // App received a WS error, stop.\n                }\n\n                // App didn't receive a WS response, probably cannot connect. Prioritize first error if it's valid.\n                if (CoreTextUtils.getErrorMessageFromError(error)) {\n                    throw error;\n                } else {\n                    throw secondError;\n                }\n            }\n        }\n\n        // Check that the user can authenticate.\n        if (!config.enablewebservices) {\n            throw this.createCannotConnectLoginError(config.httpswwwroot || config.wwwroot, {\n                supportConfig: new CoreUserGuestSupportConfig(temporarySite, config),\n                errorcode: 'webservicesnotenabled',\n                errorDetails: Translate.instant('core.login.webservicesnotenabled'),\n                critical: true,\n            });\n        }\n\n        if (!config.enablemobilewebservice) {\n            throw this.createCannotConnectLoginError(config.httpswwwroot || config.wwwroot, {\n                supportConfig: new CoreUserGuestSupportConfig(temporarySite, config),\n                errorcode: 'mobileservicesnotenabled',\n                errorDetails: Translate.instant('core.login.mobileservicesnotenabled'),\n                critical: true,\n            });\n        }\n\n        if (config.maintenanceenabled) {\n            let message = Translate.instant('core.sitemaintenance');\n            if (config.maintenancemessage) {\n                message += config.maintenancemessage;\n            }\n\n            throw new CoreLoginError({\n                message,\n                critical: true,\n            });\n        }\n\n        siteUrl = temporarySite.getURL();\n\n        return { siteUrl, code: config?.typeoflogin || 0, service: CoreConstants.CONFIG.wsservice, config };\n    }\n\n    /**\n     * Create an error to be thrown when it isn't possible to login to a site.\n     *\n     * @param siteUrl Site Url.\n     * @param options Error options.\n     * @returns Cannot connect error.\n     */\n    protected createCannotConnectLoginError(siteUrl: string | null, options?: Partial<CoreLoginErrorOptions>): CoreLoginError {\n        return new CoreLoginError({\n            ...options,\n            message: !this.isLoggedIn() && siteUrl === null\n                ? Translate.instant('core.sitenotfoundhelp')\n                : Translate.instant('core.siteunavailablehelp', { site: siteUrl ?? this.currentSite?.siteUrl }),\n        });\n    }\n\n    /**\n     * Treat an error returned by getPublicConfig in checkSiteWithProtocol. Converts the error to a CoreLoginError.\n     *\n     * @param siteUrl Site URL.\n     * @param error Error returned.\n     * @returns Promise resolved with the treated error.\n     */\n    protected async treatGetPublicConfigError(\n        siteUrl: string,\n        error: CoreError | CoreAjaxError | CoreAjaxWSError,\n    ): Promise<CoreLoginError> {\n        if (error instanceof CoreAjaxError || !('errorcode' in error)) {\n            // The WS didn't return data, probably cannot connect.\n            return new CoreLoginError({\n                title: Translate.instant('core.cannotconnect'),\n                message: Translate.instant('core.siteunavailablehelp', { site: siteUrl }),\n                errorcode: 'publicconfigfailed',\n                errorDetails: error.message || '',\n                critical: false, // Allow fallback to http if siteUrl uses https.\n            });\n        }\n\n        // Service supported but an error happened. Return error.\n        const options: CoreLoginErrorOptions = {\n            critical: true,\n            title: Translate.instant('core.cannotconnect'),\n            message: Translate.instant('core.siteunavailablehelp', { site: siteUrl }),\n            errorcode: error.errorcode,\n            supportConfig: error.supportConfig,\n            errorDetails: error.errorDetails ?? error.message,\n        };\n\n        if (error.errorcode === 'codingerror') {\n            // This could be caused by a redirect. Check if it's the case.\n            const redirect = await CoreUtils.checkRedirect(siteUrl);\n\n            options.message = Translate.instant('core.siteunavailablehelp', { site: siteUrl });\n\n            if (redirect) {\n                options.errorcode = 'sitehasredirect';\n                options.errorDetails = Translate.instant('core.login.sitehasredirect');\n                options.critical = false; // Keep checking fallback URLs.\n            }\n        } else if (error.errorcode === 'invalidrecord') {\n            // WebService not found, site not supported.\n            options.message = Translate.instant('core.siteunavailablehelp', { site: siteUrl });\n            options.errorcode = 'invalidmoodleversion';\n            options.errorDetails = Translate.instant('core.login.invalidmoodleversion', { $a: CoreSite.MINIMUM_MOODLE_VERSION });\n        } else if (error.errorcode === 'redirecterrordetected') {\n            options.critical = false; // Keep checking fallback URLs.\n        }\n\n        return new CoreLoginError(options);\n    }\n\n    /**\n     * Gets a user token from the server.\n     *\n     * @param siteUrl The site url.\n     * @param username User name.\n     * @param password Password.\n     * @param service Service to use. If not defined, it will be searched in memory.\n     * @param retry Whether we are retrying with a prefixed URL.\n     * @returns A promise resolved when the token is retrieved.\n     */\n    async getUserToken(\n        siteUrl: string,\n        username: string,\n        password: string,\n        service?: string,\n        retry?: boolean,\n    ): Promise<CoreSiteUserTokenResponse> {\n        if (!CoreNetwork.isOnline()) {\n            throw new CoreNetworkError();\n        }\n\n        service = service || CoreConstants.CONFIG.wsservice;\n        const lang = await CoreLang.getCurrentLanguage(CoreLangFormat.LMS);\n        const params = {\n            username,\n            password,\n            service,\n        };\n        const loginUrl = `${siteUrl}/login/token.php?lang=${lang}`;\n        let data: CoreSitesLoginTokenResponse;\n\n        try {\n            data = await firstValueFrom(Http.post(loginUrl, params).pipe(timeout(CoreWS.getRequestTimeout())));\n        } catch (error) {\n            throw new CoreError(\n                this.isLoggedIn()\n                    ? Translate.instant('core.siteunavailablehelp', { site: this.currentSite?.siteUrl })\n                    : Translate.instant('core.sitenotfoundhelp'),\n            );\n        }\n\n        if (data === undefined) {\n            throw new CoreError(\n                this.isLoggedIn()\n                    ? Translate.instant('core.siteunavailablehelp', { site: this.currentSite?.siteUrl })\n                    : Translate.instant('core.sitenotfoundhelp'),\n            );\n        }\n\n        if (data.token !== undefined) {\n            return { token: data.token, siteUrl, privateToken: data.privatetoken };\n        }\n\n        if (data.error === undefined) {\n            throw new CoreError(Translate.instant('core.login.invalidaccount'));\n        }\n\n        // We only allow one retry (to avoid loops).\n        if (!retry && data.errorcode == 'requirecorrectaccess') {\n            siteUrl = CoreUrlUtils.addOrRemoveWWW(siteUrl);\n\n            return this.getUserToken(siteUrl, username, password, service, true);\n        }\n\n        if (data.errorcode == 'missingparam') {\n            // It seems the server didn't receive all required params, it could be due to a redirect.\n            const redirect = await CoreUtils.checkRedirect(loginUrl);\n\n            if (redirect) {\n                throw this.createCannotConnectLoginError(siteUrl, {\n                    supportConfig: await CoreUserGuestSupportConfig.forSite(siteUrl),\n                    errorcode: 'sitehasredirect',\n                    errorDetails: Translate.instant('core.login.sitehasredirect'),\n                });\n            }\n        }\n\n        throw this.createCannotConnectLoginError(siteUrl, {\n            supportConfig: await CoreUserGuestSupportConfig.forSite(siteUrl),\n            errorcode: data.errorcode,\n            errorDetails: data.error,\n        });\n    }\n\n    /**\n     * Add a new site to the site list and authenticate the user in this site.\n     *\n     * @param siteUrl The site url.\n     * @param token User's token.\n     * @param privateToken User's private token.\n     * @param login Whether to login the user in the site. Defaults to true.\n     * @param oauthId OAuth ID. Only if the authentication was using an OAuth method.\n     * @returns A promise resolved with siteId when the site is added and the user is authenticated.\n     */\n    async newSite(\n        siteUrl: string,\n        token: string,\n        privateToken: string = '',\n        login: boolean = true,\n        oauthId?: number,\n    ): Promise<string> {\n        if (typeof login !== 'boolean') {\n            login = true;\n        }\n\n        // Validate the site.\n        const authSite = CoreSitesFactory.makeAuthenticatedSite(siteUrl, token, { privateToken });\n        let isNewSite = true;\n\n        try {\n            const info = await authSite.fetchSiteInfo();\n\n            const result = this.isValidMoodleVersion(info);\n            if (result !== CoreSitesProvider.VALID_VERSION) {\n                return this.treatInvalidAppVersion(result);\n            }\n\n            const siteId = this.createSiteID(info.siteurl, info.username);\n\n            // Check if the site already exists.\n            const storedSite = await CoreUtils.ignoreErrors(this.getSite(siteId));\n            let site: CoreSite;\n\n            if (storedSite) {\n                // Site already exists.\n                isNewSite = false;\n                site = storedSite;\n                site.setToken(token);\n                site.setPrivateToken(privateToken);\n                site.setInfo(info);\n                site.setOAuthId(oauthId);\n                site.setLoggedOut(false);\n            } else {\n                // New site, set site ID and info.\n                isNewSite = true;\n                site = CoreSitesFactory.makeSite(siteId, siteUrl, token, { info, privateToken });\n                site.setOAuthId(oauthId);\n\n                // Create database tables before login and before any WS call.\n                await this.migrateSiteSchemas(site);\n            }\n\n            // Try to get the site config.\n            let config: CoreSiteConfig | undefined;\n\n            try {\n                config = await this.getSiteConfig(site);\n            } catch (error) {\n                // Ignore errors if it's not a new site, we'll use the config already stored.\n                if (isNewSite) {\n                    throw error;\n                }\n            }\n\n            if (config !== undefined) {\n                site.setConfig(config);\n            }\n\n            // Add site to sites list.\n            await this.addSite(siteId, siteUrl, token, info, privateToken, config, oauthId);\n            this.sites[siteId] = site;\n\n            if (login) {\n                this.currentSite = site;\n                // Store session.\n                await this.login(siteId);\n            } else if (this.currentSite && this.currentSite.getId() == siteId) {\n                // Current site has just been updated, trigger the event.\n                CoreEvents.trigger(CoreEvents.SITE_UPDATED, info, siteId);\n            }\n\n            CoreEvents.trigger(CoreEvents.SITE_ADDED, info, siteId);\n\n            return siteId;\n        } catch (error) {\n            // Error invaliddevice is returned by Workplace server meaning the same as connecttoworkplaceapp.\n            if (error && error.errorcode == 'invaliddevice') {\n                return this.treatInvalidAppVersion(CoreSitesProvider.WORKPLACE_APP);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Having the result of isValidMoodleVersion, it treats the error message to be shown.\n     *\n     * @param result Result returned by isValidMoodleVersion function.\n     * @param siteId If site is already added, it will invalidate the token.\n     * @returns A promise rejected with the error info.\n     */\n    protected async treatInvalidAppVersion(result: number, siteId?: string): Promise<never> {\n        let errorCode: string | undefined;\n        let errorKey: string | undefined;\n        let translateParams = {};\n\n        switch (result) {\n            case CoreSitesProvider.MOODLE_APP:\n                errorKey = 'core.login.connecttomoodleapp';\n                errorCode = 'connecttomoodleapp';\n                break;\n            case CoreSitesProvider.WORKPLACE_APP:\n                errorKey = 'core.login.connecttoworkplaceapp';\n                errorCode = 'connecttoworkplaceapp';\n                break;\n            default:\n                errorCode = 'invalidmoodleversion';\n                errorKey = 'core.login.invalidmoodleversion';\n                translateParams = { $a: CoreSite.MINIMUM_MOODLE_VERSION };\n        }\n\n        if (siteId) {\n            await this.setSiteLoggedOut(siteId);\n        }\n\n        throw new CoreLoginError({\n            message: Translate.instant(errorKey, translateParams),\n            errorcode: errorCode,\n            loggedOut: true,\n        });\n    }\n\n    /**\n     * Create a site ID based on site URL and username.\n     *\n     * @param siteUrl The site url.\n     * @param username Username.\n     * @returns Site ID.\n     */\n    createSiteID(siteUrl: string, username: string): string {\n        return <string> Md5.hashAsciiStr(siteUrl + username);\n    }\n\n    /**\n     * Visit a site link.\n     *\n     * @param url URL to handle.\n     * @param options Behaviour options.\n     * @param options.siteId Site Id.\n     * @param options.username Username related with the URL. E.g. in 'http://myuser@m.com', url would be 'http://m.com' and\n     *                 the username 'myuser'. Don't use it if you don't want to filter by username.\n     * @param options.checkRoot Whether to check if the URL is the root URL of a site.\n     * @param options.openBrowserRoot Whether to open in browser if it's root URL and it belongs to current site.\n     */\n    async visitLink(\n        url: string,\n        options: {\n            siteId?: string;\n            username?: string;\n            checkRoot?: boolean;\n            openBrowserRoot?: boolean;\n        } = {},\n    ): Promise<void> {\n        const treated = await CoreContentLinksHelper.handleLink(url, options.username, options.checkRoot, options.openBrowserRoot);\n\n        if (treated) {\n            return;\n        }\n\n        const site = options.siteId\n            ? await CoreSites.getSite(options.siteId)\n            : CoreSites.getCurrentSite();\n\n        await site?.openInBrowserWithAutoLogin(url);\n    }\n\n    /**\n     * Check for the minimum required version.\n     *\n     * @param info Site info.\n     * @returns Either VALID_VERSION, WORKPLACE_APP, MOODLE_APP or INVALID_VERSION.\n     */\n    protected isValidMoodleVersion(info: CoreSiteInfoResponse): number {\n        if (!info) {\n            return CoreSitesProvider.INVALID_VERSION;\n        }\n\n        // Try to validate by version.\n        if (info.version) {\n            const version = parseInt(info.version, 10);\n            if (!isNaN(version)) {\n                if (version >= CoreSite.MOODLE_RELEASES[CoreSite.MINIMUM_MOODLE_VERSION]) {\n                    return this.validateWorkplaceVersion(info);\n                }\n            }\n        }\n\n        // We couldn't validate by version number. Let's try to validate by release number.\n        const release = this.getReleaseNumber(info.release || '');\n        if (release) {\n            if (release >= CoreSite.MINIMUM_MOODLE_VERSION) {\n                return this.validateWorkplaceVersion(info);\n            }\n        }\n\n        // Couldn't validate it.\n        return CoreSitesProvider.INVALID_VERSION;\n    }\n\n    /**\n     * Check if needs to be redirected to specific Workplace App or general Moodle App.\n     *\n     * @param info Site info.\n     * @returns Either VALID_VERSION, WORKPLACE_APP or MOODLE_APP.\n     */\n    protected validateWorkplaceVersion(info: CoreSiteInfoResponse): number {\n        const isWorkplace = !!info.functions && info.functions.some((func) => func.name == 'tool_program_get_user_programs');\n\n        const isWPEnabled = this.isWorkplaceEnabled();\n\n        if (!isWPEnabled && isWorkplace) {\n            return CoreSitesProvider.WORKPLACE_APP;\n        }\n\n        if (isWPEnabled && !isWorkplace) {\n            return CoreSitesProvider.MOODLE_APP;\n        }\n\n        return CoreSitesProvider.VALID_VERSION;\n    }\n\n    /**\n     * Check if the app is workplace enabled.\n     *\n     * @returns If the app is workplace enabled.\n     */\n    protected isWorkplaceEnabled(): boolean {\n        return false;\n    }\n\n    /**\n     * Returns the release number from site release info.\n     *\n     * @param rawRelease Raw release info text.\n     * @returns Release number or empty.\n     */\n    getReleaseNumber(rawRelease: string): string {\n        const matches = rawRelease.match(/^\\d+(\\.\\d+(\\.\\d+)?)?/);\n        if (matches) {\n            return matches[0];\n        }\n\n        return '';\n    }\n\n    /**\n     * Returns the major release number from site release info.\n     *\n     * @param rawRelease Raw release info text.\n     * @returns Major release number or empty.\n     */\n    getMajorReleaseNumber(rawRelease: string): string {\n        const matches = rawRelease.match(/^\\d+(\\.\\d+)?/);\n        if (matches) {\n            return matches[0];\n        }\n\n        return '';\n    }\n\n    /**\n     * Saves a site in local DB.\n     *\n     * @param id Site ID.\n     * @param siteUrl Site URL.\n     * @param token User's token in the site.\n     * @param info Site's info.\n     * @param privateToken User's private token.\n     * @param config Site config (from tool_mobile_get_config).\n     * @param oauthId OAuth ID. Only if the authentication was using an OAuth method.\n     * @returns Promise resolved when done.\n     */\n    async addSite(\n        id: string,\n        siteUrl: string,\n        token: string,\n        info: CoreSiteInfoResponse,\n        privateToken: string = '',\n        config?: CoreSiteConfig,\n        oauthId?: number,\n    ): Promise<void> {\n        const promises: Promise<unknown>[] = [];\n        const site: SiteDBEntry = {\n            id,\n            siteUrl,\n            token: '',\n            info: info ? JSON.stringify(info) : undefined,\n            privateToken: '',\n            config: config ? JSON.stringify(config) : undefined,\n            loggedOut: 0,\n            oauthId,\n        };\n\n        promises.push(this.sitesTable.insert(site));\n        promises.push(this.storeTokensInSecureStorage(id, token, privateToken));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Check the app for a site and show a download dialogs if necessary.\n     *\n     * @param config Config object of the site.\n     */\n    async checkApplication(config?: CoreSitePublicConfigResponse): Promise<void> {\n        await this.checkRequiredMinimumVersion(config);\n    }\n\n    /**\n     * Check the required minimum version of the app for a site and shows a download dialog.\n     *\n     * @param config Config object of the site.\n     * @returns Resolved with if meets the requirements, rejected otherwise.\n     */\n    protected async checkRequiredMinimumVersion(config?: CoreSitePublicConfigResponse): Promise<void> {\n        if (!config || !config.tool_mobile_minimumversion) {\n            return;\n        }\n\n        const requiredVersion = this.convertVersionName(config.tool_mobile_minimumversion);\n        const appVersion = this.convertVersionName(CoreConstants.CONFIG.versionname);\n\n        if (requiredVersion > appVersion) {\n            const storesConfig: CoreStoreConfig = {\n                android: config.tool_mobile_androidappid,\n                ios: config.tool_mobile_iosappid,\n                mobile: config.tool_mobile_setuplink || 'https://download.moodle.org/mobile/',\n                default: config.tool_mobile_setuplink,\n            };\n\n            const siteId = this.getCurrentSiteId();\n            const downloadUrl = CoreApp.getAppStoreUrl(storesConfig);\n            let promise: Promise<unknown>;\n\n            if (downloadUrl != null) {\n                // Do not block interface.\n                promise = CoreDomUtils.showConfirm(\n                    Translate.instant('core.updaterequireddesc', { $a: config.tool_mobile_minimumversion }),\n                    Translate.instant('core.updaterequired'),\n                    Translate.instant('core.download'),\n                    Translate.instant(siteId ? 'core.mainmenu.logout' : 'core.cancel'),\n                ).then(() => CoreUtils.openInBrowser(downloadUrl, { showBrowserWarning: false })).catch(() => {\n                    // Do nothing.\n                });\n            } else {\n                // Do not block interface.\n                promise = CoreDomUtils.showAlert(\n                    Translate.instant('core.updaterequired'),\n                    Translate.instant('core.updaterequireddesc', { $a: config.tool_mobile_minimumversion }),\n                ).then((alert) => alert.onWillDismiss());\n            }\n\n            promise.finally(() => {\n                if (siteId) {\n                    // Logout the currentSite and expire the token.\n                    this.logout();\n                    this.setSiteLoggedOut(siteId);\n                }\n            });\n\n            throw new CoreError('Current app version is lower than required version.');\n        }\n    }\n\n    /**\n     * Convert version name to numbers.\n     *\n     * @param name Version name (dot separated).\n     * @returns Version translated to a comparable number.\n     */\n    protected convertVersionName(name: string): number {\n        let version = 0;\n\n        const parts = name.split('-')[0].split('.', 3);\n        parts.forEach((num) => {\n            version = (version * 100) + Number(num);\n        });\n\n        if (parts.length < 3) {\n            version = version * Math.pow(100, 3 - parts.length);\n        }\n\n        return version;\n    }\n\n    /**\n     * Login a user to a site from the list of sites.\n     *\n     * @param siteId ID of the site to load.\n     * @param redirectData Data of the path/url to open once authenticated if logged out. If not defined, site initial page.\n     * @returns Promise resolved with true if site is loaded, resolved with false if cannot login.\n     */\n    async loadSite(siteId: string, redirectData?: CoreRedirectPayload): Promise<boolean> {\n        this.logger.debug(`Load site ${siteId}`);\n\n        const site = await this.getSite(siteId);\n\n        const siteUrlAllowed = await CoreLoginHelper.isSiteUrlAllowed(site.getURL(), false);\n        if (!siteUrlAllowed) {\n            throw new CoreErrorWithOptions(Translate.instant('core.login.sitenotallowed'));\n        }\n\n        this.currentSite = site;\n\n        if (site.isLoggedOut()) {\n            // Logged out, trigger session expired event and stop.\n            CoreEvents.trigger(CoreEvents.SESSION_EXPIRED, redirectData || {}, site.getId());\n\n            return false;\n        }\n\n        this.login(siteId);\n        // Get some data in background, don't block the UI.\n        this.getPublicConfigAndCheckApplication(site);\n        this.updateSiteInfo(siteId);\n\n        return true;\n    }\n\n    /**\n     * Get site public config and check if app can access the site.\n     *\n     * @param site Site.\n     * @returns Promise resolved when done.\n     */\n    protected async getPublicConfigAndCheckApplication(site: CoreSite): Promise<void> {\n        try {\n            const config = await site.getPublicConfig({\n                readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            });\n\n            await this.checkApplication(config);\n        } catch {\n            // Ignore errors, maybe the user is offline.\n        }\n    }\n\n    /**\n     * Get current site or undefined if none.\n     *\n     * @returns Current site or undefined if none.\n     */\n    getCurrentSite(): CoreSite | undefined {\n        return this.currentSite;\n    }\n\n    /**\n     * Get current site or fail if none.\n     *\n     * @returns Current site.\n     */\n    getRequiredCurrentSite(): CoreSite {\n        if (!this.currentSite) {\n            throw new CoreError('You aren\\'t authenticated in any site.');\n        }\n\n        return this.currentSite;\n    }\n\n    /**\n     * Get the site home ID of the current site.\n     *\n     * @returns Current site home ID.\n     */\n    getCurrentSiteHomeId(): number {\n        if (this.currentSite) {\n            return this.currentSite.getSiteHomeId();\n        } else {\n            return 1;\n        }\n    }\n\n    /**\n     * Get current site ID.\n     *\n     * @returns Current site ID.\n     */\n    getCurrentSiteId(): string {\n        if (this.currentSite) {\n            return this.currentSite.getId();\n        } else {\n            return '';\n        }\n    }\n\n    /**\n     * Get current site User ID.\n     *\n     * @returns Current site User ID.\n     */\n    getCurrentSiteUserId(): number {\n        return this.currentSite?.getUserId() || 0;\n    }\n\n    /**\n     * Check if the user is logged in a site.\n     *\n     * @returns Whether the user is logged in a site.\n     */\n    isLoggedIn(): boolean {\n        return this.currentSite !== undefined && this.currentSite.token !== undefined &&\n            this.currentSite.token != '';\n    }\n\n    /**\n     * Delete a site from the sites list.\n     *\n     * @param siteId ID of the site to delete.\n     * @returns Promise to be resolved when the site is deleted.\n     */\n    async deleteSite(siteId: string): Promise<void> {\n        this.logger.debug(`Delete site ${siteId}`);\n\n        if (this.currentSite !== undefined && this.currentSite.id == siteId) {\n            this.logout();\n        }\n\n        const site = await this.getSite(siteId);\n\n        await site.deleteDB();\n\n        // Site DB deleted, now delete the app from the list of sites.\n        delete this.sites[siteId];\n\n        // DB remove shouldn't fail, but we'll go ahead even if it does.\n        await CoreUtils.ignoreErrors(this.sitesTable.deleteByPrimaryKey({ id: siteId }));\n\n        // Site deleted from sites list, now delete the folder.\n        await site.deleteFolder();\n\n        await CoreUtils.ignoreErrors(CoreNative.plugin('secureStorage')?.deleteCollection(siteId));\n\n        CoreEvents.trigger(CoreEvents.SITE_DELETED, site, siteId);\n    }\n\n    /**\n     * Check if there are sites stored.\n     *\n     * @returns Promise resolved with true if there are sites and false if there aren't.\n     */\n    async hasSites(): Promise<boolean> {\n        const isEmpty = await this.sitesTable.isEmpty();\n\n        return !isEmpty;\n    }\n\n    /**\n     * Returns a site object.\n     *\n     * @param siteId The site ID. If not defined, current site (if available).\n     * @returns Promise resolved with the site.\n     */\n    async getSite(siteId?: string): Promise<CoreSite> {\n        if (!siteId) {\n            if (this.currentSite) {\n                return this.currentSite;\n            }\n\n            throw new CoreError('No current site found.');\n        }\n\n        if (this.currentSite && this.currentSite.getId() === siteId) {\n            return this.currentSite;\n        }\n\n        if (this.sites[siteId] !== undefined) {\n            return this.sites[siteId];\n        }\n\n        // Retrieve and create the site.\n        let record: SiteDBEntry;\n        try {\n            record = await this.loadSiteTokens(await this.sitesTable.getOneByPrimaryKey({ id: siteId }));\n        } catch {\n            throw new CoreError('SiteId not found.');\n        }\n\n        try {\n            return await this.addSiteFromSiteListEntry(record);\n        } catch {\n            throw new CoreError('Site database installation or update failed.');\n        }\n    }\n\n    /**\n     * Get a site directly from the database, without using any optimizations.\n     *\n     * @param siteId Site id.\n     * @returns Site.\n     */\n    async getSiteFromDB(siteId: string): Promise<CoreSite> {\n        const db = CoreApp.getDB();\n\n        try {\n            const record = await db.getRecord<SiteDBEntry>(SITES_TABLE_NAME, { id: siteId });\n\n            return this.makeSiteFromSiteListEntry(record);\n        } catch {\n            throw new CoreError('SiteId not found');\n        }\n    }\n\n    /**\n     * Finds a site with a certain URL. It will return the first site found.\n     *\n     * @param siteUrl The site URL.\n     * @returns Promise resolved with the site.\n     */\n    async getSiteByUrl(siteUrl: string): Promise<CoreSite> {\n        const data = await this.loadSiteTokens(await this.sitesTable.getOne({ siteUrl }));\n\n        return this.addSiteFromSiteListEntry(data);\n    }\n\n    /**\n     * Gets the public type config for a site with the given url.\n     *\n     * @param siteUrl The site URL.\n     * @returns Promise resolved with public config or null.\n     */\n    async getPublicSiteConfigByUrl(siteUrl: string): Promise<CoreSitePublicConfigResponse> {\n        const site = await this.getSiteByUrl(siteUrl);\n\n        return site.getPublicConfig({ readingStrategy: CoreSitesReadingStrategy.ONLY_CACHE });\n    }\n\n    /**\n     * Create a site from an entry of the sites list DB. The new site is added to the list of \"cached\" sites: this.sites.\n     *\n     * @param entry Site list entry.\n     * @returns Promised resolved with the created site.\n     */\n    async addSiteFromSiteListEntry(entry: SiteDBEntry): Promise<CoreSite> {\n        if (this.sites[entry.id] !== undefined) {\n            return this.sites[entry.id];\n        }\n\n        // Parse info and config.\n        const site = this.makeSiteFromSiteListEntry(entry);\n\n        await this.migrateSiteSchemas(site);\n\n        // Set site after migrating schemas, or a call to getSite could get the site while tables are being created.\n        this.sites[entry.id] = site;\n\n        return site;\n    }\n\n    /**\n     * Make a site instance from a database entry.\n     *\n     * @param entry Site database entry.\n     * @returns Site.\n     */\n    makeSiteFromSiteListEntry(entry: SiteDBEntry): CoreSite {\n        const info = entry.info ? CoreTextUtils.parseJSON<CoreSiteInfo>(entry.info) : undefined;\n        const config = entry.config ? CoreTextUtils.parseJSON<CoreSiteConfig>(entry.config) : undefined;\n\n        const site = CoreSitesFactory.makeSite(\n            entry.id,\n            entry.siteUrl,\n            entry.token,\n            {\n                info,\n                privateToken: entry.privateToken,\n                config,\n                loggedOut: entry.loggedOut == 1,\n            },\n        );\n        site.setOAuthId(entry.oauthId || undefined);\n\n        return site;\n    }\n\n    /**\n     * Returns if the site is the current one.\n     *\n     * @param site Site object or siteId to be compared. If not defined, use current site.\n     * @returns Whether site or siteId is the current one.\n     */\n    isCurrentSite(site?: string | CoreSite): boolean {\n        if (!site || !this.currentSite) {\n            return !!this.currentSite;\n        }\n\n        const siteId = typeof site == 'object' ? site.getId() : site;\n\n        return this.currentSite.getId() === siteId;\n    }\n\n    /**\n     * Returns the database object of a site.\n     *\n     * @param siteId The site ID. If not defined, current site (if available).\n     * @returns Promise resolved with the database.\n     */\n    async getSiteDb(siteId?: string): Promise<SQLiteDB> {\n        const site = await this.getSite(siteId);\n\n        return site.getDb();\n    }\n\n    /**\n     * Returns the site home ID of a site.\n     *\n     * @param siteId The site ID. If not defined, current site (if available).\n     * @returns Promise resolved with site home ID.\n     */\n    async getSiteHomeId(siteId?: string): Promise<number> {\n        const site = await this.getSite(siteId);\n\n        return site.getSiteHomeId();\n    }\n\n    /**\n     * Get the list of sites stored.\n     *\n     * @param ids IDs of the sites to get. If not defined, return all sites.\n     * @returns Promise resolved when the sites are retrieved.\n     */\n    async getSites(ids?: string[]): Promise<CoreSiteBasicInfo[]> {\n        const sites = await this.sitesTable.getMany();\n\n        return this.siteDBRecordsToBasicInfo(sites, ids);\n    }\n\n    /**\n     * Convert sites DB records to site basic info.\n     *\n     * @param sites DB records.\n     * @param ids IDs of sites to return, undefined to return them all.\n     * @returns Sites basic info.\n     */\n    protected async siteDBRecordsToBasicInfo(sites: SiteDBEntry[], ids?: string[]): Promise<CoreSiteBasicInfo[]> {\n        const formattedSites: CoreSiteBasicInfo[] = [];\n\n        await Promise.all(sites.map(async (site) => {\n            if (!ids || ids.indexOf(site.id) > -1) {\n                const siteInfo = site.info ? <CoreSiteInfo> CoreTextUtils.parseJSON(site.info) : undefined;\n                const siteInstance = CoreSitesFactory.makeSite(site.id, site.siteUrl, site.token, { info: siteInfo });\n\n                const siteName = await siteInstance.getSiteName();\n\n                const basicInfo: CoreSiteBasicInfo = {\n                    id: site.id,\n                    userId: siteInfo?.userid,\n                    siteUrl: site.siteUrl,\n                    siteUrlWithoutProtocol: site.siteUrl.replace(/^https?:\\/\\//, '').toLowerCase(),\n                    fullname: siteInfo?.fullname,\n                    firstname: siteInfo?.firstname,\n                    lastname: siteInfo?.lastname,\n                    siteName,\n                    userpictureurl: siteInfo?.userpictureurl,\n                    siteHomeId: siteInfo?.siteid || 1,\n                    loggedOut: !!site.loggedOut,\n                    info: siteInfo,\n                };\n                formattedSites.push(basicInfo);\n            }\n        }));\n\n        return formattedSites;\n    }\n\n    /**\n     * Get the list of sites stored, sorted by sitename, URL and fullname.\n     *\n     * @param ids IDs of the sites to get. If not defined, return all sites.\n     * @returns Promise resolved when the sites are retrieved.\n     */\n    async getSortedSites(ids?: string[]): Promise<CoreSiteBasicInfo[]> {\n        const sites = await this.getSites(ids);\n\n        // Sort sites by site name, url and then fullname.\n        sites.sort((a, b) => {\n            // First compare by site name.\n            let textA = CoreTextUtils.cleanTags(a.siteName).toLowerCase().trim();\n            let textB = CoreTextUtils.cleanTags(b.siteName).toLowerCase().trim();\n\n            let compare = textA.localeCompare(textB);\n            if (compare !== 0) {\n                return compare;\n            }\n\n            // If site name is the same, use site url without the protocol.\n            compare = a.siteUrlWithoutProtocol.localeCompare(b.siteUrlWithoutProtocol);\n            if (compare !== 0) {\n                return compare;\n            }\n\n            // Finally use fullname.\n            textA = a.fullname?.toLowerCase().trim() || '';\n            textB = b.fullname?.toLowerCase().trim() || '';\n\n            return textA.localeCompare(textB);\n        });\n\n        return sites;\n    }\n\n    /**\n     * Get the list of IDs of sites stored and not logged out.\n     *\n     * @returns Promise resolved when the sites IDs are retrieved.\n     */\n    async getLoggedInSitesIds(): Promise<string[]> {\n        const sites = await this.sitesTable.getMany({ loggedOut : 0 });\n\n        return sites.map((site) => site.id);\n    }\n\n    /**\n     * Get the list of IDs of sites stored.\n     *\n     * @returns Promise resolved when the sites IDs are retrieved.\n     */\n    async getSitesIds(): Promise<string[]> {\n        const sites = await this.sitesTable.getMany();\n\n        return sites.map((site) => site.id);\n    }\n\n    /**\n     * Get instances of all stored sites.\n     *\n     * @returns Promise resolved when the sites are retrieved.\n     */\n    async getSitesInstances(): Promise<CoreSite[]> {\n        const siteIds = await this.getSitesIds();\n\n        return Promise.all(siteIds.map((siteId) => this.getSite(siteId)));\n    }\n\n    /**\n     * Login the user in a site.\n     *\n     * @param siteId ID of the site the user is accessing.\n     * @returns Promise resolved when current site is stored.\n     */\n    async login(siteId: string): Promise<void> {\n        await CoreConfig.set(CORE_SITE_CURRENT_SITE_ID_CONFIG, siteId);\n\n        CoreEvents.trigger(CoreEvents.LOGIN, {}, siteId);\n    }\n\n    /**\n     * Logout the user.\n     *\n     * @param options Logout options.\n     * @returns Promise resolved when the user is logged out.\n     */\n    async logout(options: CoreSitesLogoutOptions = {}): Promise<void> {\n        if (!this.currentSite) {\n            return;\n        }\n\n        const promises: Promise<unknown>[] = [];\n        const siteConfig = this.currentSite.getStoredConfig();\n        const siteId = this.currentSite.getId();\n\n        this.currentSite = undefined;\n\n        if (options.forceLogout || (siteConfig && siteConfig.tool_mobile_forcelogout == '1')) {\n            promises.push(this.setSiteLoggedOut(siteId));\n        }\n\n        promises.push(this.removeStoredCurrentSite());\n\n        await CoreUtils.ignoreErrors(Promise.all(promises));\n\n        if (options.removeAccount) {\n            await CoreSites.deleteSite(siteId);\n        }\n\n        CoreEvents.trigger(CoreEvents.LOGOUT, {}, siteId);\n    }\n\n    /**\n     * Logout the user if authenticated to open a page/url in another site.\n     *\n     * @param siteId Site that will be opened after logout.\n     * @param redirectData Page/url to open after logout.\n     * @returns Promise resolved with boolean: true if app will be reloaded after logout.\n     */\n    async logoutForRedirect(siteId: string, redirectData: CoreRedirectPayload): Promise<boolean> {\n        if (!this.currentSite) {\n            return false;\n        }\n\n        if (CoreSitePlugins.hasSitePluginsLoaded) {\n            // The site has site plugins so the app will be restarted. Store the data and logout.\n            CoreApp.storeRedirect(siteId, redirectData);\n        }\n\n        await this.logout();\n\n        return CoreSitePlugins.hasSitePluginsLoaded;\n    }\n\n    /**\n     * Restores the session to the previous one so the user doesn't has to login everytime the app is started.\n     *\n     * @returns Promise resolved if a session is restored.\n     */\n    async restoreSession(): Promise<void> {\n        await this.handleAutoLogout();\n\n        if (this.sessionRestored) {\n            return Promise.reject(new CoreError('Session already restored.'));\n        }\n\n        this.sessionRestored = true;\n\n        try {\n            const siteId = await this.getStoredCurrentSiteId();\n            this.logger.debug(`Restore session in site ${siteId}`);\n\n            await this.loadSite(siteId);\n        } catch {\n            // No current session.\n        }\n    }\n\n    /**\n     * Handle auto logout by checking autologout type and time if its required.\n     */\n    async handleAutoLogout(): Promise<void> {\n        await CoreUtils.ignoreErrors(( async () => {\n            const siteId = await this.getStoredCurrentSiteId();\n            const site = await this.getSite(siteId);\n            const autoLogoutType = Number(site.getStoredConfig('tool_mobile_autologout'));\n            const autoLogoutTime = Number(site.getStoredConfig('tool_mobile_autologouttime'));\n\n            if (!autoLogoutType || autoLogoutType === CoreAutoLogoutType.NEVER || !site.id) {\n                return;\n            }\n\n            if (autoLogoutType === CoreAutoLogoutType.CUSTOM) {\n                await CoreAutoLogout.handleSessionClosed(autoLogoutTime, site);\n\n                return;\n            }\n\n            await CoreAutoLogout.handleAppClosed(site);\n        })());\n    }\n\n    /**\n     * Mark a site as logged out so the user needs to authenticate again.\n     *\n     * @param siteId ID of the site.\n     * @param isLoggedOut True if logged out and needs to authenticate again, false otherwise.\n     * @returns Promise resolved when done.\n     */\n    async setSiteLoggedOut(siteId: string, isLoggedOut: boolean = true): Promise<void> {\n        const site = await this.getSite(siteId);\n\n        site.setLoggedOut(isLoggedOut);\n\n        await this.sitesTable.update({ loggedOut: isLoggedOut ? 1 : 0 }, { id: siteId });\n    }\n\n    /**\n     * Unset current site.\n     */\n    unsetCurrentSite(): void {\n        this.currentSite = undefined;\n    }\n\n    /**\n     * Updates a site's token.\n     *\n     * @param siteUrl Site's URL.\n     * @param username Username.\n     * @param token User's new token.\n     * @param privateToken User's private token.\n     * @returns A promise resolved when the site is updated.\n     */\n    async updateSiteToken(siteUrl: string, username: string, token: string, privateToken: string = ''): Promise<void> {\n        const siteId = this.createSiteID(siteUrl, username);\n\n        await this.updateSiteTokenBySiteId(siteId, token, privateToken);\n\n        await this.login(siteId);\n    }\n\n    /**\n     * Updates a site's token using siteId.\n     *\n     * @param siteId Site Id.\n     * @param token User's new token.\n     * @param privateToken User's private token.\n     * @returns A promise resolved when the site is updated.\n     */\n    async updateSiteTokenBySiteId(siteId: string, token: string, privateToken: string = ''): Promise<void> {\n        const site = await this.getSite(siteId);\n\n        site.token = token;\n        site.privateToken = privateToken;\n        site.setLoggedOut(false); // Token updated means the user authenticated again, not logged out anymore.\n\n        const promises: Promise<unknown>[] = [];\n        const newData: Partial<SiteDBEntry> = {\n            token: '',\n            privateToken: '',\n            loggedOut: 0,\n        };\n\n        promises.push(this.sitesTable.update(newData, { id: siteId }));\n        promises.push(this.storeTokensInSecureStorage(siteId, token, privateToken));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Updates a site's info.\n     *\n     * @param siteId Site's ID.\n     * @returns A promise resolved when the site is updated.\n     */\n    async updateSiteInfo(siteId?: string): Promise<void> {\n        const site = await this.getSite(siteId);\n\n        try {\n            const info = await site.fetchSiteInfo();\n            site.setInfo(info);\n\n            const versionCheck = this.isValidMoodleVersion(info);\n            if (versionCheck != CoreSitesProvider.VALID_VERSION) {\n                // The Moodle version is not supported, reject.\n                return this.treatInvalidAppVersion(versionCheck, site.getId());\n            }\n\n            // Try to get the site config.\n            let config: CoreSiteConfig | undefined;\n\n            try {\n                config = await this.getSiteConfig(site);\n            } catch {\n                // Error getting config, keep the current one.\n            }\n\n            const newValues: Partial<SiteDBEntry> = {\n                info: JSON.stringify(info),\n                loggedOut: site.isLoggedOut() ? 1 : 0,\n            };\n\n            if (config !== undefined) {\n                site.setConfig(config);\n                newValues.config = JSON.stringify(config);\n            }\n\n            try {\n                await this.sitesTable.update(newValues, { id: siteId });\n            } finally {\n                CoreEvents.trigger(CoreEvents.SITE_UPDATED, info, siteId);\n            }\n        } catch {\n            // Ignore that we cannot fetch site info. Probably the auth token is invalid.\n        }\n    }\n\n    /**\n     * Updates a site's info.\n     *\n     * @param siteUrl Site's URL.\n     * @param username Username.\n     * @returns A promise to be resolved when the site is updated.\n     */\n    updateSiteInfoByUrl(siteUrl: string, username: string): Promise<void> {\n        const siteId = this.createSiteID(siteUrl, username);\n\n        return this.updateSiteInfo(siteId);\n    }\n\n    /**\n     * Get the site IDs a URL belongs to.\n     * Someone can have more than one account in the same site, that's why this function returns an array of IDs.\n     *\n     * @param url URL to check.\n     * @param prioritize True if it should prioritize current site. If the URL belongs to current site then it won't\n     *                   check any other site, it will only return current site.\n     * @param username If set, it will return only the sites where the current user has this username.\n     * @returns Promise resolved with the site IDs (array).\n     */\n    async getSiteIdsFromUrl(url: string, prioritize?: boolean, username?: string): Promise<string[]> {\n        // If prioritize is true, check current site first.\n        if (prioritize && this.currentSite && this.currentSite.containsUrl(url)) {\n            if (!username || this.currentSite?.getInfo()?.username === username) {\n                return [this.currentSite.getId()];\n            }\n        }\n\n        // Check if URL has http(s) protocol.\n        if (!url.match(/^https?:\\/\\//i)) {\n            // URL doesn't have http(s) protocol. Check if it has any protocol.\n            if (CoreUrlUtils.isAbsoluteURL(url)) {\n                // It has some protocol. Return empty array.\n                return [];\n            }\n\n            // No protocol, probably a relative URL. Return current site.\n            if (this.currentSite) {\n                return [this.currentSite.getId()];\n            }\n\n            return [];\n        }\n\n        try {\n            const siteEntries = await this.sitesTable.getMany();\n            const ids: string[] = [];\n\n            await Promise.all(siteEntries.map(async (site) => {\n                site = await this.loadSiteTokens(site);\n\n                await this.addSiteFromSiteListEntry(site);\n\n                if (this.sites[site.id].containsUrl(url)) {\n                    if (!username || this.sites[site.id].getInfo()?.username === username) {\n                        ids.push(site.id);\n                    }\n                }\n            }));\n\n            return ids;\n        } catch {\n            // Shouldn't happen.\n            return [];\n        }\n    }\n\n    /**\n     * Get the site ID stored in DB as current site.\n     *\n     * @returns Promise resolved with the site ID.\n     */\n    async getStoredCurrentSiteId(): Promise<string> {\n        await this.migrateCurrentSiteLegacyTable();\n\n        return CoreConfig.get(CORE_SITE_CURRENT_SITE_ID_CONFIG);\n    }\n\n    /**\n     * Remove current site stored in DB.\n     *\n     * @returns Promise resolved when done.\n     */\n    async removeStoredCurrentSite(): Promise<void> {\n        await CoreConfig.delete(CORE_SITE_CURRENT_SITE_ID_CONFIG);\n    }\n\n    /**\n     * Get the public config of a certain site.\n     *\n     * @param siteUrl URL of the site.\n     * @returns Promise resolved with the public config.\n     */\n    getSitePublicConfig(siteUrl: string): Promise<CoreSitePublicConfigResponse> {\n        const temporarySite = CoreSitesFactory.makeUnauthenticatedSite(siteUrl);\n\n        return temporarySite.getPublicConfig();\n    }\n\n    /**\n     * Get site config.\n     *\n     * @param site The site to get the config.\n     * @returns Promise resolved with config if available.\n     */\n    protected async getSiteConfig(site: CoreSite): Promise<CoreSiteConfig | undefined> {\n        return site.getConfig(undefined, true);\n    }\n\n    /**\n     * Check if a certain feature is disabled in a site.\n     *\n     * @param name Name of the feature to check.\n     * @param siteId The site ID. If not defined, current site (if available).\n     * @returns Promise resolved with true if disabled.\n     */\n    async isFeatureDisabled(name: string, siteId?: string): Promise<boolean> {\n        const site = await this.getSite(siteId);\n\n        return site.isFeatureDisabled(name);\n    }\n\n    /**\n     * Check if a WS is available in the current site, if any.\n     *\n     * @param method WS name.\n     * @returns Whether the WS is available.\n     */\n    wsAvailableInCurrentSite(method: string): boolean {\n        const site = this.getCurrentSite();\n\n        return site ? site.wsAvailable(method) : false;\n    }\n\n    /**\n     * Register a site schema in current site.\n     * This function is meant for site plugins to create DB tables in current site. Tables created from within the app\n     * should use the registerCoreSiteSchema method instead.\n     *\n     * @param schema The schema to register.\n     * @returns Promise resolved when done.\n     */\n    async registerSiteSchema(schema: CoreSiteSchema): Promise<void> {\n        if (!this.currentSite) {\n            return;\n        }\n\n        try {\n            // Site has already been created, apply the schema directly.\n            const schemas: {[name: string]: CoreRegisteredSiteSchema} = {};\n            schemas[schema.name] = schema;\n\n            // Apply it to the specified site only.\n            (schema as CoreRegisteredSiteSchema).siteId = this.currentSite.getId();\n\n            await this.applySiteSchemas(this.currentSite, schemas);\n        } finally {\n            this.pluginsSiteSchemas[schema.name] = schema;\n        }\n    }\n\n    /**\n     * Install and upgrade all the registered schemas and tables.\n     *\n     * @param site Site.\n     * @returns Promise resolved when done.\n     */\n    async migrateSiteSchemas(site: CoreSite): Promise<void> {\n        if (!site.id) {\n            return;\n        }\n\n        const siteId = site.id;\n\n        if (this.siteSchemasMigration[siteId] !== undefined) {\n            return this.siteSchemasMigration[siteId];\n        }\n\n        this.logger.debug(`Migrating all schemas of ${siteId}`);\n\n        // First create tables not registerd with name/version.\n        const promise = site.getDb().createTableFromSchema(SCHEMA_VERSIONS_TABLE_SCHEMA)\n            .then(() => this.applySiteSchemas(site, this.siteSchemas));\n\n        this.siteSchemasMigration[siteId] = promise;\n\n        return promise.finally(() => {\n            delete this.siteSchemasMigration[siteId];\n        });\n    }\n\n    /**\n     * Install and upgrade the supplied schemas for a certain site.\n     *\n     * @param site Site.\n     * @param schemas Schemas to migrate.\n     * @returns Promise resolved when done.\n     */\n    protected async applySiteSchemas(site: CoreSite, schemas: {[name: string]: CoreRegisteredSiteSchema}): Promise<void> {\n        // Fetch installed versions of the schema.\n        const records = await this.getSiteSchemasTable(site).getMany();\n\n        const versions: {[name: string]: number} = {};\n        records.forEach((record) => {\n            versions[record.name] = record.version;\n        });\n\n        const promises: Promise<void>[] = [];\n        for (const name in schemas) {\n            const schema = schemas[name];\n            const oldVersion = versions[name] || 0;\n            if (oldVersion >= schema.version || (schema.siteId && site.getId() != schema.siteId)) {\n                // Version already applied or the schema shouldn't be registered to this site.\n                continue;\n            }\n\n            this.logger.debug(`Migrating schema '${name}' of ${site.id} from version ${oldVersion} to ${schema.version}`);\n\n            promises.push(this.applySiteSchema(site, schema, oldVersion));\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Install and upgrade the supplied schema for a certain site.\n     *\n     * @param site Site.\n     * @param schema Schema to migrate.\n     * @param oldVersion Old version of the schema.\n     * @returns Promise resolved when done.\n     */\n    protected async applySiteSchema(site: CoreSite, schema: CoreRegisteredSiteSchema, oldVersion: number): Promise<void> {\n        if (!site.id) {\n            return;\n        }\n\n        const db = site.getDb();\n\n        if (schema.tables) {\n            await db.createTablesFromSchema(schema.tables);\n        }\n        if (schema.install && oldVersion == 0) {\n            await schema.install(db, site.id);\n        }\n        if (schema.migrate && oldVersion > 0) {\n            await schema.migrate(db, oldVersion, site.id);\n        }\n\n        // Set installed version.\n        await this.getSiteSchemasTable(site).insert({ name: schema.name, version: schema.version });\n    }\n\n    /**\n     * Check if a URL is the root URL of any of the stored sites.\n     *\n     * @param url URL to check.\n     * @param username Username to check.\n     * @returns Promise resolved with site to use and the list of sites that have\n     *         the URL. Site will be undefined if it isn't the root URL of any stored site.\n     */\n    async isStoredRootURL(url: string, username?: string): Promise<{site?: CoreSite; siteIds: string[]}> {\n        // Check if the site is stored.\n        const siteIds = await this.getSiteIdsFromUrl(url, true, username);\n\n        const result: {site?: CoreSite; siteIds: string[]} = {\n            siteIds,\n        };\n\n        if (!siteIds.length) {\n            return result;\n        }\n\n        // If more than one site is returned it usually means there are different users stored. Use any of them.\n        const site = await this.getSite(siteIds[0]);\n\n        const siteUrl = CoreText.removeEndingSlash(\n            CoreUrlUtils.removeProtocolAndWWW(site.getURL()),\n        );\n        const treatedUrl = CoreText.removeEndingSlash(CoreUrlUtils.removeProtocolAndWWW(url));\n\n        if (siteUrl == treatedUrl) {\n            result.site = site;\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the Site Schema names that can be cleared on space storage.\n     *\n     * @param site The site that will be cleared.\n     * @returns Name of the site schemas.\n     */\n    getSiteTableSchemasToClear(site: CoreSite): string[] {\n        let reset: string[] = [];\n        const schemas = Object.values(this.siteSchemas).concat(Object.values(this.pluginsSiteSchemas));\n\n        schemas.forEach((schema) => {\n            if (schema.canBeCleared && (!schema.siteId || site.getId() == schema.siteId)) {\n                reset = reset.concat(schema.canBeCleared);\n            }\n        });\n\n        return reset;\n    }\n\n    /**\n     * Returns presets for a given reading strategy.\n     *\n     * @param strategy Reading strategy.\n     * @returns PreSets options object.\n     */\n    getReadingStrategyPreSets(strategy?: CoreSitesReadingStrategy): CoreSiteWSPreSets {\n        switch (strategy) {\n            case CoreSitesReadingStrategy.PREFER_CACHE:\n                return {\n                    omitExpires: true,\n                };\n            case CoreSitesReadingStrategy.ONLY_CACHE:\n                return {\n                    omitExpires: true,\n                    forceOffline: true,\n                };\n            case CoreSitesReadingStrategy.PREFER_NETWORK:\n                return {\n                    getFromCache: false,\n                };\n            case CoreSitesReadingStrategy.ONLY_NETWORK:\n                return {\n                    getFromCache: false,\n                    emergencyCache: false,\n                };\n            case CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE:\n                return {\n                    updateInBackground: true,\n                    getFromCache: true,\n                    saveToCache: true,\n                };\n            default:\n                return {};\n        }\n    }\n\n    /**\n     * Returns site info found on the backend.\n     *\n     * @param search Searched text.\n     * @returns Site info list.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async findSites(search: string): Promise<CoreLoginSiteInfo[]> {\n        return [];\n    }\n\n    /**\n     * Check whether a site is using a default image or not.\n     *\n     * @param site Site info.\n     * @returns Whether the site is using a default image.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    hasDefaultImage(site: CoreLoginSiteInfo): boolean {\n        return false;\n    }\n\n    /**\n     * Migrate the legacy current_site table.\n     */\n    protected async migrateCurrentSiteLegacyTable(): Promise<void> {\n        if (await CoreConfig.has('current_site_migrated')) {\n            // Already migrated.\n            return;\n        }\n\n        try {\n            const db = CoreApp.getDB();\n\n            const { siteId } = await db.getRecord<{ siteId: string }>('current_site');\n\n            await CoreConfig.set(CORE_SITE_CURRENT_SITE_ID_CONFIG, siteId);\n            await CoreApp.deleteTableSchema('current_site');\n            await db.dropTable('current_site');\n        } catch {\n            // There was no current site, silence the error.\n        } finally {\n            await CoreConfig.set('current_site_migrated', 1);\n        }\n    }\n\n    /**\n     * Get schemas table for the given site.\n     *\n     * @param site Site.\n     * @returns Scehmas Table.\n     */\n    protected getSiteSchemasTable(site: CoreSite): AsyncInstance<CoreDatabaseTable<SchemaVersionsDBEntry, 'name'>> {\n        const siteId = site.getId();\n\n        this.schemasTables[siteId] = this.schemasTables[siteId] ?? asyncInstance(\n            () => this.getSiteTable(SCHEMA_VERSIONS_TABLE_NAME, {\n                siteId: siteId,\n                database: site.getDb(),\n                config: { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n                primaryKeyColumns: ['name'],\n                onDestroy: () => delete this.schemasTables[siteId],\n            }),\n        );\n\n        return this.schemasTables[siteId];\n    }\n\n    /**\n     * Move all tokens stored in DB to a secure storage.\n     */\n    async moveTokensToSecureStorage(): Promise<void> {\n        const sites = await this.sitesTable.getMany();\n\n        await Promise.all(sites.map(async site => {\n            if (!site.token && !site.privateToken) {\n                return; // Tokens are empty, no need to treat them.\n            }\n\n            try {\n                await this.storeTokensInSecureStorage(site.id, site.token, site.privateToken);\n            } catch {\n                this.logger.error('Error storing tokens in secure storage for site ' + site.id);\n            }\n        }));\n\n        // Remove tokens from DB even if they couldn't be stored in secure storage.\n        await this.sitesTable.update({ token: '', privateToken: '' });\n    }\n\n    /**\n     * Get tokens from secure storage.\n     *\n     * @param siteId Site ID.\n     * @returns Stored tokens.\n     */\n    protected async getTokensFromSecureStorage(siteId: string): Promise<{ token: string; privateToken?: string }> {\n        const result = await CoreNative.plugin('secureStorage')?.get(['token', 'privateToken'], siteId);\n\n        return {\n            token: result?.token ?? '',\n            privateToken: result?.privateToken ?? undefined,\n        };\n    }\n\n    /**\n     * Store tokens in secure storage.\n     *\n     * @param siteId Site ID.\n     * @param token Site token.\n     * @param privateToken Site private token.\n     */\n    protected async storeTokensInSecureStorage(\n        siteId: string,\n        token: string,\n        privateToken?: string,\n    ): Promise<void> {\n        await CoreNative.plugin('secureStorage')?.store({\n            token: token,\n            privateToken: privateToken ?? '',\n        }, siteId);\n    }\n\n    /**\n     * Given a site, load its tokens if needed.\n     *\n     * @param site Site data.\n     * @returns Site with tokens loaded.\n     */\n    protected async loadSiteTokens(site: SiteDBEntry): Promise<SiteDBEntry> {\n        if (site.token) {\n            return site;\n        }\n\n        const tokens = await this.getTokensFromSecureStorage(site.id);\n\n        return {\n            ...site,\n            ...tokens,\n        };\n    }\n\n    /**\n     * Invalidate all sites cache.\n     */\n    protected async invalidateCaches(): Promise<void> {\n        const sites = await this.getSites();\n\n        await Promise.all(\n            sites\n                .map(site => CoreSitesFactory.makeSite(site.id, site.siteUrl, ''))\n                .map(site => site.invalidateCaches()),\n        );\n    }\n\n}\n\nexport const CoreSites = makeSingleton(CoreSitesProvider);\n\n/**\n * Response of checking if a site exists and its configuration.\n */\nexport type CoreSiteCheckResponse = {\n    /**\n     * Code to identify the authentication method to use.\n     */\n    code: number;\n\n    /**\n     * Site url to use (might have changed during the process).\n     */\n    siteUrl: string;\n\n    /**\n     * Service used.\n     */\n    service: string;\n\n    /**\n     * Site public config (if available).\n     */\n    config?: CoreSitePublicConfigResponse;\n};\n\n/**\n * Response of getting user token.\n */\nexport type CoreSiteUserTokenResponse = {\n    /**\n     * User token.\n     */\n    token: string;\n\n    /**\n     * Site URL to use.\n     */\n    siteUrl: string;\n\n    /**\n     * User private token.\n     */\n    privateToken?: string;\n};\n\n/**\n * Site's basic info.\n */\nexport type CoreSiteBasicInfo = {\n    id: string; // Site ID.\n    userId?: number; // User ID.\n    siteUrl: string; // Site URL.\n    siteUrlWithoutProtocol: string; // Site URL without protocol.\n    fullname?: string; // User's full name.\n    firstname?: string; // User's first name.\n    lastname?: string; // User's last name.\n    userpictureurl?: string; // User avatar.\n    siteName?: string; // Site's name.\n    badge?: number; // Badge to display in the site.\n    siteHomeId?: number; // Site home ID.\n    loggedOut: boolean; // If Site is logged out.\n    info?: CoreSiteInfo; // Site info.\n};\n\n/**\n * Site schema and migration function.\n */\nexport type CoreSiteSchema = {\n    /**\n     * Name of the schema.\n     */\n    name: string;\n\n    /**\n     * Latest version of the schema (integer greater than 0).\n     */\n    version: number;\n\n    /**\n     * Names of the tables of the site schema that can be cleared.\n     */\n    canBeCleared?: string[];\n\n    /**\n     * Tables to create when installing or upgrading the schema.\n     */\n    tables?: SQLiteDBTableSchema[];\n\n    /**\n     * Migrates the schema in a site to the latest version.\n     *\n     * Called when upgrading the schema, after creating the defined tables.\n     *\n     * @param db Site database.\n     * @param oldVersion Old version of the schema or 0 if not installed.\n     * @param siteId Site Id to migrate.\n     * @returns Promise resolved when done.\n     */\n    migrate?(db: SQLiteDB, oldVersion: number, siteId: string): Promise<void> | void;\n\n    /**\n     * Make changes to install the schema in a site.\n     *\n     * Called when installing the schema, after creating the defined tables.\n     *\n     * @param db Site database.\n     * @param siteId Site Id to migrate.\n     * @returns Promise resolved when done.\n     */\n    install?(db: SQLiteDB, siteId: string): Promise<void> | void;\n};\n\n/**\n * Data about sites to be listed.\n */\nexport type CoreLoginSiteInfo = {\n    /**\n     * Site name.\n     */\n    name: string;\n\n    /**\n     * Site alias.\n     */\n    alias?: string;\n\n    /**\n     * URL of the site.\n     */\n    url: string;\n\n    /**\n     * Image URL of the site.\n     */\n    imageurl?: string;\n\n    /**\n     * City of the site.\n     */\n    city?: string;\n\n    /**\n     * Countrycode of the site.\n     */\n    countrycode?: string;\n\n    /**\n     * Is staging site.\n     */\n    staging?: boolean;\n\n    /**\n     * Class to apply to site item.\n     */\n    className?: string;\n\n    /**\n     * Whether the site is for demo mode usage.\n     */\n    demoMode?: boolean;\n};\n\n/**\n * Registered site schema.\n */\nexport type CoreRegisteredSiteSchema = CoreSiteSchema & {\n    /**\n     * Site ID to apply the schema to. If not defined, all sites.\n     */\n    siteId?: string;\n};\n\n/**\n * Possible reading strategies (for cache).\n */\nexport const enum CoreSitesReadingStrategy {\n    ONLY_CACHE,\n    PREFER_CACHE,\n    ONLY_NETWORK,\n    PREFER_NETWORK,\n    STALE_WHILE_REVALIDATE,\n}\n\n/**\n * Common options used when calling a WS through CoreSite.\n */\nexport type CoreSitesCommonWSOptions = {\n    readingStrategy?: CoreSitesReadingStrategy; // Reading strategy.\n    siteId?: string; // Site ID. If not defined, current site.\n};\n\n/**\n * Data about a certain demo site.\n */\nexport type CoreSitesDemoSiteData = {\n    url: string;\n    username: string;\n    password: string;\n};\n\n/**\n * Response of calls to login/token.php.\n */\nexport type CoreSitesLoginTokenResponse = {\n    token?: string;\n    privatetoken?: string;\n    error?: string;\n    errorcode?: string;\n    stacktrace?: string;\n    debuginfo?: string;\n    reproductionlink?: string;\n};\n\n/**\n * Options for logout.\n */\nexport type CoreSitesLogoutOptions = {\n    forceLogout?: boolean; // If true, site will be marked as logged out, no matter the value tool_mobile_forcelogout.\n    removeAccount?: boolean; // If true, site will be removed too after logout.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}