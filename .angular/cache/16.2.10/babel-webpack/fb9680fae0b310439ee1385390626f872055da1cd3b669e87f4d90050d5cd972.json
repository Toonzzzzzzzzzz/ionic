{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreError } from '@classes/errors/error';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModPage:';\n/**\n * Service that provides some features for page.\n */\nexport class AddonModPageProvider {\n  /**\n   * Get a page by course module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the page is retrieved.\n   */\n  getPageData(courseId, cmId, options = {}) {\n    return this.getPageByKey(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a page.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the page is retrieved.\n   */\n  getPageByKey(courseId, key, value, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this.getPageCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModPageProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_page_get_pages_by_courses', params, preSets);\n      const currentPage = response.pages.find(page => page[key] == value);\n      if (currentPage) {\n        return currentPage;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get cache key for page data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getPageCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'page:' + courseId;\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID of the module.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const promises = [];\n    promises.push(this.invalidatePageData(courseId, siteId));\n    promises.push(CoreFilepool.invalidateFilesByComponent(siteId, AddonModPageProvider.COMPONENT, moduleId));\n    promises.push(CoreCourse.invalidateModule(moduleId, siteId));\n    return CoreUtils.allPromises(promises);\n  }\n  /**\n   * Invalidates page data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidatePageData(courseId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this2.getPageCacheKey(courseId));\n    })();\n  }\n  /**\n   * Return whether or not the plugin is enabled.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n   */\n  isPluginEnabled(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.canDownloadFiles();\n    })();\n  }\n  /**\n   * Report a page as being viewed.\n   *\n   * @param pageid Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(pageid, siteId) {\n    const params = {\n      pageid\n    };\n    return CoreCourseLogHelper.log('mod_page_view_page', params, AddonModPageProvider.COMPONENT, pageid, siteId);\n  }\n}\n_class = AddonModPageProvider;\n_class.COMPONENT = 'mmaModPage';\n_class.ɵfac = function AddonModPageProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModPage = makeSingleton(AddonModPageProvider);","map":{"version":3,"names":["CoreSites","CoreSite","makeSingleton","Translate","CoreFilepool","CoreCourse","CoreUtils","CoreCourseLogHelper","CoreError","ROOT_CACHE_KEY","AddonModPageProvider","getPageData","courseId","cmId","options","getPageByKey","key","value","_this","_asyncToGenerator","site","getSite","siteId","params","courseids","preSets","_objectSpread","cacheKey","getPageCacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","response","read","currentPage","pages","find","page","instant","invalidateContent","moduleId","getCurrentSiteId","promises","push","invalidatePageData","invalidateFilesByComponent","invalidateModule","allPromises","_this2","invalidateWsCacheForKey","isPluginEnabled","canDownloadFiles","logView","pageid","log","_class","factory","ɵfac","providedIn","AddonModPage"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/page/services/page.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSitesCommonWSOptions, CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreWSExternalWarning, CoreWSExternalFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaModPage:';\n\n/**\n * Service that provides some features for page.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModPageProvider {\n\n    static readonly COMPONENT = 'mmaModPage';\n\n    /**\n     * Get a page by course module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the page is retrieved.\n     */\n    getPageData(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModPagePage> {\n        return this.getPageByKey(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a page.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the page is retrieved.\n     */\n    protected async getPageByKey(\n        courseId: number,\n        key: string,\n        value: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModPagePage> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModPageGetPagesByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getPageCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModPageProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        const response = await site.read<AddonModPageGetPagesByCoursesWSResponse>('mod_page_get_pages_by_courses', params, preSets);\n\n        const currentPage = response.pages.find((page) => page[key] == value);\n        if (currentPage) {\n            return currentPage;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get cache key for page data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getPageCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'page:' + courseId;\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID of the module.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const promises: Promise<void>[] = [];\n\n        promises.push(this.invalidatePageData(courseId, siteId));\n        promises.push(CoreFilepool.invalidateFilesByComponent(siteId, AddonModPageProvider.COMPONENT, moduleId));\n        promises.push(CoreCourse.invalidateModule(moduleId, siteId));\n\n        return CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Invalidates page data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidatePageData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getPageCacheKey(courseId));\n    }\n\n    /**\n     * Return whether or not the plugin is enabled.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n     */\n    async isPluginEnabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.canDownloadFiles();\n    }\n\n    /**\n     * Report a page as being viewed.\n     *\n     * @param pageid Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logView(pageid: number, siteId?: string): Promise<void> {\n        const params: AddonModPageViewPageWSParams = {\n            pageid,\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_page_view_page',\n            params,\n            AddonModPageProvider.COMPONENT,\n            pageid,\n            siteId,\n        );\n    }\n\n}\n\nexport const AddonModPage = makeSingleton(AddonModPageProvider);\n\n/**\n * Page returned by mod_page_get_pages_by_courses.\n */\nexport type AddonModPagePage = {\n    id: number; // Module id.\n    coursemodule: number; // Course module id.\n    course: number; // Course id.\n    name: string; // Page name.\n    intro: string; // Summary.\n    introformat: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles: CoreWSExternalFile[];\n    content: string; // Page content.\n    contentformat: number; // Content format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    contentfiles: CoreWSExternalFile[];\n    legacyfiles: number; // Legacy files flag.\n    legacyfileslast: number; // Legacy files last control flag.\n    display: number; // How to display the page.\n    displayoptions: string; // Display options (width, height).\n    revision: number; // Incremented when after each file changes, to avoid cache.\n    timemodified: number; // Last time the page was modified.\n    section: number; // Course section id.\n    visible: number; // Module visibility.\n    groupmode: number; // Group mode.\n    groupingid: number; // Grouping id.\n};\n\n/**\n * Result of WS mod_page_get_pages_by_courses.\n */\ntype AddonModPageGetPagesByCoursesWSResponse = {\n    pages: AddonModPagePage[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_page_view_page WS.\n */\ntype AddonModPageViewPageWSParams = {\n    pageid: number; // Page instance id.\n};\n\n/**\n * Params of mod_page_get_pages_by_courses WS.\n */\ntype AddonModPageGetPagesByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}