{"ast":null,"code":"var _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from \"@angular/core\";\n/**\n * This component shows a chronometer in format HH:MM:SS.\n *\n * If no startTime is provided, it will start at 00:00:00.\n * If an endTime is provided, the chrono will stop and emit an event in the onEnd output when that number of milliseconds is\n * reached. E.g. if startTime=60000 and endTime=120000, the chrono will start at 00:01:00 and end when it reaches 00:02:00.\n *\n * This component has 2 boolean inputs to control the timer: running (to start and stop it) and reset.\n *\n * Example usage:\n * <core-chrono [running]=\"running\" [reset]=\"reset\" [endTime]=\"maxTime\" (onEnd)=\"stopCapturing()\"></core-chrono>\n */\nexport class CoreChronoComponent {\n  constructor(changeDetectorRef) {\n    this.changeDetectorRef = changeDetectorRef;\n    this.startTime = 0; // Number of milliseconds to put in the chrono before starting.\n    this.hours = true;\n    this.time = 0;\n    this.onEnd = new EventEmitter();\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnInit() {\n    this.time = this.startTime || 0;\n  }\n  /**\n   * Component being changed.\n   */\n  ngOnChanges(changes) {\n    if (changes && changes.running) {\n      if (changes.running.currentValue) {\n        this.start();\n      } else {\n        this.stop();\n      }\n    }\n    if (changes && changes.reset && changes.reset.currentValue) {\n      this.resetChrono();\n    }\n  }\n  /**\n   * Reset the chrono, stopping it and setting it to startTime.\n   */\n  resetChrono() {\n    this.stop();\n    this.time = this.startTime || 0;\n  }\n  /**\n   * Start the chrono if it isn't running.\n   */\n  start() {\n    if (this.interval) {\n      // Already setup.\n      return;\n    }\n    let lastExecTime = Date.now();\n    this.interval = window.setInterval(() => {\n      // Increase the chrono.\n      this.time += Date.now() - lastExecTime;\n      lastExecTime = Date.now();\n      if (this.endTime !== undefined && this.time > this.endTime) {\n        // End time reached, stop the timer and call the end function.\n        this.stop();\n        this.onEnd.emit();\n      }\n      // Force change detection. Angular doesn't detect these async operations.\n      this.changeDetectorRef.detectChanges();\n    }, 200);\n  }\n  /**\n   * Stop the chrono, leaving the same time it has.\n   */\n  stop() {\n    clearInterval(this.interval);\n    delete this.interval;\n  }\n  ngOnDestroy() {\n    this.stop();\n  }\n}\n_class = CoreChronoComponent;\n_class.ɵfac = function CoreChronoComponent_Factory(t) {\n  return new (t || _class)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n};\n_class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: _class,\n  selectors: [[\"core-chrono\"]],\n  inputs: {\n    running: \"running\",\n    startTime: \"startTime\",\n    endTime: \"endTime\",\n    reset: \"reset\",\n    hours: \"hours\"\n  },\n  outputs: {\n    onEnd: \"onEnd\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature],\n  decls: 3,\n  vars: 4,\n  consts: [[\"role\", \"timer\"]],\n  template: function CoreChronoComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"span\", 0);\n      i0.ɵɵtext(1);\n      i0.ɵɵpipe(2, \"coreSecondsToHMS\");\n      i0.ɵɵelementEnd();\n    }\n    if (rf & 2) {\n      i0.ɵɵadvance(1);\n      i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(2, 1, ctx.time / 1000, ctx.hours));\n    }\n  },\n  encapsulation: 2\n});","map":{"version":3,"names":["EventEmitter","CoreChronoComponent","constructor","changeDetectorRef","startTime","hours","time","onEnd","ngOnInit","ngOnChanges","changes","running","currentValue","start","stop","reset","resetChrono","interval","lastExecTime","Date","now","window","setInterval","endTime","undefined","emit","detectChanges","clearInterval","ngOnDestroy","i0","ɵɵdirectiveInject","ChangeDetectorRef","selectors","inputs","outputs","features","ɵɵNgOnChangesFeature","decls","vars","consts","template","CoreChronoComponent_Template","rf","ctx","ɵɵelementStart","ɵɵtext","ɵɵelementEnd","ɵɵadvance","ɵɵtextInterpolate","ɵɵpipeBind2"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/components/chrono/chrono.ts","/home/toon/works/gitionic7/ionic-github/ionic/src/core/components/chrono/core-chrono.html"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n    Component,\n    Input,\n    OnInit,\n    OnChanges,\n    OnDestroy,\n    Output,\n    EventEmitter,\n    SimpleChange,\n    ChangeDetectorRef,\n} from '@angular/core';\n\n/**\n * This component shows a chronometer in format HH:MM:SS.\n *\n * If no startTime is provided, it will start at 00:00:00.\n * If an endTime is provided, the chrono will stop and emit an event in the onEnd output when that number of milliseconds is\n * reached. E.g. if startTime=60000 and endTime=120000, the chrono will start at 00:01:00 and end when it reaches 00:02:00.\n *\n * This component has 2 boolean inputs to control the timer: running (to start and stop it) and reset.\n *\n * Example usage:\n * <core-chrono [running]=\"running\" [reset]=\"reset\" [endTime]=\"maxTime\" (onEnd)=\"stopCapturing()\"></core-chrono>\n */\n@Component({\n    selector: 'core-chrono',\n    templateUrl: 'core-chrono.html',\n})\nexport class CoreChronoComponent implements OnInit, OnChanges, OnDestroy {\n\n    @Input() running?: boolean; // Set it to true to start the chrono. Set it to false to stop it.\n    @Input() startTime = 0; // Number of milliseconds to put in the chrono before starting.\n    @Input() endTime?: number; // Number of milliseconds to stop the chrono.\n    @Input() reset?: boolean; // Set it to true to reset the chrono.\n    @Input() hours = true;\n    @Output() onEnd: EventEmitter<void>; // Will emit an event when the endTime is reached.\n\n    time = 0;\n    protected interval?: number;\n\n    constructor(protected changeDetectorRef: ChangeDetectorRef) {\n        this.onEnd = new EventEmitter();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngOnInit(): void {\n        this.time = this.startTime || 0;\n    }\n\n    /**\n     * Component being changed.\n     */\n    ngOnChanges(changes: { [name: string]: SimpleChange }): void {\n        if (changes && changes.running) {\n            if (changes.running.currentValue) {\n                this.start();\n            } else {\n                this.stop();\n            }\n        }\n        if (changes && changes.reset && changes.reset.currentValue) {\n            this.resetChrono();\n        }\n    }\n\n    /**\n     * Reset the chrono, stopping it and setting it to startTime.\n     */\n    protected resetChrono(): void {\n        this.stop();\n        this.time = this.startTime || 0;\n    }\n\n    /**\n     * Start the chrono if it isn't running.\n     */\n    protected start(): void {\n        if (this.interval) {\n            // Already setup.\n            return;\n        }\n\n        let lastExecTime = Date.now();\n\n        this.interval = window.setInterval(() => {\n            // Increase the chrono.\n            this.time += Date.now() - lastExecTime;\n            lastExecTime = Date.now();\n\n            if (this.endTime !== undefined && this.time > this.endTime) {\n                // End time reached, stop the timer and call the end function.\n                this.stop();\n                this.onEnd.emit();\n            }\n\n            // Force change detection. Angular doesn't detect these async operations.\n            this.changeDetectorRef.detectChanges();\n        }, 200);\n    }\n\n    /**\n     * Stop the chrono, leaving the same time it has.\n     */\n    protected stop(): void {\n        clearInterval(this.interval);\n        delete this.interval;\n    }\n\n    ngOnDestroy(): void {\n        this.stop();\n    }\n\n}\n","<span role=\"timer\">{{ time / 1000 | coreSecondsToHMS:hours }}</span>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}