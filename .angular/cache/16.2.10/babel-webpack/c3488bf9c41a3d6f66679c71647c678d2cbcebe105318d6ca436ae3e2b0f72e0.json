{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSites } from '@services/sites';\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { AddonModAssignProvider, AddonModAssign } from './assign';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { AddonModAssignOffline } from './assign-offline';\nimport { CoreSync } from '@services/sync';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreNetwork } from '@services/network';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreGradesHelper } from '@features/grades/services/grades-helper';\nimport { AddonModAssignSubmissionDelegate } from './submission-delegate';\nimport { AddonModAssignFeedbackDelegate } from './feedback-delegate';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync assigns.\n */\nexport class AddonModAssignSyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModAssignSyncProvider');\n    this.componentTranslatableString = 'assign';\n  }\n  /**\n   * Get the sync ID for a certain user grade.\n   *\n   * @param assignId Assign ID.\n   * @param userId User the grade belongs to.\n   * @returns Sync ID.\n   */\n  getGradeSyncId(assignId, userId) {\n    return 'assignGrade#' + assignId + '#' + userId;\n  }\n  /**\n   * Convenience function to get scale selected option.\n   *\n   * @param options Possible options.\n   * @param selected Selected option to search.\n   * @returns Index of the selected option.\n   */\n  getSelectedScaleId(options, selected) {\n    let optionsList = options.split(',');\n    optionsList = optionsList.map(value => value.trim());\n    optionsList.unshift('');\n    const index = options.indexOf(selected) || 0;\n    if (index < 0) {\n      return 0;\n    }\n    return index;\n  }\n  /**\n   * Check if an assignment has data to synchronize.\n   *\n   * @param assignId Assign ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it has data to sync.\n   */\n  hasDataToSync(assignId, siteId) {\n    return AddonModAssignOffline.hasAssignOfflineData(assignId, siteId);\n  }\n  /**\n   * Try to synchronize all the assignments in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllAssignments(siteId, force) {\n    return this.syncOnSites('all assignments', siteId => this.syncAllAssignmentsFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all assignments on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllAssignmentsFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Get all assignments that have offline data.\n      const assignIds = yield AddonModAssignOffline.getAllAssigns(siteId);\n      // Try to sync all assignments.\n      yield Promise.all(assignIds.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (assignId) {\n          const result = force ? yield _this.syncAssign(assignId, siteId) : yield _this.syncAssignIfNeeded(assignId, siteId);\n          if (result !== null && result !== void 0 && result.updated) {\n            CoreEvents.trigger(AddonModAssignSyncProvider.AUTO_SYNCED, {\n              assignId: assignId,\n              warnings: result.warnings,\n              gradesBlocked: result.gradesBlocked\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Sync an assignment only if a certain time has passed since the last time.\n   *\n   * @param assignId Assign ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the assign is synced or it doesn't need to be synced.\n   */\n  syncAssignIfNeeded(assignId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const needed = yield _this2.isSyncNeeded(assignId, siteId);\n      if (needed) {\n        return _this2.syncAssign(assignId, siteId);\n      }\n    })();\n  }\n  /**\n   * Try to synchronize an assign.\n   *\n   * @param assignId Assign ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success.\n   */\n  syncAssign(assignId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const currentSyncPromise = _this3.getOngoingSync(assignId, siteId);\n      if (currentSyncPromise) {\n        // There's already a sync ongoing for this assign, return the promise.\n        return currentSyncPromise;\n      }\n      // Verify that assign isn't blocked.\n      if (CoreSync.isBlocked(AddonModAssignProvider.COMPONENT, assignId, siteId)) {\n        _this3.logger.debug('Cannot sync assign ' + assignId + ' because it is blocked.');\n        throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', {\n          $a: _this3.componentTranslate\n        }));\n      }\n      _this3.logger.debug('Try to sync assign ' + assignId + ' in site ' + siteId);\n      const syncPromise = _this3.performSyncAssign(assignId, siteId);\n      return _this3.addOngoingSync(assignId, syncPromise, siteId);\n    })();\n  }\n  /**\n   * Perform the assign submission.\n   *\n   * @param assignId Assign ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved in success.\n   */\n  performSyncAssign(assignId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModAssignProvider.COMPONENT, assignId, siteId));\n      const result = {\n        warnings: [],\n        updated: false,\n        gradesBlocked: []\n      };\n      // Load offline data and sync offline logs.\n      const [submissions, grades] = yield Promise.all([_this4.getOfflineSubmissions(assignId, siteId), _this4.getOfflineGrades(assignId, siteId)]);\n      if (!submissions.length && !grades.length) {\n        // Nothing to sync.\n        yield CoreUtils.ignoreErrors(_this4.setSyncTime(assignId, siteId));\n        return result;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      const courseId = submissions.length > 0 ? submissions[0].courseid : grades[0].courseid;\n      const assign = yield AddonModAssign.getAssignmentById(courseId, assignId, {\n        siteId\n      });\n      let promises = [];\n      promises = promises.concat(submissions.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (submission) {\n          yield _this4.syncSubmission(assign, submission, result.warnings, siteId);\n          result.updated = true;\n          return;\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      promises = promises.concat(grades.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (grade) {\n          try {\n            yield _this4.syncSubmissionGrade(assign, grade, result.warnings, courseId, siteId);\n            result.updated = true;\n          } catch (error) {\n            if (error instanceof CoreSyncBlockedError) {\n              // Grade blocked, but allow finish the sync.\n              result.gradesBlocked.push(grade.userid);\n            } else {\n              throw error;\n            }\n          }\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      yield CoreUtils.allPromises(promises);\n      if (result.updated) {\n        // Data has been sent to server. Now invalidate the WS calls.\n        yield CoreUtils.ignoreErrors(AddonModAssign.invalidateContent(assign.cmid, courseId, siteId));\n      }\n      // Sync finished, set sync time.\n      yield CoreUtils.ignoreErrors(_this4.setSyncTime(assignId, siteId));\n      // All done, return the result.\n      return result;\n    })();\n  }\n  /**\n   * Get offline grades to be sent.\n   *\n   * @param assignId Assign ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise with grades.\n   */\n  getOfflineGrades(assignId, siteId) {\n    return _asyncToGenerator(function* () {\n      // If no offline data found, return empty array.\n      return CoreUtils.ignoreErrors(AddonModAssignOffline.getAssignSubmissionsGrade(assignId, siteId), []);\n    })();\n  }\n  /**\n   * Get offline submissions to be sent.\n   *\n   * @param assignId Assign ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise with submissions.\n   */\n  getOfflineSubmissions(assignId, siteId) {\n    return _asyncToGenerator(function* () {\n      // If no offline data found, return empty array.\n      return CoreUtils.ignoreErrors(AddonModAssignOffline.getAssignSubmissions(assignId, siteId), []);\n    })();\n  }\n  /**\n   * Synchronize a submission.\n   *\n   * @param assign Assignment.\n   * @param offlineData Submission offline data.\n   * @param warnings List of warnings.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  syncSubmission(assign, offlineData, warnings, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const userId = offlineData.userid;\n      const pluginData = {};\n      const options = {\n        userId,\n        cmId: assign.cmid,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      const status = yield AddonModAssign.getSubmissionStatus(assign.id, options);\n      const submission = AddonModAssign.getSubmissionObjectFromAttempt(assign, status.lastattempt);\n      if (submission && submission.timemodified != offlineData.onlinetimemodified) {\n        // The submission was modified in Moodle, discard the submission.\n        _this5.addOfflineDataDeletedWarning(warnings, assign.name, Translate.instant('addon.mod_assign.warningsubmissionmodified'));\n        return _this5.deleteSubmissionData(assign, offlineData, submission, siteId);\n      }\n      try {\n        if (submission !== null && submission !== void 0 && submission.plugins) {\n          // Prepare plugins data.\n          yield Promise.all(submission.plugins.map(plugin => AddonModAssignSubmissionDelegate.preparePluginSyncData(assign, submission, plugin, offlineData, pluginData, siteId)));\n        }\n        // Now save the submission.\n        if (Object.keys(pluginData).length > 0) {\n          yield AddonModAssign.saveSubmissionOnline(assign.id, pluginData, siteId);\n        }\n        if (assign.submissiondrafts && offlineData.submitted) {\n          // The user submitted the assign manually. Submit it for grading.\n          yield AddonModAssign.submitForGradingOnline(assign.id, !!offlineData.submissionstatement, siteId);\n        }\n        // Submission data sent, update cached data. No need to block the user for this.\n        AddonModAssign.getSubmissionStatus(assign.id, options);\n      } catch (error) {\n        if (!error || !CoreUtils.isWebServiceError(error)) {\n          // Local error, reject.\n          throw error;\n        }\n        // A WebService has thrown an error, this means it cannot be submitted. Discard the submission.\n        _this5.addOfflineDataDeletedWarning(warnings, assign.name, error);\n      }\n      // Delete the offline data.\n      yield _this5.deleteSubmissionData(assign, offlineData, submission, siteId);\n    })();\n  }\n  /**\n   * Delete the submission offline data (not grades).\n   *\n   * @param assign Assign.\n   * @param offlineData Offline data.\n   * @param submission Submission.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  deleteSubmissionData(assign, offlineData, submission, siteId) {\n    return _asyncToGenerator(function* () {\n      // Delete the offline data.\n      yield AddonModAssignOffline.deleteSubmission(assign.id, offlineData.userid, siteId);\n      if (submission !== null && submission !== void 0 && submission.plugins) {\n        // Delete plugins data.\n        yield Promise.all(submission.plugins.map(plugin => AddonModAssignSubmissionDelegate.deletePluginOfflineData(assign, submission, plugin, offlineData, siteId)));\n      }\n    })();\n  }\n  /**\n   * Synchronize a submission grade.\n   *\n   * @param assign Assignment.\n   * @param offlineData Submission grade offline data.\n   * @param warnings List of warnings.\n   * @param courseId Course Id.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  syncSubmissionGrade(assign, offlineData, warnings, courseId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      var _status$feedback$grad;\n      const userId = offlineData.userid;\n      const syncId = _this6.getGradeSyncId(assign.id, userId);\n      const options = {\n        userId,\n        cmId: assign.cmid,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      // Check if this grade sync is blocked.\n      if (CoreSync.isBlocked(AddonModAssignProvider.COMPONENT, syncId, siteId)) {\n        _this6.logger.error(`Cannot sync grade for assign ${assign.id} and user ${userId} because it is blocked.!!!!`);\n        throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', {\n          $a: Translate.instant('addon.mod_assign.syncblockedusercomponent')\n        }));\n      }\n      const status = yield AddonModAssign.getSubmissionStatus(assign.id, options);\n      const timemodified = status.feedback && (status.feedback.gradeddate || ((_status$feedback$grad = status.feedback.grade) === null || _status$feedback$grad === void 0 ? void 0 : _status$feedback$grad.timemodified)) || 0;\n      if (timemodified > offlineData.timemodified) {\n        // The submission grade was modified in Moodle, discard it.\n        _this6.addOfflineDataDeletedWarning(warnings, assign.name, Translate.instant('addon.mod_assign.warningsubmissiongrademodified'));\n        return AddonModAssignOffline.deleteSubmissionGrade(assign.id, userId, siteId);\n      }\n      // If grade has been modified from gradebook, do not use offline.\n      const grades = yield CoreGradesHelper.getGradeModuleItems(courseId, assign.cmid, userId, undefined, siteId, true);\n      const gradeInfo = yield CoreCourse.getModuleBasicGradeInfo(assign.cmid, siteId);\n      // Override offline grade and outcomes based on the gradebook data.\n      grades.forEach(grade => {\n        if ((grade.gradedategraded || 0) >= offlineData.timemodified) {\n          if (!grade.outcomeid && !grade.scaleid) {\n            if (gradeInfo && gradeInfo.scale) {\n              offlineData.grade = _this6.getSelectedScaleId(gradeInfo.scale, grade.grade || '');\n            } else {\n              offlineData.grade = parseFloat(grade.grade || '');\n            }\n          } else if (gradeInfo && grade.outcomeid && gradeInfo.outcomes) {\n            gradeInfo.outcomes.forEach((outcome, index) => {\n              if (outcome.scale && grade.itemnumber == index) {\n                offlineData.outcomes[grade.itemnumber] = _this6.getSelectedScaleId(outcome.scale, grade.grade || '');\n              }\n            });\n          }\n        }\n      });\n      try {\n        // Now submit the grade.\n        yield AddonModAssign.submitGradingFormOnline(assign.id, userId, offlineData.grade, offlineData.attemptnumber, !!offlineData.addattempt, offlineData.workflowstate, !!offlineData.applytoall, offlineData.outcomes, offlineData.plugindata, siteId);\n        // Grades sent. Discard grades drafts.\n        let promises = [];\n        if (status.feedback && status.feedback.plugins) {\n          promises = status.feedback.plugins.map(plugin => AddonModAssignFeedbackDelegate.discardPluginFeedbackData(assign.id, userId, plugin, siteId));\n        }\n        // Update cached data.\n        promises.push(AddonModAssign.getSubmissionStatus(assign.id, options));\n        yield CoreUtils.allPromises(promises);\n      } catch (error) {\n        if (!error || !CoreUtils.isWebServiceError(error)) {\n          // Local error, reject.\n          throw error;\n        }\n        // A WebService has thrown an error, this means it cannot be submitted. Discard the submission.\n        _this6.addOfflineDataDeletedWarning(warnings, assign.name, error);\n      }\n      // Delete the offline data.\n      yield AddonModAssignOffline.deleteSubmissionGrade(assign.id, userId, siteId);\n    })();\n  }\n}\n_class = AddonModAssignSyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_assign_autom_synced';\n_class.MANUAL_SYNCED = 'addon_mod_assign_manual_synced';\n_class.ɵfac = function AddonModAssignSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModAssignSync = makeSingleton(AddonModAssignSyncProvider);","map":{"version":3,"names":["CoreEvents","CoreSites","CoreSyncBlockedError","AddonModAssignProvider","AddonModAssign","makeSingleton","Translate","CoreCourse","CoreCourseActivitySyncBaseProvider","AddonModAssignOffline","CoreSync","CoreCourseLogHelper","CoreUtils","CoreNetwork","CoreNetworkError","CoreGradesHelper","AddonModAssignSubmissionDelegate","AddonModAssignFeedbackDelegate","AddonModAssignSyncProvider","constructor","componentTranslatableString","getGradeSyncId","assignId","userId","getSelectedScaleId","options","selected","optionsList","split","map","value","trim","unshift","index","indexOf","hasDataToSync","siteId","hasAssignOfflineData","syncAllAssignments","force","syncOnSites","syncAllAssignmentsFunc","_this","_asyncToGenerator","assignIds","getAllAssigns","Promise","all","_ref","result","syncAssign","syncAssignIfNeeded","updated","trigger","AUTO_SYNCED","warnings","gradesBlocked","_x","apply","arguments","_this2","needed","isSyncNeeded","_this3","getCurrentSiteId","currentSyncPromise","getOngoingSync","isBlocked","COMPONENT","logger","debug","instant","$a","componentTranslate","syncPromise","performSyncAssign","addOngoingSync","_this4","ignoreErrors","syncActivity","submissions","grades","getOfflineSubmissions","getOfflineGrades","length","setSyncTime","isOnline","courseId","courseid","assign","getAssignmentById","promises","concat","_ref2","submission","syncSubmission","_x2","_ref3","grade","syncSubmissionGrade","error","push","userid","_x3","allPromises","invalidateContent","cmid","getAssignSubmissionsGrade","getAssignSubmissions","offlineData","_this5","pluginData","cmId","readingStrategy","status","getSubmissionStatus","id","getSubmissionObjectFromAttempt","lastattempt","timemodified","onlinetimemodified","addOfflineDataDeletedWarning","name","deleteSubmissionData","plugins","plugin","preparePluginSyncData","Object","keys","saveSubmissionOnline","submissiondrafts","submitted","submitForGradingOnline","submissionstatement","isWebServiceError","deleteSubmission","deletePluginOfflineData","_this6","_status$feedback$grad","syncId","feedback","gradeddate","deleteSubmissionGrade","getGradeModuleItems","undefined","gradeInfo","getModuleBasicGradeInfo","forEach","gradedategraded","outcomeid","scaleid","scale","parseFloat","outcomes","outcome","itemnumber","submitGradingFormOnline","attemptnumber","addattempt","workflowstate","applytoall","plugindata","discardPluginFeedbackData","_class","MANUAL_SYNCED","factory","ɵfac","providedIn","AddonModAssignSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/assign/services/assign-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport {\n    AddonModAssignProvider,\n    AddonModAssignAssign,\n    AddonModAssignSubmission,\n    AddonModAssign,\n    AddonModAssignGetSubmissionStatusWSResponse,\n    AddonModAssignSubmissionStatusOptions,\n} from './assign';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport {\n    AddonModAssignOffline,\n    AddonModAssignSubmissionsDBRecordFormatted,\n    AddonModAssignSubmissionsGradingDBRecordFormatted,\n} from './assign-offline';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreNetwork } from '@services/network';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreGradesFormattedItem, CoreGradesHelper } from '@features/grades/services/grades-helper';\nimport { AddonModAssignSubmissionDelegate } from './submission-delegate';\nimport { AddonModAssignFeedbackDelegate } from './feedback-delegate';\n\n/**\n * Service to sync assigns.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModAssignSyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModAssignSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_assign_autom_synced';\n    static readonly MANUAL_SYNCED = 'addon_mod_assign_manual_synced';\n\n    protected componentTranslatableString = 'assign';\n\n    constructor() {\n        super('AddonModAssignSyncProvider');\n    }\n\n    /**\n     * Get the sync ID for a certain user grade.\n     *\n     * @param assignId Assign ID.\n     * @param userId User the grade belongs to.\n     * @returns Sync ID.\n     */\n    getGradeSyncId(assignId: number, userId: number): string {\n        return 'assignGrade#' + assignId + '#' + userId;\n    }\n\n    /**\n     * Convenience function to get scale selected option.\n     *\n     * @param options Possible options.\n     * @param selected Selected option to search.\n     * @returns Index of the selected option.\n     */\n    protected getSelectedScaleId(options: string, selected: string): number {\n        let optionsList = options.split(',');\n\n        optionsList = optionsList.map((value) => value.trim());\n\n        optionsList.unshift('');\n\n        const index = options.indexOf(selected) || 0;\n        if (index < 0) {\n            return 0;\n        }\n\n        return index;\n    }\n\n    /**\n     * Check if an assignment has data to synchronize.\n     *\n     * @param assignId Assign ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it has data to sync.\n     */\n    hasDataToSync(assignId: number, siteId?: string): Promise<boolean> {\n        return AddonModAssignOffline.hasAssignOfflineData(assignId, siteId);\n    }\n\n    /**\n     * Try to synchronize all the assignments in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllAssignments(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all assignments', (siteId) => this.syncAllAssignmentsFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all assignments on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllAssignmentsFunc(force: boolean, siteId: string): Promise<void> {\n        // Get all assignments that have offline data.\n        const assignIds = await AddonModAssignOffline.getAllAssigns(siteId);\n\n        // Try to sync all assignments.\n        await Promise.all(assignIds.map(async (assignId) => {\n            const result = force\n                ? await this.syncAssign(assignId, siteId)\n                : await this.syncAssignIfNeeded(assignId, siteId);\n\n            if (result?.updated) {\n                CoreEvents.trigger(AddonModAssignSyncProvider.AUTO_SYNCED, {\n                    assignId: assignId,\n                    warnings: result.warnings,\n                    gradesBlocked: result.gradesBlocked,\n                }, siteId);\n            }\n        }));\n    }\n\n    /**\n     * Sync an assignment only if a certain time has passed since the last time.\n     *\n     * @param assignId Assign ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the assign is synced or it doesn't need to be synced.\n     */\n    async syncAssignIfNeeded(assignId: number, siteId?: string): Promise<AddonModAssignSyncResult | undefined> {\n        const needed = await this.isSyncNeeded(assignId, siteId);\n\n        if (needed) {\n            return this.syncAssign(assignId, siteId);\n        }\n    }\n\n    /**\n     * Try to synchronize an assign.\n     *\n     * @param assignId Assign ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success.\n     */\n    async syncAssign(assignId: number, siteId?: string): Promise<AddonModAssignSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(assignId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this assign, return the promise.\n            return currentSyncPromise;\n        }\n\n        // Verify that assign isn't blocked.\n        if (CoreSync.isBlocked(AddonModAssignProvider.COMPONENT, assignId, siteId)) {\n            this.logger.debug('Cannot sync assign ' + assignId + ' because it is blocked.');\n\n            throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));\n        }\n\n        this.logger.debug('Try to sync assign ' + assignId + ' in site ' + siteId);\n\n        const syncPromise = this.performSyncAssign(assignId, siteId);\n\n        return this.addOngoingSync(assignId, syncPromise, siteId);\n    }\n\n    /**\n     * Perform the assign submission.\n     *\n     * @param assignId Assign ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved in success.\n     */\n    protected async performSyncAssign(assignId: number, siteId: string): Promise<AddonModAssignSyncResult> {\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(\n            CoreCourseLogHelper.syncActivity(AddonModAssignProvider.COMPONENT, assignId, siteId),\n        );\n\n        const result: AddonModAssignSyncResult = {\n            warnings: [],\n            updated: false,\n            gradesBlocked: [],\n        };\n\n        // Load offline data and sync offline logs.\n        const [submissions, grades] = await Promise.all([\n            this.getOfflineSubmissions(assignId, siteId),\n            this.getOfflineGrades(assignId, siteId),\n        ]);\n\n        if (!submissions.length && !grades.length) {\n            // Nothing to sync.\n            await CoreUtils.ignoreErrors(this.setSyncTime(assignId, siteId));\n\n            return result;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        const courseId = submissions.length > 0 ? submissions[0].courseid : grades[0].courseid;\n\n        const assign = await AddonModAssign.getAssignmentById(courseId, assignId, { siteId });\n\n        let promises: Promise<void>[] = [];\n\n        promises = promises.concat(submissions.map(async (submission) => {\n            await this.syncSubmission(assign, submission, result.warnings, siteId);\n\n            result.updated = true;\n\n            return;\n        }));\n\n        promises = promises.concat(grades.map(async (grade) => {\n            try {\n                await this.syncSubmissionGrade(assign, grade, result.warnings, courseId, siteId);\n\n                result.updated = true;\n            } catch (error) {\n                if (error instanceof CoreSyncBlockedError) {\n                    // Grade blocked, but allow finish the sync.\n                    result.gradesBlocked.push(grade.userid);\n                } else {\n                    throw error;\n                }\n            }\n        }));\n\n        await CoreUtils.allPromises(promises);\n\n        if (result.updated) {\n            // Data has been sent to server. Now invalidate the WS calls.\n            await CoreUtils.ignoreErrors(AddonModAssign.invalidateContent(assign.cmid, courseId, siteId));\n        }\n\n        // Sync finished, set sync time.\n        await CoreUtils.ignoreErrors(this.setSyncTime(assignId, siteId));\n\n        // All done, return the result.\n        return result;\n    }\n\n    /**\n     * Get offline grades to be sent.\n     *\n     * @param assignId Assign ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise with grades.\n     */\n    protected async getOfflineGrades(\n        assignId: number,\n        siteId: string,\n    ): Promise<AddonModAssignSubmissionsGradingDBRecordFormatted[]> {\n        // If no offline data found, return empty array.\n        return CoreUtils.ignoreErrors(AddonModAssignOffline.getAssignSubmissionsGrade(assignId, siteId), []);\n    }\n\n    /**\n     * Get offline submissions to be sent.\n     *\n     * @param assignId Assign ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise with submissions.\n     */\n    protected async getOfflineSubmissions(\n        assignId: number,\n        siteId: string,\n    ): Promise<AddonModAssignSubmissionsDBRecordFormatted[]> {\n        // If no offline data found, return empty array.\n        return CoreUtils.ignoreErrors(AddonModAssignOffline.getAssignSubmissions(assignId, siteId), []);\n    }\n\n    /**\n     * Synchronize a submission.\n     *\n     * @param assign Assignment.\n     * @param offlineData Submission offline data.\n     * @param warnings List of warnings.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    protected async syncSubmission(\n        assign: AddonModAssignAssign,\n        offlineData: AddonModAssignSubmissionsDBRecordFormatted,\n        warnings: string[],\n        siteId: string,\n    ): Promise<void> {\n\n        const userId = offlineData.userid;\n        const pluginData = {};\n        const options: AddonModAssignSubmissionStatusOptions = {\n            userId,\n            cmId: assign.cmid,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        const status = await AddonModAssign.getSubmissionStatus(assign.id, options);\n\n        const submission = AddonModAssign.getSubmissionObjectFromAttempt(assign, status.lastattempt);\n\n        if (submission && submission.timemodified != offlineData.onlinetimemodified) {\n            // The submission was modified in Moodle, discard the submission.\n            this.addOfflineDataDeletedWarning(\n                warnings,\n                assign.name,\n                Translate.instant('addon.mod_assign.warningsubmissionmodified'),\n            );\n\n            return this.deleteSubmissionData(assign, offlineData, submission, siteId);\n        }\n\n        try {\n            if (submission?.plugins) {\n                // Prepare plugins data.\n                await Promise.all(submission.plugins.map((plugin) =>\n                    AddonModAssignSubmissionDelegate.preparePluginSyncData(\n                        assign,\n                        submission,\n                        plugin,\n                        offlineData,\n                        pluginData,\n                        siteId,\n                    )));\n            }\n\n            // Now save the submission.\n            if (Object.keys(pluginData).length > 0) {\n                await AddonModAssign.saveSubmissionOnline(assign.id, pluginData, siteId);\n            }\n\n            if (assign.submissiondrafts && offlineData.submitted) {\n                // The user submitted the assign manually. Submit it for grading.\n                await AddonModAssign.submitForGradingOnline(assign.id, !!offlineData.submissionstatement, siteId);\n            }\n\n            // Submission data sent, update cached data. No need to block the user for this.\n            AddonModAssign.getSubmissionStatus(assign.id, options);\n        } catch (error) {\n            if (!error || !CoreUtils.isWebServiceError(error)) {\n                // Local error, reject.\n                throw error;\n            }\n\n            // A WebService has thrown an error, this means it cannot be submitted. Discard the submission.\n            this.addOfflineDataDeletedWarning(warnings, assign.name, error);\n        }\n\n        // Delete the offline data.\n        await this.deleteSubmissionData(assign, offlineData, submission, siteId);\n    }\n\n    /**\n     * Delete the submission offline data (not grades).\n     *\n     * @param assign Assign.\n     * @param offlineData Offline data.\n     * @param submission Submission.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async deleteSubmissionData(\n        assign: AddonModAssignAssign,\n        offlineData: AddonModAssignSubmissionsDBRecordFormatted,\n        submission?: AddonModAssignSubmission,\n        siteId?: string,\n    ): Promise<void> {\n\n        // Delete the offline data.\n        await AddonModAssignOffline.deleteSubmission(assign.id, offlineData.userid, siteId);\n\n        if (submission?.plugins){\n            // Delete plugins data.\n            await Promise.all(submission.plugins.map((plugin) =>\n                AddonModAssignSubmissionDelegate.deletePluginOfflineData(\n                    assign,\n                    submission,\n                    plugin,\n                    offlineData,\n                    siteId,\n                )));\n        }\n    }\n\n    /**\n     * Synchronize a submission grade.\n     *\n     * @param assign Assignment.\n     * @param offlineData Submission grade offline data.\n     * @param warnings List of warnings.\n     * @param courseId Course Id.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    protected async syncSubmissionGrade(\n        assign: AddonModAssignAssign,\n        offlineData: AddonModAssignSubmissionsGradingDBRecordFormatted,\n        warnings: string[],\n        courseId: number,\n        siteId: string,\n    ): Promise<void> {\n\n        const userId = offlineData.userid;\n        const syncId = this.getGradeSyncId(assign.id, userId);\n        const options: AddonModAssignSubmissionStatusOptions = {\n            userId,\n            cmId: assign.cmid,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        // Check if this grade sync is blocked.\n        if (CoreSync.isBlocked(AddonModAssignProvider.COMPONENT, syncId, siteId)) {\n            this.logger.error(`Cannot sync grade for assign ${assign.id} and user ${userId} because it is blocked.!!!!`);\n\n            throw new CoreSyncBlockedError(Translate.instant(\n                'core.errorsyncblocked',\n                { $a: Translate.instant('addon.mod_assign.syncblockedusercomponent') },\n            ));\n        }\n\n        const status = await AddonModAssign.getSubmissionStatus(assign.id, options);\n\n        const timemodified = (status.feedback && (status.feedback.gradeddate || status.feedback.grade?.timemodified)) || 0;\n\n        if (timemodified > offlineData.timemodified) {\n            // The submission grade was modified in Moodle, discard it.\n            this.addOfflineDataDeletedWarning(\n                warnings,\n                assign.name,\n                Translate.instant('addon.mod_assign.warningsubmissiongrademodified'),\n            );\n\n            return AddonModAssignOffline.deleteSubmissionGrade(assign.id, userId, siteId);\n        }\n\n        // If grade has been modified from gradebook, do not use offline.\n        const grades = await CoreGradesHelper.getGradeModuleItems(courseId, assign.cmid, userId, undefined, siteId, true);\n\n        const gradeInfo = await CoreCourse.getModuleBasicGradeInfo(assign.cmid, siteId);\n\n        // Override offline grade and outcomes based on the gradebook data.\n        grades.forEach((grade: CoreGradesFormattedItem) => {\n            if ((grade.gradedategraded || 0) >= offlineData.timemodified) {\n                if (!grade.outcomeid && !grade.scaleid) {\n                    if (gradeInfo && gradeInfo.scale) {\n                        offlineData.grade = this.getSelectedScaleId(gradeInfo.scale, grade.grade || '');\n                    } else {\n                        offlineData.grade = parseFloat(grade.grade || '');\n                    }\n                } else if (gradeInfo && grade.outcomeid && gradeInfo.outcomes) {\n                    gradeInfo.outcomes.forEach((outcome, index) => {\n                        if (outcome.scale && grade.itemnumber == index) {\n                            offlineData.outcomes[grade.itemnumber] = this.getSelectedScaleId(\n                                outcome.scale,\n                                grade.grade || '',\n                            );\n                        }\n                    });\n                }\n            }\n        });\n\n        try {\n            // Now submit the grade.\n            await AddonModAssign.submitGradingFormOnline(\n                assign.id,\n                userId,\n                offlineData.grade,\n                offlineData.attemptnumber,\n                !!offlineData.addattempt,\n                offlineData.workflowstate,\n                !!offlineData.applytoall,\n                offlineData.outcomes,\n                offlineData.plugindata,\n                siteId,\n            );\n\n            // Grades sent. Discard grades drafts.\n            let promises: Promise<void | AddonModAssignGetSubmissionStatusWSResponse>[] = [];\n            if (status.feedback && status.feedback.plugins) {\n                promises = status.feedback.plugins.map((plugin) =>\n                    AddonModAssignFeedbackDelegate.discardPluginFeedbackData(assign.id, userId, plugin, siteId));\n            }\n\n            // Update cached data.\n            promises.push(AddonModAssign.getSubmissionStatus(assign.id, options));\n\n            await CoreUtils.allPromises(promises);\n        } catch (error) {\n            if (!error || !CoreUtils.isWebServiceError(error)) {\n                // Local error, reject.\n                throw error;\n            }\n\n            // A WebService has thrown an error, this means it cannot be submitted. Discard the submission.\n            this.addOfflineDataDeletedWarning(warnings, assign.name, error);\n        }\n\n        // Delete the offline data.\n        await AddonModAssignOffline.deleteSubmissionGrade(assign.id, userId, siteId);\n    }\n\n}\nexport const AddonModAssignSync = makeSingleton(AddonModAssignSyncProvider);\n\n/**\n * Data returned by a assign sync.\n */\nexport type AddonModAssignSyncResult = CoreSyncResult & {\n    courseId?: number; // Course the assign belongs to (if known).\n    gradesBlocked: number[]; // Whether some grade couldn't be synced because it was blocked. UserId fields of the blocked grade.\n};\n\n/**\n * Data passed to AUTO_SYNCED event.\n */\nexport type AddonModAssignAutoSyncData = {\n    assignId: number;\n    warnings: string[];\n    gradesBlocked: number[]; // Whether some grade couldn't be synced because it was blocked. UserId fields of the blocked grade.\n};\n\n/**\n * Data passed to MANUAL_SYNCED event.\n */\nexport type AddonModAssignManualSyncData = AddonModAssignAutoSyncData & {\n    context: string;\n    submitId?: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}