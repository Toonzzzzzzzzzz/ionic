{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreGroups } from '@services/groups';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { AddonModFeedback, AddonModFeedbackProvider } from '../feedback';\nimport { AddonModFeedbackSync } from '../feedback-sync';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to prefetch feedbacks.\n */\nexport class AddonModFeedbackPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n  constructor() {\n    super(...arguments);\n    this.name = 'AddonModFeedback';\n    this.modName = 'feedback';\n    this.component = AddonModFeedbackProvider.COMPONENT;\n    this.updatesNames = /^configuration$|^.*files$|^attemptsfinished|^attemptsunfinished$/;\n  }\n  /**\n   * @inheritdoc\n   */\n  getFiles(module, courseId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let files = [];\n      const feedback = yield AddonModFeedback.getFeedback(courseId, module.id);\n      // Get intro files and page after submit files.\n      files = feedback.pageaftersubmitfiles || [];\n      files = files.concat(_this.getIntroFilesFromInstance(module, feedback));\n      try {\n        const response = yield AddonModFeedback.getItems(feedback.id);\n        response.items.forEach(item => {\n          files = files.concat(item.itemfiles);\n        });\n      } catch (e) {\n        // Ignore errors.\n      }\n      return files;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  getIntroFiles(module, courseId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const feedback = yield CoreUtils.ignoreErrors(AddonModFeedback.getFeedback(courseId, module.id));\n      return _this2.getIntroFilesFromInstance(module, feedback);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateContent(moduleId, courseId) {\n    return AddonModFeedback.invalidateContent(moduleId, courseId);\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateModule(module, courseId) {\n    return AddonModFeedback.invalidateFeedbackData(courseId);\n  }\n  /**\n   * @inheritdoc\n   */\n  isDownloadable(module, courseId) {\n    return _asyncToGenerator(function* () {\n      const feedback = yield AddonModFeedback.getFeedback(courseId, module.id);\n      const now = CoreTimeUtils.timestamp();\n      // Check time first if available.\n      if (feedback.timeopen && feedback.timeopen > now) {\n        return false;\n      }\n      if (feedback.timeclose && feedback.timeclose < now) {\n        return false;\n      }\n      const accessData = yield AddonModFeedback.getFeedbackAccessInformation(feedback.id, {\n        cmId: module.id\n      });\n      return accessData.isopen;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  prefetch(module, courseId) {\n    return this.prefetchPackage(module, courseId, siteId => this.prefetchFeedback(module, courseId, siteId));\n  }\n  /**\n   * Prefetch a feedback.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  prefetchFeedback(module, courseId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const commonOptions = {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      const modOptions = _objectSpread({\n        cmId: module.id\n      }, commonOptions);\n      // Prefetch the feedback data.\n      const feedback = yield AddonModFeedback.getFeedback(courseId, module.id, commonOptions);\n      let files = feedback.pageaftersubmitfiles || [];\n      files = files.concat(_this3.getIntroFilesFromInstance(module, feedback));\n      const accessData = yield AddonModFeedback.getFeedbackAccessInformation(feedback.id, modOptions);\n      const promises = [];\n      if (accessData.canedititems || accessData.canviewreports) {\n        // Get all groups analysis.\n        promises.push(AddonModFeedback.getAnalysis(feedback.id, modOptions));\n        promises.push(_this3.prefetchAllGroupsAnalysis(feedback, accessData, modOptions));\n      }\n      promises.push(AddonModFeedback.getItems(feedback.id, commonOptions).then(response => {\n        response.items.forEach(item => {\n          files = files.concat(item.itemfiles);\n        });\n        return CoreFilepool.addFilesToQueue(siteId, files, _this3.component, module.id);\n      }));\n      if (accessData.cancomplete && accessData.cansubmit && !accessData.isempty) {\n        // Send empty data, so it will recover last completed feedback attempt values.\n        promises.push(AddonModFeedback.processPageOnline(feedback.id, 0, {}, false, siteId).then(() => Promise.all([AddonModFeedback.getCurrentValues(feedback.id, modOptions), AddonModFeedback.getResumePage(feedback.id, modOptions)])));\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Prefetch all groups analysis.\n   *\n   * @param feedback Feedback.\n   * @param accessData Access info.\n   * @param modOptions Options.\n   */\n  prefetchAllGroupsAnalysis(feedback, accessData, modOptions) {\n    return _asyncToGenerator(function* () {\n      const groupInfo = yield CoreGroups.getActivityGroupInfo(feedback.coursemodule, true, undefined, modOptions.siteId, true);\n      const promises = [];\n      if (!groupInfo.groups || groupInfo.groups.length == 0) {\n        groupInfo.groups = [{\n          id: 0,\n          name: ''\n        }];\n      }\n      groupInfo.groups.forEach(group => {\n        const groupOptions = _objectSpread({\n          groupId: group.id\n        }, modOptions);\n        promises.push(AddonModFeedback.getAnalysis(feedback.id, groupOptions));\n        promises.push(AddonModFeedback.getAllResponsesAnalysis(feedback.id, groupOptions));\n        if (!accessData.isanonymous) {\n          promises.push(AddonModFeedback.getAllNonRespondents(feedback.id, groupOptions));\n        }\n      });\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  sync(module, courseId, siteId) {\n    return AddonModFeedbackSync.syncFeedback(module.instance, siteId);\n  }\n}\n_class = AddonModFeedbackPrefetchHandlerService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵAddonModFeedbackPrefetchHandlerService_BaseFactory;\n  return function AddonModFeedbackPrefetchHandlerService_Factory(t) {\n    return (ɵAddonModFeedbackPrefetchHandlerService_BaseFactory || (ɵAddonModFeedbackPrefetchHandlerService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModFeedbackPrefetchHandler = makeSingleton(AddonModFeedbackPrefetchHandlerService);","map":{"version":3,"names":["CoreCourseActivityPrefetchHandlerBase","CoreFilepool","CoreGroups","CoreTimeUtils","CoreUtils","makeSingleton","AddonModFeedback","AddonModFeedbackProvider","AddonModFeedbackSync","AddonModFeedbackPrefetchHandlerService","constructor","name","modName","component","COMPONENT","updatesNames","getFiles","module","courseId","_this","_asyncToGenerator","files","feedback","getFeedback","id","pageaftersubmitfiles","concat","getIntroFilesFromInstance","response","getItems","items","forEach","item","itemfiles","e","getIntroFiles","_this2","ignoreErrors","invalidateContent","moduleId","invalidateModule","invalidateFeedbackData","isDownloadable","now","timestamp","timeopen","timeclose","accessData","getFeedbackAccessInformation","cmId","isopen","prefetch","prefetchPackage","siteId","prefetchFeedback","_this3","commonOptions","readingStrategy","modOptions","_objectSpread","promises","canedititems","canviewreports","push","getAnalysis","prefetchAllGroupsAnalysis","then","addFilesToQueue","cancomplete","cansubmit","isempty","processPageOnline","Promise","all","getCurrentValues","getResumePage","groupInfo","getActivityGroupInfo","coursemodule","undefined","groups","length","group","groupOptions","groupId","getAllResponsesAnalysis","isanonymous","getAllNonRespondents","sync","syncFeedback","instance","t","factory","ɵfac","providedIn","AddonModFeedbackPrefetchHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/feedback/services/handlers/prefetch.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourseAnyModuleData, CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreGroups } from '@services/groups';\nimport { CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport {\n    AddonModFeedback,\n    AddonModFeedbackGetFeedbackAccessInformationWSResponse,\n    AddonModFeedbackProvider,\n    AddonModFeedbackWSFeedback,\n} from '../feedback';\nimport { AddonModFeedbackSync, AddonModFeedbackSyncResult } from '../feedback-sync';\n\n/**\n * Handler to prefetch feedbacks.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModFeedbackPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n\n    name = 'AddonModFeedback';\n    modName = 'feedback';\n    component = AddonModFeedbackProvider.COMPONENT;\n    updatesNames = /^configuration$|^.*files$|^attemptsfinished|^attemptsunfinished$/;\n\n    /**\n     * @inheritdoc\n     */\n    async getFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<CoreWSFile[]> {\n        let files: CoreWSFile[] = [];\n\n        const feedback = await AddonModFeedback.getFeedback(courseId, module.id);\n\n        // Get intro files and page after submit files.\n        files = feedback.pageaftersubmitfiles || [];\n        files = files.concat(this.getIntroFilesFromInstance(module, feedback));\n\n        try {\n            const response = await AddonModFeedback.getItems(feedback.id);\n\n            response.items.forEach((item) => {\n                files = files.concat(item.itemfiles);\n            });\n        } catch (e) {\n            // Ignore errors.\n        }\n\n        return files;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getIntroFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<CoreWSFile[]> {\n        const feedback = await CoreUtils.ignoreErrors(AddonModFeedback.getFeedback(courseId, module.id));\n\n        return this.getIntroFilesFromInstance(module, feedback);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        return AddonModFeedback.invalidateContent(moduleId, courseId);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    invalidateModule(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        return AddonModFeedback.invalidateFeedbackData(courseId);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async isDownloadable(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        const feedback = await AddonModFeedback.getFeedback(courseId, module.id);\n\n        const now = CoreTimeUtils.timestamp();\n\n        // Check time first if available.\n        if (feedback.timeopen && feedback.timeopen > now) {\n            return false;\n        }\n        if (feedback.timeclose && feedback.timeclose < now) {\n            return false;\n        }\n\n        const accessData = await AddonModFeedback.getFeedbackAccessInformation(feedback.id, { cmId: module.id });\n\n        return accessData.isopen;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    prefetch(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        return this.prefetchPackage(module, courseId, (siteId) => this.prefetchFeedback(module, courseId, siteId));\n    }\n\n    /**\n     * Prefetch a feedback.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchFeedback(module: CoreCourseAnyModuleData, courseId: number, siteId: string): Promise<void> {\n        const commonOptions = {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n        const modOptions = {\n            cmId: module.id,\n            ...commonOptions, // Include all common options.\n        };\n\n        // Prefetch the feedback data.\n        const feedback = await AddonModFeedback.getFeedback(courseId, module.id, commonOptions);\n\n        let files: CoreWSFile[] = feedback.pageaftersubmitfiles || [];\n        files = files.concat(this.getIntroFilesFromInstance(module, feedback));\n\n        const accessData = await AddonModFeedback.getFeedbackAccessInformation(feedback.id, modOptions);\n\n        const promises: Promise<unknown>[] = [];\n\n        if (accessData.canedititems || accessData.canviewreports) {\n            // Get all groups analysis.\n            promises.push(AddonModFeedback.getAnalysis(feedback.id, modOptions));\n            promises.push(this.prefetchAllGroupsAnalysis(feedback, accessData, modOptions));\n        }\n\n        promises.push(AddonModFeedback.getItems(feedback.id, commonOptions).then((response) => {\n            response.items.forEach((item) => {\n                files = files.concat(item.itemfiles);\n            });\n\n            return CoreFilepool.addFilesToQueue(siteId, files, this.component, module.id);\n        }));\n\n        if (accessData.cancomplete && accessData.cansubmit && !accessData.isempty) {\n            // Send empty data, so it will recover last completed feedback attempt values.\n            promises.push(AddonModFeedback.processPageOnline(feedback.id, 0, {}, false, siteId).then(() => Promise.all([\n                AddonModFeedback.getCurrentValues(feedback.id, modOptions),\n                AddonModFeedback.getResumePage(feedback.id, modOptions),\n            ])));\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Prefetch all groups analysis.\n     *\n     * @param feedback Feedback.\n     * @param accessData Access info.\n     * @param modOptions Options.\n     */\n    protected async prefetchAllGroupsAnalysis(\n        feedback: AddonModFeedbackWSFeedback,\n        accessData: AddonModFeedbackGetFeedbackAccessInformationWSResponse,\n        modOptions: CoreCourseCommonModWSOptions,\n    ): Promise<void> {\n        const groupInfo = await CoreGroups.getActivityGroupInfo(feedback.coursemodule, true, undefined, modOptions.siteId, true);\n\n        const promises: Promise<unknown>[] = [];\n\n        if (!groupInfo.groups || groupInfo.groups.length == 0) {\n            groupInfo.groups = [{ id: 0, name: '' }];\n        }\n\n        groupInfo.groups.forEach((group) => {\n            const groupOptions = {\n                groupId: group.id,\n                ...modOptions, // Include all mod options.\n            };\n\n            promises.push(AddonModFeedback.getAnalysis(feedback.id, groupOptions));\n            promises.push(AddonModFeedback.getAllResponsesAnalysis(feedback.id, groupOptions));\n\n            if (!accessData.isanonymous) {\n                promises.push(AddonModFeedback.getAllNonRespondents(feedback.id, groupOptions));\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    sync(module: CoreCourseAnyModuleData, courseId: number, siteId?: string): Promise<AddonModFeedbackSyncResult> {\n        return AddonModFeedbackSync.syncFeedback(module.instance, siteId);\n    }\n\n}\n\nexport const AddonModFeedbackPrefetchHandler = makeSingleton(AddonModFeedbackPrefetchHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}