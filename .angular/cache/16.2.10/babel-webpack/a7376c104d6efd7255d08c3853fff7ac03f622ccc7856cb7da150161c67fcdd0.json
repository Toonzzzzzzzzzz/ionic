{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreFilterDelegate } from './filter-delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to provide filter functionalities.\n */\nexport class CoreFilterProvider {\n  constructor() {\n    this.ROOT_CACHE_KEY = 'mmFilter:';\n    /**\n     * Store the contexts in memory to speed up the process, it can take a lot of time otherwise.\n     */\n    this.contextsCache = {};\n    this.logger = CoreLogger.getInstance('CoreFilterProvider');\n    CoreEvents.on(CoreEvents.WS_CACHE_INVALIDATED, data => {\n      delete this.contextsCache[data.siteId || ''];\n    });\n    CoreEvents.on(CoreEvents.SITE_STORAGE_DELETED, data => {\n      delete this.contextsCache[data.siteId || ''];\n    });\n  }\n  /**\n   * Returns whether or not we can get the available filters: the WS is available and the feature isn't disabled.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whethe can get filters.\n   */\n  canGetFilters(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const disabled = yield _this.checkFiltersDisabled(siteId);\n      return !disabled;\n    })();\n  }\n  /**\n   * Returns whether or not we can get the available filters: the WS is available and the feature isn't disabled.\n   *\n   * @param site Site. If not defined, current site.\n   * @returns Promise resolved with boolean: whethe can get filters.\n   */\n  canGetFiltersInSite(site) {\n    return this.checkFiltersDisabledInSite(site);\n  }\n  /**\n   * Returns whether or not checking the available filters is disabled in the site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it's disabled.\n   */\n  checkFiltersDisabled(siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this2.checkFiltersDisabledInSite(site);\n    })();\n  }\n  /**\n   * Returns whether or not checking the available filters is disabled in the site.\n   *\n   * @param site Site. If not defined, current site.\n   * @returns Whether it's disabled.\n   */\n  checkFiltersDisabledInSite(site) {\n    var _site;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site = site) !== null && _site !== void 0 && _site.isFeatureDisabled('CoreFilterDelegate'));\n  }\n  /**\n   * Classify a list of filters into each context.\n   *\n   * @param contexts List of contexts.\n   * @param filters List of filters.\n   * @param hadSystemContext Whether the list of contexts originally had system context.\n   * @param hadSiteHomeContext Whether the list of contexts originally had site home context.\n   * @param site Site instance.\n   * @returns Classified filters.\n   */\n  classifyFilters(contexts, filters, hadSystemContext, hadSiteHomeContext, site) {\n    const classified = {};\n    // Initialize all contexts.\n    contexts.forEach(context => {\n      classified[context.contextlevel] = classified[context.contextlevel] || {};\n      classified[context.contextlevel][context.instanceid] = [];\n    });\n    if (contexts.length == 1 && !hadSystemContext) {\n      // Only 1 context, no need to iterate over the filters.\n      classified[contexts[0].contextlevel][contexts[0].instanceid] = filters;\n      return classified;\n    }\n    filters.forEach(filter => {\n      if (hadSystemContext && filter.contextlevel == 'course' && filter.instanceid == site.getSiteHomeId()) {\n        if (hadSiteHomeContext) {\n          // We need to return both site home and system. Add site home first.\n          classified[filter.contextlevel][filter.instanceid].push(filter);\n          // Now copy the object so it can be modified.\n          filter = Object.assign({}, filter);\n        }\n        // Simulate the system context based on the inherited data.\n        filter.contextlevel = 'system';\n        filter.instanceid = 0;\n        filter.contextid = -1;\n        filter.localstate = filter.inheritedstate;\n      }\n      classified[filter.contextlevel][filter.instanceid].push(filter);\n    });\n    return classified;\n  }\n  /**\n   * Given some HTML code, this function returns the text as safe HTML.\n   *\n   * @param text The text to be formatted.\n   * @param options Formatting options.\n   * @param filters The filters to apply. Required if filter is set to true.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the formatted text.\n   */\n  formatText(text, options, filters, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!text || typeof text != 'string') {\n        // No need to do any filters and cleaning.\n        return '';\n      }\n      // Clone object if needed so we can modify it.\n      options = options ? Object.assign({}, options) : {};\n      if (options.clean === undefined) {\n        options.clean = false;\n      }\n      if (options.filter === undefined) {\n        options.filter = true;\n      }\n      if (!options.contextLevel) {\n        options.filter = false;\n      }\n      if (options.filter) {\n        text = yield CoreFilterDelegate.filterText(text, filters, options, [], siteId);\n      }\n      if (options.clean) {\n        text = CoreTextUtils.cleanTags(text, {\n          singleLine: options.singleLine\n        });\n      }\n      if (options.shortenLength && options.shortenLength > 0) {\n        text = CoreTextUtils.shortenText(text, options.shortenLength);\n      }\n      if (options.highlight) {\n        text = CoreTextUtils.highlightText(text, options.highlight);\n      }\n      return text;\n    })();\n  }\n  /**\n   * Get cache key for available in contexts WS calls.\n   *\n   * @param contexts The contexts to check.\n   * @returns Cache key.\n   */\n  getAvailableInContextsCacheKey(contexts) {\n    return this.getAvailableInContextsPrefixCacheKey() + JSON.stringify(contexts);\n  }\n  /**\n   * Get prefixed cache key for available in contexts WS calls.\n   *\n   * @returns Cache key.\n   */\n  getAvailableInContextsPrefixCacheKey() {\n    return this.ROOT_CACHE_KEY + 'availableInContexts:';\n  }\n  /**\n   * Get the filters available in several contexts.\n   *\n   * @param contexts The contexts to check.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the filters classified by context.\n   */\n  getAvailableInContexts(contexts, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      siteId = site.getId();\n      const cacheResult = _this3.getFromMemoryCache(contexts, site);\n      if (cacheResult) {\n        return cacheResult;\n      }\n      const contextsToSend = contexts.slice(); // Copy the contexts array to be able to modify it.\n      const {\n        hadSystemContext,\n        hadSiteHomeContext\n      } = _this3.replaceSystemContext(contextsToSend, site);\n      const data = {\n        contexts: contextsToSend\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this3.getAvailableInContextsCacheKey(contextsToSend),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        splitRequest: {\n          param: 'contexts',\n          maxLength: 300\n        }\n      }, CoreSites.getReadingStrategyPreSets(4 /* CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE */));\n\n      const result = yield site.read('core_filters_get_available_in_context', data, preSets);\n      const classified = _this3.classifyFilters(contexts, result.filters, hadSystemContext, hadSiteHomeContext, site);\n      _this3.storeInMemoryCache(classified, siteId);\n      return classified;\n    })();\n  }\n  /**\n   * Get the filters available in a certain context.\n   *\n   * @param contextLevel The context level to check: system, user, coursecat, course, module, block, ...\n   * @param instanceId The instance ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the filters.\n   */\n  getAvailableInContext(contextLevel, instanceId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this4.getAvailableInContexts([{\n        contextlevel: contextLevel,\n        instanceid: instanceId\n      }], siteId);\n      return result[contextLevel][instanceId] || [];\n    })();\n  }\n  /**\n   * Get contexts filters from the memory cache.\n   *\n   * @param contexts Contexts to get.\n   * @param site Site.\n   * @returns The filters classified by context and instance.\n   */\n  getFromMemoryCache(contexts, site) {\n    if (!this.contextsCache[site.getId()]) {\n      return;\n    }\n    // Check if we have the contexts in the memory cache.\n    const siteContexts = this.contextsCache[site.getId()];\n    const isOnline = CoreNetwork.isOnline();\n    const result = {};\n    let allFound = true;\n    for (let i = 0; i < contexts.length; i++) {\n      var _siteContexts$context;\n      const context = contexts[i];\n      const cachedCtxt = (_siteContexts$context = siteContexts[context.contextlevel]) === null || _siteContexts$context === void 0 ? void 0 : _siteContexts$context[context.instanceid];\n      // Check the context isn't \"expired\". The time stored in this cache will not match the one in the site cache.\n      if (cachedCtxt && (!isOnline || Date.now() <= cachedCtxt.time + site.getExpirationDelay(CoreSite.FREQUENCY_RARELY))) {\n        result[context.contextlevel] = result[context.contextlevel] || {};\n        result[context.contextlevel][context.instanceid] = cachedCtxt.filters;\n      } else {\n        allFound = false;\n        break;\n      }\n    }\n    if (allFound) {\n      return result;\n    }\n  }\n  /**\n   * Invalidates all available in context WS calls.\n   *\n   * @param siteId Site ID (empty for current site).\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllAvailableInContext(siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this5.getAvailableInContextsPrefixCacheKey());\n    })();\n  }\n  /**\n   * Invalidates available in context WS call.\n   *\n   * @param contexts The contexts to check.\n   * @param siteId Site ID (empty for current site).\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAvailableInContexts(contexts, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this6.getAvailableInContextsCacheKey(contexts));\n    })();\n  }\n  /**\n   * Invalidates available in context WS call.\n   *\n   * @param contextLevel The context level to check.\n   * @param instanceId The instance ID.\n   * @param siteId Site ID (empty for current site).\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAvailableInContext(contextLevel, instanceId, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield _this7.invalidateAvailableInContexts([{\n        contextlevel: contextLevel,\n        instanceid: instanceId\n      }], siteId);\n    })();\n  }\n  /**\n   * Given a list of context to send to core_filters_get_available_in_context, search if the system context is in the list\n   * and, if so, replace it with a workaround.\n   *\n   * @param contexts The contexts to check.\n   * @param site Site instance.\n   * @returns Whether the filters had system context and whether they had the site home context.\n   */\n  replaceSystemContext(contexts, site) {\n    const result = {\n      hadSystemContext: false,\n      hadSiteHomeContext: false\n    };\n    // Check if any of the contexts is \"system\". We cannot use system context, so we'll have to use a wrokaround.\n    for (let i = 0; i < contexts.length; i++) {\n      const context = contexts[i];\n      if (context.contextlevel != 'system') {\n        continue;\n      }\n      result.hadSystemContext = true;\n      // Use course site home instead. Check if it's already in the list.\n      result.hadSiteHomeContext = contexts.some(context => context.contextlevel == 'course' && context.instanceid == site.getSiteHomeId());\n      if (result.hadSiteHomeContext) {\n        // Site home is already in list, remove this context from the list.\n        contexts.splice(i, 1);\n      } else {\n        // Site home not in list, use it instead of system.\n        contexts[i] = {\n          contextlevel: 'course',\n          instanceid: site.getSiteHomeId()\n        };\n      }\n      break;\n    }\n    return result;\n  }\n  /**\n   * Store filters in the memory cache.\n   *\n   * @param filters Filters to store, classified by contextlevel and instanceid\n   * @param siteId Site ID.\n   */\n  storeInMemoryCache(filters, siteId) {\n    this.contextsCache[siteId] = this.contextsCache[siteId] || {};\n    for (const contextLevel in filters) {\n      this.contextsCache[siteId][contextLevel] = this.contextsCache[siteId][contextLevel] || {};\n      for (const instanceId in filters[contextLevel]) {\n        this.contextsCache[siteId][contextLevel][instanceId] = {\n          filters: filters[contextLevel][instanceId],\n          time: Date.now()\n        };\n      }\n    }\n  }\n}\n_class = CoreFilterProvider;\n_class.ɵfac = function CoreFilterProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFilter = makeSingleton(CoreFilterProvider);","map":{"version":3,"names":["CoreNetwork","CoreSites","CoreSite","CoreTextUtils","CoreFilterDelegate","makeSingleton","CoreEvents","CoreLogger","CoreFilterProvider","constructor","ROOT_CACHE_KEY","contextsCache","logger","getInstance","on","WS_CACHE_INVALIDATED","data","siteId","SITE_STORAGE_DELETED","canGetFilters","_this","_asyncToGenerator","disabled","checkFiltersDisabled","canGetFiltersInSite","site","checkFiltersDisabledInSite","_this2","getSite","_site","getCurrentSite","isFeatureDisabled","classifyFilters","contexts","filters","hadSystemContext","hadSiteHomeContext","classified","forEach","context","contextlevel","instanceid","length","filter","getSiteHomeId","push","Object","assign","contextid","localstate","inheritedstate","formatText","text","options","clean","undefined","contextLevel","filterText","cleanTags","singleLine","shortenLength","shortenText","highlight","highlightText","getAvailableInContextsCacheKey","getAvailableInContextsPrefixCacheKey","JSON","stringify","getAvailableInContexts","_this3","getId","cacheResult","getFromMemoryCache","contextsToSend","slice","replaceSystemContext","preSets","_objectSpread","cacheKey","updateFrequency","FREQUENCY_RARELY","splitRequest","param","maxLength","getReadingStrategyPreSets","result","read","storeInMemoryCache","getAvailableInContext","instanceId","_this4","siteContexts","isOnline","allFound","i","_siteContexts$context","cachedCtxt","Date","now","time","getExpirationDelay","invalidateAllAvailableInContext","_this5","invalidateWsCacheForKeyStartingWith","invalidateAvailableInContexts","_this6","invalidateWsCacheForKey","invalidateAvailableInContext","_this7","some","splice","factory","ɵfac","providedIn","CoreFilter"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/filter/services/filter.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreFilterDelegate } from './filter-delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents, CoreEventSiteData } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\n/**\n * Service to provide filter functionalities.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFilterProvider {\n\n    protected readonly ROOT_CACHE_KEY = 'mmFilter:';\n\n    protected logger: CoreLogger;\n\n    /**\n     * Store the contexts in memory to speed up the process, it can take a lot of time otherwise.\n     */\n    protected contextsCache: {\n        [siteId: string]: {\n            [contextlevel: string]: {\n                [instanceid: number]: {\n                    filters: CoreFilterFilter[];\n                    time: number;\n                };\n            };\n        };\n    } = {};\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreFilterProvider');\n\n        CoreEvents.on(CoreEvents.WS_CACHE_INVALIDATED, (data: CoreEventSiteData) => {\n            delete this.contextsCache[data.siteId || ''];\n        });\n\n        CoreEvents.on(CoreEvents.SITE_STORAGE_DELETED, (data: CoreEventSiteData) => {\n            delete this.contextsCache[data.siteId || ''];\n        });\n    }\n\n    /**\n     * Returns whether or not we can get the available filters: the WS is available and the feature isn't disabled.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whethe can get filters.\n     */\n    async canGetFilters(siteId?: string): Promise<boolean> {\n        const disabled = await this.checkFiltersDisabled(siteId);\n\n        return !disabled;\n    }\n\n    /**\n     * Returns whether or not we can get the available filters: the WS is available and the feature isn't disabled.\n     *\n     * @param site Site. If not defined, current site.\n     * @returns Promise resolved with boolean: whethe can get filters.\n     */\n    canGetFiltersInSite(site?: CoreSite): boolean {\n        return this.checkFiltersDisabledInSite(site);\n    }\n\n    /**\n     * Returns whether or not checking the available filters is disabled in the site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it's disabled.\n     */\n    async checkFiltersDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.checkFiltersDisabledInSite(site);\n    }\n\n    /**\n     * Returns whether or not checking the available filters is disabled in the site.\n     *\n     * @param site Site. If not defined, current site.\n     * @returns Whether it's disabled.\n     */\n    checkFiltersDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!(site?.isFeatureDisabled('CoreFilterDelegate'));\n    }\n\n    /**\n     * Classify a list of filters into each context.\n     *\n     * @param contexts List of contexts.\n     * @param filters List of filters.\n     * @param hadSystemContext Whether the list of contexts originally had system context.\n     * @param hadSiteHomeContext Whether the list of contexts originally had site home context.\n     * @param site Site instance.\n     * @returns Classified filters.\n     */\n    protected classifyFilters(\n        contexts: CoreFiltersGetAvailableInContextWSParamContext[],\n        filters: CoreFilterFilter[],\n        hadSystemContext: boolean,\n        hadSiteHomeContext: boolean,\n        site: CoreSite,\n    ): CoreFilterClassifiedFilters {\n        const classified: CoreFilterClassifiedFilters = {};\n\n        // Initialize all contexts.\n        contexts.forEach((context) => {\n            classified[context.contextlevel] = classified[context.contextlevel] || {};\n            classified[context.contextlevel][context.instanceid] = [];\n        });\n\n        if (contexts.length == 1 && !hadSystemContext) {\n            // Only 1 context, no need to iterate over the filters.\n            classified[contexts[0].contextlevel][contexts[0].instanceid] = filters;\n\n            return classified;\n        }\n\n        filters.forEach((filter) => {\n            if (hadSystemContext && filter.contextlevel == 'course' && filter.instanceid == site.getSiteHomeId()) {\n                if (hadSiteHomeContext) {\n                    // We need to return both site home and system. Add site home first.\n                    classified[filter.contextlevel][filter.instanceid].push(filter);\n\n                    // Now copy the object so it can be modified.\n                    filter = Object.assign({}, filter);\n                }\n\n                // Simulate the system context based on the inherited data.\n                filter.contextlevel = 'system';\n                filter.instanceid = 0;\n                filter.contextid = -1;\n                filter.localstate = filter.inheritedstate;\n            }\n\n            classified[filter.contextlevel][filter.instanceid].push(filter);\n        });\n\n        return classified;\n    }\n\n    /**\n     * Given some HTML code, this function returns the text as safe HTML.\n     *\n     * @param text The text to be formatted.\n     * @param options Formatting options.\n     * @param filters The filters to apply. Required if filter is set to true.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the formatted text.\n     */\n    async formatText(\n        text: string,\n        options?: CoreFilterFormatTextOptions,\n        filters?: CoreFilterFilter[],\n        siteId?: string,\n    ): Promise<string> {\n\n        if (!text || typeof text != 'string') {\n            // No need to do any filters and cleaning.\n            return '';\n        }\n\n        // Clone object if needed so we can modify it.\n        options = options ? Object.assign({}, options) : {};\n\n        if (options.clean === undefined) {\n            options.clean = false;\n        }\n\n        if (options.filter === undefined) {\n            options.filter = true;\n        }\n\n        if (!options.contextLevel) {\n            options.filter = false;\n        }\n\n        if (options.filter) {\n            text = await CoreFilterDelegate.filterText(text, filters, options, [], siteId);\n        }\n\n        if (options.clean) {\n            text = CoreTextUtils.cleanTags(text, { singleLine: options.singleLine });\n        }\n\n        if (options.shortenLength && options.shortenLength > 0) {\n            text = CoreTextUtils.shortenText(text, options.shortenLength);\n        }\n\n        if (options.highlight) {\n            text = CoreTextUtils.highlightText(text, options.highlight);\n        }\n\n        return text;\n    }\n\n    /**\n     * Get cache key for available in contexts WS calls.\n     *\n     * @param contexts The contexts to check.\n     * @returns Cache key.\n     */\n    protected getAvailableInContextsCacheKey(contexts: CoreFiltersGetAvailableInContextWSParamContext[]): string {\n        return this.getAvailableInContextsPrefixCacheKey() + JSON.stringify(contexts);\n    }\n\n    /**\n     * Get prefixed cache key for available in contexts WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getAvailableInContextsPrefixCacheKey(): string {\n        return this.ROOT_CACHE_KEY + 'availableInContexts:';\n    }\n\n    /**\n     * Get the filters available in several contexts.\n     *\n     * @param contexts The contexts to check.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the filters classified by context.\n     */\n    async getAvailableInContexts(\n        contexts: CoreFiltersGetAvailableInContextWSParamContext[],\n        siteId?: string,\n    ): Promise<CoreFilterClassifiedFilters> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        siteId = site.getId();\n\n        const cacheResult = this.getFromMemoryCache(contexts, site);\n\n        if (cacheResult) {\n            return cacheResult;\n        }\n\n        const contextsToSend = contexts.slice(); // Copy the contexts array to be able to modify it.\n\n        const { hadSystemContext, hadSiteHomeContext } = this.replaceSystemContext(contextsToSend, site);\n\n        const data: CoreFiltersGetAvailableInContextWSParams = {\n            contexts: contextsToSend,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAvailableInContextsCacheKey(contextsToSend),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            splitRequest: {\n                param: 'contexts',\n                maxLength: 300,\n            },\n            // Use stale while revalidate, but always use the first value. If data is updated it will be stored in DB.\n            ...CoreSites.getReadingStrategyPreSets(CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE),\n        };\n\n        const result = await site.read<CoreFilterGetAvailableInContextResult>(\n            'core_filters_get_available_in_context',\n            data,\n            preSets,\n        );\n\n        const classified = this.classifyFilters(contexts, result.filters, hadSystemContext, hadSiteHomeContext, site);\n\n        this.storeInMemoryCache(classified, siteId);\n\n        return classified;\n    }\n\n    /**\n     * Get the filters available in a certain context.\n     *\n     * @param contextLevel The context level to check: system, user, coursecat, course, module, block, ...\n     * @param instanceId The instance ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the filters.\n     */\n    async getAvailableInContext(contextLevel: string, instanceId: number, siteId?: string): Promise<CoreFilterFilter[]> {\n        const result = await this.getAvailableInContexts([{ contextlevel: contextLevel, instanceid: instanceId }], siteId);\n\n        return result[contextLevel][instanceId] || [];\n    }\n\n    /**\n     * Get contexts filters from the memory cache.\n     *\n     * @param contexts Contexts to get.\n     * @param site Site.\n     * @returns The filters classified by context and instance.\n     */\n    protected getFromMemoryCache(\n        contexts: CoreFiltersGetAvailableInContextWSParamContext[],\n        site: CoreSite,\n    ): CoreFilterClassifiedFilters | undefined {\n\n        if (!this.contextsCache[site.getId()]) {\n            return;\n        }\n\n        // Check if we have the contexts in the memory cache.\n        const siteContexts = this.contextsCache[site.getId()];\n        const isOnline = CoreNetwork.isOnline();\n        const result: CoreFilterClassifiedFilters = {};\n        let allFound = true;\n\n        for (let i = 0; i < contexts.length; i++) {\n            const context = contexts[i];\n            const cachedCtxt = siteContexts[context.contextlevel]?.[context.instanceid];\n\n            // Check the context isn't \"expired\". The time stored in this cache will not match the one in the site cache.\n            if (cachedCtxt && (!isOnline ||\n                    Date.now() <= cachedCtxt.time + site.getExpirationDelay(CoreSite.FREQUENCY_RARELY))) {\n\n                result[context.contextlevel] = result[context.contextlevel] || {};\n                result[context.contextlevel][context.instanceid] = cachedCtxt.filters;\n            } else {\n                allFound = false;\n                break;\n            }\n        }\n\n        if (allFound) {\n            return result;\n        }\n    }\n\n    /**\n     * Invalidates all available in context WS calls.\n     *\n     * @param siteId Site ID (empty for current site).\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllAvailableInContext(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getAvailableInContextsPrefixCacheKey());\n    }\n\n    /**\n     * Invalidates available in context WS call.\n     *\n     * @param contexts The contexts to check.\n     * @param siteId Site ID (empty for current site).\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAvailableInContexts(\n        contexts: CoreFiltersGetAvailableInContextWSParamContext[],\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAvailableInContextsCacheKey(contexts));\n    }\n\n    /**\n     * Invalidates available in context WS call.\n     *\n     * @param contextLevel The context level to check.\n     * @param instanceId The instance ID.\n     * @param siteId Site ID (empty for current site).\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAvailableInContext(contextLevel: string, instanceId: number, siteId?: string): Promise<void> {\n        await this.invalidateAvailableInContexts([{ contextlevel: contextLevel, instanceid: instanceId }], siteId);\n    }\n\n    /**\n     * Given a list of context to send to core_filters_get_available_in_context, search if the system context is in the list\n     * and, if so, replace it with a workaround.\n     *\n     * @param contexts The contexts to check.\n     * @param site Site instance.\n     * @returns Whether the filters had system context and whether they had the site home context.\n     */\n    protected replaceSystemContext(\n        contexts: CoreFiltersGetAvailableInContextWSParamContext[],\n        site: CoreSite,\n    ): { hadSystemContext: boolean; hadSiteHomeContext: boolean } {\n        const result = {\n            hadSystemContext: false,\n            hadSiteHomeContext: false,\n        };\n\n        // Check if any of the contexts is \"system\". We cannot use system context, so we'll have to use a wrokaround.\n        for (let i = 0; i < contexts.length; i++) {\n            const context = contexts[i];\n\n            if (context.contextlevel != 'system') {\n                continue;\n            }\n\n            result.hadSystemContext = true;\n\n            // Use course site home instead. Check if it's already in the list.\n            result.hadSiteHomeContext = contexts.some((context) =>\n                context.contextlevel == 'course' && context.instanceid == site.getSiteHomeId());\n\n            if (result.hadSiteHomeContext) {\n                // Site home is already in list, remove this context from the list.\n                contexts.splice(i, 1);\n            } else {\n                // Site home not in list, use it instead of system.\n                contexts[i] = {\n                    contextlevel: 'course',\n                    instanceid: site.getSiteHomeId(),\n                };\n            }\n\n            break;\n        }\n\n        return result;\n    }\n\n    /**\n     * Store filters in the memory cache.\n     *\n     * @param filters Filters to store, classified by contextlevel and instanceid\n     * @param siteId Site ID.\n     */\n    protected storeInMemoryCache(filters: CoreFilterClassifiedFilters, siteId: string): void {\n        this.contextsCache[siteId] = this.contextsCache[siteId] || {};\n\n        for (const contextLevel in filters) {\n            this.contextsCache[siteId][contextLevel] = this.contextsCache[siteId][contextLevel] || {};\n\n            for (const instanceId in filters[contextLevel]) {\n                this.contextsCache[siteId][contextLevel][instanceId] = {\n                    filters: filters[contextLevel][instanceId],\n                    time: Date.now(),\n                };\n            }\n        }\n    }\n\n}\n\nexport const CoreFilter = makeSingleton(CoreFilterProvider);\n\n/**\n * Params of core_filters_get_available_in_context WS.\n */\nexport type CoreFiltersGetAvailableInContextWSParams = {\n    contexts: CoreFiltersGetAvailableInContextWSParamContext[]; // The list of contexts to check.\n};\n\n/**\n * Data about a context sent to core_filters_get_available_in_context.\n */\nexport type CoreFiltersGetAvailableInContextWSParamContext = {\n    contextlevel: string; // The context level where the filters are: (coursecat, course, module).\n    instanceid: number; // The instance id of item associated with the context.\n};\n\n/**\n * Filter object returned by core_filters_get_available_in_context.\n */\nexport type CoreFilterFilter = {\n    contextlevel: string; // The context level where the filters are: (coursecat, course, module).\n    instanceid: number; // The instance id of item associated with the context.\n    contextid: number; // The context id.\n    filter: string; // Filter plugin name.\n    localstate: number; // Filter state: 1 for on, -1 for off, 0 if inherit.\n    inheritedstate: number; // 1 or 0 to use when localstate is set to inherit.\n};\n\n/**\n * Result of core_filters_get_available_in_context.\n */\nexport type CoreFilterGetAvailableInContextResult = {\n    filters: CoreFilterFilter[]; // Available filters.\n    warnings: CoreWSExternalWarning[]; // List of warnings.\n};\n\n/**\n * Options that can be passed to format text.\n */\nexport type CoreFilterFormatTextOptions = {\n    contextLevel?: string; // The context level where the text is.\n    instanceId?: number; // The instance id related to the context.\n    clean?: boolean; // If true all HTML will be removed. Default false.\n    filter?: boolean; // If true the string will be run through applicable filters as well. Default true.\n    singleLine?: boolean; // If true then new lines will be removed (all the text in a single line).\n    shortenLength?: number; // Number of characters to shorten the text.\n    highlight?: string; // Text to highlight.\n    wsNotFiltered?: boolean; // If true it means the WS didn't filter the text for some reason.\n    courseId?: number; // Course ID the text belongs to. It can be used to improve performance.\n};\n\n/**\n * Filters classified by context and instance.\n */\nexport type CoreFilterClassifiedFilters = {\n    [contextlevel: string]: {\n        [instanceid: number]: CoreFilterFilter[];\n    };\n};\n"],"mappings":";;;AAgBA,SAASA,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,SAAS,QAAkC,iBAAiB;AACrE,SAASC,QAAQ,QAAQ,qBAAqB;AAE9C,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,kBAAkB,QAAQ,mBAAmB;AACtD,SAASC,aAAa,QAAQ,aAAa;AAC3C,SAASC,UAAU,QAA2B,oBAAoB;AAClE,SAASC,UAAU,QAAQ,oBAAoB;;AAG/C;;;AAIA,OAAM,MAAOC,kBAAkB;EAoB3BC,YAAA;IAlBmB,KAAAC,cAAc,GAAG,WAAW;IAI/C;;;IAGU,KAAAC,aAAa,GASnB,EAAE;IAGF,IAAI,CAACC,MAAM,GAAGL,UAAU,CAACM,WAAW,CAAC,oBAAoB,CAAC;IAE1DP,UAAU,CAACQ,EAAE,CAACR,UAAU,CAACS,oBAAoB,EAAGC,IAAuB,IAAI;MACvE,OAAO,IAAI,CAACL,aAAa,CAACK,IAAI,CAACC,MAAM,IAAI,EAAE,CAAC;IAChD,CAAC,CAAC;IAEFX,UAAU,CAACQ,EAAE,CAACR,UAAU,CAACY,oBAAoB,EAAGF,IAAuB,IAAI;MACvE,OAAO,IAAI,CAACL,aAAa,CAACK,IAAI,CAACC,MAAM,IAAI,EAAE,CAAC;IAChD,CAAC,CAAC;EACN;EAEA;;;;;;EAMME,aAAaA,CAACF,MAAe;IAAA,IAAAG,KAAA;IAAA,OAAAC,iBAAA;MAC/B,MAAMC,QAAQ,SAASF,KAAI,CAACG,oBAAoB,CAACN,MAAM,CAAC;MAExD,OAAO,CAACK,QAAQ;IAAC;EACrB;EAEA;;;;;;EAMAE,mBAAmBA,CAACC,IAAe;IAC/B,OAAO,IAAI,CAACC,0BAA0B,CAACD,IAAI,CAAC;EAChD;EAEA;;;;;;EAMMF,oBAAoBA,CAACN,MAAe;IAAA,IAAAU,MAAA;IAAA,OAAAN,iBAAA;MACtC,MAAMI,IAAI,SAASxB,SAAS,CAAC2B,OAAO,CAACX,MAAM,CAAC;MAE5C,OAAOU,MAAI,CAACD,0BAA0B,CAACD,IAAI,CAAC;IAAC;EACjD;EAEA;;;;;;EAMAC,0BAA0BA,CAACD,IAAe;IAAA,IAAAI,KAAA;IACtCJ,IAAI,GAAGA,IAAI,IAAIxB,SAAS,CAAC6B,cAAc,EAAE;IAEzC,OAAO,CAAC,GAAAD,KAAA,GAAEJ,IAAI,cAAAI,KAAA,eAAJA,KAAA,CAAME,iBAAiB,CAAC,oBAAoB,CAAC,CAAC;EAC5D;EAEA;;;;;;;;;;EAUUC,eAAeA,CACrBC,QAA0D,EAC1DC,OAA2B,EAC3BC,gBAAyB,EACzBC,kBAA2B,EAC3BX,IAAc;IAEd,MAAMY,UAAU,GAAgC,EAAE;IAElD;IACAJ,QAAQ,CAACK,OAAO,CAAEC,OAAO,IAAI;MACzBF,UAAU,CAACE,OAAO,CAACC,YAAY,CAAC,GAAGH,UAAU,CAACE,OAAO,CAACC,YAAY,CAAC,IAAI,EAAE;MACzEH,UAAU,CAACE,OAAO,CAACC,YAAY,CAAC,CAACD,OAAO,CAACE,UAAU,CAAC,GAAG,EAAE;IAC7D,CAAC,CAAC;IAEF,IAAIR,QAAQ,CAACS,MAAM,IAAI,CAAC,IAAI,CAACP,gBAAgB,EAAE;MAC3C;MACAE,UAAU,CAACJ,QAAQ,CAAC,CAAC,CAAC,CAACO,YAAY,CAAC,CAACP,QAAQ,CAAC,CAAC,CAAC,CAACQ,UAAU,CAAC,GAAGP,OAAO;MAEtE,OAAOG,UAAU;;IAGrBH,OAAO,CAACI,OAAO,CAAEK,MAAM,IAAI;MACvB,IAAIR,gBAAgB,IAAIQ,MAAM,CAACH,YAAY,IAAI,QAAQ,IAAIG,MAAM,CAACF,UAAU,IAAIhB,IAAI,CAACmB,aAAa,EAAE,EAAE;QAClG,IAAIR,kBAAkB,EAAE;UACpB;UACAC,UAAU,CAACM,MAAM,CAACH,YAAY,CAAC,CAACG,MAAM,CAACF,UAAU,CAAC,CAACI,IAAI,CAACF,MAAM,CAAC;UAE/D;UACAA,MAAM,GAAGG,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEJ,MAAM,CAAC;;QAGtC;QACAA,MAAM,CAACH,YAAY,GAAG,QAAQ;QAC9BG,MAAM,CAACF,UAAU,GAAG,CAAC;QACrBE,MAAM,CAACK,SAAS,GAAG,CAAC,CAAC;QACrBL,MAAM,CAACM,UAAU,GAAGN,MAAM,CAACO,cAAc;;MAG7Cb,UAAU,CAACM,MAAM,CAACH,YAAY,CAAC,CAACG,MAAM,CAACF,UAAU,CAAC,CAACI,IAAI,CAACF,MAAM,CAAC;IACnE,CAAC,CAAC;IAEF,OAAON,UAAU;EACrB;EAEA;;;;;;;;;EASMc,UAAUA,CACZC,IAAY,EACZC,OAAqC,EACrCnB,OAA4B,EAC5BjB,MAAe;IAAA,OAAAI,iBAAA;MAGf,IAAI,CAAC+B,IAAI,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAE;QAClC;QACA,OAAO,EAAE;;MAGb;MACAC,OAAO,GAAGA,OAAO,GAAGP,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEM,OAAO,CAAC,GAAG,EAAE;MAEnD,IAAIA,OAAO,CAACC,KAAK,KAAKC,SAAS,EAAE;QAC7BF,OAAO,CAACC,KAAK,GAAG,KAAK;;MAGzB,IAAID,OAAO,CAACV,MAAM,KAAKY,SAAS,EAAE;QAC9BF,OAAO,CAACV,MAAM,GAAG,IAAI;;MAGzB,IAAI,CAACU,OAAO,CAACG,YAAY,EAAE;QACvBH,OAAO,CAACV,MAAM,GAAG,KAAK;;MAG1B,IAAIU,OAAO,CAACV,MAAM,EAAE;QAChBS,IAAI,SAAShD,kBAAkB,CAACqD,UAAU,CAACL,IAAI,EAAElB,OAAO,EAAEmB,OAAO,EAAE,EAAE,EAAEpC,MAAM,CAAC;;MAGlF,IAAIoC,OAAO,CAACC,KAAK,EAAE;QACfF,IAAI,GAAGjD,aAAa,CAACuD,SAAS,CAACN,IAAI,EAAE;UAAEO,UAAU,EAAEN,OAAO,CAACM;QAAU,CAAE,CAAC;;MAG5E,IAAIN,OAAO,CAACO,aAAa,IAAIP,OAAO,CAACO,aAAa,GAAG,CAAC,EAAE;QACpDR,IAAI,GAAGjD,aAAa,CAAC0D,WAAW,CAACT,IAAI,EAAEC,OAAO,CAACO,aAAa,CAAC;;MAGjE,IAAIP,OAAO,CAACS,SAAS,EAAE;QACnBV,IAAI,GAAGjD,aAAa,CAAC4D,aAAa,CAACX,IAAI,EAAEC,OAAO,CAACS,SAAS,CAAC;;MAG/D,OAAOV,IAAI;IAAC;EAChB;EAEA;;;;;;EAMUY,8BAA8BA,CAAC/B,QAA0D;IAC/F,OAAO,IAAI,CAACgC,oCAAoC,EAAE,GAAGC,IAAI,CAACC,SAAS,CAAClC,QAAQ,CAAC;EACjF;EAEA;;;;;EAKUgC,oCAAoCA,CAAA;IAC1C,OAAO,IAAI,CAACvD,cAAc,GAAG,sBAAsB;EACvD;EAEA;;;;;;;EAOM0D,sBAAsBA,CACxBnC,QAA0D,EAC1DhB,MAAe;IAAA,IAAAoD,MAAA;IAAA,OAAAhD,iBAAA;MAGf,MAAMI,IAAI,SAASxB,SAAS,CAAC2B,OAAO,CAACX,MAAM,CAAC;MAE5CA,MAAM,GAAGQ,IAAI,CAAC6C,KAAK,EAAE;MAErB,MAAMC,WAAW,GAAGF,MAAI,CAACG,kBAAkB,CAACvC,QAAQ,EAAER,IAAI,CAAC;MAE3D,IAAI8C,WAAW,EAAE;QACb,OAAOA,WAAW;;MAGtB,MAAME,cAAc,GAAGxC,QAAQ,CAACyC,KAAK,EAAE,CAAC,CAAC;MAEzC,MAAM;QAAEvC,gBAAgB;QAAEC;MAAkB,CAAE,GAAGiC,MAAI,CAACM,oBAAoB,CAACF,cAAc,EAAEhD,IAAI,CAAC;MAEhG,MAAMT,IAAI,GAA6C;QACnDiB,QAAQ,EAAEwC;OACb;MACD,MAAMG,OAAO,GAAAC,aAAA;QACTC,QAAQ,EAAET,MAAI,CAACL,8BAA8B,CAACS,cAAc,CAAC;QAC7DM,eAAe,EAAE7E,QAAQ,CAAC8E,gBAAgB;QAC1CC,YAAY,EAAE;UACVC,KAAK,EAAE,UAAU;UACjBC,SAAS,EAAE;;MACd,GAEElF,SAAS,CAACmF,yBAAyB,yDAAiD,CAC1F;;MAED,MAAMC,MAAM,SAAS5D,IAAI,CAAC6D,IAAI,CAC1B,uCAAuC,EACvCtE,IAAI,EACJ4D,OAAO,CACV;MAED,MAAMvC,UAAU,GAAGgC,MAAI,CAACrC,eAAe,CAACC,QAAQ,EAAEoD,MAAM,CAACnD,OAAO,EAAEC,gBAAgB,EAAEC,kBAAkB,EAAEX,IAAI,CAAC;MAE7G4C,MAAI,CAACkB,kBAAkB,CAAClD,UAAU,EAAEpB,MAAM,CAAC;MAE3C,OAAOoB,UAAU;IAAC;EACtB;EAEA;;;;;;;;EAQMmD,qBAAqBA,CAAChC,YAAoB,EAAEiC,UAAkB,EAAExE,MAAe;IAAA,IAAAyE,MAAA;IAAA,OAAArE,iBAAA;MACjF,MAAMgE,MAAM,SAASK,MAAI,CAACtB,sBAAsB,CAAC,CAAC;QAAE5B,YAAY,EAAEgB,YAAY;QAAEf,UAAU,EAAEgD;MAAU,CAAE,CAAC,EAAExE,MAAM,CAAC;MAElH,OAAOoE,MAAM,CAAC7B,YAAY,CAAC,CAACiC,UAAU,CAAC,IAAI,EAAE;IAAC;EAClD;EAEA;;;;;;;EAOUjB,kBAAkBA,CACxBvC,QAA0D,EAC1DR,IAAc;IAGd,IAAI,CAAC,IAAI,CAACd,aAAa,CAACc,IAAI,CAAC6C,KAAK,EAAE,CAAC,EAAE;MACnC;;IAGJ;IACA,MAAMqB,YAAY,GAAG,IAAI,CAAChF,aAAa,CAACc,IAAI,CAAC6C,KAAK,EAAE,CAAC;IACrD,MAAMsB,QAAQ,GAAG5F,WAAW,CAAC4F,QAAQ,EAAE;IACvC,MAAMP,MAAM,GAAgC,EAAE;IAC9C,IAAIQ,QAAQ,GAAG,IAAI;IAEnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7D,QAAQ,CAACS,MAAM,EAAEoD,CAAC,EAAE,EAAE;MAAA,IAAAC,qBAAA;MACtC,MAAMxD,OAAO,GAAGN,QAAQ,CAAC6D,CAAC,CAAC;MAC3B,MAAME,UAAU,IAAAD,qBAAA,GAAGJ,YAAY,CAACpD,OAAO,CAACC,YAAY,CAAC,cAAAuD,qBAAA,uBAAlCA,qBAAA,CAAqCxD,OAAO,CAACE,UAAU,CAAC;MAE3E;MACA,IAAIuD,UAAU,KAAK,CAACJ,QAAQ,IACpBK,IAAI,CAACC,GAAG,EAAE,IAAIF,UAAU,CAACG,IAAI,GAAG1E,IAAI,CAAC2E,kBAAkB,CAAClG,QAAQ,CAAC8E,gBAAgB,CAAC,CAAC,EAAE;QAEzFK,MAAM,CAAC9C,OAAO,CAACC,YAAY,CAAC,GAAG6C,MAAM,CAAC9C,OAAO,CAACC,YAAY,CAAC,IAAI,EAAE;QACjE6C,MAAM,CAAC9C,OAAO,CAACC,YAAY,CAAC,CAACD,OAAO,CAACE,UAAU,CAAC,GAAGuD,UAAU,CAAC9D,OAAO;OACxE,MAAM;QACH2D,QAAQ,GAAG,KAAK;QAChB;;;IAIR,IAAIA,QAAQ,EAAE;MACV,OAAOR,MAAM;;EAErB;EAEA;;;;;;EAMMgB,+BAA+BA,CAACpF,MAAe;IAAA,IAAAqF,MAAA;IAAA,OAAAjF,iBAAA;MACjD,MAAMI,IAAI,SAASxB,SAAS,CAAC2B,OAAO,CAACX,MAAM,CAAC;MAE5C,MAAMQ,IAAI,CAAC8E,mCAAmC,CAACD,MAAI,CAACrC,oCAAoC,EAAE,CAAC;IAAC;EAChG;EAEA;;;;;;;EAOMuC,6BAA6BA,CAC/BvE,QAA0D,EAC1DhB,MAAe;IAAA,IAAAwF,MAAA;IAAA,OAAApF,iBAAA;MAEf,MAAMI,IAAI,SAASxB,SAAS,CAAC2B,OAAO,CAACX,MAAM,CAAC;MAE5C,MAAMQ,IAAI,CAACiF,uBAAuB,CAACD,MAAI,CAACzC,8BAA8B,CAAC/B,QAAQ,CAAC,CAAC;IAAC;EACtF;EAEA;;;;;;;;EAQM0E,4BAA4BA,CAACnD,YAAoB,EAAEiC,UAAkB,EAAExE,MAAe;IAAA,IAAA2F,MAAA;IAAA,OAAAvF,iBAAA;MACxF,MAAMuF,MAAI,CAACJ,6BAA6B,CAAC,CAAC;QAAEhE,YAAY,EAAEgB,YAAY;QAAEf,UAAU,EAAEgD;MAAU,CAAE,CAAC,EAAExE,MAAM,CAAC;IAAC;EAC/G;EAEA;;;;;;;;EAQU0D,oBAAoBA,CAC1B1C,QAA0D,EAC1DR,IAAc;IAEd,MAAM4D,MAAM,GAAG;MACXlD,gBAAgB,EAAE,KAAK;MACvBC,kBAAkB,EAAE;KACvB;IAED;IACA,KAAK,IAAI0D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7D,QAAQ,CAACS,MAAM,EAAEoD,CAAC,EAAE,EAAE;MACtC,MAAMvD,OAAO,GAAGN,QAAQ,CAAC6D,CAAC,CAAC;MAE3B,IAAIvD,OAAO,CAACC,YAAY,IAAI,QAAQ,EAAE;QAClC;;MAGJ6C,MAAM,CAAClD,gBAAgB,GAAG,IAAI;MAE9B;MACAkD,MAAM,CAACjD,kBAAkB,GAAGH,QAAQ,CAAC4E,IAAI,CAAEtE,OAAO,IAC9CA,OAAO,CAACC,YAAY,IAAI,QAAQ,IAAID,OAAO,CAACE,UAAU,IAAIhB,IAAI,CAACmB,aAAa,EAAE,CAAC;MAEnF,IAAIyC,MAAM,CAACjD,kBAAkB,EAAE;QAC3B;QACAH,QAAQ,CAAC6E,MAAM,CAAChB,CAAC,EAAE,CAAC,CAAC;OACxB,MAAM;QACH;QACA7D,QAAQ,CAAC6D,CAAC,CAAC,GAAG;UACVtD,YAAY,EAAE,QAAQ;UACtBC,UAAU,EAAEhB,IAAI,CAACmB,aAAa;SACjC;;MAGL;;IAGJ,OAAOyC,MAAM;EACjB;EAEA;;;;;;EAMUE,kBAAkBA,CAACrD,OAAoC,EAAEjB,MAAc;IAC7E,IAAI,CAACN,aAAa,CAACM,MAAM,CAAC,GAAG,IAAI,CAACN,aAAa,CAACM,MAAM,CAAC,IAAI,EAAE;IAE7D,KAAK,MAAMuC,YAAY,IAAItB,OAAO,EAAE;MAChC,IAAI,CAACvB,aAAa,CAACM,MAAM,CAAC,CAACuC,YAAY,CAAC,GAAG,IAAI,CAAC7C,aAAa,CAACM,MAAM,CAAC,CAACuC,YAAY,CAAC,IAAI,EAAE;MAEzF,KAAK,MAAMiC,UAAU,IAAIvD,OAAO,CAACsB,YAAY,CAAC,EAAE;QAC5C,IAAI,CAAC7C,aAAa,CAACM,MAAM,CAAC,CAACuC,YAAY,CAAC,CAACiC,UAAU,CAAC,GAAG;UACnDvD,OAAO,EAAEA,OAAO,CAACsB,YAAY,CAAC,CAACiC,UAAU,CAAC;UAC1CU,IAAI,EAAEF,IAAI,CAACC,GAAG;SACjB;;;EAGb;;SAxaS1F,kBAAkB;;mBAAlBA,MAAkB;AAAA;;SAAlBA,MAAkB;EAAAuG,OAAA,EAAlBvG,MAAkB,CAAAwG,IAAA;EAAAC,UAAA,EADL;AAAM;AA6ahC,OAAO,MAAMC,UAAU,GAAG7G,aAAa,CAACG,kBAAkB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}