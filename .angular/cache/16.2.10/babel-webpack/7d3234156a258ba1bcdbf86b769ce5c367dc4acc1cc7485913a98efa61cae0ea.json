{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'addonBlog:';\n/**\n * Service to handle blog entries.\n */\nexport class AddonBlogProvider {\n  /**\n   * Returns whether or not the blog plugin is enabled for a certain site.\n   *\n   * This method is called quite often and thus should only perform a quick\n   * check, we should not be calling WS from here.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if enabled, resolved with false or rejected otherwise.\n   * @since 3.6\n   */\n  isPluginEnabled(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.wsAvailable('core_blog_get_entries') && site.canUseAdvancedFeature('enableblogs');\n    })();\n  }\n  /**\n   * Get the cache key for the blog entries.\n   *\n   * @param filter Filter to apply on search.\n   * @returns Cache key.\n   */\n  getEntriesCacheKey(filter = {}) {\n    return ROOT_CACHE_KEY + CoreUtils.sortAndStringify(filter);\n  }\n  /**\n   * Get blog entries.\n   *\n   * @param filter Filter to apply on search.\n   * @param page Page of the blog entries to fetch.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise to be resolved when the entries are retrieved.\n   */\n  getEntries(filter = {}, page = 0, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const data = {\n        filters: CoreUtils.objectToArrayOfObjects(filter, 'name', 'value'),\n        page: page,\n        perpage: AddonBlogProvider.ENTRIES_PER_PAGE\n      };\n      const preSets = {\n        cacheKey: _this.getEntriesCacheKey(filter),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      return site.read('core_blog_get_entries', data, preSets);\n    })();\n  }\n  /**\n   * Invalidate blog entries WS call.\n   *\n   * @param filter Filter to apply on search\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data is invalidated.\n   */\n  invalidateEntries(filter = {}, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this2.getEntriesCacheKey(filter));\n    })();\n  }\n  /**\n   * Trigger the blog_entries_viewed event.\n   *\n   * @param filter Filter to apply on search.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise to be resolved when done.\n   */\n  logView(filter = {}, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const data = {\n        filters: CoreUtils.objectToArrayOfObjects(filter, 'name', 'value')\n      };\n      return site.write('core_blog_view_entries', data);\n    })();\n  }\n}\n_class = AddonBlogProvider;\n_class.ENTRIES_PER_PAGE = 10;\n_class.COMPONENT = 'blog';\n_class.ɵfac = function AddonBlogProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonBlog = makeSingleton(AddonBlogProvider);","map":{"version":3,"names":["CoreSite","CoreSites","CoreUtils","makeSingleton","ROOT_CACHE_KEY","AddonBlogProvider","isPluginEnabled","siteId","_asyncToGenerator","site","getSite","wsAvailable","canUseAdvancedFeature","getEntriesCacheKey","filter","sortAndStringify","getEntries","page","_this","data","filters","objectToArrayOfObjects","perpage","ENTRIES_PER_PAGE","preSets","cacheKey","updateFrequency","FREQUENCY_SOMETIMES","read","invalidateEntries","_this2","invalidateWsCacheForKey","logView","write","_class","COMPONENT","factory","ɵfac","providedIn","AddonBlog"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/blog/services/blog.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreTagItem } from '@features/tag/services/tag';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreStatusWithWarningsWSResponse, CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton } from '@singletons';\n\nconst ROOT_CACHE_KEY = 'addonBlog:';\n\n/**\n * Service to handle blog entries.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonBlogProvider {\n\n    static readonly ENTRIES_PER_PAGE = 10;\n    static readonly COMPONENT = 'blog';\n\n    /**\n     * Returns whether or not the blog plugin is enabled for a certain site.\n     *\n     * This method is called quite often and thus should only perform a quick\n     * check, we should not be calling WS from here.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if enabled, resolved with false or rejected otherwise.\n     * @since 3.6\n     */\n    async isPluginEnabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.wsAvailable('core_blog_get_entries') && site.canUseAdvancedFeature('enableblogs');\n    }\n\n    /**\n     * Get the cache key for the blog entries.\n     *\n     * @param filter Filter to apply on search.\n     * @returns Cache key.\n     */\n    getEntriesCacheKey(filter: AddonBlogFilter = {}): string {\n        return ROOT_CACHE_KEY + CoreUtils.sortAndStringify(filter);\n    }\n\n    /**\n     * Get blog entries.\n     *\n     * @param filter Filter to apply on search.\n     * @param page Page of the blog entries to fetch.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise to be resolved when the entries are retrieved.\n     */\n    async getEntries(filter: AddonBlogFilter = {}, page: number = 0, siteId?: string): Promise<CoreBlogGetEntriesWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const data: CoreBlogGetEntriesWSParams = {\n            filters: CoreUtils.objectToArrayOfObjects(filter, 'name', 'value'),\n            page: page,\n            perpage: AddonBlogProvider.ENTRIES_PER_PAGE,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEntriesCacheKey(filter),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n\n        return site.read('core_blog_get_entries', data, preSets);\n    }\n\n    /**\n     * Invalidate blog entries WS call.\n     *\n     * @param filter Filter to apply on search\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data is invalidated.\n     */\n    async invalidateEntries(filter: AddonBlogFilter = {}, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getEntriesCacheKey(filter));\n    }\n\n    /**\n     * Trigger the blog_entries_viewed event.\n     *\n     * @param filter Filter to apply on search.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise to be resolved when done.\n     */\n    async logView(filter: AddonBlogFilter = {}, siteId?: string): Promise<CoreStatusWithWarningsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const data: AddonBlogViewEntriesWSParams = {\n            filters: CoreUtils.objectToArrayOfObjects(filter, 'name', 'value'),\n        };\n\n        return site.write('core_blog_view_entries', data);\n    }\n\n}\nexport const AddonBlog = makeSingleton(AddonBlogProvider);\n\n/**\n * Params of core_blog_get_entries WS.\n */\ntype CoreBlogGetEntriesWSParams = {\n    filters?: { // Parameters to filter blog listings.\n        name: string; // The expected keys (value format) are:\n        // tag      PARAM_NOTAGS blog tag\n        // tagid    PARAM_INT    blog tag id\n        // userid   PARAM_INT    blog author (userid)\n        // cmid    PARAM_INT    course module id\n        // entryid  PARAM_INT    entry id\n        // groupid  PARAM_INT    group id\n        // courseid PARAM_INT    course id\n        // search   PARAM_RAW    search term.\n        value: string; // The value of the filter.\n    }[];\n    page?: number; // The blog page to return.\n    perpage?: number; // The number of posts to return per page.\n};\n\n/**\n * Data returned by core_blog_get_entries WS.\n */\nexport type CoreBlogGetEntriesWSResponse = {\n    entries: AddonBlogPost[];\n    totalentries: number; // The total number of entries found.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data returned by blog's post_exporter.\n */\nexport type AddonBlogPost = {\n    id: number; // Post/entry id.\n    module: string; // Where it was published the post (blog, blog_external...).\n    userid: number; // Post author.\n    courseid: number; // Course where the post was created.\n    groupid: number; // Group post was created for.\n    moduleid: number; // Module id where the post was created (not used anymore).\n    coursemoduleid: number; // Course module id where the post was created.\n    subject: string; // Post subject.\n    summary: string; // Post summary.\n    summaryformat?: number; // Summary format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    content: string; // Post content.\n    uniquehash: string; // Post unique hash.\n    rating: number; // Post rating.\n    format: number; // Post content format.\n    attachment: string; // Post atachment.\n    publishstate: string; // Post publish state.\n    lastmodified: number; // When it was last modified.\n    created: number; // When it was created.\n    usermodified: number; // User that updated the post.\n    summaryfiles: CoreWSExternalFile[]; // Summaryfiles.\n    attachmentfiles?: CoreWSExternalFile[]; // Attachmentfiles.\n    tags?: CoreTagItem[]; // @since 3.7. Tags.\n};\n\n/**\n * Params of core_blog_view_entries WS.\n */\ntype AddonBlogViewEntriesWSParams = {\n    filters?: { // Parameters used in the filter of view_entries.\n        name: string; // The expected keys (value format) are:\n        // tag      PARAM_NOTAGS blog tag\n        // tagid    PARAM_INT    blog tag id\n        // userid   PARAM_INT    blog author (userid)\n        // cmid     PARAM_INT    course module id\n        // entryid  PARAM_INT    entry id\n        // groupid  PARAM_INT    group id\n        // courseid PARAM_INT    course id\n        // search   PARAM_RAW    search term.\n        value: string; // The value of the filter.\n    }[];\n};\n\nexport type AddonBlogFilter = {\n    tag?: string;      // Blog tag\n    tagid?: number;    // Blog tag id\n    userid?: number;   // Blog author (userid)\n    cmid?: number;     // Course module id\n    entryid?: number;  // Entry id\n    groupid?: number;  // Group id\n    courseid?: number; // Course id\n    search?: string;   // Search term.\n};\n"],"mappings":";;AAgBA,SAASA,QAAQ,QAAQ,qBAAqB;AAE9C,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,SAAS,QAAQ,uBAAuB;AAEjD,SAASC,aAAa,QAAQ,aAAa;;AAE3C,MAAMC,cAAc,GAAG,YAAY;AAEnC;;;AAIA,OAAM,MAAOC,iBAAiB;EAK1B;;;;;;;;;;EAUMC,eAAeA,CAACC,MAAe;IAAA,OAAAC,iBAAA;MACjC,MAAMC,IAAI,SAASR,SAAS,CAACS,OAAO,CAACH,MAAM,CAAC;MAE5C,OAAOE,IAAI,CAACE,WAAW,CAAC,uBAAuB,CAAC,IAAIF,IAAI,CAACG,qBAAqB,CAAC,aAAa,CAAC;IAAC;EAClG;EAEA;;;;;;EAMAC,kBAAkBA,CAACC,MAAA,GAA0B,EAAE;IAC3C,OAAOV,cAAc,GAAGF,SAAS,CAACa,gBAAgB,CAACD,MAAM,CAAC;EAC9D;EAEA;;;;;;;;EAQME,UAAUA,CAACF,MAAA,GAA0B,EAAE,EAAEG,IAAA,GAAe,CAAC,EAAEV,MAAe;IAAA,IAAAW,KAAA;IAAA,OAAAV,iBAAA;MAC5E,MAAMC,IAAI,SAASR,SAAS,CAACS,OAAO,CAACH,MAAM,CAAC;MAE5C,MAAMY,IAAI,GAA+B;QACrCC,OAAO,EAAElB,SAAS,CAACmB,sBAAsB,CAACP,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC;QAClEG,IAAI,EAAEA,IAAI;QACVK,OAAO,EAAEjB,iBAAiB,CAACkB;OAC9B;MAED,MAAMC,OAAO,GAAsB;QAC/BC,QAAQ,EAAEP,KAAI,CAACL,kBAAkB,CAACC,MAAM,CAAC;QACzCY,eAAe,EAAE1B,QAAQ,CAAC2B;OAC7B;MAED,OAAOlB,IAAI,CAACmB,IAAI,CAAC,uBAAuB,EAAET,IAAI,EAAEK,OAAO,CAAC;IAAC;EAC7D;EAEA;;;;;;;EAOMK,iBAAiBA,CAACf,MAAA,GAA0B,EAAE,EAAEP,MAAe;IAAA,IAAAuB,MAAA;IAAA,OAAAtB,iBAAA;MACjE,MAAMC,IAAI,SAASR,SAAS,CAACS,OAAO,CAACH,MAAM,CAAC;MAE5C,MAAME,IAAI,CAACsB,uBAAuB,CAACD,MAAI,CAACjB,kBAAkB,CAACC,MAAM,CAAC,CAAC;IAAC;EACxE;EAEA;;;;;;;EAOMkB,OAAOA,CAAClB,MAAA,GAA0B,EAAE,EAAEP,MAAe;IAAA,OAAAC,iBAAA;MACvD,MAAMC,IAAI,SAASR,SAAS,CAACS,OAAO,CAACH,MAAM,CAAC;MAE5C,MAAMY,IAAI,GAAiC;QACvCC,OAAO,EAAElB,SAAS,CAACmB,sBAAsB,CAACP,MAAM,EAAE,MAAM,EAAE,OAAO;OACpE;MAED,OAAOL,IAAI,CAACwB,KAAK,CAAC,wBAAwB,EAAEd,IAAI,CAAC;IAAC;EACtD;;SApFSd,iBAAiB;AAEV6B,MAAA,CAAAX,gBAAgB,GAAG,EAAE;AACrBW,MAAA,CAAAC,SAAS,GAAG,MAAM;;mBAHzB9B,MAAiB;AAAA;;SAAjBA,MAAiB;EAAA+B,OAAA,EAAjB/B,MAAiB,CAAAgC,IAAA;EAAAC,UAAA,EADJ;AAAM;AAwFhC,OAAO,MAAMC,SAAS,GAAGpC,aAAa,CAACE,iBAAiB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}