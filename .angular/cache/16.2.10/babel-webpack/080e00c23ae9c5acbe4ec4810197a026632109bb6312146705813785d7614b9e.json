{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'CoreTag:';\n/**\n * Service to handle tags.\n */\nexport class CoreTagProvider {\n  /**\n   * Check whether tags are available in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if available, resolved with false otherwise.\n   * @since 3.7\n   */\n  areTagsAvailable(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this.areTagsAvailableInSite(site);\n    })();\n  }\n  /**\n   * Check whether tags are available in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns True if available.\n   * @since 3.7\n   */\n  areTagsAvailableInSite(site) {\n    site = site || CoreSites.getCurrentSite();\n    return !!site && site.wsAvailable('core_tag_get_tagindex_per_area') && site.wsAvailable('core_tag_get_tag_cloud') && site.wsAvailable('core_tag_get_tag_collections') && !site.isFeatureDisabled('NoDelegate_CoreTag');\n  }\n  /**\n   * Fetch the tag cloud.\n   *\n   * @param collectionId Tag collection ID.\n   * @param isStandard Whether to return only standard tags.\n   * @param sort Sort order for display (id, name, rawname, count, flag, isstandard, tagcollid).\n   * @param search Search string.\n   * @param fromContextId Context ID where this tag cloud is displayed.\n   * @param contextId Only retrieve tag instances in this context.\n   * @param recursive Retrieve tag instances in the context and its children.\n   * @param limit Maximum number of tags to retrieve. Defaults to SEARCH_LIMIT.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the tag cloud.\n   * @since 3.7\n   */\n  getTagCloud(collectionId = 0, isStandard = false, sort = 'name', search = '', fromContextId = 0, contextId = 0, recursive = true, limit, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      limit = limit || CoreTagProvider.SEARCH_LIMIT;\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        tagcollid: collectionId,\n        isstandard: isStandard,\n        limit,\n        sort,\n        search,\n        fromctx: fromContextId,\n        ctx: contextId,\n        rec: recursive\n      };\n      const preSets = {\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        cacheKey: _this2.getTagCloudKey(collectionId, isStandard, sort, search, fromContextId, contextId, recursive),\n        getFromCache: search != '' // Try to get updated data when searching.\n      };\n\n      return site.read('core_tag_get_tag_cloud', params, preSets);\n    })();\n  }\n  /**\n   * Fetch the tag collections.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the tag collections.\n   * @since 3.7\n   */\n  getTagCollections(siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const preSets = {\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        cacheKey: _this3.getTagCollectionsKey()\n      };\n      const response = yield site.read('core_tag_get_tag_collections', null, preSets);\n      if (!response || !response.collections) {\n        throw new CoreError('Cannot fetch tag collections');\n      }\n      return response.collections;\n    })();\n  }\n  /**\n   * Fetch the tag index.\n   *\n   * @param id Tag ID.\n   * @param name Tag name.\n   * @param collectionId Tag collection ID.\n   * @param areaId Tag area ID.\n   * @param fromContextId Context ID where the link was displayed.\n   * @param contextId Context ID where to search for items.\n   * @param recursive Search in the context and its children.\n   * @param page Page number.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the tag index per area.\n   * @since 3.7\n   */\n  getTagIndexPerArea(id, name = '', collectionId = 0, areaId = 0, fromContextId = 0, contextId = 0, recursive = true, page = 0, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        tagindex: {\n          id,\n          tag: name,\n          tc: collectionId,\n          ta: areaId,\n          excl: true,\n          from: fromContextId,\n          ctx: contextId,\n          rec: recursive,\n          page\n        }\n      };\n      const preSets = {\n        updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        cacheKey: _this4.getTagIndexPerAreaKey(id, name, collectionId, areaId, fromContextId, contextId, recursive)\n      };\n      let response;\n      try {\n        response = yield site.read('core_tag_get_tagindex_per_area', params, preSets);\n      } catch (error) {\n        // Workaround for WS not passing parameter to error string.\n        if (error && error.errorcode == 'notagsfound') {\n          error.message = Translate.instant('core.tag.notagsfound', {\n            $a: name || id || ''\n          });\n        }\n        throw error;\n      }\n      if (!response) {\n        throw new CoreError('Cannot fetch tag index per area');\n      }\n      return response;\n    })();\n  }\n  /**\n   * Invalidate tag cloud.\n   *\n   * @param collectionId Tag collection ID.\n   * @param isStandard Whether to return only standard tags.\n   * @param sort Sort order for display (id, name, rawname, count, flag, isstandard, tagcollid).\n   * @param search Search string.\n   * @param fromContextId Context ID where this tag cloud is displayed.\n   * @param contextId Only retrieve tag instances in this context.\n   * @param recursive Retrieve tag instances in the context and its children.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateTagCloud(collectionId = 0, isStandard = false, sort = 'name', search = '', fromContextId = 0, contextId = 0, recursive = true, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this5.getTagCloudKey(collectionId, isStandard, sort, search, fromContextId, contextId, recursive);\n      return site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Invalidate tag collections.\n   *\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateTagCollections(siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this6.getTagCollectionsKey();\n      return site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Invalidate tag index.\n   *\n   * @param id Tag ID.\n   * @param name Tag name.\n   * @param collectionId Tag collection ID.\n   * @param areaId Tag area ID.\n   * @param fromContextId Context ID where the link was displayed.\n   * @param contextId Context ID where to search for items.\n   * @param recursive Search in the context and its children.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateTagIndexPerArea(id, name = '', collectionId = 0, areaId = 0, fromContextId = 0, contextId = 0, recursive = true, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this7.getTagIndexPerAreaKey(id, name, collectionId, areaId, fromContextId, contextId, recursive);\n      return site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Get cache key for tag cloud.\n   *\n   * @param collectionId Tag collection ID.\n   * @param isStandard Whether to return only standard tags.\n   * @param sort Sort order for display (id, name, rawname, count, flag, isstandard, tagcollid).\n   * @param search Search string.\n   * @param fromContextId Context ID where this tag cloud is displayed.\n   * @param contextId Only retrieve tag instances in this context.\n   * @param recursive Retrieve tag instances in the context and it's children.\n   * @returns Cache key.\n   */\n  getTagCloudKey(collectionId, isStandard, sort, search, fromContextId, contextId, recursive) {\n    return ROOT_CACHE_KEY + 'cloud:' + collectionId + ':' + (isStandard ? 1 : 0) + ':' + sort + ':' + search + ':' + fromContextId + ':' + contextId + ':' + (recursive ? 1 : 0);\n  }\n  /**\n   * Get cache key for tag collections.\n   *\n   * @returns Cache key.\n   */\n  getTagCollectionsKey() {\n    return ROOT_CACHE_KEY + 'collections';\n  }\n  /**\n   * Get cache key for tag index.\n   *\n   * @param id Tag ID.\n   * @param name Tag name.\n   * @param collectionId Tag collection ID.\n   * @param areaId Tag area ID.\n   * @param fromContextId Context ID where the link was displayed.\n   * @param contextId Context ID where to search for items.\n   * @param recursive Search in the context and its children.\n   * @returns Cache key.\n   */\n  getTagIndexPerAreaKey(id, name, collectionId, areaId, fromContextId, contextId, recursive) {\n    return ROOT_CACHE_KEY + 'index:' + id + ':' + name + ':' + collectionId + ':' + areaId + ':' + fromContextId + ':' + contextId + ':' + (recursive ? 1 : 0);\n  }\n}\n_class = CoreTagProvider;\n_class.SEARCH_LIMIT = 150;\n_class.ɵfac = function CoreTagProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreTag = makeSingleton(CoreTagProvider);","map":{"version":3,"names":["CoreSites","CoreSite","makeSingleton","Translate","CoreError","ROOT_CACHE_KEY","CoreTagProvider","areTagsAvailable","siteId","_this","_asyncToGenerator","site","getSite","areTagsAvailableInSite","getCurrentSite","wsAvailable","isFeatureDisabled","getTagCloud","collectionId","isStandard","sort","search","fromContextId","contextId","recursive","limit","_this2","SEARCH_LIMIT","params","tagcollid","isstandard","fromctx","ctx","rec","preSets","updateFrequency","FREQUENCY_SOMETIMES","cacheKey","getTagCloudKey","getFromCache","read","getTagCollections","_this3","FREQUENCY_RARELY","getTagCollectionsKey","response","collections","getTagIndexPerArea","id","name","areaId","page","_this4","tagindex","tag","tc","ta","excl","from","FREQUENCY_OFTEN","getTagIndexPerAreaKey","error","errorcode","message","instant","$a","invalidateTagCloud","_this5","key","invalidateWsCacheForKey","invalidateTagCollections","_this6","invalidateTagIndexPerArea","_this7","_class","factory","ɵfac","providedIn","CoreTag"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/tag/services/tag.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'CoreTag:';\n\n/**\n * Service to handle tags.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreTagProvider {\n\n    static readonly SEARCH_LIMIT = 150;\n\n    /**\n     * Check whether tags are available in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if available, resolved with false otherwise.\n     * @since 3.7\n     */\n    async areTagsAvailable(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.areTagsAvailableInSite(site);\n    }\n\n    /**\n     * Check whether tags are available in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns True if available.\n     * @since 3.7\n     */\n    areTagsAvailableInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site && site.wsAvailable('core_tag_get_tagindex_per_area') &&\n            site.wsAvailable('core_tag_get_tag_cloud') &&\n            site.wsAvailable('core_tag_get_tag_collections') &&\n            !site.isFeatureDisabled('NoDelegate_CoreTag');\n    }\n\n    /**\n     * Fetch the tag cloud.\n     *\n     * @param collectionId Tag collection ID.\n     * @param isStandard Whether to return only standard tags.\n     * @param sort Sort order for display (id, name, rawname, count, flag, isstandard, tagcollid).\n     * @param search Search string.\n     * @param fromContextId Context ID where this tag cloud is displayed.\n     * @param contextId Only retrieve tag instances in this context.\n     * @param recursive Retrieve tag instances in the context and its children.\n     * @param limit Maximum number of tags to retrieve. Defaults to SEARCH_LIMIT.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the tag cloud.\n     * @since 3.7\n     */\n    async getTagCloud(\n        collectionId: number = 0,\n        isStandard: boolean = false,\n        sort: string = 'name',\n        search: string = '',\n        fromContextId: number = 0,\n        contextId: number = 0,\n        recursive: boolean = true,\n        limit?: number,\n        siteId?: string,\n    ): Promise<CoreTagCloud> {\n        limit = limit || CoreTagProvider.SEARCH_LIMIT;\n\n        const site = await CoreSites.getSite(siteId);\n        const params: CoreTagGetTagCloudWSParams = {\n            tagcollid: collectionId,\n            isstandard: isStandard,\n            limit,\n            sort,\n            search,\n            fromctx: fromContextId,\n            ctx: contextId,\n            rec: recursive,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            cacheKey: this.getTagCloudKey(collectionId, isStandard, sort, search, fromContextId, contextId, recursive),\n            getFromCache: search != '', // Try to get updated data when searching.\n        };\n\n        return site.read('core_tag_get_tag_cloud', params, preSets);\n    }\n\n    /**\n     * Fetch the tag collections.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the tag collections.\n     * @since 3.7\n     */\n    async getTagCollections(siteId?: string): Promise<CoreTagCollection[]> {\n        const site = await CoreSites.getSite(siteId);\n        const preSets: CoreSiteWSPreSets = {\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            cacheKey: this.getTagCollectionsKey(),\n        };\n\n        const response: CoreTagCollections = await site.read('core_tag_get_tag_collections', null, preSets);\n\n        if (!response || !response.collections) {\n            throw new CoreError('Cannot fetch tag collections');\n        }\n\n        return response.collections;\n    }\n\n    /**\n     * Fetch the tag index.\n     *\n     * @param id Tag ID.\n     * @param name Tag name.\n     * @param collectionId Tag collection ID.\n     * @param areaId Tag area ID.\n     * @param fromContextId Context ID where the link was displayed.\n     * @param contextId Context ID where to search for items.\n     * @param recursive Search in the context and its children.\n     * @param page Page number.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the tag index per area.\n     * @since 3.7\n     */\n    async getTagIndexPerArea(\n        id: number,\n        name: string = '',\n        collectionId: number = 0,\n        areaId: number = 0,\n        fromContextId: number = 0,\n        contextId: number = 0,\n        recursive: boolean = true,\n        page: number = 0,\n        siteId?: string,\n    ): Promise<CoreTagIndex[]> {\n        const site = await CoreSites.getSite(siteId);\n        const params: CoreTagGetTagindexPerAreaWSParams = {\n            tagindex: {\n                id,\n                tag: name,\n                tc: collectionId,\n                ta: areaId,\n                excl: true,\n                from: fromContextId,\n                ctx: contextId,\n                rec: recursive,\n                page,\n            },\n        };\n        const preSets: CoreSiteWSPreSets = {\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n            cacheKey: this.getTagIndexPerAreaKey(id, name, collectionId, areaId, fromContextId, contextId, recursive),\n        };\n\n        let response: CoreTagIndex[];\n        try {\n            response = await site.read('core_tag_get_tagindex_per_area', params, preSets);\n        } catch (error) {\n            // Workaround for WS not passing parameter to error string.\n            if (error && error.errorcode == 'notagsfound') {\n                error.message = Translate.instant('core.tag.notagsfound', { $a: name || id || '' });\n            }\n\n            throw error;\n        }\n\n        if (!response) {\n            throw new CoreError('Cannot fetch tag index per area');\n        }\n\n        return response;\n    }\n\n    /**\n     * Invalidate tag cloud.\n     *\n     * @param collectionId Tag collection ID.\n     * @param isStandard Whether to return only standard tags.\n     * @param sort Sort order for display (id, name, rawname, count, flag, isstandard, tagcollid).\n     * @param search Search string.\n     * @param fromContextId Context ID where this tag cloud is displayed.\n     * @param contextId Only retrieve tag instances in this context.\n     * @param recursive Retrieve tag instances in the context and its children.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateTagCloud(\n        collectionId: number = 0,\n        isStandard: boolean = false,\n        sort: string = 'name',\n        search: string = '',\n        fromContextId: number = 0,\n        contextId: number = 0,\n        recursive: boolean = true,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const key = this.getTagCloudKey(collectionId, isStandard, sort, search, fromContextId, contextId, recursive);\n\n        return site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Invalidate tag collections.\n     *\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateTagCollections(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const key = this.getTagCollectionsKey();\n\n        return site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Invalidate tag index.\n     *\n     * @param id Tag ID.\n     * @param name Tag name.\n     * @param collectionId Tag collection ID.\n     * @param areaId Tag area ID.\n     * @param fromContextId Context ID where the link was displayed.\n     * @param contextId Context ID where to search for items.\n     * @param recursive Search in the context and its children.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateTagIndexPerArea(\n        id: number,\n        name: string = '',\n        collectionId: number = 0,\n        areaId: number = 0,\n        fromContextId: number = 0,\n        contextId: number = 0,\n        recursive: boolean = true,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const key = this.getTagIndexPerAreaKey(id, name, collectionId, areaId, fromContextId, contextId, recursive);\n\n        return site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Get cache key for tag cloud.\n     *\n     * @param collectionId Tag collection ID.\n     * @param isStandard Whether to return only standard tags.\n     * @param sort Sort order for display (id, name, rawname, count, flag, isstandard, tagcollid).\n     * @param search Search string.\n     * @param fromContextId Context ID where this tag cloud is displayed.\n     * @param contextId Only retrieve tag instances in this context.\n     * @param recursive Retrieve tag instances in the context and it's children.\n     * @returns Cache key.\n     */\n    protected getTagCloudKey(\n        collectionId: number,\n        isStandard: boolean,\n        sort: string,\n        search: string,\n        fromContextId: number,\n        contextId: number,\n        recursive: boolean,\n    ): string {\n        return ROOT_CACHE_KEY +\n            'cloud:' +\n            collectionId + ':' +\n            (isStandard ? 1 : 0) + ':' +\n            sort + ':' + search + ':' +\n            fromContextId + ':' +\n            contextId + ':' +\n            (recursive ? 1 : 0);\n    }\n\n    /**\n     * Get cache key for tag collections.\n     *\n     * @returns Cache key.\n     */\n    protected getTagCollectionsKey(): string {\n        return ROOT_CACHE_KEY + 'collections';\n    }\n\n    /**\n     * Get cache key for tag index.\n     *\n     * @param id Tag ID.\n     * @param name Tag name.\n     * @param collectionId Tag collection ID.\n     * @param areaId Tag area ID.\n     * @param fromContextId Context ID where the link was displayed.\n     * @param contextId Context ID where to search for items.\n     * @param recursive Search in the context and its children.\n     * @returns Cache key.\n     */\n    protected getTagIndexPerAreaKey(\n        id: number,\n        name: string,\n        collectionId: number,\n        areaId: number,\n        fromContextId: number,\n        contextId: number,\n        recursive: boolean,\n    ): string {\n        return ROOT_CACHE_KEY +\n            'index:' + id + ':' +\n            name + ':' + collectionId + ':' +\n            areaId + ':' + fromContextId + ':' +\n            contextId + ':' +\n            (recursive ? 1 : 0);\n    }\n\n}\n\nexport const CoreTag = makeSingleton(CoreTagProvider);\n\n/**\n * Params of core_tag_get_tag_cloud WS.\n */\nexport type CoreTagGetTagCloudWSParams = {\n    tagcollid?: number; // Tag collection id.\n    isstandard?: boolean; // Whether to return only standard tags.\n    limit?: number; // Maximum number of tags to retrieve.\n    sort?: string; // Sort order for display (id, name, rawname, count, flag, isstandard, tagcollid).\n    search?: string; // Search string.\n    fromctx?: number; // Context id where this tag cloud is displayed.\n    ctx?: number; // Only retrieve tag instances in this context.\n    rec?: boolean; // Retrieve tag instances in the $ctx context and it's children.\n};\n\n/**\n * Structure of a tag cloud returned by WS.\n */\nexport type CoreTagCloud = {\n    tags: CoreTagCloudTag[];\n    tagscount: number;\n    totalcount: number;\n};\n\n/**\n * Structure of a tag cloud tag returned by WS.\n */\nexport type CoreTagCloudTag = {\n    name: string;\n    viewurl: string;\n    flag: boolean;\n    isstandard: boolean;\n    count: number;\n    size: number;\n};\n\n/**\n * Structure of a tag collection returned by WS.\n */\nexport type CoreTagCollection = {\n    id: number; // Collection id.\n    name: string; // Collection name.\n    isdefault: boolean; // Whether is the default collection.\n    component: string; // Component the collection is related to.\n    sortorder: number; // Collection ordering in the list.\n    searchable: boolean; // Whether the tag collection is searchable.\n    customurl: string; // Custom URL for the tag page instead of /tag/index.php.\n};\n\n/**\n * Structure of tag collections returned by WS.\n */\nexport type CoreTagCollections = {\n    collections: CoreTagCollection[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_tag_get_tagindex_per_area WS.\n */\nexport type CoreTagGetTagindexPerAreaWSParams = {\n    tagindex: {\n        id?: number; // Tag id.\n        tag?: string; // Tag name.\n        tc?: number; // Tag collection id.\n        ta?: number; // Tag area id.\n        excl?: boolean; // Exlusive mode for this tag area.\n        from?: number; // Context id where the link was displayed.\n        ctx?: number; // Context id where to search for items.\n        rec?: boolean; // Search in the context recursive.\n        page?: number; // Page number (0-based).\n    }; // Parameters.\n};\n\n/**\n * Structure of a tag index returned by WS.\n */\nexport type CoreTagIndex = {\n    tagid: number;\n    ta: number;\n    component: string;\n    itemtype: string;\n    nextpageurl: string;\n    prevpageurl: string;\n    exclusiveurl: string;\n    exclusivetext: string;\n    title: string;\n    content: string;\n    hascontent: number;\n    anchor: string;\n};\n\n/**\n * Structure of a tag item returned by WS.\n */\nexport type CoreTagItem = {\n    id: number; // Tag id.\n    name: string; // Tag name.\n    rawname: string; // The raw, unnormalised name for the tag as entered by users.\n    isstandard: boolean; // Whether this tag is standard.\n    tagcollid: number; // Tag collection id.\n    taginstanceid: number; // Tag instance id.\n    taginstancecontextid: number; // Context the tag instance belongs to.\n    itemid: number; // Id of the record tagged.\n    ordering: number; // Tag ordering.\n    flag: number; // Whether the tag is flagged as inappropriate.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}