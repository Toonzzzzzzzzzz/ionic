{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreSites } from '@services/sites';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\n/**\n * Superclass to help creating delegates\n */\nexport class CoreDelegate {\n  /**\n   * Constructor of the Delegate.\n   *\n   * @param delegateName Delegate name used for logging purposes.\n   * @param listenSiteEvents Whether to update the handler when a site event occurs (login, site updated, ...).\n   */\n  constructor(delegateName, listenSiteEvents = true) {\n    /**\n     * List of registered handlers.\n     */\n    this.handlers = {};\n    /**\n     * List of registered handlers enabled for the current site.\n     */\n    this.enabledHandlers = {};\n    /**\n     * Time when last updateHandler functions started.\n     */\n    this.lastUpdateHandlersStart = 0;\n    /**\n     * Name of the property to be used to index the handlers. By default, the handler's name will be used.\n     * If your delegate uses a Moodle component name to identify the handlers, please override this property.\n     * E.g. CoreCourseModuleDelegate uses 'modName' to index the handlers.\n     */\n    this.handlerNameProperty = 'name';\n    /**\n     * Set of promises to update a handler, to prevent doing the same operation twice.\n     */\n    this.updatePromises = {};\n    /**\n     * Whether handlers have been initialized.\n     */\n    this.handlersInitialized = false;\n    this.logger = CoreLogger.getInstance(delegateName);\n    this.handlersInitPromise = new Promise(resolve => {\n      this.handlersInitResolve = resolve;\n    });\n    if (listenSiteEvents) {\n      // Update handlers on this cases.\n      CoreEvents.on(CoreEvents.LOGIN, () => this.updateHandlers());\n      CoreEvents.on(CoreEvents.SITE_UPDATED, () => this.updateHandlers());\n      CoreEvents.on(CoreEvents.SITE_PLUGINS_LOADED, () => this.updateHandlers());\n      CoreEvents.on(CoreEvents.SITE_POLICY_AGREED, data => {\n        if (data.siteId === CoreSites.getCurrentSiteId()) {\n          this.updateHandlers();\n        }\n      });\n      CoreEvents.on(CoreEvents.COMPLETE_REQUIRED_PROFILE_DATA_FINISHED, data => {\n        if (data.siteId === CoreSites.getCurrentSiteId()) {\n          this.updateHandlers();\n        }\n      });\n    }\n  }\n  /**\n   * Execute a certain function in a enabled handler.\n   * If the handler isn't found or function isn't defined, call the same function in the default handler.\n   *\n   * @param handlerName The handler name.\n   * @param fnName Name of the function to execute.\n   * @param params Parameters to pass to the function.\n   * @returns Function returned value or default value.\n   */\n  executeFunctionOnEnabled(handlerName, fnName, params) {\n    return this.execute(this.enabledHandlers[handlerName], fnName, params);\n  }\n  /**\n   * Execute a certain function in a handler.\n   * If the handler isn't found or function isn't defined, call the same function in the default handler.\n   *\n   * @param handlerName The handler name.\n   * @param fnName Name of the function to execute.\n   * @param params Parameters to pass to the function.\n   * @returns Function returned value or default value.\n   */\n  executeFunction(handlerName, fnName, params) {\n    return this.execute(this.handlers[handlerName], fnName, params);\n  }\n  /**\n   * Execute a certain function in a handler.\n   * If the handler isn't found or function isn't defined, call the same function in the default handler.\n   *\n   * @param handler The handler.\n   * @param fnName Name of the function to execute.\n   * @param params Parameters to pass to the function.\n   * @returns Function returned value or default value.\n   */\n  execute(handler, fnName, params) {\n    if (handler && handler[fnName]) {\n      return handler[fnName].apply(handler, params);\n    } else if (this.defaultHandler && this.defaultHandler[fnName]) {\n      return this.defaultHandler[fnName].apply(this.defaultHandler, params);\n    }\n  }\n  /**\n   * Get a handler.\n   *\n   * @param handlerName The handler name.\n   * @param enabled Only enabled, or any.\n   * @returns Handler.\n   */\n  getHandler(handlerName, enabled = false) {\n    return enabled ? this.enabledHandlers[handlerName] : this.handlers[handlerName];\n  }\n  /**\n   * Gets the handler full name for a given name. This is useful when the handlerNameProperty is different than \"name\".\n   * E.g. blocks are indexed by blockName. If you call this function passing the blockName it will return the name.\n   *\n   * @param name Name used to indentify the handler.\n   * @returns Full name of corresponding handler.\n   */\n  getHandlerName(name) {\n    const handler = this.getHandler(name, true);\n    if (!handler) {\n      return '';\n    }\n    return handler.name;\n  }\n  /**\n   * Check if function exists on a handler.\n   *\n   * @param handlerName The handler name.\n   * @param fnName Name of the function to execute.\n   * @param onlyEnabled If check only enabled handlers or all.\n   * @returns Function returned value or default value.\n   */\n  hasFunction(handlerName, fnName, onlyEnabled = true) {\n    const handler = onlyEnabled ? this.enabledHandlers[handlerName] : this.handlers[handlerName];\n    return handler && typeof handler[fnName] == 'function';\n  }\n  /**\n   * Check if a handler name has a registered handler (not necessarily enabled).\n   *\n   * @param name The handler name.\n   * @param enabled Only enabled, or any.\n   * @returns If the handler is registered or not.\n   */\n  hasHandler(name, enabled = false) {\n    return enabled ? this.enabledHandlers[name] !== undefined : this.handlers[name] !== undefined;\n  }\n  /**\n   * Check if the delegate has at least 1 registered handler (not necessarily enabled).\n   *\n   * @returns If there is at least 1 handler.\n   */\n  hasHandlers() {\n    return Object.keys(this.handlers).length > 0;\n  }\n  /**\n   * Check if a time belongs to the last update handlers call.\n   * This is to handle the cases where updateHandlers don't finish in the same order as they're called.\n   *\n   * @param time Time to check.\n   * @returns Whether it's the last call.\n   */\n  isLastUpdateCall(time) {\n    if (!this.lastUpdateHandlersStart) {\n      return true;\n    }\n    return time == this.lastUpdateHandlersStart;\n  }\n  /**\n   * Register a handler.\n   *\n   * @param handler The handler delegate object to register.\n   * @returns True when registered, false if already registered.\n   */\n  registerHandler(handler) {\n    const key = handler[this.handlerNameProperty] || handler.name;\n    if (this.handlers[key] !== undefined) {\n      this.logger.log(`Handler '${handler[this.handlerNameProperty]}' already registered`);\n      return false;\n    }\n    this.logger.log(`Registered handler '${handler[this.handlerNameProperty]}'`);\n    this.handlers[key] = handler;\n    return true;\n  }\n  /**\n   * Update the handler for the current site.\n   *\n   * @param handler The handler to check.\n   * @returns Resolved when done.\n   */\n  updateHandler(handler) {\n    const siteId = CoreSites.getCurrentSiteId();\n    const currentSite = CoreSites.getCurrentSite();\n    let promise;\n    if (this.updatePromises[siteId] && this.updatePromises[siteId][handler.name] !== undefined) {\n      // There's already an update ongoing for this handler, return the promise.\n      return this.updatePromises[siteId][handler.name];\n    } else if (!this.updatePromises[siteId]) {\n      this.updatePromises[siteId] = {};\n    }\n    if (!currentSite || this.isFeatureDisabled(handler, currentSite)) {\n      promise = Promise.resolve(false);\n    } else {\n      promise = Promise.resolve(handler.isEnabled()).catch(() => false);\n    }\n    // Checks if the handler is enabled.\n    this.updatePromises[siteId][handler.name] = promise.then(enabled => {\n      // Check that site hasn't changed since the check started.\n      if (CoreSites.getCurrentSiteId() === siteId) {\n        const key = handler[this.handlerNameProperty] || handler.name;\n        if (enabled) {\n          this.enabledHandlers[key] = handler;\n        } else {\n          delete this.enabledHandlers[key];\n        }\n      }\n      return;\n    }).finally(() => {\n      // Update finished, delete the promise.\n      delete this.updatePromises[siteId][handler.name];\n    });\n    return this.updatePromises[siteId][handler.name];\n  }\n  /**\n   * Check if feature is enabled or disabled in the site, depending on the feature prefix and the handler name.\n   *\n   * @param handler Handler to check.\n   * @param site Site to check.\n   * @returns Whether is enabled or disabled in site.\n   */\n  isFeatureDisabled(handler, site) {\n    return this.featurePrefix !== undefined && site.isFeatureDisabled(this.featurePrefix + handler.name);\n  }\n  /**\n   * Update the handlers for the current site.\n   *\n   * @returns Resolved when done.\n   */\n  updateHandlers() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      const now = Date.now();\n      _this.logger.debug('Updating handlers for current site.');\n      _this.lastUpdateHandlersStart = now;\n      // Loop over all the handlers.\n      for (const name in _this.handlers) {\n        promises.push(_this.updateHandler(_this.handlers[name]));\n      }\n      try {\n        yield Promise.all(promises);\n      } catch (e) {\n        // Never reject\n      }\n      // Verify that this call is the last one that was started.\n      if (_this.isLastUpdateCall(now)) {\n        _this.handlersInitialized = true;\n        _this.handlersInitResolve();\n        _this.updateData();\n      }\n    })();\n  }\n  /**\n   * Update handlers Data.\n   * Override this function to update handlers data.\n   */\n  updateData() {\n    // To be overridden.\n  }\n}","map":{"version":3,"names":["CoreSites","CoreEvents","CoreLogger","CoreDelegate","constructor","delegateName","listenSiteEvents","handlers","enabledHandlers","lastUpdateHandlersStart","handlerNameProperty","updatePromises","handlersInitialized","logger","getInstance","handlersInitPromise","Promise","resolve","handlersInitResolve","on","LOGIN","updateHandlers","SITE_UPDATED","SITE_PLUGINS_LOADED","SITE_POLICY_AGREED","data","siteId","getCurrentSiteId","COMPLETE_REQUIRED_PROFILE_DATA_FINISHED","executeFunctionOnEnabled","handlerName","fnName","params","execute","executeFunction","handler","apply","defaultHandler","getHandler","enabled","getHandlerName","name","hasFunction","onlyEnabled","hasHandler","undefined","hasHandlers","Object","keys","length","isLastUpdateCall","time","registerHandler","key","log","updateHandler","currentSite","getCurrentSite","promise","isFeatureDisabled","isEnabled","catch","then","finally","site","featurePrefix","_this","_asyncToGenerator","promises","now","Date","debug","push","all","e","updateData"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreSites } from '@services/sites';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreLogger } from '@singletons/logger';\n\n/**\n * Superclass to help creating delegates\n */\nexport class CoreDelegate<HandlerType extends CoreDelegateHandler> {\n\n    /**\n     * Logger instance.\n     */\n    protected logger: CoreLogger;\n\n    /**\n     * List of registered handlers.\n     */\n    protected handlers: { [s: string]: HandlerType } = {};\n\n    /**\n     * List of registered handlers enabled for the current site.\n     */\n    protected enabledHandlers: { [s: string]: HandlerType } = {};\n\n    /**\n     * Default handler\n     */\n    protected defaultHandler?: HandlerType;\n\n    /**\n     * Time when last updateHandler functions started.\n     */\n    protected lastUpdateHandlersStart = 0;\n\n    /**\n     * Feature prefix to check is feature is enabled or disabled in site.\n     * This check is only made if not false. Override on the subclass or override isFeatureDisabled function.\n     */\n    protected featurePrefix?: string;\n\n    /**\n     * Name of the property to be used to index the handlers. By default, the handler's name will be used.\n     * If your delegate uses a Moodle component name to identify the handlers, please override this property.\n     * E.g. CoreCourseModuleDelegate uses 'modName' to index the handlers.\n     */\n    protected handlerNameProperty = 'name';\n\n    /**\n     * Set of promises to update a handler, to prevent doing the same operation twice.\n     */\n    protected updatePromises: {[siteId: string]: {[name: string]: Promise<void>}} = {};\n\n    /**\n     * Whether handlers have been initialized.\n     */\n    protected handlersInitialized = false;\n\n    /**\n     * Promise to wait for handlers to be initialized.\n     */\n    protected handlersInitPromise: Promise<void>;\n\n    /**\n     * Function to resolve the handlers init promise.\n     */\n    protected handlersInitResolve!: () => void;\n\n    /**\n     * Constructor of the Delegate.\n     *\n     * @param delegateName Delegate name used for logging purposes.\n     * @param listenSiteEvents Whether to update the handler when a site event occurs (login, site updated, ...).\n     */\n    constructor(delegateName: string, listenSiteEvents: boolean = true) {\n        this.logger = CoreLogger.getInstance(delegateName);\n\n        this.handlersInitPromise = new Promise((resolve): void => {\n            this.handlersInitResolve = resolve;\n        });\n\n        if (listenSiteEvents) {\n            // Update handlers on this cases.\n            CoreEvents.on(CoreEvents.LOGIN, () => this.updateHandlers());\n            CoreEvents.on(CoreEvents.SITE_UPDATED, () => this.updateHandlers());\n            CoreEvents.on(CoreEvents.SITE_PLUGINS_LOADED, () => this.updateHandlers());\n            CoreEvents.on(CoreEvents.SITE_POLICY_AGREED, (data) => {\n                if (data.siteId === CoreSites.getCurrentSiteId()) {\n                    this.updateHandlers();\n                }\n            });\n            CoreEvents.on(CoreEvents.COMPLETE_REQUIRED_PROFILE_DATA_FINISHED, (data) => {\n                if (data.siteId === CoreSites.getCurrentSiteId()) {\n                    this.updateHandlers();\n                }\n            });\n        }\n    }\n\n    /**\n     * Execute a certain function in a enabled handler.\n     * If the handler isn't found or function isn't defined, call the same function in the default handler.\n     *\n     * @param handlerName The handler name.\n     * @param fnName Name of the function to execute.\n     * @param params Parameters to pass to the function.\n     * @returns Function returned value or default value.\n     */\n    protected executeFunctionOnEnabled<T = unknown>(handlerName: string, fnName: string, params?: unknown[]): T | undefined {\n        return this.execute<T>(this.enabledHandlers[handlerName], fnName, params);\n    }\n\n    /**\n     * Execute a certain function in a handler.\n     * If the handler isn't found or function isn't defined, call the same function in the default handler.\n     *\n     * @param handlerName The handler name.\n     * @param fnName Name of the function to execute.\n     * @param params Parameters to pass to the function.\n     * @returns Function returned value or default value.\n     */\n    protected executeFunction<T = unknown>(handlerName: string, fnName: string, params?: unknown[]): T | undefined {\n        return this.execute<T>(this.handlers[handlerName], fnName, params);\n    }\n\n    /**\n     * Execute a certain function in a handler.\n     * If the handler isn't found or function isn't defined, call the same function in the default handler.\n     *\n     * @param handler The handler.\n     * @param fnName Name of the function to execute.\n     * @param params Parameters to pass to the function.\n     * @returns Function returned value or default value.\n     */\n    private execute<T = unknown>(handler: HandlerType, fnName: string, params?: unknown[]): T | undefined {\n        if (handler && handler[fnName]) {\n            return handler[fnName].apply(handler, params);\n        } else if (this.defaultHandler && this.defaultHandler[fnName]) {\n            return this.defaultHandler[fnName].apply(this.defaultHandler, params);\n        }\n    }\n\n    /**\n     * Get a handler.\n     *\n     * @param handlerName The handler name.\n     * @param enabled Only enabled, or any.\n     * @returns Handler.\n     */\n    protected getHandler(handlerName: string, enabled: boolean = false): HandlerType {\n        return enabled ? this.enabledHandlers[handlerName] : this.handlers[handlerName];\n    }\n\n    /**\n     * Gets the handler full name for a given name. This is useful when the handlerNameProperty is different than \"name\".\n     * E.g. blocks are indexed by blockName. If you call this function passing the blockName it will return the name.\n     *\n     * @param name Name used to indentify the handler.\n     * @returns Full name of corresponding handler.\n     */\n    getHandlerName(name: string): string {\n        const handler = this.getHandler(name, true);\n\n        if (!handler) {\n            return '';\n        }\n\n        return handler.name;\n    }\n\n    /**\n     * Check if function exists on a handler.\n     *\n     * @param handlerName The handler name.\n     * @param fnName Name of the function to execute.\n     * @param onlyEnabled If check only enabled handlers or all.\n     * @returns Function returned value or default value.\n     */\n    protected hasFunction(handlerName: string, fnName: string, onlyEnabled: boolean = true): boolean {\n        const handler = onlyEnabled ? this.enabledHandlers[handlerName] : this.handlers[handlerName];\n\n        return handler && typeof handler[fnName] == 'function';\n    }\n\n    /**\n     * Check if a handler name has a registered handler (not necessarily enabled).\n     *\n     * @param name The handler name.\n     * @param enabled Only enabled, or any.\n     * @returns If the handler is registered or not.\n     */\n    hasHandler(name: string, enabled: boolean = false): boolean {\n        return enabled ? this.enabledHandlers[name] !== undefined : this.handlers[name] !== undefined;\n    }\n\n    /**\n     * Check if the delegate has at least 1 registered handler (not necessarily enabled).\n     *\n     * @returns If there is at least 1 handler.\n     */\n    hasHandlers(): boolean {\n        return Object.keys(this.handlers).length > 0;\n    }\n\n    /**\n     * Check if a time belongs to the last update handlers call.\n     * This is to handle the cases where updateHandlers don't finish in the same order as they're called.\n     *\n     * @param time Time to check.\n     * @returns Whether it's the last call.\n     */\n    isLastUpdateCall(time: number): boolean {\n        if (!this.lastUpdateHandlersStart) {\n            return true;\n        }\n\n        return time == this.lastUpdateHandlersStart;\n    }\n\n    /**\n     * Register a handler.\n     *\n     * @param handler The handler delegate object to register.\n     * @returns True when registered, false if already registered.\n     */\n    registerHandler(handler: HandlerType): boolean {\n        const key = handler[this.handlerNameProperty] || handler.name;\n\n        if (this.handlers[key] !== undefined) {\n            this.logger.log(`Handler '${handler[this.handlerNameProperty]}' already registered`);\n\n            return false;\n        }\n\n        this.logger.log(`Registered handler '${handler[this.handlerNameProperty]}'`);\n        this.handlers[key] = handler;\n\n        return true;\n    }\n\n    /**\n     * Update the handler for the current site.\n     *\n     * @param handler The handler to check.\n     * @returns Resolved when done.\n     */\n    protected updateHandler(handler: HandlerType): Promise<void> {\n        const siteId = CoreSites.getCurrentSiteId();\n        const currentSite = CoreSites.getCurrentSite();\n        let promise: Promise<boolean>;\n\n        if (this.updatePromises[siteId] && this.updatePromises[siteId][handler.name] !== undefined) {\n            // There's already an update ongoing for this handler, return the promise.\n            return this.updatePromises[siteId][handler.name];\n        } else if (!this.updatePromises[siteId]) {\n            this.updatePromises[siteId] = {};\n        }\n\n        if (!currentSite || this.isFeatureDisabled(handler, currentSite)) {\n            promise = Promise.resolve(false);\n        } else {\n            promise = Promise.resolve(handler.isEnabled()).catch(() => false);\n        }\n\n        // Checks if the handler is enabled.\n        this.updatePromises[siteId][handler.name] = promise.then((enabled: boolean) => {\n            // Check that site hasn't changed since the check started.\n            if (CoreSites.getCurrentSiteId() === siteId) {\n                const key = handler[this.handlerNameProperty] || handler.name;\n\n                if (enabled) {\n                    this.enabledHandlers[key] = handler;\n                } else {\n                    delete this.enabledHandlers[key];\n                }\n            }\n\n            return;\n        }).finally(() => {\n            // Update finished, delete the promise.\n            delete this.updatePromises[siteId][handler.name];\n        });\n\n        return this.updatePromises[siteId][handler.name];\n    }\n\n    /**\n     * Check if feature is enabled or disabled in the site, depending on the feature prefix and the handler name.\n     *\n     * @param handler Handler to check.\n     * @param site Site to check.\n     * @returns Whether is enabled or disabled in site.\n     */\n    protected isFeatureDisabled(handler: HandlerType, site: CoreSite): boolean {\n        return this.featurePrefix !== undefined && site.isFeatureDisabled(this.featurePrefix + handler.name);\n    }\n\n    /**\n     * Update the handlers for the current site.\n     *\n     * @returns Resolved when done.\n     */\n    async updateHandlers(): Promise<void> {\n        const promises: Promise<void>[] = [];\n        const now = Date.now();\n\n        this.logger.debug('Updating handlers for current site.');\n\n        this.lastUpdateHandlersStart = now;\n\n        // Loop over all the handlers.\n        for (const name in this.handlers) {\n            promises.push(this.updateHandler(this.handlers[name]));\n        }\n\n        try {\n            await Promise.all(promises);\n        } catch (e) {\n            // Never reject\n        }\n\n        // Verify that this call is the last one that was started.\n        if (this.isLastUpdateCall(now)) {\n            this.handlersInitialized = true;\n            this.handlersInitResolve();\n\n            this.updateData();\n        }\n    }\n\n    /**\n     * Update handlers Data.\n     * Override this function to update handlers data.\n     */\n    updateData(): void {\n        // To be overridden.\n    }\n\n}\n\n/**\n * Base interface for any delegate.\n */\nexport interface CoreDelegateHandler {\n    /**\n     * Name of the handler, or name and sub context (AddonMessages, AddonMessages:blockContact, ...).\n     * This name will be used to check if the feature is disabled.\n     */\n    name: string;\n\n    /**\n     * Whether or not the handler is enabled on a site level.\n     *\n     * @returns Whether or not the handler is enabled on a site level.\n     */\n    isEnabled(): Promise<boolean>;\n}\n\n/**\n * Data returned by the delegate for each handler to be displayed.\n */\nexport interface CoreDelegateToDisplay {\n    /**\n     * Name of the handler.\n     */\n    name?: string;\n\n    /**\n     * Priority of the handler.\n     */\n    priority?: number;\n}\n\n/**\n * Base interface for a core delegate needed to be displayed.\n */\nexport interface CoreDelegateDisplayHandler<HandlerData extends CoreDelegateToDisplay> extends CoreDelegateHandler {\n    /**\n     * The highest priority is displayed first.\n     */\n    priority?: number;\n\n    /**\n     * Returns the data needed to render the handler.\n     *\n     * @returns Data.\n     */\n    getDisplayData(): HandlerData;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}