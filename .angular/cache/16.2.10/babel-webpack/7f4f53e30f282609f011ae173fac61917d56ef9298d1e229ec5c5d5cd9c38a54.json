{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreCommentsOffline } from './comments-offline';\nimport { CoreCommentsSyncProvider } from './comments-sync';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmComments:';\n/**\n * Service that provides some features regarding comments.\n */\nexport class CoreCommentsProvider {\n  // If true, the pageSize is definitive. If not, it's a temporal value to reduce WS calls.\n  /**\n   * Initialize the module service.\n   */\n  initialize() {\n    // Reset comments page size.\n    CoreEvents.on(CoreEvents.LOGIN, () => {\n      CoreCommentsProvider.pageSize = 1;\n      CoreCommentsProvider.pageSizeOK = false;\n    });\n  }\n  /**\n   * Add a comment.\n   *\n   * @param content Comment text.\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if comment was sent to server, false if stored in device.\n   */\n  addComment(content, contextLevel, instanceId, component, itemId, area = '', siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a comment to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          yield CoreCommentsOffline.saveComment(content, contextLevel, instanceId, component, itemId, area, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the comment.\n        return storeOffline();\n      }\n      // Send comment to server.\n      try {\n        return yield _this.addCommentOnline(content, contextLevel, instanceId, component, itemId, area, siteId);\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, the user cannot send the message so don't store it.\n          throw error;\n        }\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Add a comment. It will fail if offline or cannot connect.\n   *\n   * @param content Comment text.\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when added, rejected otherwise.\n   */\n  addCommentOnline(content, contextLevel, instanceId, component, itemId, area = '', siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const comments = [{\n        contextlevel: contextLevel,\n        instanceid: instanceId,\n        component: component,\n        itemid: itemId,\n        area: area,\n        content: content\n      }];\n      const commentsResponse = yield _this2.addCommentsOnline(comments, siteId);\n      // A comment was added, invalidate them.\n      yield CoreUtils.ignoreErrors(_this2.invalidateCommentsData(contextLevel, instanceId, component, itemId, area, siteId));\n      return commentsResponse[0];\n    })();\n  }\n  /**\n   * Add several comments. It will fail if offline or cannot connect.\n   *\n   * @param comments Comments to save.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when added, rejected otherwise. Promise resolved doesn't mean that comments\n   *         have been added, the resolve param can contain errors for comments not sent.\n   */\n  addCommentsOnline(comments, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!comments || !comments.length) {\n        return [];\n      }\n      const site = yield CoreSites.getSite(siteId);\n      const data = {\n        comments: comments\n      };\n      return site.write('core_comment_add_comments', data);\n    })();\n  }\n  /**\n   * Check if Calendar is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether it's disabled.\n   */\n  areCommentsDisabledInSite(site) {\n    var _site;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site = site) !== null && _site !== void 0 && _site.isFeatureDisabled('NoDelegate_CoreComments'));\n  }\n  /**\n   * Check if comments are disabled in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n   */\n  areCommentsDisabled(siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this3.areCommentsDisabledInSite(site);\n    })();\n  }\n  /**\n   * Delete a comment.\n   *\n   * @param comment Comment object to delete.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when deleted (with true if deleted in online, false otherwise), rejected otherwise.\n   *  Promise resolved doesn't mean that comments have been deleted,the resolve param can contain errors for comment\n   *  not deleted.\n   */\n  deleteComment(comment, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Offline comment, just delete it.\n      if (!comment.id) {\n        yield CoreCommentsOffline.removeComment(comment.contextlevel, comment.instanceid, comment.component, comment.itemid, comment.area, siteId);\n        return false;\n      }\n      // Convenience function to store the action to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          if (!comment.id) {\n            return false;\n          }\n          yield CoreCommentsOffline.deleteComment(comment.id, comment.contextlevel, comment.instanceid, comment.component, comment.itemid, comment.area, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the comment.\n        return storeOffline();\n      }\n      // Send comment to server.\n      try {\n        yield _this4.deleteCommentsOnline([comment.id], comment.contextlevel, comment.instanceid, comment.component, comment.itemid, comment.area, siteId);\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, the user cannot send the comment so don't store it.\n          throw error;\n        }\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Delete a comment. It will fail if offline or cannot connect.\n   *\n   * @param commentIds Comment IDs to delete.\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when deleted, rejected otherwise. Promise resolved doesn't mean that comments\n   *         have been deleted, the resolve param can contain errors for comments not deleted.\n   */\n  deleteCommentsOnline(commentIds, contextLevel, instanceId, component, itemId, area = '', siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const data = {\n        comments: commentIds\n      };\n      yield site.write('core_comment_delete_comments', data);\n      yield CoreUtils.ignoreErrors(_this5.invalidateCommentsData(contextLevel, instanceId, component, itemId, area, siteId));\n    })();\n  }\n  /**\n   * Returns whether WS to add/delete comments are available in site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if available, resolved with false or rejected otherwise.\n   * @since 3.8\n   */\n  isAddCommentsAvailable(siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // First check if it's disabled.\n      if (_this6.areCommentsDisabledInSite(site)) {\n        return false;\n      }\n      return site.wsAvailable('core_comment_add_comments');\n    })();\n  }\n  /**\n   * Get cache key for get comments data WS calls.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @returns Cache key.\n   */\n  getCommentsCacheKey(contextLevel, instanceId, component, itemId, area = '') {\n    return this.getCommentsPrefixCacheKey(contextLevel, instanceId) + ':' + component + ':' + itemId + ':' + area;\n  }\n  /**\n   * Get cache key for get comments instance data WS calls.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @returns Cache key.\n   */\n  getCommentsPrefixCacheKey(contextLevel, instanceId) {\n    return ROOT_CACHE_KEY + 'comments:' + contextLevel + ':' + instanceId;\n  }\n  /**\n   * Retrieve a list of comments.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param page Page number (0 based). Default 0.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the comments.\n   */\n  getComments(contextLevel, instanceId, component, itemId, area = '', page = 0, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        contextlevel: contextLevel,\n        instanceid: instanceId,\n        component: component,\n        itemid: itemId,\n        area: area,\n        page: page\n      };\n      const preSets = {\n        cacheKey: _this7.getCommentsCacheKey(contextLevel, instanceId, component, itemId, area),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      const response = yield site.read('core_comment_get_comments', params, preSets);\n      if (response.comments) {\n        // Update pageSize with the greatest count at the moment.\n        if (response.count === undefined && response.comments.length > CoreCommentsProvider.pageSize) {\n          CoreCommentsProvider.pageSize = response.comments.length;\n        }\n        return response;\n      }\n      throw new CoreError('No comments returned');\n    })();\n  }\n  /**\n   * Get comments count number to show on the comments component.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Comments count with plus sign if needed.\n   */\n  getCommentsCount(contextLevel, instanceId, component, itemId, area = '', siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId ? siteId : CoreSites.getCurrentSiteId();\n      let trueCount = false;\n      // Convenience function to get comments number on a page.\n      const getCommentsPageCount = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (page) {\n          try {\n            const response = yield _this8.getComments(contextLevel, instanceId, component, itemId, area, page, siteId);\n            // Count is only available in 3.8 onwards.\n            if (response.count !== undefined) {\n              trueCount = true;\n              return response.count;\n            }\n            if (response.comments) {\n              return response.comments.length || 0;\n            }\n            return -1;\n          } catch (_unused) {\n            return -1;\n          }\n        });\n        return function getCommentsPageCount(_x) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      const count = yield getCommentsPageCount(0);\n      if (trueCount || count < CoreCommentsProvider.pageSize) {\n        return count + '';\n      } else if (CoreCommentsProvider.pageSizeOK && count >= CoreCommentsProvider.pageSize) {\n        // Page Size is ok, show + in case it reached the limit.\n        return CoreCommentsProvider.pageSize - 1 + '+';\n      }\n      const countMore = yield getCommentsPageCount(1);\n      // Page limit was reached on the previous call.\n      if (countMore > 0) {\n        CoreCommentsProvider.pageSizeOK = true;\n        return CoreCommentsProvider.pageSize - 1 + '+';\n      }\n      return count + '';\n    })();\n  }\n  /**\n   * Invalidates comments data.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCommentsData(contextLevel, instanceId, component, itemId, area = '', siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield CoreUtils.allPromises([\n      // This is done with starting with to avoid conflicts with previous keys that were including page.\n      site.invalidateWsCacheForKeyStartingWith(_this9.getCommentsCacheKey(contextLevel, instanceId, component, itemId, area) + ':'), site.invalidateWsCacheForKey(_this9.getCommentsCacheKey(contextLevel, instanceId, component, itemId, area))]);\n    })();\n  }\n  /**\n   * Invalidates all comments data for an instance.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCommentsByInstance(contextLevel, instanceId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this10.getCommentsPrefixCacheKey(contextLevel, instanceId));\n    })();\n  }\n}\n_class = CoreCommentsProvider;\n_class.REFRESH_COMMENTS_EVENT = 'core_comments_refresh_comments';\n_class.COMMENTS_COUNT_CHANGED_EVENT = 'core_comments_count_changed';\n_class.pageSize = 1;\n// At least it will be one.\n_class.pageSizeOK = false;\n_class.ɵfac = function CoreCommentsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreComments = makeSingleton(CoreCommentsProvider);","map":{"version":3,"names":["CoreError","CoreSite","CoreNetwork","CoreSites","CoreUtils","makeSingleton","CoreEvents","CoreCommentsOffline","CoreCommentsSyncProvider","ROOT_CACHE_KEY","CoreCommentsProvider","initialize","on","LOGIN","pageSize","pageSizeOK","addComment","content","contextLevel","instanceId","component","itemId","area","siteId","_this","_asyncToGenerator","getCurrentSiteId","storeOffline","_ref","saveComment","apply","arguments","isOnline","addCommentOnline","error","isWebServiceError","_this2","comments","contextlevel","instanceid","itemid","commentsResponse","addCommentsOnline","ignoreErrors","invalidateCommentsData","length","site","getSite","data","write","areCommentsDisabledInSite","_site","getCurrentSite","isFeatureDisabled","areCommentsDisabled","_this3","deleteComment","comment","_this4","id","removeComment","_ref2","deleteCommentsOnline","commentIds","_this5","isAddCommentsAvailable","_this6","wsAvailable","getCommentsCacheKey","getCommentsPrefixCacheKey","getComments","page","_this7","params","preSets","cacheKey","updateFrequency","FREQUENCY_SOMETIMES","response","read","count","undefined","getCommentsCount","_this8","trueCount","getCommentsPageCount","_ref3","_unused","_x","countMore","_this9","allPromises","invalidateWsCacheForKeyStartingWith","invalidateWsCacheForKey","invalidateCommentsByInstance","_this10","_class","REFRESH_COMMENTS_EVENT","COMMENTS_COUNT_CHANGED_EVENT","factory","ɵfac","providedIn","CoreComments"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/comments/services/comments.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreCommentsOffline } from './comments-offline';\nimport { CoreCommentsSyncAutoSyncData, CoreCommentsSyncProvider } from './comments-sync';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmComments:';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [CoreCommentsProvider.REFRESH_COMMENTS_EVENT]: CoreCommentsRefreshCommentsEventData;\n        [CoreCommentsProvider.COMMENTS_COUNT_CHANGED_EVENT]: CoreCommentsCountChangedEventData;\n        [CoreCommentsSyncProvider.AUTO_SYNCED]: CoreCommentsSyncAutoSyncData;\n    }\n\n}\n\n/**\n * Service that provides some features regarding comments.\n */\n@Injectable( { providedIn: 'root' })\nexport class CoreCommentsProvider {\n\n    static readonly REFRESH_COMMENTS_EVENT = 'core_comments_refresh_comments';\n    static readonly COMMENTS_COUNT_CHANGED_EVENT = 'core_comments_count_changed';\n\n    static pageSize = 1; // At least it will be one.\n    static pageSizeOK = false; // If true, the pageSize is definitive. If not, it's a temporal value to reduce WS calls.\n\n    /**\n     * Initialize the module service.\n     */\n    initialize(): void {\n        // Reset comments page size.\n        CoreEvents.on(CoreEvents.LOGIN, () => {\n            CoreCommentsProvider.pageSize = 1;\n            CoreCommentsProvider.pageSizeOK = false;\n        });\n\n    }\n\n    /**\n     * Add a comment.\n     *\n     * @param content Comment text.\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if comment was sent to server, false if stored in device.\n     */\n    async addComment(\n        content: string,\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        siteId?: string,\n    ): Promise<CoreCommentsData | false> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a comment to be synchronized later.\n        const storeOffline = async (): Promise<false> => {\n            await CoreCommentsOffline.saveComment(content, contextLevel, instanceId, component, itemId, area, siteId);\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the comment.\n            return storeOffline();\n        }\n\n        // Send comment to server.\n        try {\n            return await this.addCommentOnline(content, contextLevel, instanceId, component, itemId, area, siteId);\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // It's a WebService error, the user cannot send the message so don't store it.\n                throw error;\n            }\n\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Add a comment. It will fail if offline or cannot connect.\n     *\n     * @param content Comment text.\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when added, rejected otherwise.\n     */\n    async addCommentOnline(\n        content: string,\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        siteId?: string,\n    ): Promise<CoreCommentsData> {\n        const comments: CoreCommentsCommentBasicData[] = [\n            {\n                contextlevel: contextLevel,\n                instanceid: instanceId,\n                component: component,\n                itemid: itemId,\n                area: area,\n                content: content,\n            },\n        ];\n\n        const commentsResponse = await this.addCommentsOnline(comments, siteId);\n\n        // A comment was added, invalidate them.\n        await CoreUtils.ignoreErrors(\n            this.invalidateCommentsData(contextLevel, instanceId, component, itemId, area, siteId),\n        );\n\n        return commentsResponse[0];\n    }\n\n    /**\n     * Add several comments. It will fail if offline or cannot connect.\n     *\n     * @param comments Comments to save.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when added, rejected otherwise. Promise resolved doesn't mean that comments\n     *         have been added, the resolve param can contain errors for comments not sent.\n     */\n    async addCommentsOnline(\n        comments: CoreCommentsCommentBasicData[],\n        siteId?: string,\n    ): Promise<CoreCommentsAddCommentsWSResponse> {\n        if (!comments || !comments.length) {\n            return [];\n        }\n\n        const site = await CoreSites.getSite(siteId);\n        const data: CoreCommentsAddCommentsWSParams = {\n            comments: comments,\n        };\n\n        return site.write('core_comment_add_comments', data);\n    }\n\n    /**\n     * Check if Calendar is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether it's disabled.\n     */\n    areCommentsDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site?.isFeatureDisabled('NoDelegate_CoreComments');\n    }\n\n    /**\n     * Check if comments are disabled in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n     */\n    async areCommentsDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.areCommentsDisabledInSite(site);\n    }\n\n    /**\n     * Delete a comment.\n     *\n     * @param comment Comment object to delete.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when deleted (with true if deleted in online, false otherwise), rejected otherwise.\n     *  Promise resolved doesn't mean that comments have been deleted,the resolve param can contain errors for comment\n     *  not deleted.\n     */\n    async deleteComment(comment: CoreCommentsCommentBasicData, siteId?: string): Promise<boolean> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Offline comment, just delete it.\n        if (!comment.id) {\n            await CoreCommentsOffline.removeComment(\n                comment.contextlevel,\n                comment.instanceid,\n                comment.component,\n                comment.itemid,\n                comment.area,\n                siteId,\n            );\n\n            return false;\n        }\n\n        // Convenience function to store the action to be synchronized later.\n        const storeOffline = async (): Promise<boolean> => {\n            if (!comment.id) {\n                return false;\n            }\n\n            await CoreCommentsOffline.deleteComment(\n                comment.id,\n                comment.contextlevel,\n                comment.instanceid,\n                comment.component,\n                comment.itemid,\n                comment.area,\n                siteId,\n            );\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the comment.\n            return storeOffline();\n        }\n\n        // Send comment to server.\n        try {\n            await this.deleteCommentsOnline(\n                [comment.id],\n                comment.contextlevel,\n                comment.instanceid,\n                comment.component,\n                comment.itemid,\n                comment.area,\n                siteId,\n            );\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // It's a WebService error, the user cannot send the comment so don't store it.\n                throw error;\n            }\n\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Delete a comment. It will fail if offline or cannot connect.\n     *\n     * @param commentIds Comment IDs to delete.\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when deleted, rejected otherwise. Promise resolved doesn't mean that comments\n     *         have been deleted, the resolve param can contain errors for comments not deleted.\n     */\n    async deleteCommentsOnline(\n        commentIds: number[],\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const data: CoreCommentsDeleteCommentsWSParams = {\n            comments: commentIds,\n        };\n\n        await site.write('core_comment_delete_comments', data);\n\n        await CoreUtils.ignoreErrors(\n            this.invalidateCommentsData(contextLevel, instanceId, component, itemId, area, siteId),\n        );\n    }\n\n    /**\n     * Returns whether WS to add/delete comments are available in site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if available, resolved with false or rejected otherwise.\n     * @since 3.8\n     */\n    async isAddCommentsAvailable(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        // First check if it's disabled.\n        if (this.areCommentsDisabledInSite(site)) {\n            return false;\n        }\n\n        return site.wsAvailable('core_comment_add_comments');\n    }\n\n    /**\n     * Get cache key for get comments data WS calls.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @returns Cache key.\n     */\n    protected getCommentsCacheKey(\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n    ): string {\n        return this.getCommentsPrefixCacheKey(contextLevel, instanceId) + ':' + component + ':' + itemId + ':' + area;\n    }\n\n    /**\n     * Get cache key for get comments instance data WS calls.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @returns Cache key.\n     */\n    protected getCommentsPrefixCacheKey(contextLevel: string, instanceId: number): string {\n        return ROOT_CACHE_KEY + 'comments:' + contextLevel + ':' + instanceId;\n    }\n\n    /**\n     * Retrieve a list of comments.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param page Page number (0 based). Default 0.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the comments.\n     */\n    async getComments(\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        page: number = 0,\n        siteId?: string,\n    ): Promise<CoreCommentsGetCommentsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreCommentsGetCommentsWSParams = {\n            contextlevel: contextLevel,\n            instanceid: instanceId,\n            component: component,\n            itemid: itemId,\n            area: area,\n            page: page,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCommentsCacheKey(contextLevel, instanceId, component, itemId, area),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n        const response = await site.read<CoreCommentsGetCommentsWSResponse>('core_comment_get_comments', params, preSets);\n\n        if (response.comments) {\n            // Update pageSize with the greatest count at the moment.\n            if (response.count === undefined && response.comments.length > CoreCommentsProvider.pageSize) {\n                CoreCommentsProvider.pageSize = response.comments.length;\n            }\n\n            return response;\n        }\n\n        throw new CoreError('No comments returned');\n    }\n\n    /**\n     * Get comments count number to show on the comments component.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Comments count with plus sign if needed.\n     */\n    async getCommentsCount(\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        siteId?: string,\n    ): Promise<string> {\n\n        siteId = siteId ? siteId : CoreSites.getCurrentSiteId();\n        let trueCount = false;\n\n        // Convenience function to get comments number on a page.\n        const getCommentsPageCount = async (page: number): Promise<number> => {\n            try {\n                const response = await this.getComments(contextLevel, instanceId, component, itemId, area, page, siteId);\n                // Count is only available in 3.8 onwards.\n\n                if (response.count !== undefined) {\n                    trueCount = true;\n\n                    return response.count;\n                }\n\n                if (response.comments) {\n                    return response.comments.length || 0;\n                }\n\n                return -1;\n            } catch {\n                return -1;\n            }\n        };\n\n        const count = await getCommentsPageCount(0);\n\n        if (trueCount || count < CoreCommentsProvider.pageSize) {\n            return count + '';\n        } else if (CoreCommentsProvider.pageSizeOK && count >= CoreCommentsProvider.pageSize) {\n            // Page Size is ok, show + in case it reached the limit.\n            return (CoreCommentsProvider.pageSize - 1) + '+';\n        }\n\n        const countMore = await getCommentsPageCount(1);\n        // Page limit was reached on the previous call.\n        if (countMore > 0) {\n            CoreCommentsProvider.pageSizeOK = true;\n\n            return (CoreCommentsProvider.pageSize - 1) + '+';\n        }\n\n        return count + '';\n    }\n\n    /**\n     * Invalidates comments data.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCommentsData(\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await CoreUtils.allPromises([\n            // This is done with starting with to avoid conflicts with previous keys that were including page.\n            site.invalidateWsCacheForKeyStartingWith(this.getCommentsCacheKey(\n                contextLevel,\n                instanceId,\n                component,\n                itemId,\n                area,\n            ) + ':'),\n\n            site.invalidateWsCacheForKey(this.getCommentsCacheKey(contextLevel, instanceId, component, itemId, area)),\n        ]);\n    }\n\n    /**\n     * Invalidates all comments data for an instance.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCommentsByInstance(contextLevel: string, instanceId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getCommentsPrefixCacheKey(contextLevel, instanceId));\n    }\n\n}\nexport const CoreComments = makeSingleton(CoreCommentsProvider);\n\n/**\n * Data returned by comment_area_exporter.\n */\nexport type CoreCommentsArea = {\n    component: string; // Component.\n    commentarea: string; // Commentarea.\n    itemid: number; // Itemid.\n    courseid: number; // Courseid.\n    contextid: number; // Contextid.\n    cid: string; // Cid.\n    autostart: boolean; // Autostart.\n    canpost: boolean; // Canpost.\n    canview: boolean; // Canview.\n    count: number; // Count.\n    collapsediconkey: string; // Collapsediconkey.\n    displaytotalcount: boolean; // Displaytotalcount.\n    displaycancel: boolean; // Displaycancel.\n    fullwidth: boolean; // Fullwidth.\n    linktext: string; // Linktext.\n    notoggle: boolean; // Notoggle.\n    template: string; // Template.\n    canpostorhascomments: boolean; // Canpostorhascomments.\n};\n\n/**\n * Params of core_comment_add_comments WS.\n */\ntype CoreCommentsAddCommentsWSParams = {\n    comments: CoreCommentsCommentBasicData[];\n};\n\nexport type CoreCommentsCommentBasicData = {\n    id?: number; // Comment ID.\n    contextlevel: string; // Contextlevel system, course, user...\n    instanceid: number; // The id of item associated with the contextlevel.\n    component: string; // Component.\n    content: string; // Component.\n    itemid: number; // Associated id.\n    area?: string; // String comment area.\n};\n\n/**\n * Comments Data returned by WS.\n */\nexport type CoreCommentsData = {\n    id: number; // Comment ID.\n    content: string; // The content text formatted.\n    format: number; // Content format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    timecreated: number; // Time created (timestamp).\n    strftimeformat: string; // Time format.\n    profileurl: string; // URL profile.\n    fullname: string; // Fullname.\n    time: string; // Time in human format.\n    avatar: string; // HTML user picture.\n    userid: number; // User ID.\n    delete?: boolean; // Permission to delete=true/false.\n};\n\n/**\n * Data returned by core_comment_add_comments WS.\n */\nexport type CoreCommentsAddCommentsWSResponse = CoreCommentsData[];\n\n/**\n * Params of core_comment_delete_comments WS.\n */\ntype CoreCommentsDeleteCommentsWSParams = {\n    comments: number[];\n};\n\n/**\n * Params of core_comment_get_comments WS.\n */\ntype CoreCommentsGetCommentsWSParams = {\n    contextlevel: string; // Contextlevel system, course, user...\n    instanceid: number; // The Instance id of item associated with the context level.\n    component: string; // Component.\n    itemid: number; // Associated id.\n    area?: string; // String comment area.\n    page?: number; // Page number (0 based).\n    sortdirection?: string; // Sort direction: ASC or DESC.\n};\n\n/**\n * Data returned by core_comment_get_comments WS.\n */\nexport type CoreCommentsGetCommentsWSResponse = {\n    comments: CoreCommentsData[]; // List of comments.\n    count?: number; // @since 3.8. Total number of comments.\n    perpage?: number; // @since 3.8. Number of comments per page.\n    canpost?: boolean; // Whether the user can post in this comment area.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data sent by COMMENTS_COUNT_CHANGED_EVENT event.\n */\nexport type CoreCommentsCountChangedEventData = {\n    contextLevel: string;\n    instanceId: number;\n    component: string;\n    itemId: number;\n    area: string;\n    countChange: number;\n};\n\n/**\n * Data sent by REFRESH_COMMENTS_EVENT event.\n */\nexport type CoreCommentsRefreshCommentsEventData = {\n    contextLevel?: string;\n    instanceId?: number;\n    component?: string;\n    itemId?: number;\n    area?: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}