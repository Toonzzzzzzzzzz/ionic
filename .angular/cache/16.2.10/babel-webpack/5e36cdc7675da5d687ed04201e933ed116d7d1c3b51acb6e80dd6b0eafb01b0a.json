{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { AddonMessagesProvider, AddonMessages } from '../messages';\nimport { CoreSites } from '@services/sites';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CorePushNotificationsDelegate } from '@features/pushnotifications/services/push-delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreMainMenuProvider } from '@features/mainmenu/services/mainmenu';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to inject an option into main menu.\n */\nexport class AddonMessagesMainMenuHandlerService {\n  constructor() {\n    this.name = 'AddonMessages';\n    this.priority = 700;\n    this.handler = {\n      icon: 'fas-comments',\n      title: 'addon.messages.messages',\n      page: AddonMessagesMainMenuHandlerService.PAGE_NAME,\n      class: 'addon-messages-handler',\n      showBadge: true,\n      badge: '',\n      badgeA11yText: 'addon.messages.unreadconversations',\n      loading: true\n    };\n    this.unreadCount = 0;\n    this.contactRequestsCount = 0;\n    this.orMore = false;\n    CoreEvents.on(AddonMessagesProvider.UNREAD_CONVERSATION_COUNTS_EVENT, data => {\n      this.unreadCount = data.favourites + data.individual + data.group + data.self;\n      this.orMore = !!data.orMore;\n      data.siteId && this.updateBadge(data.siteId);\n    });\n    CoreEvents.on(AddonMessagesProvider.CONTACT_REQUESTS_COUNT_EVENT, data => {\n      this.contactRequestsCount = data.count;\n      data.siteId && this.updateBadge(data.siteId);\n    });\n    // Reset info on logout.\n    CoreEvents.on(CoreEvents.LOGOUT, () => {\n      this.unreadCount = 0;\n      this.contactRequestsCount = 0;\n      this.orMore = false;\n      this.handler.badge = '';\n      this.handler.loading = true;\n    });\n    // If a message push notification is received, refresh the count.\n    CorePushNotificationsDelegate.on('receive').subscribe(notification => {\n      // New message received. If it's from current site, refresh the data.\n      const isMessage = CoreUtils.isFalseOrZero(notification.notif) || notification.name == 'messagecontactrequests';\n      if (isMessage && CoreSites.isCurrentSite(notification.site)) {\n        this.refreshBadge(notification.site);\n      }\n    });\n    // Register Badge counter.\n    CorePushNotificationsDelegate.registerCounterHandler(AddonMessagesMainMenuHandlerService.name);\n  }\n  /**\n   * Check if the handler is enabled on a site level.\n   *\n   * @returns Whether or not the handler is enabled on a site level.\n   */\n  isEnabled() {\n    return AddonMessages.isPluginEnabled();\n  }\n  /**\n   * Returns the data needed to render the handler.\n   *\n   * @returns Data needed to render the handler.\n   */\n  getDisplayData() {\n    if (this.handler.loading) {\n      this.refreshBadge();\n    }\n    return this.handler;\n  }\n  /**\n   * Refreshes badge number.\n   *\n   * @param siteId Site ID or current Site if undefined.\n   * @param unreadOnly If true only the unread conversations count is refreshed.\n   * @returns Resolve when done.\n   */\n  refreshBadge(siteId, unreadOnly) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const badgeSiteId = siteId || CoreSites.getCurrentSiteId();\n      if (!badgeSiteId) {\n        return;\n      }\n      const promises = [];\n      promises.push(AddonMessages.refreshUnreadConversationCounts(badgeSiteId).catch(() => {\n        _this.unreadCount = 0;\n        _this.orMore = false;\n      }));\n      // Refresh the number of contact requests in 3.6+ sites.\n      if (!unreadOnly && AddonMessages.isGroupMessagingEnabled()) {\n        promises.push(AddonMessages.refreshContactRequestsCount(badgeSiteId).catch(() => {\n          _this.contactRequestsCount = 0;\n        }));\n      }\n      yield Promise.all(promises).finally(() => {\n        _this.updateBadge(badgeSiteId);\n        _this.handler.loading = false;\n      });\n    })();\n  }\n  /**\n   * Update badge number and push notifications counter from loaded data.\n   *\n   * @param siteId Site ID.\n   */\n  updateBadge(siteId) {\n    const totalCount = this.unreadCount + (this.contactRequestsCount || 0);\n    if (this.badgeCount === totalCount) {\n      return;\n    }\n    this.badgeCount = totalCount;\n    if (totalCount > 0) {\n      this.handler.badge = totalCount + (this.orMore ? '+' : '');\n    } else {\n      this.handler.badge = '';\n    }\n    // Update push notifications badge.\n    CoreEvents.trigger(CoreMainMenuProvider.MAIN_MENU_HANDLER_BADGE_UPDATED, {\n      handler: AddonMessagesMainMenuHandlerService.name,\n      value: totalCount\n    }, siteId);\n  }\n  /**\n   * Execute the process.\n   * Receives the ID of the site affected, undefined for all sites.\n   *\n   * @param siteId ID of the site affected, undefined for all sites.\n   * @returns Promise resolved when done, rejected if failure.\n   */\n  execute(siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = CoreSites.getCurrentSite();\n      if (!CoreSites.isCurrentSite(siteId) || !site || site.isFeatureDisabled('CoreMainMenuDelegate_AddonMessages') || !site.canUseAdvancedFeature('messaging')) {\n        return;\n      }\n      _this2.refreshBadge();\n    })();\n  }\n  /**\n   * Get the time between consecutive executions.\n   *\n   * @returns Time between consecutive executions (in ms).\n   */\n  getInterval() {\n    if (!this.isSync()) {\n      return 300000; // We have a WS to check the number, check it every 5 minutes.\n    }\n\n    return 600000; // Check it every 10 minutes.\n  }\n  /**\n   * Whether it's a synchronization process or not.\n   *\n   * @returns True if is a sync process, false otherwise.\n   */\n  isSync() {\n    return false;\n  }\n  /**\n   * Whether the process should be executed during a manual sync.\n   *\n   * @returns True if is a manual sync process, false otherwise.\n   */\n  canManualSync() {\n    return true;\n  }\n}\n_class = AddonMessagesMainMenuHandlerService;\n_class.PAGE_NAME = 'messages';\n_class.ɵfac = function AddonMessagesMainMenuHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonMessagesMainMenuHandler = makeSingleton(AddonMessagesMainMenuHandlerService);","map":{"version":3,"names":["AddonMessagesProvider","AddonMessages","CoreSites","CoreEvents","CoreUtils","CorePushNotificationsDelegate","makeSingleton","CoreMainMenuProvider","AddonMessagesMainMenuHandlerService","constructor","name","priority","handler","icon","title","page","PAGE_NAME","class","showBadge","badge","badgeA11yText","loading","unreadCount","contactRequestsCount","orMore","on","UNREAD_CONVERSATION_COUNTS_EVENT","data","favourites","individual","group","self","siteId","updateBadge","CONTACT_REQUESTS_COUNT_EVENT","count","LOGOUT","subscribe","notification","isMessage","isFalseOrZero","notif","isCurrentSite","site","refreshBadge","registerCounterHandler","isEnabled","isPluginEnabled","getDisplayData","unreadOnly","_this","_asyncToGenerator","badgeSiteId","getCurrentSiteId","promises","push","refreshUnreadConversationCounts","catch","isGroupMessagingEnabled","refreshContactRequestsCount","Promise","all","finally","totalCount","badgeCount","trigger","MAIN_MENU_HANDLER_BADGE_UPDATED","value","execute","_this2","getCurrentSite","isFeatureDisabled","canUseAdvancedFeature","getInterval","isSync","canManualSync","_class","factory","ɵfac","providedIn","AddonMessagesMainMenuHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/messages/services/handlers/mainmenu.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport {\n    AddonMessagesProvider,\n    AddonMessages,\n} from '../messages';\nimport { CoreMainMenuHandler, CoreMainMenuHandlerToDisplay } from '@features/mainmenu/services/mainmenu-delegate';\nimport { CoreCronHandler } from '@services/cron';\nimport { CoreSites } from '@services/sites';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreUtils } from '@services/utils/utils';\nimport {\n    CorePushNotificationsNotificationBasicData,\n} from '@features/pushnotifications/services/pushnotifications';\nimport { CorePushNotificationsDelegate } from '@features/pushnotifications/services/push-delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreMainMenuProvider } from '@features/mainmenu/services/mainmenu';\n\n/**\n * Handler to inject an option into main menu.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonMessagesMainMenuHandlerService implements CoreMainMenuHandler, CoreCronHandler {\n\n    static readonly PAGE_NAME = 'messages';\n\n    name = 'AddonMessages';\n    priority = 700;\n\n    protected handler: CoreMainMenuHandlerToDisplay = {\n        icon: 'fas-comments',\n        title: 'addon.messages.messages',\n        page: AddonMessagesMainMenuHandlerService.PAGE_NAME,\n        class: 'addon-messages-handler',\n        showBadge: true,\n        badge: '',\n        badgeA11yText: 'addon.messages.unreadconversations',\n        loading: true,\n    };\n\n    protected unreadCount = 0;\n    protected contactRequestsCount = 0;\n    protected orMore = false;\n    protected badgeCount?: number;\n\n    constructor() {\n\n        CoreEvents.on(AddonMessagesProvider.UNREAD_CONVERSATION_COUNTS_EVENT, (data) => {\n            this.unreadCount = data.favourites + data.individual + data.group + data.self;\n            this.orMore = !!data.orMore;\n\n            data.siteId && this.updateBadge(data.siteId);\n        });\n\n        CoreEvents.on(AddonMessagesProvider.CONTACT_REQUESTS_COUNT_EVENT, (data) => {\n            this.contactRequestsCount = data.count;\n\n            data.siteId && this.updateBadge(data.siteId);\n        });\n\n        // Reset info on logout.\n        CoreEvents.on(CoreEvents.LOGOUT, () => {\n            this.unreadCount = 0;\n            this.contactRequestsCount = 0;\n            this.orMore = false;\n            this.handler.badge = '';\n            this.handler.loading = true;\n        });\n\n        // If a message push notification is received, refresh the count.\n        CorePushNotificationsDelegate.on<CorePushNotificationsNotificationBasicData>('receive').subscribe(\n            (notification) => {\n            // New message received. If it's from current site, refresh the data.\n                const isMessage = CoreUtils.isFalseOrZero(notification.notif) ||\n                    notification.name == 'messagecontactrequests';\n                if (isMessage && CoreSites.isCurrentSite(notification.site)) {\n                    this.refreshBadge(notification.site);\n                }\n            },\n        );\n\n        // Register Badge counter.\n        CorePushNotificationsDelegate.registerCounterHandler(AddonMessagesMainMenuHandlerService.name);\n    }\n\n    /**\n     * Check if the handler is enabled on a site level.\n     *\n     * @returns Whether or not the handler is enabled on a site level.\n     */\n    isEnabled(): Promise<boolean> {\n        return AddonMessages.isPluginEnabled();\n    }\n\n    /**\n     * Returns the data needed to render the handler.\n     *\n     * @returns Data needed to render the handler.\n     */\n    getDisplayData(): CoreMainMenuHandlerToDisplay {\n        if (this.handler.loading) {\n            this.refreshBadge();\n        }\n\n        return this.handler;\n    }\n\n    /**\n     * Refreshes badge number.\n     *\n     * @param siteId Site ID or current Site if undefined.\n     * @param unreadOnly If true only the unread conversations count is refreshed.\n     * @returns Resolve when done.\n     */\n    async refreshBadge(siteId?: string, unreadOnly?: boolean): Promise<void> {\n        const badgeSiteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!badgeSiteId) {\n            return;\n        }\n\n        const promises: Promise<unknown>[] = [];\n\n        promises.push(AddonMessages.refreshUnreadConversationCounts(badgeSiteId).catch(() => {\n            this.unreadCount = 0;\n            this.orMore = false;\n        }));\n\n        // Refresh the number of contact requests in 3.6+ sites.\n        if (!unreadOnly && AddonMessages.isGroupMessagingEnabled()) {\n            promises.push(AddonMessages.refreshContactRequestsCount(badgeSiteId).catch(() => {\n                this.contactRequestsCount = 0;\n            }));\n        }\n\n        await Promise.all(promises).finally(() => {\n            this.updateBadge(badgeSiteId);\n            this.handler.loading = false;\n        });\n    }\n\n    /**\n     * Update badge number and push notifications counter from loaded data.\n     *\n     * @param siteId Site ID.\n     */\n    updateBadge(siteId: string): void {\n        const totalCount = this.unreadCount + (this.contactRequestsCount || 0);\n\n        if (this.badgeCount === totalCount) {\n            return;\n        }\n\n        this.badgeCount = totalCount;\n\n        if (totalCount > 0) {\n            this.handler.badge = totalCount + (this.orMore ? '+' : '');\n        } else {\n            this.handler.badge = '';\n        }\n\n        // Update push notifications badge.\n        CoreEvents.trigger(\n            CoreMainMenuProvider.MAIN_MENU_HANDLER_BADGE_UPDATED,\n            {\n                handler: AddonMessagesMainMenuHandlerService.name,\n                value: totalCount,\n            },\n            siteId,\n        );\n    }\n\n    /**\n     * Execute the process.\n     * Receives the ID of the site affected, undefined for all sites.\n     *\n     * @param siteId ID of the site affected, undefined for all sites.\n     * @returns Promise resolved when done, rejected if failure.\n     */\n    async execute(siteId?: string): Promise<void> {\n        const site = CoreSites.getCurrentSite();\n\n        if (\n            !CoreSites.isCurrentSite(siteId) ||\n            !site ||\n            site.isFeatureDisabled('CoreMainMenuDelegate_AddonMessages') ||\n            !site.canUseAdvancedFeature('messaging')\n        ) {\n            return;\n        }\n\n        this.refreshBadge();\n    }\n\n    /**\n     * Get the time between consecutive executions.\n     *\n     * @returns Time between consecutive executions (in ms).\n     */\n    getInterval(): number {\n        if (!this.isSync()) {\n            return 300000; // We have a WS to check the number, check it every 5 minutes.\n        }\n\n        return 600000; // Check it every 10 minutes.\n    }\n\n    /**\n     * Whether it's a synchronization process or not.\n     *\n     * @returns True if is a sync process, false otherwise.\n     */\n    isSync(): boolean {\n        return false;\n    }\n\n    /**\n     * Whether the process should be executed during a manual sync.\n     *\n     * @returns True if is a manual sync process, false otherwise.\n     */\n    canManualSync(): boolean {\n        return true;\n    }\n\n}\n\nexport const AddonMessagesMainMenuHandler = makeSingleton(AddonMessagesMainMenuHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}