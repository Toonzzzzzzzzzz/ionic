{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreEvents } from '@singletons/events';\nimport { CoreFile } from '@services/file';\nimport { CoreLang } from '@services/lang';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton, Clipboard, InAppBrowser, FileOpener, WebIntent, Translate, NgZone } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreViewerQRScannerComponent } from '@features/viewer/components/qr-scanner/qr-scanner';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreWindow } from '@singletons/window';\nimport { CoreColors } from '@singletons/colors';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { CoreErrorWithOptions } from '@classes/errors/errorwithoptions';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreCancellablePromise } from '@classes/cancellable-promise';\nimport { CoreAnalytics, CoreAnalyticsEventType } from '@services/analytics';\nimport { CoreUrlUtils } from './url';\nimport { QRScanner } from '@features/native/plugins';\nimport * as i0 from \"@angular/core\";\n/*\n * \"Utils\" service with helper functions.\n */\nexport class CoreUtilsProvider {\n  constructor() {\n    this.DONT_CLONE = ['[object FileEntry]', '[object DirectoryEntry]', '[object DOMFileSystem]'];\n    this.uniqueIds = {};\n    this.initialColorSchemeContent = 'light dark';\n    this.logger = CoreLogger.getInstance('CoreUtilsProvider');\n  }\n  /**\n   * Given an error, add an extra warning to the error message and return the new error message.\n   *\n   * @param error Error object or message.\n   * @param defaultError Message to show if the error is not a string.\n   * @returns New error message.\n   */\n  addDataNotDownloadedError(error, defaultError) {\n    const errorMessage = CoreTextUtils.getErrorMessageFromError(error) || defaultError || '';\n    if (this.isWebServiceError(error)) {\n      return errorMessage;\n    }\n    // Local error. Add an extra warning.\n    return errorMessage + '<br><br>' + Translate.instant('core.errorsomedatanotdownloaded');\n  }\n  /**\n   * Similar to Promise.all, but if a promise fails this function's promise won't be rejected until ALL promises have finished.\n   *\n   * @param promises Promises.\n   * @returns Promise resolved if all promises are resolved and rejected if at least 1 promise fails.\n   */\n  allPromises(promises) {\n    return _asyncToGenerator(function* () {\n      if (!promises || !promises.length) {\n        return;\n      }\n      const getPromiseError = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (promise) {\n          try {\n            yield promise;\n          } catch (error) {\n            return error;\n          }\n        });\n        return function getPromiseError(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      const errors = yield Promise.all(promises.map(getPromiseError));\n      const error = errors.find(error => !!error);\n      if (error) {\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Combination of allPromises and ignoreErrors functions.\n   *\n   * @param promises Promises.\n   * @returns Promise resolved if all promises are resolved and rejected if at least 1 promise fails.\n   */\n  allPromisesIgnoringErrors(promises) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield CoreUtils.ignoreErrors(_this.allPromises(promises));\n    })();\n  }\n  /**\n   * Converts an array of objects to an object, using a property of each entry as the key.\n   * It can also be used to convert an array of strings to an object where the keys are the elements of the array.\n   * E.g. [{id: 10, name: 'A'}, {id: 11, name: 'B'}] => {10: {id: 10, name: 'A'}, 11: {id: 11, name: 'B'}}\n   *\n   * @param array The array to convert.\n   * @param propertyName The name of the property to use as the key. If not provided, the whole item will be used.\n   * @param result Object where to put the properties. If not defined, a new object will be created.\n   * @returns The object.\n   */\n  arrayToObject(array = [], propertyName, result = {}) {\n    for (const entry of array) {\n      const key = propertyName ? entry[propertyName] : entry;\n      result[key] = entry;\n    }\n    return result;\n  }\n  /**\n   * Log an unhandled error.\n   *\n   * @param message Message to contextualize the error.\n   * @param error Error to log.\n   */\n  logUnhandledError(message, error) {\n    this.logger.error(message, error);\n  }\n  /**\n   * Converts an array of objects to an indexed array, using a property of each entry as the key.\n   * Every entry will contain an array of the found objects of the property identifier.\n   * E.g. [{id: 10, name: 'A'}, {id: 10, name: 'B'}] => {10: [ {id: 10, name: 'A'}, {id: 10, name: 'B'} ] }\n   *\n   * @param array The array to convert.\n   * @param propertyName The name of the property to use as the key. If not provided, the whole item will be used.\n   * @param result Object where to put the properties. If not defined, a new object will be created.\n   * @returns The object.\n   */\n  arrayToObjectMultiple(array = [], propertyName, result = {}) {\n    for (const entry of array) {\n      const key = propertyName ? entry[propertyName] : entry;\n      if (result[key] === undefined) {\n        result[key] = [];\n      }\n      result[key].push(entry);\n    }\n    return result;\n  }\n  /**\n   * Compare two objects. This function won't compare functions and proto properties, it's a basic compare.\n   * Also, this will only check if itemA's properties are in itemB with same value. This function will still\n   * return true if itemB has more properties than itemA.\n   *\n   * @param itemA First object.\n   * @param itemB Second object.\n   * @param maxLevels Number of levels to reach if 2 objects are compared.\n   * @param level Current deep level (when comparing objects).\n   * @param undefinedIsNull True if undefined is equal to null. Defaults to true.\n   * @returns Whether both items are equal.\n   */\n  basicLeftCompare(itemA,\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  itemB,\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  maxLevels = 0, level = 0, undefinedIsNull = true) {\n    if (typeof itemA == 'function' || typeof itemB == 'function') {\n      return true; // Don't compare functions.\n    } else if (typeof itemA == 'object' && typeof itemB == 'object') {\n      if (level >= maxLevels) {\n        return true; // Max deep reached.\n      }\n\n      let equal = true;\n      for (const name in itemA) {\n        const value = itemA[name];\n        if (name == '$$hashKey') {\n          // Ignore $$hashKey property since it's a \"calculated\" property.\n          continue;\n        }\n        if (!this.basicLeftCompare(value, itemB[name], maxLevels, level + 1)) {\n          equal = false;\n        }\n      }\n      return equal;\n    } else {\n      if (undefinedIsNull && (itemA === undefined && itemB === null || itemA === null && itemB === undefined)) {\n        return true;\n      }\n      // We'll treat \"2\" and 2 as the same value.\n      const floatA = parseFloat(itemA);\n      const floatB = parseFloat(itemB);\n      if (!isNaN(floatA) && !isNaN(floatB)) {\n        return floatA == floatB;\n      }\n      return itemA === itemB;\n    }\n  }\n  /**\n   * Check if a URL has a redirect.\n   *\n   * @param url The URL to check.\n   * @returns Promise resolved with boolean_ whether there is a redirect.\n   */\n  checkRedirect(url) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!window.fetch) {\n        // Cannot check if there is a redirect, assume it's false.\n        return false;\n      }\n      const initOptions = {\n        redirect: 'follow'\n      };\n      // Some browsers implement fetch but no AbortController.\n      const controller = AbortController ? new AbortController() : false;\n      if (controller) {\n        initOptions.signal = controller.signal;\n      }\n      try {\n        const response = yield _this2.timeoutPromise(window.fetch(url, initOptions), CoreWS.getRequestTimeout());\n        return response.redirected;\n      } catch (error) {\n        if (error.timeout && controller) {\n          // Timeout, abort the request.\n          controller.abort();\n        }\n        // There was a timeout, cannot determine if there's a redirect. Assume it's false.\n        return false;\n      }\n    })();\n  }\n  /**\n   * Close the InAppBrowser window.\n   */\n  closeInAppBrowser() {\n    if (this.iabInstance) {\n      this.iabInstance.close();\n    }\n  }\n  /**\n   * Get inapp browser instance (if any).\n   *\n   * @returns IAB instance, undefined if not open.\n   */\n  getInAppBrowserInstance() {\n    return this.iabInstance;\n  }\n  /**\n   * Check if inapp browser is open.\n   *\n   * @returns Whether it's open.\n   */\n  isInAppBrowserOpen() {\n    return !!this.iabInstance;\n  }\n  /**\n   * Clone a variable. It should be an object, array or primitive type.\n   *\n   * @param source The variable to clone.\n   * @param level Depth we are right now inside a cloned object. It's used to prevent reaching max call stack size.\n   * @returns Cloned variable.\n   */\n  clone(source, level = 0) {\n    if (level >= 20) {\n      // Max 20 levels.\n      this.logger.error('Max depth reached when cloning object.', source);\n      return source;\n    }\n    if (this.valueIsFileEntry(source)) {\n      // Don't clone FileEntry. It has a lot of depth and they shouldn't be modified.\n      return source;\n    } else if (Array.isArray(source)) {\n      // Clone the array and all the entries.\n      const newArray = [];\n      for (let i = 0; i < source.length; i++) {\n        newArray[i] = this.clone(source[i], level + 1);\n      }\n      return newArray;\n    } else if (this.isObject(source)) {\n      // Check if the object shouldn't be copied.\n      if (source.toString && this.DONT_CLONE.indexOf(source.toString()) != -1) {\n        // Object shouldn't be copied, return it as it is.\n        return source;\n      }\n      // Clone the object and all the subproperties.\n      const newObject = {};\n      for (const name in source) {\n        newObject[name] = this.clone(source[name], level + 1);\n      }\n      return newObject;\n    } else {\n      // Primitive type or unknown, return it as it is.\n      return source;\n    }\n  }\n  /**\n   * Copy properties from one object to another.\n   *\n   * @param from Object to copy the properties from.\n   * @param to Object where to store the properties.\n   * @param clone Whether the properties should be cloned (so they are different instances).\n   */\n  copyProperties(from, to, clone = true) {\n    for (const name in from) {\n      if (clone) {\n        to[name] = this.clone(from[name]);\n      } else {\n        to[name] = from[name];\n      }\n    }\n  }\n  /**\n   * Copies a text to clipboard and shows a toast message.\n   *\n   * @param text Text to be copied\n   * @returns Promise resolved when text is copied.\n   */\n  copyToClipboard(text) {\n    return _asyncToGenerator(function* () {\n      try {\n        yield Clipboard.copy(text);\n      } catch (_unused) {\n        // Use HTML Copy command.\n        const virtualInput = document.createElement('textarea');\n        virtualInput.innerHTML = text;\n        virtualInput.select();\n        virtualInput.setSelectionRange(0, 99999);\n        document.execCommand('copy'); // eslint-disable-line deprecation/deprecation\n      }\n      // Show toast using ionicLoading.\n      CoreDomUtils.showToast('core.copiedtoclipboard', true);\n    })();\n  }\n  /**\n   * Empties an array without losing its reference.\n   *\n   * @param array Array to empty.\n   */\n  emptyArray(array) {\n    array.length = 0; // Empty array without losing its reference.\n  }\n  /**\n   * Removes all properties from an object without losing its reference.\n   *\n   * @param object Object to remove the properties.\n   */\n  emptyObject(object) {\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        delete object[key];\n      }\n    }\n  }\n  /**\n   * Execute promises one depending on the previous.\n   *\n   * @param orderedPromisesData Data to be executed.\n   * @returns Promise resolved when all promises are resolved.\n   */\n  executeOrderedPromises(orderedPromisesData) {\n    const promises = [];\n    let dependency = Promise.resolve();\n    // Execute all the processes in order.\n    for (const i in orderedPromisesData) {\n      const data = orderedPromisesData[i];\n      // Add the process to the dependency stack.\n      const promise = dependency.finally(() => {\n        try {\n          return data.function();\n        } catch (e) {\n          this.logger.error(e.message);\n          return;\n        }\n      });\n      promises.push(promise);\n      // If the new process is blocking, we set it as the dependency.\n      if (data.blocking) {\n        dependency = promise;\n      }\n    }\n    // Return when all promises are done.\n    return this.allPromises(promises);\n  }\n  /**\n   * Flatten an object, moving subobjects' properties to the first level.\n   * It supports 2 notations: dot notation and square brackets.\n   * E.g.: {a: {b: 1, c: 2}, d: 3} -> {'a.b': 1, 'a.c': 2, d: 3}\n   *\n   * @param obj Object to flatten.\n   * @param useDotNotation Whether to use dot notation '.' or square brackets '['.\n   * @returns Flattened object.\n   */\n  flattenObject(obj, useDotNotation) {\n    const toReturn = {};\n    for (const name in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, name)) {\n        continue;\n      }\n      const value = obj[name];\n      if (typeof value == 'object' && !Array.isArray(value)) {\n        const flatObject = this.flattenObject(value);\n        for (const subName in flatObject) {\n          if (!Object.prototype.hasOwnProperty.call(flatObject, subName)) {\n            continue;\n          }\n          const newName = useDotNotation ? name + '.' + subName : name + '[' + subName + ']';\n          toReturn[newName] = flatObject[subName];\n        }\n      } else {\n        toReturn[name] = value;\n      }\n    }\n    return toReturn;\n  }\n  /**\n   * Given an array of strings, return only the ones that match a regular expression.\n   *\n   * @param array Array to filter.\n   * @param regex RegExp to apply to each string.\n   * @returns Filtered array.\n   */\n  filterByRegexp(array, regex) {\n    if (!array || !array.length) {\n      return [];\n    }\n    return array.filter(entry => {\n      const matches = entry.match(regex);\n      return matches && matches.length;\n    });\n  }\n  /**\n   * Filter the list of site IDs based on a isEnabled function.\n   *\n   * @param siteIds Site IDs to filter.\n   * @param isEnabledFn Function to call for each site. It receives a siteId param and all the params sent to this function\n   *                    after 'checkAll'.\n   * @param checkAll True if it should check all the sites, false if it should check only 1 and treat them all\n   *                 depending on this result.\n   * @returns Promise resolved with the list of enabled sites.\n   */\n  filterEnabledSites(siteIds, isEnabledFn, checkAll, ...args) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      const enabledSites = [];\n      for (const i in siteIds) {\n        const siteId = siteIds[i];\n        const pushIfEnabled = enabled => enabled && enabledSites.push(siteId);\n        if (checkAll || !promises.length) {\n          promises.push(Promise.resolve(isEnabledFn(siteId, ...args)).then(pushIfEnabled));\n        }\n      }\n      yield CoreUtils.ignoreErrors(_this3.allPromises(promises));\n      if (!checkAll) {\n        // Checking 1 was enough, so it will either return all the sites or none.\n        return enabledSites.length ? siteIds : [];\n      } else {\n        return enabledSites;\n      }\n    })();\n  }\n  /**\n   * Given a float, prints it nicely. Localized floats must not be used in calculations!\n   * Based on Moodle's format_float.\n   *\n   * @param float The float to print.\n   * @returns Locale float.\n   */\n  formatFloat(float) {\n    if (float === undefined || float === null || typeof float == 'boolean') {\n      return '';\n    }\n    const localeSeparator = Translate.instant('core.decsep');\n    const floatString = String(float);\n    return floatString.replace('.', localeSeparator);\n  }\n  /**\n   * Returns a tree formatted from a plain list.\n   * List has to be sorted by depth to allow this function to work correctly. Errors can be thrown if a child node is\n   * processed before a parent node.\n   *\n   * @param list List to format.\n   * @param parentFieldName Name of the parent field to match with children.\n   * @param idFieldName Name of the children field to match with parent.\n   * @param rootParentId The id of the root.\n   * @param maxDepth Max Depth to convert to tree. Children found will be in the last level of depth.\n   * @returns Array with the formatted tree, children will be on each node under children field.\n   */\n  formatTree(list, parentFieldName = 'parent', idFieldName = 'id', rootParentId = 0, maxDepth = 5) {\n    const map = {};\n    const mapDepth = {};\n    const tree = [];\n    // Create a map first to avoid problems with not sorted.\n    list.forEach((node, index) => {\n      const id = node[idFieldName];\n      if (id === undefined) {\n        this.logger.error(`Node with incorrect ${idFieldName}:${id} found on formatTree`);\n      }\n      if (node.children === undefined) {\n        node.children = [];\n      }\n      map[id] = index;\n    });\n    list.forEach(node => {\n      const id = node[idFieldName];\n      const parent = node[parentFieldName];\n      if (id === undefined || parent === undefined) {\n        this.logger.error(`Node with incorrect ${idFieldName}:${id} or ${parentFieldName}:${parent} found on formatTree`);\n      }\n      // Use map to look-up the parents.\n      if (parent !== rootParentId) {\n        const parentNode = list[map[parent]];\n        if (parentNode) {\n          if (mapDepth[parent] == maxDepth) {\n            // Reached max level of depth. Proceed with flat order. Find parent object of the current node.\n            const parentOfParent = parentNode[parentFieldName];\n            if (parentOfParent) {\n              // This element will be the child of the node that is two levels up the hierarchy\n              // (i.e. the child of node.parent.parent).\n              list[map[parentOfParent]].children.push(node);\n              // Assign depth level to the same depth as the parent (i.e. max depth level).\n              mapDepth[id] = mapDepth[parent];\n              // Change the parent to be the one that is two levels up the hierarchy.\n              node[parentFieldName] = parentOfParent;\n            } else {\n              this.logger.error(`Node parent of parent:${parentOfParent} not found on formatTree`);\n            }\n          } else {\n            parentNode.children.push(node);\n            // Increase the depth level.\n            mapDepth[id] = mapDepth[parent] + 1;\n          }\n        } else {\n          this.logger.error(`Node parent:${parent} not found on formatTree`);\n        }\n      } else {\n        tree.push(node);\n        // Root elements are the first elements in the tree structure, therefore have the depth level 1.\n        mapDepth[id] = 1;\n      }\n    });\n    return tree;\n  }\n  /**\n   * Get country name based on country code.\n   *\n   * @param code Country code (AF, ES, US, ...).\n   * @returns Country name. If the country is not found, return the country code.\n   */\n  getCountryName(code) {\n    const countryKey = 'assets.countries.' + code;\n    const countryName = Translate.instant(countryKey);\n    return countryName !== countryKey ? countryName : code;\n  }\n  /**\n   * Get list of countries with their code and translated name.\n   *\n   * @returns Promise resolved with the list of countries.\n   */\n  getCountryList() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Get the keys of the countries.\n      const keys = yield _this4.getCountryKeysList();\n      // Now get the code and the translated name.\n      const countries = {};\n      keys.forEach(key => {\n        if (key.indexOf('assets.countries.') === 0) {\n          const code = key.replace('assets.countries.', '');\n          countries[code] = Translate.instant(key);\n        }\n      });\n      return countries;\n    })();\n  }\n  /**\n   * Get list of countries with their code and translated name. Sorted by the name of the country.\n   *\n   * @returns Promise resolved with the list of countries.\n   */\n  getCountryListSorted() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      // Get the keys of the countries.\n      const countries = yield _this5.getCountryList();\n      // Sort translations.\n      return Object.keys(countries).sort((a, b) => countries[a].localeCompare(countries[b])).map(code => ({\n        code,\n        name: countries[code]\n      }));\n    })();\n  }\n  /**\n   * Get the list of language keys of the countries.\n   *\n   * @returns Promise resolved with the countries list. Rejected if not translated.\n   */\n  getCountryKeysList() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // It's possible that the current language isn't translated, so try with default language first.\n      const defaultLang = CoreLang.getDefaultLanguage();\n      try {\n        return yield _this6.getCountryKeysListForLanguage(defaultLang);\n      } catch (_unused2) {\n        // Not translated, try to use the fallback language.\n        const fallbackLang = CoreLang.getFallbackLanguage();\n        if (fallbackLang === defaultLang) {\n          // Same language, just reject.\n          throw new Error('Countries not found.');\n        }\n        return _this6.getCountryKeysListForLanguage(fallbackLang);\n      }\n    })();\n  }\n  /**\n   * Get the list of language keys of the countries, based on the translation table for a certain language.\n   *\n   * @param lang Language to check.\n   * @returns Promise resolved with the countries list. Rejected if not translated.\n   */\n  getCountryKeysListForLanguage(lang) {\n    return _asyncToGenerator(function* () {\n      // Get the translation table for the language.\n      const table = yield CoreLang.getTranslationTable(lang);\n      // Gather all the keys for countries,\n      const keys = [];\n      for (const name in table) {\n        if (name.indexOf('assets.countries.') === 0) {\n          keys.push(name);\n        }\n      }\n      if (keys.length === 0) {\n        // Not translated, reject.\n        throw new Error('Countries not found.');\n      }\n      return keys;\n    })();\n  }\n  /**\n   * Get the mimetype of a file given its URL. It'll try to guess it using the URL, if that fails then it'll\n   * perform a HEAD request to get it. It's done in this order because pluginfile.php can return wrong mimetypes.\n   * This function is in here instead of MimetypeUtils to prevent circular dependencies.\n   *\n   * @param url The URL of the file.\n   * @returns Promise resolved with the mimetype.\n   */\n  getMimeTypeFromUrl(url) {\n    return _asyncToGenerator(function* () {\n      // First check if it can be guessed from the URL.\n      const extension = CoreMimetypeUtils.guessExtensionFromUrl(url);\n      let mimetype = extension && CoreMimetypeUtils.getMimeType(extension);\n      if (mimetype) {\n        return mimetype;\n      }\n      // Can't be guessed, get the remote mimetype.\n      mimetype = yield CoreWS.getRemoteFileMimeType(url);\n      return mimetype || '';\n    })();\n  }\n  /**\n   * Get a unique ID for a certain name.\n   *\n   * @param name The name to get the ID for.\n   * @returns Unique ID.\n   */\n  getUniqueId(name) {\n    if (!this.uniqueIds[name]) {\n      this.uniqueIds[name] = 0;\n    }\n    return ++this.uniqueIds[name];\n  }\n  /**\n   * Check if a file is a FileEntry\n   *\n   * @param file File.\n   * @returns Type guard indicating if the file is a FileEntry.\n   */\n  isFileEntry(file) {\n    return 'isFile' in file;\n  }\n  /**\n   * Check if an unknown value is a FileEntry.\n   *\n   * @param file Object to check.\n   * @returns Type guard indicating if the file is a FileEntry.\n   */\n  valueIsFileEntry(file) {\n    // We cannot use instanceof because FileEntry is a type. Check some of the properties.\n    return !!(file && typeof file == 'object' && 'isFile' in file && 'filesystem' in file && 'toInternalURL' in file && 'copyTo' in file);\n  }\n  /**\n   * Check if a value is an object.\n   *\n   * @param object Variable.\n   * @returns Type guard indicating if this is an object.\n   */\n  isObject(object) {\n    return typeof object === 'object' && object !== null;\n  }\n  /**\n   * Given a list of files, check if there are repeated names.\n   *\n   * @param files List of files.\n   * @returns String with error message if repeated, false if no repeated.\n   */\n  hasRepeatedFilenames(files) {\n    if (!files || !files.length) {\n      return false;\n    }\n    const names = [];\n    // Check if there are 2 files with the same name.\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const name = (this.isFileEntry(file) ? file.name : file.filename) || '';\n      if (names.indexOf(name) > -1) {\n        return Translate.instant('core.filenameexist', {\n          $a: name\n        });\n      }\n      names.push(name);\n    }\n    return false;\n  }\n  /**\n   * Gets the index of the first string that matches a regular expression.\n   *\n   * @param array Array to search.\n   * @param regex RegExp to apply to each string.\n   * @returns Index of the first string that matches the RegExp. -1 if not found.\n   */\n  indexOfRegexp(array, regex) {\n    if (!array || !array.length) {\n      return -1;\n    }\n    for (let i = 0; i < array.length; i++) {\n      const entry = array[i];\n      const matches = entry.match(regex);\n      if (matches && matches.length) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * Return true if the param is false (bool), 0 (number) or \"0\" (string).\n   *\n   * @param value Value to check.\n   * @returns Whether the value is false, 0 or \"0\".\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isFalseOrZero(value) {\n    return value !== undefined && (value === false || value === 'false' || parseInt(value, 10) === 0);\n  }\n  /**\n   * Return true if the param is true (bool), 1 (number) or \"1\" (string).\n   *\n   * @param value Value to check.\n   * @returns Whether the value is true, 1 or \"1\".\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isTrueOrOne(value) {\n    return value !== undefined && (value === true || value === 'true' || parseInt(value, 10) === 1);\n  }\n  /**\n   * Given an error returned by a WS call, check if the error is generated by the app or it has been returned by the WebService.\n   *\n   * @param error Error to check.\n   * @returns Whether the error was returned by the WebService.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isWebServiceError(error) {\n    return error && (error.warningcode !== undefined || error.errorcode !== undefined && error.errorcode != 'userdeleted' && error.errorcode != 'upgraderunning' && error.errorcode != 'forcepasswordchangenotice' && error.errorcode != 'usernotfullysetup' && error.errorcode != 'sitepolicynotagreed' && error.errorcode != 'sitemaintenance' && error.errorcode != 'wsaccessusersuspended' && error.errorcode != 'wsaccessuserdeleted' && !this.isExpiredTokenError(error) || error.status && error.status >= 400 // CoreHttpError, assume status 400 and above are like WebService errors.\n    );\n  }\n  /**\n   * Given an error returned by a WS call, check if the error is a token expired error.\n   *\n   * @param error Error to check.\n   * @returns Whether the error is a token expired error.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isExpiredTokenError(error) {\n    return error.errorcode === 'invalidtoken' || error.errorcode === 'accessexception' && error.message.includes('Invalid token - token expired');\n  }\n  /**\n   * Given a list (e.g. a,b,c,d,e) this function returns an array of 1->a, 2->b, 3->c etc.\n   * Taken from make_menu_from_list on moodlelib.php (not the same but similar).\n   *\n   * @param list The string to explode into array bits\n   * @param defaultLabel Element that will become default option, if not defined, it won't be added.\n   * @param separator The separator used within the list string. Default ','.\n   * @param defaultValue Element that will become default option value. Default 0.\n   * @returns The now assembled array\n   */\n  makeMenuFromList(list, defaultLabel, separator = ',', defaultValue) {\n    // Split and format the list.\n    const split = list.split(separator).map((label, index) => ({\n      label: label.trim(),\n      value: index + 1\n    }));\n    if (defaultLabel) {\n      split.unshift({\n        label: defaultLabel,\n        value: defaultValue || 0\n      });\n    }\n    return split;\n  }\n  /**\n   * Merge two arrays, removing duplicate values.\n   *\n   * @param array1 The first array.\n   * @param array2 The second array.\n   * @param [key] Key of the property that must be unique. If not specified, the whole entry.\n   * @returns Merged array.\n   */\n  mergeArraysWithoutDuplicates(array1, array2, key) {\n    return this.uniqueArray(array1.concat(array2), key);\n  }\n  /**\n   * Check if a value isn't null or undefined.\n   *\n   * @param value Value to check.\n   * @returns True if not null and not undefined.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  notNullOrUndefined(value) {\n    return value !== undefined && value !== null;\n  }\n  /**\n   * Open a file using platform specific method.\n   *\n   * @param path The local path of the file to be open.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  openFile(path, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      // Convert the path to a native path if needed.\n      path = CoreFile.unconvertFileSrc(path);\n      const extension = CoreMimetypeUtils.getFileExtension(path);\n      const mimetype = extension && CoreMimetypeUtils.getMimeType(extension);\n      if (mimetype == 'text/html' && CorePlatform.isAndroid()) {\n        // Open HTML local files in InAppBrowser, in system browser some embedded files aren't loaded.\n        _this7.openInApp(path);\n        return;\n      } else if (extension === 'apk' && CorePlatform.isAndroid()) {\n        const url = yield CoreUtils.ignoreErrors(CoreFilepool.getFileUrlByPath(CoreSites.getCurrentSiteId(), CoreFile.removeBasePath(path)));\n        // @todo MOBILE-4167: Handle urls with expired tokens.\n        throw new CoreErrorWithOptions(Translate.instant('core.cannotinstallapkinfo'), Translate.instant('core.cannotinstallapk'), url ? [{\n          text: Translate.instant('core.openinbrowser'),\n          handler: () => _this7.openInBrowser(url)\n        }, {\n          text: Translate.instant('core.cancel'),\n          role: 'cancel'\n        }] : undefined);\n      }\n      // Path needs to be decoded, the file won't be opened if the path has %20 instead of spaces and so.\n      try {\n        path = decodeURIComponent(path);\n      } catch (ex) {\n        // Error, use the original path.\n      }\n      const openFile = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (mimetype) {\n          if (_this7.shouldOpenWithDialog(options)) {\n            yield FileOpener.showOpenWithDialog(path, mimetype || '');\n          } else {\n            yield FileOpener.open(path, mimetype || '');\n          }\n        });\n        return function openFile(_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      try {\n        try {\n          yield openFile(mimetype);\n        } catch (error) {\n          if (!extension || !error || Number(error.status) !== 9) {\n            throw error;\n          }\n          // Cannot open mimetype. Check if there is a deprecated mimetype for the extension.\n          const deprecatedMimetype = CoreMimetypeUtils.getDeprecatedMimeType(extension);\n          if (!deprecatedMimetype || deprecatedMimetype === mimetype) {\n            throw error;\n          }\n          yield openFile(deprecatedMimetype);\n        }\n      } catch (error) {\n        _this7.logger.error('Error opening file ' + path + ' with mimetype ' + mimetype);\n        _this7.logger.error('Error: ', JSON.stringify(error));\n        if (!extension || extension.indexOf('/') > -1 || extension.indexOf('\\\\') > -1) {\n          // Extension not found.\n          throw new Error(Translate.instant('core.erroropenfilenoextension'));\n        }\n        throw new Error(Translate.instant('core.erroropenfilenoapp'));\n      }\n    })();\n  }\n  /**\n   * Open a URL using InAppBrowser.\n   * Do not use for files, refer to {@link CoreUtilsProvider.openFile}.\n   *\n   * @param url The URL to open.\n   * @param options Override default options passed to InAppBrowser.\n   * @returns The opened window.\n   */\n  openInApp(url, options) {\n    var _options$enableViewPo, _options$allowInlineM, _this$iabInstance, _options$originalUrl;\n    options = options || {};\n    options.usewkwebview = 'yes'; // Force WKWebView in iOS.\n    options.enableViewPortScale = (_options$enableViewPo = options.enableViewPortScale) !== null && _options$enableViewPo !== void 0 ? _options$enableViewPo : 'yes'; // Enable zoom on iOS by default.\n    options.allowInlineMediaPlayback = (_options$allowInlineM = options.allowInlineMediaPlayback) !== null && _options$allowInlineM !== void 0 ? _options$allowInlineM : 'yes'; // Allow playing inline videos in iOS.\n    if (!options.location && CorePlatform.isIOS() && url.indexOf('file://') === 0) {\n      // The URL uses file protocol, don't show it on iOS.\n      // In Android we keep it because otherwise we lose the whole toolbar.\n      options.location = 'no';\n    }\n    this.setInAppBrowserToolbarColors(options);\n    (_this$iabInstance = this.iabInstance) === null || _this$iabInstance === void 0 || _this$iabInstance.close(); // Close window if there is one already open, only allow one.\n    this.iabInstance = InAppBrowser.create(url, '_blank', options);\n    if (CorePlatform.isMobile()) {\n      const loadStartUrls = [];\n      const loadStartSubscription = this.iabInstance.on('loadstart').subscribe(event => {\n        NgZone.run(() => {\n          // Store the last loaded URLs (max 10).\n          loadStartUrls.push(event.url);\n          if (loadStartUrls.length > 10) {\n            loadStartUrls.shift();\n          }\n          CoreEvents.trigger(CoreEvents.IAB_LOAD_START, event);\n        });\n      });\n      const loadStopSubscription = this.iabInstance.on('loadstop').subscribe(event => {\n        NgZone.run(() => {\n          CoreEvents.trigger(CoreEvents.IAB_LOAD_STOP, event);\n        });\n      });\n      const messageSubscription = this.iabInstance.on('message').subscribe(event => {\n        NgZone.run(() => {\n          CoreEvents.trigger(CoreEvents.IAB_MESSAGE, event.data);\n        });\n      });\n      const exitSubscription = this.iabInstance.on('exit').subscribe(event => {\n        NgZone.run(() => {\n          loadStartSubscription.unsubscribe();\n          loadStopSubscription.unsubscribe();\n          messageSubscription.unsubscribe();\n          exitSubscription.unsubscribe();\n          this.iabInstance = undefined;\n          CoreEvents.trigger(CoreEvents.IAB_EXIT, event);\n        });\n      });\n    }\n    CoreAnalytics.logEvent({\n      type: CoreAnalyticsEventType.OPEN_LINK,\n      link: CoreUrlUtils.unfixPluginfileURL((_options$originalUrl = options.originalUrl) !== null && _options$originalUrl !== void 0 ? _options$originalUrl : url)\n    });\n    return this.iabInstance;\n  }\n  /**\n   * Given some IAB options, set the toolbar colors properties to the right values.\n   *\n   * @param options Options to change.\n   * @returns Changed options.\n   */\n  setInAppBrowserToolbarColors(options) {\n    if (options.toolbarcolor) {\n      // Color already set.\n      return options;\n    }\n    // Color not set. Check if it needs to be changed automatically.\n    let bgColor;\n    let textColor;\n    if (CoreConstants.CONFIG.iabToolbarColors === 'auto') {\n      bgColor = CoreColors.getToolbarBackgroundColor();\n    } else if (CoreConstants.CONFIG.iabToolbarColors && typeof CoreConstants.CONFIG.iabToolbarColors === 'object') {\n      bgColor = CoreConstants.CONFIG.iabToolbarColors.background;\n      textColor = CoreConstants.CONFIG.iabToolbarColors.text;\n    }\n    if (!bgColor) {\n      // Use default color. In iOS, use black background color since the default is transparent and doesn't look good.\n      options.locationcolor = '#000000';\n      return options;\n    }\n    if (!textColor) {\n      textColor = CoreColors.isWhiteContrastingBetter(bgColor) ? '#ffffff' : '#000000';\n    }\n    options.toolbarcolor = bgColor;\n    options.closebuttoncolor = textColor;\n    options.navigationbuttoncolor = textColor;\n    options.locationcolor = bgColor;\n    options.locationtextcolor = textColor;\n    return options;\n  }\n  /**\n   * Open a URL using a browser.\n   * Do not use for files, refer to {@link CoreUtilsProvider.openFile}.\n   *\n   * @param url The URL to open.\n   * @param options Options.\n   */\n  openInBrowser(url, options = {}) {\n    return _asyncToGenerator(function* () {\n      var _ref3, _options$originalUrl2;\n      // eslint-disable-next-line deprecation/deprecation\n      const originaUrl = CoreUrlUtils.unfixPluginfileURL((_ref3 = (_options$originalUrl2 = options.originalUrl) !== null && _options$originalUrl2 !== void 0 ? _options$originalUrl2 : options.browserWarningUrl) !== null && _ref3 !== void 0 ? _ref3 : url);\n      if (options.showBrowserWarning || options.showBrowserWarning === undefined) {\n        try {\n          yield CoreWindow.confirmOpenBrowserIfNeeded(originaUrl);\n        } catch (error) {\n          return; // Cancelled, stop.\n        }\n      }\n\n      CoreAnalytics.logEvent({\n        type: CoreAnalyticsEventType.OPEN_LINK,\n        link: originaUrl\n      });\n      window.open(url, '_system');\n    })();\n  }\n  /**\n   * Open an online file using platform specific method.\n   * Specially useful for audio and video since they can be streamed.\n   *\n   * @param url The URL of the file.\n   * @returns Promise resolved when opened.\n   */\n  openOnlineFile(url) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (CorePlatform.isAndroid()) {\n        // In Android we need the mimetype to open it.\n        const mimetype = yield _this8.ignoreErrors(_this8.getMimeTypeFromUrl(url));\n        if (!mimetype) {\n          // Couldn't retrieve mimetype. Return error.\n          throw new Error(Translate.instant('core.erroropenfilenoextension'));\n        }\n        const options = {\n          action: WebIntent.ACTION_VIEW,\n          url,\n          type: mimetype\n        };\n        try {\n          yield WebIntent.startActivity(options);\n          CoreAnalytics.logEvent({\n            type: CoreAnalyticsEventType.OPEN_LINK,\n            link: CoreUrlUtils.unfixPluginfileURL(url)\n          });\n        } catch (error) {\n          _this8.logger.error('Error opening online file ' + url + ' with mimetype ' + mimetype);\n          _this8.logger.error('Error: ', JSON.stringify(error));\n          throw new Error(Translate.instant('core.erroropenfilenoapp'));\n        }\n      }\n      // In the rest of platforms we need to open them in InAppBrowser.\n      _this8.openInApp(url);\n    })();\n  }\n  /**\n   * Converts an object into an array, losing the keys.\n   *\n   * @param obj Object to convert.\n   * @returns Array with the values of the object but losing the keys.\n   */\n  objectToArray(obj) {\n    return Object.keys(obj).map(key => obj[key]);\n  }\n  /**\n   * Converts an object into an array of objects, where each entry is an object containing\n   * the key and value of the original object.\n   * For example, it can convert {size: 2} into [{name: 'size', value: 2}].\n   *\n   * @param obj Object to convert.\n   * @param keyName Name of the properties where to store the keys.\n   * @param valueName Name of the properties where to store the values.\n   * @param sortByKey True to sort keys alphabetically, false otherwise. Has priority over sortByValue.\n   * @param sortByValue True to sort values alphabetically, false otherwise.\n   * @returns Array of objects with the name & value of each property.\n   */\n  objectToArrayOfObjects(obj, keyName, valueName, sortByKey, sortByValue) {\n    // Get the entries from an object or primitive value.\n    const getEntries = (elKey, value) => {\n      if (value === undefined || value == null) {\n        // Filter undefined and null values.\n        return;\n      } else if (this.isObject(value)) {\n        // It's an object, return at least an entry for each property.\n        const keys = Object.keys(value);\n        let entries = [];\n        keys.forEach(key => {\n          const newElKey = elKey ? elKey + '[' + key + ']' : key;\n          const subEntries = getEntries(newElKey, value[key]);\n          if (subEntries) {\n            entries = entries.concat(subEntries);\n          }\n        });\n        return entries;\n      } else {\n        // Not an object, return a single entry.\n        const entry = {};\n        entry[keyName] = elKey;\n        entry[valueName] = value;\n        return entry;\n      }\n    };\n    if (!obj) {\n      return [];\n    }\n    // \"obj\" will always be an object, so \"entries\" will always be an array.\n    const entries = getEntries('', obj);\n    if (sortByKey || sortByValue) {\n      return entries.sort((a, b) => {\n        if (sortByKey) {\n          return a[keyName] >= b[keyName] ? 1 : -1;\n        } else {\n          return a[valueName] >= b[valueName] ? 1 : -1;\n        }\n      });\n    }\n    return entries;\n  }\n  /**\n   * Converts an array of objects into an object with key and value. The opposite of objectToArrayOfObjects.\n   * For example, it can convert [{name: 'size', value: 2}] into {size: 2}.\n   *\n   * @param objects List of objects to convert.\n   * @param keyName Name of the properties where the keys are stored.\n   * @param valueName Name of the properties where the values are stored.\n   * @param keyPrefix Key prefix if neededs to delete it.\n   * @returns Object.\n   */\n  objectToKeyValueMap(objects, keyName, valueName, keyPrefix) {\n    const prefixSubstr = keyPrefix ? keyPrefix.length : 0;\n    const mapped = {};\n    objects.forEach(item => {\n      const keyValue = item[keyName];\n      const key = prefixSubstr > 0 ? keyValue.substring(prefixSubstr) : keyValue;\n      mapped[key] = item[valueName];\n    });\n    return mapped;\n  }\n  /**\n   * Convert an object to a format of GET param. E.g.: {a: 1, b: 2} -> a=1&b=2\n   *\n   * @param object Object to convert.\n   * @param removeEmpty Whether to remove params whose value is null/undefined.\n   * @returns GET params.\n   */\n  objectToGetParams(object, removeEmpty = true) {\n    // First of all, flatten the object so all properties are in the first level.\n    const flattened = this.flattenObject(object);\n    let result = '';\n    let joinChar = '';\n    for (const name in flattened) {\n      let value = flattened[name];\n      if (removeEmpty && (value === null || value === undefined)) {\n        continue;\n      }\n      if (typeof value == 'boolean') {\n        value = value ? 1 : 0;\n      }\n      result += joinChar + name + '=' + value;\n      joinChar = '&';\n    }\n    return result;\n  }\n  /**\n   * Add a prefix to all the keys in an object.\n   *\n   * @param data Object.\n   * @param prefix Prefix to add.\n   * @returns Prefixed object.\n   */\n  prefixKeys(data, prefix) {\n    const newObj = {};\n    const keys = Object.keys(data);\n    keys.forEach(key => {\n      newObj[prefix + key] = data[key];\n    });\n    return newObj;\n  }\n  /**\n   * Function to enumerate enum keys.\n   *\n   * @param enumeration Enumeration object.\n   * @returns Keys of the enumeration.\n   */\n  enumKeys(enumeration) {\n    return Object.keys(enumeration).filter(k => Number.isNaN(+k));\n  }\n  /**\n   * Create a deferred promise that can be resolved or rejected explicitly.\n   *\n   * @returns The deferred promise.\n   * @deprecated since 4.1. Use CorePromisedValue instead.\n   */\n  promiseDefer() {\n    return new CorePromisedValue();\n  }\n  /**\n   * Given a promise, returns true if it's rejected or false if it's resolved.\n   *\n   * @param promise Promise to check\n   * @returns Promise resolved with boolean: true if the promise is rejected or false if it's resolved.\n   */\n  promiseFails(promise) {\n    return _asyncToGenerator(function* () {\n      try {\n        yield promise;\n        return false;\n      } catch (_unused3) {\n        return true;\n      }\n    })();\n  }\n  /**\n   * Given a promise, returns true if it's resolved or false if it's rejected.\n   *\n   * @param promise Promise to check\n   * @returns Promise resolved with boolean: true if the promise it's resolved or false if it's rejected.\n   */\n  promiseWorks(promise) {\n    return _asyncToGenerator(function* () {\n      try {\n        yield promise;\n        return true;\n      } catch (_unused4) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Tests to see whether two arrays or objects have the same value at a particular key.\n   * Missing values are replaced by '', and the values are compared with ===.\n   * Booleans and numbers are cast to string before comparing.\n   *\n   * @param obj1 The first object or array.\n   * @param obj2 The second object or array.\n   * @param key Key to check.\n   * @returns Whether the two objects/arrays have the same value (or lack of one) for a given key.\n   */\n  sameAtKeyMissingIsBlank(obj1, obj2, key) {\n    let value1 = obj1[key] !== undefined ? obj1[key] : '';\n    let value2 = obj2[key] !== undefined ? obj2[key] : '';\n    if (typeof value1 == 'number' || typeof value1 == 'boolean') {\n      value1 = '' + value1;\n    }\n    if (typeof value2 == 'number' || typeof value2 == 'boolean') {\n      value2 = '' + value2;\n    }\n    return value1 === value2;\n  }\n  /**\n   * Stringify an object, sorting the properties. It doesn't sort arrays, only object properties. E.g.:\n   * {b: 2, a: 1} -> '{\"a\":1,\"b\":2}'\n   *\n   * @param obj Object to stringify.\n   * @returns Stringified object.\n   */\n  sortAndStringify(obj) {\n    return JSON.stringify(this.sortProperties(obj));\n  }\n  /**\n   * Given an object, sort its properties and the properties of all the nested objects.\n   *\n   * @param obj The object to sort. If it isn't an object, the original value will be returned.\n   * @returns Sorted object.\n   */\n  sortProperties(obj) {\n    if (obj != null && typeof obj == 'object' && !Array.isArray(obj)) {\n      // It's an object, sort it.\n      return Object.keys(obj).sort().reduce((accumulator, key) => {\n        // Always call sort with the value. If it isn't an object, the original value will be returned.\n        accumulator[key] = this.sortProperties(obj[key]);\n        return accumulator;\n      }, {});\n    } else {\n      return obj;\n    }\n  }\n  /**\n   * Given an object, sort its values. Values need to be primitive values, it cannot have subobjects.\n   *\n   * @param obj The object to sort. If it isn't an object, the original value will be returned.\n   * @returns Sorted object.\n   */\n  sortValues(obj) {\n    if (typeof obj == 'object' && !Array.isArray(obj)) {\n      // It's an object, sort it. Convert it to an array to be able to sort it and then convert it back to object.\n      const array = this.objectToArrayOfObjects(obj, 'name', 'value', false, true);\n      return this.objectToKeyValueMap(array, 'name', 'value');\n    } else {\n      return obj;\n    }\n  }\n  /**\n   * Set a timeout to a Promise. If the time passes before the Promise is resolved or rejected, it will be automatically\n   * rejected.\n   *\n   * @param promise The promise to timeout.\n   * @param time Number of milliseconds of the timeout.\n   * @returns Promise with the timeout.\n   */\n  timeoutPromise(promise, time) {\n    return new Promise((resolve, reject) => {\n      let timedOut = false;\n      const resolveBeforeTimeout = value => {\n        if (timedOut) {\n          return;\n        }\n        resolve(value);\n      };\n      const timeout = setTimeout(() => {\n        reject({\n          timeout: true\n        });\n        timedOut = true;\n      }, time);\n      promise.then(resolveBeforeTimeout).catch(reject).finally(() => clearTimeout(timeout));\n    });\n  }\n  /**\n   * Converts locale specific floating point/comma number back to a standard float number.\n   * Do NOT try to do any math operations before this conversion on any user submitted floats!\n   * Based on Moodle's unformat_float function.\n   *\n   * @param localeFloat Locale aware float representation.\n   * @param strict If true, then check the input and return false if it is not a valid number.\n   * @returns False if bad format, empty string if empty value or the parsed float if not.\n   */\n  unformatFloat(localeFloat, strict) {\n    // Bad format on input type number.\n    if (localeFloat === undefined) {\n      return false;\n    }\n    // Empty (but not zero).\n    if (localeFloat == null) {\n      return '';\n    }\n    // Convert float to string.\n    localeFloat = String(localeFloat);\n    localeFloat = localeFloat.trim();\n    if (localeFloat == '') {\n      return '';\n    }\n    localeFloat = localeFloat.replace(' ', ''); // No spaces - those might be used as thousand separators.\n    localeFloat = localeFloat.replace(Translate.instant('core.decsep'), '.');\n    // Use Number instead of parseFloat because the latter truncates the number when it finds \",\", while Number returns NaN.\n    // If the number still has \",\" then it means it's not a valid separator.\n    const parsedFloat = Number(localeFloat);\n    // Bad format.\n    if (strict && (!isFinite(parsedFloat) || isNaN(parsedFloat))) {\n      return false;\n    }\n    return parsedFloat;\n  }\n  /**\n   * Return an array without duplicate values.\n   *\n   * @param array The array to treat.\n   * @param [key] Key of the property that must be unique. If not specified, the whole entry.\n   * @returns Array without duplicate values.\n   */\n  uniqueArray(array, key) {\n    const unique = {}; // Use an object to make it faster to check if it's duplicate.\n    return array.filter(entry => {\n      const value = key ? entry[key] : entry;\n      if (value in unique) {\n        return false;\n      }\n      unique[value] = true;\n      return true;\n    });\n  }\n  /**\n   * Debounce a function so consecutive calls are ignored until a certain time has passed since the last call.\n   *\n   * @param fn Function to debounce.\n   * @param delay Time that must pass until the function is called.\n   * @returns Debounced function.\n   */\n  debounce(fn, delay) {\n    let timeoutID;\n    const debounced = (...args) => {\n      clearTimeout(timeoutID);\n      timeoutID = window.setTimeout(() => fn.apply(null, args), delay);\n    };\n    return debounced;\n  }\n  /**\n   * Throttle a function so consecutive calls are ignored until a certain time has passed since the last executed call.\n   *\n   * @param fn Function to throttle.\n   * @param duration Time that must pass until the function is called.\n   * @returns Throttled function.\n   */\n  throttle(fn, duration) {\n    let shouldWait = false;\n    const throttled = (...args) => {\n      if (!shouldWait) {\n        fn.apply(null, args);\n        shouldWait = true;\n        setTimeout(() => {\n          shouldWait = false;\n        }, duration);\n      }\n    };\n    return throttled;\n  }\n  /**\n   * Check whether the app can scan QR codes.\n   *\n   * @returns Whether the app can scan QR codes.\n   */\n  canScanQR() {\n    return CorePlatform.isMobile();\n  }\n  /**\n   * Open a modal to scan a QR code.\n   *\n   * @param title Title of the modal. Defaults to \"QR reader\".\n   * @returns Promise resolved with the captured text or undefined if cancelled or error.\n   */\n  scanQR(title) {\n    return _asyncToGenerator(function* () {\n      return CoreDomUtils.openModal({\n        component: CoreViewerQRScannerComponent,\n        cssClass: 'core-modal-fullscreen',\n        componentProps: {\n          title\n        }\n      });\n    })();\n  }\n  /**\n   * Start scanning for a QR code.\n   *\n   * @returns Promise resolved with the QR string, rejected if error or cancelled.\n   */\n  startScanQR() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (!CorePlatform.isMobile()) {\n        return Promise.reject('QRScanner isn\\'t available in browser.');\n      }\n      // Ask the user for permission to use the camera.\n      // The scan method also does this, but since it returns an Observable we wouldn't be able to detect if the user denied.\n      try {\n        const status = yield QRScanner.prepare();\n        if (!status.authorized) {\n          // No access to the camera, reject. In android this shouldn't happen, denying access passes through catch.\n          throw new Error('The user denied camera access.');\n        }\n        if (_this9.qrScanData && _this9.qrScanData.deferred) {\n          // Already scanning.\n          return _this9.qrScanData.deferred;\n        }\n        // Start scanning.\n        _this9.qrScanData = {\n          deferred: new CorePromisedValue(),\n          // When text is received, stop scanning and return the text.\n          observable: QRScanner.scan().subscribe(text => _this9.stopScanQR(text, false))\n        };\n        // Show the camera.\n        try {\n          yield QRScanner.show();\n          document.body.classList.add('core-scanning-qr');\n          // Set color-scheme to 'normal', otherwise the camera isn't seen in Android.\n          const colorSchemeMeta = document.querySelector('meta[name=\"color-scheme\"]');\n          if (colorSchemeMeta) {\n            _this9.initialColorSchemeContent = colorSchemeMeta.getAttribute('content') || _this9.initialColorSchemeContent;\n            colorSchemeMeta.setAttribute('content', 'normal');\n          }\n          return _this9.qrScanData.deferred;\n        } catch (e) {\n          _this9.stopScanQR(e, true);\n          throw e;\n        }\n      } catch (error) {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        error.message = error.message || error._message;\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Stop scanning for QR code. If no param is provided, the app will consider the user cancelled.\n   *\n   * @param data If success, the text of the QR code. If error, the error object or message. Undefined for cancelled.\n   * @param error True if the data belongs to an error, false otherwise.\n   */\n  stopScanQR(data, error) {\n    var _document$querySelect;\n    if (!this.qrScanData) {\n      // Not scanning.\n      return;\n    }\n    // Hide camera preview.\n    document.body.classList.remove('core-scanning-qr');\n    // Set color-scheme to the initial value.\n    (_document$querySelect = document.querySelector('meta[name=\"color-scheme\"]')) === null || _document$querySelect === void 0 || _document$querySelect.setAttribute('content', this.initialColorSchemeContent);\n    QRScanner.hide();\n    QRScanner.destroy();\n    this.qrScanData.observable.unsubscribe(); // Stop scanning.\n    if (error) {\n      this.qrScanData.deferred.reject(typeof data === 'string' ? new Error(data) : data);\n    } else if (data !== undefined) {\n      this.qrScanData.deferred.resolve(data);\n    } else {\n      this.qrScanData.deferred.reject(new CoreCanceledError());\n    }\n    delete this.qrScanData;\n  }\n  ignoreErrors(promise, fallback) {\n    return _asyncToGenerator(function* () {\n      try {\n        const result = yield promise;\n        return result;\n      } catch (_unused5) {\n        // Ignore errors.\n        return fallback;\n      }\n    })();\n  }\n  /**\n   * Wait some time.\n   *\n   * @param milliseconds Number of milliseconds to wait.\n   * @returns Promise resolved after the time has passed.\n   */\n  wait(milliseconds) {\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\n  }\n  /**\n   * Wait until a given condition is met.\n   *\n   * @param condition Condition.\n   * @returns Cancellable promise.\n   */\n  waitFor(condition, interval = 50) {\n    if (condition()) {\n      return CoreCancellablePromise.resolve();\n    }\n    let intervalId;\n    return new CoreCancellablePromise( /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (resolve) {\n        intervalId = window.setInterval(() => {\n          if (!condition()) {\n            return;\n          }\n          resolve();\n          window.clearInterval(intervalId);\n        }, interval);\n      });\n      return function (_x3) {\n        return _ref4.apply(this, arguments);\n      };\n    }(), () => window.clearInterval(intervalId));\n  }\n  /**\n   * Wait until the next tick.\n   *\n   * @returns Promise resolved when tick has been done.\n   */\n  nextTick() {\n    return this.wait(0);\n  }\n  /**\n   * Wait until several next ticks.\n   */\n  nextTicks(numTicks = 0) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      for (let i = 0; i < numTicks; i++) {\n        yield _this10.wait(0);\n      }\n    })();\n  }\n  /**\n   * Given some options, check if a file should be opened with showOpenWithDialog.\n   *\n   * @param options Options.\n   * @returns Boolean.\n   */\n  shouldOpenWithDialog(options = {}) {\n    var _options$iOSOpenFileA;\n    const openFileAction = (_options$iOSOpenFileA = options.iOSOpenFileAction) !== null && _options$iOSOpenFileA !== void 0 ? _options$iOSOpenFileA : CoreConstants.CONFIG.iOSDefaultOpenFileAction;\n    return CorePlatform.isIOS() && openFileAction == OpenFileAction.OPEN_WITH;\n  }\n}\n_class = CoreUtilsProvider;\n_class.fac = function CoreUtilsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.prov = /*@__PURE__*/i0.defineInjectable({\n  token: _class,\n  factory: _class.fac,\n  providedIn: 'root'\n});\nexport const CoreUtils = makeSingleton(CoreUtilsProvider);\n/**\n * Possible default picker actions.\n */\nexport var OpenFileAction;\n(function (OpenFileAction) {\n  OpenFileAction[\"OPEN\"] = \"open\";\n  OpenFileAction[\"OPEN_WITH\"] = \"open-with\";\n})(OpenFileAction || (OpenFileAction = {}));","map":{"version":3,"names":["CoreEvents","CoreFile","CoreLang","CoreWS","CoreDomUtils","CoreMimetypeUtils","CoreTextUtils","makeSingleton","Clipboard","InAppBrowser","FileOpener","WebIntent","Translate","NgZone","CoreLogger","CoreViewerQRScannerComponent","CoreCanceledError","CoreConstants","CoreWindow","CoreColors","CorePromisedValue","CorePlatform","CoreErrorWithOptions","CoreFilepool","CoreSites","CoreCancellablePromise","CoreAnalytics","CoreAnalyticsEventType","CoreUrlUtils","QRScanner","CoreUtilsProvider","constructor","DONT_CLONE","uniqueIds","initialColorSchemeContent","logger","getInstance","addDataNotDownloadedError","error","defaultError","errorMessage","getErrorMessageFromError","isWebServiceError","instant","allPromises","promises","_asyncToGenerator","length","getPromiseError","_ref","promise","_x","apply","arguments","errors","Promise","all","map","find","allPromisesIgnoringErrors","_this","CoreUtils","ignoreErrors","arrayToObject","array","propertyName","result","entry","key","logUnhandledError","message","arrayToObjectMultiple","undefined","push","basicLeftCompare","itemA","itemB","maxLevels","level","undefinedIsNull","equal","name","value","floatA","parseFloat","floatB","isNaN","checkRedirect","url","_this2","window","fetch","initOptions","redirect","controller","AbortController","signal","response","timeoutPromise","getRequestTimeout","redirected","timeout","abort","closeInAppBrowser","iabInstance","close","getInAppBrowserInstance","isInAppBrowserOpen","clone","source","valueIsFileEntry","Array","isArray","newArray","i","isObject","toString","indexOf","newObject","copyProperties","from","to","copyToClipboard","text","copy","_unused","virtualInput","document","createElement","innerHTML","select","setSelectionRange","execCommand","showToast","emptyArray","emptyObject","object","Object","prototype","hasOwnProperty","call","executeOrderedPromises","orderedPromisesData","dependency","resolve","data","finally","function","e","blocking","flattenObject","obj","useDotNotation","toReturn","flatObject","subName","newName","filterByRegexp","regex","filter","matches","match","filterEnabledSites","siteIds","isEnabledFn","checkAll","args","_this3","enabledSites","siteId","pushIfEnabled","enabled","then","formatFloat","float","localeSeparator","floatString","String","replace","formatTree","list","parentFieldName","idFieldName","rootParentId","maxDepth","mapDepth","tree","forEach","node","index","id","children","parent","parentNode","parentOfParent","getCountryName","code","countryKey","countryName","getCountryList","_this4","keys","getCountryKeysList","countries","getCountryListSorted","_this5","sort","a","b","localeCompare","_this6","defaultLang","getDefaultLanguage","getCountryKeysListForLanguage","_unused2","fallbackLang","getFallbackLanguage","Error","lang","table","getTranslationTable","getMimeTypeFromUrl","extension","guessExtensionFromUrl","mimetype","getMimeType","getRemoteFileMimeType","getUniqueId","isFileEntry","file","hasRepeatedFilenames","files","names","filename","$a","indexOfRegexp","isFalseOrZero","parseInt","isTrueOrOne","warningcode","errorcode","isExpiredTokenError","status","includes","makeMenuFromList","defaultLabel","separator","defaultValue","split","label","trim","unshift","mergeArraysWithoutDuplicates","array1","array2","uniqueArray","concat","notNullOrUndefined","openFile","path","options","_this7","unconvertFileSrc","getFileExtension","isAndroid","openInApp","getFileUrlByPath","getCurrentSiteId","removeBasePath","handler","openInBrowser","role","decodeURIComponent","ex","_ref2","shouldOpenWithDialog","showOpenWithDialog","open","_x2","Number","deprecatedMimetype","getDeprecatedMimeType","JSON","stringify","_options$enableViewPo","_options$allowInlineM","_this$iabInstance","_options$originalUrl","usewkwebview","enableViewPortScale","allowInlineMediaPlayback","location","isIOS","setInAppBrowserToolbarColors","create","isMobile","loadStartUrls","loadStartSubscription","on","subscribe","event","run","shift","trigger","IAB_LOAD_START","loadStopSubscription","IAB_LOAD_STOP","messageSubscription","IAB_MESSAGE","exitSubscription","unsubscribe","IAB_EXIT","logEvent","type","OPEN_LINK","link","unfixPluginfileURL","originalUrl","toolbarcolor","bgColor","textColor","CONFIG","iabToolbarColors","getToolbarBackgroundColor","background","locationcolor","isWhiteContrastingBetter","closebuttoncolor","navigationbuttoncolor","locationtextcolor","_ref3","_options$originalUrl2","originaUrl","browserWarningUrl","showBrowserWarning","confirmOpenBrowserIfNeeded","openOnlineFile","_this8","action","ACTION_VIEW","startActivity","objectToArray","objectToArrayOfObjects","keyName","valueName","sortByKey","sortByValue","getEntries","elKey","entries","newElKey","subEntries","objectToKeyValueMap","objects","keyPrefix","prefixSubstr","mapped","item","keyValue","substring","objectToGetParams","removeEmpty","flattened","joinChar","prefixKeys","prefix","newObj","enumKeys","enumeration","k","promiseDefer","promiseFails","_unused3","promiseWorks","_unused4","sameAtKeyMissingIsBlank","obj1","obj2","value1","value2","sortAndStringify","sortProperties","reduce","accumulator","sortValues","time","reject","timedOut","resolveBeforeTimeout","setTimeout","catch","clearTimeout","unformatFloat","localeFloat","strict","parsedFloat","isFinite","unique","debounce","fn","delay","timeoutID","debounced","throttle","duration","shouldWait","throttled","canScanQR","scanQR","title","openModal","component","cssClass","componentProps","startScanQR","_this9","prepare","authorized","qrScanData","deferred","observable","scan","stopScanQR","show","body","classList","add","colorSchemeMeta","querySelector","getAttribute","setAttribute","_message","_document$querySelect","remove","hide","destroy","fallback","_unused5","wait","milliseconds","waitFor","condition","interval","intervalId","_ref4","setInterval","clearInterval","_x3","nextTick","nextTicks","numTicks","_this10","_options$iOSOpenFileA","openFileAction","iOSOpenFileAction","iOSDefaultOpenFileAction","OpenFileAction","OPEN_WITH","factory","fac","providedIn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/utils/utils.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { InAppBrowserObject, InAppBrowserOptions } from '@awesome-cordova-plugins/in-app-browser';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\nimport { Subscription } from 'rxjs';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreFile } from '@services/file';\nimport { CoreLang } from '@services/lang';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton, Clipboard, InAppBrowser, FileOpener, WebIntent, Translate, NgZone } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreViewerQRScannerComponent } from '@features/viewer/components/qr-scanner/qr-scanner';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreFileEntry } from '@services/file-helper';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreWindow } from '@singletons/window';\nimport { CoreColors } from '@singletons/colors';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { CoreErrorWithOptions } from '@classes/errors/errorwithoptions';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreCancellablePromise } from '@classes/cancellable-promise';\nimport { CoreAnalytics, CoreAnalyticsEventType } from '@services/analytics';\nimport { CoreUrlUtils } from './url';\nimport { QRScanner } from '@features/native/plugins';\n\nexport type TreeNode<T> = T & { children: TreeNode<T>[] };\n\n/*\n * \"Utils\" service with helper functions.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreUtilsProvider {\n\n    protected readonly DONT_CLONE = ['[object FileEntry]', '[object DirectoryEntry]', '[object DOMFileSystem]'];\n\n    protected logger: CoreLogger;\n    protected iabInstance?: InAppBrowserObject;\n    protected uniqueIds: {[name: string]: number} = {};\n    protected qrScanData?: {deferred: CorePromisedValue<string>; observable: Subscription};\n    protected initialColorSchemeContent = 'light dark';\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreUtilsProvider');\n    }\n\n    /**\n     * Given an error, add an extra warning to the error message and return the new error message.\n     *\n     * @param error Error object or message.\n     * @param defaultError Message to show if the error is not a string.\n     * @returns New error message.\n     */\n    addDataNotDownloadedError(error: Error | string, defaultError?: string): string {\n        const errorMessage = CoreTextUtils.getErrorMessageFromError(error) || defaultError || '';\n\n        if (this.isWebServiceError(error)) {\n            return errorMessage;\n        }\n\n        // Local error. Add an extra warning.\n        return errorMessage + '<br><br>' + Translate.instant('core.errorsomedatanotdownloaded');\n    }\n\n    /**\n     * Similar to Promise.all, but if a promise fails this function's promise won't be rejected until ALL promises have finished.\n     *\n     * @param promises Promises.\n     * @returns Promise resolved if all promises are resolved and rejected if at least 1 promise fails.\n     */\n    async allPromises(promises: unknown[]): Promise<void> {\n        if (!promises || !promises.length) {\n            return;\n        }\n\n        const getPromiseError = async (promise: unknown): Promise<Error | void> => {\n            try {\n                await promise;\n            } catch (error) {\n                return error;\n            }\n        };\n\n        const errors = await Promise.all(promises.map(getPromiseError));\n        const error = errors.find(error => !!error);\n\n        if (error) {\n            throw error;\n        }\n    }\n\n    /**\n     * Combination of allPromises and ignoreErrors functions.\n     *\n     * @param promises Promises.\n     * @returns Promise resolved if all promises are resolved and rejected if at least 1 promise fails.\n     */\n    async allPromisesIgnoringErrors(promises: Promise<unknown>[]): Promise<void> {\n        await CoreUtils.ignoreErrors(this.allPromises(promises));\n    }\n\n    /**\n     * Converts an array of objects to an object, using a property of each entry as the key.\n     * It can also be used to convert an array of strings to an object where the keys are the elements of the array.\n     * E.g. [{id: 10, name: 'A'}, {id: 11, name: 'B'}] => {10: {id: 10, name: 'A'}, 11: {id: 11, name: 'B'}}\n     *\n     * @param array The array to convert.\n     * @param propertyName The name of the property to use as the key. If not provided, the whole item will be used.\n     * @param result Object where to put the properties. If not defined, a new object will be created.\n     * @returns The object.\n     */\n    arrayToObject<T>(\n        array: T[] = [],\n        propertyName?: string,\n        result: Record<string, T> = {},\n    ): Record<string, T> {\n        for (const entry of array) {\n            const key = propertyName ? entry[propertyName] : entry;\n\n            result[key] = entry;\n        }\n\n        return result;\n    }\n\n    /**\n     * Log an unhandled error.\n     *\n     * @param message Message to contextualize the error.\n     * @param error Error to log.\n     */\n    logUnhandledError(message: string, error: unknown): void {\n        this.logger.error(message, error);\n    }\n\n    /**\n     * Converts an array of objects to an indexed array, using a property of each entry as the key.\n     * Every entry will contain an array of the found objects of the property identifier.\n     * E.g. [{id: 10, name: 'A'}, {id: 10, name: 'B'}] => {10: [ {id: 10, name: 'A'}, {id: 10, name: 'B'} ] }\n     *\n     * @param array The array to convert.\n     * @param propertyName The name of the property to use as the key. If not provided, the whole item will be used.\n     * @param result Object where to put the properties. If not defined, a new object will be created.\n     * @returns The object.\n     */\n    arrayToObjectMultiple<T>(\n        array: T[] = [],\n        propertyName?: string,\n        result: Record<string, T[]> = {},\n    ): Record<string, T[]> {\n        for (const entry of array) {\n            const key = propertyName ? entry[propertyName] : entry;\n            if (result[key] === undefined) {\n                result[key] = [];\n            }\n\n            result[key].push(entry);\n        }\n\n        return result;\n    }\n\n    /**\n     * Compare two objects. This function won't compare functions and proto properties, it's a basic compare.\n     * Also, this will only check if itemA's properties are in itemB with same value. This function will still\n     * return true if itemB has more properties than itemA.\n     *\n     * @param itemA First object.\n     * @param itemB Second object.\n     * @param maxLevels Number of levels to reach if 2 objects are compared.\n     * @param level Current deep level (when comparing objects).\n     * @param undefinedIsNull True if undefined is equal to null. Defaults to true.\n     * @returns Whether both items are equal.\n     */\n    basicLeftCompare(\n        itemA: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        itemB: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        maxLevels: number = 0,\n        level: number = 0,\n        undefinedIsNull: boolean = true,\n    ): boolean {\n        if (typeof itemA == 'function' || typeof itemB == 'function') {\n            return true; // Don't compare functions.\n        } else if (typeof itemA == 'object' && typeof itemB == 'object') {\n            if (level >= maxLevels) {\n                return true; // Max deep reached.\n            }\n\n            let equal = true;\n            for (const name in itemA) {\n                const value = itemA[name];\n                if (name == '$$hashKey') {\n                    // Ignore $$hashKey property since it's a \"calculated\" property.\n                    continue;\n                }\n\n                if (!this.basicLeftCompare(value, itemB[name], maxLevels, level + 1)) {\n                    equal = false;\n                }\n            }\n\n            return equal;\n        } else {\n            if (undefinedIsNull && (\n                (itemA === undefined && itemB === null) || (itemA === null && itemB === undefined))) {\n                return true;\n            }\n\n            // We'll treat \"2\" and 2 as the same value.\n            const floatA = parseFloat(itemA);\n            const floatB = parseFloat(itemB);\n\n            if (!isNaN(floatA) && !isNaN(floatB)) {\n                return floatA == floatB;\n            }\n\n            return itemA === itemB;\n        }\n    }\n\n    /**\n     * Check if a URL has a redirect.\n     *\n     * @param url The URL to check.\n     * @returns Promise resolved with boolean_ whether there is a redirect.\n     */\n    async checkRedirect(url: string): Promise<boolean> {\n        if (!window.fetch) {\n            // Cannot check if there is a redirect, assume it's false.\n            return false;\n        }\n\n        const initOptions: RequestInit = { redirect: 'follow' };\n\n        // Some browsers implement fetch but no AbortController.\n        const controller = AbortController ? new AbortController() : false;\n\n        if (controller) {\n            initOptions.signal = controller.signal;\n        }\n\n        try {\n            const response = await this.timeoutPromise(window.fetch(url, initOptions), CoreWS.getRequestTimeout());\n\n            return response.redirected;\n        } catch (error) {\n            if (error.timeout && controller) {\n                // Timeout, abort the request.\n                controller.abort();\n            }\n\n            // There was a timeout, cannot determine if there's a redirect. Assume it's false.\n            return false;\n        }\n    }\n\n    /**\n     * Close the InAppBrowser window.\n     */\n    closeInAppBrowser(): void {\n        if (this.iabInstance) {\n            this.iabInstance.close();\n        }\n    }\n\n    /**\n     * Get inapp browser instance (if any).\n     *\n     * @returns IAB instance, undefined if not open.\n     */\n    getInAppBrowserInstance(): InAppBrowserObject | undefined  {\n        return this.iabInstance;\n    }\n\n    /**\n     * Check if inapp browser is open.\n     *\n     * @returns Whether it's open.\n     */\n    isInAppBrowserOpen(): boolean {\n        return !!this.iabInstance;\n    }\n\n    /**\n     * Clone a variable. It should be an object, array or primitive type.\n     *\n     * @param source The variable to clone.\n     * @param level Depth we are right now inside a cloned object. It's used to prevent reaching max call stack size.\n     * @returns Cloned variable.\n     */\n    clone<T>(source: T, level: number = 0): T {\n        if (level >= 20) {\n            // Max 20 levels.\n            this.logger.error('Max depth reached when cloning object.', source);\n\n            return source;\n        }\n\n        if (this.valueIsFileEntry(source)) {\n            // Don't clone FileEntry. It has a lot of depth and they shouldn't be modified.\n            return source;\n        } else if (Array.isArray(source)) {\n            // Clone the array and all the entries.\n            const newArray = [] as unknown as T;\n            for (let i = 0; i < source.length; i++) {\n                newArray[i] = this.clone(source[i], level + 1);\n            }\n\n            return newArray;\n        } else if (this.isObject(source)) {\n            // Check if the object shouldn't be copied.\n            if (source.toString && this.DONT_CLONE.indexOf(source.toString()) != -1) {\n                // Object shouldn't be copied, return it as it is.\n                return source;\n            }\n\n            // Clone the object and all the subproperties.\n            const newObject = {} as T;\n            for (const name in source) {\n                newObject[name] = this.clone(source[name], level + 1);\n            }\n\n            return newObject;\n        } else {\n            // Primitive type or unknown, return it as it is.\n            return source;\n        }\n    }\n\n    /**\n     * Copy properties from one object to another.\n     *\n     * @param from Object to copy the properties from.\n     * @param to Object where to store the properties.\n     * @param clone Whether the properties should be cloned (so they are different instances).\n     */\n    copyProperties(from: Record<string, unknown>, to: Record<string, unknown>, clone: boolean = true): void {\n        for (const name in from) {\n            if (clone) {\n                to[name] = this.clone(from[name]);\n            } else {\n                to[name] = from[name];\n            }\n        }\n    }\n\n    /**\n     * Copies a text to clipboard and shows a toast message.\n     *\n     * @param text Text to be copied\n     * @returns Promise resolved when text is copied.\n     */\n    async copyToClipboard(text: string): Promise<void> {\n        try {\n            await Clipboard.copy(text);\n        } catch {\n            // Use HTML Copy command.\n            const virtualInput = document.createElement('textarea');\n            virtualInput.innerHTML = text;\n            virtualInput.select();\n            virtualInput.setSelectionRange(0, 99999);\n            document.execCommand('copy'); // eslint-disable-line deprecation/deprecation\n        }\n\n        // Show toast using ionicLoading.\n        CoreDomUtils.showToast('core.copiedtoclipboard', true);\n    }\n\n    /**\n     * Empties an array without losing its reference.\n     *\n     * @param array Array to empty.\n     */\n    emptyArray(array: unknown[]): void {\n        array.length = 0; // Empty array without losing its reference.\n    }\n\n    /**\n     * Removes all properties from an object without losing its reference.\n     *\n     * @param object Object to remove the properties.\n     */\n    emptyObject(object: Record<string, unknown>): void {\n        for (const key in object) {\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n                delete object[key];\n            }\n        }\n    }\n\n    /**\n     * Execute promises one depending on the previous.\n     *\n     * @param orderedPromisesData Data to be executed.\n     * @returns Promise resolved when all promises are resolved.\n     */\n    executeOrderedPromises(orderedPromisesData: OrderedPromiseData[]): Promise<void> {\n        const promises: Promise<void>[] = [];\n        let dependency = Promise.resolve();\n\n        // Execute all the processes in order.\n        for (const i in orderedPromisesData) {\n            const data = orderedPromisesData[i];\n            // Add the process to the dependency stack.\n            const promise = dependency.finally(() => {\n                try {\n                    return data.function();\n                } catch (e) {\n                    this.logger.error(e.message);\n\n                    return;\n                }\n            });\n            promises.push(promise);\n\n            // If the new process is blocking, we set it as the dependency.\n            if (data.blocking) {\n                dependency = promise;\n            }\n        }\n\n        // Return when all promises are done.\n        return this.allPromises(promises);\n    }\n\n    /**\n     * Flatten an object, moving subobjects' properties to the first level.\n     * It supports 2 notations: dot notation and square brackets.\n     * E.g.: {a: {b: 1, c: 2}, d: 3} -> {'a.b': 1, 'a.c': 2, d: 3}\n     *\n     * @param obj Object to flatten.\n     * @param useDotNotation Whether to use dot notation '.' or square brackets '['.\n     * @returns Flattened object.\n     */\n    flattenObject(obj: Record<string, unknown>, useDotNotation?: boolean): Record<string, unknown> {\n        const toReturn = {};\n\n        for (const name in obj) {\n            if (!Object.prototype.hasOwnProperty.call(obj, name)) {\n                continue;\n            }\n\n            const value = obj[name];\n            if (typeof value == 'object' && !Array.isArray(value)) {\n                const flatObject = this.flattenObject(value as Record<string, unknown>);\n                for (const subName in flatObject) {\n                    if (!Object.prototype.hasOwnProperty.call(flatObject, subName)) {\n                        continue;\n                    }\n\n                    const newName = useDotNotation ? name + '.' + subName : name + '[' + subName + ']';\n                    toReturn[newName] = flatObject[subName];\n                }\n            } else {\n                toReturn[name] = value;\n            }\n        }\n\n        return toReturn;\n    }\n\n    /**\n     * Given an array of strings, return only the ones that match a regular expression.\n     *\n     * @param array Array to filter.\n     * @param regex RegExp to apply to each string.\n     * @returns Filtered array.\n     */\n    filterByRegexp(array: string[], regex: RegExp): string[] {\n        if (!array || !array.length) {\n            return [];\n        }\n\n        return array.filter((entry) => {\n            const matches = entry.match(regex);\n\n            return matches && matches.length;\n        });\n    }\n\n    /**\n     * Filter the list of site IDs based on a isEnabled function.\n     *\n     * @param siteIds Site IDs to filter.\n     * @param isEnabledFn Function to call for each site. It receives a siteId param and all the params sent to this function\n     *                    after 'checkAll'.\n     * @param checkAll True if it should check all the sites, false if it should check only 1 and treat them all\n     *                 depending on this result.\n     * @returns Promise resolved with the list of enabled sites.\n     */\n    async filterEnabledSites<P extends unknown[]>(\n        siteIds: string[],\n        isEnabledFn: (siteId: string, ...args: P) => boolean | Promise<boolean>,\n        checkAll?: boolean,\n        ...args: P\n    ): Promise<string[]> {\n        const promises: Promise<false | number>[] = [];\n        const enabledSites: string[] = [];\n\n        for (const i in siteIds) {\n            const siteId = siteIds[i];\n            const pushIfEnabled = enabled => enabled && enabledSites.push(siteId);\n            if (checkAll || !promises.length) {\n                promises.push(\n                    Promise\n                        .resolve(isEnabledFn(siteId, ...args))\n                        .then(pushIfEnabled),\n                );\n            }\n        }\n\n        await CoreUtils.ignoreErrors(this.allPromises(promises));\n\n        if (!checkAll) {\n            // Checking 1 was enough, so it will either return all the sites or none.\n            return enabledSites.length ? siteIds : [];\n        } else {\n            return enabledSites;\n        }\n    }\n\n    /**\n     * Given a float, prints it nicely. Localized floats must not be used in calculations!\n     * Based on Moodle's format_float.\n     *\n     * @param float The float to print.\n     * @returns Locale float.\n     */\n    formatFloat(float: unknown): string {\n        if (float === undefined || float === null || typeof float == 'boolean') {\n            return '';\n        }\n\n        const localeSeparator = Translate.instant('core.decsep');\n\n        const floatString = String(float);\n\n        return floatString.replace('.', localeSeparator);\n    }\n\n    /**\n     * Returns a tree formatted from a plain list.\n     * List has to be sorted by depth to allow this function to work correctly. Errors can be thrown if a child node is\n     * processed before a parent node.\n     *\n     * @param list List to format.\n     * @param parentFieldName Name of the parent field to match with children.\n     * @param idFieldName Name of the children field to match with parent.\n     * @param rootParentId The id of the root.\n     * @param maxDepth Max Depth to convert to tree. Children found will be in the last level of depth.\n     * @returns Array with the formatted tree, children will be on each node under children field.\n     */\n    formatTree<T>(\n        list: T[],\n        parentFieldName: string = 'parent',\n        idFieldName: string = 'id',\n        rootParentId: number = 0,\n        maxDepth: number = 5,\n    ): TreeNode<T>[] {\n        const map = {};\n        const mapDepth = {};\n        const tree: TreeNode<T>[] = [];\n\n        // Create a map first to avoid problems with not sorted.\n        list.forEach((node: TreeNode<T>, index): void => {\n            const id = node[idFieldName];\n\n            if (id === undefined) {\n                this.logger.error(`Node with incorrect ${idFieldName}:${id} found on formatTree`);\n            }\n\n            if (node.children === undefined) {\n                node.children = [];\n            }\n            map[id] = index;\n        });\n\n        list.forEach((node: TreeNode<T>): void => {\n            const id = node[idFieldName];\n            const parent = node[parentFieldName];\n\n            if (id === undefined || parent === undefined) {\n                this.logger.error(`Node with incorrect ${idFieldName}:${id} or ${parentFieldName}:${parent} found on formatTree`);\n            }\n\n            // Use map to look-up the parents.\n            if (parent !== rootParentId) {\n                const parentNode = list[map[parent]] as TreeNode<T>;\n                if (parentNode) {\n                    if (mapDepth[parent] == maxDepth) {\n                        // Reached max level of depth. Proceed with flat order. Find parent object of the current node.\n                        const parentOfParent = parentNode[parentFieldName];\n                        if (parentOfParent) {\n                            // This element will be the child of the node that is two levels up the hierarchy\n                            // (i.e. the child of node.parent.parent).\n                            (list[map[parentOfParent]] as TreeNode<T>).children.push(node);\n                            // Assign depth level to the same depth as the parent (i.e. max depth level).\n                            mapDepth[id] = mapDepth[parent];\n                            // Change the parent to be the one that is two levels up the hierarchy.\n                            node[parentFieldName] = parentOfParent;\n                        } else {\n                            this.logger.error(`Node parent of parent:${parentOfParent} not found on formatTree`);\n                        }\n                    } else {\n                        parentNode.children.push(node);\n                        // Increase the depth level.\n                        mapDepth[id] = mapDepth[parent] + 1;\n                    }\n                } else {\n                    this.logger.error(`Node parent:${parent} not found on formatTree`);\n                }\n            } else {\n                tree.push(node);\n\n                // Root elements are the first elements in the tree structure, therefore have the depth level 1.\n                mapDepth[id] = 1;\n            }\n        });\n\n        return tree;\n    }\n\n    /**\n     * Get country name based on country code.\n     *\n     * @param code Country code (AF, ES, US, ...).\n     * @returns Country name. If the country is not found, return the country code.\n     */\n    getCountryName(code: string): string {\n        const countryKey = 'assets.countries.' + code;\n        const countryName = Translate.instant(countryKey);\n\n        return countryName !== countryKey ? countryName : code;\n    }\n\n    /**\n     * Get list of countries with their code and translated name.\n     *\n     * @returns Promise resolved with the list of countries.\n     */\n    async getCountryList(): Promise<Record<string, string>> {\n        // Get the keys of the countries.\n        const keys = await this.getCountryKeysList();\n\n        // Now get the code and the translated name.\n        const countries: Record<string, string> = {};\n\n        keys.forEach((key) => {\n            if (key.indexOf('assets.countries.') === 0) {\n                const code = key.replace('assets.countries.', '');\n                countries[code] = Translate.instant(key);\n            }\n        });\n\n        return countries;\n    }\n\n    /**\n     * Get list of countries with their code and translated name. Sorted by the name of the country.\n     *\n     * @returns Promise resolved with the list of countries.\n     */\n    async getCountryListSorted(): Promise<CoreCountry[]> {\n        // Get the keys of the countries.\n        const countries = await this.getCountryList();\n\n        // Sort translations.\n        return Object.keys(countries)\n            .sort((a, b) => countries[a].localeCompare(countries[b]))\n            .map((code) => ({ code, name: countries[code] }));\n    }\n\n    /**\n     * Get the list of language keys of the countries.\n     *\n     * @returns Promise resolved with the countries list. Rejected if not translated.\n     */\n    protected async getCountryKeysList(): Promise<string[]> {\n        // It's possible that the current language isn't translated, so try with default language first.\n        const defaultLang = CoreLang.getDefaultLanguage();\n\n        try {\n            return await this.getCountryKeysListForLanguage(defaultLang);\n        } catch {\n            // Not translated, try to use the fallback language.\n            const fallbackLang = CoreLang.getFallbackLanguage();\n\n            if (fallbackLang === defaultLang) {\n                // Same language, just reject.\n                throw new Error('Countries not found.');\n            }\n\n            return this.getCountryKeysListForLanguage(fallbackLang);\n        }\n    }\n\n    /**\n     * Get the list of language keys of the countries, based on the translation table for a certain language.\n     *\n     * @param lang Language to check.\n     * @returns Promise resolved with the countries list. Rejected if not translated.\n     */\n    protected async getCountryKeysListForLanguage(lang: string): Promise<string[]> {\n        // Get the translation table for the language.\n        const table = await CoreLang.getTranslationTable(lang);\n\n        // Gather all the keys for countries,\n        const keys: string[] = [];\n\n        for (const name in table) {\n            if (name.indexOf('assets.countries.') === 0) {\n                keys.push(name);\n            }\n        }\n\n        if (keys.length === 0) {\n            // Not translated, reject.\n            throw new Error('Countries not found.');\n        }\n\n        return keys;\n    }\n\n    /**\n     * Get the mimetype of a file given its URL. It'll try to guess it using the URL, if that fails then it'll\n     * perform a HEAD request to get it. It's done in this order because pluginfile.php can return wrong mimetypes.\n     * This function is in here instead of MimetypeUtils to prevent circular dependencies.\n     *\n     * @param url The URL of the file.\n     * @returns Promise resolved with the mimetype.\n     */\n    async getMimeTypeFromUrl(url: string): Promise<string> {\n        // First check if it can be guessed from the URL.\n        const extension = CoreMimetypeUtils.guessExtensionFromUrl(url);\n        let mimetype = extension && CoreMimetypeUtils.getMimeType(extension);\n\n        if (mimetype) {\n            return mimetype;\n        }\n\n        // Can't be guessed, get the remote mimetype.\n        mimetype = await CoreWS.getRemoteFileMimeType(url);\n\n        return mimetype || '';\n    }\n\n    /**\n     * Get a unique ID for a certain name.\n     *\n     * @param name The name to get the ID for.\n     * @returns Unique ID.\n     */\n    getUniqueId(name: string): number {\n        if (!this.uniqueIds[name]) {\n            this.uniqueIds[name] = 0;\n        }\n\n        return ++this.uniqueIds[name];\n    }\n\n    /**\n     * Check if a file is a FileEntry\n     *\n     * @param file File.\n     * @returns Type guard indicating if the file is a FileEntry.\n     */\n    isFileEntry(file: CoreFileEntry): file is FileEntry {\n        return 'isFile' in file;\n    }\n\n    /**\n     * Check if an unknown value is a FileEntry.\n     *\n     * @param file Object to check.\n     * @returns Type guard indicating if the file is a FileEntry.\n     */\n    valueIsFileEntry(file: unknown): file is FileEntry {\n        // We cannot use instanceof because FileEntry is a type. Check some of the properties.\n        return !!(file && typeof file == 'object' && 'isFile' in file && 'filesystem' in file &&\n            'toInternalURL' in file && 'copyTo' in file);\n    }\n\n    /**\n     * Check if a value is an object.\n     *\n     * @param object Variable.\n     * @returns Type guard indicating if this is an object.\n     */\n    isObject(object: unknown): object is Record<string, unknown> {\n        return typeof object === 'object' && object !== null;\n    }\n\n    /**\n     * Given a list of files, check if there are repeated names.\n     *\n     * @param files List of files.\n     * @returns String with error message if repeated, false if no repeated.\n     */\n    hasRepeatedFilenames(files: CoreFileEntry[]): string | false {\n        if (!files || !files.length) {\n            return false;\n        }\n\n        const names: string[] = [];\n\n        // Check if there are 2 files with the same name.\n        for (let i = 0; i < files.length; i++) {\n            const file = files[i];\n            const name = (this.isFileEntry(file) ? file.name : file.filename) || '';\n\n            if (names.indexOf(name) > -1) {\n                return Translate.instant('core.filenameexist', { $a: name });\n            }\n\n            names.push(name);\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets the index of the first string that matches a regular expression.\n     *\n     * @param array Array to search.\n     * @param regex RegExp to apply to each string.\n     * @returns Index of the first string that matches the RegExp. -1 if not found.\n     */\n    indexOfRegexp(array: string[], regex: RegExp): number {\n        if (!array || !array.length) {\n            return -1;\n        }\n\n        for (let i = 0; i < array.length; i++) {\n            const entry = array[i];\n            const matches = entry.match(regex);\n\n            if (matches && matches.length) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Return true if the param is false (bool), 0 (number) or \"0\" (string).\n     *\n     * @param value Value to check.\n     * @returns Whether the value is false, 0 or \"0\".\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isFalseOrZero(value: any): boolean {\n        return value !== undefined && (value === false || value === 'false' || parseInt(value, 10) === 0);\n    }\n\n    /**\n     * Return true if the param is true (bool), 1 (number) or \"1\" (string).\n     *\n     * @param value Value to check.\n     * @returns Whether the value is true, 1 or \"1\".\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isTrueOrOne(value: any): boolean {\n        return value !== undefined && (value === true || value === 'true' || parseInt(value, 10) === 1);\n    }\n\n    /**\n     * Given an error returned by a WS call, check if the error is generated by the app or it has been returned by the WebService.\n     *\n     * @param error Error to check.\n     * @returns Whether the error was returned by the WebService.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isWebServiceError(error: any): boolean {\n        return error && (\n            error.warningcode !== undefined ||\n            (\n                error.errorcode !== undefined && error.errorcode != 'userdeleted' && error.errorcode != 'upgraderunning' &&\n                error.errorcode != 'forcepasswordchangenotice' && error.errorcode != 'usernotfullysetup' &&\n                error.errorcode != 'sitepolicynotagreed' && error.errorcode != 'sitemaintenance' &&\n                error.errorcode != 'wsaccessusersuspended' && error.errorcode != 'wsaccessuserdeleted' &&\n                !this.isExpiredTokenError(error)\n            ) ||\n            error.status && error.status >= 400 // CoreHttpError, assume status 400 and above are like WebService errors.\n        );\n    }\n\n    /**\n     * Given an error returned by a WS call, check if the error is a token expired error.\n     *\n     * @param error Error to check.\n     * @returns Whether the error is a token expired error.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isExpiredTokenError(error: any): boolean {\n        return error.errorcode === 'invalidtoken' ||\n            (error.errorcode === 'accessexception' && error.message.includes('Invalid token - token expired'));\n    }\n\n    /**\n     * Given a list (e.g. a,b,c,d,e) this function returns an array of 1->a, 2->b, 3->c etc.\n     * Taken from make_menu_from_list on moodlelib.php (not the same but similar).\n     *\n     * @param list The string to explode into array bits\n     * @param defaultLabel Element that will become default option, if not defined, it won't be added.\n     * @param separator The separator used within the list string. Default ','.\n     * @param defaultValue Element that will become default option value. Default 0.\n     * @returns The now assembled array\n     */\n    makeMenuFromList<T>(\n        list: string,\n        defaultLabel?: string,\n        separator: string = ',',\n        defaultValue?: T,\n    ): CoreMenuItem<T>[] {\n        // Split and format the list.\n        const split = list.split(separator).map((label, index) => ({\n            label: label.trim(),\n            value: index + 1,\n        })) as { label: string; value: T | number }[];\n\n        if (defaultLabel) {\n            split.unshift({\n                label: defaultLabel,\n                value: defaultValue || 0,\n            });\n        }\n\n        return split;\n    }\n\n    /**\n     * Merge two arrays, removing duplicate values.\n     *\n     * @param array1 The first array.\n     * @param array2 The second array.\n     * @param [key] Key of the property that must be unique. If not specified, the whole entry.\n     * @returns Merged array.\n     */\n    mergeArraysWithoutDuplicates<T>(array1: T[], array2: T[], key?: string): T[] {\n        return this.uniqueArray(array1.concat(array2), key) as T[];\n    }\n\n    /**\n     * Check if a value isn't null or undefined.\n     *\n     * @param value Value to check.\n     * @returns True if not null and not undefined.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    notNullOrUndefined(value: any): boolean {\n        return value !== undefined && value !== null;\n    }\n\n    /**\n     * Open a file using platform specific method.\n     *\n     * @param path The local path of the file to be open.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async openFile(path: string, options: CoreUtilsOpenFileOptions = {}): Promise<void> {\n        // Convert the path to a native path if needed.\n        path = CoreFile.unconvertFileSrc(path);\n\n        const extension = CoreMimetypeUtils.getFileExtension(path);\n        const mimetype = extension && CoreMimetypeUtils.getMimeType(extension);\n\n        if (mimetype == 'text/html' && CorePlatform.isAndroid()) {\n            // Open HTML local files in InAppBrowser, in system browser some embedded files aren't loaded.\n            this.openInApp(path);\n\n            return;\n        } else if (extension === 'apk' && CorePlatform.isAndroid()) {\n            const url = await CoreUtils.ignoreErrors(\n                CoreFilepool.getFileUrlByPath(CoreSites.getCurrentSiteId(), CoreFile.removeBasePath(path)),\n            );\n\n            // @todo MOBILE-4167: Handle urls with expired tokens.\n\n            throw new CoreErrorWithOptions(\n                Translate.instant('core.cannotinstallapkinfo'),\n                Translate.instant('core.cannotinstallapk'),\n                url\n                    ? [\n                        {\n                            text: Translate.instant('core.openinbrowser'),\n                            handler: () => this.openInBrowser(url),\n                        },\n                        {\n                            text: Translate.instant('core.cancel'),\n                            role: 'cancel',\n                        },\n                    ]\n                    : undefined,\n            );\n        }\n\n        // Path needs to be decoded, the file won't be opened if the path has %20 instead of spaces and so.\n        try {\n            path = decodeURIComponent(path);\n        } catch (ex) {\n            // Error, use the original path.\n        }\n\n        const openFile = async (mimetype?: string) => {\n            if (this.shouldOpenWithDialog(options)) {\n                await FileOpener.showOpenWithDialog(path, mimetype || '');\n            } else {\n                await FileOpener.open(path, mimetype || '');\n            }\n        };\n\n        try {\n            try {\n                await openFile(mimetype);\n            } catch (error) {\n                if (!extension || !error || Number(error.status) !== 9) {\n                    throw error;\n                }\n\n                // Cannot open mimetype. Check if there is a deprecated mimetype for the extension.\n                const deprecatedMimetype = CoreMimetypeUtils.getDeprecatedMimeType(extension);\n                if (!deprecatedMimetype || deprecatedMimetype === mimetype) {\n                    throw error;\n                }\n\n                await openFile(deprecatedMimetype);\n            }\n        } catch (error) {\n            this.logger.error('Error opening file ' + path + ' with mimetype ' + mimetype);\n            this.logger.error('Error: ', JSON.stringify(error));\n\n            if (!extension || extension.indexOf('/') > -1 || extension.indexOf('\\\\') > -1) {\n                // Extension not found.\n                throw new Error(Translate.instant('core.erroropenfilenoextension'));\n            }\n\n            throw new Error(Translate.instant('core.erroropenfilenoapp'));\n        }\n    }\n\n    /**\n     * Open a URL using InAppBrowser.\n     * Do not use for files, refer to {@link CoreUtilsProvider.openFile}.\n     *\n     * @param url The URL to open.\n     * @param options Override default options passed to InAppBrowser.\n     * @returns The opened window.\n     */\n    openInApp(url: string, options?: CoreUtilsOpenInAppOptions): InAppBrowserObject {\n        options = options || {};\n        options.usewkwebview = 'yes'; // Force WKWebView in iOS.\n        options.enableViewPortScale = options.enableViewPortScale ?? 'yes'; // Enable zoom on iOS by default.\n        options.allowInlineMediaPlayback = options.allowInlineMediaPlayback ?? 'yes'; // Allow playing inline videos in iOS.\n\n        if (!options.location && CorePlatform.isIOS() && url.indexOf('file://') === 0) {\n            // The URL uses file protocol, don't show it on iOS.\n            // In Android we keep it because otherwise we lose the whole toolbar.\n            options.location = 'no';\n        }\n\n        this.setInAppBrowserToolbarColors(options);\n\n        this.iabInstance?.close(); // Close window if there is one already open, only allow one.\n\n        this.iabInstance = InAppBrowser.create(url, '_blank', options);\n\n        if (CorePlatform.isMobile()) {\n            const loadStartUrls: string[] = [];\n\n            const loadStartSubscription = this.iabInstance.on('loadstart').subscribe((event) => {\n                NgZone.run(() => {\n                    // Store the last loaded URLs (max 10).\n                    loadStartUrls.push(event.url);\n                    if (loadStartUrls.length > 10) {\n                        loadStartUrls.shift();\n                    }\n\n                    CoreEvents.trigger(CoreEvents.IAB_LOAD_START, event);\n                });\n            });\n\n            const loadStopSubscription = this.iabInstance.on('loadstop').subscribe((event) => {\n                NgZone.run(() => {\n                    CoreEvents.trigger(CoreEvents.IAB_LOAD_STOP, event);\n                });\n            });\n\n            const messageSubscription = this.iabInstance.on('message').subscribe((event) => {\n                NgZone.run(() => {\n                    CoreEvents.trigger(CoreEvents.IAB_MESSAGE, event.data);\n                });\n            });\n\n            const exitSubscription = this.iabInstance.on('exit').subscribe((event) => {\n                NgZone.run(() => {\n                    loadStartSubscription.unsubscribe();\n                    loadStopSubscription.unsubscribe();\n                    messageSubscription.unsubscribe();\n                    exitSubscription.unsubscribe();\n\n                    this.iabInstance = undefined;\n                    CoreEvents.trigger(CoreEvents.IAB_EXIT, event);\n                });\n            });\n        }\n\n        CoreAnalytics.logEvent({\n            type: CoreAnalyticsEventType.OPEN_LINK,\n            link: CoreUrlUtils.unfixPluginfileURL(options.originalUrl ?? url),\n        });\n\n        return this.iabInstance;\n    }\n\n    /**\n     * Given some IAB options, set the toolbar colors properties to the right values.\n     *\n     * @param options Options to change.\n     * @returns Changed options.\n     */\n    protected setInAppBrowserToolbarColors(options: InAppBrowserOptions): InAppBrowserOptions {\n        if (options.toolbarcolor) {\n            // Color already set.\n            return options;\n        }\n\n        // Color not set. Check if it needs to be changed automatically.\n        let bgColor: string | undefined;\n        let textColor: string | undefined;\n\n        if (CoreConstants.CONFIG.iabToolbarColors === 'auto') {\n            bgColor = CoreColors.getToolbarBackgroundColor();\n        } else if (CoreConstants.CONFIG.iabToolbarColors && typeof CoreConstants.CONFIG.iabToolbarColors === 'object') {\n            bgColor = CoreConstants.CONFIG.iabToolbarColors.background;\n            textColor = CoreConstants.CONFIG.iabToolbarColors.text;\n        }\n\n        if (!bgColor) {\n            // Use default color. In iOS, use black background color since the default is transparent and doesn't look good.\n            options.locationcolor = '#000000';\n\n            return options;\n        }\n\n        if (!textColor) {\n            textColor = CoreColors.isWhiteContrastingBetter(bgColor) ? '#ffffff' : '#000000';\n        }\n\n        options.toolbarcolor = bgColor;\n        options.closebuttoncolor = textColor;\n        options.navigationbuttoncolor = textColor;\n        options.locationcolor = bgColor;\n        options.locationtextcolor = textColor;\n\n        return options;\n    }\n\n    /**\n     * Open a URL using a browser.\n     * Do not use for files, refer to {@link CoreUtilsProvider.openFile}.\n     *\n     * @param url The URL to open.\n     * @param options Options.\n     */\n    async openInBrowser(url: string, options: CoreUtilsOpenInBrowserOptions = {}): Promise<void> {\n        // eslint-disable-next-line deprecation/deprecation\n        const originaUrl = CoreUrlUtils.unfixPluginfileURL(options.originalUrl ?? options.browserWarningUrl ?? url);\n        if (options.showBrowserWarning || options.showBrowserWarning === undefined) {\n            try {\n                await CoreWindow.confirmOpenBrowserIfNeeded(originaUrl);\n            } catch (error) {\n                return; // Cancelled, stop.\n            }\n        }\n\n        CoreAnalytics.logEvent({\n            type: CoreAnalyticsEventType.OPEN_LINK,\n            link: originaUrl,\n        });\n\n        window.open(url, '_system');\n    }\n\n    /**\n     * Open an online file using platform specific method.\n     * Specially useful for audio and video since they can be streamed.\n     *\n     * @param url The URL of the file.\n     * @returns Promise resolved when opened.\n     */\n    async openOnlineFile(url: string): Promise<void> {\n        if (CorePlatform.isAndroid()) {\n            // In Android we need the mimetype to open it.\n            const mimetype = await this.ignoreErrors(this.getMimeTypeFromUrl(url));\n\n            if (!mimetype) {\n                // Couldn't retrieve mimetype. Return error.\n                throw new Error(Translate.instant('core.erroropenfilenoextension'));\n            }\n\n            const options = {\n                action: WebIntent.ACTION_VIEW,\n                url,\n                type: mimetype,\n            };\n\n            try {\n                await WebIntent.startActivity(options);\n\n                CoreAnalytics.logEvent({\n                    type: CoreAnalyticsEventType.OPEN_LINK,\n                    link: CoreUrlUtils.unfixPluginfileURL(url),\n                });\n            } catch (error) {\n                this.logger.error('Error opening online file ' + url + ' with mimetype ' + mimetype);\n                this.logger.error('Error: ', JSON.stringify(error));\n\n                throw new Error(Translate.instant('core.erroropenfilenoapp'));\n            }\n        }\n\n        // In the rest of platforms we need to open them in InAppBrowser.\n        this.openInApp(url);\n    }\n\n    /**\n     * Converts an object into an array, losing the keys.\n     *\n     * @param obj Object to convert.\n     * @returns Array with the values of the object but losing the keys.\n     */\n    objectToArray<T>(obj: Record<string, T>): T[] {\n        return Object.keys(obj).map((key) => obj[key]);\n    }\n\n    /**\n     * Converts an object into an array of objects, where each entry is an object containing\n     * the key and value of the original object.\n     * For example, it can convert {size: 2} into [{name: 'size', value: 2}].\n     *\n     * @param obj Object to convert.\n     * @param keyName Name of the properties where to store the keys.\n     * @param valueName Name of the properties where to store the values.\n     * @param sortByKey True to sort keys alphabetically, false otherwise. Has priority over sortByValue.\n     * @param sortByValue True to sort values alphabetically, false otherwise.\n     * @returns Array of objects with the name & value of each property.\n     */\n    objectToArrayOfObjects<\n        A extends Record<string,unknown> = Record<string, unknown>,\n        O extends Record<string, unknown> = Record<string, unknown>\n    >(\n        obj: O,\n        keyName: string,\n        valueName: string,\n        sortByKey?: boolean,\n        sortByValue?: boolean,\n    ): A[] {\n        // Get the entries from an object or primitive value.\n        const getEntries = (elKey: string, value: unknown): Record<string, unknown>[] | unknown => {\n            if (value === undefined || value == null) {\n                // Filter undefined and null values.\n                return;\n            } else if (this.isObject(value)) {\n                // It's an object, return at least an entry for each property.\n                const keys = Object.keys(value);\n                let entries: unknown[] = [];\n\n                keys.forEach((key) => {\n                    const newElKey = elKey ? elKey + '[' + key + ']' : key;\n                    const subEntries = getEntries(newElKey, value[key]);\n\n                    if (subEntries) {\n                        entries = entries.concat(subEntries);\n                    }\n                });\n\n                return entries;\n            } else {\n                // Not an object, return a single entry.\n                const entry = {};\n                entry[keyName] = elKey;\n                entry[valueName] = value;\n\n                return entry;\n            }\n        };\n\n        if (!obj) {\n            return [];\n        }\n\n        // \"obj\" will always be an object, so \"entries\" will always be an array.\n        const entries = getEntries('', obj) as A[];\n        if (sortByKey || sortByValue) {\n            return entries.sort((a, b) => {\n                if (sortByKey) {\n                    return (a[keyName] as number) >= (b[keyName] as number) ? 1 : -1;\n                } else {\n                    return (a[valueName] as number) >= (b[valueName] as number) ? 1 : -1;\n                }\n            });\n        }\n\n        return entries;\n    }\n\n    /**\n     * Converts an array of objects into an object with key and value. The opposite of objectToArrayOfObjects.\n     * For example, it can convert [{name: 'size', value: 2}] into {size: 2}.\n     *\n     * @param objects List of objects to convert.\n     * @param keyName Name of the properties where the keys are stored.\n     * @param valueName Name of the properties where the values are stored.\n     * @param keyPrefix Key prefix if neededs to delete it.\n     * @returns Object.\n     */\n    objectToKeyValueMap<T = unknown>(\n        objects: Record<string, unknown>[],\n        keyName: string,\n        valueName: string,\n        keyPrefix?: string,\n    ): {[name: string]: T} {\n        const prefixSubstr = keyPrefix ? keyPrefix.length : 0;\n        const mapped = {};\n        objects.forEach((item) => {\n            const keyValue = item[keyName] as string;\n            const key = prefixSubstr > 0 ? keyValue.substring(prefixSubstr) : keyValue;\n            mapped[key] = item[valueName];\n        });\n\n        return mapped;\n    }\n\n    /**\n     * Convert an object to a format of GET param. E.g.: {a: 1, b: 2} -> a=1&b=2\n     *\n     * @param object Object to convert.\n     * @param removeEmpty Whether to remove params whose value is null/undefined.\n     * @returns GET params.\n     */\n    objectToGetParams(object: Record<string, unknown>, removeEmpty: boolean = true): string {\n        // First of all, flatten the object so all properties are in the first level.\n        const flattened = this.flattenObject(object);\n        let result = '';\n        let joinChar = '';\n\n        for (const name in flattened) {\n            let value = flattened[name];\n\n            if (removeEmpty && (value === null || value === undefined)) {\n                continue;\n            }\n\n            if (typeof value == 'boolean') {\n                value = value ? 1 : 0;\n            }\n\n            result += joinChar + name + '=' + value;\n            joinChar = '&';\n        }\n\n        return result;\n    }\n\n    /**\n     * Add a prefix to all the keys in an object.\n     *\n     * @param data Object.\n     * @param prefix Prefix to add.\n     * @returns Prefixed object.\n     */\n    prefixKeys(data: Record<string, unknown>, prefix: string): Record<string, unknown> {\n        const newObj = {};\n        const keys = Object.keys(data);\n\n        keys.forEach((key) => {\n            newObj[prefix + key] = data[key];\n        });\n\n        return newObj;\n    }\n\n    /**\n     * Function to enumerate enum keys.\n     *\n     * @param enumeration Enumeration object.\n     * @returns Keys of the enumeration.\n     */\n    enumKeys<O extends object, K extends keyof O = keyof O>(enumeration: O): K[] {\n        return Object.keys(enumeration).filter(k => Number.isNaN(+k)) as K[];\n    }\n\n    /**\n     * Create a deferred promise that can be resolved or rejected explicitly.\n     *\n     * @returns The deferred promise.\n     * @deprecated since 4.1. Use CorePromisedValue instead.\n     */\n    promiseDefer<T>(): CorePromisedValue<T> {\n        return new CorePromisedValue<T>();\n    }\n\n    /**\n     * Given a promise, returns true if it's rejected or false if it's resolved.\n     *\n     * @param promise Promise to check\n     * @returns Promise resolved with boolean: true if the promise is rejected or false if it's resolved.\n     */\n    async promiseFails(promise: Promise<unknown>): Promise<boolean> {\n        try {\n            await promise;\n\n            return false;\n        } catch {\n            return true;\n        }\n    }\n\n    /**\n     * Given a promise, returns true if it's resolved or false if it's rejected.\n     *\n     * @param promise Promise to check\n     * @returns Promise resolved with boolean: true if the promise it's resolved or false if it's rejected.\n     */\n    async promiseWorks(promise: Promise<unknown>): Promise<boolean> {\n        try {\n            await promise;\n\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see whether two arrays or objects have the same value at a particular key.\n     * Missing values are replaced by '', and the values are compared with ===.\n     * Booleans and numbers are cast to string before comparing.\n     *\n     * @param obj1 The first object or array.\n     * @param obj2 The second object or array.\n     * @param key Key to check.\n     * @returns Whether the two objects/arrays have the same value (or lack of one) for a given key.\n     */\n    sameAtKeyMissingIsBlank(\n        obj1: Record<string, unknown> | unknown[],\n        obj2: Record<string, unknown> | unknown[],\n        key: string,\n    ): boolean {\n        let value1 = obj1[key] !== undefined ? obj1[key] : '';\n        let value2 = obj2[key] !== undefined ? obj2[key] : '';\n\n        if (typeof value1 == 'number' || typeof value1 == 'boolean') {\n            value1 = '' + value1;\n        }\n        if (typeof value2 == 'number' || typeof value2 == 'boolean') {\n            value2 = '' + value2;\n        }\n\n        return value1 === value2;\n    }\n\n    /**\n     * Stringify an object, sorting the properties. It doesn't sort arrays, only object properties. E.g.:\n     * {b: 2, a: 1} -> '{\"a\":1,\"b\":2}'\n     *\n     * @param obj Object to stringify.\n     * @returns Stringified object.\n     */\n    sortAndStringify(obj: Record<string, unknown>): string {\n        return JSON.stringify(this.sortProperties(obj));\n    }\n\n    /**\n     * Given an object, sort its properties and the properties of all the nested objects.\n     *\n     * @param obj The object to sort. If it isn't an object, the original value will be returned.\n     * @returns Sorted object.\n     */\n    sortProperties<T>(obj: T): T {\n        if (obj != null && typeof obj == 'object' && !Array.isArray(obj)) {\n            // It's an object, sort it.\n            return Object.keys(obj).sort().reduce((accumulator, key) => {\n                // Always call sort with the value. If it isn't an object, the original value will be returned.\n                accumulator[key] = this.sortProperties(obj[key]);\n\n                return accumulator;\n            }, {} as T);\n        } else {\n            return obj;\n        }\n    }\n\n    /**\n     * Given an object, sort its values. Values need to be primitive values, it cannot have subobjects.\n     *\n     * @param obj The object to sort. If it isn't an object, the original value will be returned.\n     * @returns Sorted object.\n     */\n    sortValues<T>(obj: T): T {\n        if (typeof obj == 'object' && !Array.isArray(obj)) {\n            // It's an object, sort it. Convert it to an array to be able to sort it and then convert it back to object.\n            const array = this.objectToArrayOfObjects(obj as Record<string, unknown>, 'name', 'value', false, true);\n\n            return this.objectToKeyValueMap(array, 'name', 'value') as unknown as T;\n        } else {\n            return obj;\n        }\n    }\n\n    /**\n     * Set a timeout to a Promise. If the time passes before the Promise is resolved or rejected, it will be automatically\n     * rejected.\n     *\n     * @param promise The promise to timeout.\n     * @param time Number of milliseconds of the timeout.\n     * @returns Promise with the timeout.\n     */\n    timeoutPromise<T>(promise: Promise<T>, time: number): Promise<T> {\n        return new Promise((resolve, reject): void => {\n            let timedOut = false;\n            const resolveBeforeTimeout = (value: T) => {\n                if (timedOut) {\n                    return;\n                }\n                resolve(value);\n            };\n            const timeout = setTimeout(\n                () => {\n                    reject({ timeout: true });\n                    timedOut = true;\n                },\n                time,\n            );\n\n            promise\n                .then(resolveBeforeTimeout)\n                .catch(reject)\n                .finally(() => clearTimeout(timeout));\n        });\n    }\n\n    /**\n     * Converts locale specific floating point/comma number back to a standard float number.\n     * Do NOT try to do any math operations before this conversion on any user submitted floats!\n     * Based on Moodle's unformat_float function.\n     *\n     * @param localeFloat Locale aware float representation.\n     * @param strict If true, then check the input and return false if it is not a valid number.\n     * @returns False if bad format, empty string if empty value or the parsed float if not.\n     */\n    unformatFloat(localeFloat: string | number | null | undefined, strict?: boolean): false | '' | number {\n        // Bad format on input type number.\n        if (localeFloat === undefined) {\n            return false;\n        }\n\n        // Empty (but not zero).\n        if (localeFloat == null) {\n            return '';\n        }\n\n        // Convert float to string.\n        localeFloat = String(localeFloat);\n        localeFloat = localeFloat.trim();\n\n        if (localeFloat == '') {\n            return '';\n        }\n\n        localeFloat = localeFloat.replace(' ', ''); // No spaces - those might be used as thousand separators.\n        localeFloat = localeFloat.replace(Translate.instant('core.decsep'), '.');\n\n        // Use Number instead of parseFloat because the latter truncates the number when it finds \",\", while Number returns NaN.\n        // If the number still has \",\" then it means it's not a valid separator.\n        const parsedFloat = Number(localeFloat);\n\n        // Bad format.\n        if (strict && (!isFinite(parsedFloat) || isNaN(parsedFloat))) {\n            return false;\n        }\n\n        return parsedFloat;\n    }\n\n    /**\n     * Return an array without duplicate values.\n     *\n     * @param array The array to treat.\n     * @param [key] Key of the property that must be unique. If not specified, the whole entry.\n     * @returns Array without duplicate values.\n     */\n    uniqueArray<T>(array: T[], key?: string): T[] {\n        const unique = {}; // Use an object to make it faster to check if it's duplicate.\n\n        return array.filter(entry => {\n            const value = key ? entry[key] : entry;\n\n            if (value in unique) {\n                return false;\n            }\n\n            unique[value] = true;\n\n            return true;\n        });\n    }\n\n    /**\n     * Debounce a function so consecutive calls are ignored until a certain time has passed since the last call.\n     *\n     * @param fn Function to debounce.\n     * @param delay Time that must pass until the function is called.\n     * @returns Debounced function.\n     */\n    debounce<T extends unknown[]>(fn: (...args: T) => unknown, delay: number): (...args: T) => void {\n        let timeoutID: number;\n\n        const debounced = (...args: T): void => {\n            clearTimeout(timeoutID);\n\n            timeoutID = window.setTimeout(() => fn.apply(null, args), delay);\n        };\n\n        return debounced;\n    }\n\n    /**\n     * Throttle a function so consecutive calls are ignored until a certain time has passed since the last executed call.\n     *\n     * @param fn Function to throttle.\n     * @param duration Time that must pass until the function is called.\n     * @returns Throttled function.\n     */\n    throttle<T extends unknown[]>(fn: (...args: T) => unknown, duration: number): (...args: T) => void {\n        let shouldWait = false;\n\n        const throttled = (...args: T): void => {\n            if (!shouldWait) {\n                fn.apply(null, args);\n\n                shouldWait = true;\n\n                setTimeout(() => {\n                    shouldWait = false;\n                }, duration);\n            }\n        };\n\n        return throttled;\n    }\n\n    /**\n     * Check whether the app can scan QR codes.\n     *\n     * @returns Whether the app can scan QR codes.\n     */\n    canScanQR(): boolean {\n        return CorePlatform.isMobile();\n    }\n\n    /**\n     * Open a modal to scan a QR code.\n     *\n     * @param title Title of the modal. Defaults to \"QR reader\".\n     * @returns Promise resolved with the captured text or undefined if cancelled or error.\n     */\n    async scanQR(title?: string): Promise<string | undefined> {\n        return CoreDomUtils.openModal<string>({\n            component: CoreViewerQRScannerComponent,\n            cssClass: 'core-modal-fullscreen',\n            componentProps: {\n                title,\n            },\n        });\n    }\n\n    /**\n     * Start scanning for a QR code.\n     *\n     * @returns Promise resolved with the QR string, rejected if error or cancelled.\n     */\n    async startScanQR(): Promise<string | undefined> {\n        if (!CorePlatform.isMobile()) {\n            return Promise.reject('QRScanner isn\\'t available in browser.');\n        }\n\n        // Ask the user for permission to use the camera.\n        // The scan method also does this, but since it returns an Observable we wouldn't be able to detect if the user denied.\n        try {\n            const status = await QRScanner.prepare();\n\n            if (!status.authorized) {\n                // No access to the camera, reject. In android this shouldn't happen, denying access passes through catch.\n                throw new Error('The user denied camera access.');\n            }\n\n            if (this.qrScanData && this.qrScanData.deferred) {\n                // Already scanning.\n                return this.qrScanData.deferred;\n            }\n\n            // Start scanning.\n            this.qrScanData = {\n                deferred: new CorePromisedValue(),\n\n                // When text is received, stop scanning and return the text.\n                observable: QRScanner.scan().subscribe(text => this.stopScanQR(text, false)),\n            };\n\n            // Show the camera.\n            try {\n                await QRScanner.show();\n\n                document.body.classList.add('core-scanning-qr');\n\n                // Set color-scheme to 'normal', otherwise the camera isn't seen in Android.\n                const colorSchemeMeta = document.querySelector('meta[name=\"color-scheme\"]');\n                if (colorSchemeMeta) {\n                    this.initialColorSchemeContent = colorSchemeMeta.getAttribute('content') || this.initialColorSchemeContent;\n                    colorSchemeMeta.setAttribute('content', 'normal');\n                }\n\n                return this.qrScanData.deferred;\n            } catch (e) {\n                this.stopScanQR(e, true);\n\n                throw e;\n            }\n        } catch (error) {\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            error.message = error.message || (error as { _message?: string })._message;\n\n            throw error;\n        }\n    }\n\n    /**\n     * Stop scanning for QR code. If no param is provided, the app will consider the user cancelled.\n     *\n     * @param data If success, the text of the QR code. If error, the error object or message. Undefined for cancelled.\n     * @param error True if the data belongs to an error, false otherwise.\n     */\n    stopScanQR(data?: string | Error, error?: boolean): void {\n        if (!this.qrScanData) {\n            // Not scanning.\n            return;\n        }\n\n        // Hide camera preview.\n        document.body.classList.remove('core-scanning-qr');\n\n        // Set color-scheme to the initial value.\n        document.querySelector('meta[name=\"color-scheme\"]')?.setAttribute('content', this.initialColorSchemeContent);\n\n        QRScanner.hide();\n        QRScanner.destroy();\n\n        this.qrScanData.observable.unsubscribe(); // Stop scanning.\n\n        if (error) {\n            this.qrScanData.deferred.reject(typeof data === 'string' ? new Error(data) : data);\n        } else if (data !== undefined) {\n            this.qrScanData.deferred.resolve(data as string);\n        } else {\n            this.qrScanData.deferred.reject(new CoreCanceledError());\n        }\n\n        delete this.qrScanData;\n    }\n\n    /**\n     * Ignore errors from a promise.\n     *\n     * @param promise Promise to ignore errors.\n     * @param fallback Value to return if the promise is rejected.\n     * @returns Promise with ignored errors, resolving to the fallback result if provided.\n     */\n    async ignoreErrors<Result>(promise?: Promise<Result>): Promise<Result | undefined>;\n    async ignoreErrors<Result, Fallback>(promise: Promise<Result>, fallback: Fallback): Promise<Result | Fallback>;\n    async ignoreErrors<Result, Fallback>(promise?: Promise<Result>, fallback?: Fallback): Promise<Result | Fallback | undefined> {\n        try {\n            const result = await promise;\n\n            return result;\n        } catch {\n            // Ignore errors.\n            return fallback;\n        }\n    }\n\n    /**\n     * Wait some time.\n     *\n     * @param milliseconds Number of milliseconds to wait.\n     * @returns Promise resolved after the time has passed.\n     */\n    wait(milliseconds: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, milliseconds));\n    }\n\n    /**\n     * Wait until a given condition is met.\n     *\n     * @param condition Condition.\n     * @returns Cancellable promise.\n     */\n    waitFor(condition: () => boolean, interval: number = 50): CoreCancellablePromise<void> {\n        if (condition()) {\n            return CoreCancellablePromise.resolve();\n        }\n\n        let intervalId: number | undefined;\n\n        return new CoreCancellablePromise<void>(\n            async (resolve) => {\n                intervalId = window.setInterval(() => {\n                    if (!condition()) {\n                        return;\n                    }\n\n                    resolve();\n                    window.clearInterval(intervalId);\n                }, interval);\n            },\n            () => window.clearInterval(intervalId),\n        );\n    }\n\n    /**\n     * Wait until the next tick.\n     *\n     * @returns Promise resolved when tick has been done.\n     */\n    nextTick(): Promise<void> {\n        return this.wait(0);\n    }\n\n    /**\n     * Wait until several next ticks.\n     */\n    async nextTicks(numTicks = 0): Promise<void> {\n        for (let i = 0; i < numTicks; i++) {\n            await this.wait(0);\n        }\n    }\n\n    /**\n     * Given some options, check if a file should be opened with showOpenWithDialog.\n     *\n     * @param options Options.\n     * @returns Boolean.\n     */\n    shouldOpenWithDialog(options: CoreUtilsOpenFileOptions = {}): boolean {\n        const openFileAction = options.iOSOpenFileAction ?? CoreConstants.CONFIG.iOSDefaultOpenFileAction;\n\n        return CorePlatform.isIOS() && openFileAction == OpenFileAction.OPEN_WITH;\n    }\n\n}\n\nexport const CoreUtils = makeSingleton(CoreUtilsProvider);\n\n/**\n * Data for each entry of executeOrderedPromises.\n */\nexport type OrderedPromiseData = {\n    /**\n     * Function to execute.\n     */\n    function: () => Promise<unknown>;\n\n    /**\n     * Whether the promise should block the following one.\n     */\n    blocking?: boolean;\n};\n\n/**\n * Data about a country.\n */\nexport type CoreCountry = {\n    code: string;\n    name: string;\n};\n\n/**\n * Menu item.\n */\nexport type CoreMenuItem<T = number> = {\n    label: string;\n    value: T | number;\n};\n\n/**\n * Options for opening a file.\n */\nexport type CoreUtilsOpenFileOptions = {\n    iOSOpenFileAction?: OpenFileAction; // Action to do when opening a file.\n};\n\n/**\n * Options for opening in browser.\n */\nexport type CoreUtilsOpenInBrowserOptions = {\n    showBrowserWarning?: boolean; // Whether to display a warning before opening in browser. Defaults to true.\n    originalUrl?: string; // Original URL to open (in case the URL was treated, e.g. to add a token or an auto-login).\n    /**\n     * @deprecated since 4.3. Use originalUrl instead.\n     */\n    browserWarningUrl?: string;\n};\n\n/**\n * Options for opening in InAppBrowser.\n */\nexport type CoreUtilsOpenInAppOptions = InAppBrowserOptions & {\n    originalUrl?: string; // Original URL to open (in case the URL was treated, e.g. to add a token or an auto-login).\n};\n\n/**\n * Possible default picker actions.\n */\nexport enum OpenFileAction {\n    OPEN = 'open',\n    OPEN_WITH = 'open-with',\n}\n"],"mappings":";;AAkBA,SAASA,UAAU,QAAQ,oBAAoB;AAC/C,SAASC,QAAQ,QAAQ,gBAAgB;AACzC,SAASC,QAAQ,QAAQ,gBAAgB;AACzC,SAASC,MAAM,QAAQ,cAAc;AACrC,SAASC,YAAY,QAAQ,qBAAqB;AAClD,SAASC,iBAAiB,QAAQ,0BAA0B;AAC5D,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,aAAa,EAAEC,SAAS,EAAEC,YAAY,EAAEC,UAAU,EAAEC,SAAS,EAAEC,SAAS,EAAEC,MAAM,QAAQ,aAAa;AAC9G,SAASC,UAAU,QAAQ,oBAAoB;AAC/C,SAASC,4BAA4B,QAAQ,mDAAmD;AAChG,SAASC,iBAAiB,QAAQ,+BAA+B;AAEjE,SAASC,aAAa,QAAQ,kBAAkB;AAChD,SAASC,UAAU,QAAQ,oBAAoB;AAC/C,SAASC,UAAU,QAAQ,oBAAoB;AAC/C,SAASC,iBAAiB,QAAQ,yBAAyB;AAC3D,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,oBAAoB,QAAQ,kCAAkC;AACvE,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,sBAAsB,QAAQ,8BAA8B;AACrE,SAASC,aAAa,EAAEC,sBAAsB,QAAQ,qBAAqB;AAC3E,SAASC,YAAY,QAAQ,OAAO;AACpC,SAASC,SAAS,QAAQ,0BAA0B;;AAIpD;;;AAIA,OAAM,MAAOC,iBAAiB;EAU1BC,YAAA;IARmB,KAAAC,UAAU,GAAG,CAAC,oBAAoB,EAAE,yBAAyB,EAAE,wBAAwB,CAAC;IAIjG,KAAAC,SAAS,GAA6B,EAAE;IAExC,KAAAC,yBAAyB,GAAG,YAAY;IAG9C,IAAI,CAACC,MAAM,GAAGrB,UAAU,CAACsB,WAAW,CAAC,mBAAmB,CAAC;EAC7D;EAEA;;;;;;;EAOAC,yBAAyBA,CAACC,KAAqB,EAAEC,YAAqB;IAClE,MAAMC,YAAY,GAAGlC,aAAa,CAACmC,wBAAwB,CAACH,KAAK,CAAC,IAAIC,YAAY,IAAI,EAAE;IAExF,IAAI,IAAI,CAACG,iBAAiB,CAACJ,KAAK,CAAC,EAAE;MAC/B,OAAOE,YAAY;;IAGvB;IACA,OAAOA,YAAY,GAAG,UAAU,GAAG5B,SAAS,CAAC+B,OAAO,CAAC,iCAAiC,CAAC;EAC3F;EAEA;;;;;;EAMMC,WAAWA,CAACC,QAAmB;IAAA,OAAAC,iBAAA;MACjC,IAAI,CAACD,QAAQ,IAAI,CAACA,QAAQ,CAACE,MAAM,EAAE;QAC/B;;MAGJ,MAAMC,eAAe;QAAA,IAAAC,IAAA,GAAAH,iBAAA,CAAG,WAAOI,OAAgB,EAA2B;UACtE,IAAI;YACA,MAAMA,OAAO;WAChB,CAAC,OAAOZ,KAAK,EAAE;YACZ,OAAOA,KAAK;;QAEpB,CAAC;QAAA,gBANKU,eAAeA,CAAAG,EAAA;UAAA,OAAAF,IAAA,CAAAG,KAAA,OAAAC,SAAA;QAAA;MAAA,GAMpB;MAED,MAAMC,MAAM,SAASC,OAAO,CAACC,GAAG,CAACX,QAAQ,CAACY,GAAG,CAACT,eAAe,CAAC,CAAC;MAC/D,MAAMV,KAAK,GAAGgB,MAAM,CAACI,IAAI,CAACpB,KAAK,IAAI,CAAC,CAACA,KAAK,CAAC;MAE3C,IAAIA,KAAK,EAAE;QACP,MAAMA,KAAK;;IACd;EACL;EAEA;;;;;;EAMMqB,yBAAyBA,CAACd,QAA4B;IAAA,IAAAe,KAAA;IAAA,OAAAd,iBAAA;MACxD,MAAMe,SAAS,CAACC,YAAY,CAACF,KAAI,CAAChB,WAAW,CAACC,QAAQ,CAAC,CAAC;IAAC;EAC7D;EAEA;;;;;;;;;;EAUAkB,aAAaA,CACTC,KAAA,GAAa,EAAE,EACfC,YAAqB,EACrBC,MAAA,GAA4B,EAAE;IAE9B,KAAK,MAAMC,KAAK,IAAIH,KAAK,EAAE;MACvB,MAAMI,GAAG,GAAGH,YAAY,GAAGE,KAAK,CAACF,YAAY,CAAC,GAAGE,KAAK;MAEtDD,MAAM,CAACE,GAAG,CAAC,GAAGD,KAAK;;IAGvB,OAAOD,MAAM;EACjB;EAEA;;;;;;EAMAG,iBAAiBA,CAACC,OAAe,EAAEhC,KAAc;IAC7C,IAAI,CAACH,MAAM,CAACG,KAAK,CAACgC,OAAO,EAAEhC,KAAK,CAAC;EACrC;EAEA;;;;;;;;;;EAUAiC,qBAAqBA,CACjBP,KAAA,GAAa,EAAE,EACfC,YAAqB,EACrBC,MAAA,GAA8B,EAAE;IAEhC,KAAK,MAAMC,KAAK,IAAIH,KAAK,EAAE;MACvB,MAAMI,GAAG,GAAGH,YAAY,GAAGE,KAAK,CAACF,YAAY,CAAC,GAAGE,KAAK;MACtD,IAAID,MAAM,CAACE,GAAG,CAAC,KAAKI,SAAS,EAAE;QAC3BN,MAAM,CAACE,GAAG,CAAC,GAAG,EAAE;;MAGpBF,MAAM,CAACE,GAAG,CAAC,CAACK,IAAI,CAACN,KAAK,CAAC;;IAG3B,OAAOD,MAAM;EACjB;EAEA;;;;;;;;;;;;EAYAQ,gBAAgBA,CACZC,KAAU;EAAE;EACZC,KAAU;EAAE;EACZC,SAAA,GAAoB,CAAC,EACrBC,KAAA,GAAgB,CAAC,EACjBC,eAAA,GAA2B,IAAI;IAE/B,IAAI,OAAOJ,KAAK,IAAI,UAAU,IAAI,OAAOC,KAAK,IAAI,UAAU,EAAE;MAC1D,OAAO,IAAI,CAAC,CAAC;KAChB,MAAM,IAAI,OAAOD,KAAK,IAAI,QAAQ,IAAI,OAAOC,KAAK,IAAI,QAAQ,EAAE;MAC7D,IAAIE,KAAK,IAAID,SAAS,EAAE;QACpB,OAAO,IAAI,CAAC,CAAC;;;MAGjB,IAAIG,KAAK,GAAG,IAAI;MAChB,KAAK,MAAMC,IAAI,IAAIN,KAAK,EAAE;QACtB,MAAMO,KAAK,GAAGP,KAAK,CAACM,IAAI,CAAC;QACzB,IAAIA,IAAI,IAAI,WAAW,EAAE;UACrB;UACA;;QAGJ,IAAI,CAAC,IAAI,CAACP,gBAAgB,CAACQ,KAAK,EAAEN,KAAK,CAACK,IAAI,CAAC,EAAEJ,SAAS,EAAEC,KAAK,GAAG,CAAC,CAAC,EAAE;UAClEE,KAAK,GAAG,KAAK;;;MAIrB,OAAOA,KAAK;KACf,MAAM;MACH,IAAID,eAAe,KACdJ,KAAK,KAAKH,SAAS,IAAII,KAAK,KAAK,IAAI,IAAMD,KAAK,KAAK,IAAI,IAAIC,KAAK,KAAKJ,SAAU,CAAC,EAAE;QACrF,OAAO,IAAI;;MAGf;MACA,MAAMW,MAAM,GAAGC,UAAU,CAACT,KAAK,CAAC;MAChC,MAAMU,MAAM,GAAGD,UAAU,CAACR,KAAK,CAAC;MAEhC,IAAI,CAACU,KAAK,CAACH,MAAM,CAAC,IAAI,CAACG,KAAK,CAACD,MAAM,CAAC,EAAE;QAClC,OAAOF,MAAM,IAAIE,MAAM;;MAG3B,OAAOV,KAAK,KAAKC,KAAK;;EAE9B;EAEA;;;;;;EAMMW,aAAaA,CAACC,GAAW;IAAA,IAAAC,MAAA;IAAA,OAAA3C,iBAAA;MAC3B,IAAI,CAAC4C,MAAM,CAACC,KAAK,EAAE;QACf;QACA,OAAO,KAAK;;MAGhB,MAAMC,WAAW,GAAgB;QAAEC,QAAQ,EAAE;MAAQ,CAAE;MAEvD;MACA,MAAMC,UAAU,GAAGC,eAAe,GAAG,IAAIA,eAAe,EAAE,GAAG,KAAK;MAElE,IAAID,UAAU,EAAE;QACZF,WAAW,CAACI,MAAM,GAAGF,UAAU,CAACE,MAAM;;MAG1C,IAAI;QACA,MAAMC,QAAQ,SAASR,MAAI,CAACS,cAAc,CAACR,MAAM,CAACC,KAAK,CAACH,GAAG,EAAEI,WAAW,CAAC,EAAEzF,MAAM,CAACgG,iBAAiB,EAAE,CAAC;QAEtG,OAAOF,QAAQ,CAACG,UAAU;OAC7B,CAAC,OAAO9D,KAAK,EAAE;QACZ,IAAIA,KAAK,CAAC+D,OAAO,IAAIP,UAAU,EAAE;UAC7B;UACAA,UAAU,CAACQ,KAAK,EAAE;;QAGtB;QACA,OAAO,KAAK;;IACf;EACL;EAEA;;;EAGAC,iBAAiBA,CAAA;IACb,IAAI,IAAI,CAACC,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACC,KAAK,EAAE;;EAEhC;EAEA;;;;;EAKAC,uBAAuBA,CAAA;IACnB,OAAO,IAAI,CAACF,WAAW;EAC3B;EAEA;;;;;EAKAG,kBAAkBA,CAAA;IACd,OAAO,CAAC,CAAC,IAAI,CAACH,WAAW;EAC7B;EAEA;;;;;;;EAOAI,KAAKA,CAAIC,MAAS,EAAE/B,KAAA,GAAgB,CAAC;IACjC,IAAIA,KAAK,IAAI,EAAE,EAAE;MACb;MACA,IAAI,CAAC3C,MAAM,CAACG,KAAK,CAAC,wCAAwC,EAAEuE,MAAM,CAAC;MAEnE,OAAOA,MAAM;;IAGjB,IAAI,IAAI,CAACC,gBAAgB,CAACD,MAAM,CAAC,EAAE;MAC/B;MACA,OAAOA,MAAM;KAChB,MAAM,IAAIE,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,EAAE;MAC9B;MACA,MAAMI,QAAQ,GAAG,EAAkB;MACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,CAAC9D,MAAM,EAAEmE,CAAC,EAAE,EAAE;QACpCD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI,CAACN,KAAK,CAACC,MAAM,CAACK,CAAC,CAAC,EAAEpC,KAAK,GAAG,CAAC,CAAC;;MAGlD,OAAOmC,QAAQ;KAClB,MAAM,IAAI,IAAI,CAACE,QAAQ,CAACN,MAAM,CAAC,EAAE;MAC9B;MACA,IAAIA,MAAM,CAACO,QAAQ,IAAI,IAAI,CAACpF,UAAU,CAACqF,OAAO,CAACR,MAAM,CAACO,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE;QACrE;QACA,OAAOP,MAAM;;MAGjB;MACA,MAAMS,SAAS,GAAG,EAAO;MACzB,KAAK,MAAMrC,IAAI,IAAI4B,MAAM,EAAE;QACvBS,SAAS,CAACrC,IAAI,CAAC,GAAG,IAAI,CAAC2B,KAAK,CAACC,MAAM,CAAC5B,IAAI,CAAC,EAAEH,KAAK,GAAG,CAAC,CAAC;;MAGzD,OAAOwC,SAAS;KACnB,MAAM;MACH;MACA,OAAOT,MAAM;;EAErB;EAEA;;;;;;;EAOAU,cAAcA,CAACC,IAA6B,EAAEC,EAA2B,EAAEb,KAAA,GAAiB,IAAI;IAC5F,KAAK,MAAM3B,IAAI,IAAIuC,IAAI,EAAE;MACrB,IAAIZ,KAAK,EAAE;QACPa,EAAE,CAACxC,IAAI,CAAC,GAAG,IAAI,CAAC2B,KAAK,CAACY,IAAI,CAACvC,IAAI,CAAC,CAAC;OACpC,MAAM;QACHwC,EAAE,CAACxC,IAAI,CAAC,GAAGuC,IAAI,CAACvC,IAAI,CAAC;;;EAGjC;EAEA;;;;;;EAMMyC,eAAeA,CAACC,IAAY;IAAA,OAAA7E,iBAAA;MAC9B,IAAI;QACA,MAAMtC,SAAS,CAACoH,IAAI,CAACD,IAAI,CAAC;OAC7B,CAAC,OAAAE,OAAA,EAAM;QACJ;QACA,MAAMC,YAAY,GAAGC,QAAQ,CAACC,aAAa,CAAC,UAAU,CAAC;QACvDF,YAAY,CAACG,SAAS,GAAGN,IAAI;QAC7BG,YAAY,CAACI,MAAM,EAAE;QACrBJ,YAAY,CAACK,iBAAiB,CAAC,CAAC,EAAE,KAAK,CAAC;QACxCJ,QAAQ,CAACK,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;;MAGlC;MACAhI,YAAY,CAACiI,SAAS,CAAC,wBAAwB,EAAE,IAAI,CAAC;IAAC;EAC3D;EAEA;;;;;EAKAC,UAAUA,CAACtE,KAAgB;IACvBA,KAAK,CAACjB,MAAM,GAAG,CAAC,CAAC,CAAC;EACtB;EAEA;;;;;EAKAwF,WAAWA,CAACC,MAA+B;IACvC,KAAK,MAAMpE,GAAG,IAAIoE,MAAM,EAAE;MACtB,IAAIC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEpE,GAAG,CAAC,EAAE;QACnD,OAAOoE,MAAM,CAACpE,GAAG,CAAC;;;EAG9B;EAEA;;;;;;EAMAyE,sBAAsBA,CAACC,mBAAyC;IAC5D,MAAMjG,QAAQ,GAAoB,EAAE;IACpC,IAAIkG,UAAU,GAAGxF,OAAO,CAACyF,OAAO,EAAE;IAElC;IACA,KAAK,MAAM9B,CAAC,IAAI4B,mBAAmB,EAAE;MACjC,MAAMG,IAAI,GAAGH,mBAAmB,CAAC5B,CAAC,CAAC;MACnC;MACA,MAAMhE,OAAO,GAAG6F,UAAU,CAACG,OAAO,CAAC,MAAK;QACpC,IAAI;UACA,OAAOD,IAAI,CAACE,QAAQ,EAAE;SACzB,CAAC,OAAOC,CAAC,EAAE;UACR,IAAI,CAACjH,MAAM,CAACG,KAAK,CAAC8G,CAAC,CAAC9E,OAAO,CAAC;UAE5B;;MAER,CAAC,CAAC;MACFzB,QAAQ,CAAC4B,IAAI,CAACvB,OAAO,CAAC;MAEtB;MACA,IAAI+F,IAAI,CAACI,QAAQ,EAAE;QACfN,UAAU,GAAG7F,OAAO;;;IAI5B;IACA,OAAO,IAAI,CAACN,WAAW,CAACC,QAAQ,CAAC;EACrC;EAEA;;;;;;;;;EASAyG,aAAaA,CAACC,GAA4B,EAAEC,cAAwB;IAChE,MAAMC,QAAQ,GAAG,EAAE;IAEnB,KAAK,MAAMxE,IAAI,IAAIsE,GAAG,EAAE;MACpB,IAAI,CAACd,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACW,GAAG,EAAEtE,IAAI,CAAC,EAAE;QAClD;;MAGJ,MAAMC,KAAK,GAAGqE,GAAG,CAACtE,IAAI,CAAC;MACvB,IAAI,OAAOC,KAAK,IAAI,QAAQ,IAAI,CAAC6B,KAAK,CAACC,OAAO,CAAC9B,KAAK,CAAC,EAAE;QACnD,MAAMwE,UAAU,GAAG,IAAI,CAACJ,aAAa,CAACpE,KAAgC,CAAC;QACvE,KAAK,MAAMyE,OAAO,IAAID,UAAU,EAAE;UAC9B,IAAI,CAACjB,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACc,UAAU,EAAEC,OAAO,CAAC,EAAE;YAC5D;;UAGJ,MAAMC,OAAO,GAAGJ,cAAc,GAAGvE,IAAI,GAAG,GAAG,GAAG0E,OAAO,GAAG1E,IAAI,GAAG,GAAG,GAAG0E,OAAO,GAAG,GAAG;UAClFF,QAAQ,CAACG,OAAO,CAAC,GAAGF,UAAU,CAACC,OAAO,CAAC;;OAE9C,MAAM;QACHF,QAAQ,CAACxE,IAAI,CAAC,GAAGC,KAAK;;;IAI9B,OAAOuE,QAAQ;EACnB;EAEA;;;;;;;EAOAI,cAAcA,CAAC7F,KAAe,EAAE8F,KAAa;IACzC,IAAI,CAAC9F,KAAK,IAAI,CAACA,KAAK,CAACjB,MAAM,EAAE;MACzB,OAAO,EAAE;;IAGb,OAAOiB,KAAK,CAAC+F,MAAM,CAAE5F,KAAK,IAAI;MAC1B,MAAM6F,OAAO,GAAG7F,KAAK,CAAC8F,KAAK,CAACH,KAAK,CAAC;MAElC,OAAOE,OAAO,IAAIA,OAAO,CAACjH,MAAM;IACpC,CAAC,CAAC;EACN;EAEA;;;;;;;;;;EAUMmH,kBAAkBA,CACpBC,OAAiB,EACjBC,WAAuE,EACvEC,QAAkB,EAClB,GAAGC,IAAO;IAAA,IAAAC,MAAA;IAAA,OAAAzH,iBAAA;MAEV,MAAMD,QAAQ,GAA8B,EAAE;MAC9C,MAAM2H,YAAY,GAAa,EAAE;MAEjC,KAAK,MAAMtD,CAAC,IAAIiD,OAAO,EAAE;QACrB,MAAMM,MAAM,GAAGN,OAAO,CAACjD,CAAC,CAAC;QACzB,MAAMwD,aAAa,GAAGC,OAAO,IAAIA,OAAO,IAAIH,YAAY,CAAC/F,IAAI,CAACgG,MAAM,CAAC;QACrE,IAAIJ,QAAQ,IAAI,CAACxH,QAAQ,CAACE,MAAM,EAAE;UAC9BF,QAAQ,CAAC4B,IAAI,CACTlB,OAAO,CACFyF,OAAO,CAACoB,WAAW,CAACK,MAAM,EAAE,GAAGH,IAAI,CAAC,CAAC,CACrCM,IAAI,CAACF,aAAa,CAAC,CAC3B;;;MAIT,MAAM7G,SAAS,CAACC,YAAY,CAACyG,MAAI,CAAC3H,WAAW,CAACC,QAAQ,CAAC,CAAC;MAExD,IAAI,CAACwH,QAAQ,EAAE;QACX;QACA,OAAOG,YAAY,CAACzH,MAAM,GAAGoH,OAAO,GAAG,EAAE;OAC5C,MAAM;QACH,OAAOK,YAAY;;IACtB;EACL;EAEA;;;;;;;EAOAK,WAAWA,CAACC,KAAc;IACtB,IAAIA,KAAK,KAAKtG,SAAS,IAAIsG,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,IAAI,SAAS,EAAE;MACpE,OAAO,EAAE;;IAGb,MAAMC,eAAe,GAAGnK,SAAS,CAAC+B,OAAO,CAAC,aAAa,CAAC;IAExD,MAAMqI,WAAW,GAAGC,MAAM,CAACH,KAAK,CAAC;IAEjC,OAAOE,WAAW,CAACE,OAAO,CAAC,GAAG,EAAEH,eAAe,CAAC;EACpD;EAEA;;;;;;;;;;;;EAYAI,UAAUA,CACNC,IAAS,EACTC,eAAA,GAA0B,QAAQ,EAClCC,WAAA,GAAsB,IAAI,EAC1BC,YAAA,GAAuB,CAAC,EACxBC,QAAA,GAAmB,CAAC;IAEpB,MAAM/H,GAAG,GAAG,EAAE;IACd,MAAMgI,QAAQ,GAAG,EAAE;IACnB,MAAMC,IAAI,GAAkB,EAAE;IAE9B;IACAN,IAAI,CAACO,OAAO,CAAC,CAACC,IAAiB,EAAEC,KAAK,KAAU;MAC5C,MAAMC,EAAE,GAAGF,IAAI,CAACN,WAAW,CAAC;MAE5B,IAAIQ,EAAE,KAAKtH,SAAS,EAAE;QAClB,IAAI,CAACrC,MAAM,CAACG,KAAK,CAAC,uBAAuBgJ,WAAW,IAAIQ,EAAE,sBAAsB,CAAC;;MAGrF,IAAIF,IAAI,CAACG,QAAQ,KAAKvH,SAAS,EAAE;QAC7BoH,IAAI,CAACG,QAAQ,GAAG,EAAE;;MAEtBtI,GAAG,CAACqI,EAAE,CAAC,GAAGD,KAAK;IACnB,CAAC,CAAC;IAEFT,IAAI,CAACO,OAAO,CAAEC,IAAiB,IAAU;MACrC,MAAME,EAAE,GAAGF,IAAI,CAACN,WAAW,CAAC;MAC5B,MAAMU,MAAM,GAAGJ,IAAI,CAACP,eAAe,CAAC;MAEpC,IAAIS,EAAE,KAAKtH,SAAS,IAAIwH,MAAM,KAAKxH,SAAS,EAAE;QAC1C,IAAI,CAACrC,MAAM,CAACG,KAAK,CAAC,uBAAuBgJ,WAAW,IAAIQ,EAAE,OAAOT,eAAe,IAAIW,MAAM,sBAAsB,CAAC;;MAGrH;MACA,IAAIA,MAAM,KAAKT,YAAY,EAAE;QACzB,MAAMU,UAAU,GAAGb,IAAI,CAAC3H,GAAG,CAACuI,MAAM,CAAC,CAAgB;QACnD,IAAIC,UAAU,EAAE;UACZ,IAAIR,QAAQ,CAACO,MAAM,CAAC,IAAIR,QAAQ,EAAE;YAC9B;YACA,MAAMU,cAAc,GAAGD,UAAU,CAACZ,eAAe,CAAC;YAClD,IAAIa,cAAc,EAAE;cAChB;cACA;cACCd,IAAI,CAAC3H,GAAG,CAACyI,cAAc,CAAC,CAAiB,CAACH,QAAQ,CAACtH,IAAI,CAACmH,IAAI,CAAC;cAC9D;cACAH,QAAQ,CAACK,EAAE,CAAC,GAAGL,QAAQ,CAACO,MAAM,CAAC;cAC/B;cACAJ,IAAI,CAACP,eAAe,CAAC,GAAGa,cAAc;aACzC,MAAM;cACH,IAAI,CAAC/J,MAAM,CAACG,KAAK,CAAC,yBAAyB4J,cAAc,0BAA0B,CAAC;;WAE3F,MAAM;YACHD,UAAU,CAACF,QAAQ,CAACtH,IAAI,CAACmH,IAAI,CAAC;YAC9B;YACAH,QAAQ,CAACK,EAAE,CAAC,GAAGL,QAAQ,CAACO,MAAM,CAAC,GAAG,CAAC;;SAE1C,MAAM;UACH,IAAI,CAAC7J,MAAM,CAACG,KAAK,CAAC,eAAe0J,MAAM,0BAA0B,CAAC;;OAEzE,MAAM;QACHN,IAAI,CAACjH,IAAI,CAACmH,IAAI,CAAC;QAEf;QACAH,QAAQ,CAACK,EAAE,CAAC,GAAG,CAAC;;IAExB,CAAC,CAAC;IAEF,OAAOJ,IAAI;EACf;EAEA;;;;;;EAMAS,cAAcA,CAACC,IAAY;IACvB,MAAMC,UAAU,GAAG,mBAAmB,GAAGD,IAAI;IAC7C,MAAME,WAAW,GAAG1L,SAAS,CAAC+B,OAAO,CAAC0J,UAAU,CAAC;IAEjD,OAAOC,WAAW,KAAKD,UAAU,GAAGC,WAAW,GAAGF,IAAI;EAC1D;EAEA;;;;;EAKMG,cAAcA,CAAA;IAAA,IAAAC,MAAA;IAAA,OAAA1J,iBAAA;MAChB;MACA,MAAM2J,IAAI,SAASD,MAAI,CAACE,kBAAkB,EAAE;MAE5C;MACA,MAAMC,SAAS,GAA2B,EAAE;MAE5CF,IAAI,CAACd,OAAO,CAAEvH,GAAG,IAAI;QACjB,IAAIA,GAAG,CAACiD,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE;UACxC,MAAM+E,IAAI,GAAGhI,GAAG,CAAC8G,OAAO,CAAC,mBAAmB,EAAE,EAAE,CAAC;UACjDyB,SAAS,CAACP,IAAI,CAAC,GAAGxL,SAAS,CAAC+B,OAAO,CAACyB,GAAG,CAAC;;MAEhD,CAAC,CAAC;MAEF,OAAOuI,SAAS;IAAC;EACrB;EAEA;;;;;EAKMC,oBAAoBA,CAAA;IAAA,IAAAC,MAAA;IAAA,OAAA/J,iBAAA;MACtB;MACA,MAAM6J,SAAS,SAASE,MAAI,CAACN,cAAc,EAAE;MAE7C;MACA,OAAO9D,MAAM,CAACgE,IAAI,CAACE,SAAS,CAAC,CACxBG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKL,SAAS,CAACI,CAAC,CAAC,CAACE,aAAa,CAACN,SAAS,CAACK,CAAC,CAAC,CAAC,CAAC,CACxDvJ,GAAG,CAAE2I,IAAI,KAAM;QAAEA,IAAI;QAAEnH,IAAI,EAAE0H,SAAS,CAACP,IAAI;MAAC,CAAE,CAAC,CAAC;IAAC;EAC1D;EAEA;;;;;EAKgBM,kBAAkBA,CAAA;IAAA,IAAAQ,MAAA;IAAA,OAAApK,iBAAA;MAC9B;MACA,MAAMqK,WAAW,GAAGjN,QAAQ,CAACkN,kBAAkB,EAAE;MAEjD,IAAI;QACA,aAAaF,MAAI,CAACG,6BAA6B,CAACF,WAAW,CAAC;OAC/D,CAAC,OAAAG,QAAA,EAAM;QACJ;QACA,MAAMC,YAAY,GAAGrN,QAAQ,CAACsN,mBAAmB,EAAE;QAEnD,IAAID,YAAY,KAAKJ,WAAW,EAAE;UAC9B;UACA,MAAM,IAAIM,KAAK,CAAC,sBAAsB,CAAC;;QAG3C,OAAOP,MAAI,CAACG,6BAA6B,CAACE,YAAY,CAAC;;IAC1D;EACL;EAEA;;;;;;EAMgBF,6BAA6BA,CAACK,IAAY;IAAA,OAAA5K,iBAAA;MACtD;MACA,MAAM6K,KAAK,SAASzN,QAAQ,CAAC0N,mBAAmB,CAACF,IAAI,CAAC;MAEtD;MACA,MAAMjB,IAAI,GAAa,EAAE;MAEzB,KAAK,MAAMxH,IAAI,IAAI0I,KAAK,EAAE;QACtB,IAAI1I,IAAI,CAACoC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE;UACzCoF,IAAI,CAAChI,IAAI,CAACQ,IAAI,CAAC;;;MAIvB,IAAIwH,IAAI,CAAC1J,MAAM,KAAK,CAAC,EAAE;QACnB;QACA,MAAM,IAAI0K,KAAK,CAAC,sBAAsB,CAAC;;MAG3C,OAAOhB,IAAI;IAAC;EAChB;EAEA;;;;;;;;EAQMoB,kBAAkBA,CAACrI,GAAW;IAAA,OAAA1C,iBAAA;MAChC;MACA,MAAMgL,SAAS,GAAGzN,iBAAiB,CAAC0N,qBAAqB,CAACvI,GAAG,CAAC;MAC9D,IAAIwI,QAAQ,GAAGF,SAAS,IAAIzN,iBAAiB,CAAC4N,WAAW,CAACH,SAAS,CAAC;MAEpE,IAAIE,QAAQ,EAAE;QACV,OAAOA,QAAQ;;MAGnB;MACAA,QAAQ,SAAS7N,MAAM,CAAC+N,qBAAqB,CAAC1I,GAAG,CAAC;MAElD,OAAOwI,QAAQ,IAAI,EAAE;IAAC;EAC1B;EAEA;;;;;;EAMAG,WAAWA,CAAClJ,IAAY;IACpB,IAAI,CAAC,IAAI,CAAChD,SAAS,CAACgD,IAAI,CAAC,EAAE;MACvB,IAAI,CAAChD,SAAS,CAACgD,IAAI,CAAC,GAAG,CAAC;;IAG5B,OAAO,EAAE,IAAI,CAAChD,SAAS,CAACgD,IAAI,CAAC;EACjC;EAEA;;;;;;EAMAmJ,WAAWA,CAACC,IAAmB;IAC3B,OAAO,QAAQ,IAAIA,IAAI;EAC3B;EAEA;;;;;;EAMAvH,gBAAgBA,CAACuH,IAAa;IAC1B;IACA,OAAO,CAAC,EAAEA,IAAI,IAAI,OAAOA,IAAI,IAAI,QAAQ,IAAI,QAAQ,IAAIA,IAAI,IAAI,YAAY,IAAIA,IAAI,IACjF,eAAe,IAAIA,IAAI,IAAI,QAAQ,IAAIA,IAAI,CAAC;EACpD;EAEA;;;;;;EAMAlH,QAAQA,CAACqB,MAAe;IACpB,OAAO,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,IAAI;EACxD;EAEA;;;;;;EAMA8F,oBAAoBA,CAACC,KAAsB;IACvC,IAAI,CAACA,KAAK,IAAI,CAACA,KAAK,CAACxL,MAAM,EAAE;MACzB,OAAO,KAAK;;IAGhB,MAAMyL,KAAK,GAAa,EAAE;IAE1B;IACA,KAAK,IAAItH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqH,KAAK,CAACxL,MAAM,EAAEmE,CAAC,EAAE,EAAE;MACnC,MAAMmH,IAAI,GAAGE,KAAK,CAACrH,CAAC,CAAC;MACrB,MAAMjC,IAAI,GAAG,CAAC,IAAI,CAACmJ,WAAW,CAACC,IAAI,CAAC,GAAGA,IAAI,CAACpJ,IAAI,GAAGoJ,IAAI,CAACI,QAAQ,KAAK,EAAE;MAEvE,IAAID,KAAK,CAACnH,OAAO,CAACpC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;QAC1B,OAAOrE,SAAS,CAAC+B,OAAO,CAAC,oBAAoB,EAAE;UAAE+L,EAAE,EAAEzJ;QAAI,CAAE,CAAC;;MAGhEuJ,KAAK,CAAC/J,IAAI,CAACQ,IAAI,CAAC;;IAGpB,OAAO,KAAK;EAChB;EAEA;;;;;;;EAOA0J,aAAaA,CAAC3K,KAAe,EAAE8F,KAAa;IACxC,IAAI,CAAC9F,KAAK,IAAI,CAACA,KAAK,CAACjB,MAAM,EAAE;MACzB,OAAO,CAAC,CAAC;;IAGb,KAAK,IAAImE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlD,KAAK,CAACjB,MAAM,EAAEmE,CAAC,EAAE,EAAE;MACnC,MAAM/C,KAAK,GAAGH,KAAK,CAACkD,CAAC,CAAC;MACtB,MAAM8C,OAAO,GAAG7F,KAAK,CAAC8F,KAAK,CAACH,KAAK,CAAC;MAElC,IAAIE,OAAO,IAAIA,OAAO,CAACjH,MAAM,EAAE;QAC3B,OAAOmE,CAAC;;;IAIhB,OAAO,CAAC,CAAC;EACb;EAEA;;;;;;EAMA;EACA0H,aAAaA,CAAC1J,KAAU;IACpB,OAAOA,KAAK,KAAKV,SAAS,KAAKU,KAAK,KAAK,KAAK,IAAIA,KAAK,KAAK,OAAO,IAAI2J,QAAQ,CAAC3J,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC;EACrG;EAEA;;;;;;EAMA;EACA4J,WAAWA,CAAC5J,KAAU;IAClB,OAAOA,KAAK,KAAKV,SAAS,KAAKU,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,MAAM,IAAI2J,QAAQ,CAAC3J,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC;EACnG;EAEA;;;;;;EAMA;EACAxC,iBAAiBA,CAACJ,KAAU;IACxB,OAAOA,KAAK,KACRA,KAAK,CAACyM,WAAW,KAAKvK,SAAS,IAE3BlC,KAAK,CAAC0M,SAAS,KAAKxK,SAAS,IAAIlC,KAAK,CAAC0M,SAAS,IAAI,aAAa,IAAI1M,KAAK,CAAC0M,SAAS,IAAI,gBAAgB,IACxG1M,KAAK,CAAC0M,SAAS,IAAI,2BAA2B,IAAI1M,KAAK,CAAC0M,SAAS,IAAI,mBAAmB,IACxF1M,KAAK,CAAC0M,SAAS,IAAI,qBAAqB,IAAI1M,KAAK,CAAC0M,SAAS,IAAI,iBAAiB,IAChF1M,KAAK,CAAC0M,SAAS,IAAI,uBAAuB,IAAI1M,KAAK,CAAC0M,SAAS,IAAI,qBAAqB,IACtF,CAAC,IAAI,CAACC,mBAAmB,CAAC3M,KAAK,CAClC,IACDA,KAAK,CAAC4M,MAAM,IAAI5M,KAAK,CAAC4M,MAAM,IAAI,GAAG,CAAC;IAAA,CACvC;EACL;EAEA;;;;;;EAMA;EACAD,mBAAmBA,CAAC3M,KAAU;IAC1B,OAAOA,KAAK,CAAC0M,SAAS,KAAK,cAAc,IACpC1M,KAAK,CAAC0M,SAAS,KAAK,iBAAiB,IAAI1M,KAAK,CAACgC,OAAO,CAAC6K,QAAQ,CAAC,+BAA+B,CAAE;EAC1G;EAEA;;;;;;;;;;EAUAC,gBAAgBA,CACZhE,IAAY,EACZiE,YAAqB,EACrBC,SAAA,GAAoB,GAAG,EACvBC,YAAgB;IAEhB;IACA,MAAMC,KAAK,GAAGpE,IAAI,CAACoE,KAAK,CAACF,SAAS,CAAC,CAAC7L,GAAG,CAAC,CAACgM,KAAK,EAAE5D,KAAK,MAAM;MACvD4D,KAAK,EAAEA,KAAK,CAACC,IAAI,EAAE;MACnBxK,KAAK,EAAE2G,KAAK,GAAG;KAClB,CAAC,CAA2C;IAE7C,IAAIwD,YAAY,EAAE;MACdG,KAAK,CAACG,OAAO,CAAC;QACVF,KAAK,EAAEJ,YAAY;QACnBnK,KAAK,EAAEqK,YAAY,IAAI;OAC1B,CAAC;;IAGN,OAAOC,KAAK;EAChB;EAEA;;;;;;;;EAQAI,4BAA4BA,CAAIC,MAAW,EAAEC,MAAW,EAAE1L,GAAY;IAClE,OAAO,IAAI,CAAC2L,WAAW,CAACF,MAAM,CAACG,MAAM,CAACF,MAAM,CAAC,EAAE1L,GAAG,CAAQ;EAC9D;EAEA;;;;;;EAMA;EACA6L,kBAAkBA,CAAC/K,KAAU;IACzB,OAAOA,KAAK,KAAKV,SAAS,IAAIU,KAAK,KAAK,IAAI;EAChD;EAEA;;;;;;;EAOMgL,QAAQA,CAACC,IAAY,EAAEC,OAAA,GAAoC,EAAE;IAAA,IAAAC,MAAA;IAAA,OAAAvN,iBAAA;MAC/D;MACAqN,IAAI,GAAGlQ,QAAQ,CAACqQ,gBAAgB,CAACH,IAAI,CAAC;MAEtC,MAAMrC,SAAS,GAAGzN,iBAAiB,CAACkQ,gBAAgB,CAACJ,IAAI,CAAC;MAC1D,MAAMnC,QAAQ,GAAGF,SAAS,IAAIzN,iBAAiB,CAAC4N,WAAW,CAACH,SAAS,CAAC;MAEtE,IAAIE,QAAQ,IAAI,WAAW,IAAI3M,YAAY,CAACmP,SAAS,EAAE,EAAE;QACrD;QACAH,MAAI,CAACI,SAAS,CAACN,IAAI,CAAC;QAEpB;OACH,MAAM,IAAIrC,SAAS,KAAK,KAAK,IAAIzM,YAAY,CAACmP,SAAS,EAAE,EAAE;QACxD,MAAMhL,GAAG,SAAS3B,SAAS,CAACC,YAAY,CACpCvC,YAAY,CAACmP,gBAAgB,CAAClP,SAAS,CAACmP,gBAAgB,EAAE,EAAE1Q,QAAQ,CAAC2Q,cAAc,CAACT,IAAI,CAAC,CAAC,CAC7F;QAED;QAEA,MAAM,IAAI7O,oBAAoB,CAC1BV,SAAS,CAAC+B,OAAO,CAAC,2BAA2B,CAAC,EAC9C/B,SAAS,CAAC+B,OAAO,CAAC,uBAAuB,CAAC,EAC1C6C,GAAG,GACG,CACE;UACImC,IAAI,EAAE/G,SAAS,CAAC+B,OAAO,CAAC,oBAAoB,CAAC;UAC7CkO,OAAO,EAAEA,CAAA,KAAMR,MAAI,CAACS,aAAa,CAACtL,GAAG;SACxC,EACD;UACImC,IAAI,EAAE/G,SAAS,CAAC+B,OAAO,CAAC,aAAa,CAAC;UACtCoO,IAAI,EAAE;SACT,CACJ,GACCvM,SAAS,CAClB;;MAGL;MACA,IAAI;QACA2L,IAAI,GAAGa,kBAAkB,CAACb,IAAI,CAAC;OAClC,CAAC,OAAOc,EAAE,EAAE;QACT;MAAA;MAGJ,MAAMf,QAAQ;QAAA,IAAAgB,KAAA,GAAApO,iBAAA,CAAG,WAAOkL,QAAiB,EAAI;UACzC,IAAIqC,MAAI,CAACc,oBAAoB,CAACf,OAAO,CAAC,EAAE;YACpC,MAAM1P,UAAU,CAAC0Q,kBAAkB,CAACjB,IAAI,EAAEnC,QAAQ,IAAI,EAAE,CAAC;WAC5D,MAAM;YACH,MAAMtN,UAAU,CAAC2Q,IAAI,CAAClB,IAAI,EAAEnC,QAAQ,IAAI,EAAE,CAAC;;QAEnD,CAAC;QAAA,gBANKkC,QAAQA,CAAAoB,GAAA;UAAA,OAAAJ,KAAA,CAAA9N,KAAA,OAAAC,SAAA;QAAA;MAAA,GAMb;MAED,IAAI;QACA,IAAI;UACA,MAAM6M,QAAQ,CAAClC,QAAQ,CAAC;SAC3B,CAAC,OAAO1L,KAAK,EAAE;UACZ,IAAI,CAACwL,SAAS,IAAI,CAACxL,KAAK,IAAIiP,MAAM,CAACjP,KAAK,CAAC4M,MAAM,CAAC,KAAK,CAAC,EAAE;YACpD,MAAM5M,KAAK;;UAGf;UACA,MAAMkP,kBAAkB,GAAGnR,iBAAiB,CAACoR,qBAAqB,CAAC3D,SAAS,CAAC;UAC7E,IAAI,CAAC0D,kBAAkB,IAAIA,kBAAkB,KAAKxD,QAAQ,EAAE;YACxD,MAAM1L,KAAK;;UAGf,MAAM4N,QAAQ,CAACsB,kBAAkB,CAAC;;OAEzC,CAAC,OAAOlP,KAAK,EAAE;QACZ+N,MAAI,CAAClO,MAAM,CAACG,KAAK,CAAC,qBAAqB,GAAG6N,IAAI,GAAG,iBAAiB,GAAGnC,QAAQ,CAAC;QAC9EqC,MAAI,CAAClO,MAAM,CAACG,KAAK,CAAC,SAAS,EAAEoP,IAAI,CAACC,SAAS,CAACrP,KAAK,CAAC,CAAC;QAEnD,IAAI,CAACwL,SAAS,IAAIA,SAAS,CAACzG,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIyG,SAAS,CAACzG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;UAC3E;UACA,MAAM,IAAIoG,KAAK,CAAC7M,SAAS,CAAC+B,OAAO,CAAC,+BAA+B,CAAC,CAAC;;QAGvE,MAAM,IAAI8K,KAAK,CAAC7M,SAAS,CAAC+B,OAAO,CAAC,yBAAyB,CAAC,CAAC;;IAChE;EACL;EAEA;;;;;;;;EAQA8N,SAASA,CAACjL,GAAW,EAAE4K,OAAmC;IAAA,IAAAwB,qBAAA,EAAAC,qBAAA,EAAAC,iBAAA,EAAAC,oBAAA;IACtD3B,OAAO,GAAGA,OAAO,IAAI,EAAE;IACvBA,OAAO,CAAC4B,YAAY,GAAG,KAAK,CAAC,CAAC;IAC9B5B,OAAO,CAAC6B,mBAAmB,IAAAL,qBAAA,GAAGxB,OAAO,CAAC6B,mBAAmB,cAAAL,qBAAA,cAAAA,qBAAA,GAAI,KAAK,CAAC,CAAC;IACpExB,OAAO,CAAC8B,wBAAwB,IAAAL,qBAAA,GAAGzB,OAAO,CAAC8B,wBAAwB,cAAAL,qBAAA,cAAAA,qBAAA,GAAI,KAAK,CAAC,CAAC;IAE9E,IAAI,CAACzB,OAAO,CAAC+B,QAAQ,IAAI9Q,YAAY,CAAC+Q,KAAK,EAAE,IAAI5M,GAAG,CAAC6B,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;MAC3E;MACA;MACA+I,OAAO,CAAC+B,QAAQ,GAAG,IAAI;;IAG3B,IAAI,CAACE,4BAA4B,CAACjC,OAAO,CAAC;IAE1C,CAAA0B,iBAAA,OAAI,CAACtL,WAAW,cAAAsL,iBAAA,eAAhBA,iBAAA,CAAkBrL,KAAK,EAAE,CAAC,CAAC;IAE3B,IAAI,CAACD,WAAW,GAAG/F,YAAY,CAAC6R,MAAM,CAAC9M,GAAG,EAAE,QAAQ,EAAE4K,OAAO,CAAC;IAE9D,IAAI/O,YAAY,CAACkR,QAAQ,EAAE,EAAE;MACzB,MAAMC,aAAa,GAAa,EAAE;MAElC,MAAMC,qBAAqB,GAAG,IAAI,CAACjM,WAAW,CAACkM,EAAE,CAAC,WAAW,CAAC,CAACC,SAAS,CAAEC,KAAK,IAAI;QAC/E/R,MAAM,CAACgS,GAAG,CAAC,MAAK;UACZ;UACAL,aAAa,CAAC/N,IAAI,CAACmO,KAAK,CAACpN,GAAG,CAAC;UAC7B,IAAIgN,aAAa,CAACzP,MAAM,GAAG,EAAE,EAAE;YAC3ByP,aAAa,CAACM,KAAK,EAAE;;UAGzB9S,UAAU,CAAC+S,OAAO,CAAC/S,UAAU,CAACgT,cAAc,EAAEJ,KAAK,CAAC;QACxD,CAAC,CAAC;MACN,CAAC,CAAC;MAEF,MAAMK,oBAAoB,GAAG,IAAI,CAACzM,WAAW,CAACkM,EAAE,CAAC,UAAU,CAAC,CAACC,SAAS,CAAEC,KAAK,IAAI;QAC7E/R,MAAM,CAACgS,GAAG,CAAC,MAAK;UACZ7S,UAAU,CAAC+S,OAAO,CAAC/S,UAAU,CAACkT,aAAa,EAAEN,KAAK,CAAC;QACvD,CAAC,CAAC;MACN,CAAC,CAAC;MAEF,MAAMO,mBAAmB,GAAG,IAAI,CAAC3M,WAAW,CAACkM,EAAE,CAAC,SAAS,CAAC,CAACC,SAAS,CAAEC,KAAK,IAAI;QAC3E/R,MAAM,CAACgS,GAAG,CAAC,MAAK;UACZ7S,UAAU,CAAC+S,OAAO,CAAC/S,UAAU,CAACoT,WAAW,EAAER,KAAK,CAAC3J,IAAI,CAAC;QAC1D,CAAC,CAAC;MACN,CAAC,CAAC;MAEF,MAAMoK,gBAAgB,GAAG,IAAI,CAAC7M,WAAW,CAACkM,EAAE,CAAC,MAAM,CAAC,CAACC,SAAS,CAAEC,KAAK,IAAI;QACrE/R,MAAM,CAACgS,GAAG,CAAC,MAAK;UACZJ,qBAAqB,CAACa,WAAW,EAAE;UACnCL,oBAAoB,CAACK,WAAW,EAAE;UAClCH,mBAAmB,CAACG,WAAW,EAAE;UACjCD,gBAAgB,CAACC,WAAW,EAAE;UAE9B,IAAI,CAAC9M,WAAW,GAAGhC,SAAS;UAC5BxE,UAAU,CAAC+S,OAAO,CAAC/S,UAAU,CAACuT,QAAQ,EAAEX,KAAK,CAAC;QAClD,CAAC,CAAC;MACN,CAAC,CAAC;;IAGNlR,aAAa,CAAC8R,QAAQ,CAAC;MACnBC,IAAI,EAAE9R,sBAAsB,CAAC+R,SAAS;MACtCC,IAAI,EAAE/R,YAAY,CAACgS,kBAAkB,EAAA7B,oBAAA,GAAC3B,OAAO,CAACyD,WAAW,cAAA9B,oBAAA,cAAAA,oBAAA,GAAIvM,GAAG;KACnE,CAAC;IAEF,OAAO,IAAI,CAACgB,WAAW;EAC3B;EAEA;;;;;;EAMU6L,4BAA4BA,CAACjC,OAA4B;IAC/D,IAAIA,OAAO,CAAC0D,YAAY,EAAE;MACtB;MACA,OAAO1D,OAAO;;IAGlB;IACA,IAAI2D,OAA2B;IAC/B,IAAIC,SAA6B;IAEjC,IAAI/S,aAAa,CAACgT,MAAM,CAACC,gBAAgB,KAAK,MAAM,EAAE;MAClDH,OAAO,GAAG5S,UAAU,CAACgT,yBAAyB,EAAE;KACnD,MAAM,IAAIlT,aAAa,CAACgT,MAAM,CAACC,gBAAgB,IAAI,OAAOjT,aAAa,CAACgT,MAAM,CAACC,gBAAgB,KAAK,QAAQ,EAAE;MAC3GH,OAAO,GAAG9S,aAAa,CAACgT,MAAM,CAACC,gBAAgB,CAACE,UAAU;MAC1DJ,SAAS,GAAG/S,aAAa,CAACgT,MAAM,CAACC,gBAAgB,CAACvM,IAAI;;IAG1D,IAAI,CAACoM,OAAO,EAAE;MACV;MACA3D,OAAO,CAACiE,aAAa,GAAG,SAAS;MAEjC,OAAOjE,OAAO;;IAGlB,IAAI,CAAC4D,SAAS,EAAE;MACZA,SAAS,GAAG7S,UAAU,CAACmT,wBAAwB,CAACP,OAAO,CAAC,GAAG,SAAS,GAAG,SAAS;;IAGpF3D,OAAO,CAAC0D,YAAY,GAAGC,OAAO;IAC9B3D,OAAO,CAACmE,gBAAgB,GAAGP,SAAS;IACpC5D,OAAO,CAACoE,qBAAqB,GAAGR,SAAS;IACzC5D,OAAO,CAACiE,aAAa,GAAGN,OAAO;IAC/B3D,OAAO,CAACqE,iBAAiB,GAAGT,SAAS;IAErC,OAAO5D,OAAO;EAClB;EAEA;;;;;;;EAOMU,aAAaA,CAACtL,GAAW,EAAE4K,OAAA,GAAyC,EAAE;IAAA,OAAAtN,iBAAA;MAAA,IAAA4R,KAAA,EAAAC,qBAAA;MACxE;MACA,MAAMC,UAAU,GAAGhT,YAAY,CAACgS,kBAAkB,EAAAc,KAAA,IAAAC,qBAAA,GAACvE,OAAO,CAACyD,WAAW,cAAAc,qBAAA,cAAAA,qBAAA,GAAIvE,OAAO,CAACyE,iBAAiB,cAAAH,KAAA,cAAAA,KAAA,GAAIlP,GAAG,CAAC;MAC3G,IAAI4K,OAAO,CAAC0E,kBAAkB,IAAI1E,OAAO,CAAC0E,kBAAkB,KAAKtQ,SAAS,EAAE;QACxE,IAAI;UACA,MAAMtD,UAAU,CAAC6T,0BAA0B,CAACH,UAAU,CAAC;SAC1D,CAAC,OAAOtS,KAAK,EAAE;UACZ,OAAO,CAAC;;;;MAIhBZ,aAAa,CAAC8R,QAAQ,CAAC;QACnBC,IAAI,EAAE9R,sBAAsB,CAAC+R,SAAS;QACtCC,IAAI,EAAEiB;OACT,CAAC;MAEFlP,MAAM,CAAC2L,IAAI,CAAC7L,GAAG,EAAE,SAAS,CAAC;IAAC;EAChC;EAEA;;;;;;;EAOMwP,cAAcA,CAACxP,GAAW;IAAA,IAAAyP,MAAA;IAAA,OAAAnS,iBAAA;MAC5B,IAAIzB,YAAY,CAACmP,SAAS,EAAE,EAAE;QAC1B;QACA,MAAMxC,QAAQ,SAASiH,MAAI,CAACnR,YAAY,CAACmR,MAAI,CAACpH,kBAAkB,CAACrI,GAAG,CAAC,CAAC;QAEtE,IAAI,CAACwI,QAAQ,EAAE;UACX;UACA,MAAM,IAAIP,KAAK,CAAC7M,SAAS,CAAC+B,OAAO,CAAC,+BAA+B,CAAC,CAAC;;QAGvE,MAAMyN,OAAO,GAAG;UACZ8E,MAAM,EAAEvU,SAAS,CAACwU,WAAW;UAC7B3P,GAAG;UACHiO,IAAI,EAAEzF;SACT;QAED,IAAI;UACA,MAAMrN,SAAS,CAACyU,aAAa,CAAChF,OAAO,CAAC;UAEtC1O,aAAa,CAAC8R,QAAQ,CAAC;YACnBC,IAAI,EAAE9R,sBAAsB,CAAC+R,SAAS;YACtCC,IAAI,EAAE/R,YAAY,CAACgS,kBAAkB,CAACpO,GAAG;WAC5C,CAAC;SACL,CAAC,OAAOlD,KAAK,EAAE;UACZ2S,MAAI,CAAC9S,MAAM,CAACG,KAAK,CAAC,4BAA4B,GAAGkD,GAAG,GAAG,iBAAiB,GAAGwI,QAAQ,CAAC;UACpFiH,MAAI,CAAC9S,MAAM,CAACG,KAAK,CAAC,SAAS,EAAEoP,IAAI,CAACC,SAAS,CAACrP,KAAK,CAAC,CAAC;UAEnD,MAAM,IAAImL,KAAK,CAAC7M,SAAS,CAAC+B,OAAO,CAAC,yBAAyB,CAAC,CAAC;;;MAIrE;MACAsS,MAAI,CAACxE,SAAS,CAACjL,GAAG,CAAC;IAAC;EACxB;EAEA;;;;;;EAMA6P,aAAaA,CAAI9L,GAAsB;IACnC,OAAOd,MAAM,CAACgE,IAAI,CAAClD,GAAG,CAAC,CAAC9F,GAAG,CAAEW,GAAG,IAAKmF,GAAG,CAACnF,GAAG,CAAC,CAAC;EAClD;EAEA;;;;;;;;;;;;EAYAkR,sBAAsBA,CAIlB/L,GAAM,EACNgM,OAAe,EACfC,SAAiB,EACjBC,SAAmB,EACnBC,WAAqB;IAErB;IACA,MAAMC,UAAU,GAAGA,CAACC,KAAa,EAAE1Q,KAAc,KAAyC;MACtF,IAAIA,KAAK,KAAKV,SAAS,IAAIU,KAAK,IAAI,IAAI,EAAE;QACtC;QACA;OACH,MAAM,IAAI,IAAI,CAACiC,QAAQ,CAACjC,KAAK,CAAC,EAAE;QAC7B;QACA,MAAMuH,IAAI,GAAGhE,MAAM,CAACgE,IAAI,CAACvH,KAAK,CAAC;QAC/B,IAAI2Q,OAAO,GAAc,EAAE;QAE3BpJ,IAAI,CAACd,OAAO,CAAEvH,GAAG,IAAI;UACjB,MAAM0R,QAAQ,GAAGF,KAAK,GAAGA,KAAK,GAAG,GAAG,GAAGxR,GAAG,GAAG,GAAG,GAAGA,GAAG;UACtD,MAAM2R,UAAU,GAAGJ,UAAU,CAACG,QAAQ,EAAE5Q,KAAK,CAACd,GAAG,CAAC,CAAC;UAEnD,IAAI2R,UAAU,EAAE;YACZF,OAAO,GAAGA,OAAO,CAAC7F,MAAM,CAAC+F,UAAU,CAAC;;QAE5C,CAAC,CAAC;QAEF,OAAOF,OAAO;OACjB,MAAM;QACH;QACA,MAAM1R,KAAK,GAAG,EAAE;QAChBA,KAAK,CAACoR,OAAO,CAAC,GAAGK,KAAK;QACtBzR,KAAK,CAACqR,SAAS,CAAC,GAAGtQ,KAAK;QAExB,OAAOf,KAAK;;IAEpB,CAAC;IAED,IAAI,CAACoF,GAAG,EAAE;MACN,OAAO,EAAE;;IAGb;IACA,MAAMsM,OAAO,GAAGF,UAAU,CAAC,EAAE,EAAEpM,GAAG,CAAQ;IAC1C,IAAIkM,SAAS,IAAIC,WAAW,EAAE;MAC1B,OAAOG,OAAO,CAAC/I,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAI;QACzB,IAAIyI,SAAS,EAAE;UACX,OAAQ1I,CAAC,CAACwI,OAAO,CAAY,IAAKvI,CAAC,CAACuI,OAAO,CAAY,GAAG,CAAC,GAAG,CAAC,CAAC;SACnE,MAAM;UACH,OAAQxI,CAAC,CAACyI,SAAS,CAAY,IAAKxI,CAAC,CAACwI,SAAS,CAAY,GAAG,CAAC,GAAG,CAAC,CAAC;;MAE5E,CAAC,CAAC;;IAGN,OAAOK,OAAO;EAClB;EAEA;;;;;;;;;;EAUAG,mBAAmBA,CACfC,OAAkC,EAClCV,OAAe,EACfC,SAAiB,EACjBU,SAAkB;IAElB,MAAMC,YAAY,GAAGD,SAAS,GAAGA,SAAS,CAACnT,MAAM,GAAG,CAAC;IACrD,MAAMqT,MAAM,GAAG,EAAE;IACjBH,OAAO,CAACtK,OAAO,CAAE0K,IAAI,IAAI;MACrB,MAAMC,QAAQ,GAAGD,IAAI,CAACd,OAAO,CAAW;MACxC,MAAMnR,GAAG,GAAG+R,YAAY,GAAG,CAAC,GAAGG,QAAQ,CAACC,SAAS,CAACJ,YAAY,CAAC,GAAGG,QAAQ;MAC1EF,MAAM,CAAChS,GAAG,CAAC,GAAGiS,IAAI,CAACb,SAAS,CAAC;IACjC,CAAC,CAAC;IAEF,OAAOY,MAAM;EACjB;EAEA;;;;;;;EAOAI,iBAAiBA,CAAChO,MAA+B,EAAEiO,WAAA,GAAuB,IAAI;IAC1E;IACA,MAAMC,SAAS,GAAG,IAAI,CAACpN,aAAa,CAACd,MAAM,CAAC;IAC5C,IAAItE,MAAM,GAAG,EAAE;IACf,IAAIyS,QAAQ,GAAG,EAAE;IAEjB,KAAK,MAAM1R,IAAI,IAAIyR,SAAS,EAAE;MAC1B,IAAIxR,KAAK,GAAGwR,SAAS,CAACzR,IAAI,CAAC;MAE3B,IAAIwR,WAAW,KAAKvR,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKV,SAAS,CAAC,EAAE;QACxD;;MAGJ,IAAI,OAAOU,KAAK,IAAI,SAAS,EAAE;QAC3BA,KAAK,GAAGA,KAAK,GAAG,CAAC,GAAG,CAAC;;MAGzBhB,MAAM,IAAIyS,QAAQ,GAAG1R,IAAI,GAAG,GAAG,GAAGC,KAAK;MACvCyR,QAAQ,GAAG,GAAG;;IAGlB,OAAOzS,MAAM;EACjB;EAEA;;;;;;;EAOA0S,UAAUA,CAAC3N,IAA6B,EAAE4N,MAAc;IACpD,MAAMC,MAAM,GAAG,EAAE;IACjB,MAAMrK,IAAI,GAAGhE,MAAM,CAACgE,IAAI,CAACxD,IAAI,CAAC;IAE9BwD,IAAI,CAACd,OAAO,CAAEvH,GAAG,IAAI;MACjB0S,MAAM,CAACD,MAAM,GAAGzS,GAAG,CAAC,GAAG6E,IAAI,CAAC7E,GAAG,CAAC;IACpC,CAAC,CAAC;IAEF,OAAO0S,MAAM;EACjB;EAEA;;;;;;EAMAC,QAAQA,CAAgDC,WAAc;IAClE,OAAOvO,MAAM,CAACgE,IAAI,CAACuK,WAAW,CAAC,CAACjN,MAAM,CAACkN,CAAC,IAAI1F,MAAM,CAACjM,KAAK,CAAC,CAAC2R,CAAC,CAAC,CAAQ;EACxE;EAEA;;;;;;EAMAC,YAAYA,CAAA;IACR,OAAO,IAAI9V,iBAAiB,EAAK;EACrC;EAEA;;;;;;EAMM+V,YAAYA,CAACjU,OAAyB;IAAA,OAAAJ,iBAAA;MACxC,IAAI;QACA,MAAMI,OAAO;QAEb,OAAO,KAAK;OACf,CAAC,OAAAkU,QAAA,EAAM;QACJ,OAAO,IAAI;;IACd;EACL;EAEA;;;;;;EAMMC,YAAYA,CAACnU,OAAyB;IAAA,OAAAJ,iBAAA;MACxC,IAAI;QACA,MAAMI,OAAO;QAEb,OAAO,IAAI;OACd,CAAC,OAAAoU,QAAA,EAAM;QACJ,OAAO,KAAK;;IACf;EACL;EAEA;;;;;;;;;;EAUAC,uBAAuBA,CACnBC,IAAyC,EACzCC,IAAyC,EACzCrT,GAAW;IAEX,IAAIsT,MAAM,GAAGF,IAAI,CAACpT,GAAG,CAAC,KAAKI,SAAS,GAAGgT,IAAI,CAACpT,GAAG,CAAC,GAAG,EAAE;IACrD,IAAIuT,MAAM,GAAGF,IAAI,CAACrT,GAAG,CAAC,KAAKI,SAAS,GAAGiT,IAAI,CAACrT,GAAG,CAAC,GAAG,EAAE;IAErD,IAAI,OAAOsT,MAAM,IAAI,QAAQ,IAAI,OAAOA,MAAM,IAAI,SAAS,EAAE;MACzDA,MAAM,GAAG,EAAE,GAAGA,MAAM;;IAExB,IAAI,OAAOC,MAAM,IAAI,QAAQ,IAAI,OAAOA,MAAM,IAAI,SAAS,EAAE;MACzDA,MAAM,GAAG,EAAE,GAAGA,MAAM;;IAGxB,OAAOD,MAAM,KAAKC,MAAM;EAC5B;EAEA;;;;;;;EAOAC,gBAAgBA,CAACrO,GAA4B;IACzC,OAAOmI,IAAI,CAACC,SAAS,CAAC,IAAI,CAACkG,cAAc,CAACtO,GAAG,CAAC,CAAC;EACnD;EAEA;;;;;;EAMAsO,cAAcA,CAAItO,GAAM;IACpB,IAAIA,GAAG,IAAI,IAAI,IAAI,OAAOA,GAAG,IAAI,QAAQ,IAAI,CAACxC,KAAK,CAACC,OAAO,CAACuC,GAAG,CAAC,EAAE;MAC9D;MACA,OAAOd,MAAM,CAACgE,IAAI,CAAClD,GAAG,CAAC,CAACuD,IAAI,EAAE,CAACgL,MAAM,CAAC,CAACC,WAAW,EAAE3T,GAAG,KAAI;QACvD;QACA2T,WAAW,CAAC3T,GAAG,CAAC,GAAG,IAAI,CAACyT,cAAc,CAACtO,GAAG,CAACnF,GAAG,CAAC,CAAC;QAEhD,OAAO2T,WAAW;MACtB,CAAC,EAAE,EAAO,CAAC;KACd,MAAM;MACH,OAAOxO,GAAG;;EAElB;EAEA;;;;;;EAMAyO,UAAUA,CAAIzO,GAAM;IAChB,IAAI,OAAOA,GAAG,IAAI,QAAQ,IAAI,CAACxC,KAAK,CAACC,OAAO,CAACuC,GAAG,CAAC,EAAE;MAC/C;MACA,MAAMvF,KAAK,GAAG,IAAI,CAACsR,sBAAsB,CAAC/L,GAA8B,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC;MAEvG,OAAO,IAAI,CAACyM,mBAAmB,CAAChS,KAAK,EAAE,MAAM,EAAE,OAAO,CAAiB;KAC1E,MAAM;MACH,OAAOuF,GAAG;;EAElB;EAEA;;;;;;;;EAQArD,cAAcA,CAAIhD,OAAmB,EAAE+U,IAAY;IAC/C,OAAO,IAAI1U,OAAO,CAAC,CAACyF,OAAO,EAAEkP,MAAM,KAAU;MACzC,IAAIC,QAAQ,GAAG,KAAK;MACpB,MAAMC,oBAAoB,GAAIlT,KAAQ,IAAI;QACtC,IAAIiT,QAAQ,EAAE;UACV;;QAEJnP,OAAO,CAAC9D,KAAK,CAAC;MAClB,CAAC;MACD,MAAMmB,OAAO,GAAGgS,UAAU,CACtB,MAAK;QACDH,MAAM,CAAC;UAAE7R,OAAO,EAAE;QAAI,CAAE,CAAC;QACzB8R,QAAQ,GAAG,IAAI;MACnB,CAAC,EACDF,IAAI,CACP;MAED/U,OAAO,CACF0H,IAAI,CAACwN,oBAAoB,CAAC,CAC1BE,KAAK,CAACJ,MAAM,CAAC,CACbhP,OAAO,CAAC,MAAMqP,YAAY,CAAClS,OAAO,CAAC,CAAC;IAC7C,CAAC,CAAC;EACN;EAEA;;;;;;;;;EASAmS,aAAaA,CAACC,WAA+C,EAAEC,MAAgB;IAC3E;IACA,IAAID,WAAW,KAAKjU,SAAS,EAAE;MAC3B,OAAO,KAAK;;IAGhB;IACA,IAAIiU,WAAW,IAAI,IAAI,EAAE;MACrB,OAAO,EAAE;;IAGb;IACAA,WAAW,GAAGxN,MAAM,CAACwN,WAAW,CAAC;IACjCA,WAAW,GAAGA,WAAW,CAAC/I,IAAI,EAAE;IAEhC,IAAI+I,WAAW,IAAI,EAAE,EAAE;MACnB,OAAO,EAAE;;IAGbA,WAAW,GAAGA,WAAW,CAACvN,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;IAC5CuN,WAAW,GAAGA,WAAW,CAACvN,OAAO,CAACtK,SAAS,CAAC+B,OAAO,CAAC,aAAa,CAAC,EAAE,GAAG,CAAC;IAExE;IACA;IACA,MAAMgW,WAAW,GAAGpH,MAAM,CAACkH,WAAW,CAAC;IAEvC;IACA,IAAIC,MAAM,KAAK,CAACE,QAAQ,CAACD,WAAW,CAAC,IAAIrT,KAAK,CAACqT,WAAW,CAAC,CAAC,EAAE;MAC1D,OAAO,KAAK;;IAGhB,OAAOA,WAAW;EACtB;EAEA;;;;;;;EAOA5I,WAAWA,CAAI/L,KAAU,EAAEI,GAAY;IACnC,MAAMyU,MAAM,GAAG,EAAE,CAAC,CAAC;IAEnB,OAAO7U,KAAK,CAAC+F,MAAM,CAAC5F,KAAK,IAAG;MACxB,MAAMe,KAAK,GAAGd,GAAG,GAAGD,KAAK,CAACC,GAAG,CAAC,GAAGD,KAAK;MAEtC,IAAIe,KAAK,IAAI2T,MAAM,EAAE;QACjB,OAAO,KAAK;;MAGhBA,MAAM,CAAC3T,KAAK,CAAC,GAAG,IAAI;MAEpB,OAAO,IAAI;IACf,CAAC,CAAC;EACN;EAEA;;;;;;;EAOA4T,QAAQA,CAAsBC,EAA2B,EAAEC,KAAa;IACpE,IAAIC,SAAiB;IAErB,MAAMC,SAAS,GAAGA,CAAC,GAAG5O,IAAO,KAAU;MACnCiO,YAAY,CAACU,SAAS,CAAC;MAEvBA,SAAS,GAAGvT,MAAM,CAAC2S,UAAU,CAAC,MAAMU,EAAE,CAAC3V,KAAK,CAAC,IAAI,EAAEkH,IAAI,CAAC,EAAE0O,KAAK,CAAC;IACpE,CAAC;IAED,OAAOE,SAAS;EACpB;EAEA;;;;;;;EAOAC,QAAQA,CAAsBJ,EAA2B,EAAEK,QAAgB;IACvE,IAAIC,UAAU,GAAG,KAAK;IAEtB,MAAMC,SAAS,GAAGA,CAAC,GAAGhP,IAAO,KAAU;MACnC,IAAI,CAAC+O,UAAU,EAAE;QACbN,EAAE,CAAC3V,KAAK,CAAC,IAAI,EAAEkH,IAAI,CAAC;QAEpB+O,UAAU,GAAG,IAAI;QAEjBhB,UAAU,CAAC,MAAK;UACZgB,UAAU,GAAG,KAAK;QACtB,CAAC,EAAED,QAAQ,CAAC;;IAEpB,CAAC;IAED,OAAOE,SAAS;EACpB;EAEA;;;;;EAKAC,SAASA,CAAA;IACL,OAAOlY,YAAY,CAACkR,QAAQ,EAAE;EAClC;EAEA;;;;;;EAMMiH,MAAMA,CAACC,KAAc;IAAA,OAAA3W,iBAAA;MACvB,OAAO1C,YAAY,CAACsZ,SAAS,CAAS;QAClCC,SAAS,EAAE5Y,4BAA4B;QACvC6Y,QAAQ,EAAE,uBAAuB;QACjCC,cAAc,EAAE;UACZJ;;OAEP,CAAC;IAAC;EACP;EAEA;;;;;EAKMK,WAAWA,CAAA;IAAA,IAAAC,MAAA;IAAA,OAAAjX,iBAAA;MACb,IAAI,CAACzB,YAAY,CAACkR,QAAQ,EAAE,EAAE;QAC1B,OAAOhP,OAAO,CAAC2U,MAAM,CAAC,wCAAwC,CAAC;;MAGnE;MACA;MACA,IAAI;QACA,MAAMhJ,MAAM,SAASrN,SAAS,CAACmY,OAAO,EAAE;QAExC,IAAI,CAAC9K,MAAM,CAAC+K,UAAU,EAAE;UACpB;UACA,MAAM,IAAIxM,KAAK,CAAC,gCAAgC,CAAC;;QAGrD,IAAIsM,MAAI,CAACG,UAAU,IAAIH,MAAI,CAACG,UAAU,CAACC,QAAQ,EAAE;UAC7C;UACA,OAAOJ,MAAI,CAACG,UAAU,CAACC,QAAQ;;QAGnC;QACAJ,MAAI,CAACG,UAAU,GAAG;UACdC,QAAQ,EAAE,IAAI/Y,iBAAiB,EAAE;UAEjC;UACAgZ,UAAU,EAAEvY,SAAS,CAACwY,IAAI,EAAE,CAAC1H,SAAS,CAAChL,IAAI,IAAIoS,MAAI,CAACO,UAAU,CAAC3S,IAAI,EAAE,KAAK,CAAC;SAC9E;QAED;QACA,IAAI;UACA,MAAM9F,SAAS,CAAC0Y,IAAI,EAAE;UAEtBxS,QAAQ,CAACyS,IAAI,CAACC,SAAS,CAACC,GAAG,CAAC,kBAAkB,CAAC;UAE/C;UACA,MAAMC,eAAe,GAAG5S,QAAQ,CAAC6S,aAAa,CAAC,2BAA2B,CAAC;UAC3E,IAAID,eAAe,EAAE;YACjBZ,MAAI,CAAC7X,yBAAyB,GAAGyY,eAAe,CAACE,YAAY,CAAC,SAAS,CAAC,IAAId,MAAI,CAAC7X,yBAAyB;YAC1GyY,eAAe,CAACG,YAAY,CAAC,SAAS,EAAE,QAAQ,CAAC;;UAGrD,OAAOf,MAAI,CAACG,UAAU,CAACC,QAAQ;SAClC,CAAC,OAAO/Q,CAAC,EAAE;UACR2Q,MAAI,CAACO,UAAU,CAAClR,CAAC,EAAE,IAAI,CAAC;UAExB,MAAMA,CAAC;;OAEd,CAAC,OAAO9G,KAAK,EAAE;QACZ;QACAA,KAAK,CAACgC,OAAO,GAAGhC,KAAK,CAACgC,OAAO,IAAKhC,KAA+B,CAACyY,QAAQ;QAE1E,MAAMzY,KAAK;;IACd;EACL;EAEA;;;;;;EAMAgY,UAAUA,CAACrR,IAAqB,EAAE3G,KAAe;IAAA,IAAA0Y,qBAAA;IAC7C,IAAI,CAAC,IAAI,CAACd,UAAU,EAAE;MAClB;MACA;;IAGJ;IACAnS,QAAQ,CAACyS,IAAI,CAACC,SAAS,CAACQ,MAAM,CAAC,kBAAkB,CAAC;IAElD;IACA,CAAAD,qBAAA,GAAAjT,QAAQ,CAAC6S,aAAa,CAAC,2BAA2B,CAAC,cAAAI,qBAAA,eAAnDA,qBAAA,CAAqDF,YAAY,CAAC,SAAS,EAAE,IAAI,CAAC5Y,yBAAyB,CAAC;IAE5GL,SAAS,CAACqZ,IAAI,EAAE;IAChBrZ,SAAS,CAACsZ,OAAO,EAAE;IAEnB,IAAI,CAACjB,UAAU,CAACE,UAAU,CAAC9G,WAAW,EAAE,CAAC,CAAC;IAE1C,IAAIhR,KAAK,EAAE;MACP,IAAI,CAAC4X,UAAU,CAACC,QAAQ,CAACjC,MAAM,CAAC,OAAOjP,IAAI,KAAK,QAAQ,GAAG,IAAIwE,KAAK,CAACxE,IAAI,CAAC,GAAGA,IAAI,CAAC;KACrF,MAAM,IAAIA,IAAI,KAAKzE,SAAS,EAAE;MAC3B,IAAI,CAAC0V,UAAU,CAACC,QAAQ,CAACnR,OAAO,CAACC,IAAc,CAAC;KACnD,MAAM;MACH,IAAI,CAACiR,UAAU,CAACC,QAAQ,CAACjC,MAAM,CAAC,IAAIlX,iBAAiB,EAAE,CAAC;;IAG5D,OAAO,IAAI,CAACkZ,UAAU;EAC1B;EAWMpW,YAAYA,CAAmBZ,OAAyB,EAAEkY,QAAmB;IAAA,OAAAtY,iBAAA;MAC/E,IAAI;QACA,MAAMoB,MAAM,SAAShB,OAAO;QAE5B,OAAOgB,MAAM;OAChB,CAAC,OAAAmX,QAAA,EAAM;QACJ;QACA,OAAOD,QAAQ;;IAClB;EACL;EAEA;;;;;;EAMAE,IAAIA,CAACC,YAAoB;IACrB,OAAO,IAAIhY,OAAO,CAACyF,OAAO,IAAIqP,UAAU,CAACrP,OAAO,EAAEuS,YAAY,CAAC,CAAC;EACpE;EAEA;;;;;;EAMAC,OAAOA,CAACC,SAAwB,EAAEC,QAAA,GAAmB,EAAE;IACnD,IAAID,SAAS,EAAE,EAAE;MACb,OAAOha,sBAAsB,CAACuH,OAAO,EAAE;;IAG3C,IAAI2S,UAA8B;IAElC,OAAO,IAAIla,sBAAsB;MAAA,IAAAma,KAAA,GAAA9Y,iBAAA,CAC7B,WAAOkG,OAAO,EAAI;QACd2S,UAAU,GAAGjW,MAAM,CAACmW,WAAW,CAAC,MAAK;UACjC,IAAI,CAACJ,SAAS,EAAE,EAAE;YACd;;UAGJzS,OAAO,EAAE;UACTtD,MAAM,CAACoW,aAAa,CAACH,UAAU,CAAC;QACpC,CAAC,EAAED,QAAQ,CAAC;MAChB,CAAC;MAAA,iBAAAK,GAAA;QAAA,OAAAH,KAAA,CAAAxY,KAAA,OAAAC,SAAA;MAAA;IAAA,KACD,MAAMqC,MAAM,CAACoW,aAAa,CAACH,UAAU,CAAC,CACzC;EACL;EAEA;;;;;EAKAK,QAAQA,CAAA;IACJ,OAAO,IAAI,CAACV,IAAI,CAAC,CAAC,CAAC;EACvB;EAEA;;;EAGMW,SAASA,CAACC,QAAQ,GAAG,CAAC;IAAA,IAAAC,OAAA;IAAA,OAAArZ,iBAAA;MACxB,KAAK,IAAIoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgV,QAAQ,EAAEhV,CAAC,EAAE,EAAE;QAC/B,MAAMiV,OAAI,CAACb,IAAI,CAAC,CAAC,CAAC;;IACrB;EACL;EAEA;;;;;;EAMAnK,oBAAoBA,CAACf,OAAA,GAAoC,EAAE;IAAA,IAAAgM,qBAAA;IACvD,MAAMC,cAAc,IAAAD,qBAAA,GAAGhM,OAAO,CAACkM,iBAAiB,cAAAF,qBAAA,cAAAA,qBAAA,GAAInb,aAAa,CAACgT,MAAM,CAACsI,wBAAwB;IAEjG,OAAOlb,YAAY,CAAC+Q,KAAK,EAAE,IAAIiK,cAAc,IAAIG,cAAc,CAACC,SAAS;EAC7E;;SAnyDS3a,iBAAiB;;mBAAjBA,MAAiB;AAAA;;SAAjBA,MAAiB;EAAA4a,OAAA,EAAjB5a,MAAiB,CAAA6a,IAAA;EAAAC,UAAA,EADJ;AAAM;AAwyDhC,OAAO,MAAM/Y,SAAS,GAAGtD,aAAa,CAACuB,iBAAiB,CAAC;AA2DzD;;;AAGA,WAAY0a,cAGX;AAHD,WAAYA,cAAc;EACtBA,cAAA,iBAAa;EACbA,cAAA,2BAAuB;AAC3B,CAAC,EAHWA,cAAc,KAAdA,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}