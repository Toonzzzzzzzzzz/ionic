{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class, _class2;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreTextUtils } from '@services/utils/text';\nimport { FileTransfer, FileTransferObject } from '@awesome-cordova-plugins/file-transfer/ngx';\nimport { CoreFile } from '@services/file';\nimport * as i0 from \"@angular/core\";\n/**\n * Mock the File Transfer Error.\n */\nexport class FileTransferErrorMock {\n  constructor(code, source, target, http_status, body, exception) {\n    this.code = code;\n    this.source = source;\n    this.target = target;\n    this.http_status = http_status;\n    this.body = body;\n    this.exception = exception;\n  }\n}\n/**\n * Emulates the Cordova FileTransfer plugin in desktop apps and in browser.\n */\n_class = FileTransferErrorMock;\n_class.FILE_NOT_FOUND_ERR = 1;\n_class.INVALID_URL_ERR = 2;\n_class.CONNECTION_ERR = 3;\n_class.ABORT_ERR = 4;\n_class.NOT_MODIFIED_ERR = 5;\nexport class FileTransferMock extends FileTransfer {\n  /**\n   * Creates a new FileTransferObjectMock object.\n   *\n   * @returns a new file transfer mock.\n   */\n  create() {\n    return new FileTransferObjectMock();\n  }\n}\n/**\n * Emulates the FileTransferObject class in desktop apps and in browser.\n */\n_class2 = FileTransferMock;\n_class2.ɵfac = /*@__PURE__*/function () {\n  let ɵFileTransferMock_BaseFactory;\n  return function FileTransferMock_Factory(t) {\n    return (ɵFileTransferMock_BaseFactory || (ɵFileTransferMock_BaseFactory = i0.ɵɵgetInheritedFactory(_class2)))(t || _class2);\n  };\n}();\n_class2.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class2,\n  factory: _class2.ɵfac\n});\nexport class FileTransferObjectMock extends FileTransferObject {\n  /**\n   * Aborts an in-progress transfer. The onerror callback is passed a FileTransferError\n   * object which has an error code of FileTransferError.ABORT_ERR.\n   */\n  abort() {\n    if (this.xhr) {\n      var _this$reject;\n      this.xhr.abort();\n      (_this$reject = this.reject) === null || _this$reject === void 0 || _this$reject.call(this, new FileTransferErrorMock(FileTransferErrorMock.ABORT_ERR, this.source || '', this.target || '', 0, '', ''));\n    }\n  }\n  /**\n   * Downloads a file from server.\n   *\n   * @param source URL of the server to download the file, as encoded by encodeURI().\n   * @param target Filesystem url representing the file on the device.\n   * @param trustAllHosts If set to true, it accepts all security certificates.\n   * @param options Optional parameters, currently only supports headers.\n   * @returns Returns a Promise that resolves to a FileEntry object.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  download(source, target, trustAllHosts, options) {\n    var _this = this;\n    return new Promise((resolve, reject) => {\n      var _options;\n      // Use XMLHttpRequest instead of HttpClient to support onprogress and abort.\n      const basicAuthHeader = this.getBasicAuthHeader(source);\n      const xhr = new XMLHttpRequest();\n      this.xhr = xhr;\n      this.source = source;\n      this.target = target;\n      this.reject = reject;\n      if (basicAuthHeader) {\n        source = source.replace(this.getUrlCredentials(source) + '@', '');\n        options = options || {};\n        options.headers = options.headers || {};\n        options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n      }\n      const headers = ((_options = options) === null || _options === void 0 ? void 0 : _options.headers) || null;\n      // Prepare the request.\n      xhr.open('GET', source, true);\n      xhr.responseType = 'blob';\n      for (const name in headers) {\n        // We can't set the User-Agent in browser.\n        if (name !== 'User-Agent') {\n          xhr.setRequestHeader(name, headers[name]);\n        }\n      }\n      xhr.onprogress = ev => {\n        if (this.progressListener) {\n          this.progressListener(ev);\n        }\n      };\n      xhr.onerror = () => {\n        reject(new FileTransferErrorMock(-1, source, target, xhr.status, xhr.statusText, ''));\n      };\n      xhr.onload = /*#__PURE__*/_asyncToGenerator(function* () {\n        // Finished dowloading the file.\n        let response = xhr.response || xhr.responseText;\n        const status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);\n        if (status < 200 || status >= 300) {\n          // Request failed. Try to get the error message.\n          response = yield _this.parseResponse(response);\n          reject(new FileTransferErrorMock(-1, source, target, xhr.status, response || xhr.statusText, ''));\n          return;\n        }\n        if (!response) {\n          reject();\n          return;\n        }\n        const basePath = CoreFile.getBasePathInstant();\n        target = target.replace(basePath, ''); // Remove basePath from the target.\n        target = target.replace(/%20/g, ' '); // Replace all %20 with spaces.\n        // eslint-disable-next-line promise/catch-or-return\n        CoreFile.writeFile(target, response).then(resolve, reject);\n      });\n      xhr.send();\n    });\n  }\n  /**\n   * Given a URL, check if it has a credentials in it and, if so, return them in a header object.\n   * This code is extracted from Cordova FileTransfer plugin.\n   *\n   * @param urlString The URL to get the credentials from.\n   * @returns The header with the credentials, null if no credentials.\n   */\n  getBasicAuthHeader(urlString) {\n    let header = null;\n    // MS Windows doesn't support credentials in http uris so we detect them by regexp and strip off from result url.\n    if (window.btoa) {\n      const credentials = this.getUrlCredentials(urlString);\n      if (credentials) {\n        header = {\n          name: 'Authorization',\n          value: 'Basic ' + window.btoa(credentials)\n        };\n      }\n    }\n    return header;\n  }\n  /**\n   * Given an instance of XMLHttpRequest, get the response headers as an object.\n   *\n   * @param xhr XMLHttpRequest instance.\n   * @returns Object with the headers.\n   */\n  getHeadersAsObject(xhr) {\n    const headersString = xhr.getAllResponseHeaders();\n    const result = {};\n    if (headersString) {\n      const headers = headersString.split('\\n');\n      for (const i in headers) {\n        const headerString = headers[i];\n        const separatorPos = headerString.indexOf(':');\n        if (separatorPos != -1) {\n          result[headerString.substring(0, separatorPos)] = headerString.substring(separatorPos + 1).trim();\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Get the credentials from a URL.\n   * This code is extracted from Cordova FileTransfer plugin.\n   *\n   * @param urlString The URL to get the credentials from.\n   * @returns Retrieved credentials.\n   */\n  getUrlCredentials(urlString) {\n    const credentialsPattern = /^https?:\\/\\/(?:(?:(([^:@/]*)(?::([^@/]*))?)?@)?([^:/?#]*)(?::(\\d*))?).*$/;\n    const credentials = credentialsPattern.exec(urlString);\n    return credentials && credentials[1];\n  }\n  /**\n   * Registers a listener that gets called whenever a new chunk of data is transferred.\n   *\n   * @param listener Listener that takes a progress event.\n   */\n  onProgress(listener) {\n    this.progressListener = listener;\n  }\n  /**\n   * Parse a response, converting it into text and the into an object if needed.\n   *\n   * @param response The response to parse.\n   * @returns Promise resolved with the parsed response.\n   */\n  parseResponse(response) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!response) {\n        return '';\n      }\n      let responseText = '';\n      if (response instanceof Blob) {\n        responseText = yield _this2.blobToText(response);\n      } else if (response instanceof ArrayBuffer) {\n        // Convert the ArrayBuffer into text.\n        responseText = String.fromCharCode.apply(null, new Uint8Array(response));\n      } else {\n        responseText = response;\n      }\n      return CoreTextUtils.parseJSON(responseText, '');\n    })();\n  }\n  /**\n   * Convert a Blob to text.\n   *\n   * @param blob Blob to convert.\n   * @returns Promise resolved with blob contents.\n   */\n  blobToText(blob) {\n    return new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        resolve(reader.result);\n      };\n      reader.readAsText(blob);\n    });\n  }\n  /**\n   * Sends a file to a server.\n   *\n   * @param fileUrl Filesystem URL representing the file on the device or a data URI.\n   * @param url URL of the server to receive the file, as encoded by encodeURI().\n   * @param options Optional parameters.\n   * @returns Promise that resolves to a FileUploadResult and rejects with FileTransferError.\n   */\n  upload(fileUrl, url, options) {\n    return new Promise((resolve, reject) => {\n      const basicAuthHeader = this.getBasicAuthHeader(url);\n      let fileKey;\n      let fileName;\n      let params; // eslint-disable-line @typescript-eslint/no-explicit-any\n      let headers; // eslint-disable-line @typescript-eslint/no-explicit-any\n      let httpMethod;\n      if (basicAuthHeader) {\n        url = url.replace(this.getUrlCredentials(url) + '@', '');\n        options = options || {};\n        options.headers = options.headers || {};\n        options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n      }\n      if (options) {\n        fileKey = options.fileKey;\n        fileName = options.fileName;\n        headers = options.headers;\n        httpMethod = options.httpMethod || 'POST';\n        if (httpMethod.toUpperCase() == 'PUT') {\n          httpMethod = 'PUT';\n        } else {\n          httpMethod = 'POST';\n        }\n        params = options.params || {};\n      }\n      // Add fileKey and fileName to the headers.\n      headers = headers || {};\n      if (!headers['Content-Disposition']) {\n        headers['Content-Disposition'] = 'form-data;' + (fileKey ? ' name=\"' + fileKey + '\";' : '') + (fileName ? ' filename=\"' + fileName + '\"' : '');\n      }\n      // Adding a Content-Type header with the mimeType makes the request fail (it doesn't detect the token in the params).\n      // Don't include this header, and delete it if it's supplied.\n      delete headers['Content-Type'];\n      // Get the file to upload.\n      CoreFile.getFile(fileUrl).then(fileEntry => CoreFile.getFileObjectFromFileEntry(fileEntry)).then(file => {\n        // Use XMLHttpRequest instead of HttpClient to support onprogress and abort.\n        const xhr = new XMLHttpRequest();\n        xhr.open(httpMethod || 'POST', url);\n        for (const name in headers) {\n          // Filter \"unsafe\" headers.\n          if (name !== 'Connection' && name !== 'User-Agent') {\n            xhr.setRequestHeader(name, headers[name]);\n          }\n        }\n        xhr.onprogress = ev => {\n          if (this.progressListener) {\n            this.progressListener(ev);\n          }\n        };\n        this.xhr = xhr;\n        this.source = fileUrl;\n        this.target = url;\n        this.reject = reject;\n        xhr.onerror = () => {\n          reject(new FileTransferErrorMock(-1, fileUrl, url, xhr.status, xhr.statusText, ''));\n        };\n        xhr.onload = () => {\n          // Finished uploading the file.\n          resolve({\n            bytesSent: file.size,\n            responseCode: xhr.status,\n            response: xhr.response,\n            headers: this.getHeadersAsObject(xhr)\n          });\n        };\n        // Create a form data to send params and the file.\n        const fd = new FormData();\n        for (const name in params) {\n          fd.append(name, params[name]);\n        }\n        fd.append('file', file, fileName);\n        xhr.send(fd);\n        return;\n      }).catch(reject);\n    });\n  }\n}","map":{"version":3,"names":["CoreTextUtils","FileTransfer","FileTransferObject","CoreFile","FileTransferErrorMock","constructor","code","source","target","http_status","body","exception","_class","FILE_NOT_FOUND_ERR","INVALID_URL_ERR","CONNECTION_ERR","ABORT_ERR","NOT_MODIFIED_ERR","FileTransferMock","create","FileTransferObjectMock","_class2","t","factory","ɵfac","abort","xhr","_this$reject","reject","call","download","trustAllHosts","options","_this","Promise","resolve","_options","basicAuthHeader","getBasicAuthHeader","XMLHttpRequest","replace","getUrlCredentials","headers","name","value","open","responseType","setRequestHeader","onprogress","ev","progressListener","onerror","status","statusText","onload","_asyncToGenerator","response","responseText","Math","max","parseResponse","basePath","getBasePathInstant","writeFile","then","send","urlString","header","window","btoa","credentials","getHeadersAsObject","headersString","getAllResponseHeaders","result","split","i","headerString","separatorPos","indexOf","substring","trim","credentialsPattern","exec","onProgress","listener","_this2","Blob","blobToText","ArrayBuffer","String","fromCharCode","apply","Uint8Array","parseJSON","blob","reader","FileReader","onloadend","readAsText","upload","fileUrl","url","fileKey","fileName","params","httpMethod","toUpperCase","getFile","fileEntry","getFileObjectFromFileEntry","file","bytesSent","size","responseCode","fd","FormData","append","catch"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/emulator/services/file-transfer.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreTextUtils } from '@services/utils/text';\nimport { Injectable } from '@angular/core';\nimport { FileTransfer, FileTransferObject, FileUploadResult, FileTransferError } from '@awesome-cordova-plugins/file-transfer/ngx';\n\nimport { CoreFile } from '@services/file';\n\n/**\n * Mock the File Transfer Error.\n */\nexport class FileTransferErrorMock implements FileTransferError {\n\n    static readonly FILE_NOT_FOUND_ERR = 1;\n    static readonly INVALID_URL_ERR = 2;\n    static readonly CONNECTION_ERR = 3;\n    static readonly ABORT_ERR = 4;\n    static readonly NOT_MODIFIED_ERR = 5;\n\n    constructor(\n        public code: number,\n        public source: string,\n        public target: string,\n        public http_status: number,\n        public body: string,\n        public exception: string,\n    ) { }\n\n}\n\n/**\n * Emulates the Cordova FileTransfer plugin in desktop apps and in browser.\n */\n@Injectable()\nexport class FileTransferMock extends FileTransfer {\n\n    /**\n     * Creates a new FileTransferObjectMock object.\n     *\n     * @returns a new file transfer mock.\n     */\n    create(): FileTransferObjectMock {\n        return new FileTransferObjectMock();\n    }\n\n}\n\n/**\n * Emulates the FileTransferObject class in desktop apps and in browser.\n */\nexport class FileTransferObjectMock extends FileTransferObject {\n\n    progressListener?: (event: ProgressEvent) => void;\n    source?: string;\n    target?: string;\n    xhr?: XMLHttpRequest;\n\n    protected reject?: (reason?: unknown) => void;\n\n    /**\n     * Aborts an in-progress transfer. The onerror callback is passed a FileTransferError\n     * object which has an error code of FileTransferError.ABORT_ERR.\n     */\n    abort(): void {\n        if (this.xhr) {\n            this.xhr.abort();\n            this.reject?.(\n                new FileTransferErrorMock(FileTransferErrorMock.ABORT_ERR, this.source || '', this.target || '', 0, '', ''),\n            );\n        }\n    }\n\n    /**\n     * Downloads a file from server.\n     *\n     * @param source URL of the server to download the file, as encoded by encodeURI().\n     * @param target Filesystem url representing the file on the device.\n     * @param trustAllHosts If set to true, it accepts all security certificates.\n     * @param options Optional parameters, currently only supports headers.\n     * @returns Returns a Promise that resolves to a FileEntry object.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    download(source: string, target: string, trustAllHosts?: boolean, options?: { [s: string]: any }): Promise<unknown> {\n        return new Promise((resolve, reject): void => {\n            // Use XMLHttpRequest instead of HttpClient to support onprogress and abort.\n            const basicAuthHeader = this.getBasicAuthHeader(source);\n            const xhr = new XMLHttpRequest();\n\n            this.xhr = xhr;\n            this.source = source;\n            this.target = target;\n            this.reject = reject;\n\n            if (basicAuthHeader) {\n                source = source.replace(this.getUrlCredentials(source) + '@', '');\n\n                options = options || {};\n                options.headers = options.headers || {};\n                options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n            }\n\n            const headers = options?.headers || null;\n\n            // Prepare the request.\n            xhr.open('GET', source, true);\n            xhr.responseType = 'blob';\n            for (const name in headers) {\n                // We can't set the User-Agent in browser.\n                if (name !== 'User-Agent') {\n                    xhr.setRequestHeader(name, headers[name]);\n                }\n            }\n\n            xhr.onprogress = (ev: ProgressEvent): void => {\n                if (this.progressListener) {\n                    this.progressListener(ev);\n                }\n            };\n\n            xhr.onerror = (): void => {\n                reject(new FileTransferErrorMock(-1, source, target, xhr.status, xhr.statusText, ''));\n            };\n\n            xhr.onload = async (): Promise<void> => {\n                // Finished dowloading the file.\n                let response = xhr.response || xhr.responseText;\n\n                const status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);\n                if (status < 200 || status >= 300) {\n                    // Request failed. Try to get the error message.\n                    response = await this.parseResponse(response);\n\n                    reject(new FileTransferErrorMock(-1, source, target, xhr.status, response || xhr.statusText, ''));\n\n                    return;\n                }\n\n                if (!response) {\n                    reject();\n\n                    return;\n                }\n\n                const basePath = CoreFile.getBasePathInstant();\n                target = target.replace(basePath, ''); // Remove basePath from the target.\n                target = target.replace(/%20/g, ' '); // Replace all %20 with spaces.\n\n                // eslint-disable-next-line promise/catch-or-return\n                CoreFile.writeFile(target, response).then(resolve, reject);\n            };\n\n            xhr.send();\n        });\n    }\n\n    /**\n     * Given a URL, check if it has a credentials in it and, if so, return them in a header object.\n     * This code is extracted from Cordova FileTransfer plugin.\n     *\n     * @param urlString The URL to get the credentials from.\n     * @returns The header with the credentials, null if no credentials.\n     */\n    protected getBasicAuthHeader(urlString: string): {name: string; value: string} | null {\n        let header: {name: string; value: string} | null = null;\n\n        // MS Windows doesn't support credentials in http uris so we detect them by regexp and strip off from result url.\n        if (window.btoa) {\n            const credentials = this.getUrlCredentials(urlString);\n            if (credentials) {\n                header = {\n                    name: 'Authorization',\n                    value: 'Basic ' + window.btoa(credentials),\n                };\n            }\n        }\n\n        return header;\n    }\n\n    /**\n     * Given an instance of XMLHttpRequest, get the response headers as an object.\n     *\n     * @param xhr XMLHttpRequest instance.\n     * @returns Object with the headers.\n     */\n    protected getHeadersAsObject(xhr: XMLHttpRequest): Record<string, string> {\n        const headersString = xhr.getAllResponseHeaders();\n        const result = {};\n\n        if (headersString) {\n            const headers = headersString.split('\\n');\n            for (const i in headers) {\n                const headerString = headers[i];\n                const separatorPos = headerString.indexOf(':');\n                if (separatorPos != -1) {\n                    result[headerString.substring(0, separatorPos)] = headerString.substring(separatorPos + 1).trim();\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the credentials from a URL.\n     * This code is extracted from Cordova FileTransfer plugin.\n     *\n     * @param urlString The URL to get the credentials from.\n     * @returns Retrieved credentials.\n     */\n    protected getUrlCredentials(urlString: string): string | null {\n        const credentialsPattern = /^https?:\\/\\/(?:(?:(([^:@/]*)(?::([^@/]*))?)?@)?([^:/?#]*)(?::(\\d*))?).*$/;\n        const credentials = credentialsPattern.exec(urlString);\n\n        return credentials && credentials[1];\n    }\n\n    /**\n     * Registers a listener that gets called whenever a new chunk of data is transferred.\n     *\n     * @param listener Listener that takes a progress event.\n     */\n    onProgress(listener: (event: ProgressEvent) => void): void {\n        this.progressListener = listener;\n    }\n\n    /**\n     * Parse a response, converting it into text and the into an object if needed.\n     *\n     * @param response The response to parse.\n     * @returns Promise resolved with the parsed response.\n     */\n    protected async parseResponse(response: Blob | ArrayBuffer | string | null): Promise<unknown> {\n        if (!response) {\n            return '';\n\n        }\n\n        let responseText = '';\n\n        if (response instanceof Blob) {\n            responseText = await this.blobToText(response);\n\n        } else if (response instanceof ArrayBuffer) {\n            // Convert the ArrayBuffer into text.\n            responseText = String.fromCharCode.apply(null, new Uint8Array(response));\n\n        } else {\n            responseText = response;\n        }\n\n        return CoreTextUtils.parseJSON(responseText, '');\n    }\n\n    /**\n     * Convert a Blob to text.\n     *\n     * @param blob Blob to convert.\n     * @returns Promise resolved with blob contents.\n     */\n    protected blobToText(blob: Blob): Promise<string> {\n        return new Promise<string>((resolve) => {\n            const reader = new FileReader();\n            reader.onloadend = (): void => {\n                resolve(<string> reader.result);\n            };\n            reader.readAsText(blob);\n        });\n    }\n\n    /**\n     * Sends a file to a server.\n     *\n     * @param fileUrl Filesystem URL representing the file on the device or a data URI.\n     * @param url URL of the server to receive the file, as encoded by encodeURI().\n     * @param options Optional parameters.\n     * @returns Promise that resolves to a FileUploadResult and rejects with FileTransferError.\n     */\n    upload(fileUrl: string, url: string, options?: FileUploadOptions): Promise<FileUploadResult> {\n        return new Promise((resolve, reject): void => {\n            const basicAuthHeader = this.getBasicAuthHeader(url);\n            let fileKey: string | undefined;\n            let fileName: string | undefined;\n            let params: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n            let headers: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n            let httpMethod: string | undefined;\n\n            if (basicAuthHeader) {\n                url = url.replace(this.getUrlCredentials(url) + '@', '');\n\n                options = options || {};\n                options.headers = options.headers || {};\n                options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n            }\n\n            if (options) {\n                fileKey = options.fileKey;\n                fileName = options.fileName;\n                headers = options.headers;\n                httpMethod = options.httpMethod || 'POST';\n\n                if (httpMethod.toUpperCase() == 'PUT') {\n                    httpMethod = 'PUT';\n                } else {\n                    httpMethod = 'POST';\n                }\n\n                params = options.params || {};\n            }\n\n            // Add fileKey and fileName to the headers.\n            headers = headers || {};\n            if (!headers['Content-Disposition']) {\n                headers['Content-Disposition'] = 'form-data;' + (fileKey ? ' name=\"' + fileKey + '\";' : '') +\n                    (fileName ? ' filename=\"' + fileName + '\"' : '');\n            }\n\n            // Adding a Content-Type header with the mimeType makes the request fail (it doesn't detect the token in the params).\n            // Don't include this header, and delete it if it's supplied.\n            delete headers['Content-Type'];\n\n            // Get the file to upload.\n            CoreFile.getFile(fileUrl).then((fileEntry) =>\n                CoreFile.getFileObjectFromFileEntry(fileEntry)).then((file) => {\n                // Use XMLHttpRequest instead of HttpClient to support onprogress and abort.\n                const xhr = new XMLHttpRequest();\n                xhr.open(httpMethod || 'POST', url);\n                for (const name in headers) {\n                    // Filter \"unsafe\" headers.\n                    if (name !=='Connection' && name !== 'User-Agent') {\n                        xhr.setRequestHeader(name, headers[name]);\n                    }\n                }\n\n                xhr.onprogress = (ev: ProgressEvent): void => {\n                    if (this.progressListener) {\n                        this.progressListener(ev);\n                    }\n                };\n\n                this.xhr = xhr;\n                this.source = fileUrl;\n                this.target = url;\n                this.reject = reject;\n\n                xhr.onerror = (): void => {\n                    reject(new FileTransferErrorMock(-1, fileUrl, url, xhr.status, xhr.statusText, ''));\n                };\n\n                xhr.onload = (): void => {\n                    // Finished uploading the file.\n                    resolve({\n                        bytesSent: file.size,\n                        responseCode: xhr.status,\n                        response: xhr.response,\n                        headers: this.getHeadersAsObject(xhr),\n                    });\n                };\n\n                // Create a form data to send params and the file.\n                const fd = new FormData();\n                for (const name in params) {\n                    fd.append(name, params[name]);\n                }\n                fd.append('file', file, fileName);\n\n                xhr.send(fd);\n\n                return;\n            }).catch(reject);\n        });\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}