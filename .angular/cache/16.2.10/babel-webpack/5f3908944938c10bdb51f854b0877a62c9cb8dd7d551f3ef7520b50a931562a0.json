{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { Subject } from 'rxjs';\nimport { CoreFile, CoreFileProvider } from '@services/file';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFileUploadOptions } from '@services/ws';\nimport { makeSingleton, Translate, MediaCapture, Camera } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CorePath } from '@singletons/path';\nimport { CorePlatform } from '@services/platform';\nimport { CoreModals } from '@services/modals';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to upload files.\n */\nexport class CoreFileUploaderProvider {\n  // 10 MB.\n  constructor() {\n    // Observers to notify when a media file starts/stops being recorded/selected.\n    this.onGetPicture = new Subject();\n    this.onAudioCapture = new Subject();\n    this.onVideoCapture = new Subject();\n    this.logger = CoreLogger.getInstance('CoreFileUploaderProvider');\n  }\n  /**\n   * Add a dot to the beginning of an extension.\n   *\n   * @param extension Extension.\n   * @returns Treated extension.\n   */\n  addDot(extension) {\n    return '.' + extension;\n  }\n  /**\n   * Compares two file lists and returns if they are different.\n   *\n   * @param a First file list.\n   * @param b Second file list.\n   * @returns Whether both lists are different.\n   */\n  areFileListDifferent(a, b) {\n    a = a || [];\n    b = b || [];\n    if (a.length != b.length) {\n      return true;\n    }\n    // Currently we are going to compare the order of the files as well.\n    // This function can be improved comparing more fields or not comparing the order.\n    for (let i = 0; i < a.length; i++) {\n      if (CoreFile.getFileName(a[i]) != CoreFile.getFileName(b[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Check if a certain site allows deleting draft files.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if can delete.\n   * @since 3.10\n   */\n  canDeleteDraftFiles(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const site = yield CoreSites.getSite(siteId);\n        return _this.canDeleteDraftFilesInSite(site);\n      } catch (error) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Check if a certain site allows deleting draft files.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether draft files can be deleted.\n   * @since 3.10\n   */\n  canDeleteDraftFilesInSite(site) {\n    var _site;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site = site) !== null && _site !== void 0 && _site.wsAvailable('core_files_delete_draft_files'));\n  }\n  /**\n   * Start the audio recorder application and return information about captured audio clip files.\n   *\n   * @returns Promise resolved with the result.\n   */\n  captureAudio() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.onAudioCapture.next(true);\n      try {\n        if (!CorePlatform.supportsMediaCapture() || !CorePlatform.supportsWebAssembly()) {\n          const media = yield MediaCapture.captureAudio({\n            limit: 1\n          });\n          return media;\n        }\n        const recording = yield _this2.captureAudioInApp();\n        return [recording];\n      } finally {\n        _this2.onAudioCapture.next(false);\n      }\n    })();\n  }\n  /**\n   * Record an audio file without using an external app.\n   *\n   * @returns Promise resolved with the file.\n   */\n  captureAudioInApp() {\n    return _asyncToGenerator(function* () {\n      const {\n        CoreFileUploaderAudioRecorderComponent\n      } = yield import('@features/fileuploader/components/audio-recorder/audio-recorder.module');\n      const recording = yield CoreModals.openSheet(CoreFileUploaderAudioRecorderComponent);\n      if (!recording) {\n        throw new Error('Recording missing from audio capture');\n      }\n      return recording;\n    })();\n  }\n  /**\n   * Start the video recorder application and return information about captured video clip files.\n   *\n   * @param options Options.\n   * @returns Promise resolved with the result.\n   */\n  captureVideo(options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.onVideoCapture.next(true);\n      try {\n        return yield MediaCapture.captureVideo(options);\n      } finally {\n        _this3.onVideoCapture.next(false);\n      }\n    })();\n  }\n  /**\n   * Clear temporary attachments to be uploaded.\n   * Attachments already saved in an offline store will NOT be deleted, only files in tmp folder will be deleted.\n   *\n   * @param files List of files.\n   */\n  clearTmpFiles(files) {\n    // Delete the temporary files.\n    files.forEach(file => {\n      if ('remove' in file && CoreFile.removeBasePath(file.toURL()).startsWith(CoreFileProvider.TMPFOLDER)) {\n        // Pass an empty function to prevent missing parameter error.\n        file.remove(() => {\n          // Nothing to do.\n        });\n      }\n    });\n  }\n  /**\n   * Delete draft files.\n   *\n   * @param draftId Draft ID.\n   * @param files Files to delete.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteDraftFiles(draftId, files, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        draftitemid: draftId,\n        files: files\n      };\n      return site.write('core_files_delete_draft_files', params);\n    })();\n  }\n  /**\n   * Get the upload options for a file taken with the Camera Cordova plugin.\n   *\n   * @param uri File URI.\n   * @param isFromAlbum True if the image was taken from album, false if it's a new image taken with camera.\n   * @returns Options.\n   */\n  getCameraUploadOptions(uri, isFromAlbum) {\n    const extension = CoreMimetypeUtils.guessExtensionFromUrl(uri);\n    const mimetype = CoreMimetypeUtils.getMimeType(extension);\n    const isIOS = CorePlatform.isIOS();\n    const options = {\n      deleteAfterUpload: !isFromAlbum,\n      mimeType: mimetype\n    };\n    const fileName = CoreFile.getFileAndDirectoryFromPath(uri).name;\n    if (isIOS && (mimetype == 'image/jpeg' || mimetype == 'image/png')) {\n      // In iOS, the pictures can have repeated names, even if they come from the album.\n      // Add a timestamp to the filename to make it unique.\n      const split = fileName.split('.');\n      split[0] += '_' + CoreTimeUtils.readableTimestamp();\n      options.fileName = split.join('.');\n    } else {\n      // Use the same name that the file already has.\n      options.fileName = fileName;\n    }\n    if (isFromAlbum) {\n      // If the file was picked from the album, delete it only if it was copied to the app's folder.\n      options.deleteAfterUpload = CoreFile.isFileInAppFolder(uri);\n      if (CorePlatform.isAndroid()) {\n        // Picking an image from album in Android adds a timestamp at the end of the file. Delete it.\n        options.fileName = options.fileName.replace(/(\\.[^.]*)\\?[^.]*$/, '$1');\n      }\n    }\n    return options;\n  }\n  /**\n   * Given a list of original files and a list of current files, return the list of files to delete.\n   *\n   * @param originalFiles Original files.\n   * @param currentFiles Current files.\n   * @returns List of files to delete.\n   */\n  getFilesToDelete(originalFiles, currentFiles) {\n    const filesToDelete = [];\n    currentFiles = currentFiles || [];\n    originalFiles.forEach(file => {\n      const stillInList = currentFiles.some(currentFile => CoreFileHelper.getFileUrl(currentFile) == CoreFileHelper.getFileUrl(file));\n      if (!stillInList) {\n        filesToDelete.push({\n          filepath: file.filepath || '',\n          filename: file.filename || ''\n        });\n      }\n    });\n    return filesToDelete;\n  }\n  /**\n   * Get the upload options for a file of any type.\n   *\n   * @param uri File URI.\n   * @param name File name.\n   * @param mimetype File mimetype.\n   * @param deleteAfterUpload Whether the file should be deleted after upload.\n   * @param fileArea File area to upload the file to. It defaults to 'draft'.\n   * @param itemId Draft ID to upload the file to, 0 to create new.\n   * @returns Options.\n   */\n  getFileUploadOptions(uri, name, mimetype, deleteAfterUpload, fileArea, itemId) {\n    const options = {};\n    options.fileName = name;\n    options.mimeType = mimetype || CoreMimetypeUtils.getMimeType(CoreMimetypeUtils.getFileExtension(options.fileName));\n    options.deleteAfterUpload = !!deleteAfterUpload;\n    options.itemId = itemId || 0;\n    options.fileArea = fileArea;\n    return options;\n  }\n  /**\n   * Get the upload options for a file taken with the media capture Cordova plugin.\n   *\n   * @param mediaFile File object to upload.\n   * @returns Options.\n   */\n  getMediaUploadOptions(mediaFile) {\n    const options = {};\n    let filename = mediaFile.name;\n    if (!filename.match(/_\\d{14}(\\..*)?$/)) {\n      // Add a timestamp to the filename to make it unique.\n      const split = filename.split('.');\n      split[0] += '_' + CoreTimeUtils.readableTimestamp();\n      filename = split.join('.');\n    }\n    options.fileName = filename;\n    options.deleteAfterUpload = true;\n    if (mediaFile.type) {\n      options.mimeType = mediaFile.type;\n    } else {\n      options.mimeType = CoreMimetypeUtils.getMimeType(CoreMimetypeUtils.getFileExtension(options.fileName));\n    }\n    return options;\n  }\n  /**\n   * Take a picture or video, or load one from the library.\n   *\n   * @param options Options.\n   * @returns Promise resolved with the result.\n   */\n  getPicture(options) {\n    this.onGetPicture.next(true);\n    return Camera.getPicture(options).finally(() => {\n      this.onGetPicture.next(false);\n    });\n  }\n  /**\n   * Get the files stored in a folder, marking them as offline.\n   *\n   * @param folderPath Folder where to get the files.\n   * @returns Promise resolved with the list of files.\n   */\n  getStoredFiles(folderPath) {\n    return _asyncToGenerator(function* () {\n      return yield CoreFile.getDirectoryContents(folderPath);\n    })();\n  }\n  /**\n   * Get stored files from combined online and offline file object.\n   *\n   * @param filesObject The combined offline and online files object.\n   * @param folderPath Folder path to get files from.\n   * @returns Promise resolved with files.\n   */\n  getStoredFilesFromOfflineFilesObject(filesObject, folderPath) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let files = [];\n      if (filesObject.online.length > 0) {\n        files = CoreUtils.clone(filesObject.online);\n      }\n      if (filesObject.offline > 0) {\n        const offlineFiles = yield CoreUtils.ignoreErrors(_this4.getStoredFiles(folderPath));\n        if (offlineFiles) {\n          files = files.concat(offlineFiles);\n        }\n      }\n      return files;\n    })();\n  }\n  /**\n   * Check if a file's mimetype is invalid based on the list of accepted mimetypes. This function needs either the file's\n   * mimetype or the file's path/name.\n   *\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @param path File's path or name.\n   * @param mimetype File's mimetype.\n   * @returns Undefined if file is valid, error message if file is invalid.\n   */\n  isInvalidMimetype(mimetypes, path, mimetype) {\n    let extension;\n    if (mimetypes) {\n      // Verify that the mimetype of the file is supported.\n      if (mimetype) {\n        extension = CoreMimetypeUtils.getExtension(mimetype);\n        if (mimetypes.indexOf(mimetype) == -1) {\n          // Get the \"main\" mimetype of the extension.\n          // It's possible that the list of accepted mimetypes only includes the \"main\" mimetypes.\n          mimetype = CoreMimetypeUtils.getMimeType(extension);\n        }\n      } else if (path) {\n        extension = CoreMimetypeUtils.getFileExtension(path);\n        mimetype = CoreMimetypeUtils.getMimeType(extension);\n      } else {\n        throw new CoreError('No mimetype or path supplied.');\n      }\n      if (mimetype && mimetypes.indexOf(mimetype) == -1) {\n        extension = extension || Translate.instant('core.unknown');\n        return Translate.instant('core.fileuploader.invalidfiletype', {\n          $a: extension\n        });\n      }\n    }\n  }\n  /**\n   * Parse filetypeList to get the list of allowed mimetypes and the data to render information.\n   *\n   * @param filetypeList Formatted string list where the mimetypes can be checked.\n   * @returns Mimetypes and the filetypes informations. Undefined if all types supported.\n   */\n  prepareFiletypeList(filetypeList) {\n    var _filetypeList;\n    filetypeList = (_filetypeList = filetypeList) === null || _filetypeList === void 0 ? void 0 : _filetypeList.trim();\n    if (!filetypeList || filetypeList == '*') {\n      // All types supported, return undefined.\n      return;\n    }\n    const filetypes = filetypeList.split(/[;, ]+/g);\n    const mimetypes = {}; // Use an object to prevent duplicates.\n    const typesInfo = [];\n    filetypes.forEach(filetype => {\n      filetype = filetype.trim();\n      if (!filetype) {\n        return;\n      }\n      if (filetype.indexOf('/') != -1) {\n        // It's a mimetype.\n        typesInfo.push({\n          name: CoreMimetypeUtils.getMimetypeDescription(filetype),\n          extlist: CoreMimetypeUtils.getExtensions(filetype).map(this.addDot).join(' ')\n        });\n        mimetypes[filetype] = true;\n      } else if (filetype.indexOf('.') === 0) {\n        // It's an extension.\n        const mimetype = CoreMimetypeUtils.getMimeType(filetype);\n        typesInfo.push({\n          name: mimetype && CoreMimetypeUtils.getMimetypeDescription(mimetype),\n          extlist: filetype\n        });\n        if (mimetype) {\n          mimetypes[mimetype] = true;\n        }\n      } else {\n        // It's a group.\n        const groupExtensions = CoreMimetypeUtils.getGroupMimeInfo(filetype, 'extensions');\n        const groupMimetypes = CoreMimetypeUtils.getGroupMimeInfo(filetype, 'mimetypes');\n        if (groupExtensions && groupExtensions.length > 0) {\n          typesInfo.push({\n            name: CoreMimetypeUtils.getTranslatedGroupName(filetype),\n            extlist: groupExtensions.map(this.addDot).join(' ')\n          });\n          groupMimetypes === null || groupMimetypes === void 0 || groupMimetypes.forEach(mimetype => {\n            if (mimetype) {\n              mimetypes[mimetype] = true;\n            }\n          });\n        } else {\n          // Treat them as extensions.\n          filetype = this.addDot(filetype);\n          const mimetype = CoreMimetypeUtils.getMimeType(filetype);\n          typesInfo.push({\n            name: mimetype && CoreMimetypeUtils.getMimetypeDescription(mimetype),\n            extlist: filetype\n          });\n          if (mimetype) {\n            mimetypes[mimetype] = true;\n          }\n        }\n      }\n    });\n    return {\n      info: typesInfo,\n      mimetypes: Object.keys(mimetypes)\n    };\n  }\n  /**\n   * Given a list of files (either online files or local files), store the local files in a local folder\n   * to be uploaded later.\n   *\n   * @param folderPath Path of the folder where to store the files.\n   * @param files List of files.\n   * @returns Promise resolved if success.\n   */\n  storeFilesToUpload(folderPath, files) {\n    return _asyncToGenerator(function* () {\n      const result = {\n        online: [],\n        offline: 0\n      };\n      if (!files || !files.length) {\n        return result;\n      }\n      // Remove unused files from previous saves.\n      yield CoreFile.removeUnusedFiles(folderPath, files);\n      yield Promise.all(files.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (file) {\n          var _file$fullPath;\n          if (!CoreUtils.isFileEntry(file)) {\n            // It's an online file, add it to the result and ignore it.\n            result.online.push({\n              filename: file.filename,\n              fileurl: CoreFileHelper.getFileUrl(file)\n            });\n          } else if (((_file$fullPath = file.fullPath) === null || _file$fullPath === void 0 ? void 0 : _file$fullPath.indexOf(folderPath)) != -1) {\n            // File already in the submission folder.\n            result.offline++;\n          } else {\n            // Local file, copy it.\n            // Use copy instead of move to prevent having a unstable state if some copies succeed and others don't.\n            const destFile = CorePath.concatenatePaths(folderPath, file.name);\n            result.offline++;\n            yield CoreFile.copyFile(file.toURL(), destFile);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return result;\n    })();\n  }\n  /**\n   * Upload a file.\n   *\n   * @param uri File URI.\n   * @param options Options for the upload.\n   * @param onProgress Function to call on progress.\n   * @param siteId Id of the site to upload the file to. If not defined, use current site.\n   * @returns Promise resolved when done.\n   */\n  uploadFile(uri, options, onProgress, siteId) {\n    return _asyncToGenerator(function* () {\n      options = options || {};\n      const deleteAfterUpload = options.deleteAfterUpload;\n      const ftOptions = CoreUtils.clone(options);\n      delete ftOptions.deleteAfterUpload;\n      const site = yield CoreSites.getSite(siteId);\n      const result = yield site.uploadFile(uri, ftOptions, onProgress);\n      if (deleteAfterUpload) {\n        CoreFile.removeExternalFile(uri);\n      }\n      return result;\n    })();\n  }\n  /**\n   * Given a list of files (either online files or local files), upload the local files to the draft area.\n   * Local files are not deleted from the device after upload.\n   *\n   * @param itemId Draft ID.\n   * @param files List of files.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the itemId.\n   */\n  uploadFiles(itemId, files, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!files || !files.length) {\n        return;\n      }\n      // Index the online files by name.\n      const usedNames = {};\n      const filesToUpload = [];\n      files.forEach(file => {\n        if (CoreUtils.isFileEntry(file)) {\n          filesToUpload.push(file);\n        } else {\n          // It's an online file.\n          usedNames[(file.filename || '').toLowerCase()] = file;\n        }\n      });\n      yield Promise.all(filesToUpload.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (file) {\n          // Make sure the file name is unique in the area.\n          const name = CoreFile.calculateUniqueName(usedNames, file.name);\n          usedNames[name] = file;\n          // Now upload the file.\n          const options = _this5.getFileUploadOptions(file.toURL(), name, undefined, false, 'draft', itemId);\n          yield _this5.uploadFile(file.toURL(), options, undefined, siteId);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Upload a file to a draft area and return the draft ID.\n   *\n   * If the file is an online file it will be downloaded and then re-uploaded.\n   * If the file is a local file it will not be deleted from the device after upload.\n   *\n   * @param file Online file or local FileEntry.\n   * @param itemId Draft ID to use. Undefined or 0 to create a new draft ID.\n   * @param component The component to set to the downloaded files.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the itemId.\n   */\n  uploadOrReuploadFile(file, itemId, component, componentId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      let fileName = '';\n      let fileEntry;\n      const isOnline = !CoreUtils.isFileEntry(file);\n      if (CoreUtils.isFileEntry(file)) {\n        // Local file, we already have the file entry.\n        fileName = file.name;\n        fileEntry = file;\n      } else {\n        // It's an online file. We need to download it and re-upload it.\n        fileName = file.filename || '';\n        const path = yield CoreFilepool.downloadUrl(siteId, CoreFileHelper.getFileUrl(file), false, component, componentId, file.timemodified, undefined, undefined, file);\n        fileEntry = yield CoreFile.getExternalFile(path);\n      }\n      // Now upload the file.\n      const extension = CoreMimetypeUtils.getFileExtension(fileName);\n      const mimetype = extension ? CoreMimetypeUtils.getMimeType(extension) : undefined;\n      const options = _this6.getFileUploadOptions(fileEntry.toURL(), fileName, mimetype, isOnline, 'draft', itemId);\n      const result = yield _this6.uploadFile(fileEntry.toURL(), options, undefined, siteId);\n      return result.itemid;\n    })();\n  }\n  /**\n   * Given a list of files (either online files or local files), upload them to a draft area and return the draft ID.\n   *\n   * Online files will be downloaded and then re-uploaded.\n   * Local files are not deleted from the device after upload.\n   * If there are no files to upload it will return a fake draft ID (1).\n   *\n   * @param files List of files.\n   * @param component The component to set to the downloaded files.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the itemId.\n   */\n  uploadOrReuploadFiles(files, component, componentId, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!files || !files.length) {\n        // Return fake draft ID.\n        return 1;\n      }\n      // Upload only the first file first to get a draft id.\n      const itemId = yield _this7.uploadOrReuploadFile(files[0], 0, component, componentId, siteId);\n      const promises = [];\n      for (let i = 1; i < files.length; i++) {\n        const file = files[i];\n        promises.push(_this7.uploadOrReuploadFile(file, itemId, component, componentId, siteId));\n      }\n      yield Promise.all(promises);\n      return itemId;\n    })();\n  }\n}\n_class = CoreFileUploaderProvider;\n_class.LIMITED_SIZE_WARNING = 1048576;\n// 1 MB.\n_class.WIFI_SIZE_WARNING = 10485760;\n_class.ɵfac = function CoreFileUploaderProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFileUploader = makeSingleton(CoreFileUploaderProvider);","map":{"version":3,"names":["Subject","CoreFile","CoreFileProvider","CoreFilepool","CoreSites","CoreMimetypeUtils","CoreTimeUtils","CoreUtils","CoreWSFileUploadOptions","makeSingleton","Translate","MediaCapture","Camera","CoreLogger","CoreError","CoreFileHelper","CorePath","CorePlatform","CoreModals","CoreFileUploaderProvider","constructor","onGetPicture","onAudioCapture","onVideoCapture","logger","getInstance","addDot","extension","areFileListDifferent","a","b","length","i","getFileName","canDeleteDraftFiles","siteId","_this","_asyncToGenerator","site","getSite","canDeleteDraftFilesInSite","error","_site","getCurrentSite","wsAvailable","captureAudio","_this2","next","supportsMediaCapture","supportsWebAssembly","media","limit","recording","captureAudioInApp","CoreFileUploaderAudioRecorderComponent","openSheet","Error","captureVideo","options","_this3","clearTmpFiles","files","forEach","file","removeBasePath","toURL","startsWith","TMPFOLDER","remove","deleteDraftFiles","draftId","params","draftitemid","write","getCameraUploadOptions","uri","isFromAlbum","guessExtensionFromUrl","mimetype","getMimeType","isIOS","deleteAfterUpload","mimeType","fileName","getFileAndDirectoryFromPath","name","split","readableTimestamp","join","isFileInAppFolder","isAndroid","replace","getFilesToDelete","originalFiles","currentFiles","filesToDelete","stillInList","some","currentFile","getFileUrl","push","filepath","filename","getFileUploadOptions","fileArea","itemId","getFileExtension","getMediaUploadOptions","mediaFile","match","type","getPicture","finally","getStoredFiles","folderPath","getDirectoryContents","getStoredFilesFromOfflineFilesObject","filesObject","_this4","online","clone","offline","offlineFiles","ignoreErrors","concat","isInvalidMimetype","mimetypes","path","getExtension","indexOf","instant","$a","prepareFiletypeList","filetypeList","_filetypeList","trim","filetypes","typesInfo","filetype","getMimetypeDescription","extlist","getExtensions","map","groupExtensions","getGroupMimeInfo","groupMimetypes","getTranslatedGroupName","info","Object","keys","storeFilesToUpload","result","removeUnusedFiles","Promise","all","_ref","_file$fullPath","isFileEntry","fileurl","fullPath","destFile","concatenatePaths","copyFile","_x","apply","arguments","uploadFile","onProgress","ftOptions","removeExternalFile","uploadFiles","_this5","getCurrentSiteId","usedNames","filesToUpload","toLowerCase","_ref2","calculateUniqueName","undefined","_x2","uploadOrReuploadFile","component","componentId","_this6","fileEntry","isOnline","downloadUrl","timemodified","getExternalFile","itemid","uploadOrReuploadFiles","_this7","promises","_class","LIMITED_SIZE_WARNING","WIFI_SIZE_WARNING","factory","ɵfac","providedIn","CoreFileUploader"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/fileuploader/services/fileuploader.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CameraOptions } from '@awesome-cordova-plugins/camera/ngx';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\nimport { MediaFile, CaptureError, CaptureVideoOptions } from '@awesome-cordova-plugins/media-capture/ngx';\nimport { Subject } from 'rxjs';\n\nimport { CoreFile, CoreFileProvider } from '@services/file';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile, CoreWSFileUploadOptions, CoreWSUploadFileResult } from '@services/ws';\nimport { makeSingleton, Translate, MediaCapture, Camera } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreFileEntry, CoreFileHelper } from '@services/file-helper';\nimport { CorePath } from '@singletons/path';\nimport { CorePlatform } from '@services/platform';\nimport { CoreModals } from '@services/modals';\n\n/**\n * File upload options.\n */\nexport interface CoreFileUploaderOptions extends CoreWSFileUploadOptions {\n    /**\n     * Whether the file should be deleted after the upload (if success).\n     */\n    deleteAfterUpload?: boolean;\n}\n\n/**\n * Service to upload files.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFileUploaderProvider {\n\n    static readonly LIMITED_SIZE_WARNING = 1048576; // 1 MB.\n    static readonly WIFI_SIZE_WARNING = 10485760; // 10 MB.\n\n    protected logger: CoreLogger;\n\n    // Observers to notify when a media file starts/stops being recorded/selected.\n    onGetPicture: Subject<boolean> = new Subject<boolean>();\n    onAudioCapture: Subject<boolean> = new Subject<boolean>();\n    onVideoCapture: Subject<boolean> = new Subject<boolean>();\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreFileUploaderProvider');\n    }\n\n    /**\n     * Add a dot to the beginning of an extension.\n     *\n     * @param extension Extension.\n     * @returns Treated extension.\n     */\n    protected addDot(extension: string): string {\n        return '.' + extension;\n    }\n\n    /**\n     * Compares two file lists and returns if they are different.\n     *\n     * @param a First file list.\n     * @param b Second file list.\n     * @returns Whether both lists are different.\n     */\n    areFileListDifferent(a: CoreFileEntry[], b: CoreFileEntry[]): boolean {\n        a = a || [];\n        b = b || [];\n        if (a.length != b.length) {\n            return true;\n        }\n\n        // Currently we are going to compare the order of the files as well.\n        // This function can be improved comparing more fields or not comparing the order.\n        for (let i = 0; i < a.length; i++) {\n            if (CoreFile.getFileName(a[i]) != CoreFile.getFileName(b[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if a certain site allows deleting draft files.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if can delete.\n     * @since 3.10\n     */\n    async canDeleteDraftFiles(siteId?: string): Promise<boolean> {\n        try {\n            const site = await CoreSites.getSite(siteId);\n\n            return this.canDeleteDraftFilesInSite(site);\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Check if a certain site allows deleting draft files.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether draft files can be deleted.\n     * @since 3.10\n     */\n    canDeleteDraftFilesInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!(site?.wsAvailable('core_files_delete_draft_files'));\n    }\n\n    /**\n     * Start the audio recorder application and return information about captured audio clip files.\n     *\n     * @returns Promise resolved with the result.\n     */\n    async captureAudio(): Promise<CoreFileUploaderAudioRecording[] | MediaFile[] | CaptureError> {\n        this.onAudioCapture.next(true);\n\n        try {\n            if (!CorePlatform.supportsMediaCapture() || !CorePlatform.supportsWebAssembly()) {\n                const media = await MediaCapture.captureAudio({ limit: 1 });\n\n                return media;\n            }\n\n            const recording = await this.captureAudioInApp();\n\n            return [recording];\n        } finally {\n            this.onAudioCapture.next(false);\n        }\n    }\n\n    /**\n     * Record an audio file without using an external app.\n     *\n     * @returns Promise resolved with the file.\n     */\n    async captureAudioInApp(): Promise<CoreFileUploaderAudioRecording> {\n        const { CoreFileUploaderAudioRecorderComponent } =\n            await import('@features/fileuploader/components/audio-recorder/audio-recorder.module');\n\n        const recording = await CoreModals.openSheet(CoreFileUploaderAudioRecorderComponent);\n\n        if (!recording) {\n            throw new Error('Recording missing from audio capture');\n        }\n\n        return recording;\n    }\n\n    /**\n     * Start the video recorder application and return information about captured video clip files.\n     *\n     * @param options Options.\n     * @returns Promise resolved with the result.\n     */\n    async captureVideo(options: CaptureVideoOptions): Promise<MediaFile[] | CaptureError> {\n        this.onVideoCapture.next(true);\n\n        try {\n            return await MediaCapture.captureVideo(options);\n        } finally {\n            this.onVideoCapture.next(false);\n        }\n    }\n\n    /**\n     * Clear temporary attachments to be uploaded.\n     * Attachments already saved in an offline store will NOT be deleted, only files in tmp folder will be deleted.\n     *\n     * @param files List of files.\n     */\n    clearTmpFiles(files: (CoreWSFile | FileEntry)[]): void {\n        // Delete the temporary files.\n        files.forEach((file) => {\n            if ('remove' in file && CoreFile.removeBasePath(file.toURL()).startsWith(CoreFileProvider.TMPFOLDER)) {\n                // Pass an empty function to prevent missing parameter error.\n                file.remove(() => {\n                    // Nothing to do.\n                });\n            }\n        });\n    }\n\n    /**\n     * Delete draft files.\n     *\n     * @param draftId Draft ID.\n     * @param files Files to delete.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteDraftFiles(draftId: number, files: { filepath: string; filename: string }[], siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params = {\n            draftitemid: draftId,\n            files: files,\n        };\n\n        return site.write('core_files_delete_draft_files', params);\n    }\n\n    /**\n     * Get the upload options for a file taken with the Camera Cordova plugin.\n     *\n     * @param uri File URI.\n     * @param isFromAlbum True if the image was taken from album, false if it's a new image taken with camera.\n     * @returns Options.\n     */\n    getCameraUploadOptions(uri: string, isFromAlbum?: boolean): CoreFileUploaderOptions {\n        const extension = CoreMimetypeUtils.guessExtensionFromUrl(uri);\n        const mimetype = CoreMimetypeUtils.getMimeType(extension);\n        const isIOS = CorePlatform.isIOS();\n        const options: CoreFileUploaderOptions = {\n            deleteAfterUpload: !isFromAlbum,\n            mimeType: mimetype,\n        };\n        const fileName = CoreFile.getFileAndDirectoryFromPath(uri).name;\n\n        if (isIOS && (mimetype == 'image/jpeg' || mimetype == 'image/png')) {\n            // In iOS, the pictures can have repeated names, even if they come from the album.\n            // Add a timestamp to the filename to make it unique.\n            const split = fileName.split('.');\n            split[0] += '_' + CoreTimeUtils.readableTimestamp();\n\n            options.fileName = split.join('.');\n        } else {\n            // Use the same name that the file already has.\n            options.fileName = fileName;\n        }\n\n        if (isFromAlbum) {\n            // If the file was picked from the album, delete it only if it was copied to the app's folder.\n            options.deleteAfterUpload = CoreFile.isFileInAppFolder(uri);\n\n            if (CorePlatform.isAndroid()) {\n                // Picking an image from album in Android adds a timestamp at the end of the file. Delete it.\n                options.fileName = options.fileName.replace(/(\\.[^.]*)\\?[^.]*$/, '$1');\n            }\n        }\n\n        return options;\n    }\n\n    /**\n     * Given a list of original files and a list of current files, return the list of files to delete.\n     *\n     * @param originalFiles Original files.\n     * @param currentFiles Current files.\n     * @returns List of files to delete.\n     */\n    getFilesToDelete(\n        originalFiles: CoreWSFile[],\n        currentFiles: CoreFileEntry[],\n    ): { filepath: string; filename: string }[] {\n\n        const filesToDelete: { filepath: string; filename: string }[] = [];\n        currentFiles = currentFiles || [];\n\n        originalFiles.forEach((file) => {\n            const stillInList = currentFiles.some((currentFile) =>\n                CoreFileHelper.getFileUrl(<CoreWSFile> currentFile) == CoreFileHelper.getFileUrl(file));\n\n            if (!stillInList) {\n                filesToDelete.push({\n                    filepath: file.filepath || '',\n                    filename: file.filename || '',\n                });\n            }\n        });\n\n        return filesToDelete;\n    }\n\n    /**\n     * Get the upload options for a file of any type.\n     *\n     * @param uri File URI.\n     * @param name File name.\n     * @param mimetype File mimetype.\n     * @param deleteAfterUpload Whether the file should be deleted after upload.\n     * @param fileArea File area to upload the file to. It defaults to 'draft'.\n     * @param itemId Draft ID to upload the file to, 0 to create new.\n     * @returns Options.\n     */\n    getFileUploadOptions(\n        uri: string,\n        name: string,\n        mimetype?: string,\n        deleteAfterUpload?: boolean,\n        fileArea?: string,\n        itemId?: number,\n    ): CoreFileUploaderOptions {\n        const options: CoreFileUploaderOptions = {};\n        options.fileName = name;\n        options.mimeType = mimetype || CoreMimetypeUtils.getMimeType(\n            CoreMimetypeUtils.getFileExtension(options.fileName),\n        );\n        options.deleteAfterUpload = !!deleteAfterUpload;\n        options.itemId = itemId || 0;\n        options.fileArea = fileArea;\n\n        return options;\n    }\n\n    /**\n     * Get the upload options for a file taken with the media capture Cordova plugin.\n     *\n     * @param mediaFile File object to upload.\n     * @returns Options.\n     */\n    getMediaUploadOptions(mediaFile: MediaFile | CoreFileUploaderAudioRecording): CoreFileUploaderOptions {\n        const options: CoreFileUploaderOptions = {};\n        let filename = mediaFile.name;\n\n        if (!filename.match(/_\\d{14}(\\..*)?$/)) {\n            // Add a timestamp to the filename to make it unique.\n            const split = filename.split('.');\n            split[0] += '_' + CoreTimeUtils.readableTimestamp();\n            filename = split.join('.');\n        }\n\n        options.fileName = filename;\n        options.deleteAfterUpload = true;\n        if (mediaFile.type) {\n            options.mimeType = mediaFile.type;\n        } else {\n            options.mimeType = CoreMimetypeUtils.getMimeType(\n                CoreMimetypeUtils.getFileExtension(options.fileName),\n            );\n        }\n\n        return options;\n    }\n\n    /**\n     * Take a picture or video, or load one from the library.\n     *\n     * @param options Options.\n     * @returns Promise resolved with the result.\n     */\n    getPicture(options: CameraOptions): Promise<string> {\n        this.onGetPicture.next(true);\n\n        return Camera.getPicture(options).finally(() => {\n            this.onGetPicture.next(false);\n        });\n    }\n\n    /**\n     * Get the files stored in a folder, marking them as offline.\n     *\n     * @param folderPath Folder where to get the files.\n     * @returns Promise resolved with the list of files.\n     */\n    async getStoredFiles(folderPath: string): Promise<FileEntry[]> {\n        return <FileEntry[]> await CoreFile.getDirectoryContents(folderPath);\n    }\n\n    /**\n     * Get stored files from combined online and offline file object.\n     *\n     * @param filesObject The combined offline and online files object.\n     * @param folderPath Folder path to get files from.\n     * @returns Promise resolved with files.\n     */\n    async getStoredFilesFromOfflineFilesObject(\n        filesObject: CoreFileUploaderStoreFilesResult,\n        folderPath: string,\n    ): Promise<CoreFileEntry[]> {\n        let files: CoreFileEntry[] = [];\n\n        if (filesObject.online.length > 0) {\n            files = CoreUtils.clone(filesObject.online);\n        }\n\n        if (filesObject.offline > 0) {\n            const offlineFiles = await CoreUtils.ignoreErrors(this.getStoredFiles(folderPath));\n\n            if (offlineFiles) {\n                files = files.concat(offlineFiles);\n            }\n        }\n\n        return files;\n    }\n\n    /**\n     * Check if a file's mimetype is invalid based on the list of accepted mimetypes. This function needs either the file's\n     * mimetype or the file's path/name.\n     *\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @param path File's path or name.\n     * @param mimetype File's mimetype.\n     * @returns Undefined if file is valid, error message if file is invalid.\n     */\n    isInvalidMimetype(mimetypes?: string[], path?: string, mimetype?: string): string | undefined {\n        let extension: string | undefined;\n\n        if (mimetypes) {\n            // Verify that the mimetype of the file is supported.\n            if (mimetype) {\n                extension = CoreMimetypeUtils.getExtension(mimetype);\n\n                if (mimetypes.indexOf(mimetype) == -1) {\n                    // Get the \"main\" mimetype of the extension.\n                    // It's possible that the list of accepted mimetypes only includes the \"main\" mimetypes.\n                    mimetype = CoreMimetypeUtils.getMimeType(extension);\n                }\n            } else if (path) {\n                extension = CoreMimetypeUtils.getFileExtension(path);\n                mimetype = CoreMimetypeUtils.getMimeType(extension);\n            } else {\n                throw new CoreError('No mimetype or path supplied.');\n            }\n\n            if (mimetype && mimetypes.indexOf(mimetype) == -1) {\n                extension = extension || Translate.instant('core.unknown');\n\n                return Translate.instant('core.fileuploader.invalidfiletype', { $a: extension });\n            }\n        }\n    }\n\n    /**\n     * Parse filetypeList to get the list of allowed mimetypes and the data to render information.\n     *\n     * @param filetypeList Formatted string list where the mimetypes can be checked.\n     * @returns Mimetypes and the filetypes informations. Undefined if all types supported.\n     */\n    prepareFiletypeList(filetypeList: string): CoreFileUploaderTypeList | undefined {\n        filetypeList = filetypeList?.trim();\n\n        if (!filetypeList || filetypeList == '*') {\n            // All types supported, return undefined.\n            return;\n        }\n\n        const filetypes = filetypeList.split(/[;, ]+/g);\n        const mimetypes: Record<string, boolean> = {}; // Use an object to prevent duplicates.\n        const typesInfo: CoreFileUploaderTypeListInfoEntry[] = [];\n\n        filetypes.forEach((filetype) => {\n            filetype = filetype.trim();\n\n            if (!filetype) {\n                return;\n            }\n\n            if (filetype.indexOf('/') != -1) {\n                // It's a mimetype.\n                typesInfo.push({\n                    name: CoreMimetypeUtils.getMimetypeDescription(filetype),\n                    extlist: CoreMimetypeUtils.getExtensions(filetype).map(this.addDot).join(' '),\n                });\n\n                mimetypes[filetype] = true;\n            } else if (filetype.indexOf('.') === 0) {\n                // It's an extension.\n                const mimetype = CoreMimetypeUtils.getMimeType(filetype);\n                typesInfo.push({\n                    name: mimetype && CoreMimetypeUtils.getMimetypeDescription(mimetype),\n                    extlist: filetype,\n                });\n\n                if (mimetype) {\n                    mimetypes[mimetype] = true;\n                }\n            } else {\n                // It's a group.\n                const groupExtensions = CoreMimetypeUtils.getGroupMimeInfo(filetype, 'extensions');\n                const groupMimetypes = CoreMimetypeUtils.getGroupMimeInfo(filetype, 'mimetypes');\n\n                if (groupExtensions && groupExtensions.length > 0) {\n                    typesInfo.push({\n                        name: CoreMimetypeUtils.getTranslatedGroupName(filetype),\n                        extlist: groupExtensions.map(this.addDot).join(' '),\n                    });\n\n                    groupMimetypes?.forEach((mimetype) => {\n                        if (mimetype) {\n                            mimetypes[mimetype] = true;\n                        }\n                    });\n                } else {\n                    // Treat them as extensions.\n                    filetype = this.addDot(filetype);\n\n                    const mimetype = CoreMimetypeUtils.getMimeType(filetype);\n                    typesInfo.push({\n                        name: mimetype && CoreMimetypeUtils.getMimetypeDescription(mimetype),\n                        extlist: filetype,\n                    });\n\n                    if (mimetype) {\n                        mimetypes[mimetype] = true;\n                    }\n                }\n            }\n        });\n\n        return {\n            info: typesInfo,\n            mimetypes: Object.keys(mimetypes),\n        };\n    }\n\n    /**\n     * Given a list of files (either online files or local files), store the local files in a local folder\n     * to be uploaded later.\n     *\n     * @param folderPath Path of the folder where to store the files.\n     * @param files List of files.\n     * @returns Promise resolved if success.\n     */\n    async storeFilesToUpload(\n        folderPath: string,\n        files: CoreFileEntry[],\n    ): Promise<CoreFileUploaderStoreFilesResult> {\n        const result: CoreFileUploaderStoreFilesResult = {\n            online: [],\n            offline: 0,\n        };\n\n        if (!files || !files.length) {\n            return result;\n        }\n\n        // Remove unused files from previous saves.\n        await CoreFile.removeUnusedFiles(folderPath, files);\n\n        await Promise.all(files.map(async (file) => {\n            if (!CoreUtils.isFileEntry(file)) {\n                // It's an online file, add it to the result and ignore it.\n                result.online.push({\n                    filename: file.filename,\n                    fileurl: CoreFileHelper.getFileUrl(file),\n                });\n            } else if (file.fullPath?.indexOf(folderPath) != -1) {\n                // File already in the submission folder.\n                result.offline++;\n            } else {\n                // Local file, copy it.\n                // Use copy instead of move to prevent having a unstable state if some copies succeed and others don't.\n                const destFile = CorePath.concatenatePaths(folderPath, file.name);\n                result.offline++;\n\n                await CoreFile.copyFile(file.toURL(), destFile);\n            }\n        }));\n\n        return result;\n    }\n\n    /**\n     * Upload a file.\n     *\n     * @param uri File URI.\n     * @param options Options for the upload.\n     * @param onProgress Function to call on progress.\n     * @param siteId Id of the site to upload the file to. If not defined, use current site.\n     * @returns Promise resolved when done.\n     */\n    async uploadFile(\n        uri: string,\n        options?: CoreFileUploaderOptions,\n        onProgress?: (event: ProgressEvent) => void,\n        siteId?: string,\n    ): Promise<CoreWSUploadFileResult> {\n        options = options || {};\n\n        const deleteAfterUpload = options.deleteAfterUpload;\n        const ftOptions = CoreUtils.clone(options);\n\n        delete ftOptions.deleteAfterUpload;\n\n        const site = await CoreSites.getSite(siteId);\n\n        const result = await site.uploadFile(uri, ftOptions, onProgress);\n\n        if (deleteAfterUpload) {\n            CoreFile.removeExternalFile(uri);\n        }\n\n        return result;\n    }\n\n    /**\n     * Given a list of files (either online files or local files), upload the local files to the draft area.\n     * Local files are not deleted from the device after upload.\n     *\n     * @param itemId Draft ID.\n     * @param files List of files.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the itemId.\n     */\n    async uploadFiles(itemId: number, files: CoreFileEntry[], siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!files || !files.length) {\n            return;\n        }\n\n        // Index the online files by name.\n        const usedNames: {[name: string]: CoreFileEntry} = {};\n        const filesToUpload: FileEntry[] = [];\n        files.forEach((file) => {\n            if (CoreUtils.isFileEntry(file)) {\n                filesToUpload.push(<FileEntry> file);\n            } else {\n                // It's an online file.\n                usedNames[(file.filename || '').toLowerCase()] = file;\n            }\n        });\n\n        await Promise.all(filesToUpload.map(async (file) => {\n            // Make sure the file name is unique in the area.\n            const name = CoreFile.calculateUniqueName(usedNames, file.name);\n            usedNames[name] = file;\n\n            // Now upload the file.\n            const options = this.getFileUploadOptions(file.toURL(), name, undefined, false, 'draft', itemId);\n\n            await this.uploadFile(file.toURL(), options, undefined, siteId);\n        }));\n    }\n\n    /**\n     * Upload a file to a draft area and return the draft ID.\n     *\n     * If the file is an online file it will be downloaded and then re-uploaded.\n     * If the file is a local file it will not be deleted from the device after upload.\n     *\n     * @param file Online file or local FileEntry.\n     * @param itemId Draft ID to use. Undefined or 0 to create a new draft ID.\n     * @param component The component to set to the downloaded files.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the itemId.\n     */\n    async uploadOrReuploadFile(\n        file: CoreFileEntry,\n        itemId?: number,\n        component?: string,\n        componentId?: string | number,\n        siteId?: string,\n    ): Promise<number> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        let fileName = '';\n        let fileEntry: FileEntry | undefined;\n\n        const isOnline = !CoreUtils.isFileEntry(file);\n\n        if (CoreUtils.isFileEntry(file)) {\n            // Local file, we already have the file entry.\n            fileName = file.name;\n            fileEntry = file;\n        } else {\n            // It's an online file. We need to download it and re-upload it.\n            fileName = file.filename || '';\n\n            const path = await CoreFilepool.downloadUrl(\n                siteId,\n                CoreFileHelper.getFileUrl(file),\n                false,\n                component,\n                componentId,\n                file.timemodified,\n                undefined,\n                undefined,\n                file,\n            );\n\n            fileEntry = await CoreFile.getExternalFile(path);\n        }\n\n        // Now upload the file.\n        const extension = CoreMimetypeUtils.getFileExtension(fileName);\n        const mimetype = extension ? CoreMimetypeUtils.getMimeType(extension) : undefined;\n        const options = this.getFileUploadOptions(fileEntry.toURL(), fileName, mimetype, isOnline, 'draft', itemId);\n\n        const result = await this.uploadFile(fileEntry.toURL(), options, undefined, siteId);\n\n        return result.itemid;\n    }\n\n    /**\n     * Given a list of files (either online files or local files), upload them to a draft area and return the draft ID.\n     *\n     * Online files will be downloaded and then re-uploaded.\n     * Local files are not deleted from the device after upload.\n     * If there are no files to upload it will return a fake draft ID (1).\n     *\n     * @param files List of files.\n     * @param component The component to set to the downloaded files.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the itemId.\n     */\n    async uploadOrReuploadFiles(\n        files: CoreFileEntry[],\n        component?: string,\n        componentId?: string | number,\n        siteId?: string,\n    ): Promise<number> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!files || !files.length) {\n            // Return fake draft ID.\n            return 1;\n        }\n\n        // Upload only the first file first to get a draft id.\n        const itemId = await this.uploadOrReuploadFile(files[0], 0, component, componentId, siteId);\n\n        const promises: Promise<number>[] = [];\n\n        for (let i = 1; i < files.length; i++) {\n            const file = files[i];\n            promises.push(this.uploadOrReuploadFile(file, itemId, component, componentId, siteId));\n        }\n\n        await Promise.all(promises);\n\n        return itemId;\n    }\n\n}\n\nexport const CoreFileUploader = makeSingleton(CoreFileUploaderProvider);\n\nexport type CoreFileUploaderStoreFilesResult = {\n    online: CoreWSFile[]; // List of online files.\n    offline: number; // Number of offline files.\n};\n\nexport type CoreFileUploaderTypeList = {\n    info: CoreFileUploaderTypeListInfoEntry[];\n    mimetypes: string[];\n};\n\nexport type CoreFileUploaderTypeListInfoEntry = {\n    name?: string;\n    extlist: string;\n};\n\nexport type CoreFileUploaderAudioRecording = {\n    name: string;\n    fullPath: string;\n    type: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}