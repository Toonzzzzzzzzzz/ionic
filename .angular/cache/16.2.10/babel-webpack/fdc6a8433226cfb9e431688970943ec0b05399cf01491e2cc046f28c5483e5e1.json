{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreFileUploader } from '@features/fileuploader/services/fileuploader';\nimport { CoreSites } from '@services/sites';\nimport { AddonModAssignProvider, AddonModAssign, AddonModAssignSubmissionStatusValues } from './assign';\nimport { AddonModAssignOffline } from './assign-offline';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreFile } from '@services/file';\nimport { CoreGroups } from '@services/groups';\nimport { AddonModAssignSubmissionDelegate } from './submission-delegate';\nimport { AddonModAssignFeedbackDelegate } from './feedback-delegate';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\n/**\n * Service that provides some helper functions for assign.\n */\nexport class AddonModAssignHelperProvider {\n  /**\n   * Calculate the end time (timestamp) for an assign and submission.\n   *\n   * @param assign Assign instance.\n   * @param submission Submission.\n   * @returns End time.\n   */\n  calculateEndTime(assign, submission) {\n    const timeDue = ((submission === null || submission === void 0 ? void 0 : submission.timestarted) || 0) + (assign.timelimit || 0);\n    if (assign.duedate) {\n      return Math.min(timeDue, assign.duedate);\n    } else if (assign.cutoffdate) {\n      return Math.min(timeDue, assign.cutoffdate);\n    }\n    return timeDue;\n  }\n  /**\n   * Check if a submission can be edited in offline.\n   *\n   * @param assign Assignment.\n   * @param submission Submission.\n   * @returns Whether it can be edited offline.\n   */\n  canEditSubmissionOffline(assign, submission) {\n    return _asyncToGenerator(function* () {\n      if (!submission) {\n        return false;\n      }\n      if (submission.status == AddonModAssignSubmissionStatusValues.NEW || submission.status == AddonModAssignSubmissionStatusValues.REOPENED) {\n        // It's a new submission, allow creating it in offline.\n        return true;\n      }\n      let canEdit = true;\n      const promises = submission.plugins ? submission.plugins.map(plugin => AddonModAssignSubmissionDelegate.canPluginEditOffline(assign, submission, plugin).then(canEditPlugin => {\n        if (!canEditPlugin) {\n          canEdit = false;\n        }\n        return;\n      })) : [];\n      yield Promise.all(promises);\n      return canEdit;\n    })();\n  }\n  /**\n   * Clear plugins temporary data because a submission was cancelled.\n   *\n   * @param assign Assignment.\n   * @param submission Submission to clear the data for.\n   * @param inputData Data entered in the submission form.\n   */\n  clearSubmissionPluginTmpData(assign, submission, inputData) {\n    var _submission$plugins;\n    if (!submission) {\n      return;\n    }\n    (_submission$plugins = submission.plugins) === null || _submission$plugins === void 0 || _submission$plugins.forEach(plugin => {\n      AddonModAssignSubmissionDelegate.clearTmpData(assign, submission, plugin, inputData);\n    });\n  }\n  /**\n   * Copy the data from last submitted attempt to the current submission.\n   * Since we don't have any WS for that we'll have to re-submit everything manually.\n   *\n   * @param assign Assignment.\n   * @param previousSubmission Submission to copy.\n   * @returns Promise resolved when done.\n   */\n  copyPreviousAttempt(assign, previousSubmission) {\n    return _asyncToGenerator(function* () {\n      const pluginData = {};\n      const promises = previousSubmission.plugins ? previousSubmission.plugins.map(plugin => AddonModAssignSubmissionDelegate.copyPluginSubmissionData(assign, plugin, pluginData)) : [];\n      yield Promise.all(promises);\n      // We got the plugin data. Now we need to submit it.\n      if (Object.keys(pluginData).length) {\n        // There's something to save.\n        return AddonModAssign.saveSubmissionOnline(assign.id, pluginData);\n      }\n    })();\n  }\n  /**\n   * Create an empty feedback object.\n   *\n   * @returns Feedback.\n   */\n  createEmptyFeedback() {\n    return {\n      grade: undefined,\n      gradefordisplay: '',\n      gradeddate: 0\n    };\n  }\n  /**\n   * Create an empty submission object.\n   *\n   * @returns Submission.\n   */\n  createEmptySubmission() {\n    return {\n      id: 0,\n      userid: 0,\n      attemptnumber: 0,\n      timecreated: 0,\n      timemodified: 0,\n      status: AddonModAssignSubmissionStatusValues.NEW,\n      groupid: 0\n    };\n  }\n  /**\n   * Delete stored submission files for a plugin. See storeSubmissionFiles.\n   *\n   * @param assignId Assignment ID.\n   * @param folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteStoredSubmissionFiles(assignId, folderName, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const folderPath = yield AddonModAssignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId);\n      yield CoreFile.removeDir(folderPath);\n    })();\n  }\n  /**\n   * Delete all drafts of the feedback plugin data.\n   *\n   * @param assignId Assignment Id.\n   * @param userId User Id.\n   * @param feedback Feedback data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  discardFeedbackPluginData(assignId, userId, feedback, siteId) {\n    return _asyncToGenerator(function* () {\n      const promises = feedback.plugins ? feedback.plugins.map(plugin => AddonModAssignFeedbackDelegate.discardPluginFeedbackData(assignId, userId, plugin, siteId)) : [];\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Check if a submission has no content.\n   *\n   * @param assign Assignment object.\n   * @param submission Submission to inspect.\n   * @returns Whether the submission is empty.\n   */\n  isSubmissionEmpty(assign, submission) {\n    var _submission$plugins2;\n    if (!submission) {\n      return true;\n    }\n    const anyNotEmpty = (_submission$plugins2 = submission.plugins) === null || _submission$plugins2 === void 0 ? void 0 : _submission$plugins2.some(plugin => !AddonModAssignSubmissionDelegate.isPluginEmpty(assign, plugin));\n    // If any plugin is not empty, we consider that the submission is not empty either.\n    if (anyNotEmpty) {\n      return false;\n    }\n    // If all the plugins were empty (or there were no plugins), we consider the submission to be empty.\n    return true;\n  }\n  /**\n   * List the participants for a single assignment, with some summary info about their submissions.\n   *\n   * @param assign Assignment object.\n   * @param groupId Group Id.\n   * @param options Other options.\n   * @returns Promise resolved with the list of participants and summary of submissions.\n   */\n  getParticipants(assign, groupId, options = {}) {\n    return _asyncToGenerator(function* () {\n      groupId = groupId || 0;\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      // Create new options including all existing ones.\n      const modOptions = _objectSpread({\n        cmId: assign.cmid\n      }, options);\n      const participants = yield AddonModAssign.listParticipants(assign.id, groupId, modOptions);\n      if (groupId || participants && participants.length > 0) {\n        return participants;\n      }\n      // If no participants returned and all groups specified, get participants by groups.\n      const groupsInfo = yield CoreGroups.getActivityGroupInfo(assign.cmid, false, undefined, modOptions.siteId);\n      const participantsIndexed = {};\n      const promises = groupsInfo.groups ? groupsInfo.groups.map(userGroup => AddonModAssign.listParticipants(assign.id, userGroup.id, modOptions).then(participantsFromList => {\n        // Do not get repeated users.\n        participantsFromList.forEach(participant => {\n          participantsIndexed[participant.id] = participant;\n        });\n        return;\n      })) : [];\n      yield Promise.all(promises);\n      return CoreUtils.objectToArray(participantsIndexed);\n    })();\n  }\n  /**\n   * Get plugin config from assignment config.\n   *\n   * @param assign Assignment object including all config.\n   * @param subtype Subtype name (assignsubmission or assignfeedback)\n   * @param type Name of the subplugin.\n   * @returns Object containing all configurations of the subplugin selected.\n   */\n  getPluginConfig(assign, subtype, type) {\n    const configs = {};\n    assign.configs.forEach(config => {\n      if (config.subtype == subtype && config.plugin == type) {\n        configs[config.name] = config.value;\n      }\n    });\n    return configs;\n  }\n  /**\n   * Get enabled subplugins.\n   *\n   * @param assign Assignment object including all config.\n   * @param subtype Subtype name (assignsubmission or assignfeedback)\n   * @returns List of enabled plugins for the assign.\n   */\n  getPluginsEnabled(assign, subtype) {\n    const enabled = [];\n    assign.configs.forEach(config => {\n      if (config.subtype == subtype && config.name == 'enabled' && parseInt(config.value, 10) === 1) {\n        // Format the plugin objects.\n        enabled.push({\n          type: config.plugin,\n          name: config.plugin\n        });\n      }\n    });\n    return enabled;\n  }\n  /**\n   * Get a list of stored submission files. See storeSubmissionFiles.\n   *\n   * @param assignId Assignment ID.\n   * @param folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the files.\n   */\n  getStoredSubmissionFiles(assignId, folderName, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const folderPath = yield AddonModAssignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId);\n      return CoreFile.getDirectoryContents(folderPath);\n    })();\n  }\n  /**\n   * Get the size that will be uploaded to perform an attempt copy.\n   *\n   * @param assign Assignment.\n   * @param previousSubmission Submission to copy.\n   * @returns Promise resolved with the size.\n   */\n  getSubmissionSizeForCopy(assign, previousSubmission) {\n    return _asyncToGenerator(function* () {\n      let totalSize = 0;\n      const promises = previousSubmission.plugins ? previousSubmission.plugins.map(plugin => AddonModAssignSubmissionDelegate.getPluginSizeForCopy(assign, plugin).then(size => {\n        totalSize += size || 0;\n        return;\n      })) : [];\n      yield Promise.all(promises);\n      return totalSize;\n    })();\n  }\n  /**\n   * Get the size that will be uploaded to save a submission.\n   *\n   * @param assign Assignment.\n   * @param submission Submission to check data.\n   * @param inputData Data entered in the submission form.\n   * @returns Promise resolved with the size.\n   */\n  getSubmissionSizeForEdit(assign, submission, inputData) {\n    return _asyncToGenerator(function* () {\n      let totalSize = 0;\n      const promises = submission.plugins ? submission.plugins.map(plugin => AddonModAssignSubmissionDelegate.getPluginSizeForEdit(assign, submission, plugin, inputData).then(size => {\n        totalSize += size || 0;\n        return;\n      })) : [];\n      yield Promise.all(promises);\n      return totalSize;\n    })();\n  }\n  /**\n   * Get user data for submissions since they only have userid.\n   *\n   * @param assign Assignment object.\n   * @param submissions Submissions to get the data for.\n   * @param groupId Group Id.\n   * @param options Other options.\n   * @returns Promise always resolved. Resolve param is the formatted submissions.\n   */\n  getSubmissionsUserData(assign, submissions = [], groupId, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const participants = yield _this.getParticipants(assign, groupId, options);\n      const blind = !!assign.blindmarking && !assign.revealidentities;\n      const teamsubmission = !!assign.teamsubmission;\n      if (teamsubmission) {\n        // On team submission discard user submissions.\n        submissions = submissions.filter(submission => submission.userid == 0);\n      }\n      return participants.map(participant => {\n        var _participant$groupid;\n        const groupId = (_participant$groupid = participant.groupid) !== null && _participant$groupid !== void 0 ? _participant$groupid : participant.groups && participant.groups[0] ? participant.groups[0].id : 0;\n        const foundSubmission = submissions.find(submission => {\n          if (teamsubmission) {\n            return submission.groupid == groupId;\n          }\n          const submitId = submission.userid && submission.userid > 0 ? submission.userid : submission.blindid;\n          return participant.id == submitId;\n        });\n        let submission;\n        if (!foundSubmission) {\n          // Create submission if none.\n          submission = _this.createEmptySubmission();\n          submission.groupid = groupId;\n          submission.status = participant.submitted ? AddonModAssignSubmissionStatusValues.SUBMITTED : AddonModAssignSubmissionStatusValues.NEW;\n        } else {\n          submission = Object.assign({}, foundSubmission);\n        }\n        submission.submitid = participant.id;\n        if (!blind) {\n          submission.userid = participant.id;\n          submission.userfullname = participant.fullname;\n          submission.userprofileimageurl = participant.profileimageurl;\n        } else {\n          submission.blindid = participant.id;\n        }\n        submission.manyGroups = !!participant.groups && participant.groups.length > 1;\n        submission.noGroups = !!participant.groups && participant.groups.length == 0;\n        if (participant.groupname) {\n          submission.groupid = participant.groupid;\n          submission.groupname = participant.groupname;\n        }\n        return submission;\n      });\n    })();\n  }\n  /**\n   * Check if the feedback data has changed for a certain submission and assign.\n   *\n   * @param assign Assignment.\n   * @param submission The submission.\n   * @param feedback Feedback data.\n   * @param userId The user ID.\n   * @returns Promise resolved with true if data has changed, resolved with false otherwise.\n   */\n  hasFeedbackDataChanged(assign, submission, feedback, userId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!submission || !feedback.plugins) {\n        return false;\n      }\n      let hasChanged = false;\n      const promises = feedback.plugins.map(plugin => _this2.prepareFeedbackPluginData(assign.id, userId, feedback).then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (inputData) {\n          const changed = yield CoreUtils.ignoreErrors(AddonModAssignFeedbackDelegate.hasPluginDataChanged(assign, submission, plugin, inputData, userId), false);\n          if (changed) {\n            hasChanged = true;\n          }\n          return;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      yield CoreUtils.allPromises(promises);\n      return hasChanged;\n    })();\n  }\n  /**\n   * Check if the submission data has changed for a certain submission and assign.\n   *\n   * @param assign Assignment.\n   * @param submission Submission to check data.\n   * @param inputData Data entered in the submission form.\n   * @returns Promise resolved with true if data has changed, resolved with false otherwise.\n   */\n  hasSubmissionDataChanged(assign, submission, inputData) {\n    return _asyncToGenerator(function* () {\n      if (!submission) {\n        return false;\n      }\n      let hasChanged = false;\n      const promises = submission.plugins ? submission.plugins.map(plugin => AddonModAssignSubmissionDelegate.hasPluginDataChanged(assign, submission, plugin, inputData).then(changed => {\n        if (changed) {\n          hasChanged = true;\n        }\n        return;\n      }).catch(() => {\n        // Ignore errors.\n      })) : [];\n      yield CoreUtils.allPromises(promises);\n      return hasChanged;\n    })();\n  }\n  /**\n   * Prepare and return the plugin data to send for a certain feedback and assign.\n   *\n   * @param assignId Assignment Id.\n   * @param userId User Id.\n   * @param feedback Feedback data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with plugin data to send to server.\n   */\n  prepareFeedbackPluginData(assignId, userId, feedback, siteId) {\n    return _asyncToGenerator(function* () {\n      const pluginData = {};\n      const promises = feedback.plugins ? feedback.plugins.map(plugin => AddonModAssignFeedbackDelegate.preparePluginFeedbackData(assignId, userId, plugin, pluginData, siteId)) : [];\n      yield Promise.all(promises);\n      return pluginData;\n    })();\n  }\n  /**\n   * Prepare and return the plugin data to send for a certain submission and assign.\n   *\n   * @param assign Assignment.\n   * @param submission Submission to check data.\n   * @param inputData Data entered in the submission form.\n   * @param offline True to prepare the data for an offline submission, false otherwise.\n   * @returns Promise resolved with plugin data to send to server.\n   */\n  prepareSubmissionPluginData(assign, submission, inputData, offline = false) {\n    return _asyncToGenerator(function* () {\n      if (!submission || !submission.plugins) {\n        return {};\n      }\n      const pluginData = {};\n      const promises = submission.plugins.map(plugin => AddonModAssignSubmissionDelegate.preparePluginSubmissionData(assign, submission, plugin, inputData, pluginData, offline));\n      yield Promise.all(promises);\n      return pluginData;\n    })();\n  }\n  /**\n   * Given a list of files (either online files or local files), store the local files in a local folder\n   * to be submitted later.\n   *\n   * @param assignId Assignment ID.\n   * @param folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).\n   * @param files List of files.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  storeSubmissionFiles(assignId, folderName, files, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      // Get the folder where to store the files.\n      const folderPath = yield AddonModAssignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId);\n      return CoreFileUploader.storeFilesToUpload(folderPath, files);\n    })();\n  }\n  /**\n   * Upload a file to a draft area. If the file is an online file it will be downloaded and then re-uploaded.\n   *\n   * @param assignId Assignment ID.\n   * @param file Online file or local FileEntry.\n   * @param itemId Draft ID to use. Undefined or 0 to create a new draft ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the itemId.\n   */\n  uploadFile(assignId, file, itemId, siteId) {\n    return CoreFileUploader.uploadOrReuploadFile(file, itemId, AddonModAssignProvider.COMPONENT, assignId, siteId);\n  }\n  /**\n   * Given a list of files (either online files or local files), upload them to a draft area and return the draft ID.\n   * Online files will be downloaded and then re-uploaded.\n   * If there are no files to upload it will return a fake draft ID (1).\n   *\n   * @param assignId Assignment ID.\n   * @param files List of files.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the itemId.\n   */\n  uploadFiles(assignId, files, siteId) {\n    return CoreFileUploader.uploadOrReuploadFiles(files, AddonModAssignProvider.COMPONENT, assignId, siteId);\n  }\n  uploadOrStoreFiles(assignId, folderName, files, offline, userId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (offline) {\n        return _this3.storeSubmissionFiles(assignId, folderName, files, userId, siteId);\n      }\n      return _this3.uploadFiles(assignId, files, siteId);\n    })();\n  }\n}\n_class = AddonModAssignHelperProvider;\n_class.ɵfac = function AddonModAssignHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModAssignHelper = makeSingleton(AddonModAssignHelperProvider);","map":{"version":3,"names":["CoreFileUploader","CoreSites","AddonModAssignProvider","AddonModAssign","AddonModAssignSubmissionStatusValues","AddonModAssignOffline","CoreUtils","CoreFile","CoreGroups","AddonModAssignSubmissionDelegate","AddonModAssignFeedbackDelegate","makeSingleton","AddonModAssignHelperProvider","calculateEndTime","assign","submission","timeDue","timestarted","timelimit","duedate","Math","min","cutoffdate","canEditSubmissionOffline","_asyncToGenerator","status","NEW","REOPENED","canEdit","promises","plugins","map","plugin","canPluginEditOffline","then","canEditPlugin","Promise","all","clearSubmissionPluginTmpData","inputData","_submission$plugins","forEach","clearTmpData","copyPreviousAttempt","previousSubmission","pluginData","copyPluginSubmissionData","Object","keys","length","saveSubmissionOnline","id","createEmptyFeedback","grade","undefined","gradefordisplay","gradeddate","createEmptySubmission","userid","attemptnumber","timecreated","timemodified","groupid","deleteStoredSubmissionFiles","assignId","folderName","userId","siteId","folderPath","getSubmissionPluginFolder","removeDir","discardFeedbackPluginData","feedback","discardPluginFeedbackData","isSubmissionEmpty","_submission$plugins2","anyNotEmpty","some","isPluginEmpty","getParticipants","groupId","options","getCurrentSiteId","modOptions","_objectSpread","cmId","cmid","participants","listParticipants","groupsInfo","getActivityGroupInfo","participantsIndexed","groups","userGroup","participantsFromList","participant","objectToArray","getPluginConfig","subtype","type","configs","config","name","value","getPluginsEnabled","enabled","parseInt","push","getStoredSubmissionFiles","getDirectoryContents","getSubmissionSizeForCopy","totalSize","getPluginSizeForCopy","size","getSubmissionSizeForEdit","getPluginSizeForEdit","getSubmissionsUserData","submissions","_this","blind","blindmarking","revealidentities","teamsubmission","filter","_participant$groupid","foundSubmission","find","submitId","blindid","submitted","SUBMITTED","submitid","userfullname","fullname","userprofileimageurl","profileimageurl","manyGroups","noGroups","groupname","hasFeedbackDataChanged","_this2","hasChanged","prepareFeedbackPluginData","_ref","changed","ignoreErrors","hasPluginDataChanged","_x","apply","arguments","allPromises","hasSubmissionDataChanged","catch","preparePluginFeedbackData","prepareSubmissionPluginData","offline","preparePluginSubmissionData","storeSubmissionFiles","files","storeFilesToUpload","uploadFile","file","itemId","uploadOrReuploadFile","COMPONENT","uploadFiles","uploadOrReuploadFiles","uploadOrStoreFiles","_this3","factory","ɵfac","providedIn","AddonModAssignHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/assign/services/assign-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreFileUploader, CoreFileUploaderStoreFilesResult } from '@features/fileuploader/services/fileuploader';\nimport { CoreSites, CoreSitesCommonWSOptions } from '@services/sites';\nimport { FileEntry, DirectoryEntry } from '@awesome-cordova-plugins/file/ngx';\nimport {\n    AddonModAssignProvider,\n    AddonModAssignAssign,\n    AddonModAssignSubmission,\n    AddonModAssignParticipant,\n    AddonModAssignSubmissionFeedback,\n    AddonModAssign,\n    AddonModAssignPlugin,\n    AddonModAssignSavePluginData,\n    AddonModAssignSubmissionStatusValues,\n} from './assign';\nimport { AddonModAssignOffline } from './assign-offline';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreFile } from '@services/file';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreGroups } from '@services/groups';\nimport { AddonModAssignSubmissionDelegate } from './submission-delegate';\nimport { AddonModAssignFeedbackDelegate } from './feedback-delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreFormFields } from '@singletons/form';\nimport { CoreFileEntry } from '@services/file-helper';\n\n/**\n * Service that provides some helper functions for assign.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModAssignHelperProvider {\n\n    /**\n     * Calculate the end time (timestamp) for an assign and submission.\n     *\n     * @param assign Assign instance.\n     * @param submission Submission.\n     * @returns End time.\n     */\n    calculateEndTime(assign: AddonModAssignAssign, submission?: AddonModAssignSubmissionFormatted): number {\n        const timeDue = (submission?.timestarted || 0) + (assign.timelimit || 0);\n\n        if (assign.duedate) {\n            return Math.min(timeDue, assign.duedate);\n        } else if (assign.cutoffdate) {\n            return Math.min(timeDue, assign.cutoffdate);\n        }\n\n        return timeDue;\n    }\n\n    /**\n     * Check if a submission can be edited in offline.\n     *\n     * @param assign Assignment.\n     * @param submission Submission.\n     * @returns Whether it can be edited offline.\n     */\n    async canEditSubmissionOffline(assign: AddonModAssignAssign, submission?: AddonModAssignSubmission): Promise<boolean> {\n        if (!submission) {\n            return false;\n        }\n\n        if (submission.status == AddonModAssignSubmissionStatusValues.NEW ||\n                submission.status == AddonModAssignSubmissionStatusValues.REOPENED) {\n            // It's a new submission, allow creating it in offline.\n            return true;\n        }\n\n        let canEdit = true;\n\n        const promises = submission.plugins\n            ? submission.plugins.map((plugin) =>\n                AddonModAssignSubmissionDelegate.canPluginEditOffline(assign, submission, plugin).then((canEditPlugin) => {\n                    if (!canEditPlugin) {\n                        canEdit = false;\n                    }\n\n                    return;\n                }))\n            : [];\n\n        await Promise.all(promises);\n\n        return canEdit;\n    }\n\n    /**\n     * Clear plugins temporary data because a submission was cancelled.\n     *\n     * @param assign Assignment.\n     * @param submission Submission to clear the data for.\n     * @param inputData Data entered in the submission form.\n     */\n    clearSubmissionPluginTmpData(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission | undefined,\n        inputData: CoreFormFields,\n    ): void {\n        if (!submission) {\n            return;\n        }\n\n        submission.plugins?.forEach((plugin) => {\n            AddonModAssignSubmissionDelegate.clearTmpData(assign, submission, plugin, inputData);\n        });\n    }\n\n    /**\n     * Copy the data from last submitted attempt to the current submission.\n     * Since we don't have any WS for that we'll have to re-submit everything manually.\n     *\n     * @param assign Assignment.\n     * @param previousSubmission Submission to copy.\n     * @returns Promise resolved when done.\n     */\n    async copyPreviousAttempt(assign: AddonModAssignAssign, previousSubmission: AddonModAssignSubmission): Promise<void> {\n        const pluginData: AddonModAssignSavePluginData = {};\n        const promises = previousSubmission.plugins\n            ? previousSubmission.plugins.map((plugin) =>\n                AddonModAssignSubmissionDelegate.copyPluginSubmissionData(assign, plugin, pluginData))\n            : [];\n\n        await Promise.all(promises);\n\n        // We got the plugin data. Now we need to submit it.\n        if (Object.keys(pluginData).length) {\n            // There's something to save.\n            return AddonModAssign.saveSubmissionOnline(assign.id, pluginData);\n        }\n    }\n\n    /**\n     * Create an empty feedback object.\n     *\n     * @returns Feedback.\n     */\n    createEmptyFeedback(): AddonModAssignSubmissionFeedback {\n        return {\n            grade: undefined,\n            gradefordisplay: '',\n            gradeddate: 0,\n        };\n    }\n\n    /**\n     * Create an empty submission object.\n     *\n     * @returns Submission.\n     */\n    createEmptySubmission(): AddonModAssignSubmissionFormatted {\n        return {\n            id: 0,\n            userid: 0,\n            attemptnumber: 0,\n            timecreated: 0,\n            timemodified: 0,\n            status: AddonModAssignSubmissionStatusValues.NEW,\n            groupid: 0,\n        };\n    }\n\n    /**\n     * Delete stored submission files for a plugin. See storeSubmissionFiles.\n     *\n     * @param assignId Assignment ID.\n     * @param folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteStoredSubmissionFiles(assignId: number, folderName: string, userId?: number, siteId?: string): Promise<void> {\n        const folderPath = await AddonModAssignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId);\n\n        await CoreFile.removeDir(folderPath);\n    }\n\n    /**\n     * Delete all drafts of the feedback plugin data.\n     *\n     * @param assignId Assignment Id.\n     * @param userId User Id.\n     * @param feedback Feedback data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async discardFeedbackPluginData(\n        assignId: number,\n        userId: number,\n        feedback: AddonModAssignSubmissionFeedback,\n        siteId?: string,\n    ): Promise<void> {\n\n        const promises = feedback.plugins\n            ? feedback.plugins.map((plugin) =>\n                AddonModAssignFeedbackDelegate.discardPluginFeedbackData(assignId, userId, plugin, siteId))\n            : [];\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Check if a submission has no content.\n     *\n     * @param assign Assignment object.\n     * @param submission Submission to inspect.\n     * @returns Whether the submission is empty.\n     */\n    isSubmissionEmpty(assign: AddonModAssignAssign, submission?: AddonModAssignSubmission): boolean {\n        if (!submission) {\n            return true;\n        }\n\n        const anyNotEmpty = submission.plugins?.some((plugin) =>\n            !AddonModAssignSubmissionDelegate.isPluginEmpty(assign, plugin));\n\n        // If any plugin is not empty, we consider that the submission is not empty either.\n        if (anyNotEmpty) {\n            return false;\n        }\n\n        // If all the plugins were empty (or there were no plugins), we consider the submission to be empty.\n        return true;\n    }\n\n    /**\n     * List the participants for a single assignment, with some summary info about their submissions.\n     *\n     * @param assign Assignment object.\n     * @param groupId Group Id.\n     * @param options Other options.\n     * @returns Promise resolved with the list of participants and summary of submissions.\n     */\n    async getParticipants(\n        assign: AddonModAssignAssign,\n        groupId?: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModAssignParticipant[]> {\n\n        groupId = groupId || 0;\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        // Create new options including all existing ones.\n        const modOptions: CoreCourseCommonModWSOptions = { cmId: assign.cmid, ...options };\n\n        const participants = await AddonModAssign.listParticipants(assign.id, groupId, modOptions);\n\n        if (groupId || participants && participants.length > 0) {\n            return participants;\n        }\n\n        // If no participants returned and all groups specified, get participants by groups.\n        const groupsInfo = await CoreGroups.getActivityGroupInfo(assign.cmid, false, undefined, modOptions.siteId);\n\n        const participantsIndexed: {[id: number]: AddonModAssignParticipant} = {};\n\n        const promises = groupsInfo.groups\n            ? groupsInfo.groups.map((userGroup) =>\n                AddonModAssign.listParticipants(assign.id, userGroup.id, modOptions).then((participantsFromList) => {\n                    // Do not get repeated users.\n                    participantsFromList.forEach((participant) => {\n                        participantsIndexed[participant.id] = participant;\n                    });\n\n                    return;\n                }))\n            :[];\n\n        await Promise.all(promises);\n\n        return CoreUtils.objectToArray(participantsIndexed);\n    }\n\n    /**\n     * Get plugin config from assignment config.\n     *\n     * @param assign Assignment object including all config.\n     * @param subtype Subtype name (assignsubmission or assignfeedback)\n     * @param type Name of the subplugin.\n     * @returns Object containing all configurations of the subplugin selected.\n     */\n    getPluginConfig(assign: AddonModAssignAssign, subtype: string, type: string): AddonModAssignPluginConfig {\n        const configs: AddonModAssignPluginConfig = {};\n\n        assign.configs.forEach((config) => {\n            if (config.subtype == subtype && config.plugin == type) {\n                configs[config.name] = config.value;\n            }\n        });\n\n        return configs;\n    }\n\n    /**\n     * Get enabled subplugins.\n     *\n     * @param assign Assignment object including all config.\n     * @param subtype Subtype name (assignsubmission or assignfeedback)\n     * @returns List of enabled plugins for the assign.\n     */\n    getPluginsEnabled(assign: AddonModAssignAssign, subtype: string): AddonModAssignPlugin[] {\n        const enabled: AddonModAssignPlugin[] = [];\n\n        assign.configs.forEach((config) => {\n            if (config.subtype == subtype && config.name == 'enabled' && parseInt(config.value, 10) === 1) {\n                // Format the plugin objects.\n                enabled.push({\n                    type: config.plugin,\n                    name: config.plugin,\n                });\n            }\n        });\n\n        return enabled;\n    }\n\n    /**\n     * Get a list of stored submission files. See storeSubmissionFiles.\n     *\n     * @param assignId Assignment ID.\n     * @param folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the files.\n     */\n    async getStoredSubmissionFiles(\n        assignId: number,\n        folderName: string,\n        userId?: number,\n        siteId?: string,\n    ): Promise<(FileEntry | DirectoryEntry)[]> {\n        const folderPath = await AddonModAssignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId);\n\n        return CoreFile.getDirectoryContents(folderPath);\n    }\n\n    /**\n     * Get the size that will be uploaded to perform an attempt copy.\n     *\n     * @param assign Assignment.\n     * @param previousSubmission Submission to copy.\n     * @returns Promise resolved with the size.\n     */\n    async getSubmissionSizeForCopy(assign: AddonModAssignAssign, previousSubmission: AddonModAssignSubmission): Promise<number> {\n        let totalSize = 0;\n\n        const promises = previousSubmission.plugins\n            ? previousSubmission.plugins.map((plugin) =>\n                AddonModAssignSubmissionDelegate.getPluginSizeForCopy(assign, plugin).then((size) => {\n                    totalSize += (size || 0);\n\n                    return;\n                }))\n            : [];\n\n        await Promise.all(promises);\n\n        return totalSize;\n    }\n\n    /**\n     * Get the size that will be uploaded to save a submission.\n     *\n     * @param assign Assignment.\n     * @param submission Submission to check data.\n     * @param inputData Data entered in the submission form.\n     * @returns Promise resolved with the size.\n     */\n    async getSubmissionSizeForEdit(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission,\n        inputData: CoreFormFields,\n    ): Promise<number> {\n\n        let totalSize = 0;\n\n        const promises = submission.plugins\n            ? submission.plugins.map((plugin) =>\n                AddonModAssignSubmissionDelegate.getPluginSizeForEdit(assign, submission, plugin, inputData)\n                    .then((size) => {\n                        totalSize += (size || 0);\n\n                        return;\n                    }))\n            : [];\n\n        await Promise.all(promises);\n\n        return totalSize;\n    }\n\n    /**\n     * Get user data for submissions since they only have userid.\n     *\n     * @param assign Assignment object.\n     * @param submissions Submissions to get the data for.\n     * @param groupId Group Id.\n     * @param options Other options.\n     * @returns Promise always resolved. Resolve param is the formatted submissions.\n     */\n    async getSubmissionsUserData(\n        assign: AddonModAssignAssign,\n        submissions: AddonModAssignSubmissionFormatted[] = [],\n        groupId?: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModAssignSubmissionFormatted[]> {\n        const participants = await this.getParticipants(assign, groupId, options);\n\n        const blind = !!assign.blindmarking && !assign.revealidentities;\n        const teamsubmission = !!assign.teamsubmission;\n\n        if (teamsubmission) {\n            // On team submission discard user submissions.\n            submissions = submissions.filter((submission) => submission.userid == 0);\n        }\n\n        return participants.map((participant) => {\n            const groupId = participant.groupid ??\n                (participant.groups && participant.groups[0] ? participant.groups[0].id : 0);\n\n            const foundSubmission = submissions.find((submission) => {\n                if (teamsubmission) {\n                    return submission.groupid == groupId;\n                }\n\n                const submitId = submission.userid && submission.userid > 0 ? submission.userid : submission.blindid;\n\n                return participant.id == submitId;\n            });\n\n            let submission: AddonModAssignSubmissionFormatted | undefined;\n            if (!foundSubmission) {\n                // Create submission if none.\n                submission = this.createEmptySubmission();\n                submission.groupid = groupId;\n                submission.status = participant.submitted\n                    ? AddonModAssignSubmissionStatusValues.SUBMITTED\n                    : AddonModAssignSubmissionStatusValues.NEW;\n            } else {\n                submission = Object.assign({}, foundSubmission);\n            }\n\n            submission.submitid = participant.id;\n\n            if (!blind) {\n                submission.userid = participant.id;\n                submission.userfullname = participant.fullname;\n                submission.userprofileimageurl = participant.profileimageurl;\n            } else {\n                submission.blindid = participant.id;\n            }\n\n            submission.manyGroups = !!participant.groups && participant.groups.length > 1;\n            submission.noGroups = !!participant.groups && participant.groups.length == 0;\n            if (participant.groupname) {\n                submission.groupid = participant.groupid;\n                submission.groupname = participant.groupname;\n            }\n\n            return submission;\n\n        });\n    }\n\n    /**\n     * Check if the feedback data has changed for a certain submission and assign.\n     *\n     * @param assign Assignment.\n     * @param submission The submission.\n     * @param feedback Feedback data.\n     * @param userId The user ID.\n     * @returns Promise resolved with true if data has changed, resolved with false otherwise.\n     */\n    async hasFeedbackDataChanged(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission | AddonModAssignSubmissionFormatted | undefined,\n        feedback: AddonModAssignSubmissionFeedback,\n        userId: number,\n    ): Promise<boolean> {\n        if (!submission || !feedback.plugins) {\n            return false;\n        }\n\n        let hasChanged = false;\n\n        const promises = feedback.plugins.map((plugin) =>\n            this.prepareFeedbackPluginData(assign.id, userId, feedback).then(async (inputData) => {\n                const changed = await CoreUtils.ignoreErrors(\n                    AddonModAssignFeedbackDelegate.hasPluginDataChanged(assign, submission, plugin, inputData, userId),\n                    false,\n                );\n                if (changed) {\n                    hasChanged = true;\n                }\n\n                return;\n            }));\n\n        await CoreUtils.allPromises(promises);\n\n        return hasChanged;\n    }\n\n    /**\n     * Check if the submission data has changed for a certain submission and assign.\n     *\n     * @param assign Assignment.\n     * @param submission Submission to check data.\n     * @param inputData Data entered in the submission form.\n     * @returns Promise resolved with true if data has changed, resolved with false otherwise.\n     */\n    async hasSubmissionDataChanged(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission | undefined,\n        inputData: CoreFormFields,\n    ): Promise<boolean> {\n        if (!submission) {\n            return false;\n        }\n\n        let hasChanged = false;\n\n        const promises = submission.plugins\n            ? submission.plugins.map((plugin) =>\n                AddonModAssignSubmissionDelegate.hasPluginDataChanged(assign, submission, plugin, inputData)\n                    .then((changed) => {\n                        if (changed) {\n                            hasChanged = true;\n                        }\n\n                        return;\n                    }).catch(() => {\n                        // Ignore errors.\n                    }))\n            : [];\n\n        await CoreUtils.allPromises(promises);\n\n        return hasChanged;\n    }\n\n    /**\n     * Prepare and return the plugin data to send for a certain feedback and assign.\n     *\n     * @param assignId Assignment Id.\n     * @param userId User Id.\n     * @param feedback Feedback data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with plugin data to send to server.\n     */\n    async prepareFeedbackPluginData(\n        assignId: number,\n        userId: number,\n        feedback: AddonModAssignSubmissionFeedback,\n        siteId?: string,\n    ): Promise<AddonModAssignSavePluginData> {\n\n        const pluginData: CoreFormFields = {};\n        const promises = feedback.plugins\n            ? feedback.plugins.map((plugin) =>\n                AddonModAssignFeedbackDelegate.preparePluginFeedbackData(assignId, userId, plugin, pluginData, siteId))\n            : [];\n\n        await Promise.all(promises);\n\n        return pluginData;\n    }\n\n    /**\n     * Prepare and return the plugin data to send for a certain submission and assign.\n     *\n     * @param assign Assignment.\n     * @param submission Submission to check data.\n     * @param inputData Data entered in the submission form.\n     * @param offline True to prepare the data for an offline submission, false otherwise.\n     * @returns Promise resolved with plugin data to send to server.\n     */\n    async prepareSubmissionPluginData(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission | undefined,\n        inputData: CoreFormFields,\n        offline = false,\n    ): Promise<AddonModAssignSavePluginData> {\n\n        if (!submission || !submission.plugins) {\n            return {};\n        }\n\n        const pluginData: AddonModAssignSavePluginData = {};\n        const promises = submission.plugins.map((plugin) =>\n            AddonModAssignSubmissionDelegate.preparePluginSubmissionData(\n                assign,\n                submission,\n                plugin,\n                inputData,\n                pluginData,\n                offline,\n            ));\n\n        await Promise.all(promises);\n\n        return pluginData;\n    }\n\n    /**\n     * Given a list of files (either online files or local files), store the local files in a local folder\n     * to be submitted later.\n     *\n     * @param assignId Assignment ID.\n     * @param folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).\n     * @param files List of files.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    async storeSubmissionFiles(\n        assignId: number,\n        folderName: string,\n        files: CoreFileEntry[],\n        userId?: number,\n        siteId?: string,\n    ): Promise<CoreFileUploaderStoreFilesResult> {\n        // Get the folder where to store the files.\n        const folderPath = await AddonModAssignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId);\n\n        return CoreFileUploader.storeFilesToUpload(folderPath, files);\n    }\n\n    /**\n     * Upload a file to a draft area. If the file is an online file it will be downloaded and then re-uploaded.\n     *\n     * @param assignId Assignment ID.\n     * @param file Online file or local FileEntry.\n     * @param itemId Draft ID to use. Undefined or 0 to create a new draft ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the itemId.\n     */\n    uploadFile(assignId: number, file: CoreFileEntry, itemId?: number, siteId?: string): Promise<number> {\n        return CoreFileUploader.uploadOrReuploadFile(file, itemId, AddonModAssignProvider.COMPONENT, assignId, siteId);\n    }\n\n    /**\n     * Given a list of files (either online files or local files), upload them to a draft area and return the draft ID.\n     * Online files will be downloaded and then re-uploaded.\n     * If there are no files to upload it will return a fake draft ID (1).\n     *\n     * @param assignId Assignment ID.\n     * @param files List of files.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the itemId.\n     */\n    uploadFiles(assignId: number, files: CoreFileEntry[], siteId?: string): Promise<number> {\n        return CoreFileUploader.uploadOrReuploadFiles(files, AddonModAssignProvider.COMPONENT, assignId, siteId);\n    }\n\n    /**\n     * Upload or store some files, depending if the user is offline or not.\n     *\n     * @param assignId Assignment ID.\n     * @param folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).\n     * @param files List of files.\n     * @param offline True if files sould be stored for offline, false to upload them.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async uploadOrStoreFiles(\n        assignId: number,\n        folderName: string,\n        files: CoreFileEntry[],\n        offline: true,\n        userId?: number,\n        siteId?: string,\n    ): Promise<CoreFileUploaderStoreFilesResult>;\n    async uploadOrStoreFiles(\n        assignId: number,\n        folderName: string,\n        files: CoreFileEntry[],\n        offline: false,\n        userId?: number,\n        siteId?: string,\n    ): Promise<number>;\n    async uploadOrStoreFiles(\n        assignId: number,\n        folderName: string,\n        files: CoreFileEntry[],\n        offline: boolean,\n        userId?: number,\n        siteId?: string,\n    ): Promise<number | CoreFileUploaderStoreFilesResult>;\n    async uploadOrStoreFiles(\n        assignId: number,\n        folderName: string,\n        files: CoreFileEntry[],\n        offline: boolean,\n        userId?: number,\n        siteId?: string,\n    ): Promise<number | CoreFileUploaderStoreFilesResult> {\n\n        if (offline) {\n            return this.storeSubmissionFiles(assignId, folderName, files, userId, siteId);\n        }\n\n        return this.uploadFiles(assignId, files, siteId);\n    }\n\n}\nexport const AddonModAssignHelper = makeSingleton(AddonModAssignHelperProvider);\n\n/**\n * Assign submission with some calculated data.\n */\nexport type AddonModAssignSubmissionFormatted =\n    Omit<AddonModAssignSubmission, 'userid'|'groupid'> & {\n        userid?: number; // Student id.\n        groupid?: number; // Group id.\n        blindid?: number; // Calculated in the app. Blindid of the user that did the submission.\n        submitid?: number; // Calculated in the app. Userid or blindid of the user that did the submission.\n        userfullname?: string; // Calculated in the app. Full name of the user that did the submission.\n        userprofileimageurl?: string; // Calculated in the app. Avatar of the user that did the submission.\n        manyGroups?: boolean; // Calculated in the app. Whether the user belongs to more than 1 group.\n        noGroups?: boolean; // Calculated in the app. Whether the user doesn't belong to any group.\n        groupname?: string; // Calculated in the app. Name of the group the submission belongs to.\n    };\n\n/**\n * Assignment plugin config.\n */\nexport type AddonModAssignPluginConfig = {[name: string]: string};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}