{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreContentLinksDelegate } from '@features/contentlinks/services/contentlinks-delegate';\nimport { CoreContentLinksHelper } from '@features/contentlinks/services/contentlinks-helper';\nimport { CoreLoginHelper } from '@features/login/services/login-helper';\nimport { ApplicationInit, makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CorePath } from '@singletons/path';\nimport { CoreConstants } from '../constants';\nimport { CoreApp } from './app';\nimport { CoreNavigator } from './navigator';\nimport { CoreSites } from './sites';\nimport { CoreDomUtils } from './utils/dom';\nimport { CoreTextUtils } from './utils/text';\nimport { CoreUrlUtils } from './utils/url';\nimport { CoreUtils } from './utils/utils';\nimport * as i0 from \"@angular/core\";\n/*\n * Provider to handle custom URL schemes.\n */\nexport class CoreCustomURLSchemesProvider {\n  constructor() {\n    this.lastUrls = {};\n    this.logger = CoreLogger.getInstance('CoreCustomURLSchemesProvider');\n  }\n  /**\n   * Given some data of a custom URL with a token, create a site if it needs to be created.\n   *\n   * @param data URL data.\n   * @returns Promise resolved with the site ID if created or already exists.\n   */\n  createSiteIfNeeded(data) {\n    return _asyncToGenerator(function* () {\n      if (!data.token) {\n        return;\n      }\n      const currentSite = CoreSites.getCurrentSite();\n      if (!currentSite || currentSite.getToken() != data.token || currentSite.isLoggedOut()) {\n        // Token belongs to a different site or site is logged out, create it. It doesn't matter if it already exists.\n        if (!data.siteUrl.match(/^https?:\\/\\//)) {\n          // URL doesn't have a protocol and it's required to be able to create the site. Check which one to use.\n          const result = yield CoreSites.checkSite(data.siteUrl);\n          data.siteUrl = result.siteUrl;\n          yield CoreSites.checkApplication(result.config);\n        }\n        return CoreSites.newSite(data.siteUrl, data.token, data.privateToken, !!data.isSSOToken, CoreLoginHelper.getOAuthIdFromParams(data.ssoUrlParams));\n      } else {\n        // Token belongs to current site, no need to create it.\n        return CoreSites.getCurrentSiteId();\n      }\n    })();\n  }\n  /**\n   * Handle an URL received by custom URL scheme.\n   *\n   * @param url URL to treat.\n   * @returns Promise resolved when done. If rejected, the parameter is of type CoreCustomURLSchemesHandleError.\n   */\n  handleCustomURL(url) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.isCustomURL(url)) {\n        throw new CoreCustomURLSchemesHandleError(null);\n      }\n      /* First check that this URL hasn't been treated a few seconds ago. The function that handles custom URL schemes already\n         does this, but this function is called from other places so we need to handle it in here too. */\n      if (_this.lastUrls[url] && Date.now() - _this.lastUrls[url] < 3000) {\n        // Function called more than once, stop.\n        return;\n      }\n      _this.lastUrls[url] = Date.now();\n      url = CoreTextUtils.decodeURIComponent(url);\n      // Wait for app to be ready.\n      yield ApplicationInit.donePromise;\n      // Some platforms like Windows add a slash at the end. Remove it.\n      // Some sites add a # at the end of the URL. If it's there, remove it.\n      url = url.replace(/\\/?(#.*)?\\/?$/, '');\n      const modal = yield CoreDomUtils.showModalLoading();\n      let data;\n      // Get the data from the URL.\n      try {\n        if (_this.isCustomURLToken(url)) {\n          data = yield _this.getCustomURLTokenData(url);\n        } else if (_this.isCustomURLLink(url)) {\n          // In iOS, the protocol after the scheme doesn't have \":\". Add it.\n          url = url.replace(/\\/\\/link=(https?)\\/\\//, '//link=$1://');\n          data = yield _this.getCustomURLLinkData(url);\n        } else {\n          // In iOS, the protocol after the scheme doesn't have \":\". Add it.\n          url = url.replace(/\\/\\/(https?)\\/\\//, '//$1://');\n          data = yield _this.getCustomURLData(url);\n        }\n      } catch (error) {\n        modal.dismiss();\n        throw error;\n      }\n      try {\n        const isValid = yield CoreLoginHelper.isSiteUrlAllowed(data.siteUrl);\n        if (!isValid) {\n          throw Translate.instant('core.errorurlschemeinvalidsite');\n        }\n        if (data.redirect && data.redirect.match(/^https?:\\/\\//) && data.redirect.indexOf(data.siteUrl) == -1) {\n          // Redirect URL must belong to the same site. Reject.\n          throw Translate.instant('core.contentlinks.errorredirectothersite');\n        }\n        // First of all, create the site if needed.\n        const siteId = yield _this.createSiteIfNeeded(data);\n        if (data.isSSOToken || data.isAuthenticationURL && siteId && CoreSites.getCurrentSiteId() == siteId) {\n          // Site created and authenticated, open the page to go.\n          CoreNavigator.navigateToSiteHome({\n            params: {\n              redirectPath: data.redirectPath,\n              redirectOptions: data.redirectOptions,\n              urlToOpen: data.urlToOpen\n            }\n          });\n          return;\n        }\n        if (data.redirect && !data.redirect.match(/^https?:\\/\\//)) {\n          // Redirect is a relative URL. Append the site URL.\n          data.redirect = CorePath.concatenatePaths(data.siteUrl, data.redirect);\n        }\n        let siteIds = [siteId];\n        if (!siteId) {\n          // No site created, check if the site is stored (to know which one to use).\n          siteIds = yield CoreSites.getSiteIdsFromUrl(data.siteUrl, true, data.username);\n        }\n        if (siteIds.length > 1) {\n          // More than one site to treat the URL, let the user choose.\n          CoreContentLinksHelper.goToChooseSite(data.redirect || data.siteUrl);\n        } else if (siteIds.length == 1) {\n          // Only one site, handle the link.\n          const site = yield CoreSites.getSite(siteIds[0]);\n          if (!data.redirect) {\n            // No redirect, go to the root URL if needed.\n            yield CoreContentLinksHelper.handleRootURL(site, false, true);\n          } else {\n            var _site$getInfo;\n            // Handle the redirect link.\n            modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.\n            /* Always use the username from the site in this case. If the link has a username and a token,\n               this will make sure that the link is opened with the user the token belongs to. */\n            const username = ((_site$getInfo = site.getInfo()) === null || _site$getInfo === void 0 ? void 0 : _site$getInfo.username) || data.username;\n            const treated = yield CoreContentLinksHelper.handleLink(data.redirect, username);\n            if (!treated) {\n              CoreDomUtils.showErrorModal('core.contentlinks.errornoactions', true);\n            }\n          }\n        } else {\n          // Site not stored. Try to add the site.\n          const result = yield CoreSites.checkSite(data.siteUrl);\n          // Site exists. We'll allow to add it.\n          modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.\n          yield _this.goToAddSite(data, result);\n        }\n      } catch (error) {\n        throw new CoreCustomURLSchemesHandleError(error, data);\n      } finally {\n        modal.dismiss();\n        if (data.isSSOToken) {\n          CoreApp.finishSSOAuthentication();\n        }\n      }\n    })();\n  }\n  /**\n   * Get the data from a custom URL scheme. The structure of the URL is:\n   * moodlemobile://username@domain.com?token=TOKEN&privatetoken=PRIVATETOKEN&redirect=http://domain.com/course/view.php?id=2\n   *\n   * @param url URL to treat.\n   * @returns Promise resolved with the data.\n   */\n  getCustomURLData(url) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.isCustomURL(url)) {\n        throw new CoreCustomURLSchemesHandleError(null);\n      }\n      // App opened using custom URL scheme.\n      _this2.logger.debug('Treating custom URL scheme: ' + url);\n      // Delete the sso scheme from the URL.\n      url = _this2.removeCustomURLScheme(url);\n      // Detect if there's a user specified.\n      const username = CoreUrlUtils.getUsernameFromUrl(url);\n      if (username) {\n        url = url.replace(username + '@', ''); // Remove the username from the URL.\n      }\n      // Get the params of the URL.\n      const params = CoreUrlUtils.extractUrlParams(url);\n      // Remove the params to get the site URL.\n      if (url.indexOf('?') != -1) {\n        url = url.substring(0, url.indexOf('?'));\n      }\n      if (!url.match(/https?:\\/\\//)) {\n        // Url doesn't have a protocol. Check if the site is stored in the app to be able to determine the protocol.\n        const siteIds = yield CoreSites.getSiteIdsFromUrl(url, true, username);\n        if (siteIds.length) {\n          // There is at least 1 site with this URL. Use it to know the full URL.\n          const site = yield CoreSites.getSite(siteIds[0]);\n          url = site.getURL();\n        }\n      }\n      return {\n        siteUrl: url,\n        username: username,\n        token: params.token,\n        privateToken: params.privateToken,\n        redirect: params.redirect,\n        isAuthenticationURL: !!params.token\n      };\n    })();\n  }\n  /**\n   * Get the data from a \"link\" custom URL scheme. This kind of URL is deprecated.\n   *\n   * @param url URL to treat.\n   * @returns Promise resolved with the data.\n   */\n  getCustomURLLinkData(url) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.isCustomURLLink(url)) {\n        throw new CoreCustomURLSchemesHandleError(null);\n      }\n      // App opened using custom URL scheme.\n      _this3.logger.debug('Treating custom URL scheme with link param: ' + url);\n      // Delete the sso scheme from the URL.\n      url = _this3.removeCustomURLLinkScheme(url);\n      // Detect if there's a user specified.\n      const username = CoreUrlUtils.getUsernameFromUrl(url);\n      if (username) {\n        url = url.replace(username + '@', ''); // Remove the username from the URL.\n      }\n      // First of all, check if it's the root URL of a site.\n      const data = yield CoreSites.isStoredRootURL(url, username);\n      if (data.site) {\n        // Root URL.\n        return {\n          siteUrl: data.site.getURL(),\n          username: username\n        };\n      } else if (data.siteIds.length > 0) {\n        // Not the root URL, but at least 1 site supports the URL. Get the site URL from the list of sites.\n        const site = yield CoreSites.getSite(data.siteIds[0]);\n        return {\n          siteUrl: site.getURL(),\n          username: username,\n          redirect: url\n        };\n      } else {\n        // Get the site URL.\n        let siteUrl = CoreContentLinksDelegate.getSiteUrl(url);\n        let redirect = url;\n        if (!siteUrl) {\n          // Site URL not found, use the original URL since it could be the root URL of the site.\n          siteUrl = url;\n          redirect = undefined;\n        }\n        return {\n          siteUrl: siteUrl,\n          username: username,\n          redirect: redirect\n        };\n      }\n    })();\n  }\n  /**\n   * Get the data from a \"token\" custom URL scheme. This kind of URL is deprecated.\n   *\n   * @param url URL to treat.\n   * @returns Promise resolved with the data.\n   */\n  getCustomURLTokenData(url) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this4.isCustomURLToken(url)) {\n        throw new CoreCustomURLSchemesHandleError(null);\n      }\n      if (CoreApp.isSSOAuthenticationOngoing()) {\n        // Authentication ongoing, probably duplicated request.\n        throw new CoreCustomURLSchemesHandleError('Duplicated');\n      }\n      // App opened using custom URL scheme. Probably an SSO authentication.\n      CoreApp.startSSOAuthentication();\n      _this4.logger.debug('App launched by URL with an SSO');\n      // Delete the sso scheme from the URL.\n      url = _this4.removeCustomURLTokenScheme(url);\n      // Some platforms like Windows add a slash at the end. Remove it.\n      // Some sites add a # at the end of the URL. If it's there, remove it.\n      url = url.replace(/\\/?#?\\/?$/, '');\n      // Decode from base64.\n      try {\n        url = atob(url);\n      } catch (err) {\n        // Error decoding the parameter.\n        _this4.logger.error('Error decoding parameter received for login SSO');\n        throw new CoreCustomURLSchemesHandleError(null);\n      }\n      const data = yield CoreLoginHelper.validateBrowserSSOLogin(url);\n      data.isSSOToken = true;\n      data.isAuthenticationURL = true;\n      return data;\n    })();\n  }\n  /**\n   * Go to page to add a site, or open a browser if SSO.\n   *\n   * @param data URL data.\n   * @param siteCheck Result of checkSite.\n   * @returns Promise resolved when done.\n   */\n  goToAddSite(data, siteCheck) {\n    return _asyncToGenerator(function* () {\n      const pageParams = {\n        username: data.username,\n        urlToOpen: data.redirect,\n        siteCheck\n      };\n      if (CoreSites.isLoggedIn()) {\n        // Ask the user before changing site.\n        yield CoreDomUtils.showConfirm(Translate.instant('core.contentlinks.confirmurlothersite'));\n        const willReload = yield CoreSites.logoutForRedirect(CoreConstants.NO_SITE_ID, {\n          redirectPath: '/login/credentials',\n          redirectOptions: {\n            params: pageParams\n          }\n        });\n        if (willReload) {\n          return;\n        }\n      }\n      yield CoreNavigator.navigateToLoginCredentials(pageParams);\n    })();\n  }\n  /**\n   * Check whether a URL is a custom URL scheme.\n   *\n   * @param url URL to check.\n   * @returns Whether it's a custom URL scheme.\n   */\n  isCustomURL(url) {\n    if (!url) {\n      return false;\n    }\n    return url.indexOf(CoreConstants.CONFIG.customurlscheme + '://') != -1;\n  }\n  /**\n   * Check whether a URL is a custom URL scheme with the \"link\" param (deprecated).\n   *\n   * @param url URL to check.\n   * @returns Whether it's a custom URL scheme.\n   */\n  isCustomURLLink(url) {\n    if (!url) {\n      return false;\n    }\n    return url.indexOf(CoreConstants.CONFIG.customurlscheme + '://link=') != -1;\n  }\n  /**\n   * Check whether a URL is a custom URL scheme with a \"token\" param (deprecated).\n   *\n   * @param url URL to check.\n   * @returns Whether it's a custom URL scheme.\n   */\n  isCustomURLToken(url) {\n    if (!url) {\n      return false;\n    }\n    return url.indexOf(CoreConstants.CONFIG.customurlscheme + '://token=') != -1;\n  }\n  /**\n   * Remove the scheme from a custom URL.\n   *\n   * @param url URL to treat.\n   * @returns URL without scheme.\n   */\n  removeCustomURLScheme(url) {\n    return url.replace(CoreConstants.CONFIG.customurlscheme + '://', '');\n  }\n  /**\n   * Remove the scheme and the \"link=\" prefix from a link custom URL.\n   *\n   * @param url URL to treat.\n   * @returns URL without scheme and prefix.\n   */\n  removeCustomURLLinkScheme(url) {\n    return url.replace(CoreConstants.CONFIG.customurlscheme + '://link=', '');\n  }\n  /**\n   * Remove the scheme and the \"token=\" prefix from a token custom URL.\n   *\n   * @param url URL to treat.\n   * @returns URL without scheme and prefix.\n   */\n  removeCustomURLTokenScheme(url) {\n    return url.replace(CoreConstants.CONFIG.customurlscheme + '://token=', '');\n  }\n  /**\n   * Treat error returned by handleCustomURL.\n   *\n   * @param error Error data.\n   */\n  treatHandleCustomURLError(error) {\n    if (error.error == 'Duplicated') {\n      // Duplicated request\n    } else if (CoreUtils.isWebServiceError(error.error) && error.data && error.data.isSSOToken) {\n      // An error occurred, display the error and logout the user.\n      CoreLoginHelper.treatUserTokenError(error.data.siteUrl, error.error);\n      CoreSites.logout();\n    } else {\n      CoreDomUtils.showErrorModalDefault(error.error, Translate.instant('core.login.invalidsite'));\n    }\n  }\n}\n/**\n * Error returned by handleCustomURL.\n */\n_class = CoreCustomURLSchemesProvider;\n_class.ɵfac = function CoreCustomURLSchemesProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport class CoreCustomURLSchemesHandleError extends CoreError {\n  /**\n   * Constructor.\n   *\n   * @param error The error message or object.\n   * @param data Data obtained from the URL (if any).\n   */\n  constructor(error, data) {\n    super(CoreTextUtils.getErrorMessageFromError(error));\n    this.error = error;\n    this.data = data;\n  }\n}\nexport const CoreCustomURLSchemes = makeSingleton(CoreCustomURLSchemesProvider);","map":{"version":3,"names":["CoreError","CoreContentLinksDelegate","CoreContentLinksHelper","CoreLoginHelper","ApplicationInit","makeSingleton","Translate","CoreLogger","CorePath","CoreConstants","CoreApp","CoreNavigator","CoreSites","CoreDomUtils","CoreTextUtils","CoreUrlUtils","CoreUtils","CoreCustomURLSchemesProvider","constructor","lastUrls","logger","getInstance","createSiteIfNeeded","data","_asyncToGenerator","token","currentSite","getCurrentSite","getToken","isLoggedOut","siteUrl","match","result","checkSite","checkApplication","config","newSite","privateToken","isSSOToken","getOAuthIdFromParams","ssoUrlParams","getCurrentSiteId","handleCustomURL","url","_this","isCustomURL","CoreCustomURLSchemesHandleError","Date","now","decodeURIComponent","donePromise","replace","modal","showModalLoading","isCustomURLToken","getCustomURLTokenData","isCustomURLLink","getCustomURLLinkData","getCustomURLData","error","dismiss","isValid","isSiteUrlAllowed","instant","redirect","indexOf","siteId","isAuthenticationURL","navigateToSiteHome","params","redirectPath","redirectOptions","urlToOpen","concatenatePaths","siteIds","getSiteIdsFromUrl","username","length","goToChooseSite","site","getSite","handleRootURL","_site$getInfo","getInfo","treated","handleLink","showErrorModal","goToAddSite","finishSSOAuthentication","_this2","debug","removeCustomURLScheme","getUsernameFromUrl","extractUrlParams","substring","getURL","_this3","removeCustomURLLinkScheme","isStoredRootURL","getSiteUrl","undefined","_this4","isSSOAuthenticationOngoing","startSSOAuthentication","removeCustomURLTokenScheme","atob","err","validateBrowserSSOLogin","siteCheck","pageParams","isLoggedIn","showConfirm","willReload","logoutForRedirect","NO_SITE_ID","navigateToLoginCredentials","CONFIG","customurlscheme","treatHandleCustomURLError","isWebServiceError","treatUserTokenError","logout","showErrorModalDefault","_class","factory","ɵfac","providedIn","getErrorMessageFromError","CoreCustomURLSchemes"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/urlschemes.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreContentLinksDelegate } from '@features/contentlinks/services/contentlinks-delegate';\nimport { CoreContentLinksHelper } from '@features/contentlinks/services/contentlinks-helper';\nimport { CoreLoginHelper, CoreLoginSSOData } from '@features/login/services/login-helper';\nimport { ApplicationInit, makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CorePath } from '@singletons/path';\nimport { CoreConstants } from '../constants';\nimport { CoreApp } from './app';\nimport { CoreNavigator, CoreRedirectPayload } from './navigator';\nimport { CoreSiteCheckResponse, CoreSites } from './sites';\nimport { CoreDomUtils } from './utils/dom';\nimport { CoreTextErrorObject, CoreTextUtils } from './utils/text';\nimport { CoreUrlUtils } from './utils/url';\nimport { CoreUtils } from './utils/utils';\n\n/*\n * Provider to handle custom URL schemes.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCustomURLSchemesProvider {\n\n    protected logger: CoreLogger;\n    protected lastUrls: Record<string, number> = {};\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreCustomURLSchemesProvider');\n    }\n\n    /**\n     * Given some data of a custom URL with a token, create a site if it needs to be created.\n     *\n     * @param data URL data.\n     * @returns Promise resolved with the site ID if created or already exists.\n     */\n    protected async createSiteIfNeeded(data: CoreCustomURLSchemesParams): Promise<string | undefined> {\n        if (!data.token) {\n            return;\n        }\n\n        const currentSite = CoreSites.getCurrentSite();\n\n        if (!currentSite || currentSite.getToken() != data.token || currentSite.isLoggedOut()) {\n            // Token belongs to a different site or site is logged out, create it. It doesn't matter if it already exists.\n\n            if (!data.siteUrl.match(/^https?:\\/\\//)) {\n                // URL doesn't have a protocol and it's required to be able to create the site. Check which one to use.\n                const result = await CoreSites.checkSite(data.siteUrl);\n\n                data.siteUrl = result.siteUrl;\n\n                await CoreSites.checkApplication(result.config);\n            }\n\n            return CoreSites.newSite(\n                data.siteUrl,\n                data.token,\n                data.privateToken,\n                !!data.isSSOToken,\n                CoreLoginHelper.getOAuthIdFromParams(data.ssoUrlParams),\n            );\n        } else {\n            // Token belongs to current site, no need to create it.\n            return CoreSites.getCurrentSiteId();\n        }\n    }\n\n    /**\n     * Handle an URL received by custom URL scheme.\n     *\n     * @param url URL to treat.\n     * @returns Promise resolved when done. If rejected, the parameter is of type CoreCustomURLSchemesHandleError.\n     */\n    async handleCustomURL(url: string): Promise<void> {\n        if (!this.isCustomURL(url)) {\n            throw new CoreCustomURLSchemesHandleError(null);\n        }\n\n        /* First check that this URL hasn't been treated a few seconds ago. The function that handles custom URL schemes already\n           does this, but this function is called from other places so we need to handle it in here too. */\n        if (this.lastUrls[url] && Date.now() - this.lastUrls[url] < 3000) {\n            // Function called more than once, stop.\n            return;\n        }\n\n        this.lastUrls[url] = Date.now();\n        url = CoreTextUtils.decodeURIComponent(url);\n\n        // Wait for app to be ready.\n        await ApplicationInit.donePromise;\n\n        // Some platforms like Windows add a slash at the end. Remove it.\n        // Some sites add a # at the end of the URL. If it's there, remove it.\n        url = url.replace(/\\/?(#.*)?\\/?$/, '');\n\n        const modal = await CoreDomUtils.showModalLoading();\n        let data: CoreCustomURLSchemesParams;\n\n        // Get the data from the URL.\n        try {\n            if (this.isCustomURLToken(url)) {\n                data = await this.getCustomURLTokenData(url);\n            } else if (this.isCustomURLLink(url)) {\n                // In iOS, the protocol after the scheme doesn't have \":\". Add it.\n                url = url.replace(/\\/\\/link=(https?)\\/\\//, '//link=$1://');\n\n                data = await this.getCustomURLLinkData(url);\n            } else {\n                // In iOS, the protocol after the scheme doesn't have \":\". Add it.\n                url = url.replace(/\\/\\/(https?)\\/\\//, '//$1://');\n\n                data = await this.getCustomURLData(url);\n            }\n        } catch (error) {\n            modal.dismiss();\n\n            throw error;\n        }\n\n        try {\n            const isValid = await CoreLoginHelper.isSiteUrlAllowed(data.siteUrl);\n\n            if (!isValid) {\n                throw Translate.instant('core.errorurlschemeinvalidsite');\n            }\n\n            if (data.redirect && data.redirect.match(/^https?:\\/\\//) && data.redirect.indexOf(data.siteUrl) == -1) {\n                // Redirect URL must belong to the same site. Reject.\n                throw Translate.instant('core.contentlinks.errorredirectothersite');\n            }\n\n            // First of all, create the site if needed.\n            const siteId = await this.createSiteIfNeeded(data);\n\n            if (data.isSSOToken || (data.isAuthenticationURL && siteId && CoreSites.getCurrentSiteId() == siteId)) {\n                // Site created and authenticated, open the page to go.\n                CoreNavigator.navigateToSiteHome({\n                    params: <CoreRedirectPayload> {\n                        redirectPath: data.redirectPath,\n                        redirectOptions: data.redirectOptions,\n                        urlToOpen: data.urlToOpen,\n                    },\n                });\n\n                return;\n            }\n\n            if (data.redirect && !data.redirect.match(/^https?:\\/\\//)) {\n                // Redirect is a relative URL. Append the site URL.\n                data.redirect = CorePath.concatenatePaths(data.siteUrl, data.redirect);\n            }\n\n            let siteIds = [siteId];\n\n            if (!siteId) {\n                // No site created, check if the site is stored (to know which one to use).\n                siteIds = await CoreSites.getSiteIdsFromUrl(data.siteUrl, true, data.username);\n            }\n\n            if (siteIds.length > 1) {\n                // More than one site to treat the URL, let the user choose.\n                CoreContentLinksHelper.goToChooseSite(data.redirect || data.siteUrl);\n\n            } else if (siteIds.length == 1) {\n                // Only one site, handle the link.\n                const site = await CoreSites.getSite(siteIds[0]);\n\n                if (!data.redirect) {\n                    // No redirect, go to the root URL if needed.\n                    await CoreContentLinksHelper.handleRootURL(site, false, true);\n                } else {\n                    // Handle the redirect link.\n                    modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.\n\n                    /* Always use the username from the site in this case. If the link has a username and a token,\n                       this will make sure that the link is opened with the user the token belongs to. */\n                    const username = site.getInfo()?.username || data.username;\n\n                    const treated = await CoreContentLinksHelper.handleLink(data.redirect, username);\n\n                    if (!treated) {\n                        CoreDomUtils.showErrorModal('core.contentlinks.errornoactions', true);\n                    }\n                }\n\n            } else {\n                // Site not stored. Try to add the site.\n                const result = await CoreSites.checkSite(data.siteUrl);\n\n                // Site exists. We'll allow to add it.\n                modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.\n\n                await this.goToAddSite(data, result);\n            }\n\n        } catch (error) {\n            throw new CoreCustomURLSchemesHandleError(error, data);\n        } finally {\n            modal.dismiss();\n\n            if (data.isSSOToken) {\n                CoreApp.finishSSOAuthentication();\n            }\n        }\n    }\n\n    /**\n     * Get the data from a custom URL scheme. The structure of the URL is:\n     * moodlemobile://username@domain.com?token=TOKEN&privatetoken=PRIVATETOKEN&redirect=http://domain.com/course/view.php?id=2\n     *\n     * @param url URL to treat.\n     * @returns Promise resolved with the data.\n     */\n    protected async getCustomURLData(url: string): Promise<CoreCustomURLSchemesParams> {\n        if (!this.isCustomURL(url)) {\n            throw new CoreCustomURLSchemesHandleError(null);\n        }\n\n        // App opened using custom URL scheme.\n        this.logger.debug('Treating custom URL scheme: ' + url);\n\n        // Delete the sso scheme from the URL.\n        url = this.removeCustomURLScheme(url);\n\n        // Detect if there's a user specified.\n        const username = CoreUrlUtils.getUsernameFromUrl(url);\n        if (username) {\n            url = url.replace(username + '@', ''); // Remove the username from the URL.\n        }\n\n        // Get the params of the URL.\n        const params = CoreUrlUtils.extractUrlParams(url);\n\n        // Remove the params to get the site URL.\n        if (url.indexOf('?') != -1) {\n            url = url.substring(0, url.indexOf('?'));\n        }\n\n        if (!url.match(/https?:\\/\\//)) {\n            // Url doesn't have a protocol. Check if the site is stored in the app to be able to determine the protocol.\n            const siteIds = await CoreSites.getSiteIdsFromUrl(url, true, username);\n\n            if (siteIds.length) {\n                // There is at least 1 site with this URL. Use it to know the full URL.\n                const site = await CoreSites.getSite(siteIds[0]);\n\n                url = site.getURL();\n            }\n        }\n\n        return {\n            siteUrl: url,\n            username: username,\n            token: params.token,\n            privateToken: params.privateToken,\n            redirect: params.redirect,\n            isAuthenticationURL: !!params.token,\n        };\n    }\n\n    /**\n     * Get the data from a \"link\" custom URL scheme. This kind of URL is deprecated.\n     *\n     * @param url URL to treat.\n     * @returns Promise resolved with the data.\n     */\n    protected async getCustomURLLinkData(url: string): Promise<CoreCustomURLSchemesParams> {\n        if (!this.isCustomURLLink(url)) {\n            throw new CoreCustomURLSchemesHandleError(null);\n        }\n\n        // App opened using custom URL scheme.\n        this.logger.debug('Treating custom URL scheme with link param: ' + url);\n\n        // Delete the sso scheme from the URL.\n        url = this.removeCustomURLLinkScheme(url);\n\n        // Detect if there's a user specified.\n        const username = CoreUrlUtils.getUsernameFromUrl(url);\n        if (username) {\n            url = url.replace(username + '@', ''); // Remove the username from the URL.\n        }\n\n        // First of all, check if it's the root URL of a site.\n        const data = await CoreSites.isStoredRootURL(url, username);\n\n        if (data.site) {\n            // Root URL.\n            return {\n                siteUrl: data.site.getURL(),\n                username: username,\n            };\n\n        } else if (data.siteIds.length > 0) {\n            // Not the root URL, but at least 1 site supports the URL. Get the site URL from the list of sites.\n            const site = await CoreSites.getSite(data.siteIds[0]);\n\n            return {\n                siteUrl: site.getURL(),\n                username: username,\n                redirect: url,\n            };\n\n        } else {\n            // Get the site URL.\n            let siteUrl = CoreContentLinksDelegate.getSiteUrl(url);\n            let redirect: string | undefined = url;\n\n            if (!siteUrl) {\n                // Site URL not found, use the original URL since it could be the root URL of the site.\n                siteUrl = url;\n                redirect = undefined;\n            }\n\n            return {\n                siteUrl: siteUrl,\n                username: username,\n                redirect: redirect,\n            };\n        }\n    }\n\n    /**\n     * Get the data from a \"token\" custom URL scheme. This kind of URL is deprecated.\n     *\n     * @param url URL to treat.\n     * @returns Promise resolved with the data.\n     */\n    protected async getCustomURLTokenData(url: string): Promise<CoreCustomURLSchemesParams> {\n        if (!this.isCustomURLToken(url)) {\n            throw new CoreCustomURLSchemesHandleError(null);\n        }\n\n        if (CoreApp.isSSOAuthenticationOngoing()) {\n            // Authentication ongoing, probably duplicated request.\n            throw new CoreCustomURLSchemesHandleError('Duplicated');\n        }\n\n        // App opened using custom URL scheme. Probably an SSO authentication.\n        CoreApp.startSSOAuthentication();\n        this.logger.debug('App launched by URL with an SSO');\n\n        // Delete the sso scheme from the URL.\n        url = this.removeCustomURLTokenScheme(url);\n\n        // Some platforms like Windows add a slash at the end. Remove it.\n        // Some sites add a # at the end of the URL. If it's there, remove it.\n        url = url.replace(/\\/?#?\\/?$/, '');\n\n        // Decode from base64.\n        try {\n            url = atob(url);\n        } catch (err) {\n            // Error decoding the parameter.\n            this.logger.error('Error decoding parameter received for login SSO');\n\n            throw new CoreCustomURLSchemesHandleError(null);\n        }\n\n        const data: CoreCustomURLSchemesParams = await CoreLoginHelper.validateBrowserSSOLogin(url);\n\n        data.isSSOToken = true;\n        data.isAuthenticationURL = true;\n\n        return data;\n    }\n\n    /**\n     * Go to page to add a site, or open a browser if SSO.\n     *\n     * @param data URL data.\n     * @param siteCheck Result of checkSite.\n     * @returns Promise resolved when done.\n     */\n    protected async goToAddSite(data: CoreCustomURLSchemesParams, siteCheck: CoreSiteCheckResponse): Promise<void> {\n        const pageParams = {\n            username: data.username,\n            urlToOpen: data.redirect,\n            siteCheck,\n        };\n\n        if (CoreSites.isLoggedIn()) {\n            // Ask the user before changing site.\n            await CoreDomUtils.showConfirm(Translate.instant('core.contentlinks.confirmurlothersite'));\n\n            const willReload = await CoreSites.logoutForRedirect(CoreConstants.NO_SITE_ID, {\n                redirectPath: '/login/credentials',\n                redirectOptions: { params: pageParams },\n            });\n\n            if (willReload) {\n                return;\n            }\n        }\n\n        await CoreNavigator.navigateToLoginCredentials(pageParams);\n    }\n\n    /**\n     * Check whether a URL is a custom URL scheme.\n     *\n     * @param url URL to check.\n     * @returns Whether it's a custom URL scheme.\n     */\n    isCustomURL(url: string): boolean {\n        if (!url) {\n            return false;\n        }\n\n        return url.indexOf(CoreConstants.CONFIG.customurlscheme + '://') != -1;\n    }\n\n    /**\n     * Check whether a URL is a custom URL scheme with the \"link\" param (deprecated).\n     *\n     * @param url URL to check.\n     * @returns Whether it's a custom URL scheme.\n     */\n    isCustomURLLink(url: string): boolean {\n        if (!url) {\n            return false;\n        }\n\n        return url.indexOf(CoreConstants.CONFIG.customurlscheme + '://link=') != -1;\n    }\n\n    /**\n     * Check whether a URL is a custom URL scheme with a \"token\" param (deprecated).\n     *\n     * @param url URL to check.\n     * @returns Whether it's a custom URL scheme.\n     */\n    isCustomURLToken(url: string): boolean {\n        if (!url) {\n            return false;\n        }\n\n        return url.indexOf(CoreConstants.CONFIG.customurlscheme + '://token=') != -1;\n    }\n\n    /**\n     * Remove the scheme from a custom URL.\n     *\n     * @param url URL to treat.\n     * @returns URL without scheme.\n     */\n    removeCustomURLScheme(url: string): string {\n        return url.replace(CoreConstants.CONFIG.customurlscheme + '://', '');\n    }\n\n    /**\n     * Remove the scheme and the \"link=\" prefix from a link custom URL.\n     *\n     * @param url URL to treat.\n     * @returns URL without scheme and prefix.\n     */\n    removeCustomURLLinkScheme(url: string): string {\n        return url.replace(CoreConstants.CONFIG.customurlscheme + '://link=', '');\n    }\n\n    /**\n     * Remove the scheme and the \"token=\" prefix from a token custom URL.\n     *\n     * @param url URL to treat.\n     * @returns URL without scheme and prefix.\n     */\n    removeCustomURLTokenScheme(url: string): string {\n        return url.replace(CoreConstants.CONFIG.customurlscheme + '://token=', '');\n    }\n\n    /**\n     * Treat error returned by handleCustomURL.\n     *\n     * @param error Error data.\n     */\n    treatHandleCustomURLError(error: CoreCustomURLSchemesHandleError): void {\n        if (error.error == 'Duplicated') {\n            // Duplicated request\n        } else if (CoreUtils.isWebServiceError(error.error) && error.data && error.data.isSSOToken) {\n            // An error occurred, display the error and logout the user.\n            CoreLoginHelper.treatUserTokenError(error.data.siteUrl, <CoreWSError> error.error);\n            CoreSites.logout();\n        } else {\n            CoreDomUtils.showErrorModalDefault(error.error, Translate.instant('core.login.invalidsite'));\n        }\n    }\n\n}\n\n/**\n * Error returned by handleCustomURL.\n */\nexport class CoreCustomURLSchemesHandleError extends CoreError {\n\n    /**\n     * Constructor.\n     *\n     * @param error The error message or object.\n     * @param data Data obtained from the URL (if any).\n     */\n    constructor(public error: string | CoreError | CoreTextErrorObject | null, public data?: CoreCustomURLSchemesParams) {\n        super(CoreTextUtils.getErrorMessageFromError(error));\n    }\n\n}\n\nexport const CoreCustomURLSchemes = makeSingleton(CoreCustomURLSchemesProvider);\n\n/**\n * All params that can be in a custom URL scheme.\n */\nexport interface CoreCustomURLSchemesParams extends CoreLoginSSOData {\n\n    /**\n     * Username.\n     */\n    username?: string;\n\n    /**\n     * URL to open once authenticated.\n     */\n    redirect?: string;\n\n    /**\n     * Whether it's an SSO token URL.\n     */\n    isSSOToken?: boolean;\n\n    /**\n     * Whether the URL is meant to perform an authentication.\n     */\n    isAuthenticationURL?: boolean;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}