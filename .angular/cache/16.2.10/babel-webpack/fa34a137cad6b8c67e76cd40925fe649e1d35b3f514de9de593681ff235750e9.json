{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { makeSingleton } from '@singletons';\nimport { CoreSites } from '@services/sites';\nimport { PASSWORD_TABLE_NAME } from '../database/password';\nimport { AddonModQuizAccessPasswordComponent } from '../../component/password';\nimport { CoreUtils } from '@services/utils/utils';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to support password access rule.\n */\nexport class AddonModQuizAccessPasswordHandlerService {\n  constructor() {\n    this.name = 'AddonModQuizAccessPassword';\n    this.ruleName = 'quizaccess_password';\n  }\n  /**\n   * Add preflight data that doesn't require user interaction. The data should be added to the preflightData param.\n   *\n   * @param quiz The quiz the rule belongs to.\n   * @param preflightData Object where to add the preflight data.\n   * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done if async, void if it's synchronous.\n   */\n  getFixedPreflightData(quiz, preflightData, attempt, prefetch, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (preflightData.quizpassword !== undefined) {\n        return;\n      }\n      try {\n        // Try to get a password stored. If it's found, use it.\n        const entry = yield _this.getPasswordEntry(quiz.id, siteId);\n        preflightData.quizpassword = entry.password;\n      } catch (_unused) {\n        // No password stored.\n      }\n    })();\n  }\n  /**\n   * Get a password stored in DB.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the DB entry on success.\n   */\n  getPasswordEntry(quizId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecord(PASSWORD_TABLE_NAME, {\n        id: quizId\n      });\n    })();\n  }\n  /**\n   * Return the Component to use to display the access rule preflight.\n   * Implement this if your access rule requires a preflight check with user interaction.\n   * It's recommended to return the class of the component, but you can also return an instance of the component.\n   *\n   * @returns The component (or promise resolved with component) to use, undefined if not found.\n   */\n  getPreflightComponent() {\n    return AddonModQuizAccessPasswordComponent;\n  }\n  /**\n   * Whether or not the handler is enabled on a site level.\n   *\n   * @returns True or promise resolved with true if enabled.\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  /**\n   * Whether the rule requires a preflight check when prefetch/start/continue an attempt.\n   *\n   * @param quiz The quiz the rule belongs to.\n   * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Whether the rule requires a preflight check.\n   */\n  isPreflightCheckRequired(quiz, attempt, prefetch, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // If there's a password stored don't require the preflight since we'll use the stored one.\n      const entry = yield CoreUtils.ignoreErrors(_this2.getPasswordEntry(quiz.id, siteId));\n      return !entry;\n    })();\n  }\n  /**\n   * Function called when the preflight check has passed. This is a chance to record that fact in some way.\n   *\n   * @param quiz The quiz the rule belongs to.\n   * @param attempt The attempt started/continued.\n   * @param preflightData Preflight data gathered.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done if async, void if it's synchronous.\n   */\n  notifyPreflightCheckPassed(quiz, attempt, preflightData, prefetch, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // The password is right, store it to use it automatically in following executions.\n      if (preflightData.quizpassword !== undefined) {\n        return _this3.storePassword(quiz.id, preflightData.quizpassword, siteId);\n      }\n    })();\n  }\n  /**\n   * Function called when the preflight check fails. This is a chance to record that fact in some way.\n   *\n   * @param quiz The quiz the rule belongs to.\n   * @param attempt The attempt started/continued.\n   * @param preflightData Preflight data gathered.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done if async, void if it's synchronous.\n   */\n  notifyPreflightCheckFailed(quiz, attempt, preflightData, prefetch, siteId) {\n    // The password is wrong, remove it from DB if it's there.\n    return this.removePassword(quiz.id, siteId);\n  }\n  /**\n   * Remove a password from DB.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  removePassword(quizId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(PASSWORD_TABLE_NAME, {\n        id: quizId\n      });\n    })();\n  }\n  /**\n   * Store a password in DB.\n   *\n   * @param quizId Quiz ID.\n   * @param password Password.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  storePassword(quizId, password, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        id: quizId,\n        password,\n        timemodified: Date.now()\n      };\n      yield site.getDb().insertRecord(PASSWORD_TABLE_NAME, entry);\n    })();\n  }\n}\n_class = AddonModQuizAccessPasswordHandlerService;\n_class.ɵfac = function AddonModQuizAccessPasswordHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModQuizAccessPasswordHandler = makeSingleton(AddonModQuizAccessPasswordHandlerService);","map":{"version":3,"names":["makeSingleton","CoreSites","PASSWORD_TABLE_NAME","AddonModQuizAccessPasswordComponent","CoreUtils","AddonModQuizAccessPasswordHandlerService","constructor","name","ruleName","getFixedPreflightData","quiz","preflightData","attempt","prefetch","siteId","_this","_asyncToGenerator","quizpassword","undefined","entry","getPasswordEntry","id","password","_unused","quizId","site","getSite","getDb","getRecord","getPreflightComponent","isEnabled","isPreflightCheckRequired","_this2","ignoreErrors","notifyPreflightCheckPassed","_this3","storePassword","notifyPreflightCheckFailed","removePassword","deleteRecords","timemodified","Date","now","insertRecord","factory","ɵfac","providedIn","AddonModQuizAccessPasswordHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/quiz/accessrules/password/services/handlers/password.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\n\nimport { AddonModQuizAccessRuleHandler } from '@addons/mod/quiz/services/access-rules-delegate';\nimport { makeSingleton } from '@singletons';\nimport { AddonModQuizAttemptWSData, AddonModQuizQuizWSData } from '@addons/mod/quiz/services/quiz';\nimport { CoreSites } from '@services/sites';\nimport { AddonModQuizAccessPasswordDBRecord, PASSWORD_TABLE_NAME } from '../database/password';\nimport { AddonModQuizAccessPasswordComponent } from '../../component/password';\nimport { CoreUtils } from '@services/utils/utils';\n\n/**\n * Handler to support password access rule.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModQuizAccessPasswordHandlerService implements AddonModQuizAccessRuleHandler {\n\n    name = 'AddonModQuizAccessPassword';\n    ruleName = 'quizaccess_password';\n\n    /**\n     * Add preflight data that doesn't require user interaction. The data should be added to the preflightData param.\n     *\n     * @param quiz The quiz the rule belongs to.\n     * @param preflightData Object where to add the preflight data.\n     * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done if async, void if it's synchronous.\n     */\n    async getFixedPreflightData(\n        quiz: AddonModQuizQuizWSData,\n        preflightData: Record<string, string>,\n        attempt?: AddonModQuizAttemptWSData,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        if (preflightData.quizpassword !== undefined) {\n            return;\n        }\n\n        try {\n            // Try to get a password stored. If it's found, use it.\n            const entry = await this.getPasswordEntry(quiz.id, siteId);\n\n            preflightData.quizpassword = entry.password;\n        } catch {\n            // No password stored.\n        }\n    }\n\n    /**\n     * Get a password stored in DB.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the DB entry on success.\n     */\n    protected async getPasswordEntry(quizId: number, siteId?: string): Promise<AddonModQuizAccessPasswordDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecord(PASSWORD_TABLE_NAME, { id: quizId });\n    }\n\n    /**\n     * Return the Component to use to display the access rule preflight.\n     * Implement this if your access rule requires a preflight check with user interaction.\n     * It's recommended to return the class of the component, but you can also return an instance of the component.\n     *\n     * @returns The component (or promise resolved with component) to use, undefined if not found.\n     */\n    getPreflightComponent(): Type<unknown> | Promise<Type<unknown>> {\n        return AddonModQuizAccessPasswordComponent;\n    }\n\n    /**\n     * Whether or not the handler is enabled on a site level.\n     *\n     * @returns True or promise resolved with true if enabled.\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * Whether the rule requires a preflight check when prefetch/start/continue an attempt.\n     *\n     * @param quiz The quiz the rule belongs to.\n     * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Whether the rule requires a preflight check.\n     */\n    async isPreflightCheckRequired(\n        quiz: AddonModQuizQuizWSData,\n        attempt?: AddonModQuizAttemptWSData,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<boolean> {\n        // If there's a password stored don't require the preflight since we'll use the stored one.\n        const entry = await CoreUtils.ignoreErrors(this.getPasswordEntry(quiz.id, siteId));\n\n        return !entry;\n    }\n\n    /**\n     * Function called when the preflight check has passed. This is a chance to record that fact in some way.\n     *\n     * @param quiz The quiz the rule belongs to.\n     * @param attempt The attempt started/continued.\n     * @param preflightData Preflight data gathered.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done if async, void if it's synchronous.\n     */\n    async notifyPreflightCheckPassed(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData | undefined,\n        preflightData: Record<string, string>,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        // The password is right, store it to use it automatically in following executions.\n        if (preflightData.quizpassword !== undefined) {\n            return this.storePassword(quiz.id, preflightData.quizpassword, siteId);\n        }\n    }\n\n    /**\n     * Function called when the preflight check fails. This is a chance to record that fact in some way.\n     *\n     * @param quiz The quiz the rule belongs to.\n     * @param attempt The attempt started/continued.\n     * @param preflightData Preflight data gathered.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done if async, void if it's synchronous.\n     */\n    notifyPreflightCheckFailed?(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData | undefined,\n        preflightData: Record<string, string>,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        // The password is wrong, remove it from DB if it's there.\n        return this.removePassword(quiz.id, siteId);\n    }\n\n    /**\n     * Remove a password from DB.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    protected async removePassword(quizId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(PASSWORD_TABLE_NAME, { id: quizId });\n    }\n\n    /**\n     * Store a password in DB.\n     *\n     * @param quizId Quiz ID.\n     * @param password Password.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    protected async storePassword(quizId: number, password: string, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entry: AddonModQuizAccessPasswordDBRecord = {\n            id: quizId,\n            password,\n            timemodified: Date.now(),\n        };\n\n        await site.getDb().insertRecord(PASSWORD_TABLE_NAME, entry);\n    }\n\n}\n\nexport const AddonModQuizAccessPasswordHandler = makeSingleton(AddonModQuizAccessPasswordHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}