{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBaseProvider } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonNotes } from './notes';\nimport { AddonNotesOffline } from './notes-offline';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync notes.\n */\nexport class AddonNotesSyncProvider extends CoreSyncBaseProvider {\n  constructor() {\n    super('AddonNotesSync');\n  }\n  /**\n   * Try to synchronize all the notes in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllNotes(siteId, force) {\n    return this.syncOnSites('all notes', siteId => this.syncAllNotesFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Synchronize all the notes in a certain site\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllNotesFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const notesArray = yield Promise.all([AddonNotesOffline.getAllNotes(siteId), AddonNotesOffline.getAllDeletedNotes(siteId)]);\n      // Get all the courses to be synced.\n      let courseIds = [];\n      notesArray.forEach(notes => {\n        courseIds = courseIds.concat(notes.map(note => note.courseid));\n      });\n      CoreUtils.uniqueArray(courseIds);\n      // Sync all courses.\n      const promises = courseIds.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (courseId) {\n          const result = yield force ? _this.syncNotes(courseId, siteId) : _this.syncNotesIfNeeded(courseId, siteId);\n          if (result !== undefined) {\n            // Sync successful, send event.\n            CoreEvents.trigger(AddonNotesSyncProvider.AUTO_SYNCED, {\n              courseId,\n              warnings: result.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Sync course notes only if a certain time has passed since the last time.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the notes are synced or if they don't need to be synced.\n   */\n  syncNotesIfNeeded(courseId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const needed = yield _this2.isSyncNeeded(courseId, siteId);\n      if (needed) {\n        return _this2.syncNotes(courseId, siteId);\n      }\n    })();\n  }\n  /**\n   * Synchronize notes of a course.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncNotes(courseId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const currentSyncPromise = this.getOngoingSync(courseId, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for notes, return the promise.\n      return currentSyncPromise;\n    }\n    this.logger.debug('Try to sync notes for course ' + courseId);\n    const syncPromise = this.performSyncNotes(courseId, siteId);\n    return this.addOngoingSync(courseId, syncPromise, siteId);\n  }\n  /**\n   * Perform the synchronization of the notes of a course.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  performSyncNotes(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: []\n      };\n      // Get offline notes to be sent and deleted.\n      const [offlineNotes, deletedNotes] = yield Promise.all([AddonNotesOffline.getAllNotes(siteId), AddonNotesOffline.getAllDeletedNotes(siteId)]);\n      if (!offlineNotes.length && !deletedNotes.length) {\n        // Nothing to sync.\n        return result;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      const errors = [];\n      const promises = [];\n      // Format the notes to be sent.\n      const notesToSend = offlineNotes.map(note => ({\n        userid: note.userid,\n        publishstate: note.publishstate,\n        courseid: note.courseid,\n        text: note.content,\n        format: 1\n      }));\n      // Send the notes.\n      promises.push(AddonNotes.addNotesOnline(notesToSend, siteId).then(response => {\n        // Search errors in the response.\n        response.forEach(entry => {\n          if (entry.noteid === -1 && entry.errormessage && errors.indexOf(entry.errormessage) == -1) {\n            errors.push(entry.errormessage);\n          }\n        });\n        return;\n      }).catch(error => {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, this means the user cannot send notes.\n          errors.push(error);\n          return;\n        }\n        // Not a WebService error, reject the synchronization to try again.\n        throw error;\n      }).then( /*#__PURE__*/_asyncToGenerator(function* () {\n        // Notes were sent, delete them from local DB.\n        const promises = offlineNotes.map(note => AddonNotesOffline.deleteOfflineNote(note.userid, note.content, note.created, siteId));\n        yield Promise.all(promises);\n        return;\n      })));\n      // Format the notes to be sent.\n      const notesToDelete = deletedNotes.map(note => note.noteid);\n      // Delete the notes.\n      promises.push(AddonNotes.deleteNotesOnline(notesToDelete, courseId, siteId).catch(error => {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, this means the user cannot send notes.\n          errors.push(error);\n          return;\n        }\n        // Not a WebService error, reject the synchronization to try again.\n        throw error;\n      }).then( /*#__PURE__*/_asyncToGenerator(function* () {\n        // Notes were sent, delete them from local DB.\n        const promises = notesToDelete.map(noteId => AddonNotesOffline.undoDeleteNote(noteId, siteId));\n        yield Promise.all(promises);\n        return;\n      })));\n      yield Promise.all(promises);\n      // Fetch the notes from server to be sure they're up to date.\n      yield CoreUtils.ignoreErrors(AddonNotes.invalidateNotes(courseId, undefined, siteId));\n      yield CoreUtils.ignoreErrors(AddonNotes.getNotes(courseId, undefined, false, true, siteId));\n      if (errors && errors.length) {\n        // At least an error occurred, get course name and add errors to warnings array.\n        const course = yield CoreUtils.ignoreErrors(CoreCourses.getUserCourse(courseId, true, siteId), {});\n        result.warnings = errors.map(error => Translate.instant('addon.notes.warningnotenotsent', {\n          course: 'fullname' in course ? course.fullname : courseId,\n          error: error\n        }));\n      }\n      // All done, return the warnings.\n      return result;\n    })();\n  }\n}\n_class = AddonNotesSyncProvider;\n_class.AUTO_SYNCED = 'addon_notes_autom_synced';\n_class.ɵfac = function AddonNotesSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonNotesSync = makeSingleton(AddonNotesSyncProvider);","map":{"version":3,"names":["CoreSyncBaseProvider","CoreNetworkError","CoreCourses","CoreNetwork","CoreSites","CoreUtils","Translate","makeSingleton","CoreEvents","AddonNotes","AddonNotesOffline","AddonNotesSyncProvider","constructor","syncAllNotes","siteId","force","syncOnSites","syncAllNotesFunc","_this","_asyncToGenerator","notesArray","Promise","all","getAllNotes","getAllDeletedNotes","courseIds","forEach","notes","concat","map","note","courseid","uniqueArray","promises","_ref","courseId","result","syncNotes","syncNotesIfNeeded","undefined","trigger","AUTO_SYNCED","warnings","_x","apply","arguments","_this2","needed","isSyncNeeded","getCurrentSiteId","currentSyncPromise","getOngoingSync","logger","debug","syncPromise","performSyncNotes","addOngoingSync","offlineNotes","deletedNotes","length","isOnline","errors","notesToSend","userid","publishstate","text","content","format","push","addNotesOnline","then","response","entry","noteid","errormessage","indexOf","catch","error","isWebServiceError","deleteOfflineNote","created","notesToDelete","deleteNotesOnline","noteId","undoDeleteNote","ignoreErrors","invalidateNotes","getNotes","course","getUserCourse","instant","fullname","_class","factory","ɵfac","providedIn","AddonNotesSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/notes/services/notes-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSyncBaseProvider } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonNotesDBRecord, AddonNotesDeletedDBRecord } from './database/notes';\nimport { AddonNotes, AddonNotesCreateNoteData } from './notes';\nimport { AddonNotesOffline } from './notes-offline';\n\n/**\n * Service to sync notes.\n */\n@Injectable( { providedIn: 'root' } )\nexport class AddonNotesSyncProvider extends CoreSyncBaseProvider<AddonNotesSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_notes_autom_synced';\n\n    constructor() {\n        super('AddonNotesSync');\n    }\n\n    /**\n     * Try to synchronize all the notes in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllNotes(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all notes', (siteId) => this.syncAllNotesFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Synchronize all the notes in a certain site\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllNotesFunc(force: boolean, siteId: string): Promise<void> {\n        const notesArray = await Promise.all([\n            AddonNotesOffline.getAllNotes(siteId),\n            AddonNotesOffline.getAllDeletedNotes(siteId),\n        ]);\n\n        // Get all the courses to be synced.\n        let courseIds: number[] = [];\n        notesArray.forEach((notes: (AddonNotesDeletedDBRecord | AddonNotesDBRecord)[]) => {\n            courseIds = courseIds.concat(notes.map((note) => note.courseid));\n        });\n\n        CoreUtils.uniqueArray(courseIds);\n\n        // Sync all courses.\n        const promises = courseIds.map(async (courseId) => {\n            const result = await (force\n                ? this.syncNotes(courseId, siteId)\n                : this.syncNotesIfNeeded(courseId, siteId));\n\n            if (result !== undefined) {\n                // Sync successful, send event.\n                CoreEvents.trigger(AddonNotesSyncProvider.AUTO_SYNCED, {\n                    courseId,\n                    warnings: result.warnings,\n                }, siteId);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Sync course notes only if a certain time has passed since the last time.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the notes are synced or if they don't need to be synced.\n     */\n    protected async syncNotesIfNeeded(courseId: number, siteId?: string): Promise<AddonNotesSyncResult | undefined> {\n        const needed = await this.isSyncNeeded(courseId, siteId);\n\n        if (needed) {\n            return this.syncNotes(courseId, siteId);\n        }\n    }\n\n    /**\n     * Synchronize notes of a course.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    syncNotes(courseId: number, siteId?: string): Promise<AddonNotesSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(courseId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for notes, return the promise.\n            return currentSyncPromise;\n        }\n\n        this.logger.debug('Try to sync notes for course ' + courseId);\n\n        const syncPromise = this.performSyncNotes(courseId, siteId);\n\n        return this.addOngoingSync(courseId, syncPromise, siteId);\n    }\n\n    /**\n     * Perform the synchronization of the notes of a course.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    async performSyncNotes(courseId: number, siteId?: string): Promise<AddonNotesSyncResult> {\n        const result: AddonNotesSyncResult = {\n            warnings: [],\n        };\n\n        // Get offline notes to be sent and deleted.\n        const [offlineNotes, deletedNotes] = await Promise.all([\n            AddonNotesOffline.getAllNotes(siteId),\n            AddonNotesOffline.getAllDeletedNotes(siteId),\n        ]);\n\n        if (!offlineNotes.length && !deletedNotes.length) {\n            // Nothing to sync.\n            return result;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        const errors: string[] = [];\n        const promises: Promise<void>[] = [];\n\n        // Format the notes to be sent.\n        const notesToSend: AddonNotesCreateNoteData[] = offlineNotes.map((note) => ({\n            userid: note.userid,\n            publishstate: note.publishstate,\n            courseid: note.courseid,\n            text: note.content,\n            format: 1,\n        }));\n\n        // Send the notes.\n        promises.push(AddonNotes.addNotesOnline(notesToSend, siteId).then((response) => {\n            // Search errors in the response.\n            response.forEach((entry) => {\n                if (entry.noteid === -1 && entry.errormessage && errors.indexOf(entry.errormessage) == -1) {\n                    errors.push(entry.errormessage);\n                }\n            });\n\n            return;\n        }).catch((error) => {\n            if (CoreUtils.isWebServiceError(error)) {\n                // It's a WebService error, this means the user cannot send notes.\n                errors.push(error);\n\n                return;\n            }\n\n            // Not a WebService error, reject the synchronization to try again.\n            throw error;\n        }).then(async () => {\n            // Notes were sent, delete them from local DB.\n            const promises: Promise<void>[] = offlineNotes.map((note) =>\n                AddonNotesOffline.deleteOfflineNote(note.userid, note.content, note.created, siteId));\n\n            await Promise.all(promises);\n\n            return;\n        }));\n\n        // Format the notes to be sent.\n        const notesToDelete = deletedNotes.map((note) => note.noteid);\n\n        // Delete the notes.\n        promises.push(AddonNotes.deleteNotesOnline(notesToDelete, courseId, siteId).catch((error) => {\n            if (CoreUtils.isWebServiceError(error)) {\n                // It's a WebService error, this means the user cannot send notes.\n                errors.push(error);\n\n                return;\n            }\n\n            // Not a WebService error, reject the synchronization to try again.\n            throw error;\n        }).then(async () => {\n            // Notes were sent, delete them from local DB.\n            const promises = notesToDelete.map((noteId) => AddonNotesOffline.undoDeleteNote(noteId, siteId));\n\n            await Promise.all(promises);\n\n            return;\n        }));\n\n        await Promise.all(promises);\n\n        // Fetch the notes from server to be sure they're up to date.\n        await CoreUtils.ignoreErrors(AddonNotes.invalidateNotes(courseId, undefined, siteId));\n\n        await CoreUtils.ignoreErrors(AddonNotes.getNotes(courseId, undefined, false, true, siteId));\n\n        if (errors && errors.length) {\n            // At least an error occurred, get course name and add errors to warnings array.\n            const course = await CoreUtils.ignoreErrors(CoreCourses.getUserCourse(courseId, true, siteId), {});\n\n            result.warnings = errors.map((error) =>\n                Translate.instant('addon.notes.warningnotenotsent', {\n                    course: 'fullname' in course ? course.fullname : courseId, // @deprecated since 4.3.\n                    error: error,\n                }));\n        }\n\n        // All done, return the warnings.\n        return result;\n    }\n\n}\nexport const AddonNotesSync = makeSingleton(AddonNotesSyncProvider);\n\nexport type AddonNotesSyncResult = {\n    warnings: string[]; // List of warnings.\n};\n\n/**\n * Data passed to AUTO_SYNCED event.\n */\nexport type AddonNotesSyncAutoSyncData = {\n    courseId: number;\n    warnings: string[];\n};\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonNotesSyncProvider.AUTO_SYNCED]: AddonNotesSyncAutoSyncData;\n    }\n\n}\n"],"mappings":";;AAeA,SAASA,oBAAoB,QAAQ,oBAAoB;AACzD,SAASC,gBAAgB,QAAQ,+BAA+B;AAChE,SAASC,WAAW,QAAQ,oCAAoC;AAChE,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,SAAS,EAAEC,aAAa,QAAQ,aAAa;AACtD,SAASC,UAAU,QAAQ,oBAAoB;AAE/C,SAASC,UAAU,QAAkC,SAAS;AAC9D,SAASC,iBAAiB,QAAQ,iBAAiB;;AAEnD;;;AAIA,OAAM,MAAOC,sBAAuB,SAAQX,oBAA0C;EAIlFY,YAAA;IACI,KAAK,CAAC,gBAAgB,CAAC;EAC3B;EAEA;;;;;;;EAOAC,YAAYA,CAACC,MAAe,EAAEC,KAAe;IACzC,OAAO,IAAI,CAACC,WAAW,CAAC,WAAW,EAAGF,MAAM,IAAK,IAAI,CAACG,gBAAgB,CAAC,CAAC,CAACF,KAAK,EAAED,MAAM,CAAC,EAAEA,MAAM,CAAC;EACpG;EAEA;;;;;;;EAOgBG,gBAAgBA,CAACF,KAAc,EAAED,MAAc;IAAA,IAAAI,KAAA;IAAA,OAAAC,iBAAA;MAC3D,MAAMC,UAAU,SAASC,OAAO,CAACC,GAAG,CAAC,CACjCZ,iBAAiB,CAACa,WAAW,CAACT,MAAM,CAAC,EACrCJ,iBAAiB,CAACc,kBAAkB,CAACV,MAAM,CAAC,CAC/C,CAAC;MAEF;MACA,IAAIW,SAAS,GAAa,EAAE;MAC5BL,UAAU,CAACM,OAAO,CAAEC,KAAyD,IAAI;QAC7EF,SAAS,GAAGA,SAAS,CAACG,MAAM,CAACD,KAAK,CAACE,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACC,QAAQ,CAAC,CAAC;MACpE,CAAC,CAAC;MAEF1B,SAAS,CAAC2B,WAAW,CAACP,SAAS,CAAC;MAEhC;MACA,MAAMQ,QAAQ,GAAGR,SAAS,CAACI,GAAG;QAAA,IAAAK,IAAA,GAAAf,iBAAA,CAAC,WAAOgB,QAAQ,EAAI;UAC9C,MAAMC,MAAM,SAAUrB,KAAK,GACrBG,KAAI,CAACmB,SAAS,CAACF,QAAQ,EAAErB,MAAM,CAAC,GAChCI,KAAI,CAACoB,iBAAiB,CAACH,QAAQ,EAAErB,MAAM,CAAE;UAE/C,IAAIsB,MAAM,KAAKG,SAAS,EAAE;YACtB;YACA/B,UAAU,CAACgC,OAAO,CAAC7B,sBAAsB,CAAC8B,WAAW,EAAE;cACnDN,QAAQ;cACRO,QAAQ,EAAEN,MAAM,CAACM;aACpB,EAAE5B,MAAM,CAAC;;QAElB,CAAC;QAAA,iBAAA6B,EAAA;UAAA,OAAAT,IAAA,CAAAU,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC;MAEF,MAAMxB,OAAO,CAACC,GAAG,CAACW,QAAQ,CAAC;IAAC;EAChC;EAEA;;;;;;;EAOgBK,iBAAiBA,CAACH,QAAgB,EAAErB,MAAe;IAAA,IAAAgC,MAAA;IAAA,OAAA3B,iBAAA;MAC/D,MAAM4B,MAAM,SAASD,MAAI,CAACE,YAAY,CAACb,QAAQ,EAAErB,MAAM,CAAC;MAExD,IAAIiC,MAAM,EAAE;QACR,OAAOD,MAAI,CAACT,SAAS,CAACF,QAAQ,EAAErB,MAAM,CAAC;;IAC1C;EACL;EAEA;;;;;;;EAOAuB,SAASA,CAACF,QAAgB,EAAErB,MAAe;IACvCA,MAAM,GAAGA,MAAM,IAAIV,SAAS,CAAC6C,gBAAgB,EAAE;IAE/C,MAAMC,kBAAkB,GAAG,IAAI,CAACC,cAAc,CAAChB,QAAQ,EAAErB,MAAM,CAAC;IAChE,IAAIoC,kBAAkB,EAAE;MACpB;MACA,OAAOA,kBAAkB;;IAG7B,IAAI,CAACE,MAAM,CAACC,KAAK,CAAC,+BAA+B,GAAGlB,QAAQ,CAAC;IAE7D,MAAMmB,WAAW,GAAG,IAAI,CAACC,gBAAgB,CAACpB,QAAQ,EAAErB,MAAM,CAAC;IAE3D,OAAO,IAAI,CAAC0C,cAAc,CAACrB,QAAQ,EAAEmB,WAAW,EAAExC,MAAM,CAAC;EAC7D;EAEA;;;;;;;EAOMyC,gBAAgBA,CAACpB,QAAgB,EAAErB,MAAe;IAAA,OAAAK,iBAAA;MACpD,MAAMiB,MAAM,GAAyB;QACjCM,QAAQ,EAAE;OACb;MAED;MACA,MAAM,CAACe,YAAY,EAAEC,YAAY,CAAC,SAASrC,OAAO,CAACC,GAAG,CAAC,CACnDZ,iBAAiB,CAACa,WAAW,CAACT,MAAM,CAAC,EACrCJ,iBAAiB,CAACc,kBAAkB,CAACV,MAAM,CAAC,CAC/C,CAAC;MAEF,IAAI,CAAC2C,YAAY,CAACE,MAAM,IAAI,CAACD,YAAY,CAACC,MAAM,EAAE;QAC9C;QACA,OAAOvB,MAAM;;MAGjB,IAAI,CAACjC,WAAW,CAACyD,QAAQ,EAAE,EAAE;QACzB;QACA,MAAM,IAAI3D,gBAAgB,EAAE;;MAGhC,MAAM4D,MAAM,GAAa,EAAE;MAC3B,MAAM5B,QAAQ,GAAoB,EAAE;MAEpC;MACA,MAAM6B,WAAW,GAA+BL,YAAY,CAAC5B,GAAG,CAAEC,IAAI,KAAM;QACxEiC,MAAM,EAAEjC,IAAI,CAACiC,MAAM;QACnBC,YAAY,EAAElC,IAAI,CAACkC,YAAY;QAC/BjC,QAAQ,EAAED,IAAI,CAACC,QAAQ;QACvBkC,IAAI,EAAEnC,IAAI,CAACoC,OAAO;QAClBC,MAAM,EAAE;OACX,CAAC,CAAC;MAEH;MACAlC,QAAQ,CAACmC,IAAI,CAAC3D,UAAU,CAAC4D,cAAc,CAACP,WAAW,EAAEhD,MAAM,CAAC,CAACwD,IAAI,CAAEC,QAAQ,IAAI;QAC3E;QACAA,QAAQ,CAAC7C,OAAO,CAAE8C,KAAK,IAAI;UACvB,IAAIA,KAAK,CAACC,MAAM,KAAK,CAAC,CAAC,IAAID,KAAK,CAACE,YAAY,IAAIb,MAAM,CAACc,OAAO,CAACH,KAAK,CAACE,YAAY,CAAC,IAAI,CAAC,CAAC,EAAE;YACvFb,MAAM,CAACO,IAAI,CAACI,KAAK,CAACE,YAAY,CAAC;;QAEvC,CAAC,CAAC;QAEF;MACJ,CAAC,CAAC,CAACE,KAAK,CAAEC,KAAK,IAAI;QACf,IAAIxE,SAAS,CAACyE,iBAAiB,CAACD,KAAK,CAAC,EAAE;UACpC;UACAhB,MAAM,CAACO,IAAI,CAACS,KAAK,CAAC;UAElB;;QAGJ;QACA,MAAMA,KAAK;MACf,CAAC,CAAC,CAACP,IAAI,eAAAnD,iBAAA,CAAC,aAAW;QACf;QACA,MAAMc,QAAQ,GAAoBwB,YAAY,CAAC5B,GAAG,CAAEC,IAAI,IACpDpB,iBAAiB,CAACqE,iBAAiB,CAACjD,IAAI,CAACiC,MAAM,EAAEjC,IAAI,CAACoC,OAAO,EAAEpC,IAAI,CAACkD,OAAO,EAAElE,MAAM,CAAC,CAAC;QAEzF,MAAMO,OAAO,CAACC,GAAG,CAACW,QAAQ,CAAC;QAE3B;MACJ,CAAC,EAAC,CAAC;MAEH;MACA,MAAMgD,aAAa,GAAGvB,YAAY,CAAC7B,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAAC2C,MAAM,CAAC;MAE7D;MACAxC,QAAQ,CAACmC,IAAI,CAAC3D,UAAU,CAACyE,iBAAiB,CAACD,aAAa,EAAE9C,QAAQ,EAAErB,MAAM,CAAC,CAAC8D,KAAK,CAAEC,KAAK,IAAI;QACxF,IAAIxE,SAAS,CAACyE,iBAAiB,CAACD,KAAK,CAAC,EAAE;UACpC;UACAhB,MAAM,CAACO,IAAI,CAACS,KAAK,CAAC;UAElB;;QAGJ;QACA,MAAMA,KAAK;MACf,CAAC,CAAC,CAACP,IAAI,eAAAnD,iBAAA,CAAC,aAAW;QACf;QACA,MAAMc,QAAQ,GAAGgD,aAAa,CAACpD,GAAG,CAAEsD,MAAM,IAAKzE,iBAAiB,CAAC0E,cAAc,CAACD,MAAM,EAAErE,MAAM,CAAC,CAAC;QAEhG,MAAMO,OAAO,CAACC,GAAG,CAACW,QAAQ,CAAC;QAE3B;MACJ,CAAC,EAAC,CAAC;MAEH,MAAMZ,OAAO,CAACC,GAAG,CAACW,QAAQ,CAAC;MAE3B;MACA,MAAM5B,SAAS,CAACgF,YAAY,CAAC5E,UAAU,CAAC6E,eAAe,CAACnD,QAAQ,EAAEI,SAAS,EAAEzB,MAAM,CAAC,CAAC;MAErF,MAAMT,SAAS,CAACgF,YAAY,CAAC5E,UAAU,CAAC8E,QAAQ,CAACpD,QAAQ,EAAEI,SAAS,EAAE,KAAK,EAAE,IAAI,EAAEzB,MAAM,CAAC,CAAC;MAE3F,IAAI+C,MAAM,IAAIA,MAAM,CAACF,MAAM,EAAE;QACzB;QACA,MAAM6B,MAAM,SAASnF,SAAS,CAACgF,YAAY,CAACnF,WAAW,CAACuF,aAAa,CAACtD,QAAQ,EAAE,IAAI,EAAErB,MAAM,CAAC,EAAE,EAAE,CAAC;QAElGsB,MAAM,CAACM,QAAQ,GAAGmB,MAAM,CAAChC,GAAG,CAAEgD,KAAK,IAC/BvE,SAAS,CAACoF,OAAO,CAAC,gCAAgC,EAAE;UAChDF,MAAM,EAAE,UAAU,IAAIA,MAAM,GAAGA,MAAM,CAACG,QAAQ,GAAGxD,QAAQ;UACzD0C,KAAK,EAAEA;SACV,CAAC,CAAC;;MAGX;MACA,OAAOzC,MAAM;IAAC;EAClB;;SAjNSzB,sBAAuB;AAEhBiF,MAAA,CAAAnD,WAAW,GAAG,0BAA0B;;mBAF/C9B,MAAsB;AAAA;;SAAtBA,MAAsB;EAAAkF,OAAA,EAAtBlF,MAAsB,CAAAmF,IAAA;EAAAC,UAAA,EADR;AAAM;AAqNjC,OAAO,MAAMC,cAAc,GAAGzF,aAAa,CAACI,sBAAsB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}