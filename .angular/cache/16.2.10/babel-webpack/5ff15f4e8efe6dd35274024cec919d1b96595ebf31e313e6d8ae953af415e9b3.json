{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreFormatTextDirective } from '@directives/format-text';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreDirectivesRegistry } from '@singletons/directives-registry';\nimport { CoreDom } from '@singletons/dom';\nimport { CoreLogger } from '@singletons/logger';\n/**\n * Class to make a question of ddwtos type work.\n */\nexport class AddonQtypeDdwtosQuestion {\n  /**\n   * Create the instance.\n   *\n   * @param container The container HTMLElement of the question.\n   * @param question The question instance.\n   * @param readOnly Whether it's read only.\n   * @param inputIds Ids of the inputs of the question (where the answers will be stored).\n   */\n  constructor(container, question, readOnly, inputIds) {\n    this.container = container;\n    this.question = question;\n    this.readOnly = readOnly;\n    this.inputIds = inputIds;\n    this.nextDragItemNo = 1;\n    this.selectors = new AddonQtypeDdwtosQuestionCSSSelectors(); // Result of cssSelectors.\n    this.placed = {}; // Map that relates drag elements numbers with drop zones numbers.\n    this.logger = CoreLogger.getInstance('AddonQtypeDdwtosQuestion');\n    this.initializer();\n  }\n  /**\n   * Clone a drag item and add it to the drag container.\n   *\n   * @param dragHome Item to clone\n   */\n  cloneDragItem(dragHome) {\n    const drag = dragHome.cloneNode(true);\n    drag.classList.remove('draghome');\n    drag.classList.add('drag');\n    drag.classList.add('no' + this.nextDragItemNo);\n    this.nextDragItemNo++;\n    drag.setAttribute('tabindex', '0');\n    drag.style.visibility = 'visible';\n    drag.style.position = 'absolute';\n    const container = this.container.querySelector(this.selectors.dragContainer());\n    container === null || container === void 0 || container.appendChild(drag);\n    if (!this.readOnly) {\n      this.makeDraggable(drag);\n    }\n  }\n  /**\n   * Clone the 'drag homes'.\n   * Invisible 'drag homes' are output in the question. These have the same properties as the drag items but are invisible.\n   * We clone these invisible elements to make the actual drag items.\n   */\n  cloneDragItems() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const dragHomes = Array.from(_this.container.querySelectorAll(_this.selectors.dragHomes()));\n      for (let x = 0; x < dragHomes.length; x++) {\n        _this.cloneDragItemsForOneChoice(dragHomes[x]);\n      }\n    })();\n  }\n  /**\n   * Clone a certain 'drag home'. If it's an \"infinite\" drag, clone it several times.\n   *\n   * @param dragHome Element to clone.\n   */\n  cloneDragItemsForOneChoice(dragHome) {\n    if (dragHome.classList.contains('infinite')) {\n      var _this$getGroup;\n      const groupNo = (_this$getGroup = this.getGroup(dragHome)) !== null && _this$getGroup !== void 0 ? _this$getGroup : -1;\n      const noOfDrags = this.container.querySelectorAll(this.selectors.dropsInGroup(groupNo)).length;\n      for (let x = 0; x < noOfDrags; x++) {\n        this.cloneDragItem(dragHome);\n      }\n    } else {\n      this.cloneDragItem(dragHome);\n    }\n  }\n  /**\n   * Deselect all drags.\n   */\n  deselectDrags() {\n    // Remove the selected class from all drags.\n    const drags = Array.from(this.container.querySelectorAll(this.selectors.drags()));\n    drags.forEach(drag => {\n      drag.classList.remove('selected');\n    });\n    this.selected = undefined;\n  }\n  /**\n   * Function to call when the instance is no longer needed.\n   */\n  destroy() {\n    var _this$resizeListener;\n    (_this$resizeListener = this.resizeListener) === null || _this$resizeListener === void 0 || _this$resizeListener.off();\n  }\n  /**\n   * Get the choice number of an element. It is extracted from the classes.\n   *\n   * @param node Element to check.\n   * @returns Choice number.\n   */\n  getChoice(node) {\n    return this.getClassnameNumericSuffix(node, 'choice');\n  }\n  /**\n   * Get the number in a certain class name of an element.\n   *\n   * @param node The element to check.\n   * @param prefix Prefix of the class to check.\n   * @returns The number in the class.\n   */\n  getClassnameNumericSuffix(node, prefix) {\n    if (node !== null && node !== void 0 && node.classList.length) {\n      const patt1 = new RegExp('^' + prefix + '([0-9])+$');\n      const patt2 = new RegExp('([0-9])+$');\n      for (let index = 0; index < node.classList.length; index++) {\n        if (patt1.test(node.classList[index])) {\n          const match = patt2.exec(node.classList[index]);\n          return Number(match === null || match === void 0 ? void 0 : match[0]);\n        }\n      }\n    }\n    this.logger.warn('Prefix \"' + prefix + '\" not found in class names.');\n  }\n  /**\n   * Get the group number of an element. It is extracted from the classes.\n   *\n   * @param node Element to check.\n   * @returns Group number.\n   */\n  getGroup(node) {\n    return this.getClassnameNumericSuffix(node, 'group');\n  }\n  /**\n   * Get the number of an element ('no'). It is extracted from the classes.\n   *\n   * @param node Element to check.\n   * @returns Number.\n   */\n  getNo(node) {\n    return this.getClassnameNumericSuffix(node, 'no');\n  }\n  /**\n   * Get the place number of an element. It is extracted from the classes.\n   *\n   * @param node Element to check.\n   * @returns Place number.\n   */\n  getPlace(node) {\n    return this.getClassnameNumericSuffix(node, 'place');\n  }\n  /**\n   * Initialize the question.\n   */\n  initializer() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const container = _this2.container.querySelector(_this2.selectors.topNode());\n      container === null || container === void 0 || container.classList.add(_this2.readOnly ? 'readonly' : 'notreadonly');\n      // Wait for the elements to be ready.\n      yield _this2.waitForReady();\n      yield _this2.setPaddingSizesAll();\n      _this2.cloneDragItems();\n      _this2.initialPlaceOfDragItems();\n      _this2.makeDropZones();\n      _this2.positionDragItems();\n      _this2.resizeListener = CoreDom.onWindowResize(() => {\n        _this2.positionDragItems();\n      });\n    })();\n  }\n  /**\n   * Initialize drag items, putting them in their initial place.\n   */\n  initialPlaceOfDragItems() {\n    const drags = Array.from(this.container.querySelectorAll(this.selectors.drags()));\n    // Add the class 'unplaced' to all elements.\n    drags.forEach(drag => {\n      drag.classList.add('unplaced');\n    });\n    this.placed = {};\n    for (const placeNo in this.inputIds) {\n      const inputId = this.inputIds[placeNo];\n      const inputNode = this.container.querySelector('input#' + inputId);\n      const choiceNo = Number(inputNode === null || inputNode === void 0 ? void 0 : inputNode.getAttribute('value'));\n      if (choiceNo !== 0 && !isNaN(choiceNo)) {\n        var _this$getGroup2;\n        const drop = this.container.querySelector(this.selectors.dropForPlace(parseInt(placeNo, 10) + 1));\n        const groupNo = (_this$getGroup2 = this.getGroup(drop)) !== null && _this$getGroup2 !== void 0 ? _this$getGroup2 : -1;\n        const drag = this.container.querySelector(this.selectors.unplacedDragsForChoiceInGroup(choiceNo, groupNo));\n        this.placeDragInDrop(drag, drop);\n        this.positionDragItem(drag);\n      }\n    }\n  }\n  /**\n   * Make an element \"draggable\". In the mobile app, items are \"dragged\" using tap and drop.\n   *\n   * @param drag Element.\n   */\n  makeDraggable(drag) {\n    drag.addEventListener('click', () => {\n      if (drag.classList.contains('selected')) {\n        this.deselectDrags();\n      } else {\n        this.selectDrag(drag);\n      }\n    });\n  }\n  /**\n   * Convert an element into a drop zone.\n   *\n   * @param drop Element.\n   */\n  makeDropZone(drop) {\n    drop.addEventListener('click', () => {\n      const drag = this.selected;\n      if (!drag) {\n        // No element selected, nothing to do.\n        return false;\n      }\n      // Place it only if the same group is selected.\n      if (this.getGroup(drag) === this.getGroup(drop)) {\n        this.placeDragInDrop(drag, drop);\n        this.deselectDrags();\n        this.positionDragItem(drag);\n      }\n    });\n  }\n  /**\n   * Create all drop zones.\n   */\n  makeDropZones() {\n    if (this.readOnly) {\n      return;\n    }\n    // Create all the drop zones.\n    const drops = Array.from(this.container.querySelectorAll(this.selectors.drops()));\n    drops.forEach(drop => {\n      this.makeDropZone(drop);\n    });\n    // If home answer zone is clicked, return drag home.\n    const home = this.container.querySelector(this.selectors.topNode() + ' .answercontainer');\n    home === null || home === void 0 || home.addEventListener('click', () => {\n      const drag = this.selected;\n      if (!drag) {\n        // No element selected, nothing to do.\n        return;\n      }\n      // Not placed yet, deselect.\n      if (drag.classList.contains('unplaced')) {\n        this.deselectDrags();\n        return;\n      }\n      // Remove, deselect and move back home in this order.\n      this.removeDragFromDrop(drag);\n      this.deselectDrags();\n      this.positionDragItem(drag);\n    });\n  }\n  /**\n   * Set the width and height of an element.\n   *\n   * @param node Element.\n   * @param width Width to set.\n   * @param height Height to set.\n   */\n  padToWidthHeight(node, width, height) {\n    node.style.width = width + 'px';\n    node.style.height = height + 'px';\n    // Originally lineHeight was set as height to center the text but it comes on too height lines on multiline elements.\n  }\n  /**\n   * Place a draggable element inside a drop zone.\n   *\n   * @param drag Draggable element.\n   * @param drop Drop zone.\n   */\n  placeDragInDrop(drag, drop) {\n    var _this$getPlace;\n    if (!drop) {\n      return;\n    }\n    const placeNo = (_this$getPlace = this.getPlace(drop)) !== null && _this$getPlace !== void 0 ? _this$getPlace : -1;\n    const inputId = this.inputIds[placeNo - 1];\n    const inputNode = this.container.querySelector('input#' + inputId);\n    // Set the value of the drag element in the input of the drop zone.\n    if (drag !== null) {\n      inputNode === null || inputNode === void 0 || inputNode.setAttribute('value', String(this.getChoice(drag)));\n    } else {\n      inputNode === null || inputNode === void 0 || inputNode.setAttribute('value', '0');\n    }\n    // Remove the element from the \"placed\" map if it's there.\n    for (const alreadyThereDragNo in this.placed) {\n      if (this.placed[alreadyThereDragNo] === placeNo) {\n        delete this.placed[alreadyThereDragNo];\n      }\n    }\n    if (drag !== null) {\n      var _this$getNo;\n      // Add the element in the \"placed\" map.\n      this.placed[(_this$getNo = this.getNo(drag)) !== null && _this$getNo !== void 0 ? _this$getNo : -1] = placeNo;\n    }\n  }\n  /**\n   * Position a drag element in the right drop zone or in the home zone.\n   *\n   * @param drag Drag element.\n   */\n  positionDragItem(drag) {\n    var _this$getNo2;\n    if (!drag) {\n      return;\n    }\n    const placeNo = this.placed[(_this$getNo2 = this.getNo(drag)) !== null && _this$getNo2 !== void 0 ? _this$getNo2 : -1];\n    const parent = this.container.querySelector('.addon-qtype-ddwtos-container');\n    if (!parent) {\n      return;\n    }\n    let position;\n    if (!placeNo) {\n      var _this$getGroup3, _this$getChoice;\n      // Not placed, put it in home zone.\n      const groupNo = (_this$getGroup3 = this.getGroup(drag)) !== null && _this$getGroup3 !== void 0 ? _this$getGroup3 : -1;\n      const choiceNo = (_this$getChoice = this.getChoice(drag)) !== null && _this$getChoice !== void 0 ? _this$getChoice : -1;\n      const dragHome = this.container.querySelector(this.selectors.dragHome(groupNo, choiceNo));\n      if (dragHome) {\n        position = CoreDom.getRelativeElementPosition(dragHome, parent);\n      }\n    } else {\n      // Get the drop zone position.\n      const dropZone = this.container.querySelector(this.selectors.dropForPlace(placeNo));\n      if (dropZone) {\n        position = CoreDom.getRelativeElementPosition(dropZone, parent);\n        // Avoid the border.\n        position.x++;\n        position.y++;\n      }\n    }\n    drag.classList.toggle('unplaced', !placeNo);\n    if (position) {\n      drag.style.left = position.x + 'px';\n      drag.style.top = position.y + 'px';\n    }\n  }\n  /**\n   * Postition, or reposition, all the drag items. They're placed in the right drop zone or in the home zone.\n   */\n  positionDragItems() {\n    const drags = Array.from(this.container.querySelectorAll(this.selectors.drags()));\n    drags.forEach(drag => {\n      this.positionDragItem(drag);\n    });\n  }\n  /**\n   * Wait for the drag home items to be in DOM.\n   *\n   * @returns Promise resolved when ready in the DOM.\n   */\n  waitForReady() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreDom.waitToBeInDOM(_this3.container);\n      yield CoreDirectivesRegistry.waitDirectivesReady(_this3.container, 'core-format-text', CoreFormatTextDirective);\n      const drag = Array.from(_this3.container.querySelectorAll(_this3.selectors.dragHomes()))[0];\n      yield CoreDom.waitToBeInDOM(drag);\n    })();\n  }\n  /**\n   * Remove a draggable element from a drop zone.\n   *\n   * @param drag The draggable element.\n   */\n  removeDragFromDrop(drag) {\n    var _this$getNo3;\n    const placeNo = this.placed[(_this$getNo3 = this.getNo(drag)) !== null && _this$getNo3 !== void 0 ? _this$getNo3 : -1];\n    const drop = this.container.querySelector(this.selectors.dropForPlace(placeNo));\n    this.placeDragInDrop(null, drop);\n  }\n  /**\n   * Select a certain element as being \"dragged\".\n   *\n   * @param drag Element.\n   */\n  selectDrag(drag) {\n    // Deselect previous drags, only 1 can be selected.\n    this.deselectDrags();\n    this.selected = drag;\n    drag.classList.add('selected');\n  }\n  /**\n   * Set the padding size for all groups.\n   */\n  setPaddingSizesAll() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      for (let groupNo = 1; groupNo <= 8; groupNo++) {\n        yield _this4.setPaddingSizeForGroup(groupNo);\n      }\n    })();\n  }\n  /**\n   * Set the padding size for a certain group.\n   *\n   * @param groupNo Group number.\n   */\n  setPaddingSizeForGroup(groupNo) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const groupItems = Array.from(_this5.container.querySelectorAll(_this5.selectors.dragHomesGroup(groupNo)));\n      if (!groupItems.length) {\n        return;\n      }\n      groupItems.forEach(item => {\n        item.innerHTML = CoreTextUtils.decodeHTML(item.innerHTML);\n      });\n      // Wait to render in order to calculate size.\n      if (groupItems[0].parentElement) {\n        // Wait for parent to be visible. We cannot wait for group items because they have visibility hidden.\n        yield CoreDom.waitToBeVisible(groupItems[0].parentElement);\n      } else {\n        // Group items should always have a parent, add a fallback just in case.\n        yield CoreDom.waitToBeInDOM(groupItems[0]);\n        yield CoreUtils.nextTicks(5);\n      }\n      // Find max height and width.\n      let maxWidth = 0;\n      let maxHeight = 0;\n      groupItems.forEach(item => {\n        maxWidth = Math.max(maxWidth, Math.ceil(item.offsetWidth));\n        maxHeight = Math.max(maxHeight, Math.ceil(item.offsetHeight));\n      });\n      maxWidth += 8;\n      maxHeight += 5;\n      groupItems.forEach(item => {\n        _this5.padToWidthHeight(item, maxWidth, maxHeight);\n      });\n      const dropsGroup = Array.from(_this5.container.querySelectorAll(_this5.selectors.dropsGroup(groupNo)));\n      dropsGroup.forEach(item => {\n        _this5.padToWidthHeight(item, maxWidth + 2, maxHeight + 2);\n      });\n    })();\n  }\n}\n/**\n * Set of functions to get the CSS selectors.\n */\nexport class AddonQtypeDdwtosQuestionCSSSelectors {\n  topNode() {\n    return '.addon-qtype-ddwtos-container';\n  }\n  dragContainer() {\n    return this.topNode() + ' div.drags';\n  }\n  drags() {\n    return this.dragContainer() + ' span.drag';\n  }\n  drag(no) {\n    return this.drags() + `.no${no}`;\n  }\n  dragsInGroup(groupNo) {\n    return this.drags() + `.group${groupNo}`;\n  }\n  unplacedDragsInGroup(groupNo) {\n    return this.dragsInGroup(groupNo) + '.unplaced';\n  }\n  dragsForChoiceInGroup(choiceNo, groupNo) {\n    return this.dragsInGroup(groupNo) + `.choice${choiceNo}`;\n  }\n  unplacedDragsForChoiceInGroup(choiceNo, groupNo) {\n    return this.unplacedDragsInGroup(groupNo) + `.choice${choiceNo}`;\n  }\n  drops() {\n    return this.topNode() + ' span.drop';\n  }\n  dropForPlace(placeNo) {\n    return this.drops() + `.place${placeNo}`;\n  }\n  dropsInGroup(groupNo) {\n    return this.drops() + `.group${groupNo}`;\n  }\n  dragHomes() {\n    return this.topNode() + ' span.draghome';\n  }\n  dragHomesGroup(groupNo) {\n    return this.topNode() + ` .draggrouphomes${groupNo} span.draghome`;\n  }\n  dragHome(groupNo, choiceNo) {\n    return this.topNode() + ` .draggrouphomes${groupNo} span.draghome.choice${choiceNo}`;\n  }\n  dropsGroup(groupNo) {\n    return this.topNode() + ` span.drop.group${groupNo}`;\n  }\n}","map":{"version":3,"names":["CoreFormatTextDirective","CoreTextUtils","CoreUtils","CoreDirectivesRegistry","CoreDom","CoreLogger","AddonQtypeDdwtosQuestion","constructor","container","question","readOnly","inputIds","nextDragItemNo","selectors","AddonQtypeDdwtosQuestionCSSSelectors","placed","logger","getInstance","initializer","cloneDragItem","dragHome","drag","cloneNode","classList","remove","add","setAttribute","style","visibility","position","querySelector","dragContainer","appendChild","makeDraggable","cloneDragItems","_this","_asyncToGenerator","dragHomes","Array","from","querySelectorAll","x","length","cloneDragItemsForOneChoice","contains","_this$getGroup","groupNo","getGroup","noOfDrags","dropsInGroup","deselectDrags","drags","forEach","selected","undefined","destroy","_this$resizeListener","resizeListener","off","getChoice","node","getClassnameNumericSuffix","prefix","patt1","RegExp","patt2","index","test","match","exec","Number","warn","getNo","getPlace","_this2","topNode","waitForReady","setPaddingSizesAll","initialPlaceOfDragItems","makeDropZones","positionDragItems","onWindowResize","placeNo","inputId","inputNode","choiceNo","getAttribute","isNaN","_this$getGroup2","drop","dropForPlace","parseInt","unplacedDragsForChoiceInGroup","placeDragInDrop","positionDragItem","addEventListener","selectDrag","makeDropZone","drops","home","removeDragFromDrop","padToWidthHeight","width","height","_this$getPlace","String","alreadyThereDragNo","_this$getNo","_this$getNo2","parent","_this$getGroup3","_this$getChoice","getRelativeElementPosition","dropZone","y","toggle","left","top","_this3","waitToBeInDOM","waitDirectivesReady","_this$getNo3","_this4","setPaddingSizeForGroup","_this5","groupItems","dragHomesGroup","item","innerHTML","decodeHTML","parentElement","waitToBeVisible","nextTicks","maxWidth","maxHeight","Math","max","ceil","offsetWidth","offsetHeight","dropsGroup","no","dragsInGroup","unplacedDragsInGroup","dragsForChoiceInGroup"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/qtype/ddwtos/classes/ddwtos.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreFormatTextDirective } from '@directives/format-text';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreDirectivesRegistry } from '@singletons/directives-registry';\nimport { CoreCoordinates, CoreDom } from '@singletons/dom';\nimport { CoreEventObserver } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { AddonModQuizDdwtosQuestionData } from '../component/ddwtos';\n\n/**\n * Class to make a question of ddwtos type work.\n */\nexport class AddonQtypeDdwtosQuestion {\n\n    protected logger: CoreLogger;\n    protected nextDragItemNo = 1;\n    protected selectors = new AddonQtypeDdwtosQuestionCSSSelectors(); // Result of cssSelectors.\n    protected placed: {[no: number]: number} = {}; // Map that relates drag elements numbers with drop zones numbers.\n    protected selected?: HTMLElement; // Selected element (being \"dragged\").\n    protected resizeListener?: CoreEventObserver;\n\n    /**\n     * Create the instance.\n     *\n     * @param container The container HTMLElement of the question.\n     * @param question The question instance.\n     * @param readOnly Whether it's read only.\n     * @param inputIds Ids of the inputs of the question (where the answers will be stored).\n     */\n    constructor(\n        protected container: HTMLElement,\n        protected question: AddonModQuizDdwtosQuestionData,\n        protected readOnly: boolean,\n        protected inputIds: string[],\n    ) {\n        this.logger = CoreLogger.getInstance('AddonQtypeDdwtosQuestion');\n\n        this.initializer();\n    }\n\n    /**\n     * Clone a drag item and add it to the drag container.\n     *\n     * @param dragHome Item to clone\n     */\n    cloneDragItem(dragHome: HTMLElement): void {\n        const drag = <HTMLElement> dragHome.cloneNode(true);\n\n        drag.classList.remove('draghome');\n        drag.classList.add('drag');\n        drag.classList.add('no' + this.nextDragItemNo);\n        this.nextDragItemNo++;\n        drag.setAttribute('tabindex', '0');\n\n        drag.style.visibility = 'visible';\n        drag.style.position = 'absolute';\n\n        const container = this.container.querySelector(this.selectors.dragContainer());\n        container?.appendChild(drag);\n\n        if (!this.readOnly) {\n            this.makeDraggable(drag);\n        }\n    }\n\n    /**\n     * Clone the 'drag homes'.\n     * Invisible 'drag homes' are output in the question. These have the same properties as the drag items but are invisible.\n     * We clone these invisible elements to make the actual drag items.\n     */\n    async cloneDragItems(): Promise<void> {\n        const dragHomes = Array.from(this.container.querySelectorAll<HTMLElement>(this.selectors.dragHomes()));\n        for (let x = 0; x < dragHomes.length; x++) {\n            this.cloneDragItemsForOneChoice(dragHomes[x]);\n        }\n    }\n\n    /**\n     * Clone a certain 'drag home'. If it's an \"infinite\" drag, clone it several times.\n     *\n     * @param dragHome Element to clone.\n     */\n    cloneDragItemsForOneChoice(dragHome: HTMLElement): void {\n        if (dragHome.classList.contains('infinite')) {\n            const groupNo = this.getGroup(dragHome) ?? -1;\n            const noOfDrags = this.container.querySelectorAll(this.selectors.dropsInGroup(groupNo)).length;\n\n            for (let x = 0; x < noOfDrags; x++) {\n                this.cloneDragItem(dragHome);\n            }\n        } else {\n            this.cloneDragItem(dragHome);\n        }\n    }\n\n    /**\n     * Deselect all drags.\n     */\n    deselectDrags(): void {\n        // Remove the selected class from all drags.\n        const drags = Array.from(this.container.querySelectorAll<HTMLElement>(this.selectors.drags()));\n        drags.forEach((drag) => {\n            drag.classList.remove('selected');\n        });\n        this.selected = undefined;\n    }\n\n    /**\n     * Function to call when the instance is no longer needed.\n     */\n    destroy(): void {\n        this.resizeListener?.off();\n    }\n\n    /**\n     * Get the choice number of an element. It is extracted from the classes.\n     *\n     * @param node Element to check.\n     * @returns Choice number.\n     */\n    getChoice(node: HTMLElement | null): number | undefined {\n        return this.getClassnameNumericSuffix(node, 'choice');\n    }\n\n    /**\n     * Get the number in a certain class name of an element.\n     *\n     * @param node The element to check.\n     * @param prefix Prefix of the class to check.\n     * @returns The number in the class.\n     */\n    getClassnameNumericSuffix(node: HTMLElement | null, prefix: string): number | undefined {\n        if (node?.classList.length) {\n            const patt1 = new RegExp('^' + prefix + '([0-9])+$');\n            const patt2 = new RegExp('([0-9])+$');\n\n            for (let index = 0; index < node.classList.length; index++) {\n                if (patt1.test(node.classList[index])) {\n                    const match = patt2.exec(node.classList[index]);\n\n                    return Number(match?.[0]);\n                }\n            }\n        }\n\n        this.logger.warn('Prefix \"' + prefix + '\" not found in class names.');\n    }\n\n    /**\n     * Get the group number of an element. It is extracted from the classes.\n     *\n     * @param node Element to check.\n     * @returns Group number.\n     */\n    getGroup(node: HTMLElement | null): number | undefined {\n        return this.getClassnameNumericSuffix(node, 'group');\n    }\n\n    /**\n     * Get the number of an element ('no'). It is extracted from the classes.\n     *\n     * @param node Element to check.\n     * @returns Number.\n     */\n    getNo(node: HTMLElement | null): number | undefined {\n        return this.getClassnameNumericSuffix(node, 'no');\n    }\n\n    /**\n     * Get the place number of an element. It is extracted from the classes.\n     *\n     * @param node Element to check.\n     * @returns Place number.\n     */\n    getPlace(node: HTMLElement | null): number | undefined {\n        return this.getClassnameNumericSuffix(node, 'place');\n    }\n\n    /**\n     * Initialize the question.\n     */\n    async initializer(): Promise<void> {\n        const container = this.container.querySelector<HTMLElement>(this.selectors.topNode());\n        container?.classList.add(this.readOnly ? 'readonly' : 'notreadonly');\n\n        // Wait for the elements to be ready.\n        await this.waitForReady();\n\n        await this.setPaddingSizesAll();\n        this.cloneDragItems();\n        this.initialPlaceOfDragItems();\n        this.makeDropZones();\n\n        this.positionDragItems();\n\n        this.resizeListener = CoreDom.onWindowResize(() => {\n            this.positionDragItems();\n        });\n    }\n\n    /**\n     * Initialize drag items, putting them in their initial place.\n     */\n    initialPlaceOfDragItems(): void {\n        const drags = Array.from(this.container.querySelectorAll<HTMLElement>(this.selectors.drags()));\n\n        // Add the class 'unplaced' to all elements.\n        drags.forEach((drag) => {\n            drag.classList.add('unplaced');\n        });\n\n        this.placed = {};\n        for (const placeNo in this.inputIds) {\n            const inputId = this.inputIds[placeNo];\n            const inputNode = this.container.querySelector('input#' + inputId);\n            const choiceNo = Number(inputNode?.getAttribute('value'));\n\n            if (choiceNo !== 0 && !isNaN(choiceNo)) {\n                const drop = this.container.querySelector<HTMLElement>(this.selectors.dropForPlace(parseInt(placeNo, 10) + 1));\n                const groupNo = this.getGroup(drop) ?? -1;\n                const drag = this.container.querySelector<HTMLElement>(\n                    this.selectors.unplacedDragsForChoiceInGroup(choiceNo, groupNo),\n                );\n\n                this.placeDragInDrop(drag, drop);\n                this.positionDragItem(drag);\n            }\n        }\n    }\n\n    /**\n     * Make an element \"draggable\". In the mobile app, items are \"dragged\" using tap and drop.\n     *\n     * @param drag Element.\n     */\n    makeDraggable(drag: HTMLElement): void {\n        drag.addEventListener('click', () => {\n            if (drag.classList.contains('selected')) {\n                this.deselectDrags();\n            } else {\n                this.selectDrag(drag);\n            }\n        });\n    }\n\n    /**\n     * Convert an element into a drop zone.\n     *\n     * @param drop Element.\n     */\n    makeDropZone(drop: HTMLElement): void {\n        drop.addEventListener('click', () => {\n            const drag = this.selected;\n            if (!drag) {\n                // No element selected, nothing to do.\n                return false;\n            }\n\n            // Place it only if the same group is selected.\n            if (this.getGroup(drag) === this.getGroup(drop)) {\n                this.placeDragInDrop(drag, drop);\n                this.deselectDrags();\n                this.positionDragItem(drag);\n            }\n        });\n    }\n\n    /**\n     * Create all drop zones.\n     */\n    makeDropZones(): void {\n        if (this.readOnly) {\n            return;\n        }\n\n        // Create all the drop zones.\n        const drops = Array.from(this.container.querySelectorAll<HTMLElement>(this.selectors.drops()));\n        drops.forEach((drop) => {\n            this.makeDropZone(drop);\n        });\n\n        // If home answer zone is clicked, return drag home.\n        const home = this.container.querySelector<HTMLElement>(this.selectors.topNode() + ' .answercontainer');\n\n        home?.addEventListener('click', () => {\n            const drag = this.selected;\n            if (!drag) {\n                // No element selected, nothing to do.\n                return;\n            }\n\n            // Not placed yet, deselect.\n            if (drag.classList.contains('unplaced')) {\n                this.deselectDrags();\n\n                return;\n            }\n\n            // Remove, deselect and move back home in this order.\n            this.removeDragFromDrop(drag);\n            this.deselectDrags();\n            this.positionDragItem(drag);\n        });\n    }\n\n    /**\n     * Set the width and height of an element.\n     *\n     * @param node Element.\n     * @param width Width to set.\n     * @param height Height to set.\n     */\n    protected padToWidthHeight(node: HTMLElement, width: number, height: number): void {\n        node.style.width = width + 'px';\n        node.style.height = height + 'px';\n        // Originally lineHeight was set as height to center the text but it comes on too height lines on multiline elements.\n    }\n\n    /**\n     * Place a draggable element inside a drop zone.\n     *\n     * @param drag Draggable element.\n     * @param drop Drop zone.\n     */\n    placeDragInDrop(drag: HTMLElement | null, drop: HTMLElement | null): void {\n        if (!drop) {\n            return;\n        }\n\n        const placeNo = this.getPlace(drop) ?? -1;\n        const inputId = this.inputIds[placeNo - 1];\n        const inputNode = this.container.querySelector('input#' + inputId);\n\n        // Set the value of the drag element in the input of the drop zone.\n        if (drag !== null) {\n            inputNode?.setAttribute('value', String(this.getChoice(drag)));\n        } else {\n            inputNode?.setAttribute('value', '0');\n        }\n\n        // Remove the element from the \"placed\" map if it's there.\n        for (const alreadyThereDragNo in this.placed) {\n            if (this.placed[alreadyThereDragNo] === placeNo) {\n                delete this.placed[alreadyThereDragNo];\n            }\n        }\n\n        if (drag !== null) {\n            // Add the element in the \"placed\" map.\n            this.placed[this.getNo(drag) ?? -1] = placeNo;\n        }\n    }\n\n    /**\n     * Position a drag element in the right drop zone or in the home zone.\n     *\n     * @param drag Drag element.\n     */\n    positionDragItem(drag: HTMLElement | null): void {\n        if (!drag) {\n            return;\n        }\n\n        const placeNo = this.placed[this.getNo(drag) ?? -1];\n        const parent = this.container.querySelector<HTMLElement>('.addon-qtype-ddwtos-container');\n        if (!parent) {\n            return;\n        }\n\n        let position: CoreCoordinates | undefined;\n\n        if (!placeNo) {\n            // Not placed, put it in home zone.\n            const groupNo = this.getGroup(drag) ?? -1;\n            const choiceNo = this.getChoice(drag) ?? -1;\n            const dragHome = this.container.querySelector<HTMLElement>(this.selectors.dragHome(groupNo, choiceNo));\n            if (dragHome) {\n                position = CoreDom.getRelativeElementPosition(dragHome, parent);\n            }\n        } else {\n            // Get the drop zone position.\n            const dropZone = this.container.querySelector<HTMLElement>(this.selectors.dropForPlace(placeNo));\n            if (dropZone) {\n                position = CoreDom.getRelativeElementPosition(dropZone, parent);\n                // Avoid the border.\n                position.x++;\n                position.y++;\n            }\n        }\n        drag.classList.toggle('unplaced', !placeNo);\n\n        if (position) {\n            drag.style.left = position.x + 'px';\n            drag.style.top = position.y + 'px';\n        }\n    }\n\n    /**\n     * Postition, or reposition, all the drag items. They're placed in the right drop zone or in the home zone.\n     */\n    positionDragItems(): void {\n        const drags = Array.from(this.container.querySelectorAll<HTMLElement>(this.selectors.drags()));\n        drags.forEach((drag) => {\n            this.positionDragItem(drag);\n        });\n    }\n\n    /**\n     * Wait for the drag home items to be in DOM.\n     *\n     * @returns Promise resolved when ready in the DOM.\n     */\n    protected async waitForReady(): Promise<void> {\n        await CoreDom.waitToBeInDOM(this.container);\n\n        await CoreDirectivesRegistry.waitDirectivesReady(this.container, 'core-format-text', CoreFormatTextDirective);\n\n        const drag = Array.from(this.container.querySelectorAll<HTMLElement>(this.selectors.dragHomes()))[0];\n\n        await CoreDom.waitToBeInDOM(drag);\n    }\n\n    /**\n     * Remove a draggable element from a drop zone.\n     *\n     * @param drag The draggable element.\n     */\n    removeDragFromDrop(drag: HTMLElement): void {\n        const placeNo = this.placed[this.getNo(drag) ?? -1];\n        const drop = this.container.querySelector<HTMLElement>(this.selectors.dropForPlace(placeNo));\n\n        this.placeDragInDrop(null, drop);\n    }\n\n    /**\n     * Select a certain element as being \"dragged\".\n     *\n     * @param drag Element.\n     */\n    selectDrag(drag: HTMLElement): void {\n        // Deselect previous drags, only 1 can be selected.\n        this.deselectDrags();\n\n        this.selected = drag;\n        drag.classList.add('selected');\n    }\n\n    /**\n     * Set the padding size for all groups.\n     */\n    async setPaddingSizesAll(): Promise<void> {\n        for (let groupNo = 1; groupNo <= 8; groupNo++) {\n            await this.setPaddingSizeForGroup(groupNo);\n        }\n    }\n\n    /**\n     * Set the padding size for a certain group.\n     *\n     * @param groupNo Group number.\n     */\n    async setPaddingSizeForGroup(groupNo: number): Promise<void> {\n        const groupItems = Array.from(this.container.querySelectorAll<HTMLElement>(this.selectors.dragHomesGroup(groupNo)));\n\n        if (!groupItems.length) {\n            return;\n        }\n\n        groupItems.forEach((item) => {\n            item.innerHTML = CoreTextUtils.decodeHTML(item.innerHTML);\n        });\n\n        // Wait to render in order to calculate size.\n        if (groupItems[0].parentElement) {\n            // Wait for parent to be visible. We cannot wait for group items because they have visibility hidden.\n            await CoreDom.waitToBeVisible(groupItems[0].parentElement);\n        } else {\n            // Group items should always have a parent, add a fallback just in case.\n            await CoreDom.waitToBeInDOM(groupItems[0]);\n            await CoreUtils.nextTicks(5);\n        }\n\n        // Find max height and width.\n        let maxWidth = 0;\n        let maxHeight = 0;\n        groupItems.forEach((item) => {\n            maxWidth = Math.max(maxWidth, Math.ceil(item.offsetWidth));\n            maxHeight = Math.max(maxHeight, Math.ceil(item.offsetHeight));\n        });\n\n        maxWidth += 8;\n        maxHeight += 5;\n        groupItems.forEach((item) => {\n            this.padToWidthHeight(item, maxWidth, maxHeight);\n        });\n\n        const dropsGroup = Array.from(this.container.querySelectorAll<HTMLElement>(this.selectors.dropsGroup(groupNo)));\n        dropsGroup.forEach((item) => {\n            this.padToWidthHeight(item, maxWidth + 2, maxHeight + 2);\n        });\n    }\n\n}\n\n/**\n * Set of functions to get the CSS selectors.\n */\nexport class AddonQtypeDdwtosQuestionCSSSelectors {\n\n    topNode(): string {\n        return '.addon-qtype-ddwtos-container';\n    }\n\n    dragContainer(): string {\n        return this.topNode() + ' div.drags';\n    }\n\n    drags(): string {\n        return this.dragContainer() + ' span.drag';\n    }\n\n    drag(no: number): string {\n        return this.drags() + `.no${no}`;\n    }\n\n    dragsInGroup(groupNo: number): string {\n        return this.drags() + `.group${groupNo}`;\n    }\n\n    unplacedDragsInGroup(groupNo: number): string {\n        return this.dragsInGroup(groupNo) + '.unplaced';\n    }\n\n    dragsForChoiceInGroup(choiceNo: number, groupNo: number): string {\n        return this.dragsInGroup(groupNo) + `.choice${choiceNo}`;\n    }\n\n    unplacedDragsForChoiceInGroup(choiceNo: number, groupNo: number): string {\n        return this.unplacedDragsInGroup(groupNo) + `.choice${choiceNo}`;\n    }\n\n    drops(): string {\n        return this.topNode() + ' span.drop';\n    }\n\n    dropForPlace(placeNo: number): string {\n        return this.drops() + `.place${placeNo}`;\n    }\n\n    dropsInGroup(groupNo: number): string {\n        return this.drops() + `.group${groupNo}`;\n    }\n\n    dragHomes(): string {\n        return this.topNode() + ' span.draghome';\n    }\n\n    dragHomesGroup(groupNo: number): string {\n        return this.topNode() + ` .draggrouphomes${groupNo} span.draghome`;\n    }\n\n    dragHome(groupNo: number, choiceNo: number): string {\n        return this.topNode() + ` .draggrouphomes${groupNo} span.draghome.choice${choiceNo}`;\n    }\n\n    dropsGroup(groupNo: number): string {\n        return this.topNode() + ` span.drop.group${groupNo}`;\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}