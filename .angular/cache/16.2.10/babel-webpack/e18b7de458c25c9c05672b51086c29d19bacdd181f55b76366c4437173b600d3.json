{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CONVERSATION_MESSAGES_TABLE, MESSAGES_TABLE } from './database/messages';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle Offline messages.\n */\nexport class AddonMessagesOfflineProvider {\n  /**\n   * Delete a message.\n   *\n   * @param conversationId Conversation ID.\n   * @param message The message.\n   * @param timeCreated The time the message was created.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteConversationMessage(conversationId, message, timeCreated, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(CONVERSATION_MESSAGES_TABLE, {\n        conversationid: conversationId,\n        text: message,\n        timecreated: timeCreated\n      });\n    })();\n  }\n  /**\n   * Delete all the messages in a conversation.\n   *\n   * @param conversationId Conversation ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteConversationMessages(conversationId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(CONVERSATION_MESSAGES_TABLE, {\n        conversationid: conversationId\n      });\n    })();\n  }\n  /**\n   * Delete a message.\n   *\n   * @param toUserId User ID to send the message to.\n   * @param message The message.\n   * @param timeCreated The time the message was created.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteMessage(toUserId, message, timeCreated, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(MESSAGES_TABLE, {\n        touserid: toUserId,\n        smallmessage: message,\n        timecreated: timeCreated\n      });\n    })();\n  }\n  /**\n   * Get all messages where deviceoffline is set to 1.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with messages.\n   */\n  getAllDeviceOfflineMessages(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const [messages, conversations] = yield Promise.all([site.getDb().getRecords(MESSAGES_TABLE, {\n        deviceoffline: 1\n      }), site.getDb().getRecords(CONVERSATION_MESSAGES_TABLE, {\n        deviceoffline: 1\n      })]);\n      const messageResult = _this.parseMessages(messages);\n      const formattedConv = _this.parseConversationMessages(conversations);\n      return messageResult.concat(formattedConv);\n    })();\n  }\n  /**\n   * Get all offline messages.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with messages.\n   */\n  getAllMessages(siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const [messages, conversations] = yield Promise.all([site.getDb().getAllRecords(MESSAGES_TABLE), site.getDb().getAllRecords(CONVERSATION_MESSAGES_TABLE)]);\n      const messageResult = _this2.parseMessages(messages);\n      const formattedConv = _this2.parseConversationMessages(conversations);\n      return messageResult.concat(formattedConv);\n    })();\n  }\n  /**\n   * Get offline messages to send to a certain user.\n   *\n   * @param conversationId Conversation ID.\n   * @param userIdFrom To add to the conversation messages when parsing.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with messages.\n   */\n  getConversationMessages(conversationId, userIdFrom, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const messages = yield site.getDb().getRecords(CONVERSATION_MESSAGES_TABLE, {\n        conversationid: conversationId\n      });\n      return _this3.parseConversationMessages(messages, userIdFrom);\n    })();\n  }\n  /**\n   * Get offline messages to send to a certain user.\n   *\n   * @param toUserId User ID to get messages to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with messages.\n   */\n  getMessages(toUserId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const messages = yield site.getDb().getRecords(MESSAGES_TABLE, {\n        touserid: toUserId\n      });\n      return _this4.parseMessages(messages);\n    })();\n  }\n  /**\n   * Check if there are offline messages to send to a conversation.\n   *\n   * @param conversationId Conversation ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has offline messages, false otherwise.\n   */\n  hasConversationMessages(conversationId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const messages = yield _this5.getConversationMessages(conversationId, undefined, siteId);\n      return !!messages.length;\n    })();\n  }\n  /**\n   * Check if there are offline messages to send to a certain user.\n   *\n   * @param toUserId User ID to check.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has offline messages, false otherwise.\n   */\n  hasMessages(toUserId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const messages = yield _this6.getMessages(toUserId, siteId);\n      return !!messages.length;\n    })();\n  }\n  /**\n   * Parse some fields of each offline conversation messages.\n   *\n   * @param messages List of messages to parse.\n   * @param userIdFrom To add to the conversation messages when parsin.\n   * @returns Parsed messages.\n   */\n  parseConversationMessages(messages, userIdFrom) {\n    if (!messages) {\n      return [];\n    }\n    return messages.map(message => {\n      const parsedMessage = {\n        conversationid: message.conversationid,\n        text: message.text,\n        timecreated: message.timecreated,\n        deviceoffline: message.deviceoffline,\n        conversation: message.conversation ? CoreTextUtils.parseJSON(message.conversation, undefined) : undefined,\n        pending: true,\n        useridfrom: userIdFrom\n      };\n      return parsedMessage;\n    });\n  }\n  /**\n   * Parse some fields of each offline messages.\n   *\n   * @param messages List of messages to parse.\n   * @returns Parsed messages.\n   */\n  parseMessages(messages) {\n    if (!messages) {\n      return [];\n    }\n    return messages.map(message => {\n      const parsedMessage = {\n        touserid: message.touserid,\n        useridfrom: message.useridfrom,\n        smallmessage: message.smallmessage,\n        timecreated: message.timecreated,\n        deviceoffline: message.deviceoffline,\n        pending: true,\n        text: message.smallmessage\n      };\n      return parsedMessage;\n    });\n  }\n  /**\n   * Save a conversation message to be sent later.\n   *\n   * @param conversation Conversation.\n   * @param message The message to send.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  saveConversationMessage(conversation, message, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        conversationid: conversation.id,\n        text: message,\n        timecreated: Date.now(),\n        deviceoffline: CoreNetwork.isOnline() ? 0 : 1,\n        conversation: JSON.stringify({\n          name: conversation.name || '',\n          subname: conversation.subname || '',\n          imageurl: conversation.imageurl || '',\n          isfavourite: conversation.isfavourite ? 1 : 0,\n          type: conversation.type\n        })\n      };\n      yield site.getDb().insertRecord(CONVERSATION_MESSAGES_TABLE, entry);\n      return entry;\n    })();\n  }\n  /**\n   * Save a message to be sent later.\n   *\n   * @param toUserId User ID recipient of the message.\n   * @param message The message to send.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  saveMessage(toUserId, message, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        touserid: toUserId,\n        useridfrom: site.getUserId(),\n        smallmessage: message,\n        timecreated: Date.now(),\n        deviceoffline: CoreNetwork.isOnline() ? 0 : 1\n      };\n      yield site.getDb().insertRecord(MESSAGES_TABLE, entry);\n      return entry;\n    })();\n  }\n  /**\n   * Set deviceoffline for a group of messages.\n   *\n   * @param messages Messages to update. Should be the same entry as retrieved from the DB.\n   * @param value Value to set.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  setMessagesDeviceOffline(messages, value, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const db = site.getDb();\n      const promises = [];\n      const data = {\n        deviceoffline: value ? 1 : 0\n      };\n      messages.forEach(message => {\n        if ('conversationid' in message) {\n          promises.push(db.updateRecords(CONVERSATION_MESSAGES_TABLE, data, {\n            conversationid: message.conversationid,\n            text: message.text,\n            timecreated: message.timecreated\n          }));\n        } else {\n          promises.push(db.updateRecords(MESSAGES_TABLE, data, {\n            touserid: message.touserid,\n            smallmessage: message.smallmessage,\n            timecreated: message.timecreated\n          }));\n        }\n      });\n      yield Promise.all(promises);\n    })();\n  }\n}\n_class = AddonMessagesOfflineProvider;\n_class.ɵfac = function AddonMessagesOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonMessagesOffline = makeSingleton(AddonMessagesOfflineProvider);","map":{"version":3,"names":["CoreSites","CoreNetwork","CoreTextUtils","CONVERSATION_MESSAGES_TABLE","MESSAGES_TABLE","makeSingleton","AddonMessagesOfflineProvider","deleteConversationMessage","conversationId","message","timeCreated","siteId","_asyncToGenerator","site","getSite","getDb","deleteRecords","conversationid","text","timecreated","deleteConversationMessages","deleteMessage","toUserId","touserid","smallmessage","getAllDeviceOfflineMessages","_this","messages","conversations","Promise","all","getRecords","deviceoffline","messageResult","parseMessages","formattedConv","parseConversationMessages","concat","getAllMessages","_this2","getAllRecords","getConversationMessages","userIdFrom","_this3","getMessages","_this4","hasConversationMessages","_this5","undefined","length","hasMessages","_this6","map","parsedMessage","conversation","parseJSON","pending","useridfrom","saveConversationMessage","entry","id","Date","now","isOnline","JSON","stringify","name","subname","imageurl","isfavourite","type","insertRecord","saveMessage","getUserId","setMessagesDeviceOffline","value","db","promises","data","forEach","push","updateRecords","factory","ɵfac","providedIn","AddonMessagesOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/messages/services/messages-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreTextUtils } from '@services/utils/text';\nimport {\n    AddonMessagesOfflineConversationMessagesDBRecord,\n    AddonMessagesOfflineMessagesDBRecord,\n    CONVERSATION_MESSAGES_TABLE,\n    MESSAGES_TABLE,\n} from './database/messages';\nimport { makeSingleton } from '@singletons';\nimport { AddonMessagesConversation } from './messages';\n\n/**\n * Service to handle Offline messages.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonMessagesOfflineProvider {\n\n    /**\n     * Delete a message.\n     *\n     * @param conversationId Conversation ID.\n     * @param message The message.\n     * @param timeCreated The time the message was created.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteConversationMessage(conversationId: number, message: string, timeCreated: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(CONVERSATION_MESSAGES_TABLE, {\n            conversationid: conversationId,\n            text: message,\n            timecreated: timeCreated,\n        });\n    }\n\n    /**\n     * Delete all the messages in a conversation.\n     *\n     * @param conversationId Conversation ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteConversationMessages(conversationId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(CONVERSATION_MESSAGES_TABLE, {\n            conversationid: conversationId,\n        });\n    }\n\n    /**\n     * Delete a message.\n     *\n     * @param toUserId User ID to send the message to.\n     * @param message The message.\n     * @param timeCreated The time the message was created.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteMessage(toUserId: number, message: string, timeCreated: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(MESSAGES_TABLE, {\n            touserid: toUserId,\n            smallmessage: message,\n            timecreated: timeCreated,\n        });\n    }\n\n    /**\n     * Get all messages where deviceoffline is set to 1.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with messages.\n     */\n    async getAllDeviceOfflineMessages(\n        siteId?: string,\n    ): Promise<AddonMessagesOfflineAnyMessagesFormatted[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const [\n            messages,\n            conversations,\n        ] = await Promise.all([\n            site.getDb().getRecords<AddonMessagesOfflineMessagesDBRecord>(MESSAGES_TABLE, { deviceoffline: 1 }),\n            site.getDb().getRecords<AddonMessagesOfflineConversationMessagesDBRecord>(\n                CONVERSATION_MESSAGES_TABLE,\n                { deviceoffline: 1 },\n            ),\n        ]);\n\n        const messageResult:\n        AddonMessagesOfflineAnyMessagesFormatted[] =\n            this.parseMessages(messages);\n        const formattedConv = this.parseConversationMessages(conversations);\n\n        return messageResult.concat(formattedConv);\n    }\n\n    /**\n     * Get all offline messages.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with messages.\n     */\n    async getAllMessages(\n        siteId?: string,\n    ): Promise<AddonMessagesOfflineAnyMessagesFormatted[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const [\n            messages,\n            conversations,\n        ] = await Promise.all([\n            site.getDb().getAllRecords<AddonMessagesOfflineMessagesDBRecord>(MESSAGES_TABLE),\n            site.getDb().getAllRecords<AddonMessagesOfflineConversationMessagesDBRecord>(CONVERSATION_MESSAGES_TABLE),\n        ]);\n\n        const messageResult:\n        AddonMessagesOfflineAnyMessagesFormatted[] =\n            this.parseMessages(messages);\n        const formattedConv = this.parseConversationMessages(conversations);\n\n        return messageResult.concat(formattedConv);\n    }\n\n    /**\n     * Get offline messages to send to a certain user.\n     *\n     * @param conversationId Conversation ID.\n     * @param userIdFrom To add to the conversation messages when parsing.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with messages.\n     */\n    async getConversationMessages(\n        conversationId: number,\n        userIdFrom?: number,\n        siteId?: string,\n    ): Promise<AddonMessagesOfflineConversationMessagesDBRecordFormatted[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const messages: AddonMessagesOfflineConversationMessagesDBRecord[] = await site.getDb().getRecords(\n            CONVERSATION_MESSAGES_TABLE,\n            { conversationid: conversationId },\n        );\n\n        return this.parseConversationMessages(messages, userIdFrom);\n    }\n\n    /**\n     * Get offline messages to send to a certain user.\n     *\n     * @param toUserId User ID to get messages to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with messages.\n     */\n    async getMessages(toUserId: number, siteId?: string): Promise<AddonMessagesOfflineMessagesDBRecordFormatted[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const messages: AddonMessagesOfflineMessagesDBRecord[] =\n            await site.getDb().getRecords(MESSAGES_TABLE, { touserid: toUserId });\n\n        return this.parseMessages(messages);\n    }\n\n    /**\n     * Check if there are offline messages to send to a conversation.\n     *\n     * @param conversationId Conversation ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has offline messages, false otherwise.\n     */\n    async hasConversationMessages(conversationId: number, siteId?: string): Promise<boolean> {\n        const messages = await this.getConversationMessages(conversationId, undefined, siteId);\n\n        return !!messages.length;\n    }\n\n    /**\n     * Check if there are offline messages to send to a certain user.\n     *\n     * @param toUserId User ID to check.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has offline messages, false otherwise.\n     */\n    async hasMessages(toUserId: number, siteId?: string): Promise<boolean> {\n        const messages = await this.getMessages(toUserId, siteId);\n\n        return !!messages.length;\n    }\n\n    /**\n     * Parse some fields of each offline conversation messages.\n     *\n     * @param messages List of messages to parse.\n     * @param userIdFrom To add to the conversation messages when parsin.\n     * @returns Parsed messages.\n     */\n    protected parseConversationMessages(\n        messages: AddonMessagesOfflineConversationMessagesDBRecord[],\n        userIdFrom?: number,\n    ): AddonMessagesOfflineConversationMessagesDBRecordFormatted[] {\n        if (!messages) {\n            return [];\n        }\n\n        return messages.map((message) => {\n            const parsedMessage: AddonMessagesOfflineConversationMessagesDBRecordFormatted = {\n                conversationid: message.conversationid,\n                text: message.text,\n                timecreated: message.timecreated,\n                deviceoffline: message.deviceoffline,\n                conversation: message.conversation ? CoreTextUtils.parseJSON(message.conversation, undefined) : undefined,\n                pending: true,\n                useridfrom: userIdFrom,\n            };\n\n            return parsedMessage;\n        });\n    }\n\n    /**\n     * Parse some fields of each offline messages.\n     *\n     * @param messages List of messages to parse.\n     * @returns Parsed messages.\n     */\n    protected parseMessages(\n        messages: AddonMessagesOfflineMessagesDBRecord[],\n    ): AddonMessagesOfflineMessagesDBRecordFormatted[] {\n        if (!messages) {\n            return [];\n        }\n\n        return messages.map((message) => {\n            const parsedMessage: AddonMessagesOfflineMessagesDBRecordFormatted = {\n                touserid: message.touserid,\n                useridfrom: message.useridfrom,\n                smallmessage: message.smallmessage,\n                timecreated: message.timecreated,\n                deviceoffline: message.deviceoffline,\n                pending: true,\n                text: message.smallmessage,\n            };\n\n            return parsedMessage;\n        });\n    }\n\n    /**\n     * Save a conversation message to be sent later.\n     *\n     * @param conversation Conversation.\n     * @param message The message to send.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async saveConversationMessage(\n        conversation: AddonMessagesConversation,\n        message: string,\n        siteId?: string,\n    ): Promise<AddonMessagesOfflineConversationMessagesDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entry: AddonMessagesOfflineConversationMessagesDBRecord = {\n            conversationid: conversation.id,\n            text: message,\n            timecreated: Date.now(),\n            deviceoffline: CoreNetwork.isOnline() ? 0 : 1,\n            conversation: JSON.stringify({\n                name: conversation.name || '',\n                subname: conversation.subname || '',\n                imageurl: conversation.imageurl || '',\n                isfavourite: conversation.isfavourite ? 1 : 0,\n                type: conversation.type,\n            }),\n        };\n\n        await site.getDb().insertRecord(CONVERSATION_MESSAGES_TABLE, entry);\n\n        return entry;\n    }\n\n    /**\n     * Save a message to be sent later.\n     *\n     * @param toUserId User ID recipient of the message.\n     * @param message The message to send.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async saveMessage(toUserId: number, message: string, siteId?: string): Promise<AddonMessagesOfflineMessagesDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entry: AddonMessagesOfflineMessagesDBRecord = {\n            touserid: toUserId,\n            useridfrom: site.getUserId(),\n            smallmessage: message,\n            timecreated: Date.now(),\n            deviceoffline: CoreNetwork.isOnline() ? 0 : 1,\n        };\n\n        await site.getDb().insertRecord(MESSAGES_TABLE, entry);\n\n        return entry;\n    }\n\n    /**\n     * Set deviceoffline for a group of messages.\n     *\n     * @param messages Messages to update. Should be the same entry as retrieved from the DB.\n     * @param value Value to set.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async setMessagesDeviceOffline(\n        messages: AddonMessagesOfflineAnyMessagesFormatted[],\n        value: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const db = site.getDb();\n\n        const promises: Promise<number>[] = [];\n        const data = { deviceoffline: value ? 1 : 0 };\n\n        messages.forEach((message) => {\n            if ('conversationid' in message) {\n                promises.push(db.updateRecords(\n                    CONVERSATION_MESSAGES_TABLE,\n                    data,\n                    { conversationid: message.conversationid, text: message.text, timecreated: message.timecreated },\n                ));\n            } else {\n                promises.push(db.updateRecords(\n                    MESSAGES_TABLE,\n                    data,\n                    { touserid: message.touserid, smallmessage: message.smallmessage, timecreated: message.timecreated },\n                ));\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n}\n\nexport const AddonMessagesOffline = makeSingleton(AddonMessagesOfflineProvider);\n\nexport type AddonMessagesOfflineMessagesDBRecordFormatted = AddonMessagesOfflineMessagesDBRecord & {\n    pending?: boolean; // Will be likely true.\n    text?: string; // Copy of smallmessage.\n};\n\nexport type AddonMessagesOfflineConversationMessagesDBRecordFormatted =\n    Omit<AddonMessagesOfflineConversationMessagesDBRecord, 'conversation'> &\n    {\n        conversation?: AddonMessagesConversation; // Data about the conversation.\n        pending: boolean; // Will be always true.\n        useridfrom?: number; // User Id who send the message, will be likely us.\n    };\n\nexport type AddonMessagesOfflineAnyMessagesFormatted =\n    AddonMessagesOfflineConversationMessagesDBRecordFormatted | AddonMessagesOfflineMessagesDBRecordFormatted;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}