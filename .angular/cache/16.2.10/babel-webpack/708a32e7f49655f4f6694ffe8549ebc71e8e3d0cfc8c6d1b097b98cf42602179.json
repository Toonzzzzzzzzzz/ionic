{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreRatingSync } from '@features/rating/services/rating-sync';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModDataProvider, AddonModData, AddonModDataAction } from './data';\nimport { AddonModDataHelper } from './data-helper';\nimport { AddonModDataOffline } from './data-offline';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync databases.\n */\nexport class AddonModDataSyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModDataSyncProvider');\n    this.componentTranslatableString = 'data';\n  }\n  /**\n   * Check if a database has data to synchronize.\n   *\n   * @param dataId Database ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has data to sync, false otherwise.\n   */\n  hasDataToSync(dataId, siteId) {\n    return AddonModDataOffline.hasOfflineData(dataId, siteId);\n  }\n  /**\n   * Try to synchronize all the databases in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllDatabases(siteId, force) {\n    return this.syncOnSites('all databases', siteId => this.syncAllDatabasesFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all pending databases on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllDatabasesFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      // Get all data answers pending to be sent in the site.\n      promises.push(AddonModDataOffline.getAllEntries(siteId).then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (offlineActions) {\n          // Get data id.\n          let dataIds = offlineActions.map(action => action.dataid);\n          // Get unique values.\n          dataIds = dataIds.filter((id, pos) => dataIds.indexOf(id) == pos);\n          const entriesPromises = dataIds.map( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (dataId) {\n              const result = force ? yield _this.syncDatabase(dataId, siteId) : yield _this.syncDatabaseIfNeeded(dataId, siteId);\n              if (result && result.updated) {\n                // Sync done. Send event.\n                CoreEvents.trigger(AddonModDataSyncProvider.AUTO_SYNCED, {\n                  dataId: dataId,\n                  warnings: result.warnings\n                }, siteId);\n              }\n            });\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }());\n          yield Promise.all(entriesPromises);\n          return;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      promises.push(_this.syncRatings(undefined, force, siteId));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Sync a database only if a certain time has passed since the last time.\n   *\n   * @param dataId Database ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is synced or if it doesn't need to be synced.\n   */\n  syncDatabaseIfNeeded(dataId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const needed = yield _this2.isSyncNeeded(dataId, siteId);\n      if (needed) {\n        return _this2.syncDatabase(dataId, siteId);\n      }\n    })();\n  }\n  /**\n   * Synchronize a data.\n   *\n   * @param dataId Data ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncDatabase(dataId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const currentSyncPromise = this.getOngoingSync(dataId, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for this database, return the promise.\n      return currentSyncPromise;\n    }\n    // Verify that database isn't blocked.\n    if (CoreSync.isBlocked(AddonModDataProvider.COMPONENT, dataId, siteId)) {\n      this.logger.debug(`Cannot sync database '${dataId}' because it is blocked.`);\n      throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', {\n        $a: this.componentTranslate\n      }));\n    }\n    this.logger.debug(`Try to sync data '${dataId}' in site ${siteId}'`);\n    const syncPromise = this.performSyncDatabase(dataId, siteId);\n    return this.addOngoingSync(dataId, syncPromise, siteId);\n  }\n  /**\n   * Perform the database syncronization.\n   *\n   * @param dataId Data ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  performSyncDatabase(dataId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModDataProvider.COMPONENT, dataId, siteId));\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Get answers to be sent.\n      const offlineActions = yield CoreUtils.ignoreErrors(AddonModDataOffline.getDatabaseEntries(dataId, siteId), []);\n      if (!offlineActions.length) {\n        // Nothing to sync.\n        yield CoreUtils.ignoreErrors(_this3.setSyncTime(dataId, siteId));\n        return result;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      const courseId = offlineActions[0].courseid;\n      // Send the answers.\n      const database = yield AddonModData.getDatabaseById(courseId, dataId, {\n        siteId\n      });\n      const offlineEntries = {};\n      offlineActions.forEach(entry => {\n        if (offlineEntries[entry.entryid] === undefined) {\n          offlineEntries[entry.entryid] = [];\n        }\n        offlineEntries[entry.entryid].push(entry);\n      });\n      const promises = CoreUtils.objectToArray(offlineEntries).map(entryActions => _this3.syncEntry(database, entryActions, result, siteId));\n      yield Promise.all(promises);\n      if (result.updated) {\n        // Data has been sent to server. Now invalidate the WS calls.\n        yield CoreUtils.ignoreErrors(AddonModData.invalidateContent(database.coursemodule, courseId, siteId));\n      }\n      // Sync finished, set sync time.\n      yield CoreUtils.ignoreErrors(_this3.setSyncTime(dataId, siteId));\n      return result;\n    })();\n  }\n  /**\n   * Synchronize an entry.\n   *\n   * @param database Database.\n   * @param entryActions Entry actions.\n   * @param result Object with the result of the sync.\n   * @param siteId Site ID.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  syncEntry(database, entryActions, result, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const syncEntryResult = yield _this4.performSyncEntry(database, entryActions, result, siteId);\n      if (syncEntryResult.discardError) {\n        // Submission was discarded, add a warning.\n        _this4.addOfflineDataDeletedWarning(result.warnings, database.name, syncEntryResult.discardError);\n      }\n      // Sync done. Send event.\n      CoreEvents.trigger(AddonModDataSyncProvider.AUTO_SYNCED, {\n        dataId: database.id,\n        entryId: syncEntryResult.entryId,\n        offlineEntryId: syncEntryResult.offlineId,\n        warnings: result.warnings,\n        deleted: syncEntryResult.deleted\n      }, siteId);\n    })();\n  }\n  /**\n   * Perform the synchronization of an entry.\n   *\n   * @param database Database.\n   * @param entryActions Entry actions.\n   * @param result Object with the result of the sync.\n   * @param siteId Site ID.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  performSyncEntry(database, entryActions, result, siteId) {\n    return _asyncToGenerator(function* () {\n      let entryId = entryActions[0].entryid;\n      const entryResult = {\n        deleted: false,\n        entryId: entryId\n      };\n      const editAction = entryActions.find(action => action.action == AddonModDataAction.ADD || action.action == AddonModDataAction.EDIT);\n      const approveAction = entryActions.find(action => action.action == AddonModDataAction.APPROVE || action.action == AddonModDataAction.DISAPPROVE);\n      const deleteAction = entryActions.find(action => action.action == AddonModDataAction.DELETE);\n      const options = {\n        cmId: database.coursemodule,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      let timemodified = 0;\n      if (entryId > 0) {\n        try {\n          const entry = yield AddonModData.getEntry(database.id, entryId, options);\n          timemodified = entry.entry.timemodified;\n        } catch (error) {\n          if (error && CoreUtils.isWebServiceError(error)) {\n            // The WebService has thrown an error, this means the entry has been deleted.\n            timemodified = -1;\n          } else {\n            throw error;\n          }\n        }\n      } else if (editAction) {\n        // New entry.\n        entryResult.offlineId = entryId;\n        timemodified = 0;\n      } else {\n        // New entry but the add action is missing, discard.\n        timemodified = -1;\n      }\n      if (timemodified < 0 || timemodified >= entryActions[0].timemodified) {\n        // The entry was not found in Moodle or the entry has been modified, discard the action.\n        result.updated = true;\n        entryResult.discardError = Translate.instant('addon.mod_data.warningsubmissionmodified');\n        yield AddonModDataOffline.deleteAllEntryActions(database.id, entryId, siteId);\n        return entryResult;\n      }\n      if (deleteAction) {\n        try {\n          yield AddonModData.deleteEntryOnline(entryId, siteId);\n          entryResult.deleted = true;\n        } catch (error) {\n          if (error && CoreUtils.isWebServiceError(error)) {\n            // The WebService has thrown an error, this means it cannot be performed. Discard.\n            entryResult.discardError = CoreTextUtils.getErrorMessageFromError(error);\n          } else {\n            // Couldn't connect to server, reject.\n            throw error;\n          }\n        }\n        // Delete the offline data.\n        result.updated = true;\n        yield AddonModDataOffline.deleteAllEntryActions(deleteAction.dataid, deleteAction.entryid, siteId);\n        return entryResult;\n      }\n      if (editAction) {\n        try {\n          yield Promise.all(editAction.fields.map( /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(function* (field) {\n              // Upload Files if asked.\n              const value = CoreTextUtils.parseJSON(field.value || '', null);\n              if (value && (value.online || value.offline)) {\n                let files = value.online || [];\n                const offlineFiles = value.offline ? yield AddonModDataHelper.getStoredFiles(editAction.dataid, entryId, field.fieldid) : [];\n                files = files.concat(offlineFiles);\n                const filesResult = yield AddonModDataHelper.uploadOrStoreFiles(editAction.dataid, 0, entryId, field.fieldid, files, false, siteId);\n                field.value = JSON.stringify(filesResult);\n              }\n            });\n            return function (_x3) {\n              return _ref3.apply(this, arguments);\n            };\n          }()));\n          if (editAction.action == AddonModDataAction.ADD) {\n            const result = yield AddonModData.addEntryOnline(editAction.dataid, editAction.fields, editAction.groupid, siteId);\n            entryId = result.newentryid;\n            entryResult.entryId = entryId;\n          } else {\n            yield AddonModData.editEntryOnline(entryId, editAction.fields, siteId);\n          }\n        } catch (error) {\n          if (error && CoreUtils.isWebServiceError(error)) {\n            // The WebService has thrown an error, this means it cannot be performed. Discard.\n            entryResult.discardError = CoreTextUtils.getErrorMessageFromError(error);\n          } else {\n            // Couldn't connect to server, reject.\n            throw error;\n          }\n        }\n        // Delete the offline data.\n        result.updated = true;\n        yield AddonModDataOffline.deleteEntry(editAction.dataid, editAction.entryid, editAction.action, siteId);\n      }\n      if (approveAction) {\n        try {\n          yield AddonModData.approveEntryOnline(entryId, approveAction.action == AddonModDataAction.APPROVE, siteId);\n        } catch (error) {\n          if (error && CoreUtils.isWebServiceError(error)) {\n            // The WebService has thrown an error, this means it cannot be performed. Discard.\n            entryResult.discardError = CoreTextUtils.getErrorMessageFromError(error);\n          } else {\n            // Couldn't connect to server, reject.\n            throw error;\n          }\n        }\n        // Delete the offline data.\n        result.updated = true;\n        yield AddonModDataOffline.deleteEntry(approveAction.dataid, approveAction.entryid, approveAction.action, siteId);\n      }\n      return entryResult;\n    })();\n  }\n  /**\n   * Synchronize offline ratings.\n   *\n   * @param cmId Course module to be synced. If not defined, sync all databases.\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncRatings(cmId, force, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const results = yield CoreRatingSync.syncRatings('mod_data', 'entry', \"module\" /* ContextLevel.MODULE */, cmId, 0, force, siteId);\n      let updated = false;\n      const warnings = [];\n      const promises = results.map(result => AddonModData.getDatabase(result.itemSet.courseId, result.itemSet.instanceId, {\n        siteId\n      }).then(database => {\n        const subPromises = [];\n        if (result.updated.length) {\n          updated = true;\n          // Invalidate entry of updated ratings.\n          result.updated.forEach(itemId => {\n            subPromises.push(AddonModData.invalidateEntryData(database.id, itemId, siteId));\n          });\n        }\n        if (result.warnings.length) {\n          result.warnings.forEach(warning => {\n            _this5.addOfflineDataDeletedWarning(warnings, database.name, warning);\n          });\n        }\n        return CoreUtils.allPromises(subPromises);\n      }));\n      yield Promise.all(promises);\n      return {\n        updated,\n        warnings\n      };\n    })();\n  }\n}\n_class = AddonModDataSyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_data_autom_synced';\n_class.ɵfac = function AddonModDataSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModDataSync = makeSingleton(AddonModDataSyncProvider);","map":{"version":3,"names":["CoreSyncBlockedError","CoreNetworkError","CoreCourseActivitySyncBaseProvider","CoreCourseLogHelper","CoreRatingSync","CoreNetwork","CoreSites","CoreSync","CoreTextUtils","CoreUtils","Translate","makeSingleton","CoreEvents","AddonModDataProvider","AddonModData","AddonModDataAction","AddonModDataHelper","AddonModDataOffline","AddonModDataSyncProvider","constructor","componentTranslatableString","hasDataToSync","dataId","siteId","hasOfflineData","syncAllDatabases","force","syncOnSites","syncAllDatabasesFunc","_this","_asyncToGenerator","promises","push","getAllEntries","then","_ref","offlineActions","dataIds","map","action","dataid","filter","id","pos","indexOf","entriesPromises","_ref2","result","syncDatabase","syncDatabaseIfNeeded","updated","trigger","AUTO_SYNCED","warnings","_x2","apply","arguments","Promise","all","_x","syncRatings","undefined","_this2","needed","isSyncNeeded","getCurrentSiteId","currentSyncPromise","getOngoingSync","isBlocked","COMPONENT","logger","debug","instant","$a","componentTranslate","syncPromise","performSyncDatabase","addOngoingSync","_this3","ignoreErrors","syncActivity","getDatabaseEntries","length","setSyncTime","isOnline","courseId","courseid","database","getDatabaseById","offlineEntries","forEach","entry","entryid","objectToArray","entryActions","syncEntry","invalidateContent","coursemodule","_this4","syncEntryResult","performSyncEntry","discardError","addOfflineDataDeletedWarning","name","entryId","offlineEntryId","offlineId","deleted","entryResult","editAction","find","ADD","EDIT","approveAction","APPROVE","DISAPPROVE","deleteAction","DELETE","options","cmId","readingStrategy","timemodified","getEntry","error","isWebServiceError","deleteAllEntryActions","deleteEntryOnline","getErrorMessageFromError","fields","_ref3","field","value","parseJSON","online","offline","files","offlineFiles","getStoredFiles","fieldid","concat","filesResult","uploadOrStoreFiles","JSON","stringify","_x3","addEntryOnline","groupid","newentryid","editEntryOnline","deleteEntry","approveEntryOnline","_this5","results","getDatabase","itemSet","instanceId","subPromises","itemId","invalidateEntryData","warning","allPromises","_class","factory","ɵfac","providedIn","AddonModDataSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/data/services/data-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { ContextLevel } from '@/core/constants';\nimport { Injectable } from '@angular/core';\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreFileUploaderStoreFilesResult } from '@features/fileuploader/services/fileuploader';\nimport { CoreRatingSync } from '@features/rating/services/rating-sync';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFileEntry } from '@services/file-helper';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModDataProvider, AddonModData, AddonModDataData, AddonModDataAction } from './data';\nimport { AddonModDataHelper } from './data-helper';\nimport { AddonModDataOffline, AddonModDataOfflineAction } from './data-offline';\n\n/**\n * Service to sync databases.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModDataSyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModDataSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_data_autom_synced';\n\n    protected componentTranslatableString = 'data';\n\n    constructor() {\n        super('AddonModDataSyncProvider');\n    }\n\n    /**\n     * Check if a database has data to synchronize.\n     *\n     * @param dataId Database ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has data to sync, false otherwise.\n     */\n    hasDataToSync(dataId: number, siteId?: string): Promise<boolean> {\n        return AddonModDataOffline.hasOfflineData(dataId, siteId);\n    }\n\n    /**\n     * Try to synchronize all the databases in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllDatabases(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all databases', (siteId) => this.syncAllDatabasesFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all pending databases on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllDatabasesFunc(force: boolean, siteId: string): Promise<void> {\n        const promises: Promise<unknown>[] = [];\n\n        // Get all data answers pending to be sent in the site.\n        promises.push(AddonModDataOffline.getAllEntries(siteId).then(async (offlineActions) => {\n            // Get data id.\n            let dataIds: number[] = offlineActions.map((action) => action.dataid);\n            // Get unique values.\n            dataIds = dataIds.filter((id, pos) => dataIds.indexOf(id) == pos);\n\n            const entriesPromises = dataIds.map(async (dataId) => {\n                const result = force\n                    ? await this.syncDatabase(dataId, siteId)\n                    : await this.syncDatabaseIfNeeded(dataId, siteId);\n\n                if (result && result.updated) {\n                    // Sync done. Send event.\n                    CoreEvents.trigger(AddonModDataSyncProvider.AUTO_SYNCED, {\n                        dataId: dataId,\n                        warnings: result.warnings,\n                    }, siteId);\n                }\n            });\n\n            await Promise.all(entriesPromises);\n\n            return;\n        }));\n\n        promises.push(this.syncRatings(undefined, force, siteId));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Sync a database only if a certain time has passed since the last time.\n     *\n     * @param dataId Database ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is synced or if it doesn't need to be synced.\n     */\n    async syncDatabaseIfNeeded(dataId: number, siteId?: string): Promise<AddonModDataSyncResult | undefined> {\n        const needed = await this.isSyncNeeded(dataId, siteId);\n\n        if (needed) {\n            return this.syncDatabase(dataId, siteId);\n        }\n    }\n\n    /**\n     * Synchronize a data.\n     *\n     * @param dataId Data ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    syncDatabase(dataId: number, siteId?: string): Promise<AddonModDataSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(dataId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this database, return the promise.\n            return currentSyncPromise;\n        }\n\n        // Verify that database isn't blocked.\n        if (CoreSync.isBlocked(AddonModDataProvider.COMPONENT, dataId, siteId)) {\n            this.logger.debug(`Cannot sync database '${dataId}' because it is blocked.`);\n\n            throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));\n        }\n\n        this.logger.debug(`Try to sync data '${dataId}' in site ${siteId}'`);\n\n        const syncPromise = this.performSyncDatabase(dataId, siteId);\n\n        return this.addOngoingSync(dataId, syncPromise, siteId);\n    }\n\n    /**\n     * Perform the database syncronization.\n     *\n     * @param dataId Data ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    protected async performSyncDatabase(dataId: number, siteId: string): Promise<AddonModDataSyncResult> {\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(\n            CoreCourseLogHelper.syncActivity(AddonModDataProvider.COMPONENT, dataId, siteId),\n        );\n\n        const result: AddonModDataSyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Get answers to be sent.\n        const offlineActions: AddonModDataOfflineAction[] =\n            await CoreUtils.ignoreErrors(AddonModDataOffline.getDatabaseEntries(dataId, siteId), []);\n\n        if (!offlineActions.length) {\n            // Nothing to sync.\n            await CoreUtils.ignoreErrors(this.setSyncTime(dataId, siteId));\n\n            return result;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        const courseId = offlineActions[0].courseid;\n\n        // Send the answers.\n        const database = await AddonModData.getDatabaseById(courseId, dataId, { siteId });\n\n        const offlineEntries: Record<number, AddonModDataOfflineAction[]> = {};\n\n        offlineActions.forEach((entry) => {\n            if (offlineEntries[entry.entryid] === undefined) {\n                offlineEntries[entry.entryid] = [];\n            }\n\n            offlineEntries[entry.entryid].push(entry);\n        });\n\n        const promises = CoreUtils.objectToArray(offlineEntries).map((entryActions) =>\n            this.syncEntry(database, entryActions, result, siteId));\n\n        await Promise.all(promises);\n\n        if (result.updated) {\n            // Data has been sent to server. Now invalidate the WS calls.\n            await CoreUtils.ignoreErrors(AddonModData.invalidateContent(database.coursemodule, courseId, siteId));\n        }\n\n        // Sync finished, set sync time.\n        await CoreUtils.ignoreErrors(this.setSyncTime(dataId, siteId));\n\n        return result;\n    }\n\n    /**\n     * Synchronize an entry.\n     *\n     * @param database Database.\n     * @param entryActions Entry actions.\n     * @param result Object with the result of the sync.\n     * @param siteId Site ID.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    protected async syncEntry(\n        database: AddonModDataData,\n        entryActions: AddonModDataOfflineAction[],\n        result: AddonModDataSyncResult,\n        siteId: string,\n    ): Promise<void> {\n        const syncEntryResult = await this.performSyncEntry(database, entryActions, result, siteId);\n\n        if (syncEntryResult.discardError) {\n            // Submission was discarded, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, database.name, syncEntryResult.discardError);\n        }\n\n        // Sync done. Send event.\n        CoreEvents.trigger(AddonModDataSyncProvider.AUTO_SYNCED, {\n            dataId: database.id,\n            entryId: syncEntryResult.entryId,\n            offlineEntryId: syncEntryResult.offlineId,\n            warnings: result.warnings,\n            deleted: syncEntryResult.deleted,\n        }, siteId);\n    }\n\n    /**\n     * Perform the synchronization of an entry.\n     *\n     * @param database Database.\n     * @param entryActions Entry actions.\n     * @param result Object with the result of the sync.\n     * @param siteId Site ID.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    protected async performSyncEntry(\n        database: AddonModDataData,\n        entryActions: AddonModDataOfflineAction[],\n        result: AddonModDataSyncResult,\n        siteId: string,\n    ): Promise<AddonModDataSyncEntryResult> {\n        let entryId = entryActions[0].entryid;\n\n        const entryResult: AddonModDataSyncEntryResult = {\n            deleted: false,\n            entryId: entryId,\n        };\n\n        const editAction = entryActions.find((action) =>\n            action.action == AddonModDataAction.ADD || action.action == AddonModDataAction.EDIT);\n        const approveAction = entryActions.find((action) =>\n            action.action == AddonModDataAction.APPROVE || action.action == AddonModDataAction.DISAPPROVE);\n        const deleteAction = entryActions.find((action) => action.action == AddonModDataAction.DELETE);\n\n        const options: CoreCourseCommonModWSOptions = {\n            cmId: database.coursemodule,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        let timemodified = 0;\n        if (entryId > 0) {\n            try {\n                const entry = await AddonModData.getEntry(database.id, entryId, options);\n\n                timemodified = entry.entry.timemodified;\n            } catch (error) {\n                if (error && CoreUtils.isWebServiceError(error)) {\n                    // The WebService has thrown an error, this means the entry has been deleted.\n                    timemodified = -1;\n                } else {\n                    throw error;\n                }\n            }\n\n        } else if (editAction) {\n            // New entry.\n            entryResult.offlineId = entryId;\n            timemodified = 0;\n        } else {\n            // New entry but the add action is missing, discard.\n            timemodified = -1;\n        }\n\n        if (timemodified < 0 || timemodified >= entryActions[0].timemodified) {\n            // The entry was not found in Moodle or the entry has been modified, discard the action.\n            result.updated = true;\n            entryResult.discardError = Translate.instant('addon.mod_data.warningsubmissionmodified');\n\n            await AddonModDataOffline.deleteAllEntryActions(database.id, entryId, siteId);\n\n            return entryResult;\n        }\n\n        if (deleteAction) {\n            try {\n                await AddonModData.deleteEntryOnline(entryId, siteId);\n                entryResult.deleted = true;\n            } catch (error) {\n                if (error && CoreUtils.isWebServiceError(error)) {\n                    // The WebService has thrown an error, this means it cannot be performed. Discard.\n                    entryResult.discardError = CoreTextUtils.getErrorMessageFromError(error);\n                } else {\n                    // Couldn't connect to server, reject.\n                    throw error;\n                }\n            }\n\n            // Delete the offline data.\n            result.updated = true;\n\n            await AddonModDataOffline.deleteAllEntryActions(deleteAction.dataid, deleteAction.entryid, siteId);\n\n            return entryResult;\n        }\n\n        if (editAction) {\n            try {\n                await Promise.all(editAction.fields.map(async (field) => {\n                    // Upload Files if asked.\n                    const value = CoreTextUtils.parseJSON<CoreFileUploaderStoreFilesResult | null>(field.value || '', null);\n                    if (value && (value.online || value.offline)) {\n                        let files: CoreFileEntry[] = value.online || [];\n\n                        const offlineFiles = value.offline\n                            ? await AddonModDataHelper.getStoredFiles(editAction.dataid, entryId, field.fieldid)\n                            : [];\n\n                        files = files.concat(offlineFiles);\n\n                        const filesResult = await AddonModDataHelper.uploadOrStoreFiles(\n                            editAction.dataid,\n                            0,\n                            entryId,\n                            field.fieldid,\n                            files,\n                            false,\n                            siteId,\n                        );\n\n                        field.value = JSON.stringify(filesResult);\n                    }\n                }));\n\n                if (editAction.action == AddonModDataAction.ADD) {\n                    const result = await AddonModData.addEntryOnline(\n                        editAction.dataid,\n                        editAction.fields,\n                        editAction.groupid,\n                        siteId,\n                    );\n                    entryId = result.newentryid;\n                    entryResult.entryId = entryId;\n                } else {\n                    await AddonModData.editEntryOnline(entryId, editAction.fields, siteId);\n                }\n            } catch (error) {\n                if (error && CoreUtils.isWebServiceError(error)) {\n                    // The WebService has thrown an error, this means it cannot be performed. Discard.\n                    entryResult.discardError = CoreTextUtils.getErrorMessageFromError(error);\n                } else {\n                    // Couldn't connect to server, reject.\n                    throw error;\n                }\n            }\n            // Delete the offline data.\n            result.updated = true;\n\n            await AddonModDataOffline.deleteEntry(editAction.dataid, editAction.entryid, editAction.action, siteId);\n        }\n\n        if (approveAction) {\n            try {\n                await AddonModData.approveEntryOnline(entryId, approveAction.action == AddonModDataAction.APPROVE, siteId);\n            } catch (error) {\n                if (error && CoreUtils.isWebServiceError(error)) {\n                    // The WebService has thrown an error, this means it cannot be performed. Discard.\n                    entryResult.discardError = CoreTextUtils.getErrorMessageFromError(error);\n                } else {\n                    // Couldn't connect to server, reject.\n                    throw error;\n                }\n            }\n            // Delete the offline data.\n            result.updated = true;\n\n            await AddonModDataOffline.deleteEntry(approveAction.dataid, approveAction.entryid, approveAction.action, siteId);\n        }\n\n        return entryResult;\n    }\n\n    /**\n     * Synchronize offline ratings.\n     *\n     * @param cmId Course module to be synced. If not defined, sync all databases.\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    async syncRatings(cmId?: number, force?: boolean, siteId?: string): Promise<AddonModDataSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const results = await CoreRatingSync.syncRatings('mod_data', 'entry', ContextLevel.MODULE, cmId, 0, force, siteId);\n        let updated = false;\n        const warnings = [];\n\n        const promises = results.map((result) =>\n            AddonModData.getDatabase(result.itemSet.courseId, result.itemSet.instanceId, { siteId })\n                .then((database) => {\n                    const subPromises: Promise<void>[] = [];\n\n                    if (result.updated.length) {\n                        updated = true;\n\n                        // Invalidate entry of updated ratings.\n                        result.updated.forEach((itemId) => {\n                            subPromises.push(AddonModData.invalidateEntryData(database.id, itemId, siteId));\n                        });\n                    }\n\n                    if (result.warnings.length) {\n                        result.warnings.forEach((warning) => {\n                            this.addOfflineDataDeletedWarning(warnings, database.name, warning);\n                        });\n                    }\n\n                    return CoreUtils.allPromises(subPromises);\n                }));\n\n        await Promise.all(promises);\n\n        return ({ updated, warnings });\n    }\n\n}\nexport const AddonModDataSync = makeSingleton(AddonModDataSyncProvider);\n\n/**\n * Data returned by a database sync.\n */\nexport type AddonModDataSyncEntryResult = {\n    discardError?: string;\n    offlineId?: number;\n    entryId: number;\n    deleted: boolean;\n};\n\n/**\n * Data returned by a database sync.\n */\nexport type AddonModDataSyncResult = CoreSyncResult;\n\nexport type AddonModDataAutoSyncData = {\n    dataId: number;\n    warnings: string[];\n    entryId?: number;\n    offlineEntryId?: number;\n    deleted?: boolean;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}