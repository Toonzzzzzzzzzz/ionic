{"ast":null,"code":"import _objectWithoutProperties from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nconst _excluded = [\"waitForDismissCompleted\", \"closeOnNavigate\"],\n  _excluded2 = [\"waitForDismissCompleted\"];\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { SimpleChange } from '@angular/core';\nimport { getMode } from '@ionic/core';\nimport { Md5 } from 'ts-md5';\nimport { CoreApp } from '@services/app';\nimport { CoreConfig } from '@services/config';\nimport { CoreFile } from '@services/file';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreIonLoadingElement } from '@classes/ion-loading';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSilentError } from '@classes/errors/silenterror';\nimport { makeSingleton, Translate, AlertController, ToastController, PopoverController, ModalController, Router } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreBSTooltipComponent } from '@components/bs-tooltip/bs-tooltip';\nimport { CoreViewerImageComponent } from '@features/viewer/components/image/image';\nimport { CoreModalLateralTransitionEnter, CoreModalLateralTransitionLeave } from '@classes/modal-lateral-transition';\nimport { CoreSites } from '@services/sites';\nimport { NavigationStart } from '@angular/router';\nimport { filter } from 'rxjs/operators';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSiteError } from '@classes/errors/siteerror';\nimport { CoreUserSupport } from '@features/user/services/support';\nimport { CoreErrorInfoComponent } from '@components/error-info/error-info';\nimport { CorePlatform } from '@services/platform';\nimport { CoreCancellablePromise } from '@classes/cancellable-promise';\nimport { CoreLang } from '@services/lang';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreErrorLogs } from '@singletons/error-logs';\nimport * as i0 from \"@angular/core\";\n/*\n * \"Utils\" service with helper functions for UI, DOM elements and HTML code.\n */\nexport class CoreDomUtilsProvider {\n  constructor() {\n    this.INSTANCE_ID_ATTR_NAME = 'core-instance-id';\n    // List of input types that support keyboard.\n    this.INPUT_SUPPORT_KEYBOARD = ['date', 'datetime', 'datetime-local', 'email', 'month', 'number', 'password', 'search', 'tel', 'text', 'time', 'url', 'week'];\n    this.template = document.createElement('template'); // A template element to convert HTML to element.\n    this.debugDisplay = false; // Whether to display debug messages. Store it in a variable to make it synchronous.\n    this.displayedAlerts = {}; // To prevent duplicated alerts.\n    this.displayedModals = {}; // To prevent duplicated modals.\n    this.activeLoadingModals = [];\n    this.logger = CoreLogger.getInstance('CoreDomUtilsProvider');\n    this.init();\n  }\n  /**\n   * Init some properties.\n   */\n  init() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Check if debug messages should be displayed.\n      const debugDisplay = yield CoreConfig.get(CoreConstants.SETTINGS_DEBUG_DISPLAY, 0);\n      _this.debugDisplay = debugDisplay != 0;\n    })();\n  }\n  /**\n   * If the download size is higher than a certain threshold shows a confirm dialog.\n   *\n   * @param size Object containing size to download and a boolean to indicate if its totally or partialy calculated.\n   * @param message Code of the message to show. Default: 'core.course.confirmdownload'.\n   * @param unknownMessage ID of the message to show if size is unknown.\n   * @param wifiThreshold Threshold to show confirm in WiFi connection. Default: CoreWifiDownloadThreshold.\n   * @param limitedThreshold Threshold to show confirm in limited connection. Default: CoreDownloadThreshold.\n   * @param alwaysConfirm True to show a confirm even if the size isn't high, false otherwise.\n   * @returns Promise resolved when the user confirms or if no confirm needed.\n   */\n  confirmDownloadSize(size, message, unknownMessage, wifiThreshold, limitedThreshold, alwaysConfirm) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const readableSize = CoreTextUtils.bytesToSize(size.size, 2);\n      const getAvailableBytes = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          const availableBytes = yield CoreFile.calculateFreeSpace();\n          if (CorePlatform.isAndroid()) {\n            return availableBytes;\n          } else {\n            // Space calculation is not accurate on iOS, but it gets more accurate when space is lower.\n            // We'll only use it when space is <500MB, or we're downloading more than twice the reported space.\n            if (availableBytes < CoreConstants.IOS_FREE_SPACE_THRESHOLD || size.size > availableBytes / 2) {\n              return availableBytes;\n            } else {\n              return null;\n            }\n          }\n        });\n        return function getAvailableBytes() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      const getAvailableSpace = availableBytes => {\n        if (availableBytes === null) {\n          return '';\n        } else {\n          const availableSize = CoreTextUtils.bytesToSize(availableBytes, 2);\n          if (CorePlatform.isAndroid() && size.size > availableBytes - CoreConstants.MINIMUM_FREE_SPACE) {\n            throw new CoreError(Translate.instant('core.course.insufficientavailablespace', {\n              size: readableSize\n            }));\n          }\n          return Translate.instant('core.course.availablespace', {\n            available: availableSize\n          });\n        }\n      };\n      const availableBytes = yield getAvailableBytes();\n      const availableSpace = getAvailableSpace(availableBytes);\n      wifiThreshold = wifiThreshold === undefined ? CoreConstants.WIFI_DOWNLOAD_THRESHOLD : wifiThreshold;\n      limitedThreshold = limitedThreshold === undefined ? CoreConstants.DOWNLOAD_THRESHOLD : limitedThreshold;\n      let wifiPrefix = '';\n      if (CoreNetwork.isNetworkAccessLimited()) {\n        wifiPrefix = Translate.instant('core.course.confirmlimiteddownload');\n      }\n      if (size.size < 0 || size.size == 0 && !size.total) {\n        // Seems size was unable to be calculated. Show a warning.\n        unknownMessage = unknownMessage || 'core.course.confirmdownloadunknownsize';\n        return _this2.showConfirm(wifiPrefix + Translate.instant(unknownMessage, {\n          availableSpace: availableSpace\n        }));\n      } else if (!size.total) {\n        // Filesize is only partial.\n        return _this2.showConfirm(wifiPrefix + Translate.instant('core.course.confirmpartialdownloadsize', {\n          size: readableSize,\n          availableSpace: availableSpace\n        }));\n      } else if (alwaysConfirm || size.size >= wifiThreshold || CoreNetwork.isNetworkAccessLimited() && size.size >= limitedThreshold) {\n        message = message || (size.size === 0 ? 'core.course.confirmdownloadzerosize' : 'core.course.confirmdownload');\n        return _this2.showConfirm(wifiPrefix + Translate.instant(message, {\n          size: readableSize,\n          availableSpace: availableSpace\n        }));\n      }\n    })();\n  }\n  /**\n   * Convert some HTML as text into an HTMLElement. This HTML is put inside a div or a body.\n   *\n   * @param html Text to convert.\n   * @returns Element.\n   */\n  convertToElement(html) {\n    // Add a div to hold the content, that's the element that will be returned.\n    this.template.innerHTML = '<div>' + html + '</div>';\n    return this.template.content.children[0];\n  }\n  /**\n   * Given a list of changes for a component input detected by a KeyValueDiffers, create an object similar to the one\n   * passed to the ngOnChanges functions.\n   *\n   * @param changes Changes detected by KeyValueDiffer.\n   * @returns Changes in a format like ngOnChanges.\n   */\n  createChangesFromKeyValueDiff(changes) {\n    const newChanges = {};\n    // Added items are considered first change.\n    changes.forEachAddedItem(item => {\n      newChanges[item.key] = new SimpleChange(item.previousValue, item.currentValue, true);\n    });\n    // Changed or removed items aren't first change.\n    changes.forEachChangedItem(item => {\n      newChanges[item.key] = new SimpleChange(item.previousValue, item.currentValue, false);\n    });\n    changes.forEachRemovedItem(item => {\n      newChanges[item.key] = new SimpleChange(item.previousValue, item.currentValue, true);\n    });\n    return newChanges;\n  }\n  /**\n   * Search all the URLs in a CSS file content.\n   *\n   * @param code CSS code.\n   * @returns List of URLs.\n   */\n  extractUrlsFromCSS(code) {\n    // First of all, search all the url(...) occurrences that don't include \"data:\".\n    const urls = [];\n    const matches = code.match(/url\\(\\s*[\"']?(?!data:)([^)]+)\\)/igm);\n    if (!matches) {\n      return urls;\n    }\n    // Extract the URL from each match.\n    matches.forEach(match => {\n      const submatches = match.match(/url\\(\\s*['\"]?([^'\"]*)['\"]?\\s*\\)/im);\n      if (submatches !== null && submatches !== void 0 && submatches[1]) {\n        urls.push(submatches[1]);\n      }\n    });\n    return urls;\n  }\n  /**\n   * Fix syntax errors in HTML.\n   *\n   * @param html HTML text.\n   * @returns Fixed HTML text.\n   */\n  fixHtml(html) {\n    this.template.innerHTML = html;\n    // eslint-disable-next-line no-control-regex\n    const attrNameRegExp = /[^\\x00-\\x20\\x7F-\\x9F\"'>/=]+/;\n    const fixElement = element => {\n      // Remove attributes with an invalid name.\n      Array.from(element.attributes).forEach(attr => {\n        if (!attrNameRegExp.test(attr.name)) {\n          element.removeAttributeNode(attr);\n        }\n      });\n      Array.from(element.children).forEach(fixElement);\n    };\n    Array.from(this.template.content.children).forEach(fixElement);\n    return this.template.innerHTML;\n  }\n  /**\n   * Focus an element and open keyboard.\n   *\n   * @param element HTML element to focus.\n   */\n  focusElement(element) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      let retries = 10;\n      let focusElement = element;\n      if ('getInputElement' in focusElement) {\n        // If it's an Ionic element get the right input to use.\n        focusElement.componentOnReady && (yield focusElement.componentOnReady());\n        focusElement = yield focusElement.getInputElement();\n      }\n      if (!focusElement || !focusElement.focus) {\n        throw new CoreError('Element to focus cannot be focused');\n      }\n      while (retries > 0 && focusElement !== document.activeElement) {\n        focusElement.focus();\n        if (focusElement === document.activeElement) {\n          yield CoreUtils.nextTick();\n          if (CorePlatform.isAndroid() && _this3.supportsInputKeyboard(focusElement)) {\n            // On some Android versions the keyboard doesn't open automatically.\n            CoreApp.openKeyboard();\n          }\n          break;\n        }\n        // @TODO Probably a Mutation Observer would get this working.\n        yield CoreUtils.wait(50);\n        retries--;\n      }\n    })();\n  }\n  /**\n   * Formats a size to be used as width/height of an element.\n   * If the size is already valid (like '500px' or '50%') it won't be modified.\n   * Returned size will have a format like '500px'.\n   *\n   * @param size Size to format.\n   * @returns Formatted size. If size is not valid, returns an empty string.\n   */\n  formatPixelsSize(size) {\n    if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1 || size == 'auto' || size == 'initial')) {\n      // It seems to be a valid size.\n      return size;\n    }\n    if (typeof size == 'string') {\n      // It's important to use parseInt instead of Number because Number('') is 0 instead of NaN.\n      size = parseInt(size, 10);\n    }\n    if (!isNaN(size)) {\n      return size + 'px';\n    }\n    return '';\n  }\n  /**\n   * Returns the contents of a certain selection in a DOM element.\n   *\n   * @param element DOM element to search in.\n   * @param selector Selector to search.\n   * @returns Selection contents. Undefined if not found.\n   */\n  getContentsOfElement(element, selector) {\n    const selected = element.querySelector(selector);\n    if (selected) {\n      return selected.innerHTML;\n    }\n  }\n  /**\n   * Returns the attribute value of a string element. Only the first element will be selected.\n   *\n   * @param html HTML element in string.\n   * @param attribute Attribute to get.\n   * @returns Attribute value.\n   */\n  getHTMLElementAttribute(html, attribute) {\n    return this.convertToElement(html).children[0].getAttribute(attribute);\n  }\n  /**\n   * Returns the computed style measure or 0 if not found or NaN.\n   *\n   * @param style Style from getComputedStyle.\n   * @param measure Measure to get.\n   * @returns Result of the measure.\n   */\n  getComputedStyleMeasure(style, measure) {\n    return parseInt(style[measure], 10) || 0;\n  }\n  /**\n   * Given a message, it deduce if it's a network error.\n   *\n   * @param message Message text.\n   * @param error Error object.\n   * @returns True if the message error is a network error, false otherwise.\n   */\n  isNetworkError(message, error) {\n    return message == Translate.instant('core.networkerrormsg') || message == Translate.instant('core.fileuploader.errormustbeonlinetoupload') || error instanceof CoreNetworkError;\n  }\n  /**\n   * Given a message, check if it's a site unavailable error.\n   *\n   * @param message Message text.\n   * @returns Whether the message is a site unavailable error.\n   */\n  isSiteUnavailableError(message) {\n    let siteUnavailableMessage = Translate.instant('core.siteunavailablehelp', {\n      site: 'SITEURLPLACEHOLDER'\n    });\n    siteUnavailableMessage = CoreTextUtils.escapeForRegex(siteUnavailableMessage);\n    siteUnavailableMessage = siteUnavailableMessage.replace('SITEURLPLACEHOLDER', '.*');\n    return new RegExp(siteUnavailableMessage).test(message);\n  }\n  /**\n   * Get the error message from an error, including debug data if needed.\n   *\n   * @param error Message to show.\n   * @param needsTranslate Whether the error needs to be translated.\n   * @returns Error message, null if no error should be displayed.\n   */\n  getErrorMessage(error, needsTranslate) {\n    if (typeof error != 'string' && !error) {\n      return null;\n    }\n    let extraInfo = '';\n    let errorMessage;\n    if (typeof error == 'object') {\n      if (this.debugDisplay) {\n        // Get the debug info. Escape the HTML so it is displayed as it is in the view.\n        if ('debuginfo' in error && error.debuginfo) {\n          extraInfo = '<br><br>' + CoreTextUtils.escapeHTML(error.debuginfo, false);\n        }\n        if ('backtrace' in error && error.backtrace) {\n          extraInfo += '<br><br>' + CoreTextUtils.replaceNewLines(CoreTextUtils.escapeHTML(error.backtrace, false), '<br>');\n        }\n        // eslint-disable-next-line no-console\n        console.error(error);\n      }\n      if (this.isSilentError(error)) {\n        // It's a silent error, don't display an error.\n        return null;\n      }\n      // We received an object instead of a string. Search for common properties.\n      errorMessage = CoreTextUtils.getErrorMessageFromError(error);\n      CoreErrorLogs.addErrorLog({\n        message: JSON.stringify(error),\n        type: errorMessage || '',\n        time: new Date().getTime()\n      });\n      if (!errorMessage) {\n        // No common properties found, just stringify it.\n        errorMessage = JSON.stringify(error);\n        extraInfo = ''; // No need to add extra info because it's already in the error.\n      }\n      // Try to remove tokens from the contents.\n      const matches = errorMessage.match(/token\"?[=|:]\"?(\\w*)/);\n      if (matches !== null && matches !== void 0 && matches[1]) {\n        errorMessage = errorMessage.replace(new RegExp(matches[1], 'g'), 'secret');\n      }\n    } else {\n      errorMessage = error;\n    }\n    let message = CoreTextUtils.decodeHTML(needsTranslate ? Translate.instant(errorMessage) : errorMessage);\n    if (extraInfo) {\n      message += extraInfo;\n    }\n    return message;\n  }\n  /**\n   * Check whether an error is an error caused because the user canceled a showConfirm.\n   *\n   * @param error Error to check.\n   * @returns Whether it's a canceled error.\n   */\n  isCanceledError(error) {\n    return error instanceof CoreCanceledError;\n  }\n  /**\n   * Check whether an error is an error caused because the user canceled a showConfirm.\n   *\n   * @param error Error to check.\n   * @returns Whether it's a canceled error.\n   */\n  isSilentError(error) {\n    return error instanceof CoreSilentError;\n  }\n  /**\n   * Handle bootstrap tooltips in a certain element.\n   *\n   * @param element Element to check.\n   */\n  handleBootstrapTooltips(element) {\n    const els = Array.from(element.querySelectorAll('[data-toggle=\"tooltip\"]'));\n    els.forEach(el => {\n      const content = el.getAttribute('title') || el.getAttribute('data-original-title');\n      const trigger = el.getAttribute('data-trigger') || 'hover focus';\n      const treated = el.getAttribute('data-bstooltip-treated');\n      if (!content || treated === 'true' || trigger.indexOf('hover') == -1 && trigger.indexOf('focus') == -1 && trigger.indexOf('click') == -1) {\n        return;\n      }\n      el.setAttribute('data-bstooltip-treated', 'true'); // Mark it as treated.\n      // Store the title in data-original-title instead of title, like BS does.\n      el.setAttribute('data-original-title', content);\n      el.setAttribute('title', '');\n      el.addEventListener('click', /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (ev) {\n          const html = el.getAttribute('data-html');\n          yield CoreDomUtils.openPopover({\n            component: CoreBSTooltipComponent,\n            componentProps: {\n              content,\n              html: html === 'true'\n            },\n            event: ev\n          });\n        });\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    });\n  }\n  /**\n   * Check if an element is outside of screen (viewport).\n   *\n   * @param scrollEl The element that must be scrolled.\n   * @param element DOM element to check.\n   * @param point The point of the element to check.\n   * @returns Whether the element is outside of the viewport.\n   */\n  isElementOutsideOfScreen(scrollEl, element, point = VerticalPoint.MID) {\n    const elementRect = element.getBoundingClientRect();\n    if (!elementRect) {\n      return false;\n    }\n    let elementPoint;\n    switch (point) {\n      case VerticalPoint.TOP:\n        elementPoint = elementRect.top;\n        break;\n      case VerticalPoint.BOTTOM:\n        elementPoint = elementRect.bottom;\n        break;\n      case VerticalPoint.MID:\n        elementPoint = Math.round((elementRect.bottom + elementRect.top) / 2);\n        break;\n    }\n    const scrollElRect = scrollEl.getBoundingClientRect();\n    const scrollTopPos = (scrollElRect === null || scrollElRect === void 0 ? void 0 : scrollElRect.top) || 0;\n    return elementPoint > window.innerHeight || elementPoint < scrollTopPos;\n  }\n  /**\n   * Check if rich text editor is enabled.\n   *\n   * @returns Promise resolved with boolean: true if enabled, false otherwise.\n   */\n  isRichTextEditorEnabled() {\n    return _asyncToGenerator(function* () {\n      const enabled = yield CoreConfig.get(CoreConstants.SETTINGS_RICH_TEXT_EDITOR, true);\n      return !!enabled;\n    })();\n  }\n  /**\n   * Move children from one HTMLElement to another.\n   *\n   * @param oldParent The old parent.\n   * @param newParent The new parent.\n   * @param prepend If true, adds the children to the beginning of the new parent.\n   * @returns List of moved children.\n   */\n  moveChildren(oldParent, newParent, prepend) {\n    const movedChildren = [];\n    const referenceNode = prepend ? newParent.firstChild : null;\n    while (oldParent.childNodes.length > 0) {\n      const child = oldParent.childNodes[0];\n      movedChildren.push(child);\n      newParent.insertBefore(child, referenceNode);\n    }\n    return movedChildren;\n  }\n  /**\n   * Search and remove a certain element from inside another element.\n   *\n   * @param element DOM element to search in.\n   * @param selector Selector to search.\n   */\n  removeElement(element, selector) {\n    const selected = element.querySelector(selector);\n    if (selected) {\n      selected.remove();\n    }\n  }\n  /**\n   * Search and remove a certain element from an HTML code.\n   *\n   * @param html HTML code to change.\n   * @param selector Selector to search.\n   * @param removeAll True if it should remove all matches found, false if it should only remove the first one.\n   * @returns HTML without the element.\n   */\n  removeElementFromHtml(html, selector, removeAll) {\n    const element = this.convertToElement(html);\n    if (removeAll) {\n      const selected = element.querySelectorAll(selector);\n      for (let i = 0; i < selected.length; i++) {\n        selected[i].remove();\n      }\n    } else {\n      const selected = element.querySelector(selector);\n      if (selected) {\n        selected.remove();\n      }\n    }\n    return element.innerHTML;\n  }\n  /**\n   * Search for certain classes in an element contents and replace them with the specified new values.\n   *\n   * @param element DOM element.\n   * @param map Mapping of the classes to replace. Keys must be the value to replace, values must be\n   *            the new class name. Example: {'correct': 'core-question-answer-correct'}.\n   */\n  replaceClassesInElement(element, map) {\n    for (const key in map) {\n      const foundElements = element.querySelectorAll('.' + key);\n      for (let i = 0; i < foundElements.length; i++) {\n        const foundElement = foundElements[i];\n        foundElement.className = foundElement.className.replace(key, map[key]);\n      }\n    }\n  }\n  /**\n   * Given an HTML, search all links and media and tries to restore original sources using the paths object.\n   *\n   * @param html HTML code.\n   * @param paths Object linking URLs in the html code with the real URLs to use.\n   * @param anchorFn Function to call with each anchor. Optional.\n   * @returns Treated HTML code.\n   */\n  restoreSourcesInHtml(html, paths, anchorFn) {\n    const element = this.convertToElement(html);\n    // Treat elements with src (img, audio, video, ...).\n    const media = Array.from(element.querySelectorAll('img, video, audio, source, track'));\n    media.forEach(media => {\n      const currentSrc = media.getAttribute('src');\n      const newSrc = currentSrc ? paths[CoreUrlUtils.removeUrlParams(CoreTextUtils.decodeURIComponent(currentSrc))] : undefined;\n      if (newSrc !== undefined) {\n        media.setAttribute('src', newSrc);\n      }\n      // Treat video posters.\n      const currentPoster = media.getAttribute('poster');\n      if (media.tagName == 'VIDEO' && currentPoster) {\n        const newPoster = paths[CoreTextUtils.decodeURIComponent(currentPoster)];\n        if (newPoster !== undefined) {\n          media.setAttribute('poster', newPoster);\n        }\n      }\n    });\n    // Now treat links.\n    const anchors = Array.from(element.querySelectorAll('a'));\n    anchors.forEach(anchor => {\n      const currentHref = anchor.getAttribute('href');\n      const newHref = currentHref ? paths[CoreUrlUtils.removeUrlParams(CoreTextUtils.decodeURIComponent(currentHref))] : undefined;\n      if (newHref !== undefined) {\n        anchor.setAttribute('href', newHref);\n        if (typeof anchorFn == 'function') {\n          anchorFn(anchor, newHref);\n        }\n      }\n    });\n    return element.innerHTML;\n  }\n  /**\n   * Returns height of the content.\n   *\n   * @param content Content where to execute the function.\n   * @returns Promise resolved with content height.\n   */\n  getContentHeight(content) {\n    return _asyncToGenerator(function* () {\n      try {\n        const scrollElement = yield content.getScrollElement();\n        return scrollElement.clientHeight || 0;\n      } catch (_unused) {\n        return 0;\n      }\n    })();\n  }\n  /**\n   * Returns scroll height of the content.\n   *\n   * @param content Content where to execute the function.\n   * @returns Promise resolved with scroll height.\n   */\n  getScrollHeight(content) {\n    return _asyncToGenerator(function* () {\n      try {\n        const scrollElement = yield content.getScrollElement();\n        return scrollElement.scrollHeight || 0;\n      } catch (_unused2) {\n        return 0;\n      }\n    })();\n  }\n  /**\n   * Returns scrollTop of the content.\n   *\n   * @param content Content where to execute the function.\n   * @returns Promise resolved with scroll top.\n   */\n  getScrollTop(content) {\n    return _asyncToGenerator(function* () {\n      try {\n        const scrollElement = yield content.getScrollElement();\n        return scrollElement.scrollTop || 0;\n      } catch (_unused3) {\n        return 0;\n      }\n    })();\n  }\n  /**\n   * Set whether debug messages should be displayed.\n   *\n   * @param value Whether to display or not.\n   */\n  setDebugDisplay(value) {\n    this.debugDisplay = value;\n  }\n  /**\n   * Show an alert modal with a button to close it.\n   *\n   * @param header Title to show.\n   * @param message Message to show.\n   * @param buttonText Text of the button.\n   * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n   * @returns Promise resolved with the alert modal.\n   */\n  showAlert(header, message, buttonText, autocloseTime) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4.showAlertWithOptions({\n        header,\n        message,\n        buttons: [buttonText || Translate.instant('core.ok')]\n      }, autocloseTime);\n    })();\n  }\n  /**\n   * General show an alert modal.\n   *\n   * @param options Alert options to pass to the alert.\n   * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n   * @returns Promise resolved with the alert modal.\n   */\n  showAlertWithOptions(options = {}, autocloseTime) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var _options$message, _CoreSites$getCurrent;\n      let message = typeof options.message == 'string' ? options.message : ((_options$message = options.message) === null || _options$message === void 0 ? void 0 : _options$message.value) || '';\n      const hasHTMLTags = CoreTextUtils.hasHTMLTags(message);\n      if (hasHTMLTags && !((_CoreSites$getCurrent = CoreSites.getCurrentSite()) !== null && _CoreSites$getCurrent !== void 0 && _CoreSites$getCurrent.isVersionGreaterEqualThan('3.7'))) {\n        // Treat multilang.\n        message = yield CoreLang.filterMultilang(message);\n      }\n      options.message = message;\n      const alertId = Md5.hashAsciiStr((options.header || '') + '#' + (message || ''));\n      if (_this5.displayedAlerts[alertId]) {\n        // There's already an alert with the same message and title. Return it.\n        return _this5.displayedAlerts[alertId];\n      }\n      const alert = yield AlertController.create(options);\n      if (Object.keys(_this5.displayedAlerts).length === 0) {\n        yield Promise.all(_this5.activeLoadingModals.slice(0).reverse().map(modal => modal.pause()));\n      }\n      // eslint-disable-next-line promise/catch-or-return\n      alert.present().then(() => {\n        if (hasHTMLTags) {\n          // Treat all anchors so they don't override the app.\n          const alertMessageEl = alert.querySelector('.alert-message');\n          alertMessageEl && _this5.treatAnchors(alertMessageEl);\n        }\n        return;\n      });\n      // Store the alert and remove it when dismissed.\n      _this5.displayedAlerts[alertId] = alert;\n      // Set the callbacks to trigger an observable event.\n      // eslint-disable-next-line promise/catch-or-return\n      alert.onDidDismiss().then( /*#__PURE__*/_asyncToGenerator(function* () {\n        delete _this5.displayedAlerts[alertId];\n        // eslint-disable-next-line promise/always-return\n        if (Object.keys(_this5.displayedAlerts).length === 0) {\n          yield Promise.all(_this5.activeLoadingModals.map(modal => modal.resume()));\n        }\n      }));\n      if (autocloseTime && autocloseTime > 0) {\n        setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n          yield alert.dismiss();\n          if (options.buttons) {\n            var _cancelButton$handler;\n            // Execute dismiss function if any.\n            const cancelButton = options.buttons.find(button => typeof button != 'string' && button.handler !== undefined && button.role == 'cancel');\n            cancelButton === null || cancelButton === void 0 || (_cancelButton$handler = cancelButton.handler) === null || _cancelButton$handler === void 0 || _cancelButton$handler.call(cancelButton, null);\n          }\n        }), autocloseTime);\n      }\n      return alert;\n    })();\n  }\n  /**\n   * Show an alert modal with a button to close it, translating the values supplied.\n   *\n   * @param header Title to show.\n   * @param message Message to show.\n   * @param buttonText Text of the button.\n   * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n   * @returns Promise resolved with the alert modal.\n   */\n  showAlertTranslated(header, message, buttonText, autocloseTime) {\n    header = header ? Translate.instant(header) : header;\n    message = message ? Translate.instant(message) : message;\n    buttonText = buttonText ? Translate.instant(buttonText) : buttonText;\n    return this.showAlert(header, message, buttonText, autocloseTime);\n  }\n  /**\n   * Shortcut for a delete confirmation modal.\n   *\n   * @param translateMessage String key to show in the modal body translated. Default: 'core.areyousure'.\n   * @param translateArgs Arguments to pass to translate if necessary.\n   * @param options More options. See https://ionicframework.com/docs/v3/api/components/alert/AlertController/\n   * @returns Promise resolved if the user confirms and rejected with a canceled error if he cancels.\n   */\n  showDeleteConfirm(translateMessage = 'core.areyousure', translateArgs = {}, options = {}) {\n    return new Promise((resolve, reject) => {\n      options.message = Translate.instant(translateMessage, translateArgs);\n      options.buttons = [{\n        text: Translate.instant('core.cancel'),\n        role: 'cancel',\n        handler: () => {\n          reject(new CoreCanceledError(''));\n        }\n      }, {\n        text: Translate.instant('core.delete'),\n        role: 'destructive',\n        handler: () => {\n          resolve();\n        }\n      }];\n      if (!options.header) {\n        options.cssClass = (options.cssClass || '') + ' core-nohead';\n      }\n      this.showAlertWithOptions(options, 0);\n    });\n  }\n  /**\n   * Show a confirm modal.\n   *\n   * @param message Message to show in the modal body.\n   * @param header Header of the modal.\n   * @param okText Text of the OK button.\n   * @param cancelText Text of the Cancel button.\n   * @param options More options.\n   * @returns Promise resolved if the user confirms and rejected with a canceled error if he cancels.\n   */\n  showConfirm(message, header, okText, cancelText, options = {}) {\n    return new Promise((resolve, reject) => {\n      options.header = header;\n      options.message = message;\n      options.buttons = [{\n        text: cancelText || Translate.instant('core.cancel'),\n        role: 'cancel',\n        handler: () => {\n          reject(new CoreCanceledError(''));\n        }\n      }, {\n        text: okText || Translate.instant('core.ok'),\n        handler: data => {\n          resolve(data);\n        }\n      }];\n      if (!header) {\n        options.cssClass = (options.cssClass || '') + ' core-nohead';\n      }\n      this.showAlertWithOptions(options, 0);\n    });\n  }\n  /**\n   * Show an alert modal with an error message.\n   *\n   * @param error Message to show.\n   * @param needsTranslate Whether the error needs to be translated.\n   * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n   * @returns Promise resolved with the alert modal.\n   */\n  showErrorModal(error, needsTranslate, autocloseTime) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (_this6.isCanceledError(error)) {\n        // It's a canceled error, don't display an error.\n        return null;\n      }\n      const message = _this6.getErrorMessage(error, needsTranslate);\n      if (message === null) {\n        // Message doesn't need to be displayed, stop.\n        return null;\n      }\n      const alertOptions = {\n        message\n      };\n      if (_this6.isNetworkError(message, error)) {\n        alertOptions.cssClass = 'core-alert-network-error';\n      }\n      if (typeof error !== 'string' && 'title' in error && error.title) {\n        alertOptions.header = error.title || undefined;\n      } else if (message === Translate.instant('core.sitenotfoundhelp')) {\n        alertOptions.header = Translate.instant('core.cannotconnect');\n      } else if (_this6.isSiteUnavailableError(message)) {\n        alertOptions.header = CoreSites.isLoggedIn() ? Translate.instant('core.connectionlost') : Translate.instant('core.cannotconnect');\n      } else {\n        alertOptions.header = Translate.instant('core.error');\n      }\n      if (typeof error !== 'string' && 'buttons' in error && typeof error.buttons !== 'undefined') {\n        alertOptions.buttons = error.buttons;\n      } else if (error instanceof CoreSiteError) {\n        if (error.errorDetails) {\n          alertOptions.message = `<p>${alertOptions.message}</p><div class=\"core-error-info-container\"></div>`;\n        }\n        const supportConfig = error.supportConfig;\n        alertOptions.buttons = [Translate.instant('core.ok')];\n        if (supportConfig !== null && supportConfig !== void 0 && supportConfig.canContactSupport()) {\n          alertOptions.buttons.push({\n            text: Translate.instant('core.contactsupport'),\n            handler: () => CoreUserSupport.contact({\n              supportConfig,\n              subject: alertOptions.header,\n              message: `${error.errorcode}\\n\\n${error.errorDetails}`\n            })\n          });\n        }\n      } else {\n        alertOptions.buttons = [Translate.instant('core.ok')];\n      }\n      const alertElement = yield _this6.showAlertWithOptions(alertOptions, autocloseTime);\n      if (error instanceof CoreSiteError && error.errorDetails) {\n        const containerElement = alertElement.querySelector('.core-error-info-container');\n        if (containerElement) {\n          containerElement.innerHTML = CoreErrorInfoComponent.render(error.errorDetails, error.errorcode);\n        }\n      }\n      return alertElement;\n    })();\n  }\n  /**\n   * Show an alert modal with an error message. It uses a default message if error is not a string.\n   *\n   * @param error Message to show.\n   * @param defaultError Message to show if the error is not a string.\n   * @param needsTranslate Whether the error needs to be translated.\n   * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n   * @returns Promise resolved with the alert modal.\n   */\n  showErrorModalDefault(error, defaultError, needsTranslate = false, autocloseTime) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (_this7.isCanceledError(error) || _this7.isSilentError(error)) {\n        // It's a canceled or a silent error, don't display an error.\n        return null;\n      }\n      let errorMessage = error || undefined;\n      if (error && typeof error != 'string') {\n        errorMessage = CoreTextUtils.getErrorMessageFromError(error);\n      }\n      return _this7.showErrorModal(typeof errorMessage == 'string' && errorMessage && error ? error : defaultError, needsTranslate, autocloseTime);\n    })();\n  }\n  /**\n   * Show an alert modal with the first warning error message. It uses a default message if error is not a string.\n   *\n   * @param warnings Warnings returned.\n   * @param defaultError Message to show if the error is not a string.\n   * @param needsTranslate Whether the error needs to be translated.\n   * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n   * @returns Promise resolved with the alert modal.\n   */\n  showErrorModalFirstWarning(warnings, defaultError, needsTranslate, autocloseTime) {\n    return this.showErrorModalDefault(warnings === null || warnings === void 0 ? void 0 : warnings[0], defaultError, needsTranslate, autocloseTime);\n  }\n  /**\n   * Displays a loading modal window.\n   *\n   * @param text The text of the modal window. Default: core.loading.\n   * @param needsTranslate Whether the 'text' needs to be translated.\n   * @returns Loading element instance.\n   * @description\n   * Usage:\n   *     let modal = await domUtils.showModalLoading(myText);\n   *     ...\n   *     modal.dismiss();\n   */\n  showModalLoading(text, needsTranslate) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (!text) {\n        text = Translate.instant('core.loading');\n      } else if (needsTranslate) {\n        text = Translate.instant(text);\n      }\n      const loading = new CoreIonLoadingElement(text);\n      loading.onDismiss(() => {\n        const index = _this8.activeLoadingModals.indexOf(loading);\n        if (index !== -1) {\n          _this8.activeLoadingModals.splice(index, 1);\n        }\n      });\n      _this8.activeLoadingModals.push(loading);\n      yield loading.present();\n      return loading;\n    })();\n  }\n  /**\n   * Show a loading modal whilst an operation is running, and an error modal if it fails.\n   *\n   * @param text Loading dialog text.\n   * @param needsTranslate Whether the 'text' needs to be translated.\n   * @param operation Operation.\n   * @returns Operation result.\n   */\n  showOperationModals(text, needsTranslate, operation) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const modal = yield _this9.showModalLoading(text, needsTranslate);\n      try {\n        return yield operation();\n      } catch (error) {\n        CoreDomUtils.showErrorModal(error);\n        return null;\n      } finally {\n        modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Show a modal warning the user that he should use a different app.\n   *\n   * @param message The warning message.\n   * @param link Link to the app to download if any.\n   * @returns Promise resolved when done.\n   */\n  showDownloadAppNoticeModal(message, link) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const buttons = [{\n        text: Translate.instant('core.ok'),\n        role: 'cancel'\n      }];\n      if (link) {\n        buttons.push({\n          text: Translate.instant('core.download'),\n          handler: () => {\n            CoreUtils.openInBrowser(link, {\n              showBrowserWarning: false\n            });\n          }\n        });\n      }\n      const alert = yield _this10.showAlertWithOptions({\n        message: message,\n        buttons: buttons\n      });\n      const isDevice = CorePlatform.isAndroid() || CorePlatform.isIOS();\n      if (!isDevice) {\n        // Treat all anchors so they don't override the app.\n        const alertMessageEl = alert.querySelector('.alert-message');\n        alertMessageEl && _this10.treatAnchors(alertMessageEl);\n      }\n      yield alert.onDidDismiss();\n    })();\n  }\n  /**\n   * Show a prompt modal to input some data.\n   *\n   * @param message Modal message.\n   * @param header Modal header.\n   * @param placeholderOrLabel Placeholder (for textual/numeric inputs) or label (for radio/checkbox). By default, \"Password\".\n   * @param type Type of the input element. By default, password.\n   * @param buttons Buttons. If not provided or it's an object with texts, OK and Cancel buttons will be displayed.\n   * @param options Other alert options.\n   * @returns Promise resolved with the input data (true for checkbox/radio) if the user clicks OK, rejected if cancels.\n   */\n  showPrompt(message, header, placeholderOrLabel, type = 'password', buttons, options = {}) {\n    return new Promise((resolve, reject) => {\n      var _placeholderOrLabel;\n      placeholderOrLabel = (_placeholderOrLabel = placeholderOrLabel) !== null && _placeholderOrLabel !== void 0 ? _placeholderOrLabel : Translate.instant('core.login.password');\n      const isCheckbox = type === 'checkbox';\n      const isRadio = type === 'radio';\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const resolvePromise = data => {\n        if (isCheckbox) {\n          resolve(data[0]);\n        } else if (isRadio) {\n          resolve(data);\n        } else {\n          resolve(data.promptinput);\n        }\n      };\n      options.header = header;\n      options.message = message;\n      options.inputs = [{\n        name: 'promptinput',\n        placeholder: placeholderOrLabel,\n        label: placeholderOrLabel,\n        type,\n        value: isCheckbox || isRadio ? true : undefined\n      }];\n      if (Array.isArray(buttons) && buttons.length) {\n        options.buttons = buttons.map(button => _objectSpread(_objectSpread({}, button), {}, {\n          handler: data => {\n            if (!button.handler) {\n              // Just resolve the promise.\n              resolvePromise(data);\n              return;\n            }\n            button.handler(data, resolve, reject);\n          }\n        }));\n      } else {\n        // Default buttons.\n        options.buttons = [{\n          text: buttons && 'cancelText' in buttons ? buttons.cancelText : Translate.instant('core.cancel'),\n          role: 'cancel',\n          handler: () => {\n            reject();\n          }\n        }, {\n          text: buttons && 'okText' in buttons ? buttons.okText : Translate.instant('core.ok'),\n          handler: resolvePromise\n        }];\n      }\n      this.showAlertWithOptions(options);\n    });\n  }\n  /**\n   * Show a prompt modal to input a textarea.\n   *\n   * @param title Modal title.\n   * @param message Modal message.\n   * @param buttons Buttons to pass to the modal.\n   * @param placeholder Placeholder of the input element if any.\n   * @returns Promise resolved with the entered text if any.\n   */\n  showTextareaPrompt(title, message, buttons, placeholder) {\n    return _asyncToGenerator(function* () {\n      var _result$data;\n      const alert = yield AlertController.create({\n        header: title,\n        message,\n        inputs: [{\n          name: 'textarea-prompt',\n          type: 'textarea',\n          placeholder: placeholder\n        }],\n        buttons\n      });\n      yield alert.present();\n      const result = yield alert.onWillDismiss();\n      if (result.role === 'cancel') {\n        return;\n      }\n      return (_result$data = result.data) === null || _result$data === void 0 || (_result$data = _result$data.values) === null || _result$data === void 0 ? void 0 : _result$data['textarea-prompt'];\n    })();\n  }\n  /**\n   * Displays an autodimissable toast modal window.\n   *\n   * @param text The text of the toast.\n   * @param needsTranslate Whether the 'text' needs to be translated.\n   * @param duration Duration in ms of the dimissable toast.\n   * @param cssClass Class to add to the toast.\n   * @returns Toast instance.\n   */\n  showToast(text, needsTranslate, duration = ToastDuration.SHORT, cssClass = '') {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (needsTranslate) {\n        text = Translate.instant(text);\n      }\n      return _this11.showToastWithOptions({\n        message: text,\n        duration: duration,\n        position: 'bottom',\n        cssClass: cssClass\n      });\n    })();\n  }\n  /**\n   * Show toast with some options.\n   *\n   * @param options Options.\n   * @returns Promise resolved with Toast instance.\n   */\n  showToastWithOptions(options) {\n    return _asyncToGenerator(function* () {\n      var _ref5, _CoreConstants$CONFIG, _options$position;\n      // Convert some values and set default values.\n      const toastOptions = _objectSpread(_objectSpread({}, options), {}, {\n        duration: (_ref5 = (_CoreConstants$CONFIG = CoreConstants.CONFIG.toastDurations[options.duration]) !== null && _CoreConstants$CONFIG !== void 0 ? _CoreConstants$CONFIG : options.duration) !== null && _ref5 !== void 0 ? _ref5 : 2000,\n        position: (_options$position = options.position) !== null && _options$position !== void 0 ? _options$position : 'bottom'\n      });\n      const loader = yield ToastController.create(toastOptions);\n      yield loader.present();\n      return loader;\n    })();\n  }\n  /**\n   * Check if an element supports input via keyboard.\n   *\n   * @param el HTML element to check.\n   * @returns Whether it supports input using keyboard.\n   */\n  supportsInputKeyboard(el) {\n    return el && !el.disabled && (el.tagName.toLowerCase() == 'textarea' || el.tagName.toLowerCase() == 'input' && this.INPUT_SUPPORT_KEYBOARD.indexOf(el.type) != -1);\n  }\n  /**\n   * Converts HTML formatted text to DOM element(s).\n   *\n   * @param text HTML text.\n   * @returns Same text converted to HTMLCollection.\n   */\n  toDom(text) {\n    const element = this.convertToElement(text);\n    return element.children;\n  }\n  /**\n   * Treat anchors inside alert/modals.\n   *\n   * @param container The HTMLElement that can contain anchors.\n   */\n  treatAnchors(container) {\n    const anchors = Array.from(container.querySelectorAll('a'));\n    anchors.forEach(anchor => {\n      anchor.addEventListener('click', event => {\n        if (event.defaultPrevented) {\n          // Stop.\n          return;\n        }\n        const href = anchor.getAttribute('href');\n        if (href) {\n          event.preventDefault();\n          event.stopPropagation();\n          CoreUtils.openInBrowser(href);\n        }\n      });\n    });\n  }\n  /**\n   * Opens a Modal.\n   *\n   * @param options Modal Options.\n   * @returns The modal data when the modal closes.\n   */\n  openModal(options) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      var _options$component, _navSubscription;\n      const {\n          waitForDismissCompleted,\n          closeOnNavigate\n        } = options,\n        modalOptions = _objectWithoutProperties(options, _excluded);\n      const listenCloseEvents = closeOnNavigate !== null && closeOnNavigate !== void 0 ? closeOnNavigate : true; // Default to true.\n      // TODO: Improve this if we need two modals with same component open at the same time.\n      const modalId = Md5.hashAsciiStr(((_options$component = options.component) === null || _options$component === void 0 ? void 0 : _options$component.toString()) || '');\n      const modal = _this12.displayedModals[modalId] ? _this12.displayedModals[modalId] : yield ModalController.create(modalOptions);\n      let navSubscription;\n      // Get the promise before presenting to get result if modal is suddenly hidden.\n      const resultPromise = waitForDismissCompleted ? modal.onDidDismiss() : modal.onWillDismiss();\n      if (!_this12.displayedModals[modalId]) {\n        // Store the modal and remove it when dismissed.\n        _this12.displayedModals[modalId] = modal;\n        if (listenCloseEvents) {\n          // Listen navigation events to close modals.\n          navSubscription = Router.events.pipe(filter(event => event instanceof NavigationStart)).subscribe( /*#__PURE__*/_asyncToGenerator(function* () {\n            modal.dismiss();\n          }));\n        }\n        yield modal.present();\n      }\n      const result = yield resultPromise;\n      (_navSubscription = navSubscription) === null || _navSubscription === void 0 || _navSubscription.unsubscribe();\n      delete _this12.displayedModals[modalId];\n      if (result !== null && result !== void 0 && result.data) {\n        return result === null || result === void 0 ? void 0 : result.data;\n      }\n    })();\n  }\n  /**\n   * Opens a side Modal.\n   *\n   * @param options Modal Options.\n   * @returns The modal data when the modal closes.\n   */\n  openSideModal(options) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      options = Object.assign({\n        cssClass: 'core-modal-lateral',\n        showBackdrop: true,\n        backdropDismiss: true,\n        enterAnimation: CoreModalLateralTransitionEnter,\n        leaveAnimation: CoreModalLateralTransitionLeave\n      }, options);\n      return _this13.openModal(options);\n    })();\n  }\n  /**\n   * Opens a popover.\n   *\n   * @param options Options.\n   * @returns Promise resolved when the popover is dismissed or will be dismissed.\n   */\n  openPopover(options) {\n    return _asyncToGenerator(function* () {\n      const {\n          waitForDismissCompleted\n        } = options,\n        popoverOptions = _objectWithoutProperties(options, _excluded2);\n      const popover = yield PopoverController.create(popoverOptions);\n      const zoomLevel = yield CoreConfig.get(CoreConstants.SETTINGS_ZOOM_LEVEL, CoreConstants.CONFIG.defaultZoomLevel);\n      yield popover.present();\n      // Fix popover position if zoom is applied.\n      if (zoomLevel !== \"none\" /* CoreZoomLevel.NONE */) {\n        switch (getMode()) {\n          case 'ios':\n            fixIOSPopoverPosition(popover, options.event);\n            break;\n          case 'md':\n            fixMDPopoverPosition(popover, options.event);\n            break;\n        }\n      }\n      const result = waitForDismissCompleted ? yield popover.onDidDismiss() : yield popover.onWillDismiss();\n      if (result !== null && result !== void 0 && result.data) {\n        return result === null || result === void 0 ? void 0 : result.data;\n      }\n    })();\n  }\n  /**\n   * Prompts password to the user and returns the entered text.\n   *\n   * @param passwordParams Params to show the modal.\n   * @returns Entered password, error and validation.\n   */\n  promptPassword(passwordParams) {\n    return _asyncToGenerator(function* () {\n      const {\n        CorePasswordModalComponent\n      } = yield import('@/core/components/password-modal/password-modal.module');\n      const modalData = yield CoreDomUtils.openModal({\n        cssClass: 'core-password-modal',\n        showBackdrop: true,\n        backdropDismiss: true,\n        component: CorePasswordModalComponent,\n        componentProps: passwordParams\n      });\n      if (modalData === undefined) {\n        throw new CoreCanceledError();\n      } else if (modalData instanceof CoreWSError) {\n        throw modalData;\n      }\n      return modalData;\n    })();\n  }\n  /**\n   * View an image in a modal.\n   *\n   * @param image URL of the image.\n   * @param title Title of the page or modal.\n   * @param component Component to link the image to if needed.\n   * @param componentId An ID to use in conjunction with the component.\n   */\n  viewImage(image, title, component, componentId) {\n    return _asyncToGenerator(function* () {\n      if (!image) {\n        return;\n      }\n      yield CoreDomUtils.openModal({\n        component: CoreViewerImageComponent,\n        componentProps: {\n          title,\n          image,\n          component,\n          componentId\n        },\n        cssClass: 'core-modal-transparent'\n      });\n    })();\n  }\n  /**\n   * Wait for images to load.\n   *\n   * @param element The element to search in.\n   * @returns Promise resolved with a boolean: whether there was any image to load.\n   */\n  waitForImages(element) {\n    const imgs = Array.from(element.querySelectorAll('img'));\n    if (imgs.length === 0) {\n      return CoreCancellablePromise.resolve(false);\n    }\n    let completedImages = 0;\n    let waitedForImages = false;\n    const listeners = new WeakMap();\n    const imageCompleted = resolve => {\n      completedImages++;\n      if (completedImages === imgs.length) {\n        resolve(waitedForImages);\n      }\n    };\n    return new CoreCancellablePromise(resolve => {\n      for (const img of imgs) {\n        if (!img || img.complete) {\n          imageCompleted(resolve);\n          continue;\n        }\n        waitedForImages = true;\n        // Wait for image to load or fail.\n        const imgCompleted = () => {\n          img.removeEventListener('load', imgCompleted);\n          img.removeEventListener('error', imgCompleted);\n          imageCompleted(resolve);\n        };\n        img.addEventListener('load', imgCompleted);\n        img.addEventListener('error', imgCompleted);\n        listeners.set(img, imgCompleted);\n      }\n    }, () => {\n      imgs.forEach(img => {\n        const listener = listeners.get(img);\n        if (!listener) {\n          return;\n        }\n        img.removeEventListener('load', listener);\n        img.removeEventListener('error', listener);\n      });\n    });\n  }\n  /**\n   * Wrap an HTMLElement with another element.\n   *\n   * @param el The element to wrap.\n   * @param wrapper Wrapper.\n   */\n  wrapElement(el, wrapper) {\n    var _el$parentNode;\n    // Insert the wrapper before the element.\n    (_el$parentNode = el.parentNode) === null || _el$parentNode === void 0 || _el$parentNode.insertBefore(wrapper, el);\n    // Now move the element into the wrapper.\n    wrapper.appendChild(el);\n  }\n  /**\n   * In iOS the resize event is triggered before the window size changes. Wait for the size to change.\n   * Use of this function is discouraged. Please use CoreDom.onWindowResize to check window resize event.\n   *\n   * @param windowWidth Initial window width.\n   * @param windowHeight Initial window height.\n   * @param retries Number of retries done.\n   * @returns Promise resolved when done.\n   */\n  waitForResizeDone(windowWidth, windowHeight, retries = 0) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (!CorePlatform.isIOS()) {\n        return; // Only wait in iOS.\n      }\n\n      windowWidth = windowWidth || window.innerWidth;\n      windowHeight = windowHeight || window.innerHeight;\n      if (windowWidth != window.innerWidth || windowHeight != window.innerHeight || retries >= 10) {\n        // Window size changed or max number of retries reached, stop.\n        return;\n      }\n      // Wait a bit and try again.\n      yield CoreUtils.wait(50);\n      return _this14.waitForResizeDone(windowWidth, windowHeight, retries + 1);\n    })();\n  }\n  /**\n   * Check whether a CSS class indicating an app mode is set.\n   *\n   * @param className Class name.\n   * @returns Whether the CSS class is set.\n   */\n  hasModeClass(className) {\n    return document.documentElement.classList.contains(className);\n  }\n  /**\n   * Get active mode CSS classes.\n   *\n   * @returns Mode classes.\n   */\n  getModeClasses() {\n    return Array.from(document.documentElement.classList);\n  }\n  /**\n   * Toggle a CSS class in the root element used to indicate app modes.\n   *\n   * @param className Class name.\n   * @param enable Whether to add or remove the class.\n   * @param options Legacy options, deprecated since 4.1.\n   */\n  toggleModeClass(className, enable = false, options = {\n    includeLegacy: false\n  }) {\n    document.documentElement.classList.toggle(className, enable);\n    // @deprecated since 4.1.\n    document.body.classList.toggle(className, enable && options.includeLegacy);\n  }\n}\n/**\n * Fix the position of a popover that was created with a zoom level applied in iOS.\n *\n * This is necessary because Ionic's implementation gets the body dimensions from `element.ownerDocument.defaultView.innerXXX`,\n * which doesn't return the correct dimensions when the `zoom` CSS property is being used. This is specially necessary\n * in iOS because Android already respects system font sizes. Eventually, we should find an alternative implementation for iOS\n * that doesn't require this workaround (also because the `zoom` CSS property is not standard and its usage is discouraged for\n * production).\n *\n * This function has been copied in its entirety from Ionic's source code, only changing the aforementioned calculation\n * of the body dimensions with `document.body.clientXXX`.\n *\n * @see https://github.com/ionic-team/ionic-framework/blob/v5.6.6/core/src/components/popover/animations/ios.enter.ts\n */\n_class = CoreDomUtilsProvider;\n_class.fac = function CoreDomUtilsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.prov = /*@__PURE__*/i0.defineInjectable({\n  token: _class,\n  factory: _class.fac,\n  providedIn: 'root'\n});\nfunction fixIOSPopoverPosition(baseEl, ev) {\n  let originY = 'top';\n  let originX = 'left';\n  const POPOVER_IOS_BODY_PADDING = 5;\n  const contentEl = baseEl.querySelector('.popover-content');\n  const contentDimentions = contentEl.getBoundingClientRect();\n  const contentWidth = contentDimentions.width;\n  const contentHeight = contentDimentions.height;\n  const bodyWidth = document.body.clientWidth;\n  const bodyHeight = document.body.clientHeight;\n  const targetDim = ev && ev.target && ev.target.getBoundingClientRect();\n  const targetTop = targetDim != null && 'top' in targetDim ? targetDim.top : bodyHeight / 2 - contentHeight / 2;\n  const targetLeft = targetDim != null && 'left' in targetDim ? targetDim.left : bodyWidth / 2;\n  const targetWidth = targetDim && targetDim.width || 0;\n  const targetHeight = targetDim && targetDim.height || 0;\n  const arrowEl = baseEl.querySelector('.popover-arrow');\n  const arrowDim = arrowEl.getBoundingClientRect();\n  const arrowWidth = arrowDim.width;\n  const arrowHeight = arrowDim.height;\n  if (targetDim == null) {\n    arrowEl.style.display = 'none';\n  }\n  const arrowCSS = {\n    top: targetTop + targetHeight,\n    left: targetLeft + targetWidth / 2 - arrowWidth / 2\n  };\n  const popoverCSS = {\n    top: targetTop + targetHeight + (arrowHeight - 1),\n    left: targetLeft + targetWidth / 2 - contentWidth / 2\n  };\n  let checkSafeAreaLeft = false;\n  let checkSafeAreaRight = false;\n  if (popoverCSS.left < POPOVER_IOS_BODY_PADDING + 25) {\n    checkSafeAreaLeft = true;\n    popoverCSS.left = POPOVER_IOS_BODY_PADDING;\n  } else if (contentWidth + POPOVER_IOS_BODY_PADDING + popoverCSS.left + 25 > bodyWidth) {\n    checkSafeAreaRight = true;\n    popoverCSS.left = bodyWidth - contentWidth - POPOVER_IOS_BODY_PADDING;\n    originX = 'right';\n  }\n  if (targetTop + targetHeight + contentHeight > bodyHeight && targetTop - contentHeight > 0) {\n    arrowCSS.top = targetTop - (arrowHeight + 1);\n    popoverCSS.top = targetTop - contentHeight - (arrowHeight - 1);\n    baseEl.className = baseEl.className + ' popover-bottom';\n    originY = 'bottom';\n  } else if (targetTop + targetHeight + contentHeight > bodyHeight) {\n    contentEl.style.bottom = POPOVER_IOS_BODY_PADDING + '%';\n  }\n  arrowEl.style.top = arrowCSS.top + 'px';\n  arrowEl.style.left = arrowCSS.left + 'px';\n  contentEl.style.top = popoverCSS.top + 'px';\n  contentEl.style.left = popoverCSS.left + 'px';\n  if (checkSafeAreaLeft) {\n    contentEl.style.left = `calc(${popoverCSS.left}px + var(--ion-safe-area-left, 0px))`;\n  }\n  if (checkSafeAreaRight) {\n    contentEl.style.left = `calc(${popoverCSS.left}px - var(--ion-safe-area-right, 0px))`;\n  }\n  contentEl.style.transformOrigin = originY + ' ' + originX;\n}\n/**\n * Fix the position of a popover that was created with a zoom level applied in Android.\n *\n * This is necessary because Ionic's implementation gets the body dimensions from `element.ownerDocument.defaultView.innerXXX`,\n * which doesn't return the correct dimensions when the `zoom` CSS property is being used. This is only a temporary solution\n * in Android because system zooming is already supported, so it won't be necessary to do it at an app level.\n *\n * @todo MOBILE-3790 remove the ability to zoom in Android.\n *\n * This function has been copied in its entirety from Ionic's source code, only changing the aforementioned calculation\n * of the body dimensions with `document.body.clientXXX`.\n *\n * @see https://github.com/ionic-team/ionic-framework/blob/v5.6.6/core/src/components/popover/animations/md.enter.ts\n */\nfunction fixMDPopoverPosition(baseEl, ev) {\n  const POPOVER_MD_BODY_PADDING = 12;\n  const isRTL = document.dir === 'rtl';\n  let originY = 'top';\n  let originX = isRTL ? 'right' : 'left';\n  const contentEl = baseEl.querySelector('.popover-content');\n  const contentDimentions = contentEl.getBoundingClientRect();\n  const contentWidth = contentDimentions.width;\n  const contentHeight = contentDimentions.height;\n  const bodyWidth = document.body.clientWidth;\n  const bodyHeight = document.body.clientHeight;\n  const targetDim = ev && ev.target && ev.target.getBoundingClientRect();\n  const targetTop = targetDim != null && 'bottom' in targetDim ? targetDim.bottom : bodyHeight / 2 - contentHeight / 2;\n  const targetLeft = targetDim != null && 'left' in targetDim ? isRTL ? targetDim.left - contentWidth + targetDim.width : targetDim.left : bodyWidth / 2 - contentWidth / 2;\n  const targetHeight = targetDim && targetDim.height || 0;\n  const popoverCSS = {\n    top: targetTop,\n    left: targetLeft\n  };\n  if (popoverCSS.left < POPOVER_MD_BODY_PADDING) {\n    popoverCSS.left = POPOVER_MD_BODY_PADDING;\n    originX = 'left';\n  } else if (contentWidth + POPOVER_MD_BODY_PADDING + popoverCSS.left > bodyWidth) {\n    popoverCSS.left = bodyWidth - contentWidth - POPOVER_MD_BODY_PADDING;\n    originX = 'right';\n  }\n  if (targetTop + targetHeight + contentHeight > bodyHeight && targetTop - contentHeight > 0) {\n    popoverCSS.top = targetTop - contentHeight - targetHeight;\n    baseEl.className = baseEl.className + ' popover-bottom';\n    originY = 'bottom';\n  } else if (targetTop + targetHeight + contentHeight > bodyHeight) {\n    contentEl.style.bottom = POPOVER_MD_BODY_PADDING + 'px';\n  }\n  contentEl.style.top = popoverCSS.top + 'px';\n  contentEl.style.left = popoverCSS.left + 'px';\n  contentEl.style.transformOrigin = originY + ' ' + originX;\n}\nexport const CoreDomUtils = makeSingleton(CoreDomUtilsProvider);\n/**\n * Vertical points for an element.\n */\nexport var VerticalPoint;\n(function (VerticalPoint) {\n  VerticalPoint[\"TOP\"] = \"top\";\n  VerticalPoint[\"MID\"] = \"mid\";\n  VerticalPoint[\"BOTTOM\"] = \"bottom\";\n})(VerticalPoint || (VerticalPoint = {}));\n/**\n * Toast duration.\n */\nexport var ToastDuration;\n(function (ToastDuration) {\n  ToastDuration[\"LONG\"] = \"long\";\n  ToastDuration[\"SHORT\"] = \"short\";\n  ToastDuration[\"STICKY\"] = \"sticky\";\n})(ToastDuration || (ToastDuration = {}));","map":{"version":3,"names":["SimpleChange","getMode","Md5","CoreApp","CoreConfig","CoreFile","CoreTextUtils","CoreUrlUtils","CoreUtils","CoreConstants","CoreIonLoadingElement","CoreCanceledError","CoreError","CoreSilentError","makeSingleton","Translate","AlertController","ToastController","PopoverController","ModalController","Router","CoreLogger","CoreNetworkError","CoreBSTooltipComponent","CoreViewerImageComponent","CoreModalLateralTransitionEnter","CoreModalLateralTransitionLeave","CoreSites","NavigationStart","filter","CoreNetwork","CoreSiteError","CoreUserSupport","CoreErrorInfoComponent","CorePlatform","CoreCancellablePromise","CoreLang","CoreWSError","CoreErrorLogs","CoreDomUtilsProvider","constructor","INSTANCE_ID_ATTR_NAME","INPUT_SUPPORT_KEYBOARD","template","document","createElement","debugDisplay","displayedAlerts","displayedModals","activeLoadingModals","logger","getInstance","init","_this","_asyncToGenerator","get","SETTINGS_DEBUG_DISPLAY","confirmDownloadSize","size","message","unknownMessage","wifiThreshold","limitedThreshold","alwaysConfirm","_this2","readableSize","bytesToSize","getAvailableBytes","_ref","availableBytes","calculateFreeSpace","isAndroid","IOS_FREE_SPACE_THRESHOLD","apply","arguments","getAvailableSpace","availableSize","MINIMUM_FREE_SPACE","instant","available","availableSpace","undefined","WIFI_DOWNLOAD_THRESHOLD","DOWNLOAD_THRESHOLD","wifiPrefix","isNetworkAccessLimited","total","showConfirm","convertToElement","html","innerHTML","content","children","createChangesFromKeyValueDiff","changes","newChanges","forEachAddedItem","item","key","previousValue","currentValue","forEachChangedItem","forEachRemovedItem","extractUrlsFromCSS","code","urls","matches","match","forEach","submatches","push","fixHtml","attrNameRegExp","fixElement","element","Array","from","attributes","attr","test","name","removeAttributeNode","focusElement","_this3","retries","componentOnReady","getInputElement","focus","activeElement","nextTick","supportsInputKeyboard","openKeyboard","wait","formatPixelsSize","indexOf","parseInt","isNaN","getContentsOfElement","selector","selected","querySelector","getHTMLElementAttribute","attribute","getAttribute","getComputedStyleMeasure","style","measure","isNetworkError","error","isSiteUnavailableError","siteUnavailableMessage","site","escapeForRegex","replace","RegExp","getErrorMessage","needsTranslate","extraInfo","errorMessage","debuginfo","escapeHTML","backtrace","replaceNewLines","console","isSilentError","getErrorMessageFromError","addErrorLog","JSON","stringify","type","time","Date","getTime","decodeHTML","isCanceledError","handleBootstrapTooltips","els","querySelectorAll","el","trigger","treated","setAttribute","addEventListener","_ref2","ev","CoreDomUtils","openPopover","component","componentProps","event","_x","isElementOutsideOfScreen","scrollEl","point","VerticalPoint","MID","elementRect","getBoundingClientRect","elementPoint","TOP","top","BOTTOM","bottom","Math","round","scrollElRect","scrollTopPos","window","innerHeight","isRichTextEditorEnabled","enabled","SETTINGS_RICH_TEXT_EDITOR","moveChildren","oldParent","newParent","prepend","movedChildren","referenceNode","firstChild","childNodes","length","child","insertBefore","removeElement","remove","removeElementFromHtml","removeAll","i","replaceClassesInElement","map","foundElements","foundElement","className","restoreSourcesInHtml","paths","anchorFn","media","currentSrc","newSrc","removeUrlParams","decodeURIComponent","currentPoster","tagName","newPoster","anchors","anchor","currentHref","newHref","getContentHeight","scrollElement","getScrollElement","clientHeight","_unused","getScrollHeight","scrollHeight","_unused2","getScrollTop","scrollTop","_unused3","setDebugDisplay","value","showAlert","header","buttonText","autocloseTime","_this4","showAlertWithOptions","buttons","options","_this5","_options$message","_CoreSites$getCurrent","hasHTMLTags","getCurrentSite","isVersionGreaterEqualThan","filterMultilang","alertId","hashAsciiStr","alert","create","Object","keys","Promise","all","slice","reverse","modal","pause","present","then","alertMessageEl","treatAnchors","onDidDismiss","resume","setTimeout","dismiss","_cancelButton$handler","cancelButton","find","button","handler","role","call","showAlertTranslated","showDeleteConfirm","translateMessage","translateArgs","resolve","reject","text","cssClass","okText","cancelText","data","showErrorModal","_this6","alertOptions","title","isLoggedIn","errorDetails","supportConfig","canContactSupport","contact","subject","errorcode","alertElement","containerElement","render","showErrorModalDefault","defaultError","_this7","showErrorModalFirstWarning","warnings","showModalLoading","_this8","loading","onDismiss","index","splice","showOperationModals","operation","_this9","showDownloadAppNoticeModal","link","_this10","openInBrowser","showBrowserWarning","isDevice","isIOS","showPrompt","placeholderOrLabel","_placeholderOrLabel","isCheckbox","isRadio","resolvePromise","promptinput","inputs","placeholder","label","isArray","_objectSpread","showTextareaPrompt","_result$data","result","onWillDismiss","values","showToast","duration","ToastDuration","SHORT","_this11","showToastWithOptions","position","_ref5","_CoreConstants$CONFIG","_options$position","toastOptions","CONFIG","toastDurations","loader","disabled","toLowerCase","toDom","container","defaultPrevented","href","preventDefault","stopPropagation","openModal","_this12","_options$component","_navSubscription","waitForDismissCompleted","closeOnNavigate","modalOptions","_objectWithoutProperties","_excluded","listenCloseEvents","modalId","toString","navSubscription","resultPromise","events","pipe","subscribe","unsubscribe","openSideModal","_this13","assign","showBackdrop","backdropDismiss","enterAnimation","leaveAnimation","popoverOptions","_excluded2","popover","zoomLevel","SETTINGS_ZOOM_LEVEL","defaultZoomLevel","fixIOSPopoverPosition","fixMDPopoverPosition","promptPassword","passwordParams","CorePasswordModalComponent","modalData","viewImage","image","componentId","waitForImages","imgs","completedImages","waitedForImages","listeners","WeakMap","imageCompleted","img","complete","imgCompleted","removeEventListener","set","listener","wrapElement","wrapper","_el$parentNode","parentNode","appendChild","waitForResizeDone","windowWidth","windowHeight","_this14","innerWidth","hasModeClass","documentElement","classList","contains","getModeClasses","toggleModeClass","enable","includeLegacy","toggle","body","_class","factory","fac","providedIn","baseEl","originY","originX","POPOVER_IOS_BODY_PADDING","contentEl","contentDimentions","contentWidth","width","contentHeight","height","bodyWidth","clientWidth","bodyHeight","targetDim","target","targetTop","targetLeft","left","targetWidth","targetHeight","arrowEl","arrowDim","arrowWidth","arrowHeight","display","arrowCSS","popoverCSS","checkSafeAreaLeft","checkSafeAreaRight","transformOrigin","POPOVER_MD_BODY_PADDING","isRTL","dir"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/utils/dom.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, SimpleChange, KeyValueChanges } from '@angular/core';\nimport { IonContent } from '@ionic/angular';\nimport { ModalOptions, PopoverOptions, AlertOptions, AlertButton, TextFieldTypes, getMode, ToastOptions } from '@ionic/core';\nimport { Md5 } from 'ts-md5';\n\nimport { CoreApp } from '@services/app';\nimport { CoreConfig } from '@services/config';\nimport { CoreFile } from '@services/file';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { CoreTextUtils, CoreTextErrorObject } from '@services/utils/text';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreIonLoadingElement } from '@classes/ion-loading';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreAnyError, CoreError } from '@classes/errors/error';\nimport { CoreSilentError } from '@classes/errors/silenterror';\nimport {\n    makeSingleton,\n    Translate,\n    AlertController,\n    ToastController,\n    PopoverController,\n    ModalController,\n    Router,\n} from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreFileSizeSum } from '@services/plugin-file-delegate';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreBSTooltipComponent } from '@components/bs-tooltip/bs-tooltip';\nimport { CoreViewerImageComponent } from '@features/viewer/components/image/image';\nimport { CoreModalLateralTransitionEnter, CoreModalLateralTransitionLeave } from '@classes/modal-lateral-transition';\nimport { CoreZoomLevel } from '@features/settings/services/settings-helper';\nimport { CoreSites } from '@services/sites';\nimport { NavigationStart } from '@angular/router';\nimport { filter } from 'rxjs/operators';\nimport { Subscription } from 'rxjs';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSiteError } from '@classes/errors/siteerror';\nimport { CoreUserSupport } from '@features/user/services/support';\nimport { CoreErrorInfoComponent } from '@components/error-info/error-info';\nimport { CorePlatform } from '@services/platform';\nimport { CoreCancellablePromise } from '@classes/cancellable-promise';\nimport { CoreLang } from '@services/lang';\nimport { CorePasswordModalParams, CorePasswordModalResponse } from '@components/password-modal/password-modal';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreErrorLogs } from '@singletons/error-logs';\n\n/*\n * \"Utils\" service with helper functions for UI, DOM elements and HTML code.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreDomUtilsProvider {\n\n    protected readonly INSTANCE_ID_ATTR_NAME = 'core-instance-id';\n\n    // List of input types that support keyboard.\n    protected readonly INPUT_SUPPORT_KEYBOARD: string[] = ['date', 'datetime', 'datetime-local', 'email', 'month', 'number',\n        'password', 'search', 'tel', 'text', 'time', 'url', 'week'];\n\n    protected template: HTMLTemplateElement = document.createElement('template'); // A template element to convert HTML to element.\n\n    protected matchesFunctionName?: string; // Name of the \"matches\" function to use when simulating a closest call.\n    protected debugDisplay = false; // Whether to display debug messages. Store it in a variable to make it synchronous.\n    protected displayedAlerts: Record<string, HTMLIonAlertElement> = {}; // To prevent duplicated alerts.\n    protected displayedModals: Record<string, HTMLIonModalElement> = {}; // To prevent duplicated modals.\n    protected activeLoadingModals: CoreIonLoadingElement[] = [];\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreDomUtilsProvider');\n\n        this.init();\n    }\n\n    /**\n     * Init some properties.\n     */\n    protected async init(): Promise<void> {\n        // Check if debug messages should be displayed.\n        const debugDisplay = await CoreConfig.get<number>(CoreConstants.SETTINGS_DEBUG_DISPLAY, 0);\n\n        this.debugDisplay = debugDisplay != 0;\n    }\n\n    /**\n     * If the download size is higher than a certain threshold shows a confirm dialog.\n     *\n     * @param size Object containing size to download and a boolean to indicate if its totally or partialy calculated.\n     * @param message Code of the message to show. Default: 'core.course.confirmdownload'.\n     * @param unknownMessage ID of the message to show if size is unknown.\n     * @param wifiThreshold Threshold to show confirm in WiFi connection. Default: CoreWifiDownloadThreshold.\n     * @param limitedThreshold Threshold to show confirm in limited connection. Default: CoreDownloadThreshold.\n     * @param alwaysConfirm True to show a confirm even if the size isn't high, false otherwise.\n     * @returns Promise resolved when the user confirms or if no confirm needed.\n     */\n    async confirmDownloadSize(\n        size: CoreFileSizeSum,\n        message?: string,\n        unknownMessage?: string,\n        wifiThreshold?: number,\n        limitedThreshold?: number,\n        alwaysConfirm?: boolean,\n    ): Promise<void> {\n        const readableSize = CoreTextUtils.bytesToSize(size.size, 2);\n\n        const getAvailableBytes = async (): Promise<number | null> => {\n            const availableBytes = await CoreFile.calculateFreeSpace();\n\n            if (CorePlatform.isAndroid()) {\n                return availableBytes;\n            } else {\n                // Space calculation is not accurate on iOS, but it gets more accurate when space is lower.\n                // We'll only use it when space is <500MB, or we're downloading more than twice the reported space.\n                if (availableBytes < CoreConstants.IOS_FREE_SPACE_THRESHOLD || size.size > availableBytes / 2) {\n                    return availableBytes;\n                } else {\n                    return null;\n                }\n            }\n        };\n\n        const getAvailableSpace = (availableBytes: number | null): string => {\n            if (availableBytes === null) {\n                return '';\n            } else {\n                const availableSize = CoreTextUtils.bytesToSize(availableBytes, 2);\n\n                if (CorePlatform.isAndroid() && size.size > availableBytes - CoreConstants.MINIMUM_FREE_SPACE) {\n                    throw new CoreError(\n                        Translate.instant(\n                            'core.course.insufficientavailablespace',\n                            { size: readableSize },\n                        ),\n                    );\n                }\n\n                return Translate.instant('core.course.availablespace', { available: availableSize });\n            }\n        };\n\n        const availableBytes = await getAvailableBytes();\n\n        const availableSpace = getAvailableSpace(availableBytes);\n\n        wifiThreshold = wifiThreshold === undefined ? CoreConstants.WIFI_DOWNLOAD_THRESHOLD : wifiThreshold;\n        limitedThreshold = limitedThreshold === undefined ? CoreConstants.DOWNLOAD_THRESHOLD : limitedThreshold;\n\n        let wifiPrefix = '';\n        if (CoreNetwork.isNetworkAccessLimited()) {\n            wifiPrefix = Translate.instant('core.course.confirmlimiteddownload');\n        }\n\n        if (size.size < 0 || (size.size == 0 && !size.total)) {\n            // Seems size was unable to be calculated. Show a warning.\n            unknownMessage = unknownMessage || 'core.course.confirmdownloadunknownsize';\n\n            return this.showConfirm(\n                wifiPrefix + Translate.instant(\n                    unknownMessage,\n                    { availableSpace: availableSpace },\n                ),\n            );\n        } else if (!size.total) {\n            // Filesize is only partial.\n\n            return this.showConfirm(\n                wifiPrefix + Translate.instant(\n                    'core.course.confirmpartialdownloadsize',\n                    { size: readableSize, availableSpace: availableSpace },\n                ),\n            );\n        } else if (alwaysConfirm || size.size >= wifiThreshold ||\n                (CoreNetwork.isNetworkAccessLimited() && size.size >= limitedThreshold)) {\n            message = message || (size.size === 0 ? 'core.course.confirmdownloadzerosize' : 'core.course.confirmdownload');\n\n            return this.showConfirm(\n                wifiPrefix + Translate.instant(\n                    message,\n                    { size: readableSize, availableSpace: availableSpace },\n                ),\n            );\n        }\n    }\n\n    /**\n     * Convert some HTML as text into an HTMLElement. This HTML is put inside a div or a body.\n     *\n     * @param html Text to convert.\n     * @returns Element.\n     */\n    convertToElement(html: string): HTMLElement {\n        // Add a div to hold the content, that's the element that will be returned.\n        this.template.innerHTML = '<div>' + html + '</div>';\n\n        return <HTMLElement> this.template.content.children[0];\n    }\n\n    /**\n     * Given a list of changes for a component input detected by a KeyValueDiffers, create an object similar to the one\n     * passed to the ngOnChanges functions.\n     *\n     * @param changes Changes detected by KeyValueDiffer.\n     * @returns Changes in a format like ngOnChanges.\n     */\n    createChangesFromKeyValueDiff(changes: KeyValueChanges<string, unknown>): { [name: string]: SimpleChange } {\n        const newChanges: { [name: string]: SimpleChange } = {};\n\n        // Added items are considered first change.\n        changes.forEachAddedItem((item) => {\n            newChanges[item.key] = new SimpleChange(item.previousValue, item.currentValue, true);\n        });\n\n        // Changed or removed items aren't first change.\n        changes.forEachChangedItem((item) => {\n            newChanges[item.key] = new SimpleChange(item.previousValue, item.currentValue, false);\n        });\n        changes.forEachRemovedItem((item) => {\n            newChanges[item.key] = new SimpleChange(item.previousValue, item.currentValue, true);\n        });\n\n        return newChanges;\n    }\n\n    /**\n     * Search all the URLs in a CSS file content.\n     *\n     * @param code CSS code.\n     * @returns List of URLs.\n     */\n    extractUrlsFromCSS(code: string): string[] {\n        // First of all, search all the url(...) occurrences that don't include \"data:\".\n        const urls: string[] = [];\n        const matches = code.match(/url\\(\\s*[\"']?(?!data:)([^)]+)\\)/igm);\n\n        if (!matches) {\n            return urls;\n        }\n\n        // Extract the URL from each match.\n        matches.forEach((match) => {\n            const submatches = match.match(/url\\(\\s*['\"]?([^'\"]*)['\"]?\\s*\\)/im);\n            if (submatches?.[1]) {\n                urls.push(submatches[1]);\n            }\n        });\n\n        return urls;\n    }\n\n    /**\n     * Fix syntax errors in HTML.\n     *\n     * @param html HTML text.\n     * @returns Fixed HTML text.\n     */\n    fixHtml(html: string): string {\n        this.template.innerHTML = html;\n\n        // eslint-disable-next-line no-control-regex\n        const attrNameRegExp = /[^\\x00-\\x20\\x7F-\\x9F\"'>/=]+/;\n        const fixElement = (element: Element): void => {\n            // Remove attributes with an invalid name.\n            Array.from(element.attributes).forEach((attr) => {\n                if (!attrNameRegExp.test(attr.name)) {\n                    element.removeAttributeNode(attr);\n                }\n            });\n\n            Array.from(element.children).forEach(fixElement);\n        };\n\n        Array.from(this.template.content.children).forEach(fixElement);\n\n        return this.template.innerHTML;\n    }\n\n    /**\n     * Focus an element and open keyboard.\n     *\n     * @param element HTML element to focus.\n     */\n    async focusElement(\n        element: HTMLIonInputElement | HTMLIonTextareaElement | HTMLIonSearchbarElement | HTMLElement,\n    ): Promise<void> {\n        let retries = 10;\n\n        let focusElement = element;\n\n        if ('getInputElement' in focusElement) {\n            // If it's an Ionic element get the right input to use.\n            focusElement.componentOnReady && await focusElement.componentOnReady();\n            focusElement = await focusElement.getInputElement();\n        }\n\n        if (!focusElement || !focusElement.focus) {\n            throw new CoreError('Element to focus cannot be focused');\n        }\n\n        while (retries > 0 && focusElement !== document.activeElement) {\n            focusElement.focus();\n\n            if (focusElement === document.activeElement) {\n                await CoreUtils.nextTick();\n                if (CorePlatform.isAndroid() && this.supportsInputKeyboard(focusElement)) {\n                    // On some Android versions the keyboard doesn't open automatically.\n                    CoreApp.openKeyboard();\n                }\n                break;\n            }\n\n            // @TODO Probably a Mutation Observer would get this working.\n            await CoreUtils.wait(50);\n            retries--;\n        }\n    }\n\n    /**\n     * Formats a size to be used as width/height of an element.\n     * If the size is already valid (like '500px' or '50%') it won't be modified.\n     * Returned size will have a format like '500px'.\n     *\n     * @param size Size to format.\n     * @returns Formatted size. If size is not valid, returns an empty string.\n     */\n    formatPixelsSize(size: string | number): string {\n        if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1 || size == 'auto' || size == 'initial')) {\n            // It seems to be a valid size.\n            return size;\n        }\n\n        if (typeof size == 'string') {\n            // It's important to use parseInt instead of Number because Number('') is 0 instead of NaN.\n            size = parseInt(size, 10);\n        }\n\n        if (!isNaN(size)) {\n            return size + 'px';\n        }\n\n        return '';\n    }\n\n    /**\n     * Returns the contents of a certain selection in a DOM element.\n     *\n     * @param element DOM element to search in.\n     * @param selector Selector to search.\n     * @returns Selection contents. Undefined if not found.\n     */\n    getContentsOfElement(element: HTMLElement, selector: string): string | undefined {\n        const selected = element.querySelector(selector);\n        if (selected) {\n            return selected.innerHTML;\n        }\n    }\n\n    /**\n     * Returns the attribute value of a string element. Only the first element will be selected.\n     *\n     * @param html HTML element in string.\n     * @param attribute Attribute to get.\n     * @returns Attribute value.\n     */\n    getHTMLElementAttribute(html: string, attribute: string): string | null {\n        return this.convertToElement(html).children[0].getAttribute(attribute);\n    }\n\n    /**\n     * Returns the computed style measure or 0 if not found or NaN.\n     *\n     * @param style Style from getComputedStyle.\n     * @param measure Measure to get.\n     * @returns Result of the measure.\n     */\n    getComputedStyleMeasure(style: CSSStyleDeclaration, measure: string): number {\n        return parseInt(style[measure], 10) || 0;\n    }\n\n    /**\n     * Given a message, it deduce if it's a network error.\n     *\n     * @param message Message text.\n     * @param error Error object.\n     * @returns True if the message error is a network error, false otherwise.\n     */\n    protected isNetworkError(message: string, error?: CoreError | CoreTextErrorObject | string): boolean {\n        return message == Translate.instant('core.networkerrormsg') ||\n            message == Translate.instant('core.fileuploader.errormustbeonlinetoupload') ||\n            error instanceof CoreNetworkError;\n    }\n\n    /**\n     * Given a message, check if it's a site unavailable error.\n     *\n     * @param message Message text.\n     * @returns Whether the message is a site unavailable error.\n     */\n    protected isSiteUnavailableError(message: string): boolean {\n        let siteUnavailableMessage = Translate.instant('core.siteunavailablehelp', { site: 'SITEURLPLACEHOLDER' });\n        siteUnavailableMessage = CoreTextUtils.escapeForRegex(siteUnavailableMessage);\n        siteUnavailableMessage = siteUnavailableMessage.replace('SITEURLPLACEHOLDER', '.*');\n\n        return new RegExp(siteUnavailableMessage).test(message);\n    }\n\n    /**\n     * Get the error message from an error, including debug data if needed.\n     *\n     * @param error Message to show.\n     * @param needsTranslate Whether the error needs to be translated.\n     * @returns Error message, null if no error should be displayed.\n     */\n    getErrorMessage(error: CoreError | CoreTextErrorObject | string, needsTranslate?: boolean): string | null {\n        if (typeof error != 'string' && !error) {\n            return null;\n        }\n\n        let extraInfo = '';\n        let errorMessage: string | undefined;\n\n        if (typeof error == 'object') {\n            if (this.debugDisplay) {\n                // Get the debug info. Escape the HTML so it is displayed as it is in the view.\n                if ('debuginfo' in error && error.debuginfo) {\n                    extraInfo = '<br><br>' + CoreTextUtils.escapeHTML(error.debuginfo, false);\n                }\n                if ('backtrace' in error && error.backtrace) {\n                    extraInfo += '<br><br>' + CoreTextUtils.replaceNewLines(\n                        CoreTextUtils.escapeHTML(error.backtrace, false),\n                        '<br>',\n                    );\n                }\n\n                // eslint-disable-next-line no-console\n                console.error(error);\n            }\n\n            if (this.isSilentError(error)) {\n                // It's a silent error, don't display an error.\n                return null;\n            }\n\n            // We received an object instead of a string. Search for common properties.\n            errorMessage = CoreTextUtils.getErrorMessageFromError(error);\n            CoreErrorLogs.addErrorLog({ message: JSON.stringify(error), type: errorMessage || '', time: new Date().getTime() });\n            if (!errorMessage) {\n                // No common properties found, just stringify it.\n                errorMessage = JSON.stringify(error);\n                extraInfo = ''; // No need to add extra info because it's already in the error.\n            }\n\n            // Try to remove tokens from the contents.\n            const matches = errorMessage.match(/token\"?[=|:]\"?(\\w*)/);\n            if (matches?.[1]) {\n                errorMessage = errorMessage.replace(new RegExp(matches[1], 'g'), 'secret');\n            }\n        } else {\n            errorMessage = error;\n        }\n\n        let message = CoreTextUtils.decodeHTML(needsTranslate ? Translate.instant(errorMessage) : errorMessage);\n\n        if (extraInfo) {\n            message += extraInfo;\n        }\n\n        return message;\n    }\n\n    /**\n     * Check whether an error is an error caused because the user canceled a showConfirm.\n     *\n     * @param error Error to check.\n     * @returns Whether it's a canceled error.\n     */\n    isCanceledError(error: CoreAnyError): boolean {\n        return error instanceof CoreCanceledError;\n    }\n\n    /**\n     * Check whether an error is an error caused because the user canceled a showConfirm.\n     *\n     * @param error Error to check.\n     * @returns Whether it's a canceled error.\n     */\n    isSilentError(error: CoreAnyError): boolean {\n        return error instanceof CoreSilentError;\n    }\n\n    /**\n     * Handle bootstrap tooltips in a certain element.\n     *\n     * @param element Element to check.\n     */\n    handleBootstrapTooltips(element: HTMLElement): void {\n        const els = Array.from(element.querySelectorAll('[data-toggle=\"tooltip\"]'));\n\n        els.forEach((el) => {\n            const content = el.getAttribute('title') || el.getAttribute('data-original-title');\n            const trigger = el.getAttribute('data-trigger') || 'hover focus';\n            const treated = el.getAttribute('data-bstooltip-treated');\n\n            if (!content || treated === 'true' ||\n                    (trigger.indexOf('hover') == -1 && trigger.indexOf('focus') == -1 && trigger.indexOf('click') == -1)) {\n                return;\n            }\n\n            el.setAttribute('data-bstooltip-treated', 'true'); // Mark it as treated.\n\n            // Store the title in data-original-title instead of title, like BS does.\n            el.setAttribute('data-original-title', content);\n            el.setAttribute('title', '');\n\n            el.addEventListener('click', async (ev: Event) => {\n                const html = el.getAttribute('data-html');\n\n                await CoreDomUtils.openPopover({\n                    component: CoreBSTooltipComponent,\n                    componentProps: {\n                        content,\n                        html: html === 'true',\n                    },\n                    event: ev,\n                });\n            });\n        });\n    }\n\n    /**\n     * Check if an element is outside of screen (viewport).\n     *\n     * @param scrollEl The element that must be scrolled.\n     * @param element DOM element to check.\n     * @param point The point of the element to check.\n     * @returns Whether the element is outside of the viewport.\n     */\n    isElementOutsideOfScreen(\n        scrollEl: HTMLElement,\n        element: HTMLElement,\n        point: VerticalPoint = VerticalPoint.MID,\n    ): boolean {\n        const elementRect = element.getBoundingClientRect();\n\n        if (!elementRect) {\n            return false;\n        }\n\n        let elementPoint: number;\n        switch (point) {\n            case VerticalPoint.TOP:\n                elementPoint = elementRect.top;\n                break;\n\n            case VerticalPoint.BOTTOM:\n                elementPoint = elementRect.bottom;\n                break;\n\n            case VerticalPoint.MID:\n                elementPoint = Math.round((elementRect.bottom + elementRect.top) / 2);\n                break;\n        }\n\n        const scrollElRect = scrollEl.getBoundingClientRect();\n        const scrollTopPos = scrollElRect?.top || 0;\n\n        return elementPoint > window.innerHeight || elementPoint < scrollTopPos;\n    }\n\n    /**\n     * Check if rich text editor is enabled.\n     *\n     * @returns Promise resolved with boolean: true if enabled, false otherwise.\n     */\n    async isRichTextEditorEnabled(): Promise<boolean> {\n        const enabled = await CoreConfig.get(CoreConstants.SETTINGS_RICH_TEXT_EDITOR, true);\n\n        return !!enabled;\n    }\n\n    /**\n     * Move children from one HTMLElement to another.\n     *\n     * @param oldParent The old parent.\n     * @param newParent The new parent.\n     * @param prepend If true, adds the children to the beginning of the new parent.\n     * @returns List of moved children.\n     */\n    moveChildren(oldParent: HTMLElement, newParent: HTMLElement, prepend?: boolean): Node[] {\n        const movedChildren: Node[] = [];\n        const referenceNode = prepend ? newParent.firstChild : null;\n\n        while (oldParent.childNodes.length > 0) {\n            const child = oldParent.childNodes[0];\n            movedChildren.push(child);\n\n            newParent.insertBefore(child, referenceNode);\n        }\n\n        return movedChildren;\n    }\n\n    /**\n     * Search and remove a certain element from inside another element.\n     *\n     * @param element DOM element to search in.\n     * @param selector Selector to search.\n     */\n    removeElement(element: HTMLElement, selector: string): void {\n        const selected = element.querySelector(selector);\n        if (selected) {\n            selected.remove();\n        }\n    }\n\n    /**\n     * Search and remove a certain element from an HTML code.\n     *\n     * @param html HTML code to change.\n     * @param selector Selector to search.\n     * @param removeAll True if it should remove all matches found, false if it should only remove the first one.\n     * @returns HTML without the element.\n     */\n    removeElementFromHtml(html: string, selector: string, removeAll?: boolean): string {\n        const element = this.convertToElement(html);\n\n        if (removeAll) {\n            const selected = element.querySelectorAll(selector);\n            for (let i = 0; i < selected.length; i++) {\n                selected[i].remove();\n            }\n        } else {\n            const selected = element.querySelector(selector);\n            if (selected) {\n                selected.remove();\n            }\n        }\n\n        return element.innerHTML;\n    }\n\n    /**\n     * Search for certain classes in an element contents and replace them with the specified new values.\n     *\n     * @param element DOM element.\n     * @param map Mapping of the classes to replace. Keys must be the value to replace, values must be\n     *            the new class name. Example: {'correct': 'core-question-answer-correct'}.\n     */\n    replaceClassesInElement(element: HTMLElement, map: {[currentValue: string]: string}): void {\n        for (const key in map) {\n            const foundElements = element.querySelectorAll('.' + key);\n\n            for (let i = 0; i < foundElements.length; i++) {\n                const foundElement = foundElements[i];\n                foundElement.className = foundElement.className.replace(key, map[key]);\n            }\n        }\n    }\n\n    /**\n     * Given an HTML, search all links and media and tries to restore original sources using the paths object.\n     *\n     * @param html HTML code.\n     * @param paths Object linking URLs in the html code with the real URLs to use.\n     * @param anchorFn Function to call with each anchor. Optional.\n     * @returns Treated HTML code.\n     */\n    restoreSourcesInHtml(\n        html: string,\n        paths: {[url: string]: string},\n        anchorFn?: (anchor: HTMLElement, href: string) => void,\n    ): string {\n        const element = this.convertToElement(html);\n\n        // Treat elements with src (img, audio, video, ...).\n        const media = Array.from(element.querySelectorAll<HTMLElement>('img, video, audio, source, track'));\n        media.forEach((media: HTMLElement) => {\n            const currentSrc = media.getAttribute('src');\n            const newSrc = currentSrc ?\n                paths[CoreUrlUtils.removeUrlParams(CoreTextUtils.decodeURIComponent(currentSrc))] :\n                undefined;\n\n            if (newSrc !== undefined) {\n                media.setAttribute('src', newSrc);\n            }\n\n            // Treat video posters.\n            const currentPoster = media.getAttribute('poster');\n            if (media.tagName == 'VIDEO' && currentPoster) {\n                const newPoster = paths[CoreTextUtils.decodeURIComponent(currentPoster)];\n                if (newPoster !== undefined) {\n                    media.setAttribute('poster', newPoster);\n                }\n            }\n        });\n\n        // Now treat links.\n        const anchors = Array.from(element.querySelectorAll('a'));\n        anchors.forEach((anchor: HTMLElement) => {\n            const currentHref = anchor.getAttribute('href');\n            const newHref = currentHref ?\n                paths[CoreUrlUtils.removeUrlParams(CoreTextUtils.decodeURIComponent(currentHref))] :\n                undefined;\n\n            if (newHref !== undefined) {\n                anchor.setAttribute('href', newHref);\n\n                if (typeof anchorFn == 'function') {\n                    anchorFn(anchor, newHref);\n                }\n            }\n        });\n\n        return element.innerHTML;\n    }\n\n    /**\n     * Returns height of the content.\n     *\n     * @param content Content where to execute the function.\n     * @returns Promise resolved with content height.\n     */\n    async getContentHeight(content: IonContent): Promise<number> {\n        try {\n            const scrollElement = await content.getScrollElement();\n\n            return scrollElement.clientHeight || 0;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns scroll height of the content.\n     *\n     * @param content Content where to execute the function.\n     * @returns Promise resolved with scroll height.\n     */\n    async getScrollHeight(content: IonContent): Promise<number> {\n        try {\n            const scrollElement = await content.getScrollElement();\n\n            return scrollElement.scrollHeight || 0;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns scrollTop of the content.\n     *\n     * @param content Content where to execute the function.\n     * @returns Promise resolved with scroll top.\n     */\n    async getScrollTop(content: IonContent): Promise<number> {\n        try {\n            const scrollElement = await content.getScrollElement();\n\n            return scrollElement.scrollTop || 0;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Set whether debug messages should be displayed.\n     *\n     * @param value Whether to display or not.\n     */\n    setDebugDisplay(value: boolean): void {\n        this.debugDisplay = value;\n    }\n\n    /**\n     * Show an alert modal with a button to close it.\n     *\n     * @param header Title to show.\n     * @param message Message to show.\n     * @param buttonText Text of the button.\n     * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n     * @returns Promise resolved with the alert modal.\n     */\n    async showAlert(\n        header: string | undefined,\n        message: string,\n        buttonText?: string,\n        autocloseTime?: number,\n    ): Promise<HTMLIonAlertElement> {\n        return this.showAlertWithOptions({\n            header,\n            message,\n            buttons: [buttonText || Translate.instant('core.ok')],\n        }, autocloseTime);\n    }\n\n    /**\n     * General show an alert modal.\n     *\n     * @param options Alert options to pass to the alert.\n     * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n     * @returns Promise resolved with the alert modal.\n     */\n    async showAlertWithOptions(options: AlertOptions = {}, autocloseTime?: number): Promise<HTMLIonAlertElement> {\n        let message = typeof options.message == 'string'\n            ? options.message\n            : options.message?.value || '';\n\n        const hasHTMLTags = CoreTextUtils.hasHTMLTags(message);\n\n        if (hasHTMLTags && !CoreSites.getCurrentSite()?.isVersionGreaterEqualThan('3.7')) {\n            // Treat multilang.\n            message = await CoreLang.filterMultilang(message);\n        }\n\n        options.message = message;\n\n        const alertId = Md5.hashAsciiStr((options.header || '') + '#' + (message|| ''));\n\n        if (this.displayedAlerts[alertId]) {\n            // There's already an alert with the same message and title. Return it.\n            return this.displayedAlerts[alertId];\n        }\n\n        const alert = await AlertController.create(options);\n\n        if (Object.keys(this.displayedAlerts).length === 0) {\n            await Promise.all(this.activeLoadingModals.slice(0).reverse().map(modal => modal.pause()));\n        }\n\n        // eslint-disable-next-line promise/catch-or-return\n        alert.present().then(() => {\n            if (hasHTMLTags) {\n                // Treat all anchors so they don't override the app.\n                const alertMessageEl: HTMLElement | null = alert.querySelector('.alert-message');\n                alertMessageEl && this.treatAnchors(alertMessageEl);\n            }\n\n            return;\n        });\n\n        // Store the alert and remove it when dismissed.\n        this.displayedAlerts[alertId] = alert;\n\n        // Set the callbacks to trigger an observable event.\n        // eslint-disable-next-line promise/catch-or-return\n        alert.onDidDismiss().then(async () => {\n            delete this.displayedAlerts[alertId];\n\n            // eslint-disable-next-line promise/always-return\n            if (Object.keys(this.displayedAlerts).length === 0) {\n                await Promise.all(this.activeLoadingModals.map(modal => modal.resume()));\n            }\n        });\n\n        if (autocloseTime && autocloseTime > 0) {\n            setTimeout(async () => {\n                await alert.dismiss();\n\n                if (options.buttons) {\n                    // Execute dismiss function if any.\n                    const cancelButton = <AlertButton | undefined> options.buttons.find(\n                        (button) => typeof button != 'string' && button.handler !== undefined && button.role == 'cancel',\n                    );\n                    cancelButton?.handler?.(null);\n                }\n            }, autocloseTime);\n        }\n\n        return alert;\n    }\n\n    /**\n     * Show an alert modal with a button to close it, translating the values supplied.\n     *\n     * @param header Title to show.\n     * @param message Message to show.\n     * @param buttonText Text of the button.\n     * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n     * @returns Promise resolved with the alert modal.\n     */\n    showAlertTranslated(\n        header: string | undefined,\n        message: string,\n        buttonText?: string,\n        autocloseTime?: number,\n    ): Promise<HTMLIonAlertElement> {\n        header = header ? Translate.instant(header) : header;\n        message = message ? Translate.instant(message) : message;\n        buttonText = buttonText ? Translate.instant(buttonText) : buttonText;\n\n        return this.showAlert(header, message, buttonText, autocloseTime);\n    }\n\n    /**\n     * Shortcut for a delete confirmation modal.\n     *\n     * @param translateMessage String key to show in the modal body translated. Default: 'core.areyousure'.\n     * @param translateArgs Arguments to pass to translate if necessary.\n     * @param options More options. See https://ionicframework.com/docs/v3/api/components/alert/AlertController/\n     * @returns Promise resolved if the user confirms and rejected with a canceled error if he cancels.\n     */\n    showDeleteConfirm(\n        translateMessage: string = 'core.areyousure',\n        translateArgs: Record<string, unknown> = {},\n        options: AlertOptions = {},\n    ): Promise<void> {\n        return new Promise((resolve, reject): void => {\n            options.message = Translate.instant(translateMessage, translateArgs);\n\n            options.buttons = [\n                {\n                    text: Translate.instant('core.cancel'),\n                    role: 'cancel',\n                    handler: () => {\n                        reject(new CoreCanceledError(''));\n                    },\n                },\n                {\n                    text: Translate.instant('core.delete'),\n                    role: 'destructive',\n                    handler: () => {\n                        resolve();\n                    },\n                },\n            ];\n\n            if (!options.header) {\n                options.cssClass = (options.cssClass || '') + ' core-nohead';\n            }\n\n            this.showAlertWithOptions(options, 0);\n        });\n    }\n\n    /**\n     * Show a confirm modal.\n     *\n     * @param message Message to show in the modal body.\n     * @param header Header of the modal.\n     * @param okText Text of the OK button.\n     * @param cancelText Text of the Cancel button.\n     * @param options More options.\n     * @returns Promise resolved if the user confirms and rejected with a canceled error if he cancels.\n     */\n    showConfirm<T>(\n        message: string,\n        header?: string,\n        okText?: string,\n        cancelText?: string,\n        options: AlertOptions = {},\n    ): Promise<T> {\n        return new Promise<T>((resolve, reject): void => {\n            options.header = header;\n            options.message = message;\n\n            options.buttons = [\n                {\n                    text: cancelText || Translate.instant('core.cancel'),\n                    role: 'cancel',\n                    handler: () => {\n                        reject(new CoreCanceledError(''));\n                    },\n                },\n                {\n                    text: okText || Translate.instant('core.ok'),\n                    handler: (data: T) => {\n                        resolve(data);\n                    },\n                },\n            ];\n\n            if (!header) {\n                options.cssClass = (options.cssClass || '') + ' core-nohead';\n            }\n\n            this.showAlertWithOptions(options, 0);\n        });\n    }\n\n    /**\n     * Show an alert modal with an error message.\n     *\n     * @param error Message to show.\n     * @param needsTranslate Whether the error needs to be translated.\n     * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n     * @returns Promise resolved with the alert modal.\n     */\n    async showErrorModal(\n        error: CoreError | CoreTextErrorObject | string,\n        needsTranslate?: boolean,\n        autocloseTime?: number,\n    ): Promise<HTMLIonAlertElement | null> {\n        if (this.isCanceledError(error)) {\n            // It's a canceled error, don't display an error.\n            return null;\n        }\n\n        const message = this.getErrorMessage(error, needsTranslate);\n\n        if (message === null) {\n            // Message doesn't need to be displayed, stop.\n            return null;\n        }\n\n        const alertOptions: AlertOptions = { message };\n\n        if (this.isNetworkError(message, error)) {\n            alertOptions.cssClass = 'core-alert-network-error';\n        }\n\n        if (typeof error !== 'string' && 'title' in error && error.title) {\n            alertOptions.header = error.title || undefined;\n        } else if (message === Translate.instant('core.sitenotfoundhelp')) {\n            alertOptions.header = Translate.instant('core.cannotconnect');\n        } else if (this.isSiteUnavailableError(message)) {\n            alertOptions.header = CoreSites.isLoggedIn()\n                ? Translate.instant('core.connectionlost')\n                : Translate.instant('core.cannotconnect');\n        } else {\n            alertOptions.header = Translate.instant('core.error');\n        }\n\n        if (typeof error !== 'string' && 'buttons' in error && typeof error.buttons !== 'undefined') {\n            alertOptions.buttons = error.buttons;\n        } else if (error instanceof CoreSiteError) {\n            if (error.errorDetails) {\n                alertOptions.message = `<p>${alertOptions.message}</p><div class=\"core-error-info-container\"></div>`;\n            }\n\n            const supportConfig = error.supportConfig;\n\n            alertOptions.buttons = [Translate.instant('core.ok')];\n\n            if (supportConfig?.canContactSupport()) {\n                alertOptions.buttons.push({\n                    text: Translate.instant('core.contactsupport'),\n                    handler: () => CoreUserSupport.contact({\n                        supportConfig,\n                        subject: alertOptions.header,\n                        message: `${error.errorcode}\\n\\n${error.errorDetails}`,\n                    }),\n                });\n            }\n        } else {\n            alertOptions.buttons = [Translate.instant('core.ok')];\n        }\n\n        const alertElement = await this.showAlertWithOptions(alertOptions, autocloseTime);\n\n        if (error instanceof CoreSiteError && error.errorDetails) {\n            const containerElement = alertElement.querySelector('.core-error-info-container');\n\n            if (containerElement) {\n                containerElement.innerHTML = CoreErrorInfoComponent.render(error.errorDetails, error.errorcode);\n            }\n        }\n\n        return alertElement;\n    }\n\n    /**\n     * Show an alert modal with an error message. It uses a default message if error is not a string.\n     *\n     * @param error Message to show.\n     * @param defaultError Message to show if the error is not a string.\n     * @param needsTranslate Whether the error needs to be translated.\n     * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n     * @returns Promise resolved with the alert modal.\n     */\n    async showErrorModalDefault(\n        error: CoreAnyError,\n        defaultError: string,\n        needsTranslate = false,\n        autocloseTime?: number,\n    ): Promise<HTMLIonAlertElement | null> {\n        if (this.isCanceledError(error) || this.isSilentError(error)) {\n            // It's a canceled or a silent error, don't display an error.\n            return null;\n        }\n\n        let errorMessage = error || undefined;\n\n        if (error && typeof error != 'string') {\n            errorMessage = CoreTextUtils.getErrorMessageFromError(error);\n        }\n\n        return this.showErrorModal(\n            typeof errorMessage == 'string' && errorMessage && error ? error : defaultError,\n            needsTranslate,\n            autocloseTime,\n        );\n    }\n\n    /**\n     * Show an alert modal with the first warning error message. It uses a default message if error is not a string.\n     *\n     * @param warnings Warnings returned.\n     * @param defaultError Message to show if the error is not a string.\n     * @param needsTranslate Whether the error needs to be translated.\n     * @param autocloseTime Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.\n     * @returns Promise resolved with the alert modal.\n     */\n    showErrorModalFirstWarning(\n        warnings: CoreWSExternalWarning[],\n        defaultError: string,\n        needsTranslate?: boolean,\n        autocloseTime?: number,\n    ): Promise<HTMLIonAlertElement | null> {\n        return this.showErrorModalDefault(warnings?.[0], defaultError, needsTranslate, autocloseTime);\n    }\n\n    /**\n     * Displays a loading modal window.\n     *\n     * @param text The text of the modal window. Default: core.loading.\n     * @param needsTranslate Whether the 'text' needs to be translated.\n     * @returns Loading element instance.\n     * @description\n     * Usage:\n     *     let modal = await domUtils.showModalLoading(myText);\n     *     ...\n     *     modal.dismiss();\n     */\n    async showModalLoading(text?: string, needsTranslate?: boolean): Promise<CoreIonLoadingElement> {\n        if (!text) {\n            text = Translate.instant('core.loading');\n        } else if (needsTranslate) {\n            text = Translate.instant(text);\n        }\n\n        const loading = new CoreIonLoadingElement(text);\n\n        loading.onDismiss(() => {\n            const index = this.activeLoadingModals.indexOf(loading);\n\n            if (index !== -1) {\n                this.activeLoadingModals.splice(index, 1);\n            }\n        });\n\n        this.activeLoadingModals.push(loading);\n\n        await loading.present();\n\n        return loading;\n    }\n\n    /**\n     * Show a loading modal whilst an operation is running, and an error modal if it fails.\n     *\n     * @param text Loading dialog text.\n     * @param needsTranslate Whether the 'text' needs to be translated.\n     * @param operation Operation.\n     * @returns Operation result.\n     */\n    async showOperationModals<T>(text: string, needsTranslate: boolean, operation: () => Promise<T>): Promise<T | null> {\n        const modal = await this.showModalLoading(text, needsTranslate);\n\n        try {\n            return await operation();\n        } catch (error) {\n            CoreDomUtils.showErrorModal(error);\n\n            return null;\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Show a modal warning the user that he should use a different app.\n     *\n     * @param message The warning message.\n     * @param link Link to the app to download if any.\n     * @returns Promise resolved when done.\n     */\n    async showDownloadAppNoticeModal(message: string, link?: string): Promise<void> {\n        const buttons: AlertButton[] = [{\n            text: Translate.instant('core.ok'),\n            role: 'cancel',\n        }];\n\n        if (link) {\n            buttons.push({\n                text: Translate.instant('core.download'),\n                handler: (): void => {\n                    CoreUtils.openInBrowser(link, { showBrowserWarning: false });\n                },\n            });\n        }\n\n        const alert = await this.showAlertWithOptions({\n            message: message,\n            buttons: buttons,\n        });\n\n        const isDevice = CorePlatform.isAndroid() || CorePlatform.isIOS();\n        if (!isDevice) {\n            // Treat all anchors so they don't override the app.\n            const alertMessageEl: HTMLElement | null = alert.querySelector('.alert-message');\n            alertMessageEl && this.treatAnchors(alertMessageEl);\n        }\n\n        await alert.onDidDismiss();\n    }\n\n    /**\n     * Show a prompt modal to input some data.\n     *\n     * @param message Modal message.\n     * @param header Modal header.\n     * @param placeholderOrLabel Placeholder (for textual/numeric inputs) or label (for radio/checkbox). By default, \"Password\".\n     * @param type Type of the input element. By default, password.\n     * @param buttons Buttons. If not provided or it's an object with texts, OK and Cancel buttons will be displayed.\n     * @param options Other alert options.\n     * @returns Promise resolved with the input data (true for checkbox/radio) if the user clicks OK, rejected if cancels.\n     */\n    showPrompt(\n        message: string,\n        header?: string,\n        placeholderOrLabel?: string,\n        type: TextFieldTypes | 'checkbox' | 'radio' | 'textarea' = 'password',\n        buttons?: PromptButton[] | { okText?: string; cancelText?: string },\n        options: AlertOptions = {},\n    ): Promise<any> { // eslint-disable-line @typescript-eslint/no-explicit-any\n        return new Promise((resolve, reject) => {\n            placeholderOrLabel = placeholderOrLabel ?? Translate.instant('core.login.password');\n\n            const isCheckbox = type === 'checkbox';\n            const isRadio = type === 'radio';\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const resolvePromise = (data: any) => {\n                if (isCheckbox) {\n                    resolve(data[0]);\n                } else if (isRadio) {\n                    resolve(data);\n                } else {\n                    resolve(data.promptinput);\n                }\n            };\n\n            options.header = header;\n            options.message = message;\n            options.inputs = [\n                {\n                    name: 'promptinput',\n                    placeholder: placeholderOrLabel,\n                    label: placeholderOrLabel,\n                    type,\n                    value: (isCheckbox || isRadio) ? true : undefined,\n                },\n            ];\n\n            if (Array.isArray(buttons) && buttons.length) {\n                options.buttons = buttons.map((button) => ({\n                    ...button,\n                    handler: (data) => {\n                        if (!button.handler) {\n                            // Just resolve the promise.\n                            resolvePromise(data);\n\n                            return;\n                        }\n\n                        button.handler(data, resolve, reject);\n                    },\n                }));\n            } else {\n                // Default buttons.\n                options.buttons = [\n                    {\n                        text: buttons && 'cancelText' in buttons\n                            ? buttons.cancelText as string\n                            : Translate.instant('core.cancel'),\n                        role: 'cancel',\n                        handler: () => {\n                            reject();\n                        },\n                    },\n                    {\n                        text: buttons && 'okText' in buttons\n                            ? buttons.okText as string\n                            : Translate.instant('core.ok'),\n                        handler: resolvePromise,\n                    },\n                ];\n            }\n\n            this.showAlertWithOptions(options);\n        });\n    }\n\n    /**\n     * Show a prompt modal to input a textarea.\n     *\n     * @param title Modal title.\n     * @param message Modal message.\n     * @param buttons Buttons to pass to the modal.\n     * @param placeholder Placeholder of the input element if any.\n     * @returns Promise resolved with the entered text if any.\n     */\n    async showTextareaPrompt(\n        title: string,\n        message: string,\n        buttons: AlertButton[],\n        placeholder?: string,\n    ): Promise<string | undefined> {\n        const alert = await AlertController.create({\n            header: title,\n            message,\n            inputs: [\n                {\n                    name: 'textarea-prompt',\n                    type: 'textarea',\n                    placeholder: placeholder,\n                },\n            ],\n            buttons,\n        });\n\n        await alert.present();\n\n        const result = await alert.onWillDismiss();\n\n        if (result.role === 'cancel') {\n            return;\n        }\n\n        return result.data?.values?.['textarea-prompt'];\n    }\n\n    /**\n     * Displays an autodimissable toast modal window.\n     *\n     * @param text The text of the toast.\n     * @param needsTranslate Whether the 'text' needs to be translated.\n     * @param duration Duration in ms of the dimissable toast.\n     * @param cssClass Class to add to the toast.\n     * @returns Toast instance.\n     */\n    async showToast(\n        text: string,\n        needsTranslate?: boolean,\n        duration: ToastDuration | number = ToastDuration.SHORT,\n        cssClass: string = '',\n    ): Promise<HTMLIonToastElement> {\n        if (needsTranslate) {\n            text = Translate.instant(text);\n        }\n\n        return this.showToastWithOptions({\n            message: text,\n            duration: duration,\n            position: 'bottom',\n            cssClass: cssClass,\n        });\n    }\n\n    /**\n     * Show toast with some options.\n     *\n     * @param options Options.\n     * @returns Promise resolved with Toast instance.\n     */\n    async showToastWithOptions(options: ShowToastOptions): Promise<HTMLIonToastElement> {\n        // Convert some values and set default values.\n        const toastOptions: ToastOptions = {\n            ...options,\n            duration: CoreConstants.CONFIG.toastDurations[options.duration] ?? options.duration ?? 2000,\n            position: options.position ?? 'bottom',\n        };\n\n        const loader = await ToastController.create(toastOptions);\n\n        await loader.present();\n\n        return loader;\n    }\n\n    /**\n     * Check if an element supports input via keyboard.\n     *\n     * @param el HTML element to check.\n     * @returns Whether it supports input using keyboard.\n     */\n    supportsInputKeyboard(el: HTMLElement): boolean {\n        return el &&\n            !(<HTMLInputElement> el).disabled &&\n            (el.tagName.toLowerCase() == 'textarea' ||\n                (el.tagName.toLowerCase() == 'input' && this.INPUT_SUPPORT_KEYBOARD.indexOf((<HTMLInputElement> el).type) != -1));\n    }\n\n    /**\n     * Converts HTML formatted text to DOM element(s).\n     *\n     * @param text HTML text.\n     * @returns Same text converted to HTMLCollection.\n     */\n    toDom(text: string): HTMLCollection {\n        const element = this.convertToElement(text);\n\n        return element.children;\n    }\n\n    /**\n     * Treat anchors inside alert/modals.\n     *\n     * @param container The HTMLElement that can contain anchors.\n     */\n    treatAnchors(container: HTMLElement): void {\n        const anchors = Array.from(container.querySelectorAll('a'));\n\n        anchors.forEach((anchor) => {\n            anchor.addEventListener('click', (event) => {\n                if (event.defaultPrevented) {\n                    // Stop.\n                    return;\n                }\n\n                const href = anchor.getAttribute('href');\n                if (href) {\n                    event.preventDefault();\n                    event.stopPropagation();\n\n                    CoreUtils.openInBrowser(href);\n                }\n            });\n        });\n    }\n\n    /**\n     * Opens a Modal.\n     *\n     * @param options Modal Options.\n     * @returns The modal data when the modal closes.\n     */\n    async openModal<T = unknown>(\n        options: OpenModalOptions,\n    ): Promise<T | undefined> {\n        const { waitForDismissCompleted, closeOnNavigate, ...modalOptions } = options;\n        const listenCloseEvents = closeOnNavigate ?? true; // Default to true.\n\n        // TODO: Improve this if we need two modals with same component open at the same time.\n        const modalId = <string> Md5.hashAsciiStr(options.component?.toString() || '');\n\n        const modal = this.displayedModals[modalId]\n            ? this.displayedModals[modalId]\n            : await ModalController.create(modalOptions);\n\n        let navSubscription: Subscription | undefined;\n\n        // Get the promise before presenting to get result if modal is suddenly hidden.\n        const resultPromise = waitForDismissCompleted ? modal.onDidDismiss<T>() : modal.onWillDismiss<T>();\n\n        if (!this.displayedModals[modalId]) {\n            // Store the modal and remove it when dismissed.\n            this.displayedModals[modalId] = modal;\n\n            if (listenCloseEvents) {\n                // Listen navigation events to close modals.\n                navSubscription = Router.events\n                    .pipe(filter(event => event instanceof NavigationStart))\n                    .subscribe(async () => {\n                        modal.dismiss();\n                    });\n            }\n\n            await modal.present();\n        }\n\n        const result = await resultPromise;\n\n        navSubscription?.unsubscribe();\n        delete this.displayedModals[modalId];\n\n        if (result?.data) {\n            return result?.data;\n        }\n    }\n\n    /**\n     * Opens a side Modal.\n     *\n     * @param options Modal Options.\n     * @returns The modal data when the modal closes.\n     */\n    async openSideModal<T = unknown>(\n        options: OpenModalOptions,\n    ): Promise<T | undefined> {\n\n        options = Object.assign({\n            cssClass: 'core-modal-lateral',\n            showBackdrop: true,\n            backdropDismiss: true,\n            enterAnimation: CoreModalLateralTransitionEnter,\n            leaveAnimation: CoreModalLateralTransitionLeave,\n        }, options);\n\n        return this.openModal<T>(options);\n    }\n\n    /**\n     * Opens a popover.\n     *\n     * @param options Options.\n     * @returns Promise resolved when the popover is dismissed or will be dismissed.\n     */\n    async openPopover<T = void>(options: OpenPopoverOptions): Promise<T | undefined> {\n\n        const { waitForDismissCompleted, ...popoverOptions } = options;\n        const popover = await PopoverController.create(popoverOptions);\n        const zoomLevel = await CoreConfig.get(CoreConstants.SETTINGS_ZOOM_LEVEL, CoreConstants.CONFIG.defaultZoomLevel);\n\n        await popover.present();\n\n        // Fix popover position if zoom is applied.\n        if (zoomLevel !== CoreZoomLevel.NONE) {\n            switch (getMode()) {\n                case 'ios':\n                    fixIOSPopoverPosition(popover, options.event);\n                    break;\n                case 'md':\n                    fixMDPopoverPosition(popover, options.event);\n                    break;\n            }\n        }\n\n        const result = waitForDismissCompleted ? await popover.onDidDismiss<T>() : await popover.onWillDismiss<T>();\n        if (result?.data) {\n            return result?.data;\n        }\n    }\n\n    /**\n     * Prompts password to the user and returns the entered text.\n     *\n     * @param passwordParams Params to show the modal.\n     * @returns Entered password, error and validation.\n     */\n    async promptPassword<T extends CorePasswordModalResponse>(passwordParams?: CorePasswordModalParams): Promise<T> {\n        const { CorePasswordModalComponent } =\n            await import('@/core/components/password-modal/password-modal.module');\n\n        const modalData = await CoreDomUtils.openModal<T>(\n            {\n                cssClass: 'core-password-modal',\n                showBackdrop: true,\n                backdropDismiss: true,\n                component: CorePasswordModalComponent,\n                componentProps: passwordParams,\n            },\n        );\n\n        if (modalData === undefined) {\n            throw new CoreCanceledError();\n        } else if (modalData instanceof CoreWSError) {\n            throw modalData;\n        }\n\n        return modalData;\n    }\n\n    /**\n     * View an image in a modal.\n     *\n     * @param image URL of the image.\n     * @param title Title of the page or modal.\n     * @param component Component to link the image to if needed.\n     * @param componentId An ID to use in conjunction with the component.\n     */\n    async viewImage(\n        image: string,\n        title?: string | null,\n        component?: string,\n        componentId?: string | number,\n    ): Promise<void> {\n        if (!image) {\n            return;\n        }\n\n        await CoreDomUtils.openModal({\n            component: CoreViewerImageComponent,\n            componentProps: {\n                title,\n                image,\n                component,\n                componentId,\n            },\n            cssClass: 'core-modal-transparent',\n        });\n\n    }\n\n    /**\n     * Wait for images to load.\n     *\n     * @param element The element to search in.\n     * @returns Promise resolved with a boolean: whether there was any image to load.\n     */\n    waitForImages(element: HTMLElement): CoreCancellablePromise<boolean> {\n        const imgs = Array.from(element.querySelectorAll('img'));\n\n        if (imgs.length === 0) {\n            return CoreCancellablePromise.resolve(false);\n        }\n\n        let completedImages = 0;\n        let waitedForImages = false;\n        const listeners: WeakMap<Element, () => unknown> = new WeakMap();\n        const imageCompleted = (resolve: (result: boolean) => void) => {\n            completedImages++;\n\n            if (completedImages === imgs.length) {\n                resolve(waitedForImages);\n            }\n        };\n\n        return new CoreCancellablePromise<boolean>(\n            resolve => {\n                for (const img of imgs) {\n                    if (!img || img.complete) {\n                        imageCompleted(resolve);\n\n                        continue;\n                    }\n\n                    waitedForImages = true;\n\n                    // Wait for image to load or fail.\n                    const imgCompleted = (): void => {\n                        img.removeEventListener('load', imgCompleted);\n                        img.removeEventListener('error', imgCompleted);\n\n                        imageCompleted(resolve);\n                    };\n\n                    img.addEventListener('load', imgCompleted);\n                    img.addEventListener('error', imgCompleted);\n\n                    listeners.set(img, imgCompleted);\n                }\n            },\n            () => {\n                imgs.forEach(img => {\n                    const listener = listeners.get(img);\n\n                    if (!listener) {\n                        return;\n                    }\n\n                    img.removeEventListener('load', listener);\n                    img.removeEventListener('error', listener);\n                });\n            },\n        );\n    }\n\n    /**\n     * Wrap an HTMLElement with another element.\n     *\n     * @param el The element to wrap.\n     * @param wrapper Wrapper.\n     */\n    wrapElement(el: HTMLElement, wrapper: HTMLElement): void {\n        // Insert the wrapper before the element.\n        el.parentNode?.insertBefore(wrapper, el);\n        // Now move the element into the wrapper.\n        wrapper.appendChild(el);\n    }\n\n    /**\n     * In iOS the resize event is triggered before the window size changes. Wait for the size to change.\n     * Use of this function is discouraged. Please use CoreDom.onWindowResize to check window resize event.\n     *\n     * @param windowWidth Initial window width.\n     * @param windowHeight Initial window height.\n     * @param retries Number of retries done.\n     * @returns Promise resolved when done.\n     */\n    async waitForResizeDone(windowWidth?: number, windowHeight?: number, retries = 0): Promise<void> {\n        if (!CorePlatform.isIOS()) {\n            return; // Only wait in iOS.\n        }\n\n        windowWidth = windowWidth || window.innerWidth;\n        windowHeight = windowHeight || window.innerHeight;\n\n        if (windowWidth != window.innerWidth || windowHeight != window.innerHeight || retries >= 10) {\n            // Window size changed or max number of retries reached, stop.\n            return;\n        }\n\n        // Wait a bit and try again.\n        await CoreUtils.wait(50);\n\n        return this.waitForResizeDone(windowWidth, windowHeight, retries+1);\n    }\n\n    /**\n     * Check whether a CSS class indicating an app mode is set.\n     *\n     * @param className Class name.\n     * @returns Whether the CSS class is set.\n     */\n    hasModeClass(className: string): boolean {\n        return document.documentElement.classList.contains(className);\n    }\n\n    /**\n     * Get active mode CSS classes.\n     *\n     * @returns Mode classes.\n     */\n    getModeClasses(): string[] {\n        return Array.from(document.documentElement.classList);\n    }\n\n    /**\n     * Toggle a CSS class in the root element used to indicate app modes.\n     *\n     * @param className Class name.\n     * @param enable Whether to add or remove the class.\n     * @param options Legacy options, deprecated since 4.1.\n     */\n    toggleModeClass(\n        className: string,\n        enable = false,\n        options: { includeLegacy: boolean } = { includeLegacy: false },\n    ): void {\n        document.documentElement.classList.toggle(className, enable);\n\n        // @deprecated since 4.1.\n        document.body.classList.toggle(className, enable && options.includeLegacy);\n    }\n\n}\n\n/**\n * Fix the position of a popover that was created with a zoom level applied in iOS.\n *\n * This is necessary because Ionic's implementation gets the body dimensions from `element.ownerDocument.defaultView.innerXXX`,\n * which doesn't return the correct dimensions when the `zoom` CSS property is being used. This is specially necessary\n * in iOS because Android already respects system font sizes. Eventually, we should find an alternative implementation for iOS\n * that doesn't require this workaround (also because the `zoom` CSS property is not standard and its usage is discouraged for\n * production).\n *\n * This function has been copied in its entirety from Ionic's source code, only changing the aforementioned calculation\n * of the body dimensions with `document.body.clientXXX`.\n *\n * @see https://github.com/ionic-team/ionic-framework/blob/v5.6.6/core/src/components/popover/animations/ios.enter.ts\n */\nfunction fixIOSPopoverPosition(baseEl: HTMLElement, ev?: Event): void {\n    let originY = 'top';\n    let originX = 'left';\n\n    const POPOVER_IOS_BODY_PADDING = 5;\n    const contentEl = baseEl.querySelector('.popover-content') as HTMLElement;\n    const contentDimentions = contentEl.getBoundingClientRect();\n    const contentWidth = contentDimentions.width;\n    const contentHeight = contentDimentions.height;\n    const bodyWidth = document.body.clientWidth;\n    const bodyHeight = document.body.clientHeight;\n    const targetDim = ev && ev.target && (ev.target as HTMLElement).getBoundingClientRect();\n    const targetTop = targetDim != null && 'top' in targetDim ? targetDim.top : bodyHeight / 2 - contentHeight / 2;\n    const targetLeft = targetDim != null && 'left' in targetDim ? targetDim.left : bodyWidth / 2;\n    const targetWidth = (targetDim && targetDim.width) || 0;\n    const targetHeight = (targetDim && targetDim.height) || 0;\n    const arrowEl = baseEl.querySelector('.popover-arrow') as HTMLElement;\n    const arrowDim = arrowEl.getBoundingClientRect();\n    const arrowWidth = arrowDim.width;\n    const arrowHeight = arrowDim.height;\n\n    if (targetDim == null) {\n        arrowEl.style.display = 'none';\n    }\n\n    const arrowCSS = {\n        top: targetTop + targetHeight,\n        left: targetLeft + targetWidth / 2 - arrowWidth / 2,\n    };\n\n    const popoverCSS: { top: number; left: number } = {\n        top: targetTop + targetHeight + (arrowHeight - 1),\n        left: targetLeft + targetWidth / 2 - contentWidth / 2,\n    };\n\n    let checkSafeAreaLeft = false;\n    let checkSafeAreaRight = false;\n\n    if (popoverCSS.left < POPOVER_IOS_BODY_PADDING + 25) {\n        checkSafeAreaLeft = true;\n        popoverCSS.left = POPOVER_IOS_BODY_PADDING;\n    } else if (\n        contentWidth + POPOVER_IOS_BODY_PADDING + popoverCSS.left + 25 > bodyWidth\n    ) {\n        checkSafeAreaRight = true;\n        popoverCSS.left = bodyWidth - contentWidth - POPOVER_IOS_BODY_PADDING;\n        originX = 'right';\n    }\n\n    if (targetTop + targetHeight + contentHeight > bodyHeight && targetTop - contentHeight > 0) {\n        arrowCSS.top = targetTop - (arrowHeight + 1);\n        popoverCSS.top = targetTop - contentHeight - (arrowHeight - 1);\n\n        baseEl.className = baseEl.className + ' popover-bottom';\n        originY = 'bottom';\n    } else if (targetTop + targetHeight + contentHeight > bodyHeight) {\n        contentEl.style.bottom = POPOVER_IOS_BODY_PADDING + '%';\n    }\n\n    arrowEl.style.top = arrowCSS.top + 'px';\n    arrowEl.style.left = arrowCSS.left + 'px';\n\n    contentEl.style.top = popoverCSS.top + 'px';\n    contentEl.style.left = popoverCSS.left + 'px';\n\n    if (checkSafeAreaLeft) {\n        contentEl.style.left = `calc(${popoverCSS.left}px + var(--ion-safe-area-left, 0px))`;\n    }\n\n    if (checkSafeAreaRight) {\n        contentEl.style.left = `calc(${popoverCSS.left}px - var(--ion-safe-area-right, 0px))`;\n    }\n\n    contentEl.style.transformOrigin = originY + ' ' + originX;\n}\n\n/**\n * Fix the position of a popover that was created with a zoom level applied in Android.\n *\n * This is necessary because Ionic's implementation gets the body dimensions from `element.ownerDocument.defaultView.innerXXX`,\n * which doesn't return the correct dimensions when the `zoom` CSS property is being used. This is only a temporary solution\n * in Android because system zooming is already supported, so it won't be necessary to do it at an app level.\n *\n * @todo MOBILE-3790 remove the ability to zoom in Android.\n *\n * This function has been copied in its entirety from Ionic's source code, only changing the aforementioned calculation\n * of the body dimensions with `document.body.clientXXX`.\n *\n * @see https://github.com/ionic-team/ionic-framework/blob/v5.6.6/core/src/components/popover/animations/md.enter.ts\n */\nfunction fixMDPopoverPosition(baseEl: HTMLElement, ev?: Event): void {\n    const POPOVER_MD_BODY_PADDING = 12;\n    const isRTL = document.dir === 'rtl';\n\n    let originY = 'top';\n    let originX = isRTL ? 'right' : 'left';\n\n    const contentEl = baseEl.querySelector('.popover-content') as HTMLElement;\n    const contentDimentions = contentEl.getBoundingClientRect();\n    const contentWidth = contentDimentions.width;\n    const contentHeight = contentDimentions.height;\n    const bodyWidth = document.body.clientWidth;\n    const bodyHeight = document.body.clientHeight;\n    const targetDim = ev && ev.target && (ev.target as HTMLElement).getBoundingClientRect();\n    const targetTop = targetDim != null && 'bottom' in targetDim\n        ? targetDim.bottom\n        : bodyHeight / 2 - contentHeight / 2;\n    const targetLeft = targetDim != null && 'left' in targetDim\n        ? isRTL\n            ? targetDim.left - contentWidth + targetDim.width\n            : targetDim.left\n        : bodyWidth / 2 - contentWidth / 2;\n    const targetHeight = (targetDim && targetDim.height) || 0;\n    const popoverCSS: { top: number; left: number } = {\n        top: targetTop,\n        left: targetLeft,\n    };\n\n    if (popoverCSS.left < POPOVER_MD_BODY_PADDING) {\n        popoverCSS.left = POPOVER_MD_BODY_PADDING;\n        originX = 'left';\n    } else if (contentWidth + POPOVER_MD_BODY_PADDING + popoverCSS.left > bodyWidth) {\n        popoverCSS.left = bodyWidth - contentWidth - POPOVER_MD_BODY_PADDING;\n        originX = 'right';\n    }\n\n    if (targetTop + targetHeight + contentHeight > bodyHeight && targetTop - contentHeight > 0) {\n        popoverCSS.top = targetTop - contentHeight - targetHeight;\n        baseEl.className = baseEl.className + ' popover-bottom';\n        originY = 'bottom';\n    } else if (targetTop + targetHeight + contentHeight > bodyHeight) {\n        contentEl.style.bottom = POPOVER_MD_BODY_PADDING + 'px';\n    }\n\n    contentEl.style.top = popoverCSS.top + 'px';\n    contentEl.style.left = popoverCSS.left + 'px';\n    contentEl.style.transformOrigin = originY + ' ' + originX;\n}\n\nexport const CoreDomUtils = makeSingleton(CoreDomUtilsProvider);\n\n/**\n * Options for the openPopover function.\n */\nexport type OpenPopoverOptions = Omit<PopoverOptions, 'showBackdrop'> & {\n    waitForDismissCompleted?: boolean;\n};\n\n/**\n * Options for the openModal function.\n */\nexport type OpenModalOptions = ModalOptions & {\n    waitForDismissCompleted?: boolean;\n    closeOnNavigate?: boolean; // Default true.\n};\n\n/**\n * Buttons for prompt alert.\n */\nexport type PromptButton = Omit<AlertButton, 'handler'> & {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    handler?: (value: any, resolve: (value: any) => void, reject: (reason: any) => void) => void;\n};\n\n/**\n * Vertical points for an element.\n */\nexport enum VerticalPoint {\n    TOP = 'top',\n    MID = 'mid',\n    BOTTOM = 'bottom',\n}\n\n/**\n * Toast duration.\n */\nexport enum ToastDuration {\n    LONG = 'long',\n    SHORT = 'short',\n    STICKY = 'sticky',\n}\n\n/**\n * Options for showToastWithOptions.\n */\nexport type ShowToastOptions = Omit<ToastOptions, 'duration'> & {\n    duration: ToastDuration | number;\n};\n"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAqBA,YAAY,QAAyB,eAAe;AAEzE,SAAkFC,OAAO,QAAsB,aAAa;AAC5H,SAASC,GAAG,QAAQ,QAAQ;AAE5B,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,UAAU,QAAQ,kBAAkB;AAC7C,SAASC,QAAQ,QAAQ,gBAAgB;AAEzC,SAASC,aAAa,QAA6B,sBAAsB;AACzE,SAASC,YAAY,QAAQ,qBAAqB;AAClD,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,aAAa,QAAQ,kBAAkB;AAChD,SAASC,qBAAqB,QAAQ,sBAAsB;AAC5D,SAASC,iBAAiB,QAAQ,+BAA+B;AACjE,SAAuBC,SAAS,QAAQ,uBAAuB;AAC/D,SAASC,eAAe,QAAQ,6BAA6B;AAC7D,SACIC,aAAa,EACbC,SAAS,EACTC,eAAe,EACfC,eAAe,EACfC,iBAAiB,EACjBC,eAAe,EACfC,MAAM,QACH,aAAa;AACpB,SAASC,UAAU,QAAQ,oBAAoB;AAE/C,SAASC,gBAAgB,QAAQ,+BAA+B;AAChE,SAASC,sBAAsB,QAAQ,mCAAmC;AAC1E,SAASC,wBAAwB,QAAQ,yCAAyC;AAClF,SAASC,+BAA+B,EAAEC,+BAA+B,QAAQ,mCAAmC;AAEpH,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,eAAe,QAAQ,iBAAiB;AACjD,SAASC,MAAM,QAAQ,gBAAgB;AAEvC,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,eAAe,QAAQ,iCAAiC;AACjE,SAASC,sBAAsB,QAAQ,mCAAmC;AAC1E,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,sBAAsB,QAAQ,8BAA8B;AACrE,SAASC,QAAQ,QAAQ,gBAAgB;AAEzC,SAASC,WAAW,QAAQ,yBAAyB;AACrD,SAASC,aAAa,QAAQ,wBAAwB;;AAEtD;;;AAIA,OAAM,MAAOC,oBAAoB;EAiB7BC,YAAA;IAfmB,KAAAC,qBAAqB,GAAG,kBAAkB;IAE7D;IACmB,KAAAC,sBAAsB,GAAa,CAAC,MAAM,EAAE,UAAU,EAAE,gBAAgB,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EACnH,UAAU,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,CAAC;IAErD,KAAAC,QAAQ,GAAwBC,QAAQ,CAACC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC;IAGpE,KAAAC,YAAY,GAAG,KAAK,CAAC,CAAC;IACtB,KAAAC,eAAe,GAAwC,EAAE,CAAC,CAAC;IAC3D,KAAAC,eAAe,GAAwC,EAAE,CAAC,CAAC;IAC3D,KAAAC,mBAAmB,GAA4B,EAAE;IAIvD,IAAI,CAACC,MAAM,GAAG7B,UAAU,CAAC8B,WAAW,CAAC,sBAAsB,CAAC;IAE5D,IAAI,CAACC,IAAI,EAAE;EACf;EAEA;;;EAGgBA,IAAIA,CAAA;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAChB;MACA,MAAMR,YAAY,SAAS1C,UAAU,CAACmD,GAAG,CAAS9C,aAAa,CAAC+C,sBAAsB,EAAE,CAAC,CAAC;MAE1FH,KAAI,CAACP,YAAY,GAAGA,YAAY,IAAI,CAAC;IAAC;EAC1C;EAEA;;;;;;;;;;;EAWMW,mBAAmBA,CACrBC,IAAqB,EACrBC,OAAgB,EAChBC,cAAuB,EACvBC,aAAsB,EACtBC,gBAAyB,EACzBC,aAAuB;IAAA,IAAAC,MAAA;IAAA,OAAAV,iBAAA;MAEvB,MAAMW,YAAY,GAAG3D,aAAa,CAAC4D,WAAW,CAACR,IAAI,CAACA,IAAI,EAAE,CAAC,CAAC;MAE5D,MAAMS,iBAAiB;QAAA,IAAAC,IAAA,GAAAd,iBAAA,CAAG,aAAmC;UACzD,MAAMe,cAAc,SAAShE,QAAQ,CAACiE,kBAAkB,EAAE;UAE1D,IAAIpC,YAAY,CAACqC,SAAS,EAAE,EAAE;YAC1B,OAAOF,cAAc;WACxB,MAAM;YACH;YACA;YACA,IAAIA,cAAc,GAAG5D,aAAa,CAAC+D,wBAAwB,IAAId,IAAI,CAACA,IAAI,GAAGW,cAAc,GAAG,CAAC,EAAE;cAC3F,OAAOA,cAAc;aACxB,MAAM;cACH,OAAO,IAAI;;;QAGvB,CAAC;QAAA,gBAdKF,iBAAiBA,CAAA;UAAA,OAAAC,IAAA,CAAAK,KAAA,OAAAC,SAAA;QAAA;MAAA,GActB;MAED,MAAMC,iBAAiB,GAAIN,cAA6B,IAAY;QAChE,IAAIA,cAAc,KAAK,IAAI,EAAE;UACzB,OAAO,EAAE;SACZ,MAAM;UACH,MAAMO,aAAa,GAAGtE,aAAa,CAAC4D,WAAW,CAACG,cAAc,EAAE,CAAC,CAAC;UAElE,IAAInC,YAAY,CAACqC,SAAS,EAAE,IAAIb,IAAI,CAACA,IAAI,GAAGW,cAAc,GAAG5D,aAAa,CAACoE,kBAAkB,EAAE;YAC3F,MAAM,IAAIjE,SAAS,CACfG,SAAS,CAAC+D,OAAO,CACb,wCAAwC,EACxC;cAAEpB,IAAI,EAAEO;YAAY,CAAE,CACzB,CACJ;;UAGL,OAAOlD,SAAS,CAAC+D,OAAO,CAAC,4BAA4B,EAAE;YAAEC,SAAS,EAAEH;UAAa,CAAE,CAAC;;MAE5F,CAAC;MAED,MAAMP,cAAc,SAASF,iBAAiB,EAAE;MAEhD,MAAMa,cAAc,GAAGL,iBAAiB,CAACN,cAAc,CAAC;MAExDR,aAAa,GAAGA,aAAa,KAAKoB,SAAS,GAAGxE,aAAa,CAACyE,uBAAuB,GAAGrB,aAAa;MACnGC,gBAAgB,GAAGA,gBAAgB,KAAKmB,SAAS,GAAGxE,aAAa,CAAC0E,kBAAkB,GAAGrB,gBAAgB;MAEvG,IAAIsB,UAAU,GAAG,EAAE;MACnB,IAAItD,WAAW,CAACuD,sBAAsB,EAAE,EAAE;QACtCD,UAAU,GAAGrE,SAAS,CAAC+D,OAAO,CAAC,oCAAoC,CAAC;;MAGxE,IAAIpB,IAAI,CAACA,IAAI,GAAG,CAAC,IAAKA,IAAI,CAACA,IAAI,IAAI,CAAC,IAAI,CAACA,IAAI,CAAC4B,KAAM,EAAE;QAClD;QACA1B,cAAc,GAAGA,cAAc,IAAI,wCAAwC;QAE3E,OAAOI,MAAI,CAACuB,WAAW,CACnBH,UAAU,GAAGrE,SAAS,CAAC+D,OAAO,CAC1BlB,cAAc,EACd;UAAEoB,cAAc,EAAEA;QAAc,CAAE,CACrC,CACJ;OACJ,MAAM,IAAI,CAACtB,IAAI,CAAC4B,KAAK,EAAE;QACpB;QAEA,OAAOtB,MAAI,CAACuB,WAAW,CACnBH,UAAU,GAAGrE,SAAS,CAAC+D,OAAO,CAC1B,wCAAwC,EACxC;UAAEpB,IAAI,EAAEO,YAAY;UAAEe,cAAc,EAAEA;QAAc,CAAE,CACzD,CACJ;OACJ,MAAM,IAAIjB,aAAa,IAAIL,IAAI,CAACA,IAAI,IAAIG,aAAa,IAC7C/B,WAAW,CAACuD,sBAAsB,EAAE,IAAI3B,IAAI,CAACA,IAAI,IAAII,gBAAiB,EAAE;QAC7EH,OAAO,GAAGA,OAAO,KAAKD,IAAI,CAACA,IAAI,KAAK,CAAC,GAAG,qCAAqC,GAAG,6BAA6B,CAAC;QAE9G,OAAOM,MAAI,CAACuB,WAAW,CACnBH,UAAU,GAAGrE,SAAS,CAAC+D,OAAO,CAC1BnB,OAAO,EACP;UAAED,IAAI,EAAEO,YAAY;UAAEe,cAAc,EAAEA;QAAc,CAAE,CACzD,CACJ;;IACJ;EACL;EAEA;;;;;;EAMAQ,gBAAgBA,CAACC,IAAY;IACzB;IACA,IAAI,CAAC9C,QAAQ,CAAC+C,SAAS,GAAG,OAAO,GAAGD,IAAI,GAAG,QAAQ;IAEnD,OAAqB,IAAI,CAAC9C,QAAQ,CAACgD,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC;EAC1D;EAEA;;;;;;;EAOAC,6BAA6BA,CAACC,OAAyC;IACnE,MAAMC,UAAU,GAAqC,EAAE;IAEvD;IACAD,OAAO,CAACE,gBAAgB,CAAEC,IAAI,IAAI;MAC9BF,UAAU,CAACE,IAAI,CAACC,GAAG,CAAC,GAAG,IAAIlG,YAAY,CAACiG,IAAI,CAACE,aAAa,EAAEF,IAAI,CAACG,YAAY,EAAE,IAAI,CAAC;IACxF,CAAC,CAAC;IAEF;IACAN,OAAO,CAACO,kBAAkB,CAAEJ,IAAI,IAAI;MAChCF,UAAU,CAACE,IAAI,CAACC,GAAG,CAAC,GAAG,IAAIlG,YAAY,CAACiG,IAAI,CAACE,aAAa,EAAEF,IAAI,CAACG,YAAY,EAAE,KAAK,CAAC;IACzF,CAAC,CAAC;IACFN,OAAO,CAACQ,kBAAkB,CAAEL,IAAI,IAAI;MAChCF,UAAU,CAACE,IAAI,CAACC,GAAG,CAAC,GAAG,IAAIlG,YAAY,CAACiG,IAAI,CAACE,aAAa,EAAEF,IAAI,CAACG,YAAY,EAAE,IAAI,CAAC;IACxF,CAAC,CAAC;IAEF,OAAOL,UAAU;EACrB;EAEA;;;;;;EAMAQ,kBAAkBA,CAACC,IAAY;IAC3B;IACA,MAAMC,IAAI,GAAa,EAAE;IACzB,MAAMC,OAAO,GAAGF,IAAI,CAACG,KAAK,CAAC,oCAAoC,CAAC;IAEhE,IAAI,CAACD,OAAO,EAAE;MACV,OAAOD,IAAI;;IAGf;IACAC,OAAO,CAACE,OAAO,CAAED,KAAK,IAAI;MACtB,MAAME,UAAU,GAAGF,KAAK,CAACA,KAAK,CAAC,mCAAmC,CAAC;MACnE,IAAIE,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAG,CAAC,CAAC,EAAE;QACjBJ,IAAI,CAACK,IAAI,CAACD,UAAU,CAAC,CAAC,CAAC,CAAC;;IAEhC,CAAC,CAAC;IAEF,OAAOJ,IAAI;EACf;EAEA;;;;;;EAMAM,OAAOA,CAACtB,IAAY;IAChB,IAAI,CAAC9C,QAAQ,CAAC+C,SAAS,GAAGD,IAAI;IAE9B;IACA,MAAMuB,cAAc,GAAG,6BAA6B;IACpD,MAAMC,UAAU,GAAIC,OAAgB,IAAU;MAC1C;MACAC,KAAK,CAACC,IAAI,CAACF,OAAO,CAACG,UAAU,CAAC,CAACT,OAAO,CAAEU,IAAI,IAAI;QAC5C,IAAI,CAACN,cAAc,CAACO,IAAI,CAACD,IAAI,CAACE,IAAI,CAAC,EAAE;UACjCN,OAAO,CAACO,mBAAmB,CAACH,IAAI,CAAC;;MAEzC,CAAC,CAAC;MAEFH,KAAK,CAACC,IAAI,CAACF,OAAO,CAACtB,QAAQ,CAAC,CAACgB,OAAO,CAACK,UAAU,CAAC;IACpD,CAAC;IAEDE,KAAK,CAACC,IAAI,CAAC,IAAI,CAACzE,QAAQ,CAACgD,OAAO,CAACC,QAAQ,CAAC,CAACgB,OAAO,CAACK,UAAU,CAAC;IAE9D,OAAO,IAAI,CAACtE,QAAQ,CAAC+C,SAAS;EAClC;EAEA;;;;;EAKMgC,YAAYA,CACdR,OAA6F;IAAA,IAAAS,MAAA;IAAA,OAAArE,iBAAA;MAE7F,IAAIsE,OAAO,GAAG,EAAE;MAEhB,IAAIF,YAAY,GAAGR,OAAO;MAE1B,IAAI,iBAAiB,IAAIQ,YAAY,EAAE;QACnC;QACAA,YAAY,CAACG,gBAAgB,WAAUH,YAAY,CAACG,gBAAgB,EAAE;QACtEH,YAAY,SAASA,YAAY,CAACI,eAAe,EAAE;;MAGvD,IAAI,CAACJ,YAAY,IAAI,CAACA,YAAY,CAACK,KAAK,EAAE;QACtC,MAAM,IAAInH,SAAS,CAAC,oCAAoC,CAAC;;MAG7D,OAAOgH,OAAO,GAAG,CAAC,IAAIF,YAAY,KAAK9E,QAAQ,CAACoF,aAAa,EAAE;QAC3DN,YAAY,CAACK,KAAK,EAAE;QAEpB,IAAIL,YAAY,KAAK9E,QAAQ,CAACoF,aAAa,EAAE;UACzC,MAAMxH,SAAS,CAACyH,QAAQ,EAAE;UAC1B,IAAI/F,YAAY,CAACqC,SAAS,EAAE,IAAIoD,MAAI,CAACO,qBAAqB,CAACR,YAAY,CAAC,EAAE;YACtE;YACAvH,OAAO,CAACgI,YAAY,EAAE;;UAE1B;;QAGJ;QACA,MAAM3H,SAAS,CAAC4H,IAAI,CAAC,EAAE,CAAC;QACxBR,OAAO,EAAE;;IACZ;EACL;EAEA;;;;;;;;EAQAS,gBAAgBA,CAAC3E,IAAqB;IAClC,IAAI,OAAOA,IAAI,IAAI,QAAQ,KAAKA,IAAI,CAAC4E,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI5E,IAAI,CAAC4E,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI5E,IAAI,IAAI,MAAM,IAAIA,IAAI,IAAI,SAAS,CAAC,EAAE;MACvH;MACA,OAAOA,IAAI;;IAGf,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAE;MACzB;MACAA,IAAI,GAAG6E,QAAQ,CAAC7E,IAAI,EAAE,EAAE,CAAC;;IAG7B,IAAI,CAAC8E,KAAK,CAAC9E,IAAI,CAAC,EAAE;MACd,OAAOA,IAAI,GAAG,IAAI;;IAGtB,OAAO,EAAE;EACb;EAEA;;;;;;;EAOA+E,oBAAoBA,CAACvB,OAAoB,EAAEwB,QAAgB;IACvD,MAAMC,QAAQ,GAAGzB,OAAO,CAAC0B,aAAa,CAACF,QAAQ,CAAC;IAChD,IAAIC,QAAQ,EAAE;MACV,OAAOA,QAAQ,CAACjD,SAAS;;EAEjC;EAEA;;;;;;;EAOAmD,uBAAuBA,CAACpD,IAAY,EAAEqD,SAAiB;IACnD,OAAO,IAAI,CAACtD,gBAAgB,CAACC,IAAI,CAAC,CAACG,QAAQ,CAAC,CAAC,CAAC,CAACmD,YAAY,CAACD,SAAS,CAAC;EAC1E;EAEA;;;;;;;EAOAE,uBAAuBA,CAACC,KAA0B,EAAEC,OAAe;IAC/D,OAAOX,QAAQ,CAACU,KAAK,CAACC,OAAO,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC;EAC5C;EAEA;;;;;;;EAOUC,cAAcA,CAACxF,OAAe,EAAEyF,KAAgD;IACtF,OAAOzF,OAAO,IAAI5C,SAAS,CAAC+D,OAAO,CAAC,sBAAsB,CAAC,IACvDnB,OAAO,IAAI5C,SAAS,CAAC+D,OAAO,CAAC,6CAA6C,CAAC,IAC3EsE,KAAK,YAAY9H,gBAAgB;EACzC;EAEA;;;;;;EAMU+H,sBAAsBA,CAAC1F,OAAe;IAC5C,IAAI2F,sBAAsB,GAAGvI,SAAS,CAAC+D,OAAO,CAAC,0BAA0B,EAAE;MAAEyE,IAAI,EAAE;IAAoB,CAAE,CAAC;IAC1GD,sBAAsB,GAAGhJ,aAAa,CAACkJ,cAAc,CAACF,sBAAsB,CAAC;IAC7EA,sBAAsB,GAAGA,sBAAsB,CAACG,OAAO,CAAC,oBAAoB,EAAE,IAAI,CAAC;IAEnF,OAAO,IAAIC,MAAM,CAACJ,sBAAsB,CAAC,CAAC/B,IAAI,CAAC5D,OAAO,CAAC;EAC3D;EAEA;;;;;;;EAOAgG,eAAeA,CAACP,KAA+C,EAAEQ,cAAwB;IACrF,IAAI,OAAOR,KAAK,IAAI,QAAQ,IAAI,CAACA,KAAK,EAAE;MACpC,OAAO,IAAI;;IAGf,IAAIS,SAAS,GAAG,EAAE;IAClB,IAAIC,YAAgC;IAEpC,IAAI,OAAOV,KAAK,IAAI,QAAQ,EAAE;MAC1B,IAAI,IAAI,CAACtG,YAAY,EAAE;QACnB;QACA,IAAI,WAAW,IAAIsG,KAAK,IAAIA,KAAK,CAACW,SAAS,EAAE;UACzCF,SAAS,GAAG,UAAU,GAAGvJ,aAAa,CAAC0J,UAAU,CAACZ,KAAK,CAACW,SAAS,EAAE,KAAK,CAAC;;QAE7E,IAAI,WAAW,IAAIX,KAAK,IAAIA,KAAK,CAACa,SAAS,EAAE;UACzCJ,SAAS,IAAI,UAAU,GAAGvJ,aAAa,CAAC4J,eAAe,CACnD5J,aAAa,CAAC0J,UAAU,CAACZ,KAAK,CAACa,SAAS,EAAE,KAAK,CAAC,EAChD,MAAM,CACT;;QAGL;QACAE,OAAO,CAACf,KAAK,CAACA,KAAK,CAAC;;MAGxB,IAAI,IAAI,CAACgB,aAAa,CAAChB,KAAK,CAAC,EAAE;QAC3B;QACA,OAAO,IAAI;;MAGf;MACAU,YAAY,GAAGxJ,aAAa,CAAC+J,wBAAwB,CAACjB,KAAK,CAAC;MAC5D9G,aAAa,CAACgI,WAAW,CAAC;QAAE3G,OAAO,EAAE4G,IAAI,CAACC,SAAS,CAACpB,KAAK,CAAC;QAAEqB,IAAI,EAAEX,YAAY,IAAI,EAAE;QAAEY,IAAI,EAAE,IAAIC,IAAI,EAAE,CAACC,OAAO;MAAE,CAAE,CAAC;MACnH,IAAI,CAACd,YAAY,EAAE;QACf;QACAA,YAAY,GAAGS,IAAI,CAACC,SAAS,CAACpB,KAAK,CAAC;QACpCS,SAAS,GAAG,EAAE,CAAC,CAAC;;MAGpB;MACA,MAAMnD,OAAO,GAAGoD,YAAY,CAACnD,KAAK,CAAC,qBAAqB,CAAC;MACzD,IAAID,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAG,CAAC,CAAC,EAAE;QACdoD,YAAY,GAAGA,YAAY,CAACL,OAAO,CAAC,IAAIC,MAAM,CAAChD,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,QAAQ,CAAC;;KAEjF,MAAM;MACHoD,YAAY,GAAGV,KAAK;;IAGxB,IAAIzF,OAAO,GAAGrD,aAAa,CAACuK,UAAU,CAACjB,cAAc,GAAG7I,SAAS,CAAC+D,OAAO,CAACgF,YAAY,CAAC,GAAGA,YAAY,CAAC;IAEvG,IAAID,SAAS,EAAE;MACXlG,OAAO,IAAIkG,SAAS;;IAGxB,OAAOlG,OAAO;EAClB;EAEA;;;;;;EAMAmH,eAAeA,CAAC1B,KAAmB;IAC/B,OAAOA,KAAK,YAAYzI,iBAAiB;EAC7C;EAEA;;;;;;EAMAyJ,aAAaA,CAAChB,KAAmB;IAC7B,OAAOA,KAAK,YAAYvI,eAAe;EAC3C;EAEA;;;;;EAKAkK,uBAAuBA,CAAC7D,OAAoB;IACxC,MAAM8D,GAAG,GAAG7D,KAAK,CAACC,IAAI,CAACF,OAAO,CAAC+D,gBAAgB,CAAC,yBAAyB,CAAC,CAAC;IAE3ED,GAAG,CAACpE,OAAO,CAAEsE,EAAE,IAAI;MACf,MAAMvF,OAAO,GAAGuF,EAAE,CAACnC,YAAY,CAAC,OAAO,CAAC,IAAImC,EAAE,CAACnC,YAAY,CAAC,qBAAqB,CAAC;MAClF,MAAMoC,OAAO,GAAGD,EAAE,CAACnC,YAAY,CAAC,cAAc,CAAC,IAAI,aAAa;MAChE,MAAMqC,OAAO,GAAGF,EAAE,CAACnC,YAAY,CAAC,wBAAwB,CAAC;MAEzD,IAAI,CAACpD,OAAO,IAAIyF,OAAO,KAAK,MAAM,IACzBD,OAAO,CAAC7C,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI6C,OAAO,CAAC7C,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI6C,OAAO,CAAC7C,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAE,EAAE;QAC1G;;MAGJ4C,EAAE,CAACG,YAAY,CAAC,wBAAwB,EAAE,MAAM,CAAC,CAAC,CAAC;MAEnD;MACAH,EAAE,CAACG,YAAY,CAAC,qBAAqB,EAAE1F,OAAO,CAAC;MAC/CuF,EAAE,CAACG,YAAY,CAAC,OAAO,EAAE,EAAE,CAAC;MAE5BH,EAAE,CAACI,gBAAgB,CAAC,OAAO;QAAA,IAAAC,KAAA,GAAAjI,iBAAA,CAAE,WAAOkI,EAAS,EAAI;UAC7C,MAAM/F,IAAI,GAAGyF,EAAE,CAACnC,YAAY,CAAC,WAAW,CAAC;UAEzC,MAAM0C,YAAY,CAACC,WAAW,CAAC;YAC3BC,SAAS,EAAEpK,sBAAsB;YACjCqK,cAAc,EAAE;cACZjG,OAAO;cACPF,IAAI,EAAEA,IAAI,KAAK;aAClB;YACDoG,KAAK,EAAEL;WACV,CAAC;QACN,CAAC;QAAA,iBAAAM,EAAA;UAAA,OAAAP,KAAA,CAAA9G,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC;IACN,CAAC,CAAC;EACN;EAEA;;;;;;;;EAQAqH,wBAAwBA,CACpBC,QAAqB,EACrB9E,OAAoB,EACpB+E,KAAA,GAAuBC,aAAa,CAACC,GAAG;IAExC,MAAMC,WAAW,GAAGlF,OAAO,CAACmF,qBAAqB,EAAE;IAEnD,IAAI,CAACD,WAAW,EAAE;MACd,OAAO,KAAK;;IAGhB,IAAIE,YAAoB;IACxB,QAAQL,KAAK;MACT,KAAKC,aAAa,CAACK,GAAG;QAClBD,YAAY,GAAGF,WAAW,CAACI,GAAG;QAC9B;MAEJ,KAAKN,aAAa,CAACO,MAAM;QACrBH,YAAY,GAAGF,WAAW,CAACM,MAAM;QACjC;MAEJ,KAAKR,aAAa,CAACC,GAAG;QAClBG,YAAY,GAAGK,IAAI,CAACC,KAAK,CAAC,CAACR,WAAW,CAACM,MAAM,GAAGN,WAAW,CAACI,GAAG,IAAI,CAAC,CAAC;QACrE;;IAGR,MAAMK,YAAY,GAAGb,QAAQ,CAACK,qBAAqB,EAAE;IACrD,MAAMS,YAAY,GAAG,CAAAD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEL,GAAG,KAAI,CAAC;IAE3C,OAAOF,YAAY,GAAGS,MAAM,CAACC,WAAW,IAAIV,YAAY,GAAGQ,YAAY;EAC3E;EAEA;;;;;EAKMG,uBAAuBA,CAAA;IAAA,OAAA3J,iBAAA;MACzB,MAAM4J,OAAO,SAAS9M,UAAU,CAACmD,GAAG,CAAC9C,aAAa,CAAC0M,yBAAyB,EAAE,IAAI,CAAC;MAEnF,OAAO,CAAC,CAACD,OAAO;IAAC;EACrB;EAEA;;;;;;;;EAQAE,YAAYA,CAACC,SAAsB,EAAEC,SAAsB,EAAEC,OAAiB;IAC1E,MAAMC,aAAa,GAAW,EAAE;IAChC,MAAMC,aAAa,GAAGF,OAAO,GAAGD,SAAS,CAACI,UAAU,GAAG,IAAI;IAE3D,OAAOL,SAAS,CAACM,UAAU,CAACC,MAAM,GAAG,CAAC,EAAE;MACpC,MAAMC,KAAK,GAAGR,SAAS,CAACM,UAAU,CAAC,CAAC,CAAC;MACrCH,aAAa,CAAC1G,IAAI,CAAC+G,KAAK,CAAC;MAEzBP,SAAS,CAACQ,YAAY,CAACD,KAAK,EAAEJ,aAAa,CAAC;;IAGhD,OAAOD,aAAa;EACxB;EAEA;;;;;;EAMAO,aAAaA,CAAC7G,OAAoB,EAAEwB,QAAgB;IAChD,MAAMC,QAAQ,GAAGzB,OAAO,CAAC0B,aAAa,CAACF,QAAQ,CAAC;IAChD,IAAIC,QAAQ,EAAE;MACVA,QAAQ,CAACqF,MAAM,EAAE;;EAEzB;EAEA;;;;;;;;EAQAC,qBAAqBA,CAACxI,IAAY,EAAEiD,QAAgB,EAAEwF,SAAmB;IACrE,MAAMhH,OAAO,GAAG,IAAI,CAAC1B,gBAAgB,CAACC,IAAI,CAAC;IAE3C,IAAIyI,SAAS,EAAE;MACX,MAAMvF,QAAQ,GAAGzB,OAAO,CAAC+D,gBAAgB,CAACvC,QAAQ,CAAC;MACnD,KAAK,IAAIyF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxF,QAAQ,CAACiF,MAAM,EAAEO,CAAC,EAAE,EAAE;QACtCxF,QAAQ,CAACwF,CAAC,CAAC,CAACH,MAAM,EAAE;;KAE3B,MAAM;MACH,MAAMrF,QAAQ,GAAGzB,OAAO,CAAC0B,aAAa,CAACF,QAAQ,CAAC;MAChD,IAAIC,QAAQ,EAAE;QACVA,QAAQ,CAACqF,MAAM,EAAE;;;IAIzB,OAAO9G,OAAO,CAACxB,SAAS;EAC5B;EAEA;;;;;;;EAOA0I,uBAAuBA,CAAClH,OAAoB,EAAEmH,GAAqC;IAC/E,KAAK,MAAMnI,GAAG,IAAImI,GAAG,EAAE;MACnB,MAAMC,aAAa,GAAGpH,OAAO,CAAC+D,gBAAgB,CAAC,GAAG,GAAG/E,GAAG,CAAC;MAEzD,KAAK,IAAIiI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,aAAa,CAACV,MAAM,EAAEO,CAAC,EAAE,EAAE;QAC3C,MAAMI,YAAY,GAAGD,aAAa,CAACH,CAAC,CAAC;QACrCI,YAAY,CAACC,SAAS,GAAGD,YAAY,CAACC,SAAS,CAAC/E,OAAO,CAACvD,GAAG,EAAEmI,GAAG,CAACnI,GAAG,CAAC,CAAC;;;EAGlF;EAEA;;;;;;;;EAQAuI,oBAAoBA,CAChBhJ,IAAY,EACZiJ,KAA8B,EAC9BC,QAAsD;IAEtD,MAAMzH,OAAO,GAAG,IAAI,CAAC1B,gBAAgB,CAACC,IAAI,CAAC;IAE3C;IACA,MAAMmJ,KAAK,GAAGzH,KAAK,CAACC,IAAI,CAACF,OAAO,CAAC+D,gBAAgB,CAAc,kCAAkC,CAAC,CAAC;IACnG2D,KAAK,CAAChI,OAAO,CAAEgI,KAAkB,IAAI;MACjC,MAAMC,UAAU,GAAGD,KAAK,CAAC7F,YAAY,CAAC,KAAK,CAAC;MAC5C,MAAM+F,MAAM,GAAGD,UAAU,GACrBH,KAAK,CAACnO,YAAY,CAACwO,eAAe,CAACzO,aAAa,CAAC0O,kBAAkB,CAACH,UAAU,CAAC,CAAC,CAAC,GACjF5J,SAAS;MAEb,IAAI6J,MAAM,KAAK7J,SAAS,EAAE;QACtB2J,KAAK,CAACvD,YAAY,CAAC,KAAK,EAAEyD,MAAM,CAAC;;MAGrC;MACA,MAAMG,aAAa,GAAGL,KAAK,CAAC7F,YAAY,CAAC,QAAQ,CAAC;MAClD,IAAI6F,KAAK,CAACM,OAAO,IAAI,OAAO,IAAID,aAAa,EAAE;QAC3C,MAAME,SAAS,GAAGT,KAAK,CAACpO,aAAa,CAAC0O,kBAAkB,CAACC,aAAa,CAAC,CAAC;QACxE,IAAIE,SAAS,KAAKlK,SAAS,EAAE;UACzB2J,KAAK,CAACvD,YAAY,CAAC,QAAQ,EAAE8D,SAAS,CAAC;;;IAGnD,CAAC,CAAC;IAEF;IACA,MAAMC,OAAO,GAAGjI,KAAK,CAACC,IAAI,CAACF,OAAO,CAAC+D,gBAAgB,CAAC,GAAG,CAAC,CAAC;IACzDmE,OAAO,CAACxI,OAAO,CAAEyI,MAAmB,IAAI;MACpC,MAAMC,WAAW,GAAGD,MAAM,CAACtG,YAAY,CAAC,MAAM,CAAC;MAC/C,MAAMwG,OAAO,GAAGD,WAAW,GACvBZ,KAAK,CAACnO,YAAY,CAACwO,eAAe,CAACzO,aAAa,CAAC0O,kBAAkB,CAACM,WAAW,CAAC,CAAC,CAAC,GAClFrK,SAAS;MAEb,IAAIsK,OAAO,KAAKtK,SAAS,EAAE;QACvBoK,MAAM,CAAChE,YAAY,CAAC,MAAM,EAAEkE,OAAO,CAAC;QAEpC,IAAI,OAAOZ,QAAQ,IAAI,UAAU,EAAE;UAC/BA,QAAQ,CAACU,MAAM,EAAEE,OAAO,CAAC;;;IAGrC,CAAC,CAAC;IAEF,OAAOrI,OAAO,CAACxB,SAAS;EAC5B;EAEA;;;;;;EAMM8J,gBAAgBA,CAAC7J,OAAmB;IAAA,OAAArC,iBAAA;MACtC,IAAI;QACA,MAAMmM,aAAa,SAAS9J,OAAO,CAAC+J,gBAAgB,EAAE;QAEtD,OAAOD,aAAa,CAACE,YAAY,IAAI,CAAC;OACzC,CAAC,OAAAC,OAAA,EAAM;QACJ,OAAO,CAAC;;IACX;EACL;EAEA;;;;;;EAMMC,eAAeA,CAAClK,OAAmB;IAAA,OAAArC,iBAAA;MACrC,IAAI;QACA,MAAMmM,aAAa,SAAS9J,OAAO,CAAC+J,gBAAgB,EAAE;QAEtD,OAAOD,aAAa,CAACK,YAAY,IAAI,CAAC;OACzC,CAAC,OAAAC,QAAA,EAAM;QACJ,OAAO,CAAC;;IACX;EACL;EAEA;;;;;;EAMMC,YAAYA,CAACrK,OAAmB;IAAA,OAAArC,iBAAA;MAClC,IAAI;QACA,MAAMmM,aAAa,SAAS9J,OAAO,CAAC+J,gBAAgB,EAAE;QAEtD,OAAOD,aAAa,CAACQ,SAAS,IAAI,CAAC;OACtC,CAAC,OAAAC,QAAA,EAAM;QACJ,OAAO,CAAC;;IACX;EACL;EAEA;;;;;EAKAC,eAAeA,CAACC,KAAc;IAC1B,IAAI,CAACtN,YAAY,GAAGsN,KAAK;EAC7B;EAEA;;;;;;;;;EASMC,SAASA,CACXC,MAA0B,EAC1B3M,OAAe,EACf4M,UAAmB,EACnBC,aAAsB;IAAA,IAAAC,MAAA;IAAA,OAAAnN,iBAAA;MAEtB,OAAOmN,MAAI,CAACC,oBAAoB,CAAC;QAC7BJ,MAAM;QACN3M,OAAO;QACPgN,OAAO,EAAE,CAACJ,UAAU,IAAIxP,SAAS,CAAC+D,OAAO,CAAC,SAAS,CAAC;OACvD,EAAE0L,aAAa,CAAC;IAAC;EACtB;EAEA;;;;;;;EAOME,oBAAoBA,CAACE,OAAA,GAAwB,EAAE,EAAEJ,aAAsB;IAAA,IAAAK,MAAA;IAAA,OAAAvN,iBAAA;MAAA,IAAAwN,gBAAA,EAAAC,qBAAA;MACzE,IAAIpN,OAAO,GAAG,OAAOiN,OAAO,CAACjN,OAAO,IAAI,QAAQ,GAC1CiN,OAAO,CAACjN,OAAO,GACf,EAAAmN,gBAAA,GAAAF,OAAO,CAACjN,OAAO,cAAAmN,gBAAA,uBAAfA,gBAAA,CAAiBV,KAAK,KAAI,EAAE;MAElC,MAAMY,WAAW,GAAG1Q,aAAa,CAAC0Q,WAAW,CAACrN,OAAO,CAAC;MAEtD,IAAIqN,WAAW,IAAI,GAAAD,qBAAA,GAACpP,SAAS,CAACsP,cAAc,EAAE,cAAAF,qBAAA,eAA1BA,qBAAA,CAA4BG,yBAAyB,CAAC,KAAK,CAAC,GAAE;QAC9E;QACAvN,OAAO,SAASvB,QAAQ,CAAC+O,eAAe,CAACxN,OAAO,CAAC;;MAGrDiN,OAAO,CAACjN,OAAO,GAAGA,OAAO;MAEzB,MAAMyN,OAAO,GAAGlR,GAAG,CAACmR,YAAY,CAAC,CAACT,OAAO,CAACN,MAAM,IAAI,EAAE,IAAI,GAAG,IAAI3M,OAAO,IAAG,EAAE,CAAC,CAAC;MAE/E,IAAIkN,MAAI,CAAC9N,eAAe,CAACqO,OAAO,CAAC,EAAE;QAC/B;QACA,OAAOP,MAAI,CAAC9N,eAAe,CAACqO,OAAO,CAAC;;MAGxC,MAAME,KAAK,SAAStQ,eAAe,CAACuQ,MAAM,CAACX,OAAO,CAAC;MAEnD,IAAIY,MAAM,CAACC,IAAI,CAACZ,MAAI,CAAC9N,eAAe,CAAC,CAAC6K,MAAM,KAAK,CAAC,EAAE;QAChD,MAAM8D,OAAO,CAACC,GAAG,CAACd,MAAI,CAAC5N,mBAAmB,CAAC2O,KAAK,CAAC,CAAC,CAAC,CAACC,OAAO,EAAE,CAACxD,GAAG,CAACyD,KAAK,IAAIA,KAAK,CAACC,KAAK,EAAE,CAAC,CAAC;;MAG9F;MACAT,KAAK,CAACU,OAAO,EAAE,CAACC,IAAI,CAAC,MAAK;QACtB,IAAIjB,WAAW,EAAE;UACb;UACA,MAAMkB,cAAc,GAAuBZ,KAAK,CAAC1I,aAAa,CAAC,gBAAgB,CAAC;UAChFsJ,cAAc,IAAIrB,MAAI,CAACsB,YAAY,CAACD,cAAc,CAAC;;QAGvD;MACJ,CAAC,CAAC;MAEF;MACArB,MAAI,CAAC9N,eAAe,CAACqO,OAAO,CAAC,GAAGE,KAAK;MAErC;MACA;MACAA,KAAK,CAACc,YAAY,EAAE,CAACH,IAAI,eAAA3O,iBAAA,CAAC,aAAW;QACjC,OAAOuN,MAAI,CAAC9N,eAAe,CAACqO,OAAO,CAAC;QAEpC;QACA,IAAII,MAAM,CAACC,IAAI,CAACZ,MAAI,CAAC9N,eAAe,CAAC,CAAC6K,MAAM,KAAK,CAAC,EAAE;UAChD,MAAM8D,OAAO,CAACC,GAAG,CAACd,MAAI,CAAC5N,mBAAmB,CAACoL,GAAG,CAACyD,KAAK,IAAIA,KAAK,CAACO,MAAM,EAAE,CAAC,CAAC;;MAEhF,CAAC,EAAC;MAEF,IAAI7B,aAAa,IAAIA,aAAa,GAAG,CAAC,EAAE;QACpC8B,UAAU,eAAAhP,iBAAA,CAAC,aAAW;UAClB,MAAMgO,KAAK,CAACiB,OAAO,EAAE;UAErB,IAAI3B,OAAO,CAACD,OAAO,EAAE;YAAA,IAAA6B,qBAAA;YACjB;YACA,MAAMC,YAAY,GAA6B7B,OAAO,CAACD,OAAO,CAAC+B,IAAI,CAC9DC,MAAM,IAAK,OAAOA,MAAM,IAAI,QAAQ,IAAIA,MAAM,CAACC,OAAO,KAAK3N,SAAS,IAAI0N,MAAM,CAACE,IAAI,IAAI,QAAQ,CACnG;YACDJ,YAAY,aAAZA,YAAY,gBAAAD,qBAAA,GAAZC,YAAY,CAAEG,OAAO,cAAAJ,qBAAA,eAArBA,qBAAA,CAAAM,IAAA,CAAAL,YAAY,EAAY,IAAI,CAAC;;QAErC,CAAC,GAAEjC,aAAa,CAAC;;MAGrB,OAAOc,KAAK;IAAC;EACjB;EAEA;;;;;;;;;EASAyB,mBAAmBA,CACfzC,MAA0B,EAC1B3M,OAAe,EACf4M,UAAmB,EACnBC,aAAsB;IAEtBF,MAAM,GAAGA,MAAM,GAAGvP,SAAS,CAAC+D,OAAO,CAACwL,MAAM,CAAC,GAAGA,MAAM;IACpD3M,OAAO,GAAGA,OAAO,GAAG5C,SAAS,CAAC+D,OAAO,CAACnB,OAAO,CAAC,GAAGA,OAAO;IACxD4M,UAAU,GAAGA,UAAU,GAAGxP,SAAS,CAAC+D,OAAO,CAACyL,UAAU,CAAC,GAAGA,UAAU;IAEpE,OAAO,IAAI,CAACF,SAAS,CAACC,MAAM,EAAE3M,OAAO,EAAE4M,UAAU,EAAEC,aAAa,CAAC;EACrE;EAEA;;;;;;;;EAQAwC,iBAAiBA,CACbC,gBAAA,GAA2B,iBAAiB,EAC5CC,aAAA,GAAyC,EAAE,EAC3CtC,OAAA,GAAwB,EAAE;IAE1B,OAAO,IAAIc,OAAO,CAAC,CAACyB,OAAO,EAAEC,MAAM,KAAU;MACzCxC,OAAO,CAACjN,OAAO,GAAG5C,SAAS,CAAC+D,OAAO,CAACmO,gBAAgB,EAAEC,aAAa,CAAC;MAEpEtC,OAAO,CAACD,OAAO,GAAG,CACd;QACI0C,IAAI,EAAEtS,SAAS,CAAC+D,OAAO,CAAC,aAAa,CAAC;QACtC+N,IAAI,EAAE,QAAQ;QACdD,OAAO,EAAEA,CAAA,KAAK;UACVQ,MAAM,CAAC,IAAIzS,iBAAiB,CAAC,EAAE,CAAC,CAAC;QACrC;OACH,EACD;QACI0S,IAAI,EAAEtS,SAAS,CAAC+D,OAAO,CAAC,aAAa,CAAC;QACtC+N,IAAI,EAAE,aAAa;QACnBD,OAAO,EAAEA,CAAA,KAAK;UACVO,OAAO,EAAE;QACb;OACH,CACJ;MAED,IAAI,CAACvC,OAAO,CAACN,MAAM,EAAE;QACjBM,OAAO,CAAC0C,QAAQ,GAAG,CAAC1C,OAAO,CAAC0C,QAAQ,IAAI,EAAE,IAAI,cAAc;;MAGhE,IAAI,CAAC5C,oBAAoB,CAACE,OAAO,EAAE,CAAC,CAAC;IACzC,CAAC,CAAC;EACN;EAEA;;;;;;;;;;EAUArL,WAAWA,CACP5B,OAAe,EACf2M,MAAe,EACfiD,MAAe,EACfC,UAAmB,EACnB5C,OAAA,GAAwB,EAAE;IAE1B,OAAO,IAAIc,OAAO,CAAI,CAACyB,OAAO,EAAEC,MAAM,KAAU;MAC5CxC,OAAO,CAACN,MAAM,GAAGA,MAAM;MACvBM,OAAO,CAACjN,OAAO,GAAGA,OAAO;MAEzBiN,OAAO,CAACD,OAAO,GAAG,CACd;QACI0C,IAAI,EAAEG,UAAU,IAAIzS,SAAS,CAAC+D,OAAO,CAAC,aAAa,CAAC;QACpD+N,IAAI,EAAE,QAAQ;QACdD,OAAO,EAAEA,CAAA,KAAK;UACVQ,MAAM,CAAC,IAAIzS,iBAAiB,CAAC,EAAE,CAAC,CAAC;QACrC;OACH,EACD;QACI0S,IAAI,EAAEE,MAAM,IAAIxS,SAAS,CAAC+D,OAAO,CAAC,SAAS,CAAC;QAC5C8N,OAAO,EAAGa,IAAO,IAAI;UACjBN,OAAO,CAACM,IAAI,CAAC;QACjB;OACH,CACJ;MAED,IAAI,CAACnD,MAAM,EAAE;QACTM,OAAO,CAAC0C,QAAQ,GAAG,CAAC1C,OAAO,CAAC0C,QAAQ,IAAI,EAAE,IAAI,cAAc;;MAGhE,IAAI,CAAC5C,oBAAoB,CAACE,OAAO,EAAE,CAAC,CAAC;IACzC,CAAC,CAAC;EACN;EAEA;;;;;;;;EAQM8C,cAAcA,CAChBtK,KAA+C,EAC/CQ,cAAwB,EACxB4G,aAAsB;IAAA,IAAAmD,MAAA;IAAA,OAAArQ,iBAAA;MAEtB,IAAIqQ,MAAI,CAAC7I,eAAe,CAAC1B,KAAK,CAAC,EAAE;QAC7B;QACA,OAAO,IAAI;;MAGf,MAAMzF,OAAO,GAAGgQ,MAAI,CAAChK,eAAe,CAACP,KAAK,EAAEQ,cAAc,CAAC;MAE3D,IAAIjG,OAAO,KAAK,IAAI,EAAE;QAClB;QACA,OAAO,IAAI;;MAGf,MAAMiQ,YAAY,GAAiB;QAAEjQ;MAAO,CAAE;MAE9C,IAAIgQ,MAAI,CAACxK,cAAc,CAACxF,OAAO,EAAEyF,KAAK,CAAC,EAAE;QACrCwK,YAAY,CAACN,QAAQ,GAAG,0BAA0B;;MAGtD,IAAI,OAAOlK,KAAK,KAAK,QAAQ,IAAI,OAAO,IAAIA,KAAK,IAAIA,KAAK,CAACyK,KAAK,EAAE;QAC9DD,YAAY,CAACtD,MAAM,GAAGlH,KAAK,CAACyK,KAAK,IAAI5O,SAAS;OACjD,MAAM,IAAItB,OAAO,KAAK5C,SAAS,CAAC+D,OAAO,CAAC,uBAAuB,CAAC,EAAE;QAC/D8O,YAAY,CAACtD,MAAM,GAAGvP,SAAS,CAAC+D,OAAO,CAAC,oBAAoB,CAAC;OAChE,MAAM,IAAI6O,MAAI,CAACtK,sBAAsB,CAAC1F,OAAO,CAAC,EAAE;QAC7CiQ,YAAY,CAACtD,MAAM,GAAG3O,SAAS,CAACmS,UAAU,EAAE,GACtC/S,SAAS,CAAC+D,OAAO,CAAC,qBAAqB,CAAC,GACxC/D,SAAS,CAAC+D,OAAO,CAAC,oBAAoB,CAAC;OAChD,MAAM;QACH8O,YAAY,CAACtD,MAAM,GAAGvP,SAAS,CAAC+D,OAAO,CAAC,YAAY,CAAC;;MAGzD,IAAI,OAAOsE,KAAK,KAAK,QAAQ,IAAI,SAAS,IAAIA,KAAK,IAAI,OAAOA,KAAK,CAACuH,OAAO,KAAK,WAAW,EAAE;QACzFiD,YAAY,CAACjD,OAAO,GAAGvH,KAAK,CAACuH,OAAO;OACvC,MAAM,IAAIvH,KAAK,YAAYrH,aAAa,EAAE;QACvC,IAAIqH,KAAK,CAAC2K,YAAY,EAAE;UACpBH,YAAY,CAACjQ,OAAO,GAAG,MAAMiQ,YAAY,CAACjQ,OAAO,mDAAmD;;QAGxG,MAAMqQ,aAAa,GAAG5K,KAAK,CAAC4K,aAAa;QAEzCJ,YAAY,CAACjD,OAAO,GAAG,CAAC5P,SAAS,CAAC+D,OAAO,CAAC,SAAS,CAAC,CAAC;QAErD,IAAIkP,aAAa,aAAbA,aAAa,eAAbA,aAAa,CAAEC,iBAAiB,EAAE,EAAE;UACpCL,YAAY,CAACjD,OAAO,CAAC7J,IAAI,CAAC;YACtBuM,IAAI,EAAEtS,SAAS,CAAC+D,OAAO,CAAC,qBAAqB,CAAC;YAC9C8N,OAAO,EAAEA,CAAA,KAAM5Q,eAAe,CAACkS,OAAO,CAAC;cACnCF,aAAa;cACbG,OAAO,EAAEP,YAAY,CAACtD,MAAM;cAC5B3M,OAAO,EAAE,GAAGyF,KAAK,CAACgL,SAAS,OAAOhL,KAAK,CAAC2K,YAAY;aACvD;WACJ,CAAC;;OAET,MAAM;QACHH,YAAY,CAACjD,OAAO,GAAG,CAAC5P,SAAS,CAAC+D,OAAO,CAAC,SAAS,CAAC,CAAC;;MAGzD,MAAMuP,YAAY,SAASV,MAAI,CAACjD,oBAAoB,CAACkD,YAAY,EAAEpD,aAAa,CAAC;MAEjF,IAAIpH,KAAK,YAAYrH,aAAa,IAAIqH,KAAK,CAAC2K,YAAY,EAAE;QACtD,MAAMO,gBAAgB,GAAGD,YAAY,CAACzL,aAAa,CAAC,4BAA4B,CAAC;QAEjF,IAAI0L,gBAAgB,EAAE;UAClBA,gBAAgB,CAAC5O,SAAS,GAAGzD,sBAAsB,CAACsS,MAAM,CAACnL,KAAK,CAAC2K,YAAY,EAAE3K,KAAK,CAACgL,SAAS,CAAC;;;MAIvG,OAAOC,YAAY;IAAC;EACxB;EAEA;;;;;;;;;EASMG,qBAAqBA,CACvBpL,KAAmB,EACnBqL,YAAoB,EACpB7K,cAAc,GAAG,KAAK,EACtB4G,aAAsB;IAAA,IAAAkE,MAAA;IAAA,OAAApR,iBAAA;MAEtB,IAAIoR,MAAI,CAAC5J,eAAe,CAAC1B,KAAK,CAAC,IAAIsL,MAAI,CAACtK,aAAa,CAAChB,KAAK,CAAC,EAAE;QAC1D;QACA,OAAO,IAAI;;MAGf,IAAIU,YAAY,GAAGV,KAAK,IAAInE,SAAS;MAErC,IAAImE,KAAK,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;QACnCU,YAAY,GAAGxJ,aAAa,CAAC+J,wBAAwB,CAACjB,KAAK,CAAC;;MAGhE,OAAOsL,MAAI,CAAChB,cAAc,CACtB,OAAO5J,YAAY,IAAI,QAAQ,IAAIA,YAAY,IAAIV,KAAK,GAAGA,KAAK,GAAGqL,YAAY,EAC/E7K,cAAc,EACd4G,aAAa,CAChB;IAAC;EACN;EAEA;;;;;;;;;EASAmE,0BAA0BA,CACtBC,QAAiC,EACjCH,YAAoB,EACpB7K,cAAwB,EACxB4G,aAAsB;IAEtB,OAAO,IAAI,CAACgE,qBAAqB,CAACI,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAG,CAAC,CAAC,EAAEH,YAAY,EAAE7K,cAAc,EAAE4G,aAAa,CAAC;EACjG;EAEA;;;;;;;;;;;;EAYMqE,gBAAgBA,CAACxB,IAAa,EAAEzJ,cAAwB;IAAA,IAAAkL,MAAA;IAAA,OAAAxR,iBAAA;MAC1D,IAAI,CAAC+P,IAAI,EAAE;QACPA,IAAI,GAAGtS,SAAS,CAAC+D,OAAO,CAAC,cAAc,CAAC;OAC3C,MAAM,IAAI8E,cAAc,EAAE;QACvByJ,IAAI,GAAGtS,SAAS,CAAC+D,OAAO,CAACuO,IAAI,CAAC;;MAGlC,MAAM0B,OAAO,GAAG,IAAIrU,qBAAqB,CAAC2S,IAAI,CAAC;MAE/C0B,OAAO,CAACC,SAAS,CAAC,MAAK;QACnB,MAAMC,KAAK,GAAGH,MAAI,CAAC7R,mBAAmB,CAACqF,OAAO,CAACyM,OAAO,CAAC;QAEvD,IAAIE,KAAK,KAAK,CAAC,CAAC,EAAE;UACdH,MAAI,CAAC7R,mBAAmB,CAACiS,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;;MAEjD,CAAC,CAAC;MAEFH,MAAI,CAAC7R,mBAAmB,CAAC6D,IAAI,CAACiO,OAAO,CAAC;MAEtC,MAAMA,OAAO,CAAC/C,OAAO,EAAE;MAEvB,OAAO+C,OAAO;IAAC;EACnB;EAEA;;;;;;;;EAQMI,mBAAmBA,CAAI9B,IAAY,EAAEzJ,cAAuB,EAAEwL,SAA2B;IAAA,IAAAC,MAAA;IAAA,OAAA/R,iBAAA;MAC3F,MAAMwO,KAAK,SAASuD,MAAI,CAACR,gBAAgB,CAACxB,IAAI,EAAEzJ,cAAc,CAAC;MAE/D,IAAI;QACA,aAAawL,SAAS,EAAE;OAC3B,CAAC,OAAOhM,KAAK,EAAE;QACZqC,YAAY,CAACiI,cAAc,CAACtK,KAAK,CAAC;QAElC,OAAO,IAAI;OACd,SAAS;QACN0I,KAAK,CAACS,OAAO,EAAE;;IAClB;EACL;EAEA;;;;;;;EAOM+C,0BAA0BA,CAAC3R,OAAe,EAAE4R,IAAa;IAAA,IAAAC,OAAA;IAAA,OAAAlS,iBAAA;MAC3D,MAAMqN,OAAO,GAAkB,CAAC;QAC5B0C,IAAI,EAAEtS,SAAS,CAAC+D,OAAO,CAAC,SAAS,CAAC;QAClC+N,IAAI,EAAE;OACT,CAAC;MAEF,IAAI0C,IAAI,EAAE;QACN5E,OAAO,CAAC7J,IAAI,CAAC;UACTuM,IAAI,EAAEtS,SAAS,CAAC+D,OAAO,CAAC,eAAe,CAAC;UACxC8N,OAAO,EAAEA,CAAA,KAAW;YAChBpS,SAAS,CAACiV,aAAa,CAACF,IAAI,EAAE;cAAEG,kBAAkB,EAAE;YAAK,CAAE,CAAC;UAChE;SACH,CAAC;;MAGN,MAAMpE,KAAK,SAASkE,OAAI,CAAC9E,oBAAoB,CAAC;QAC1C/M,OAAO,EAAEA,OAAO;QAChBgN,OAAO,EAAEA;OACZ,CAAC;MAEF,MAAMgF,QAAQ,GAAGzT,YAAY,CAACqC,SAAS,EAAE,IAAIrC,YAAY,CAAC0T,KAAK,EAAE;MACjE,IAAI,CAACD,QAAQ,EAAE;QACX;QACA,MAAMzD,cAAc,GAAuBZ,KAAK,CAAC1I,aAAa,CAAC,gBAAgB,CAAC;QAChFsJ,cAAc,IAAIsD,OAAI,CAACrD,YAAY,CAACD,cAAc,CAAC;;MAGvD,MAAMZ,KAAK,CAACc,YAAY,EAAE;IAAC;EAC/B;EAEA;;;;;;;;;;;EAWAyD,UAAUA,CACNlS,OAAe,EACf2M,MAAe,EACfwF,kBAA2B,EAC3BrL,IAAA,GAA2D,UAAU,EACrEkG,OAAmE,EACnEC,OAAA,GAAwB,EAAE;IAE1B,OAAO,IAAIc,OAAO,CAAC,CAACyB,OAAO,EAAEC,MAAM,KAAI;MAAA,IAAA2C,mBAAA;MACnCD,kBAAkB,IAAAC,mBAAA,GAAGD,kBAAkB,cAAAC,mBAAA,cAAAA,mBAAA,GAAIhV,SAAS,CAAC+D,OAAO,CAAC,qBAAqB,CAAC;MAEnF,MAAMkR,UAAU,GAAGvL,IAAI,KAAK,UAAU;MACtC,MAAMwL,OAAO,GAAGxL,IAAI,KAAK,OAAO;MAEhC;MACA,MAAMyL,cAAc,GAAIzC,IAAS,IAAI;QACjC,IAAIuC,UAAU,EAAE;UACZ7C,OAAO,CAACM,IAAI,CAAC,CAAC,CAAC,CAAC;SACnB,MAAM,IAAIwC,OAAO,EAAE;UAChB9C,OAAO,CAACM,IAAI,CAAC;SAChB,MAAM;UACHN,OAAO,CAACM,IAAI,CAAC0C,WAAW,CAAC;;MAEjC,CAAC;MAEDvF,OAAO,CAACN,MAAM,GAAGA,MAAM;MACvBM,OAAO,CAACjN,OAAO,GAAGA,OAAO;MACzBiN,OAAO,CAACwF,MAAM,GAAG,CACb;QACI5O,IAAI,EAAE,aAAa;QACnB6O,WAAW,EAAEP,kBAAkB;QAC/BQ,KAAK,EAAER,kBAAkB;QACzBrL,IAAI;QACJ2F,KAAK,EAAG4F,UAAU,IAAIC,OAAO,GAAI,IAAI,GAAGhR;OAC3C,CACJ;MAED,IAAIkC,KAAK,CAACoP,OAAO,CAAC5F,OAAO,CAAC,IAAIA,OAAO,CAAC/C,MAAM,EAAE;QAC1CgD,OAAO,CAACD,OAAO,GAAGA,OAAO,CAACtC,GAAG,CAAEsE,MAAM,IAAA6D,aAAA,CAAAA,aAAA,KAC9B7D,MAAM;UACTC,OAAO,EAAGa,IAAI,IAAI;YACd,IAAI,CAACd,MAAM,CAACC,OAAO,EAAE;cACjB;cACAsD,cAAc,CAACzC,IAAI,CAAC;cAEpB;;YAGJd,MAAM,CAACC,OAAO,CAACa,IAAI,EAAEN,OAAO,EAAEC,MAAM,CAAC;UACzC;QAAC,EACH,CAAC;OACN,MAAM;QACH;QACAxC,OAAO,CAACD,OAAO,GAAG,CACd;UACI0C,IAAI,EAAE1C,OAAO,IAAI,YAAY,IAAIA,OAAO,GAClCA,OAAO,CAAC6C,UAAoB,GAC5BzS,SAAS,CAAC+D,OAAO,CAAC,aAAa,CAAC;UACtC+N,IAAI,EAAE,QAAQ;UACdD,OAAO,EAAEA,CAAA,KAAK;YACVQ,MAAM,EAAE;UACZ;SACH,EACD;UACIC,IAAI,EAAE1C,OAAO,IAAI,QAAQ,IAAIA,OAAO,GAC9BA,OAAO,CAAC4C,MAAgB,GACxBxS,SAAS,CAAC+D,OAAO,CAAC,SAAS,CAAC;UAClC8N,OAAO,EAAEsD;SACZ,CACJ;;MAGL,IAAI,CAACxF,oBAAoB,CAACE,OAAO,CAAC;IACtC,CAAC,CAAC;EACN;EAEA;;;;;;;;;EASM6F,kBAAkBA,CACpB5C,KAAa,EACblQ,OAAe,EACfgN,OAAsB,EACtB0F,WAAoB;IAAA,OAAA/S,iBAAA;MAAA,IAAAoT,YAAA;MAEpB,MAAMpF,KAAK,SAAStQ,eAAe,CAACuQ,MAAM,CAAC;QACvCjB,MAAM,EAAEuD,KAAK;QACblQ,OAAO;QACPyS,MAAM,EAAE,CACJ;UACI5O,IAAI,EAAE,iBAAiB;UACvBiD,IAAI,EAAE,UAAU;UAChB4L,WAAW,EAAEA;SAChB,CACJ;QACD1F;OACH,CAAC;MAEF,MAAMW,KAAK,CAACU,OAAO,EAAE;MAErB,MAAM2E,MAAM,SAASrF,KAAK,CAACsF,aAAa,EAAE;MAE1C,IAAID,MAAM,CAAC9D,IAAI,KAAK,QAAQ,EAAE;QAC1B;;MAGJ,QAAA6D,YAAA,GAAOC,MAAM,CAAClD,IAAI,cAAAiD,YAAA,gBAAAA,YAAA,GAAXA,YAAA,CAAaG,MAAM,cAAAH,YAAA,uBAAnBA,YAAA,CAAsB,iBAAiB,CAAC;IAAC;EACpD;EAEA;;;;;;;;;EASMI,SAASA,CACXzD,IAAY,EACZzJ,cAAwB,EACxBmN,QAAA,GAAmCC,aAAa,CAACC,KAAK,EACtD3D,QAAA,GAAmB,EAAE;IAAA,IAAA4D,OAAA;IAAA,OAAA5T,iBAAA;MAErB,IAAIsG,cAAc,EAAE;QAChByJ,IAAI,GAAGtS,SAAS,CAAC+D,OAAO,CAACuO,IAAI,CAAC;;MAGlC,OAAO6D,OAAI,CAACC,oBAAoB,CAAC;QAC7BxT,OAAO,EAAE0P,IAAI;QACb0D,QAAQ,EAAEA,QAAQ;QAClBK,QAAQ,EAAE,QAAQ;QAClB9D,QAAQ,EAAEA;OACb,CAAC;IAAC;EACP;EAEA;;;;;;EAMM6D,oBAAoBA,CAACvG,OAAyB;IAAA,OAAAtN,iBAAA;MAAA,IAAA+T,KAAA,EAAAC,qBAAA,EAAAC,iBAAA;MAChD;MACA,MAAMC,YAAY,GAAAhB,aAAA,CAAAA,aAAA,KACX5F,OAAO;QACVmG,QAAQ,GAAAM,KAAA,IAAAC,qBAAA,GAAE7W,aAAa,CAACgX,MAAM,CAACC,cAAc,CAAC9G,OAAO,CAACmG,QAAQ,CAAC,cAAAO,qBAAA,cAAAA,qBAAA,GAAI1G,OAAO,CAACmG,QAAQ,cAAAM,KAAA,cAAAA,KAAA,GAAI,IAAI;QAC3FD,QAAQ,GAAAG,iBAAA,GAAE3G,OAAO,CAACwG,QAAQ,cAAAG,iBAAA,cAAAA,iBAAA,GAAI;MAAQ,EACzC;MAED,MAAMI,MAAM,SAAS1W,eAAe,CAACsQ,MAAM,CAACiG,YAAY,CAAC;MAEzD,MAAMG,MAAM,CAAC3F,OAAO,EAAE;MAEtB,OAAO2F,MAAM;IAAC;EAClB;EAEA;;;;;;EAMAzP,qBAAqBA,CAACgD,EAAe;IACjC,OAAOA,EAAE,IACL,CAAqBA,EAAG,CAAC0M,QAAQ,KAChC1M,EAAE,CAACgE,OAAO,CAAC2I,WAAW,EAAE,IAAI,UAAU,IAClC3M,EAAE,CAACgE,OAAO,CAAC2I,WAAW,EAAE,IAAI,OAAO,IAAI,IAAI,CAACnV,sBAAsB,CAAC4F,OAAO,CAAqB4C,EAAG,CAACT,IAAI,CAAC,IAAI,CAAC,CAAE,CAAC;EAC7H;EAEA;;;;;;EAMAqN,KAAKA,CAACzE,IAAY;IACd,MAAMnM,OAAO,GAAG,IAAI,CAAC1B,gBAAgB,CAAC6N,IAAI,CAAC;IAE3C,OAAOnM,OAAO,CAACtB,QAAQ;EAC3B;EAEA;;;;;EAKAuM,YAAYA,CAAC4F,SAAsB;IAC/B,MAAM3I,OAAO,GAAGjI,KAAK,CAACC,IAAI,CAAC2Q,SAAS,CAAC9M,gBAAgB,CAAC,GAAG,CAAC,CAAC;IAE3DmE,OAAO,CAACxI,OAAO,CAAEyI,MAAM,IAAI;MACvBA,MAAM,CAAC/D,gBAAgB,CAAC,OAAO,EAAGO,KAAK,IAAI;QACvC,IAAIA,KAAK,CAACmM,gBAAgB,EAAE;UACxB;UACA;;QAGJ,MAAMC,IAAI,GAAG5I,MAAM,CAACtG,YAAY,CAAC,MAAM,CAAC;QACxC,IAAIkP,IAAI,EAAE;UACNpM,KAAK,CAACqM,cAAc,EAAE;UACtBrM,KAAK,CAACsM,eAAe,EAAE;UAEvB3X,SAAS,CAACiV,aAAa,CAACwC,IAAI,CAAC;;MAErC,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA;;;;;;EAMMG,SAASA,CACXxH,OAAyB;IAAA,IAAAyH,OAAA;IAAA,OAAA/U,iBAAA;MAAA,IAAAgV,kBAAA,EAAAC,gBAAA;MAEzB,MAAM;UAAEC,uBAAuB;UAAEC;QAAgC,CAAE,GAAG7H,OAAO;QAAxB8H,YAAY,GAAAC,wBAAA,CAAK/H,OAAO,EAAAgI,SAAA;MAC7E,MAAMC,iBAAiB,GAAGJ,eAAe,aAAfA,eAAe,cAAfA,eAAe,GAAI,IAAI,CAAC,CAAC;MAEnD;MACA,MAAMK,OAAO,GAAY5Y,GAAG,CAACmR,YAAY,CAAC,EAAAiH,kBAAA,GAAA1H,OAAO,CAACjF,SAAS,cAAA2M,kBAAA,uBAAjBA,kBAAA,CAAmBS,QAAQ,EAAE,KAAI,EAAE,CAAC;MAE9E,MAAMjH,KAAK,GAAGuG,OAAI,CAACrV,eAAe,CAAC8V,OAAO,CAAC,GACrCT,OAAI,CAACrV,eAAe,CAAC8V,OAAO,CAAC,SACvB3X,eAAe,CAACoQ,MAAM,CAACmH,YAAY,CAAC;MAEhD,IAAIM,eAAyC;MAE7C;MACA,MAAMC,aAAa,GAAGT,uBAAuB,GAAG1G,KAAK,CAACM,YAAY,EAAK,GAAGN,KAAK,CAAC8E,aAAa,EAAK;MAElG,IAAI,CAACyB,OAAI,CAACrV,eAAe,CAAC8V,OAAO,CAAC,EAAE;QAChC;QACAT,OAAI,CAACrV,eAAe,CAAC8V,OAAO,CAAC,GAAGhH,KAAK;QAErC,IAAI+G,iBAAiB,EAAE;UACnB;UACAG,eAAe,GAAG5X,MAAM,CAAC8X,MAAM,CAC1BC,IAAI,CAACtX,MAAM,CAACgK,KAAK,IAAIA,KAAK,YAAYjK,eAAe,CAAC,CAAC,CACvDwX,SAAS,eAAA9V,iBAAA,CAAC,aAAW;YAClBwO,KAAK,CAACS,OAAO,EAAE;UACnB,CAAC,EAAC;;QAGV,MAAMT,KAAK,CAACE,OAAO,EAAE;;MAGzB,MAAM2E,MAAM,SAASsC,aAAa;MAElC,CAAAV,gBAAA,GAAAS,eAAe,cAAAT,gBAAA,eAAfA,gBAAA,CAAiBc,WAAW,EAAE;MAC9B,OAAOhB,OAAI,CAACrV,eAAe,CAAC8V,OAAO,CAAC;MAEpC,IAAInC,MAAM,aAANA,MAAM,eAANA,MAAM,CAAElD,IAAI,EAAE;QACd,OAAOkD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAElD,IAAI;;IACtB;EACL;EAEA;;;;;;EAMM6F,aAAaA,CACf1I,OAAyB;IAAA,IAAA2I,OAAA;IAAA,OAAAjW,iBAAA;MAGzBsN,OAAO,GAAGY,MAAM,CAACgI,MAAM,CAAC;QACpBlG,QAAQ,EAAE,oBAAoB;QAC9BmG,YAAY,EAAE,IAAI;QAClBC,eAAe,EAAE,IAAI;QACrBC,cAAc,EAAElY,+BAA+B;QAC/CmY,cAAc,EAAElY;OACnB,EAAEkP,OAAO,CAAC;MAEX,OAAO2I,OAAI,CAACnB,SAAS,CAAIxH,OAAO,CAAC;IAAC;EACtC;EAEA;;;;;;EAMMlF,WAAWA,CAAWkF,OAA2B;IAAA,OAAAtN,iBAAA;MAEnD,MAAM;UAAEkV;QAA0C,CAAE,GAAG5H,OAAO;QAA1BiJ,cAAc,GAAAlB,wBAAA,CAAK/H,OAAO,EAAAkJ,UAAA;MAC9D,MAAMC,OAAO,SAAS7Y,iBAAiB,CAACqQ,MAAM,CAACsI,cAAc,CAAC;MAC9D,MAAMG,SAAS,SAAS5Z,UAAU,CAACmD,GAAG,CAAC9C,aAAa,CAACwZ,mBAAmB,EAAExZ,aAAa,CAACgX,MAAM,CAACyC,gBAAgB,CAAC;MAEhH,MAAMH,OAAO,CAAC/H,OAAO,EAAE;MAEvB;MACA,IAAIgI,SAAS,sCAAyB;QAClC,QAAQ/Z,OAAO,EAAE;UACb,KAAK,KAAK;YACNka,qBAAqB,CAACJ,OAAO,EAAEnJ,OAAO,CAAC/E,KAAK,CAAC;YAC7C;UACJ,KAAK,IAAI;YACLuO,oBAAoB,CAACL,OAAO,EAAEnJ,OAAO,CAAC/E,KAAK,CAAC;YAC5C;;;MAIZ,MAAM8K,MAAM,GAAG6B,uBAAuB,SAASuB,OAAO,CAAC3H,YAAY,EAAK,SAAS2H,OAAO,CAACnD,aAAa,EAAK;MAC3G,IAAID,MAAM,aAANA,MAAM,eAANA,MAAM,CAAElD,IAAI,EAAE;QACd,OAAOkD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAElD,IAAI;;IACtB;EACL;EAEA;;;;;;EAMM4G,cAAcA,CAAsCC,cAAwC;IAAA,OAAAhX,iBAAA;MAC9F,MAAM;QAAEiX;MAA0B,CAAE,SAC1B,MAAM,CAAC,wDAAwD,CAAC;MAE1E,MAAMC,SAAS,SAAS/O,YAAY,CAAC2M,SAAS,CAC1C;QACI9E,QAAQ,EAAE,qBAAqB;QAC/BmG,YAAY,EAAE,IAAI;QAClBC,eAAe,EAAE,IAAI;QACrB/N,SAAS,EAAE4O,0BAA0B;QACrC3O,cAAc,EAAE0O;OACnB,CACJ;MAED,IAAIE,SAAS,KAAKvV,SAAS,EAAE;QACzB,MAAM,IAAItE,iBAAiB,EAAE;OAChC,MAAM,IAAI6Z,SAAS,YAAYnY,WAAW,EAAE;QACzC,MAAMmY,SAAS;;MAGnB,OAAOA,SAAS;IAAC;EACrB;EAEA;;;;;;;;EAQMC,SAASA,CACXC,KAAa,EACb7G,KAAqB,EACrBlI,SAAkB,EAClBgP,WAA6B;IAAA,OAAArX,iBAAA;MAE7B,IAAI,CAACoX,KAAK,EAAE;QACR;;MAGJ,MAAMjP,YAAY,CAAC2M,SAAS,CAAC;QACzBzM,SAAS,EAAEnK,wBAAwB;QACnCoK,cAAc,EAAE;UACZiI,KAAK;UACL6G,KAAK;UACL/O,SAAS;UACTgP;SACH;QACDrH,QAAQ,EAAE;OACb,CAAC;IAAC;EAEP;EAEA;;;;;;EAMAsH,aAAaA,CAAC1T,OAAoB;IAC9B,MAAM2T,IAAI,GAAG1T,KAAK,CAACC,IAAI,CAACF,OAAO,CAAC+D,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAExD,IAAI4P,IAAI,CAACjN,MAAM,KAAK,CAAC,EAAE;MACnB,OAAOzL,sBAAsB,CAACgR,OAAO,CAAC,KAAK,CAAC;;IAGhD,IAAI2H,eAAe,GAAG,CAAC;IACvB,IAAIC,eAAe,GAAG,KAAK;IAC3B,MAAMC,SAAS,GAAoC,IAAIC,OAAO,EAAE;IAChE,MAAMC,cAAc,GAAI/H,OAAkC,IAAI;MAC1D2H,eAAe,EAAE;MAEjB,IAAIA,eAAe,KAAKD,IAAI,CAACjN,MAAM,EAAE;QACjCuF,OAAO,CAAC4H,eAAe,CAAC;;IAEhC,CAAC;IAED,OAAO,IAAI5Y,sBAAsB,CAC7BgR,OAAO,IAAG;MACN,KAAK,MAAMgI,GAAG,IAAIN,IAAI,EAAE;QACpB,IAAI,CAACM,GAAG,IAAIA,GAAG,CAACC,QAAQ,EAAE;UACtBF,cAAc,CAAC/H,OAAO,CAAC;UAEvB;;QAGJ4H,eAAe,GAAG,IAAI;QAEtB;QACA,MAAMM,YAAY,GAAGA,CAAA,KAAW;UAC5BF,GAAG,CAACG,mBAAmB,CAAC,MAAM,EAAED,YAAY,CAAC;UAC7CF,GAAG,CAACG,mBAAmB,CAAC,OAAO,EAAED,YAAY,CAAC;UAE9CH,cAAc,CAAC/H,OAAO,CAAC;QAC3B,CAAC;QAEDgI,GAAG,CAAC7P,gBAAgB,CAAC,MAAM,EAAE+P,YAAY,CAAC;QAC1CF,GAAG,CAAC7P,gBAAgB,CAAC,OAAO,EAAE+P,YAAY,CAAC;QAE3CL,SAAS,CAACO,GAAG,CAACJ,GAAG,EAAEE,YAAY,CAAC;;IAExC,CAAC,EACD,MAAK;MACDR,IAAI,CAACjU,OAAO,CAACuU,GAAG,IAAG;QACf,MAAMK,QAAQ,GAAGR,SAAS,CAACzX,GAAG,CAAC4X,GAAG,CAAC;QAEnC,IAAI,CAACK,QAAQ,EAAE;UACX;;QAGJL,GAAG,CAACG,mBAAmB,CAAC,MAAM,EAAEE,QAAQ,CAAC;QACzCL,GAAG,CAACG,mBAAmB,CAAC,OAAO,EAAEE,QAAQ,CAAC;MAC9C,CAAC,CAAC;IACN,CAAC,CACJ;EACL;EAEA;;;;;;EAMAC,WAAWA,CAACvQ,EAAe,EAAEwQ,OAAoB;IAAA,IAAAC,cAAA;IAC7C;IACA,CAAAA,cAAA,GAAAzQ,EAAE,CAAC0Q,UAAU,cAAAD,cAAA,eAAbA,cAAA,CAAe7N,YAAY,CAAC4N,OAAO,EAAExQ,EAAE,CAAC;IACxC;IACAwQ,OAAO,CAACG,WAAW,CAAC3Q,EAAE,CAAC;EAC3B;EAEA;;;;;;;;;EASM4Q,iBAAiBA,CAACC,WAAoB,EAAEC,YAAqB,EAAEpU,OAAO,GAAG,CAAC;IAAA,IAAAqU,OAAA;IAAA,OAAA3Y,iBAAA;MAC5E,IAAI,CAACpB,YAAY,CAAC0T,KAAK,EAAE,EAAE;QACvB,OAAO,CAAC;;;MAGZmG,WAAW,GAAGA,WAAW,IAAIhP,MAAM,CAACmP,UAAU;MAC9CF,YAAY,GAAGA,YAAY,IAAIjP,MAAM,CAACC,WAAW;MAEjD,IAAI+O,WAAW,IAAIhP,MAAM,CAACmP,UAAU,IAAIF,YAAY,IAAIjP,MAAM,CAACC,WAAW,IAAIpF,OAAO,IAAI,EAAE,EAAE;QACzF;QACA;;MAGJ;MACA,MAAMpH,SAAS,CAAC4H,IAAI,CAAC,EAAE,CAAC;MAExB,OAAO6T,OAAI,CAACH,iBAAiB,CAACC,WAAW,EAAEC,YAAY,EAAEpU,OAAO,GAAC,CAAC,CAAC;IAAC;EACxE;EAEA;;;;;;EAMAuU,YAAYA,CAAC3N,SAAiB;IAC1B,OAAO5L,QAAQ,CAACwZ,eAAe,CAACC,SAAS,CAACC,QAAQ,CAAC9N,SAAS,CAAC;EACjE;EAEA;;;;;EAKA+N,cAAcA,CAAA;IACV,OAAOpV,KAAK,CAACC,IAAI,CAACxE,QAAQ,CAACwZ,eAAe,CAACC,SAAS,CAAC;EACzD;EAEA;;;;;;;EAOAG,eAAeA,CACXhO,SAAiB,EACjBiO,MAAM,GAAG,KAAK,EACd7L,OAAA,GAAsC;IAAE8L,aAAa,EAAE;EAAK,CAAE;IAE9D9Z,QAAQ,CAACwZ,eAAe,CAACC,SAAS,CAACM,MAAM,CAACnO,SAAS,EAAEiO,MAAM,CAAC;IAE5D;IACA7Z,QAAQ,CAACga,IAAI,CAACP,SAAS,CAACM,MAAM,CAACnO,SAAS,EAAEiO,MAAM,IAAI7L,OAAO,CAAC8L,aAAa,CAAC;EAC9E;;AAIJ;;;;;;;;;;;;;;AAAAG,MAAA,GAtpData,oBAAoB;;mBAApBA,MAAoB;AAAA;;SAApBA,MAAoB;EAAAua,OAAA,EAApBva,MAAoB,CAAAwa,IAAA;EAAAC,UAAA,EADP;AAAM;AAqqDhC,SAAS7C,qBAAqBA,CAAC8C,MAAmB,EAAEzR,EAAU;EAC1D,IAAI0R,OAAO,GAAG,KAAK;EACnB,IAAIC,OAAO,GAAG,MAAM;EAEpB,MAAMC,wBAAwB,GAAG,CAAC;EAClC,MAAMC,SAAS,GAAGJ,MAAM,CAACrU,aAAa,CAAC,kBAAkB,CAAgB;EACzE,MAAM0U,iBAAiB,GAAGD,SAAS,CAAChR,qBAAqB,EAAE;EAC3D,MAAMkR,YAAY,GAAGD,iBAAiB,CAACE,KAAK;EAC5C,MAAMC,aAAa,GAAGH,iBAAiB,CAACI,MAAM;EAC9C,MAAMC,SAAS,GAAG/a,QAAQ,CAACga,IAAI,CAACgB,WAAW;EAC3C,MAAMC,UAAU,GAAGjb,QAAQ,CAACga,IAAI,CAACjN,YAAY;EAC7C,MAAMmO,SAAS,GAAGtS,EAAE,IAAIA,EAAE,CAACuS,MAAM,IAAKvS,EAAE,CAACuS,MAAsB,CAAC1R,qBAAqB,EAAE;EACvF,MAAM2R,SAAS,GAAGF,SAAS,IAAI,IAAI,IAAI,KAAK,IAAIA,SAAS,GAAGA,SAAS,CAACtR,GAAG,GAAGqR,UAAU,GAAG,CAAC,GAAGJ,aAAa,GAAG,CAAC;EAC9G,MAAMQ,UAAU,GAAGH,SAAS,IAAI,IAAI,IAAI,MAAM,IAAIA,SAAS,GAAGA,SAAS,CAACI,IAAI,GAAGP,SAAS,GAAG,CAAC;EAC5F,MAAMQ,WAAW,GAAIL,SAAS,IAAIA,SAAS,CAACN,KAAK,IAAK,CAAC;EACvD,MAAMY,YAAY,GAAIN,SAAS,IAAIA,SAAS,CAACJ,MAAM,IAAK,CAAC;EACzD,MAAMW,OAAO,GAAGpB,MAAM,CAACrU,aAAa,CAAC,gBAAgB,CAAgB;EACrE,MAAM0V,QAAQ,GAAGD,OAAO,CAAChS,qBAAqB,EAAE;EAChD,MAAMkS,UAAU,GAAGD,QAAQ,CAACd,KAAK;EACjC,MAAMgB,WAAW,GAAGF,QAAQ,CAACZ,MAAM;EAEnC,IAAII,SAAS,IAAI,IAAI,EAAE;IACnBO,OAAO,CAACpV,KAAK,CAACwV,OAAO,GAAG,MAAM;;EAGlC,MAAMC,QAAQ,GAAG;IACblS,GAAG,EAAEwR,SAAS,GAAGI,YAAY;IAC7BF,IAAI,EAAED,UAAU,GAAGE,WAAW,GAAG,CAAC,GAAGI,UAAU,GAAG;GACrD;EAED,MAAMI,UAAU,GAAkC;IAC9CnS,GAAG,EAAEwR,SAAS,GAAGI,YAAY,IAAII,WAAW,GAAG,CAAC,CAAC;IACjDN,IAAI,EAAED,UAAU,GAAGE,WAAW,GAAG,CAAC,GAAGZ,YAAY,GAAG;GACvD;EAED,IAAIqB,iBAAiB,GAAG,KAAK;EAC7B,IAAIC,kBAAkB,GAAG,KAAK;EAE9B,IAAIF,UAAU,CAACT,IAAI,GAAGd,wBAAwB,GAAG,EAAE,EAAE;IACjDwB,iBAAiB,GAAG,IAAI;IACxBD,UAAU,CAACT,IAAI,GAAGd,wBAAwB;GAC7C,MAAM,IACHG,YAAY,GAAGH,wBAAwB,GAAGuB,UAAU,CAACT,IAAI,GAAG,EAAE,GAAGP,SAAS,EAC5E;IACEkB,kBAAkB,GAAG,IAAI;IACzBF,UAAU,CAACT,IAAI,GAAGP,SAAS,GAAGJ,YAAY,GAAGH,wBAAwB;IACrED,OAAO,GAAG,OAAO;;EAGrB,IAAIa,SAAS,GAAGI,YAAY,GAAGX,aAAa,GAAGI,UAAU,IAAIG,SAAS,GAAGP,aAAa,GAAG,CAAC,EAAE;IACxFiB,QAAQ,CAAClS,GAAG,GAAGwR,SAAS,IAAIQ,WAAW,GAAG,CAAC,CAAC;IAC5CG,UAAU,CAACnS,GAAG,GAAGwR,SAAS,GAAGP,aAAa,IAAIe,WAAW,GAAG,CAAC,CAAC;IAE9DvB,MAAM,CAACzO,SAAS,GAAGyO,MAAM,CAACzO,SAAS,GAAG,iBAAiB;IACvD0O,OAAO,GAAG,QAAQ;GACrB,MAAM,IAAIc,SAAS,GAAGI,YAAY,GAAGX,aAAa,GAAGI,UAAU,EAAE;IAC9DR,SAAS,CAACpU,KAAK,CAACyD,MAAM,GAAG0Q,wBAAwB,GAAG,GAAG;;EAG3DiB,OAAO,CAACpV,KAAK,CAACuD,GAAG,GAAGkS,QAAQ,CAAClS,GAAG,GAAG,IAAI;EACvC6R,OAAO,CAACpV,KAAK,CAACiV,IAAI,GAAGQ,QAAQ,CAACR,IAAI,GAAG,IAAI;EAEzCb,SAAS,CAACpU,KAAK,CAACuD,GAAG,GAAGmS,UAAU,CAACnS,GAAG,GAAG,IAAI;EAC3C6Q,SAAS,CAACpU,KAAK,CAACiV,IAAI,GAAGS,UAAU,CAACT,IAAI,GAAG,IAAI;EAE7C,IAAIU,iBAAiB,EAAE;IACnBvB,SAAS,CAACpU,KAAK,CAACiV,IAAI,GAAG,QAAQS,UAAU,CAACT,IAAI,sCAAsC;;EAGxF,IAAIW,kBAAkB,EAAE;IACpBxB,SAAS,CAACpU,KAAK,CAACiV,IAAI,GAAG,QAAQS,UAAU,CAACT,IAAI,uCAAuC;;EAGzFb,SAAS,CAACpU,KAAK,CAAC6V,eAAe,GAAG5B,OAAO,GAAG,GAAG,GAAGC,OAAO;AAC7D;AAEA;;;;;;;;;;;;;;AAcA,SAAS/C,oBAAoBA,CAAC6C,MAAmB,EAAEzR,EAAU;EACzD,MAAMuT,uBAAuB,GAAG,EAAE;EAClC,MAAMC,KAAK,GAAGpc,QAAQ,CAACqc,GAAG,KAAK,KAAK;EAEpC,IAAI/B,OAAO,GAAG,KAAK;EACnB,IAAIC,OAAO,GAAG6B,KAAK,GAAG,OAAO,GAAG,MAAM;EAEtC,MAAM3B,SAAS,GAAGJ,MAAM,CAACrU,aAAa,CAAC,kBAAkB,CAAgB;EACzE,MAAM0U,iBAAiB,GAAGD,SAAS,CAAChR,qBAAqB,EAAE;EAC3D,MAAMkR,YAAY,GAAGD,iBAAiB,CAACE,KAAK;EAC5C,MAAMC,aAAa,GAAGH,iBAAiB,CAACI,MAAM;EAC9C,MAAMC,SAAS,GAAG/a,QAAQ,CAACga,IAAI,CAACgB,WAAW;EAC3C,MAAMC,UAAU,GAAGjb,QAAQ,CAACga,IAAI,CAACjN,YAAY;EAC7C,MAAMmO,SAAS,GAAGtS,EAAE,IAAIA,EAAE,CAACuS,MAAM,IAAKvS,EAAE,CAACuS,MAAsB,CAAC1R,qBAAqB,EAAE;EACvF,MAAM2R,SAAS,GAAGF,SAAS,IAAI,IAAI,IAAI,QAAQ,IAAIA,SAAS,GACtDA,SAAS,CAACpR,MAAM,GAChBmR,UAAU,GAAG,CAAC,GAAGJ,aAAa,GAAG,CAAC;EACxC,MAAMQ,UAAU,GAAGH,SAAS,IAAI,IAAI,IAAI,MAAM,IAAIA,SAAS,GACrDkB,KAAK,GACDlB,SAAS,CAACI,IAAI,GAAGX,YAAY,GAAGO,SAAS,CAACN,KAAK,GAC/CM,SAAS,CAACI,IAAI,GAClBP,SAAS,GAAG,CAAC,GAAGJ,YAAY,GAAG,CAAC;EACtC,MAAMa,YAAY,GAAIN,SAAS,IAAIA,SAAS,CAACJ,MAAM,IAAK,CAAC;EACzD,MAAMiB,UAAU,GAAkC;IAC9CnS,GAAG,EAAEwR,SAAS;IACdE,IAAI,EAAED;GACT;EAED,IAAIU,UAAU,CAACT,IAAI,GAAGa,uBAAuB,EAAE;IAC3CJ,UAAU,CAACT,IAAI,GAAGa,uBAAuB;IACzC5B,OAAO,GAAG,MAAM;GACnB,MAAM,IAAII,YAAY,GAAGwB,uBAAuB,GAAGJ,UAAU,CAACT,IAAI,GAAGP,SAAS,EAAE;IAC7EgB,UAAU,CAACT,IAAI,GAAGP,SAAS,GAAGJ,YAAY,GAAGwB,uBAAuB;IACpE5B,OAAO,GAAG,OAAO;;EAGrB,IAAIa,SAAS,GAAGI,YAAY,GAAGX,aAAa,GAAGI,UAAU,IAAIG,SAAS,GAAGP,aAAa,GAAG,CAAC,EAAE;IACxFkB,UAAU,CAACnS,GAAG,GAAGwR,SAAS,GAAGP,aAAa,GAAGW,YAAY;IACzDnB,MAAM,CAACzO,SAAS,GAAGyO,MAAM,CAACzO,SAAS,GAAG,iBAAiB;IACvD0O,OAAO,GAAG,QAAQ;GACrB,MAAM,IAAIc,SAAS,GAAGI,YAAY,GAAGX,aAAa,GAAGI,UAAU,EAAE;IAC9DR,SAAS,CAACpU,KAAK,CAACyD,MAAM,GAAGqS,uBAAuB,GAAG,IAAI;;EAG3D1B,SAAS,CAACpU,KAAK,CAACuD,GAAG,GAAGmS,UAAU,CAACnS,GAAG,GAAG,IAAI;EAC3C6Q,SAAS,CAACpU,KAAK,CAACiV,IAAI,GAAGS,UAAU,CAACT,IAAI,GAAG,IAAI;EAC7Cb,SAAS,CAACpU,KAAK,CAAC6V,eAAe,GAAG5B,OAAO,GAAG,GAAG,GAAGC,OAAO;AAC7D;AAEA,OAAO,MAAM1R,YAAY,GAAG3K,aAAa,CAACyB,oBAAoB,CAAC;AAyB/D;;;AAGA,WAAY2J,aAIX;AAJD,WAAYA,aAAa;EACrBA,aAAA,eAAW;EACXA,aAAA,eAAW;EACXA,aAAA,qBAAiB;AACrB,CAAC,EAJWA,aAAa,KAAbA,aAAa;AAMzB;;;AAGA,WAAY8K,aAIX;AAJD,WAAYA,aAAa;EACrBA,aAAA,iBAAa;EACbA,aAAA,mBAAe;EACfA,aAAA,qBAAiB;AACrB,CAAC,EAJWA,aAAa,KAAbA,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}