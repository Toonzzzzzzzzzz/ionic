{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreDelegate } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreSites } from './sites';\nimport { CoreFileHelper } from './file-helper';\nimport * as i0 from \"@angular/core\";\n/**\n * Delegate to register pluginfile information handlers.\n */\nexport class CorePluginFileDelegateService extends CoreDelegate {\n  constructor() {\n    super('CorePluginFileDelegate', true);\n  }\n  /**\n   * React to a file being deleted.\n   *\n   * @param fileUrl The file URL used to download the file.\n   * @param path The path of the deleted file.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  fileDeleted(fileUrl, path, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this.getHandlerForFile({\n        fileurl: fileUrl\n      });\n      if (handler && handler.fileDeleted) {\n        yield handler.fileDeleted(fileUrl, path, siteId);\n      }\n    })();\n  }\n  /**\n   * Check whether a file can be downloaded. If so, return the file to download.\n   *\n   * @param file The file data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the file to use. Rejected if cannot download.\n   */\n  getDownloadableFile(file, siteId) {\n    const handler = this.getHandlerForFile(file);\n    return this.getHandlerDownloadableFile(file, handler, siteId);\n  }\n  /**\n   * Check whether a file can be downloaded. If so, return the file to download.\n   *\n   * @param file The file data.\n   * @param handler The handler to use.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the file to use. Rejected if cannot download.\n   */\n  getHandlerDownloadableFile(file, handler, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const isDownloadable = yield _this2.isFileDownloadable(file, siteId);\n      if (!isDownloadable.downloadable) {\n        throw isDownloadable.reason;\n      }\n      if (handler && handler.getDownloadableFile) {\n        const newFile = yield handler.getDownloadableFile(file, siteId);\n        return newFile || file;\n      }\n      return file;\n    })();\n  }\n  /**\n   * Get the RegExp of the component and filearea described in the URL.\n   *\n   * @param args Arguments of the pluginfile URL defining component and filearea at least.\n   * @returns RegExp to match the revision or undefined if not found.\n   */\n  getComponentRevisionRegExp(args) {\n    // Get handler based on component (args[1]).\n    const handler = this.getHandler(args[1], true);\n    if (handler && handler.getComponentRevisionRegExp) {\n      return handler.getComponentRevisionRegExp(args);\n    }\n  }\n  /**\n   * Given an HTML element, get the URLs of the files that should be downloaded and weren't treated by\n   * CoreFilepoolProvider.extractDownloadableFilesFromHtml.\n   *\n   * @param container Container where to get the URLs from.\n   * @returns List of URLs.\n   */\n  getDownloadableFilesFromHTML(container) {\n    let files = [];\n    for (const component in this.enabledHandlers) {\n      const handler = this.enabledHandlers[component];\n      if (handler && handler.getDownloadableFilesFromHTML) {\n        files = files.concat(handler.getDownloadableFilesFromHTML(container));\n      }\n    }\n    return files;\n  }\n  /**\n   * Sum the filesizes from a list if they are not downloaded.\n   *\n   * @param files List of files to sum its filesize.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with file size and a boolean to indicate if it is the total size or only partial.\n   */\n  getFilesDownloadSize(files, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const siteIdentifier = siteId || CoreSites.getCurrentSiteId();\n      const filteredFiles = [];\n      yield Promise.all(files.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (file) {\n          const state = yield CoreFilepool.getFileStateByUrl(siteIdentifier, CoreFileHelper.getFileUrl(file), file.timemodified);\n          if (state !== CoreConstants.DOWNLOADED && state !== CoreConstants.NOT_DOWNLOADABLE) {\n            filteredFiles.push(file);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return _this3.getFilesSize(filteredFiles, siteIdentifier);\n    })();\n  }\n  /**\n   * Sum the filesizes from a list of files checking if the size will be partial or totally calculated.\n   *\n   * @param files List of files to sum its filesize.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with file size and a boolean to indicate if it is the total size or only partial.\n   */\n  getFilesSize(files, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        size: 0,\n        total: true\n      };\n      yield Promise.all(files.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (file) {\n          const size = yield _this4.getFileSize(file, siteId);\n          if (size === undefined) {\n            // We don't have the file size, cannot calculate its total size.\n            result.total = false;\n          } else {\n            result.size += size;\n          }\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      return result;\n    })();\n  }\n  /**\n   * Get a file size.\n   *\n   * @param file The file data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the size.\n   */\n  getFileSize(file, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const isDownloadable = yield _this5.isFileDownloadable(file, siteId);\n      if (!isDownloadable.downloadable) {\n        return 0;\n      }\n      const handler = _this5.getHandlerForFile(file);\n      // First of all check if file can be downloaded.\n      const downloadableFile = yield _this5.getHandlerDownloadableFile(file, handler, siteId);\n      if (!downloadableFile) {\n        return 0;\n      }\n      if (handler && handler.getFileSize) {\n        try {\n          return yield handler.getFileSize(downloadableFile, siteId);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n      }\n      return downloadableFile.filesize || 0;\n    })();\n  }\n  /**\n   * Get a handler to treat a certain file.\n   *\n   * @param file File data.\n   * @returns Handler.\n   */\n  getHandlerForFile(file) {\n    for (const component in this.enabledHandlers) {\n      const handler = this.enabledHandlers[component];\n      if (handler && handler.shouldHandleFile && handler.shouldHandleFile(file)) {\n        return handler;\n      }\n    }\n  }\n  /**\n   * Check if a file is downloadable.\n   *\n   * @param file The file data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise with the data.\n   */\n  isFileDownloadable(file, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this6.getHandlerForFile(file);\n      if (handler && handler.isFileDownloadable) {\n        return handler.isFileDownloadable(file, siteId);\n      }\n      // Default to true.\n      return {\n        downloadable: true\n      };\n    })();\n  }\n  /**\n   * Removes the revision number from a file URL.\n   *\n   * @param url URL to be replaced.\n   * @param args Arguments of the pluginfile URL defining component and filearea at least.\n   * @returns Replaced URL without revision.\n   */\n  removeRevisionFromUrl(url, args) {\n    // Get handler based on component (args[1]).\n    const handler = this.getHandler(args[1], true);\n    if (handler && handler.getComponentRevisionRegExp && handler.getComponentRevisionReplace) {\n      const revisionRegex = handler.getComponentRevisionRegExp(args);\n      if (revisionRegex) {\n        return url.replace(revisionRegex, handler.getComponentRevisionReplace(args));\n      }\n    }\n    return url;\n  }\n  /**\n   * Treat a downloaded file.\n   *\n   * @param fileUrl The file URL used to download the file.\n   * @param file The file entry of the downloaded file.\n   * @param siteId Site ID. If not defined, current site.\n   * @param onProgress Function to call on progress.\n   * @returns Promise resolved when done.\n   */\n  treatDownloadedFile(fileUrl, file, siteId, onProgress) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this7.getHandlerForFile({\n        fileurl: fileUrl\n      });\n      if (handler && handler.treatDownloadedFile) {\n        yield handler.treatDownloadedFile(fileUrl, file, siteId, onProgress);\n      }\n    })();\n  }\n}\n_class = CorePluginFileDelegateService;\n_class.ɵfac = function CorePluginFileDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CorePluginFileDelegate = makeSingleton(CorePluginFileDelegateService);","map":{"version":3,"names":["CoreFilepool","CoreConstants","CoreDelegate","makeSingleton","CoreSites","CoreFileHelper","CorePluginFileDelegateService","constructor","fileDeleted","fileUrl","path","siteId","_this","_asyncToGenerator","handler","getHandlerForFile","fileurl","getDownloadableFile","file","getHandlerDownloadableFile","_this2","isDownloadable","isFileDownloadable","downloadable","reason","newFile","getComponentRevisionRegExp","args","getHandler","getDownloadableFilesFromHTML","container","files","component","enabledHandlers","concat","getFilesDownloadSize","_this3","siteIdentifier","getCurrentSiteId","filteredFiles","Promise","all","map","_ref","state","getFileStateByUrl","getFileUrl","timemodified","DOWNLOADED","NOT_DOWNLOADABLE","push","_x","apply","arguments","getFilesSize","_this4","result","size","total","_ref2","getFileSize","undefined","_x2","_this5","downloadableFile","_unused","filesize","shouldHandleFile","_this6","removeRevisionFromUrl","url","getComponentRevisionReplace","revisionRegex","replace","treatDownloadedFile","onProgress","_this7","factory","ɵfac","providedIn","CorePluginFileDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/plugin-file-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreFilepool, CoreFilepoolOnProgressCallback } from '@services/filepool';\nimport { CoreWSFile } from '@services/ws';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreSites } from './sites';\nimport { CoreFileHelper } from './file-helper';\n\n/**\n * Delegate to register pluginfile information handlers.\n */\n@Injectable({ providedIn: 'root' })\nexport class CorePluginFileDelegateService extends CoreDelegate<CorePluginFileHandler> {\n\n    constructor() {\n        super('CorePluginFileDelegate', true);\n    }\n\n    /**\n     * React to a file being deleted.\n     *\n     * @param fileUrl The file URL used to download the file.\n     * @param path The path of the deleted file.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async fileDeleted(fileUrl: string, path: string, siteId?: string): Promise<void> {\n        const handler = this.getHandlerForFile({ fileurl: fileUrl });\n\n        if (handler && handler.fileDeleted) {\n            await handler.fileDeleted(fileUrl, path, siteId);\n        }\n    }\n\n    /**\n     * Check whether a file can be downloaded. If so, return the file to download.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the file to use. Rejected if cannot download.\n     */\n    getDownloadableFile(file: CoreWSFile, siteId?: string): Promise<CoreWSFile> {\n        const handler = this.getHandlerForFile(file);\n\n        return this.getHandlerDownloadableFile(file, handler, siteId);\n    }\n\n    /**\n     * Check whether a file can be downloaded. If so, return the file to download.\n     *\n     * @param file The file data.\n     * @param handler The handler to use.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the file to use. Rejected if cannot download.\n     */\n    protected async getHandlerDownloadableFile(\n        file: CoreWSFile,\n        handler?: CorePluginFileHandler,\n        siteId?: string,\n    ): Promise<CoreWSFile> {\n        const isDownloadable = await this.isFileDownloadable(file, siteId);\n\n        if (!isDownloadable.downloadable) {\n            throw isDownloadable.reason;\n        }\n\n        if (handler && handler.getDownloadableFile) {\n            const newFile = await handler.getDownloadableFile(file, siteId);\n\n            return newFile || file;\n        }\n\n        return file;\n    }\n\n    /**\n     * Get the RegExp of the component and filearea described in the URL.\n     *\n     * @param args Arguments of the pluginfile URL defining component and filearea at least.\n     * @returns RegExp to match the revision or undefined if not found.\n     */\n    getComponentRevisionRegExp(args: string[]): RegExp | void {\n        // Get handler based on component (args[1]).\n        const handler = this.getHandler(args[1], true);\n\n        if (handler && handler.getComponentRevisionRegExp) {\n            return handler.getComponentRevisionRegExp(args);\n        }\n    }\n\n    /**\n     * Given an HTML element, get the URLs of the files that should be downloaded and weren't treated by\n     * CoreFilepoolProvider.extractDownloadableFilesFromHtml.\n     *\n     * @param container Container where to get the URLs from.\n     * @returns List of URLs.\n     */\n    getDownloadableFilesFromHTML(container: HTMLElement): string[] {\n        let files: string[] = [];\n\n        for (const component in this.enabledHandlers) {\n            const handler = this.enabledHandlers[component];\n\n            if (handler && handler.getDownloadableFilesFromHTML) {\n                files = files.concat(handler.getDownloadableFilesFromHTML(container));\n            }\n        }\n\n        return files;\n    }\n\n    /**\n     * Sum the filesizes from a list if they are not downloaded.\n     *\n     * @param files List of files to sum its filesize.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with file size and a boolean to indicate if it is the total size or only partial.\n     */\n    async getFilesDownloadSize(files: CoreWSFile[], siteId?: string): Promise<CoreFileSizeSum> {\n        const siteIdentifier = siteId || CoreSites.getCurrentSiteId();\n\n        const filteredFiles: CoreWSFile[] = [];\n\n        await Promise.all(files.map(async (file) => {\n            const state = await CoreFilepool.getFileStateByUrl(siteIdentifier, CoreFileHelper.getFileUrl(file), file.timemodified);\n\n            if (state !== CoreConstants.DOWNLOADED && state !== CoreConstants.NOT_DOWNLOADABLE) {\n                filteredFiles.push(file);\n            }\n        }));\n\n        return this.getFilesSize(filteredFiles, siteIdentifier);\n    }\n\n    /**\n     * Sum the filesizes from a list of files checking if the size will be partial or totally calculated.\n     *\n     * @param files List of files to sum its filesize.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with file size and a boolean to indicate if it is the total size or only partial.\n     */\n    async getFilesSize(files: CoreWSFile[], siteId?: string): Promise<CoreFileSizeSum> {\n        const result: CoreFileSizeSum = {\n            size: 0,\n            total: true,\n        };\n\n        await Promise.all(files.map(async (file) => {\n            const size = await this.getFileSize(file, siteId);\n\n            if (size === undefined) {\n                // We don't have the file size, cannot calculate its total size.\n                result.total = false;\n            } else {\n                result.size += size;\n            }\n        }));\n\n        return result;\n    }\n\n    /**\n     * Get a file size.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the size.\n     */\n    async getFileSize(file: CoreWSFile, siteId?: string): Promise<number> {\n        const isDownloadable = await this.isFileDownloadable(file, siteId);\n\n        if (!isDownloadable.downloadable) {\n            return 0;\n        }\n\n        const handler = this.getHandlerForFile(file);\n\n        // First of all check if file can be downloaded.\n        const downloadableFile = await this.getHandlerDownloadableFile(file, handler, siteId);\n        if (!downloadableFile) {\n            return 0;\n        }\n\n        if (handler && handler.getFileSize) {\n            try {\n                return await handler.getFileSize(downloadableFile, siteId);\n            } catch {\n                // Ignore errors.\n            }\n        }\n\n        return downloadableFile.filesize || 0;\n    }\n\n    /**\n     * Get a handler to treat a certain file.\n     *\n     * @param file File data.\n     * @returns Handler.\n     */\n    protected getHandlerForFile(file: CoreWSFile): CorePluginFileHandler | undefined {\n        for (const component in this.enabledHandlers) {\n            const handler = this.enabledHandlers[component];\n\n            if (handler && handler.shouldHandleFile && handler.shouldHandleFile(file)) {\n                return handler;\n            }\n        }\n    }\n\n    /**\n     * Check if a file is downloadable.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise with the data.\n     */\n    async isFileDownloadable(file: CoreWSFile, siteId?: string): Promise<CorePluginFileDownloadableResult> {\n        const handler = this.getHandlerForFile(file);\n\n        if (handler && handler.isFileDownloadable) {\n            return handler.isFileDownloadable(file, siteId);\n        }\n\n        // Default to true.\n        return { downloadable: true };\n    }\n\n    /**\n     * Removes the revision number from a file URL.\n     *\n     * @param url URL to be replaced.\n     * @param args Arguments of the pluginfile URL defining component and filearea at least.\n     * @returns Replaced URL without revision.\n     */\n    removeRevisionFromUrl(url: string, args: string[]): string {\n        // Get handler based on component (args[1]).\n        const handler = this.getHandler(args[1], true);\n\n        if (handler && handler.getComponentRevisionRegExp && handler.getComponentRevisionReplace) {\n            const revisionRegex = handler.getComponentRevisionRegExp(args);\n            if (revisionRegex) {\n                return url.replace(revisionRegex, handler.getComponentRevisionReplace(args));\n            }\n        }\n\n        return url;\n    }\n\n    /**\n     * Treat a downloaded file.\n     *\n     * @param fileUrl The file URL used to download the file.\n     * @param file The file entry of the downloaded file.\n     * @param siteId Site ID. If not defined, current site.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when done.\n     */\n    async treatDownloadedFile(\n        fileUrl: string,\n        file: FileEntry,\n        siteId?: string,\n        onProgress?: CoreFilepoolOnProgressCallback,\n    ): Promise<void> {\n        const handler = this.getHandlerForFile({ fileurl: fileUrl });\n\n        if (handler && handler.treatDownloadedFile) {\n            await handler.treatDownloadedFile(fileUrl, file, siteId, onProgress);\n        }\n    }\n\n}\n\nexport const CorePluginFileDelegate = makeSingleton(CorePluginFileDelegateService);\n\n/**\n * Interface that all plugin file handlers must implement.\n */\nexport interface CorePluginFileHandler extends CoreDelegateHandler {\n\n    /**\n     * The \"component\" of the handler. It should match the \"component\" of pluginfile URLs.\n     * It is used to treat revision from URLs.\n     */\n    component?: string;\n\n    /**\n     * Return the RegExp to match the revision on pluginfile URLs.\n     *\n     * @param args Arguments of the pluginfile URL defining component and filearea at least.\n     * @returns RegExp to match the revision on pluginfile URLs.\n     */\n    getComponentRevisionRegExp?(args: string[]): RegExp | undefined;\n\n    /**\n     * Should return the string to remove the revision on pluginfile url.\n     *\n     * @param args Arguments of the pluginfile URL defining component and filearea at least.\n     * @returns String to remove the revision on pluginfile url.\n     */\n    getComponentRevisionReplace?(args: string[]): string;\n\n    /**\n     * React to a file being deleted.\n     *\n     * @param fileUrl The file URL used to download the file.\n     * @param path The path of the deleted file.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    fileDeleted?(fileUrl: string, path: string, siteId?: string): Promise<void>;\n\n    /**\n     * Check whether a file can be downloaded. If so, return the file to download.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the file to use. Rejected if cannot download.\n     */\n    getDownloadableFile?(file: CoreWSFile, siteId?: string): Promise<CoreWSFile>;\n\n    /**\n     * Given an HTML element, get the URLs of the files that should be downloaded and weren't treated by\n     * CoreFilepoolProvider.extractDownloadableFilesFromHtml.\n     *\n     * @param container Container where to get the URLs from.\n     * @returns List of URLs.\n     */\n    getDownloadableFilesFromHTML?(container: HTMLElement): string[];\n\n    /**\n     * Get a file size.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the size.\n     */\n    getFileSize?(file: CoreWSFile, siteId?: string): Promise<number>;\n\n    /**\n     * Check if a file is downloadable.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with a boolean and a reason why it isn't downloadable if needed.\n     */\n    isFileDownloadable?(file: CoreWSFile, siteId?: string): Promise<CorePluginFileDownloadableResult>;\n\n    /**\n     * Check whether the file should be treated by this handler. It is used in functions where the component isn't used.\n     *\n     * @param file The file data.\n     * @returns Whether the file should be treated by this handler.\n     */\n    shouldHandleFile?(file: CoreWSFile): boolean;\n\n    /**\n     * Treat a downloaded file.\n     *\n     * @param fileUrl The file URL used to download the file.\n     * @param file The file entry of the downloaded file.\n     * @param siteId Site ID. If not defined, current site.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when done.\n     */\n    treatDownloadedFile?(\n        fileUrl: string,\n        file: FileEntry,\n        siteId?: string,\n        onProgress?: CoreFilepoolOnProgressCallback):\n    Promise<void>;\n}\n\n/**\n * Data about if a file is downloadable.\n */\nexport type CorePluginFileDownloadableResult = {\n    /**\n     * Whether it's downloadable.\n     */\n    downloadable: boolean;\n\n    /**\n     * If not downloadable, the reason why it isn't.\n     */\n    reason?: string;\n};\n\n/**\n * Sum of file sizes.\n */\nexport type CoreFileSizeSum = {\n    size: number; // Sum of file sizes.\n    total: boolean; // False if any file size is not available.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}