{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { DomSanitizer, makeSingleton, Translate } from '@singletons';\nimport { Locutus } from '@singletons/locutus';\nimport { CoreViewerTextComponent } from '@features/viewer/components/text/text';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreDomUtils } from './dom';\nimport { CoreUrl } from '@singletons/url';\nimport { CorePath } from '@singletons/path';\nimport { CorePlatform } from '@services/platform';\nimport * as i0 from \"@angular/core\";\n/*\n * \"Utils\" service with helper functions for text.\n*/\nexport class CoreTextUtilsProvider {\n  constructor() {\n    // List of regular expressions to convert the old nomenclature to new nomenclature for disabled features.\n    this.DISABLED_FEATURES_COMPAT_REGEXPS = [{\n      old: /\\$mmLoginEmailSignup/g,\n      new: 'CoreLoginEmailSignup'\n    }, {\n      old: /\\$mmSideMenuDelegate/g,\n      new: 'CoreMainMenuDelegate'\n    }, {\n      old: /\\$mmCoursesDelegate/g,\n      new: 'CoreCourseOptionsDelegate'\n    }, {\n      old: /\\$mmUserDelegate/g,\n      new: 'CoreUserDelegate'\n    }, {\n      old: /\\$mmCourseDelegate/g,\n      new: 'CoreCourseModuleDelegate'\n    }, {\n      old: /_mmCourses/g,\n      new: '_CoreCourses'\n    }, {\n      old: /_mmaFrontpage/g,\n      new: '_CoreSiteHome'\n    }, {\n      old: /_mmaGrades/g,\n      new: '_CoreGrades'\n    }, {\n      old: /_mmaCompetency/g,\n      new: '_AddonCompetency'\n    }, {\n      old: /_mmaNotifications/g,\n      new: '_AddonNotifications'\n    }, {\n      old: /_mmaMessages/g,\n      new: '_AddonMessages'\n    }, {\n      old: /_mmaCalendar/g,\n      new: '_AddonCalendar'\n    }, {\n      old: /_mmaFiles/g,\n      new: '_AddonPrivateFiles'\n    }, {\n      old: /_mmaParticipants/g,\n      new: '_CoreUserParticipants'\n    }, {\n      old: /_mmaCourseCompletion/g,\n      new: '_AddonCourseCompletion'\n    }, {\n      old: /_mmaNotes/g,\n      new: '_AddonNotes'\n    }, {\n      old: /_mmaBadges/g,\n      new: '_AddonBadges'\n    }, {\n      old: /files_privatefiles/g,\n      new: 'AddonPrivateFilesPrivateFiles'\n    }, {\n      old: /files_sitefiles/g,\n      new: 'AddonPrivateFilesSiteFiles'\n    }, {\n      old: /files_upload/g,\n      new: 'AddonPrivateFilesUpload'\n    }, {\n      old: /_mmaModAssign/g,\n      new: '_AddonModAssign'\n    }, {\n      old: /_mmaModBigbluebuttonbn/g,\n      new: '_AddonModBBB'\n    }, {\n      old: /_mmaModBook/g,\n      new: '_AddonModBook'\n    }, {\n      old: /_mmaModChat/g,\n      new: '_AddonModChat'\n    }, {\n      old: /_mmaModChoice/g,\n      new: '_AddonModChoice'\n    }, {\n      old: /_mmaModData/g,\n      new: '_AddonModData'\n    }, {\n      old: /_mmaModFeedback/g,\n      new: '_AddonModFeedback'\n    }, {\n      old: /_mmaModFolder/g,\n      new: '_AddonModFolder'\n    }, {\n      old: /_mmaModForum/g,\n      new: '_AddonModForum'\n    }, {\n      old: /_mmaModGlossary/g,\n      new: '_AddonModGlossary'\n    }, {\n      old: /_mmaModH5pactivity/g,\n      new: '_AddonModH5PActivity'\n    }, {\n      old: /_mmaModImscp/g,\n      new: '_AddonModImscp'\n    }, {\n      old: /_mmaModLabel/g,\n      new: '_AddonModLabel'\n    }, {\n      old: /_mmaModLesson/g,\n      new: '_AddonModLesson'\n    }, {\n      old: /_mmaModLti/g,\n      new: '_AddonModLti'\n    }, {\n      old: /_mmaModPage/g,\n      new: '_AddonModPage'\n    }, {\n      old: /_mmaModQuiz/g,\n      new: '_AddonModQuiz'\n    }, {\n      old: /_mmaModResource/g,\n      new: '_AddonModResource'\n    }, {\n      old: /_mmaModScorm/g,\n      new: '_AddonModScorm'\n    }, {\n      old: /_mmaModSurvey/g,\n      new: '_AddonModSurvey'\n    }, {\n      old: /_mmaModUrl/g,\n      new: '_AddonModUrl'\n    }, {\n      old: /_mmaModWiki/g,\n      new: '_AddonModWiki'\n    }, {\n      old: /_mmaModWorkshop/g,\n      new: '_AddonModWorkshop'\n    }, {\n      old: /remoteAddOn_/g,\n      new: 'sitePlugin_'\n    }, {\n      old: /AddonNotes:addNote/g,\n      new: 'AddonNotes:notes'\n    }];\n    this.template = document.createElement('template'); // A template element to convert HTML to element.\n  }\n  /**\n   * Add ending slash from a path or URL.\n   *\n   * @param text Text to treat.\n   * @returns Treated text.\n   */\n  addEndingSlash(text) {\n    if (!text) {\n      return '';\n    }\n    if (text.slice(-1) != '/') {\n      return text + '/';\n    }\n    return text;\n  }\n  /**\n   * Add some text to an error message.\n   *\n   * @param error Error message or object.\n   * @param text Text to add.\n   * @returns Modified error.\n   */\n  addTextToError(error, text) {\n    if (typeof error == 'string') {\n      return error + text;\n    }\n    if (error instanceof CoreError) {\n      error.message += text;\n      return error;\n    }\n    if (!error) {\n      return text;\n    }\n    if (typeof error.message == 'string') {\n      error.message += text;\n    } else if (typeof error.error == 'string') {\n      error.error += text;\n    } else if (typeof error.content == 'string') {\n      error.content += text;\n    } else if (typeof error.body == 'string') {\n      error.body += text;\n    }\n    return error;\n  }\n  /**\n   * Add some title to an error message.\n   *\n   * @param error Error message or object.\n   * @param title Title to add.\n   * @returns Modified error.\n   */\n  addTitleToError(error, title) {\n    let improvedError = {};\n    if (typeof error === 'string') {\n      improvedError.message = error;\n    } else if (error && 'message' in error) {\n      improvedError = error;\n    }\n    improvedError.title = improvedError.title || title;\n    return improvedError;\n  }\n  /**\n   * Given an address as a string, return a URL to open the address in maps.\n   *\n   * @param address The address.\n   * @returns URL to view the address.\n   */\n  buildAddressURL(address) {\n    const parsedUrl = CoreUrl.parse(address);\n    if (parsedUrl !== null && parsedUrl !== void 0 && parsedUrl.protocol) {\n      // It's already a URL, don't convert it.\n      return DomSanitizer.bypassSecurityTrustUrl(address);\n    }\n    return DomSanitizer.bypassSecurityTrustUrl((CorePlatform.isAndroid() ? 'geo:0,0?q=' : 'http://maps.google.com?q=') + encodeURIComponent(address));\n  }\n  /**\n   * Given a list of sentences, build a message with all of them wrapped in <p>.\n   *\n   * @param messages Messages to show.\n   * @returns Message with all the messages.\n   */\n  buildMessage(messages) {\n    let result = '';\n    messages.forEach(message => {\n      if (message) {\n        result += `<p>${message}</p>`;\n      }\n    });\n    return result;\n  }\n  /**\n   * Build a message with several paragraphs.\n   *\n   * @param paragraphs List of paragraphs.\n   * @returns Built message.\n   */\n  buildSeveralParagraphsMessage(paragraphs) {\n    // Filter invalid messages, and convert them to messages in case they're errors.\n    const messages = [];\n    paragraphs.forEach(paragraph => {\n      // If it's an error, get its message.\n      const message = this.getErrorMessageFromError(paragraph);\n      if (paragraph && message) {\n        messages.push(message);\n      }\n    });\n    if (messages.length < 2) {\n      return messages[0] || '';\n    }\n    let builtMessage = messages[0];\n    for (let i = 1; i < messages.length; i++) {\n      builtMessage = Translate.instant('core.twoparagraphs', {\n        p1: builtMessage,\n        p2: messages[i]\n      });\n    }\n    return builtMessage;\n  }\n  /**\n   * Convert size in bytes into human readable format\n   *\n   * @param bytes Number of bytes to convert.\n   * @param precision Number of digits after the decimal separator.\n   * @returns Size in human readable format.\n   */\n  bytesToSize(bytes, precision = 2) {\n    if (bytes === undefined || bytes === null || bytes < 0) {\n      return Translate.instant('core.notapplicable');\n    }\n    if (precision < 0) {\n      precision = 2;\n    }\n    const keys = ['core.sizeb', 'core.sizekb', 'core.sizemb', 'core.sizegb', 'core.sizetb'];\n    const units = Translate.instant(keys);\n    let pos = 0;\n    if (bytes >= 1024) {\n      while (bytes >= 1024) {\n        pos++;\n        bytes = bytes / 1024;\n      }\n      // Round to \"precision\" decimals if needed.\n      bytes = Number(Math.round(parseFloat(bytes + 'e+' + precision)) + 'e-' + precision);\n    }\n    return Translate.instant('core.humanreadablesize', {\n      size: bytes,\n      unit: units[keys[pos]]\n    });\n  }\n  /**\n   * Clean HTML tags.\n   *\n   * @param text The text to be cleaned.\n   * @param options Processing options.\n   * @param options.singleLine True if new lines should be removed (all the text in a single line).\n   * @param options.trim True if text should be trimmed.\n   * @returns Clean text.\n   */\n  cleanTags(text, options = {}) {\n    if (!text) {\n      return '';\n    }\n    // First, we use a regexpr.\n    text = text.replace(/(<([^>]+)>)/ig, '');\n    // Then, we rely on the browser. We need to wrap the text to be sure is HTML.\n    text = this.convertToElement(text).textContent || '';\n    // Trim text\n    text = options.trim ? text.trim() : text;\n    // Recover or remove new lines.\n    text = this.replaceNewLines(text, options.singleLine ? ' ' : '<br>');\n    return text;\n  }\n  /**\n   * Convert some HTML as text into an HTMLElement. This HTML is put inside a div or a body.\n   * This function is the same as in DomUtils, but we cannot use that one because of circular dependencies.\n   *\n   * @param html Text to convert.\n   * @returns Element.\n   */\n  convertToElement(html) {\n    // Add a div to hold the content, that's the element that will be returned.\n    this.template.innerHTML = '<div>' + html + '</div>';\n    return this.template.content.children[0];\n  }\n  /**\n   * Count words in a text.\n   * This function is based on Moodle's count_words.\n   *\n   * @param text Text to count.\n   * @returns Number of words.\n   */\n  countWords(text) {\n    if (!text || typeof text != 'string') {\n      return 0;\n    }\n    // Before stripping tags, add a space after the close tag of anything that is not obviously inline.\n    // Also, br is a special case because it definitely delimits a word, but has no close tag.\n    text = text.replace(/(<\\/(?!a>|b>|del>|em>|i>|ins>|s>|small>|span>|strong>|sub>|sup>|u>)\\w+>|<br>|<br\\s*\\/>)/ig, '$1 ');\n    // Now remove HTML tags.\n    text = text.replace(/(<([^>]+)>)/ig, '');\n    // Decode HTML entities.\n    text = this.decodeHTMLEntities(text);\n    // Now, the word count is the number of blocks of characters separated\n    // by any sort of space. That seems to be the definition used by all other systems.\n    // To be precise about what is considered to separate words:\n    // * Anything that Unicode considers a 'Separator'\n    // * Anything that Unicode considers a 'Control character'\n    // * An em- or en- dash.\n    let words;\n    try {\n      words = text.split(/[\\0- \\x7F-\\xA0\\u1680\\u2000-\\u200A\\u2013\\u2014\\u2028\\u2029\\u202F\\u205F\\u3000]+/);\n    } catch (_unused) {\n      // Unicode-aware flag not supported.\n      words = text.split(/\\s+/);\n    }\n    // Filter empty words.\n    return words.filter(word => word).length;\n  }\n  /**\n   * Decode an escaped HTML text. This implementation is based on PHP's htmlspecialchars_decode.\n   *\n   * @param text Text to decode.\n   * @returns Decoded text.\n   */\n  decodeHTML(text) {\n    if (text === undefined || text === null || typeof text == 'number' && isNaN(text)) {\n      return '';\n    } else if (typeof text != 'string') {\n      return '' + text;\n    }\n    return text.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '\"').replace(/&#039;/g, '\\'').replace(/&nbsp;/g, ' ');\n  }\n  /**\n   * Decode HTML entities in a text. Equivalent to PHP html_entity_decode.\n   *\n   * @param text Text to decode.\n   * @returns Decoded text.\n   */\n  decodeHTMLEntities(text) {\n    if (text) {\n      text = this.convertToElement(text).textContent || '';\n    }\n    return text;\n  }\n  /**\n   * Same as Javascript's decodeURI, but if an exception is thrown it will return the original URI.\n   *\n   * @param uri URI to decode.\n   * @returns Decoded URI, or original URI if an exception is thrown.\n   */\n  decodeURI(uri) {\n    try {\n      return decodeURI(uri);\n    } catch (ex) {\n      // Error, use the original URI.\n    }\n    return uri;\n  }\n  /**\n   * Same as Javascript's decodeURIComponent, but if an exception is thrown it will return the original URI.\n   *\n   * @param uri URI to decode.\n   * @returns Decoded URI, or original URI if an exception is thrown.\n   */\n  decodeURIComponent(uri) {\n    try {\n      return decodeURIComponent(uri);\n    } catch (ex) {\n      // Error, use the original URI.\n    }\n    return uri;\n  }\n  /**\n   * Escapes some characters in a string to be used as a regular expression.\n   *\n   * @param text Text to escape.\n   * @returns Escaped text.\n   */\n  escapeForRegex(text) {\n    if (!text || typeof text != 'string') {\n      return '';\n    }\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  }\n  /**\n   * Escape an HTML text. This implementation is based on PHP's htmlspecialchars.\n   *\n   * @param text Text to escape.\n   * @param doubleEncode If false, it will not convert existing html entities. Defaults to true.\n   * @returns Escaped text.\n   */\n  escapeHTML(text, doubleEncode = true) {\n    if (text === undefined || text === null || typeof text == 'number' && isNaN(text)) {\n      return '';\n    } else if (typeof text != 'string') {\n      return '' + text;\n    }\n    if (doubleEncode) {\n      text = text.replace(/&/g, '&amp;');\n    } else {\n      text = text.replace(/&(?!amp;)(?!lt;)(?!gt;)(?!quot;)(?!#039;)/g, '&amp;');\n    }\n    return text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;');\n  }\n  /**\n   * Formats a text, in HTML replacing new lines by correct html new lines.\n   *\n   * @param text Text to format.\n   * @returns Formatted text.\n   */\n  formatHtmlLines(text) {\n    const hasHTMLTags = this.hasHTMLTags(text);\n    if (text.indexOf('<p>') == -1) {\n      // Wrap the text in <p> tags.\n      text = '<p>' + text + '</p>';\n    }\n    if (!hasHTMLTags) {\n      // The text doesn't have HTML, replace new lines for <br>.\n      return this.replaceNewLines(text, '<br>');\n    }\n    return text;\n  }\n  /**\n   * Get the error message from an error object.\n   *\n   * @param error Error.\n   * @returns Error message, undefined if not found.\n   */\n  getErrorMessageFromError(error) {\n    if (typeof error === 'string') {\n      return error;\n    }\n    if (error instanceof CoreError) {\n      return error.message;\n    }\n    if (!error) {\n      return undefined;\n    }\n    return error.message || error.error || error.content || error.body;\n  }\n  /**\n   * Given some HTML code, return the HTML code inside <body> tags. If there are no body tags, return the whole HTML.\n   *\n   * @param html HTML text.\n   * @returns Body HTML.\n   */\n  getHTMLBodyContent(html) {\n    var _matches$;\n    const matches = html.match(/<body>([\\s\\S]*)<\\/body>/im);\n    return (_matches$ = matches === null || matches === void 0 ? void 0 : matches[1]) !== null && _matches$ !== void 0 ? _matches$ : html;\n  }\n  /**\n   * Get the pluginfile URL to replace @@PLUGINFILE@@ wildcards.\n   *\n   * @param files Files to extract the URL from. They need to have the URL in a 'url' or 'fileurl' attribute.\n   * @returns Pluginfile URL, undefined if no files found.\n   */\n  getTextPluginfileUrl(files) {\n    if (files !== null && files !== void 0 && files.length) {\n      const url = CoreFileHelper.getFileUrl(files[0]);\n      // Remove text after last slash (encoded or not).\n      return url === null || url === void 0 ? void 0 : url.substring(0, Math.max(url.lastIndexOf('/'), url.lastIndexOf('%2F')));\n    }\n    return undefined;\n  }\n  /**\n   * Check if a text contains HTML tags.\n   *\n   * @param text Text to check.\n   * @returns Whether it has HTML tags.\n   */\n  hasHTMLTags(text) {\n    return /<[a-z][\\s\\S]*>/i.test(text);\n  }\n  /**\n   * Highlight all occurrences of a certain text inside another text. It will add some HTML code to highlight it.\n   *\n   * @param text Full text.\n   * @param searchText Text to search and highlight.\n   * @returns Highlighted text.\n   */\n  highlightText(text, searchText) {\n    if (!text || typeof text != 'string') {\n      return '';\n    } else if (!searchText) {\n      return text;\n    }\n    const regex = new RegExp('(' + searchText + ')', 'gi');\n    return text.replace(regex, '<mark class=\"matchtext\">$1</mark>');\n  }\n  /**\n   * Check if HTML content is blank.\n   *\n   * @param content HTML content.\n   * @returns True if the string does not contain actual content: text, images, etc.\n   */\n  htmlIsBlank(content) {\n    if (!content) {\n      return true;\n    }\n    this.template.innerHTML = content.trim().replace(/(\\r\\n|\\n|\\r)/g, '');\n    const tags = this.template.content.querySelectorAll('img, audio, video, object, iframe, canvas, svg, input, select, textarea, frame, embed');\n    return this.template.content.textContent === '' && tags.length === 0;\n  }\n  /**\n   * Check if a text contains Unicode long chars.\n   * Using as threshold Hex value D800\n   *\n   * @param text Text to check.\n   * @returns True if has Unicode chars, false otherwise.\n   */\n  hasUnicode(text) {\n    for (let x = 0; x < text.length; x++) {\n      if (text.charCodeAt(x) > 55295) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Check if an object has any long Unicode char.\n   *\n   * @param data Object to be checked.\n   * @returns If the data has any long Unicode char on it.\n   */\n  hasUnicodeData(data) {\n    for (const el in data) {\n      if (typeof data[el] == 'object') {\n        if (this.hasUnicodeData(data[el])) {\n          return true;\n        }\n        continue;\n      }\n      if (typeof data[el] == 'string' && this.hasUnicode(data[el])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Check whether the given text matches a glob pattern.\n   *\n   * @param text Text to match against.\n   * @param pattern Glob pattern.\n   * @returns Whether the pattern matches.\n   */\n  matchesGlob(text, pattern) {\n    pattern = pattern.replace(/\\*\\*/g, '%RECURSIVE_MATCH%').replace(/\\*/g, '%LOCAL_MATCH%').replace(/\\?/g, '%CHARACTER_MATCH%');\n    pattern = this.escapeForRegex(pattern);\n    pattern = pattern.replace(/%RECURSIVE_MATCH%/g, '.*').replace(/%LOCAL_MATCH%/g, '[^/]*').replace(/%CHARACTER_MATCH%/g, '[^/]');\n    return new RegExp(`^${pattern}$`).test(text);\n  }\n  /**\n   * Same as Javascript's JSON.parse, but it will handle errors.\n   *\n   * @param json JSON text.\n   * @param defaultValue Default value to return if the parse fails. Defaults to the original value.\n   * @param logErrorFn An error to call with the exception to log the error. If not supplied, no error.\n   * @returns JSON parsed as object or what it gets.\n   */\n  parseJSON(json, defaultValue, logErrorFn) {\n    try {\n      return JSON.parse(json);\n    } catch (error) {\n      // Error, log the error if needed.\n      if (logErrorFn) {\n        logErrorFn(error);\n      }\n    }\n    // Error parsing, return the default value or the original value.\n    if (defaultValue !== undefined) {\n      return defaultValue;\n    }\n    throw new CoreError('JSON cannot be parsed and not default value has been provided');\n  }\n  /**\n   * Replace all characters that cause problems with files in Android and iOS.\n   *\n   * @param text Text to treat.\n   * @returns Treated text.\n   */\n  removeSpecialCharactersForFiles(text) {\n    if (!text || typeof text != 'string') {\n      return '';\n    }\n    return text.replace(/[#:/?\\\\]+/g, '_');\n  }\n  /**\n   * Replace {{ARGUMENT}} arguments in the text.\n   *\n   * @param text Text to treat.\n   * @param replacements Argument values.\n   * @param encoding Encoding to use in values.\n   * @returns Treated text.\n   */\n  replaceArguments(text, replacements = {}, encoding) {\n    let match = null;\n    while (match = text.match(/\\{\\{([^}]+)\\}\\}/)) {\n      var _replacements$argumen;\n      const argument = match[1].trim();\n      const value = (_replacements$argumen = replacements[argument]) !== null && _replacements$argumen !== void 0 ? _replacements$argumen : '';\n      const encodedValue = encoding ? encodeURIComponent(value) : value;\n      text = text.replace(`{{${argument}}}`, encodedValue);\n    }\n    return text;\n  }\n  /**\n   * Replace all the new lines on a certain text.\n   *\n   * @param text The text to be treated.\n   * @param newValue Text to use instead of new lines.\n   * @returns Treated text.\n   */\n  replaceNewLines(text, newValue) {\n    if (!text || typeof text != 'string') {\n      return '';\n    }\n    return text.replace(/(?:\\r\\n|\\r|\\n)/g, newValue);\n  }\n  /**\n   * Replace draftfile URLs with the equivalent pluginfile URL.\n   *\n   * @param siteUrl URL of the site.\n   * @param text Text to treat, including draftfile URLs.\n   * @param files List of files of the area, using pluginfile URLs.\n   * @returns Treated text and map with the replacements.\n   */\n  replaceDraftfileUrls(siteUrl, text, files) {\n    if (!text || !files || !files.length) {\n      return {\n        text\n      };\n    }\n    const draftfileUrl = CorePath.concatenatePaths(siteUrl, 'draftfile.php');\n    const matches = text.match(new RegExp(this.escapeForRegex(draftfileUrl) + '[^\\'\" ]+', 'ig'));\n    if (!matches || !matches.length) {\n      return {\n        text\n      };\n    }\n    // Index the pluginfile URLs by file name.\n    const pluginfileMap = {};\n    files.forEach(file => {\n      if (!file.filename) {\n        return;\n      }\n      pluginfileMap[file.filename] = CoreFileHelper.getFileUrl(file);\n    });\n    // Replace each draftfile with the corresponding pluginfile URL.\n    const replaceMap = {};\n    matches.forEach(url => {\n      if (replaceMap[url]) {\n        // URL already treated, same file embedded more than once.\n        return;\n      }\n      // Get the filename from the URL.\n      let filename = url.substring(url.lastIndexOf('/') + 1);\n      if (filename.indexOf('?') != -1) {\n        filename = filename.substring(0, filename.indexOf('?'));\n      }\n      if (pluginfileMap[filename]) {\n        replaceMap[url] = pluginfileMap[filename];\n        text = text.replace(new RegExp(this.escapeForRegex(url), 'g'), pluginfileMap[filename]);\n      }\n    });\n    return {\n      text,\n      replaceMap\n    };\n  }\n  /**\n   * Replace @@PLUGINFILE@@ wildcards with the real URL in a text.\n   *\n   * @param text to treat.\n   * @param files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.\n   * @returns Treated text.\n   */\n  replacePluginfileUrls(text, files) {\n    if (text && typeof text == 'string') {\n      const fileURL = this.getTextPluginfileUrl(files);\n      if (fileURL) {\n        return text.replace(/@@PLUGINFILE@@/g, fileURL);\n      }\n    }\n    return text;\n  }\n  /**\n   * Restore original draftfile URLs.\n   *\n   * @param siteUrl Site URL.\n   * @param treatedText Treated text with replacements.\n   * @param originalText Original text.\n   * @param files List of files to search and replace.\n   * @returns Treated text.\n   */\n  restoreDraftfileUrls(siteUrl, treatedText, originalText, files) {\n    if (!treatedText || !files || !files.length) {\n      return treatedText;\n    }\n    const draftfileUrl = CorePath.concatenatePaths(siteUrl, 'draftfile.php');\n    const draftfileUrlRegexPrefix = this.escapeForRegex(draftfileUrl) + '/[^/]+/[^/]+/[^/]+/[^/]+/';\n    files.forEach(file => {\n      if (!file.filename) {\n        return;\n      }\n      // Search the draftfile URL in the original text.\n      const matches = originalText.match(new RegExp(draftfileUrlRegexPrefix + this.escapeForRegex(file.filename) + '[^\\'\" ]*', 'i'));\n      if (!matches || !matches[0]) {\n        return; // Original URL not found, skip.\n      }\n\n      treatedText = treatedText.replace(new RegExp(this.escapeForRegex(CoreFileHelper.getFileUrl(file)), 'g'), matches[0]);\n    });\n    return treatedText;\n  }\n  /**\n   * Replace pluginfile URLs with @@PLUGINFILE@@ wildcards.\n   *\n   * @param text Text to treat.\n   * @param files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.\n   * @returns Treated text.\n   */\n  restorePluginfileUrls(text, files) {\n    if (text && typeof text == 'string') {\n      const fileURL = this.getTextPluginfileUrl(files);\n      if (fileURL) {\n        return text.replace(new RegExp(this.escapeForRegex(fileURL), 'g'), '@@PLUGINFILE@@');\n      }\n    }\n    return text;\n  }\n  /**\n   * Rounds a number to use a certain amout of decimals or less.\n   * Difference between this function and float's toFixed:\n   * 7.toFixed(2) -> 7.00\n   * roundToDecimals(7, 2) -> 7\n   *\n   * @param num Number to round.\n   * @param decimals Number of decimals. By default, 2.\n   * @returns Rounded number.\n   */\n  roundToDecimals(num, decimals = 2) {\n    const multiplier = Math.pow(10, decimals);\n    return Math.round(num * multiplier) / multiplier;\n  }\n  /**\n   * Add quotes to HTML characters.\n   *\n   * Returns text with HTML characters (like \"<\", \">\", etc.) properly quoted.\n   * Based on Moodle's s() function.\n   *\n   * @param text Text to treat.\n   * @returns Treated text.\n   */\n  s(text) {\n    if (!text) {\n      return '';\n    }\n    return this.escapeHTML(text).replace(/&amp;#(\\d+|x[0-9a-f]+);/i, '&#$1;');\n  }\n  /**\n   * Shortens a text to length and adds an ellipsis.\n   *\n   * @param text The text to be shortened.\n   * @param length The desired length.\n   * @returns Shortened text.\n   */\n  shortenText(text, length) {\n    if (text.length > length) {\n      text = text.substring(0, length);\n      // Now, truncate at the last word boundary (if exists).\n      const lastWordPos = text.lastIndexOf(' ');\n      if (lastWordPos > 0) {\n        text = text.substring(0, lastWordPos);\n      }\n      text += '&hellip;';\n    }\n    return text;\n  }\n  /**\n   * Strip Unicode long char of a given text.\n   * Using as threshold Hex value D800\n   *\n   * @param text Text to check.\n   * @returns Without the Unicode chars.\n   */\n  stripUnicode(text) {\n    let stripped = '';\n    for (let x = 0; x < text.length; x++) {\n      if (text.charCodeAt(x) <= 55295) {\n        stripped += text.charAt(x);\n      }\n    }\n    return stripped;\n  }\n  /**\n   * Replace text within a portion of a string. Equivalent to PHP's substr_replace.\n   *\n   * @param str The string to treat.\n   * @param replace The value to put inside the string.\n   * @param start The index where to start putting the new string. If negative, it will count from the end of the string.\n   * @param length Length of the portion of string which is to be replaced. If negative, it represents the number of characters\n   *               from the end of string at which to stop replacing. If not provided, replace until the end of the string.\n   * @returns Treated string.\n   */\n  substrReplace(str, replace, start, length) {\n    return Locutus.substrReplace(str, replace, start, length);\n  }\n  /**\n   * Treat the list of disabled features, replacing old nomenclature with the new one.\n   *\n   * @param features List of disabled features.\n   * @returns Treated list.\n   */\n  treatDisabledFeatures(features) {\n    if (!features) {\n      return '';\n    }\n    for (let i = 0; i < this.DISABLED_FEATURES_COMPAT_REGEXPS.length; i++) {\n      const entry = this.DISABLED_FEATURES_COMPAT_REGEXPS[i];\n      features = features.replace(entry.old, entry.new);\n    }\n    return features;\n  }\n  /**\n   * Remove all ocurrences of a certain character from the start and end of a string.\n   *\n   * @param text Text to treat.\n   * @param character Character to remove.\n   * @returns Treated text.\n   */\n  trimCharacter(text, character) {\n    const escaped = this.escapeForRegex(character);\n    const regExp = new RegExp(`^${escaped}+|${escaped}+$`, 'g');\n    return text.replace(regExp, '');\n  }\n  /**\n   * If a number has only 1 digit, add a leading zero to it.\n   *\n   * @param num Number to convert.\n   * @returns Number with leading zeros.\n   */\n  twoDigits(num) {\n    if (Number(num) < 10) {\n      return '0' + num;\n    } else {\n      return '' + num; // Convert to string for coherence.\n    }\n  }\n  /**\n   * Make a string's first character uppercase.\n   *\n   * @param text Text to treat.\n   * @returns Treated text.\n   */\n  ucFirst(text) {\n    return text.charAt(0).toUpperCase() + text.slice(1);\n  }\n  /**\n   * Unserialize Array from PHP.\n   *\n   * @param data String to unserialize.\n   * @returns Unserialized data.\n   */\n  unserialize(data) {\n    return Locutus.unserialize(data);\n  }\n  /**\n   * Shows a text on a new page.\n   *\n   * @param title Title of the new state.\n   * @param content Content of the text to be expanded.\n   * @param options Options.\n   * @returns Promise resolved when the modal is displayed.\n   */\n  viewText(title, content, options) {\n    return _asyncToGenerator(function* () {\n      if (!content.length) {\n        return;\n      }\n      options = options || {};\n      const modalOptions = Object.assign(options.modalOptions || {}, {\n        component: CoreViewerTextComponent\n      });\n      delete options.modalOptions;\n      modalOptions.componentProps = _objectSpread({\n        title,\n        content\n      }, options);\n      yield CoreDomUtils.openModal(modalOptions);\n    })();\n  }\n}\n_class = CoreTextUtilsProvider;\n_class.ɵfac = function CoreTextUtilsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreTextUtils = makeSingleton(CoreTextUtilsProvider);\n/**\n * Define text formatting types.\n */\nexport var CoreTextFormat;\n(function (CoreTextFormat) {\n  CoreTextFormat[CoreTextFormat[\"FORMAT_MOODLE\"] = 0] = \"FORMAT_MOODLE\";\n  CoreTextFormat[CoreTextFormat[\"FORMAT_HTML\"] = 1] = \"FORMAT_HTML\";\n  CoreTextFormat[CoreTextFormat[\"FORMAT_PLAIN\"] = 2] = \"FORMAT_PLAIN\";\n  // FORMAT_WIKI is deprecated since 2005...\n  CoreTextFormat[CoreTextFormat[\"FORMAT_MARKDOWN\"] = 4] = \"FORMAT_MARKDOWN\";\n})(CoreTextFormat || (CoreTextFormat = {}));\nexport const defaultTextFormat = CoreTextFormat.FORMAT_HTML;","map":{"version":3,"names":["CoreError","DomSanitizer","makeSingleton","Translate","Locutus","CoreViewerTextComponent","CoreFileHelper","CoreDomUtils","CoreUrl","CorePath","CorePlatform","CoreTextUtilsProvider","constructor","DISABLED_FEATURES_COMPAT_REGEXPS","old","new","template","document","createElement","addEndingSlash","text","slice","addTextToError","error","message","content","body","addTitleToError","title","improvedError","buildAddressURL","address","parsedUrl","parse","protocol","bypassSecurityTrustUrl","isAndroid","encodeURIComponent","buildMessage","messages","result","forEach","buildSeveralParagraphsMessage","paragraphs","paragraph","getErrorMessageFromError","push","length","builtMessage","i","instant","p1","p2","bytesToSize","bytes","precision","undefined","keys","units","pos","Number","Math","round","parseFloat","size","unit","cleanTags","options","replace","convertToElement","textContent","trim","replaceNewLines","singleLine","html","innerHTML","children","countWords","decodeHTMLEntities","words","split","_unused","filter","word","decodeHTML","isNaN","decodeURI","uri","ex","decodeURIComponent","escapeForRegex","escapeHTML","doubleEncode","formatHtmlLines","hasHTMLTags","indexOf","getHTMLBodyContent","_matches$","matches","match","getTextPluginfileUrl","files","url","getFileUrl","substring","max","lastIndexOf","test","highlightText","searchText","regex","RegExp","htmlIsBlank","tags","querySelectorAll","hasUnicode","x","charCodeAt","hasUnicodeData","data","el","matchesGlob","pattern","parseJSON","json","defaultValue","logErrorFn","JSON","removeSpecialCharactersForFiles","replaceArguments","replacements","encoding","_replacements$argumen","argument","value","encodedValue","newValue","replaceDraftfileUrls","siteUrl","draftfileUrl","concatenatePaths","pluginfileMap","file","filename","replaceMap","replacePluginfileUrls","fileURL","restoreDraftfileUrls","treatedText","originalText","draftfileUrlRegexPrefix","restorePluginfileUrls","roundToDecimals","num","decimals","multiplier","pow","s","shortenText","lastWordPos","stripUnicode","stripped","charAt","substrReplace","str","start","treatDisabledFeatures","features","entry","trimCharacter","character","escaped","regExp","twoDigits","ucFirst","toUpperCase","unserialize","viewText","_asyncToGenerator","modalOptions","Object","assign","component","componentProps","_objectSpread","openModal","factory","ɵfac","providedIn","CoreTextUtils","CoreTextFormat","defaultTextFormat","FORMAT_HTML"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/utils/text.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { SafeUrl } from '@angular/platform-browser';\nimport { ModalOptions } from '@ionic/core';\n\nimport { CoreAnyError, CoreError } from '@classes/errors/error';\nimport { DomSanitizer, makeSingleton, Translate } from '@singletons';\nimport { CoreWSFile } from '@services/ws';\nimport { Locutus } from '@singletons/locutus';\nimport { CoreViewerTextComponent } from '@features/viewer/components/text/text';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreDomUtils } from './dom';\nimport { CoreUrl } from '@singletons/url';\nimport { AlertButton } from '@ionic/angular';\nimport { CorePath } from '@singletons/path';\nimport { CorePlatform } from '@services/platform';\n\n/**\n * Different type of errors the app can treat.\n */\nexport type CoreTextErrorObject = {\n    message?: string;\n    error?: string;\n    content?: string;\n    body?: string;\n    debuginfo?: string;\n    backtrace?: string;\n    title?: string;\n    buttons?: AlertButton[];\n};\n\n/*\n * \"Utils\" service with helper functions for text.\n*/\n@Injectable({ providedIn: 'root' })\nexport class CoreTextUtilsProvider {\n\n    // List of regular expressions to convert the old nomenclature to new nomenclature for disabled features.\n    protected readonly DISABLED_FEATURES_COMPAT_REGEXPS: { old: RegExp; new: string }[] = [\n        { old: /\\$mmLoginEmailSignup/g, new: 'CoreLoginEmailSignup' },\n        { old: /\\$mmSideMenuDelegate/g, new: 'CoreMainMenuDelegate' },\n        { old: /\\$mmCoursesDelegate/g, new: 'CoreCourseOptionsDelegate' },\n        { old: /\\$mmUserDelegate/g, new: 'CoreUserDelegate' },\n        { old: /\\$mmCourseDelegate/g, new: 'CoreCourseModuleDelegate' },\n        { old: /_mmCourses/g, new: '_CoreCourses' },\n        { old: /_mmaFrontpage/g, new: '_CoreSiteHome' },\n        { old: /_mmaGrades/g, new: '_CoreGrades' },\n        { old: /_mmaCompetency/g, new: '_AddonCompetency' },\n        { old: /_mmaNotifications/g, new: '_AddonNotifications' },\n        { old: /_mmaMessages/g, new: '_AddonMessages' },\n        { old: /_mmaCalendar/g, new: '_AddonCalendar' },\n        { old: /_mmaFiles/g, new: '_AddonPrivateFiles' },\n        { old: /_mmaParticipants/g, new: '_CoreUserParticipants' },\n        { old: /_mmaCourseCompletion/g, new: '_AddonCourseCompletion' },\n        { old: /_mmaNotes/g, new: '_AddonNotes' },\n        { old: /_mmaBadges/g, new: '_AddonBadges' },\n        { old: /files_privatefiles/g, new: 'AddonPrivateFilesPrivateFiles' },\n        { old: /files_sitefiles/g, new: 'AddonPrivateFilesSiteFiles' },\n        { old: /files_upload/g, new: 'AddonPrivateFilesUpload' },\n        { old: /_mmaModAssign/g, new: '_AddonModAssign' },\n        { old: /_mmaModBigbluebuttonbn/g, new: '_AddonModBBB' },\n        { old: /_mmaModBook/g, new: '_AddonModBook' },\n        { old: /_mmaModChat/g, new: '_AddonModChat' },\n        { old: /_mmaModChoice/g, new: '_AddonModChoice' },\n        { old: /_mmaModData/g, new: '_AddonModData' },\n        { old: /_mmaModFeedback/g, new: '_AddonModFeedback' },\n        { old: /_mmaModFolder/g, new: '_AddonModFolder' },\n        { old: /_mmaModForum/g, new: '_AddonModForum' },\n        { old: /_mmaModGlossary/g, new: '_AddonModGlossary' },\n        { old: /_mmaModH5pactivity/g, new: '_AddonModH5PActivity' },\n        { old: /_mmaModImscp/g, new: '_AddonModImscp' },\n        { old: /_mmaModLabel/g, new: '_AddonModLabel' },\n        { old: /_mmaModLesson/g, new: '_AddonModLesson' },\n        { old: /_mmaModLti/g, new: '_AddonModLti' },\n        { old: /_mmaModPage/g, new: '_AddonModPage' },\n        { old: /_mmaModQuiz/g, new: '_AddonModQuiz' },\n        { old: /_mmaModResource/g, new: '_AddonModResource' },\n        { old: /_mmaModScorm/g, new: '_AddonModScorm' },\n        { old: /_mmaModSurvey/g, new: '_AddonModSurvey' },\n        { old: /_mmaModUrl/g, new: '_AddonModUrl' },\n        { old: /_mmaModWiki/g, new: '_AddonModWiki' },\n        { old: /_mmaModWorkshop/g, new: '_AddonModWorkshop' },\n        { old: /remoteAddOn_/g, new: 'sitePlugin_' },\n        { old: /AddonNotes:addNote/g, new: 'AddonNotes:notes' },\n    ];\n\n    protected template: HTMLTemplateElement = document.createElement('template'); // A template element to convert HTML to element.\n\n    /**\n     * Add ending slash from a path or URL.\n     *\n     * @param text Text to treat.\n     * @returns Treated text.\n     */\n    addEndingSlash(text: string): string {\n        if (!text) {\n            return '';\n        }\n\n        if (text.slice(-1) != '/') {\n            return text + '/';\n        }\n\n        return text;\n    }\n\n    /**\n     * Add some text to an error message.\n     *\n     * @param error Error message or object.\n     * @param text Text to add.\n     * @returns Modified error.\n     */\n    addTextToError(error: string | CoreError | CoreTextErrorObject | undefined | null, text: string): string | CoreTextErrorObject {\n        if (typeof error == 'string') {\n            return error + text;\n        }\n\n        if (error instanceof CoreError) {\n            error.message += text;\n\n            return error;\n        }\n\n        if (!error) {\n            return text;\n        }\n\n        if (typeof error.message == 'string') {\n            error.message += text;\n        } else if (typeof error.error == 'string') {\n            error.error += text;\n        } else if (typeof error.content == 'string') {\n            error.content += text;\n        } else if (typeof error.body == 'string') {\n            error.body += text;\n        }\n\n        return error;\n    }\n\n    /**\n     * Add some title to an error message.\n     *\n     * @param error Error message or object.\n     * @param title Title to add.\n     * @returns Modified error.\n     */\n    addTitleToError(error: string | CoreError | CoreTextErrorObject | undefined | null, title: string): CoreTextErrorObject {\n        let improvedError: CoreTextErrorObject = {};\n\n        if (typeof error === 'string') {\n            improvedError.message = error;\n        } else if (error && 'message' in error) {\n            improvedError = error;\n        }\n\n        improvedError.title = improvedError.title || title;\n\n        return improvedError;\n    }\n\n    /**\n     * Given an address as a string, return a URL to open the address in maps.\n     *\n     * @param address The address.\n     * @returns URL to view the address.\n     */\n    buildAddressURL(address: string): SafeUrl {\n        const parsedUrl = CoreUrl.parse(address);\n        if (parsedUrl?.protocol) {\n            // It's already a URL, don't convert it.\n            return DomSanitizer.bypassSecurityTrustUrl(address);\n        }\n\n        return DomSanitizer.bypassSecurityTrustUrl((CorePlatform.isAndroid() ? 'geo:0,0?q=' : 'http://maps.google.com?q=') +\n                encodeURIComponent(address));\n    }\n\n    /**\n     * Given a list of sentences, build a message with all of them wrapped in <p>.\n     *\n     * @param messages Messages to show.\n     * @returns Message with all the messages.\n     */\n    buildMessage(messages: string[]): string {\n        let result = '';\n\n        messages.forEach((message) => {\n            if (message) {\n                result += `<p>${message}</p>`;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Build a message with several paragraphs.\n     *\n     * @param paragraphs List of paragraphs.\n     * @returns Built message.\n     */\n    buildSeveralParagraphsMessage(paragraphs: (string | CoreTextErrorObject)[]): string {\n        // Filter invalid messages, and convert them to messages in case they're errors.\n        const messages: string[] = [];\n\n        paragraphs.forEach(paragraph => {\n            // If it's an error, get its message.\n            const message = this.getErrorMessageFromError(paragraph);\n\n            if (paragraph && message) {\n                messages.push(message);\n            }\n        });\n\n        if (messages.length < 2) {\n            return messages[0] || '';\n        }\n\n        let builtMessage = messages[0];\n\n        for (let i = 1; i < messages.length; i++) {\n            builtMessage = Translate.instant('core.twoparagraphs', { p1: builtMessage, p2: messages[i] });\n        }\n\n        return builtMessage;\n    }\n\n    /**\n     * Convert size in bytes into human readable format\n     *\n     * @param bytes Number of bytes to convert.\n     * @param precision Number of digits after the decimal separator.\n     * @returns Size in human readable format.\n     */\n    bytesToSize(bytes: number, precision: number = 2): string {\n        if (bytes === undefined || bytes === null || bytes < 0) {\n            return Translate.instant('core.notapplicable');\n        }\n\n        if (precision < 0) {\n            precision = 2;\n        }\n\n        const keys = ['core.sizeb', 'core.sizekb', 'core.sizemb', 'core.sizegb', 'core.sizetb'];\n        const units = Translate.instant(keys);\n        let pos = 0;\n\n        if (bytes >= 1024) {\n            while (bytes >= 1024) {\n                pos++;\n                bytes = bytes / 1024;\n            }\n            // Round to \"precision\" decimals if needed.\n            bytes = Number(Math.round(parseFloat(bytes + 'e+' + precision)) + 'e-' + precision);\n        }\n\n        return Translate.instant('core.humanreadablesize', { size: bytes, unit: units[keys[pos]] });\n    }\n\n    /**\n     * Clean HTML tags.\n     *\n     * @param text The text to be cleaned.\n     * @param options Processing options.\n     * @param options.singleLine True if new lines should be removed (all the text in a single line).\n     * @param options.trim True if text should be trimmed.\n     * @returns Clean text.\n     */\n    cleanTags(text: string | undefined, options: { singleLine?: boolean; trim?: boolean } = {}): string {\n        if (!text) {\n            return '';\n        }\n\n        // First, we use a regexpr.\n        text = text.replace(/(<([^>]+)>)/ig, '');\n        // Then, we rely on the browser. We need to wrap the text to be sure is HTML.\n        text = this.convertToElement(text).textContent || '';\n        // Trim text\n        text = options.trim ? text.trim() : text;\n        // Recover or remove new lines.\n        text = this.replaceNewLines(text, options.singleLine ? ' ' : '<br>');\n\n        return text;\n    }\n\n    /**\n     * Convert some HTML as text into an HTMLElement. This HTML is put inside a div or a body.\n     * This function is the same as in DomUtils, but we cannot use that one because of circular dependencies.\n     *\n     * @param html Text to convert.\n     * @returns Element.\n     */\n    protected convertToElement(html: string): HTMLElement {\n        // Add a div to hold the content, that's the element that will be returned.\n        this.template.innerHTML = '<div>' + html + '</div>';\n\n        return <HTMLElement> this.template.content.children[0];\n    }\n\n    /**\n     * Count words in a text.\n     * This function is based on Moodle's count_words.\n     *\n     * @param text Text to count.\n     * @returns Number of words.\n     */\n    countWords(text?: string | null): number {\n        if (!text || typeof text != 'string') {\n            return 0;\n        }\n\n        // Before stripping tags, add a space after the close tag of anything that is not obviously inline.\n        // Also, br is a special case because it definitely delimits a word, but has no close tag.\n        text = text.replace(/(<\\/(?!a>|b>|del>|em>|i>|ins>|s>|small>|span>|strong>|sub>|sup>|u>)\\w+>|<br>|<br\\s*\\/>)/ig, '$1 ');\n\n        // Now remove HTML tags.\n        text = text.replace(/(<([^>]+)>)/ig, '');\n        // Decode HTML entities.\n        text = this.decodeHTMLEntities(text);\n\n        // Now, the word count is the number of blocks of characters separated\n        // by any sort of space. That seems to be the definition used by all other systems.\n        // To be precise about what is considered to separate words:\n        // * Anything that Unicode considers a 'Separator'\n        // * Anything that Unicode considers a 'Control character'\n        // * An em- or en- dash.\n        let words: string[];\n        try {\n            words = text.split(/[\\p{Z}\\p{Cc}—–]+/u);\n        } catch {\n            // Unicode-aware flag not supported.\n            words = text.split(/\\s+/);\n        }\n\n        // Filter empty words.\n        return words.filter(word => word).length;\n    }\n\n    /**\n     * Decode an escaped HTML text. This implementation is based on PHP's htmlspecialchars_decode.\n     *\n     * @param text Text to decode.\n     * @returns Decoded text.\n     */\n    decodeHTML(text: string | number): string {\n        if (text === undefined || text === null || (typeof text == 'number' && isNaN(text))) {\n            return '';\n        } else if (typeof text != 'string') {\n            return '' + text;\n        }\n\n        return text\n            .replace(/&amp;/g, '&')\n            .replace(/&lt;/g, '<')\n            .replace(/&gt;/g, '>')\n            .replace(/&quot;/g, '\"')\n            .replace(/&#039;/g, '\\'')\n            .replace(/&nbsp;/g, ' ');\n    }\n\n    /**\n     * Decode HTML entities in a text. Equivalent to PHP html_entity_decode.\n     *\n     * @param text Text to decode.\n     * @returns Decoded text.\n     */\n    decodeHTMLEntities(text: string): string {\n        if (text) {\n            text = this.convertToElement(text).textContent || '';\n        }\n\n        return text;\n    }\n\n    /**\n     * Same as Javascript's decodeURI, but if an exception is thrown it will return the original URI.\n     *\n     * @param uri URI to decode.\n     * @returns Decoded URI, or original URI if an exception is thrown.\n     */\n    decodeURI(uri: string): string {\n        try {\n            return decodeURI(uri);\n        } catch (ex) {\n            // Error, use the original URI.\n        }\n\n        return uri;\n    }\n\n    /**\n     * Same as Javascript's decodeURIComponent, but if an exception is thrown it will return the original URI.\n     *\n     * @param uri URI to decode.\n     * @returns Decoded URI, or original URI if an exception is thrown.\n     */\n    decodeURIComponent(uri: string): string {\n        try {\n            return decodeURIComponent(uri);\n        } catch (ex) {\n            // Error, use the original URI.\n        }\n\n        return uri;\n    }\n\n    /**\n     * Escapes some characters in a string to be used as a regular expression.\n     *\n     * @param text Text to escape.\n     * @returns Escaped text.\n     */\n    escapeForRegex(text: string): string {\n        if (!text || typeof text != 'string') {\n            return '';\n        }\n\n        return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n    }\n\n    /**\n     * Escape an HTML text. This implementation is based on PHP's htmlspecialchars.\n     *\n     * @param text Text to escape.\n     * @param doubleEncode If false, it will not convert existing html entities. Defaults to true.\n     * @returns Escaped text.\n     */\n    escapeHTML(text?: string | number | null, doubleEncode: boolean = true): string {\n        if (text === undefined || text === null || (typeof text == 'number' && isNaN(text))) {\n            return '';\n        } else if (typeof text != 'string') {\n            return '' + text;\n        }\n\n        if (doubleEncode) {\n            text = text.replace(/&/g, '&amp;');\n        } else {\n            text = text.replace(/&(?!amp;)(?!lt;)(?!gt;)(?!quot;)(?!#039;)/g, '&amp;');\n        }\n\n        return text\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#039;');\n    }\n\n    /**\n     * Formats a text, in HTML replacing new lines by correct html new lines.\n     *\n     * @param text Text to format.\n     * @returns Formatted text.\n     */\n    formatHtmlLines(text: string): string {\n        const hasHTMLTags = this.hasHTMLTags(text);\n        if (text.indexOf('<p>') == -1) {\n            // Wrap the text in <p> tags.\n            text = '<p>' + text + '</p>';\n        }\n\n        if (!hasHTMLTags) {\n            // The text doesn't have HTML, replace new lines for <br>.\n            return this.replaceNewLines(text, '<br>');\n        }\n\n        return text;\n    }\n\n    /**\n     * Get the error message from an error object.\n     *\n     * @param error Error.\n     * @returns Error message, undefined if not found.\n     */\n    getErrorMessageFromError(error?: CoreAnyError): string | undefined {\n        if (typeof error === 'string') {\n            return error;\n        }\n\n        if (error instanceof CoreError) {\n            return error.message;\n        }\n\n        if (!error) {\n            return undefined;\n        }\n\n        return error.message || error.error || error.content || error.body;\n    }\n\n    /**\n     * Given some HTML code, return the HTML code inside <body> tags. If there are no body tags, return the whole HTML.\n     *\n     * @param html HTML text.\n     * @returns Body HTML.\n     */\n    getHTMLBodyContent(html: string): string {\n        const matches = html.match(/<body>([\\s\\S]*)<\\/body>/im);\n\n        return matches?.[1] ?? html;\n    }\n\n    /**\n     * Get the pluginfile URL to replace @@PLUGINFILE@@ wildcards.\n     *\n     * @param files Files to extract the URL from. They need to have the URL in a 'url' or 'fileurl' attribute.\n     * @returns Pluginfile URL, undefined if no files found.\n     */\n    getTextPluginfileUrl(files: CoreWSFile[]): string | undefined {\n        if (files?.length) {\n            const url = CoreFileHelper.getFileUrl(files[0]);\n\n            // Remove text after last slash (encoded or not).\n            return url?.substring(0, Math.max(url.lastIndexOf('/'), url.lastIndexOf('%2F')));\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Check if a text contains HTML tags.\n     *\n     * @param text Text to check.\n     * @returns Whether it has HTML tags.\n     */\n    hasHTMLTags(text: string): boolean {\n        return /<[a-z][\\s\\S]*>/i.test(text);\n    }\n\n    /**\n     * Highlight all occurrences of a certain text inside another text. It will add some HTML code to highlight it.\n     *\n     * @param text Full text.\n     * @param searchText Text to search and highlight.\n     * @returns Highlighted text.\n     */\n    highlightText(text: string, searchText: string): string {\n        if (!text || typeof text != 'string') {\n            return '';\n        } else if (!searchText) {\n            return text;\n        }\n\n        const regex = new RegExp('(' + searchText + ')', 'gi');\n\n        return text.replace(regex, '<mark class=\"matchtext\">$1</mark>');\n    }\n\n    /**\n     * Check if HTML content is blank.\n     *\n     * @param content HTML content.\n     * @returns True if the string does not contain actual content: text, images, etc.\n     */\n    htmlIsBlank(content: string): boolean {\n        if (!content) {\n            return true;\n        }\n\n        this.template.innerHTML = content.trim().replace(/(\\r\\n|\\n|\\r)/g, '');\n        const tags = this.template.content.querySelectorAll(\n            'img, audio, video, object, iframe, canvas, svg, input, select, textarea, frame, embed',\n        );\n\n        return this.template.content.textContent === '' && tags.length === 0;\n    }\n\n    /**\n     * Check if a text contains Unicode long chars.\n     * Using as threshold Hex value D800\n     *\n     * @param text Text to check.\n     * @returns True if has Unicode chars, false otherwise.\n     */\n    hasUnicode(text: string): boolean {\n        for (let x = 0; x < text.length; x++) {\n            if (text.charCodeAt(x) > 55295) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if an object has any long Unicode char.\n     *\n     * @param data Object to be checked.\n     * @returns If the data has any long Unicode char on it.\n     */\n    hasUnicodeData(data: Record<string, unknown>): boolean {\n        for (const el in data) {\n            if (typeof data[el] == 'object') {\n                if (this.hasUnicodeData(data[el] as Record<string, unknown>)) {\n                    return true;\n                }\n\n                continue;\n            }\n\n            if (typeof data[el] == 'string' && this.hasUnicode(data[el] as string)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check whether the given text matches a glob pattern.\n     *\n     * @param text Text to match against.\n     * @param pattern Glob pattern.\n     * @returns Whether the pattern matches.\n     */\n    matchesGlob(text: string, pattern: string): boolean {\n        pattern = pattern\n            .replace(/\\*\\*/g, '%RECURSIVE_MATCH%')\n            .replace(/\\*/g, '%LOCAL_MATCH%')\n            .replace(/\\?/g, '%CHARACTER_MATCH%');\n\n        pattern = this.escapeForRegex(pattern);\n\n        pattern = pattern\n            .replace(/%RECURSIVE_MATCH%/g, '.*')\n            .replace(/%LOCAL_MATCH%/g, '[^/]*')\n            .replace(/%CHARACTER_MATCH%/g, '[^/]');\n\n        return new RegExp(`^${pattern}$`).test(text);\n    }\n\n    /**\n     * Same as Javascript's JSON.parse, but it will handle errors.\n     *\n     * @param json JSON text.\n     * @param defaultValue Default value to return if the parse fails. Defaults to the original value.\n     * @param logErrorFn An error to call with the exception to log the error. If not supplied, no error.\n     * @returns JSON parsed as object or what it gets.\n     */\n    parseJSON<T>(json: string, defaultValue?: T, logErrorFn?: (error?: Error) => void): T {\n        try {\n            return JSON.parse(json);\n        } catch (error) {\n            // Error, log the error if needed.\n            if (logErrorFn) {\n                logErrorFn(error);\n            }\n        }\n\n        // Error parsing, return the default value or the original value.\n        if (defaultValue !== undefined) {\n            return defaultValue;\n        }\n\n        throw new CoreError('JSON cannot be parsed and not default value has been provided') ;\n    }\n\n    /**\n     * Replace all characters that cause problems with files in Android and iOS.\n     *\n     * @param text Text to treat.\n     * @returns Treated text.\n     */\n    removeSpecialCharactersForFiles(text: string): string {\n        if (!text || typeof text != 'string') {\n            return '';\n        }\n\n        return text.replace(/[#:/?\\\\]+/g, '_');\n    }\n\n    /**\n     * Replace {{ARGUMENT}} arguments in the text.\n     *\n     * @param text Text to treat.\n     * @param replacements Argument values.\n     * @param encoding Encoding to use in values.\n     * @returns Treated text.\n     */\n    replaceArguments(text: string, replacements: Record<string, string> = {}, encoding?: 'uri'): string {\n        let match: RegExpMatchArray | null = null;\n\n        while ((match = text.match(/\\{\\{([^}]+)\\}\\}/))) {\n            const argument = match[1].trim();\n            const value = replacements[argument] ?? '';\n            const encodedValue = encoding ? encodeURIComponent(value) : value;\n\n            text = text.replace(`{{${argument}}}`, encodedValue);\n        }\n\n        return text;\n    }\n\n    /**\n     * Replace all the new lines on a certain text.\n     *\n     * @param text The text to be treated.\n     * @param newValue Text to use instead of new lines.\n     * @returns Treated text.\n     */\n    replaceNewLines(text: string, newValue: string): string {\n        if (!text || typeof text != 'string') {\n            return '';\n        }\n\n        return text.replace(/(?:\\r\\n|\\r|\\n)/g, newValue);\n    }\n\n    /**\n     * Replace draftfile URLs with the equivalent pluginfile URL.\n     *\n     * @param siteUrl URL of the site.\n     * @param text Text to treat, including draftfile URLs.\n     * @param files List of files of the area, using pluginfile URLs.\n     * @returns Treated text and map with the replacements.\n     */\n    replaceDraftfileUrls(\n        siteUrl: string,\n        text: string,\n        files: CoreWSFile[],\n    ): { text: string; replaceMap?: {[url: string]: string} } {\n\n        if (!text || !files || !files.length) {\n            return { text };\n        }\n\n        const draftfileUrl = CorePath.concatenatePaths(siteUrl, 'draftfile.php');\n        const matches = text.match(new RegExp(this.escapeForRegex(draftfileUrl) + '[^\\'\" ]+', 'ig'));\n\n        if (!matches || !matches.length) {\n            return { text };\n        }\n\n        // Index the pluginfile URLs by file name.\n        const pluginfileMap: {[name: string]: string} = {};\n        files.forEach((file) => {\n            if (!file.filename) {\n                return;\n            }\n            pluginfileMap[file.filename] = CoreFileHelper.getFileUrl(file);\n        });\n\n        // Replace each draftfile with the corresponding pluginfile URL.\n        const replaceMap: {[url: string]: string} = {};\n        matches.forEach((url) => {\n            if (replaceMap[url]) {\n                // URL already treated, same file embedded more than once.\n                return;\n            }\n\n            // Get the filename from the URL.\n            let filename = url.substring(url.lastIndexOf('/') + 1);\n            if (filename.indexOf('?') != -1) {\n                filename = filename.substring(0, filename.indexOf('?'));\n            }\n\n            if (pluginfileMap[filename]) {\n                replaceMap[url] = pluginfileMap[filename];\n                text = text.replace(new RegExp(this.escapeForRegex(url), 'g'), pluginfileMap[filename]);\n            }\n        });\n\n        return {\n            text,\n            replaceMap,\n        };\n    }\n\n    /**\n     * Replace @@PLUGINFILE@@ wildcards with the real URL in a text.\n     *\n     * @param text to treat.\n     * @param files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.\n     * @returns Treated text.\n     */\n    replacePluginfileUrls(text: string, files: CoreWSFile[]): string {\n        if (text && typeof text == 'string') {\n            const fileURL = this.getTextPluginfileUrl(files);\n            if (fileURL) {\n                return text.replace(/@@PLUGINFILE@@/g, fileURL);\n            }\n        }\n\n        return text;\n    }\n\n    /**\n     * Restore original draftfile URLs.\n     *\n     * @param siteUrl Site URL.\n     * @param treatedText Treated text with replacements.\n     * @param originalText Original text.\n     * @param files List of files to search and replace.\n     * @returns Treated text.\n     */\n    restoreDraftfileUrls(siteUrl: string, treatedText: string, originalText: string, files: CoreWSFile[]): string {\n        if (!treatedText || !files || !files.length) {\n            return treatedText;\n        }\n\n        const draftfileUrl = CorePath.concatenatePaths(siteUrl, 'draftfile.php');\n        const draftfileUrlRegexPrefix = this.escapeForRegex(draftfileUrl) + '/[^/]+/[^/]+/[^/]+/[^/]+/';\n\n        files.forEach((file) => {\n            if (!file.filename) {\n                return;\n            }\n\n            // Search the draftfile URL in the original text.\n            const matches = originalText.match(\n                new RegExp(draftfileUrlRegexPrefix + this.escapeForRegex(file.filename) + '[^\\'\" ]*', 'i'),\n            );\n\n            if (!matches || !matches[0]) {\n                return; // Original URL not found, skip.\n            }\n\n            treatedText = treatedText.replace(new RegExp(this.escapeForRegex(CoreFileHelper.getFileUrl(file)), 'g'), matches[0]);\n        });\n\n        return treatedText;\n    }\n\n    /**\n     * Replace pluginfile URLs with @@PLUGINFILE@@ wildcards.\n     *\n     * @param text Text to treat.\n     * @param files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.\n     * @returns Treated text.\n     */\n    restorePluginfileUrls(text: string, files: CoreWSFile[]): string {\n        if (text && typeof text == 'string') {\n            const fileURL = this.getTextPluginfileUrl(files);\n            if (fileURL) {\n                return text.replace(new RegExp(this.escapeForRegex(fileURL), 'g'), '@@PLUGINFILE@@');\n            }\n        }\n\n        return text;\n    }\n\n    /**\n     * Rounds a number to use a certain amout of decimals or less.\n     * Difference between this function and float's toFixed:\n     * 7.toFixed(2) -> 7.00\n     * roundToDecimals(7, 2) -> 7\n     *\n     * @param num Number to round.\n     * @param decimals Number of decimals. By default, 2.\n     * @returns Rounded number.\n     */\n    roundToDecimals(num: number, decimals: number = 2): number {\n        const multiplier = Math.pow(10, decimals);\n\n        return Math.round(num * multiplier) / multiplier;\n    }\n\n    /**\n     * Add quotes to HTML characters.\n     *\n     * Returns text with HTML characters (like \"<\", \">\", etc.) properly quoted.\n     * Based on Moodle's s() function.\n     *\n     * @param text Text to treat.\n     * @returns Treated text.\n     */\n    s(text: string): string {\n        if (!text) {\n            return '';\n        }\n\n        return this.escapeHTML(text).replace(/&amp;#(\\d+|x[0-9a-f]+);/i, '&#$1;');\n    }\n\n    /**\n     * Shortens a text to length and adds an ellipsis.\n     *\n     * @param text The text to be shortened.\n     * @param length The desired length.\n     * @returns Shortened text.\n     */\n    shortenText(text: string, length: number): string {\n        if (text.length > length) {\n            text = text.substring(0, length);\n\n            // Now, truncate at the last word boundary (if exists).\n            const lastWordPos = text.lastIndexOf(' ');\n            if (lastWordPos > 0) {\n                text = text.substring(0, lastWordPos);\n            }\n            text += '&hellip;';\n        }\n\n        return text;\n    }\n\n    /**\n     * Strip Unicode long char of a given text.\n     * Using as threshold Hex value D800\n     *\n     * @param text Text to check.\n     * @returns Without the Unicode chars.\n     */\n    stripUnicode(text: string): string {\n        let stripped = '';\n        for (let x = 0; x < text.length; x++) {\n            if (text.charCodeAt(x) <= 55295) {\n                stripped += text.charAt(x);\n            }\n        }\n\n        return stripped;\n    }\n\n    /**\n     * Replace text within a portion of a string. Equivalent to PHP's substr_replace.\n     *\n     * @param str The string to treat.\n     * @param replace The value to put inside the string.\n     * @param start The index where to start putting the new string. If negative, it will count from the end of the string.\n     * @param length Length of the portion of string which is to be replaced. If negative, it represents the number of characters\n     *               from the end of string at which to stop replacing. If not provided, replace until the end of the string.\n     * @returns Treated string.\n     */\n    substrReplace(str: string, replace: string, start: number, length?: number): string {\n        return Locutus.substrReplace(str, replace, start, length);\n    }\n\n    /**\n     * Treat the list of disabled features, replacing old nomenclature with the new one.\n     *\n     * @param features List of disabled features.\n     * @returns Treated list.\n     */\n    treatDisabledFeatures(features: string): string {\n        if (!features) {\n            return '';\n        }\n\n        for (let i = 0; i < this.DISABLED_FEATURES_COMPAT_REGEXPS.length; i++) {\n            const entry = this.DISABLED_FEATURES_COMPAT_REGEXPS[i];\n\n            features = features.replace(entry.old, entry.new);\n        }\n\n        return features;\n    }\n\n    /**\n     * Remove all ocurrences of a certain character from the start and end of a string.\n     *\n     * @param text Text to treat.\n     * @param character Character to remove.\n     * @returns Treated text.\n     */\n    trimCharacter(text: string, character: string): string {\n        const escaped = this.escapeForRegex(character);\n        const regExp = new RegExp(`^${escaped}+|${escaped}+$`, 'g');\n\n        return text.replace(regExp, '');\n    }\n\n    /**\n     * If a number has only 1 digit, add a leading zero to it.\n     *\n     * @param num Number to convert.\n     * @returns Number with leading zeros.\n     */\n    twoDigits(num: string | number): string {\n        if (Number(num) < 10) {\n            return '0' + num;\n        } else {\n            return '' + num; // Convert to string for coherence.\n        }\n    }\n\n    /**\n     * Make a string's first character uppercase.\n     *\n     * @param text Text to treat.\n     * @returns Treated text.\n     */\n    ucFirst(text: string): string {\n        return text.charAt(0).toUpperCase() + text.slice(1);\n    }\n\n    /**\n     * Unserialize Array from PHP.\n     *\n     * @param data String to unserialize.\n     * @returns Unserialized data.\n     */\n    unserialize<T = unknown>(data: string): T {\n        return Locutus.unserialize<T>(data);\n    }\n\n    /**\n     * Shows a text on a new page.\n     *\n     * @param title Title of the new state.\n     * @param content Content of the text to be expanded.\n     * @param options Options.\n     * @returns Promise resolved when the modal is displayed.\n     */\n    async viewText(title: string, content: string, options?: CoreTextUtilsViewTextOptions): Promise<void> {\n        if (!content.length) {\n            return;\n        }\n\n        options = options || {};\n\n        const modalOptions: ModalOptions = Object.assign(options.modalOptions || {}, {\n            component: CoreViewerTextComponent,\n        });\n        delete options.modalOptions;\n        modalOptions.componentProps = {\n            title,\n            content,\n            ...options,\n        };\n\n        await CoreDomUtils.openModal(modalOptions);\n    }\n\n}\nexport const CoreTextUtils = makeSingleton(CoreTextUtilsProvider);\n\n/**\n * Options for viewText.\n */\nexport type CoreTextUtilsViewTextOptions = {\n    component?: string; // Component to link the embedded files to.\n    componentId?: string | number; // An ID to use in conjunction with the component.\n    files?: CoreWSFile[]; // List of files to display along with the text.\n    filter?: boolean; // Whether the text should be filtered.\n    contextLevel?: string; // The context level.\n    instanceId?: number; // The instance ID related to the context.\n    courseId?: number; // Course ID the text belongs to. It can be used to improve performance with filters.\n    displayCopyButton?: boolean; // Whether to display a button to copy the text.\n    modalOptions?: Partial<ModalOptions>; // Modal options.\n};\n\n/**\n * Define text formatting types.\n */\nexport enum CoreTextFormat {\n    FORMAT_MOODLE = 0, // Does all sorts of transformations and filtering.\n    FORMAT_HTML = 1, // Plain HTML (with some tags stripped). Use it by default.\n    FORMAT_PLAIN = 2, // Plain text (even tags are printed in full).\n    // FORMAT_WIKI is deprecated since 2005...\n    FORMAT_MARKDOWN = 4, // Markdown-formatted text http://daringfireball.net/projects/markdown/\n}\n\nexport const defaultTextFormat = CoreTextFormat.FORMAT_HTML;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}