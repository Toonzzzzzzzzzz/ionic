{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { ATTEMPTS_TABLE_NAME, TRACKS_TABLE_NAME } from './database/scorm';\nimport { AddonModScormProvider } from './scorm';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline SCORM.\n */\nexport class AddonModScormOfflineProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('AddonModScormOfflineProvider');\n  }\n  /**\n   * Changes an attempt number in the data stored in offline.\n   * This function is used to convert attempts into new attempts, so the stored snapshot will be removed and\n   * entries will be marked as not synced.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Number of the attempt to change.\n   * @param newAttempt New attempt number.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the attempt number changes.\n   */\n  changeAttemptNumber(scormId, attempt, newAttempt, siteId, userId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      _this.logger.debug(`Change attempt number from ${attempt} to ${newAttempt} in SCORM ${scormId}`);\n      // Update the attempt number.\n      const db = site.getDb();\n      const currentAttemptConditions = {\n        scormid: scormId,\n        userid: userId,\n        attempt\n      };\n      const newAttemptConditions = {\n        scormid: scormId,\n        userid: userId,\n        attempt: newAttempt\n      };\n      const newAttemptData = {\n        attempt: newAttempt,\n        timemodified: CoreTimeUtils.timestamp()\n      };\n      // Block the SCORM so it can't be synced.\n      CoreSync.blockOperation(AddonModScormProvider.COMPONENT, scormId, 'changeAttemptNumber', site.id);\n      try {\n        yield db.updateRecords(ATTEMPTS_TABLE_NAME, newAttemptData, currentAttemptConditions);\n        try {\n          // Now update the attempt number of all the tracks and mark them as not synced.\n          const newTrackData = {\n            attempt: newAttempt,\n            synced: 0\n          };\n          yield db.updateRecords(TRACKS_TABLE_NAME, newTrackData, currentAttemptConditions);\n        } catch (error) {\n          // Failed to update the tracks, restore the old attempt number.\n          yield db.updateRecords(ATTEMPTS_TABLE_NAME, {\n            attempt\n          }, newAttemptConditions);\n          throw error;\n        }\n      } finally {\n        // Unblock the SCORM.\n        CoreSync.unblockOperation(AddonModScormProvider.COMPONENT, scormId, 'changeAttemptNumber', site.id);\n      }\n    })();\n  }\n  /**\n   * Creates a new offline attempt. It can be created from scratch or as a copy of another attempt.\n   *\n   * @param scorm SCORM.\n   * @param attempt Number of the new attempt.\n   * @param userData User data to store in the attempt.\n   * @param snapshot Optional. Snapshot to store in the attempt.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the new attempt is created.\n   */\n  createNewAttempt(scorm, attempt, userData, snapshot, siteId, userId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      _this2.logger.debug(`Creating new offline attempt ${attempt} in SCORM ${scorm.id}`);\n      // Block the SCORM so it can't be synced.\n      CoreSync.blockOperation(AddonModScormProvider.COMPONENT, scorm.id, 'createNewAttempt', site.id);\n      // Create attempt in DB.\n      const db = site.getDb();\n      const entry = {\n        scormid: scorm.id,\n        userid: userId,\n        attempt,\n        courseid: scorm.course,\n        timecreated: CoreTimeUtils.timestamp(),\n        timemodified: CoreTimeUtils.timestamp(),\n        snapshot: null\n      };\n      if (snapshot) {\n        // Save a snapshot of the data we had when we created the attempt.\n        // Remove the default data, we don't want to store it.\n        entry.snapshot = JSON.stringify(_this2.removeDefaultData(snapshot));\n      }\n      try {\n        yield db.insertRecord(ATTEMPTS_TABLE_NAME, entry);\n        // Store all the data in userData.\n        const promises = [];\n        for (const key in userData) {\n          const sco = userData[key];\n          const tracks = [];\n          for (const element in sco.userdata) {\n            tracks.push({\n              element,\n              value: sco.userdata[element]\n            });\n          }\n          promises.push(_this2.saveTracks(scorm, sco.scoid, attempt, tracks, userData, site.id, userId));\n        }\n        yield Promise.all(promises);\n      } finally {\n        // Unblock the SCORM.\n        CoreSync.unblockOperation(AddonModScormProvider.COMPONENT, scorm.id, 'createNewAttempt', site.id);\n      }\n    })();\n  }\n  /**\n   * Delete all the stored data from an attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when all the data has been deleted.\n   */\n  deleteAttempt(scormId, attempt, siteId, userId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      _this3.logger.debug(`Delete offline attempt ${attempt} in SCORM ${scormId}`);\n      const db = site.getDb();\n      const conditions = {\n        scormid: scormId,\n        userid: userId,\n        attempt\n      };\n      yield Promise.all([db.deleteRecords(ATTEMPTS_TABLE_NAME, conditions), db.deleteRecords(TRACKS_TABLE_NAME, conditions)]);\n    })();\n  }\n  /**\n   * Helper function to return a formatted list of interactions for reports.\n   * This function is based in Moodle's scorm_format_interactions.\n   *\n   * @param scoUserData Userdata from a certain SCO.\n   * @returns Formatted userdata.\n   */\n  formatInteractions(scoUserData) {\n    const formatted = {};\n    // Defined in order to unify scorm1.2 and scorm2004.\n    formatted.score_raw = '';\n    formatted.status = '';\n    formatted.total_time = '00:00:00';\n    formatted.session_time = '00:00:00';\n    for (const element in scoUserData) {\n      let value = scoUserData[element];\n      // Ignore elements that are calculated.\n      if (element == 'score_raw' || element == 'status' || element == 'total_time' || element == 'session_time') {\n        continue;\n      }\n      formatted[element] = value;\n      switch (element) {\n        case 'cmi.core.lesson_status':\n        case 'cmi.completion_status':\n          if (value == 'not attempted') {\n            value = 'notattempted';\n          }\n          formatted.status = value;\n          break;\n        case 'cmi.core.score.raw':\n        case 'cmi.score.raw':\n          formatted.score_raw = CoreTextUtils.roundToDecimals(Number(value), 2); // Round to 2 decimals max.\n          break;\n        case 'cmi.core.session_time':\n        case 'cmi.session_time':\n          formatted.session_time = value;\n          break;\n        case 'cmi.core.total_time':\n        case 'cmi.total_time':\n          formatted.total_time = value;\n          break;\n        default:\n        // Nothing to do.\n      }\n    }\n\n    return formatted;\n  }\n  /**\n   * Get all the offline attempts in a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the offline attempts are retrieved.\n   */\n  getAllAttempts(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      const attempts = yield db.getAllRecords(ATTEMPTS_TABLE_NAME);\n      return attempts.map(attempt => _this4.parseAttempt(attempt));\n    })();\n  }\n  /**\n   * Get an offline attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved with the attempt.\n   */\n  getAttempt(scormId, attempt, siteId, userId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const attemptRecord = yield site.getDb().getRecord(ATTEMPTS_TABLE_NAME, {\n        scormid: scormId,\n        userid: userId,\n        attempt\n      });\n      return _this5.parseAttempt(attemptRecord);\n    })();\n  }\n  /**\n   * Get the creation time of an attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved with time the attempt was created, undefined if attempt not found.\n   */\n  getAttemptCreationTime(scormId, attempt, siteId, userId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const attemptRecord = yield _this6.getAttempt(scormId, attempt, siteId, userId);\n        return attemptRecord.timecreated;\n      } catch (_unused) {\n        return;\n      }\n    })();\n  }\n  /**\n   * Get the offline attempts done by a user in the given SCORM.\n   *\n   * @param scormId SCORM ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the offline attempts are retrieved.\n   */\n  getAttempts(scormId, siteId, userId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const attempts = yield site.getDb().getRecords(ATTEMPTS_TABLE_NAME, {\n        scormid: scormId,\n        userid: userId\n      });\n      return attempts.map(attempt => _this7.parseAttempt(attempt));\n    })();\n  }\n  /**\n   * Get the snapshot of an attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved with the snapshot or undefined if no snapshot.\n   */\n  getAttemptSnapshot(scormId, attempt, siteId, userId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const attemptRecord = yield _this8.getAttempt(scormId, attempt, siteId, userId);\n        return attemptRecord.snapshot || undefined;\n      } catch (_unused2) {\n        return;\n      }\n    })();\n  }\n  /**\n   * Get launch URLs from a list of SCOs, indexing them by SCO ID.\n   *\n   * @param scos List of SCOs.\n   * @returns Launch URLs indexed by SCO ID.\n   */\n  getLaunchUrlsFromScos(scos) {\n    scos = scos || [];\n    const response = {};\n    scos.forEach(sco => {\n      response[sco.id] = sco.launch;\n    });\n    return response;\n  }\n  /**\n   * Get data stored in local DB for a certain scorm and attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param excludeSynced Whether it should only return not synced entries.\n   * @param excludeNotSynced Whether it should only return synced entries.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved with the entries.\n   */\n  getScormStoredData(scormId, attempt, excludeSynced, excludeNotSynced, siteId, userId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (excludeSynced && excludeNotSynced) {\n        return [];\n      }\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const conditions = {\n        scormid: scormId,\n        userid: userId,\n        attempt\n      };\n      if (excludeSynced) {\n        conditions.synced = 0;\n      } else if (excludeNotSynced) {\n        conditions.synced = 1;\n      }\n      const tracks = yield site.getDb().getRecords(TRACKS_TABLE_NAME, conditions);\n      return _this9.parseTracks(tracks);\n    })();\n  }\n  /**\n   * Get the user data for a certain SCORM and offline attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param scos SCOs returned by AddonModScormProvider.getScos. If not supplied, this function will only return the\n   *             SCOs that have something stored and cmi.launch_data will be undefined.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the user data is retrieved.\n   */\n  getScormUserData(scormId, attempt, scos, siteId, userId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      scos = scos || [];\n      let fullName = '';\n      let userName = '';\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      // Get username and fullname.\n      if (userId == site.getUserId()) {\n        var _site$getInfo, _site$getInfo2;\n        fullName = ((_site$getInfo = site.getInfo()) === null || _site$getInfo === void 0 ? void 0 : _site$getInfo.fullname) || '';\n        userName = ((_site$getInfo2 = site.getInfo()) === null || _site$getInfo2 === void 0 ? void 0 : _site$getInfo2.username) || '';\n      } else {\n        const profile = yield CoreUtils.ignoreErrors(CoreUser.getProfile(userId));\n        fullName = (profile === null || profile === void 0 ? void 0 : profile.fullname) || '';\n        userName = (profile === null || profile === void 0 ? void 0 : profile.username) || '';\n      }\n      // Get user data.\n      const entries = yield _this10.getScormStoredData(scormId, attempt, false, false, siteId, userId);\n      const response = {};\n      const launchUrls = _this10.getLaunchUrlsFromScos(scos);\n      // Gather user data retrieved from DB, grouping it by scoid.\n      entries.forEach(entry => {\n        var _entry$value;\n        const scoId = entry.scoid;\n        if (!response[scoId]) {\n          var _userId;\n          // Initialize SCO.\n          response[scoId] = {\n            scoid: scoId,\n            userdata: {\n              userid: (_userId = userId) !== null && _userId !== void 0 ? _userId : site.getUserId(),\n              scoid: scoId,\n              timemodified: 0\n            },\n            defaultdata: {}\n          };\n        }\n        response[scoId].userdata[entry.element] = (_entry$value = entry.value) !== null && _entry$value !== void 0 ? _entry$value : '';\n        if (entry.timemodified > Number(response[scoId].userdata.timemodified)) {\n          response[scoId].userdata.timemodified = entry.timemodified;\n        }\n      });\n      // Format each user data retrieved.\n      for (const scoId in response) {\n        const sco = response[scoId];\n        sco.userdata = _this10.formatInteractions(sco.userdata);\n      }\n      // Create empty entries for the SCOs without user data stored.\n      scos.forEach(sco => {\n        if (!response[sco.id]) {\n          response[sco.id] = {\n            scoid: sco.id,\n            userdata: {\n              status: '',\n              score_raw: '' // eslint-disable-line @typescript-eslint/naming-convention\n            },\n\n            defaultdata: {}\n          };\n        }\n      });\n      // Calculate defaultdata.\n      for (const scoId in response) {\n        const sco = response[scoId];\n        sco.defaultdata = {};\n        sco.defaultdata['cmi.core.student_id'] = userName;\n        sco.defaultdata['cmi.core.student_name'] = fullName;\n        sco.defaultdata['cmi.core.lesson_mode'] = 'normal'; // Overridden in player.\n        sco.defaultdata['cmi.core.credit'] = 'credit'; // Overridden in player.\n        if (sco.userdata.status === '') {\n          sco.defaultdata['cmi.core.entry'] = 'ab-initio';\n        } else if (sco.userdata['cmi.core.exit'] === 'suspend') {\n          sco.defaultdata['cmi.core.entry'] = 'resume';\n        } else {\n          sco.defaultdata['cmi.core.entry'] = '';\n        }\n        sco.defaultdata['cmi.student_data.mastery_score'] = _this10.scormIsset(sco.userdata, 'masteryscore');\n        sco.defaultdata['cmi.student_data.max_time_allowed'] = _this10.scormIsset(sco.userdata, 'max_time_allowed');\n        sco.defaultdata['cmi.student_data.time_limit_action'] = _this10.scormIsset(sco.userdata, 'time_limit_action');\n        sco.defaultdata['cmi.core.total_time'] = _this10.scormIsset(sco.userdata, 'cmi.core.total_time', '00:00:00');\n        sco.defaultdata['cmi.launch_data'] = launchUrls[sco.scoid];\n        // Now handle standard userdata items.\n        sco.defaultdata['cmi.core.lesson_location'] = _this10.scormIsset(sco.userdata, 'cmi.core.lesson_location');\n        sco.defaultdata['cmi.core.lesson_status'] = _this10.scormIsset(sco.userdata, 'cmi.core.lesson_status');\n        sco.defaultdata['cmi.core.score.raw'] = _this10.scormIsset(sco.userdata, 'cmi.core.score.raw');\n        sco.defaultdata['cmi.core.score.max'] = _this10.scormIsset(sco.userdata, 'cmi.core.score.max');\n        sco.defaultdata['cmi.core.score.min'] = _this10.scormIsset(sco.userdata, 'cmi.core.score.min');\n        sco.defaultdata['cmi.core.exit'] = _this10.scormIsset(sco.userdata, 'cmi.core.exit');\n        sco.defaultdata['cmi.suspend_data'] = _this10.scormIsset(sco.userdata, 'cmi.suspend_data');\n        sco.defaultdata['cmi.comments'] = _this10.scormIsset(sco.userdata, 'cmi.comments');\n        sco.defaultdata['cmi.student_preference.language'] = _this10.scormIsset(sco.userdata, 'cmi.student_preference.language');\n        sco.defaultdata['cmi.student_preference.audio'] = _this10.scormIsset(sco.userdata, 'cmi.student_preference.audio', '0');\n        sco.defaultdata['cmi.student_preference.speed'] = _this10.scormIsset(sco.userdata, 'cmi.student_preference.speed', '0');\n        sco.defaultdata['cmi.student_preference.text'] = _this10.scormIsset(sco.userdata, 'cmi.student_preference.text', '0');\n        // Some data needs to be both in default data and user data.\n        sco.userdata.student_id = userName;\n        sco.userdata.student_name = fullName;\n        sco.userdata.mode = sco.defaultdata['cmi.core.lesson_mode'];\n        sco.userdata.credit = sco.defaultdata['cmi.core.credit'];\n        sco.userdata.entry = sco.defaultdata['cmi.core.entry'];\n      }\n      return response;\n    })();\n  }\n  /**\n   * Insert a track in the offline tracks store.\n   * This function is based on Moodle's scorm_insert_track.\n   *\n   * @param scormId SCORM ID.\n   * @param scoId SCO ID.\n   * @param attempt Attempt number.\n   * @param element Name of the element to insert.\n   * @param value Value to insert.\n   * @param forceCompleted True if SCORM forces completed.\n   * @param scoData User data for the given SCO.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not set use site's current user.\n   * @returns Promise resolved when the insert is done.\n   */\n  insertTrack(scormId, scoId, attempt, element, value, forceCompleted, scoData, siteId, userId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const scoUserData = (scoData === null || scoData === void 0 ? void 0 : scoData.userdata) || {};\n      const db = site.getDb();\n      let lessonStatusInserted = false;\n      if (forceCompleted) {\n        if (element == 'cmi.core.lesson_status' && value == 'incomplete') {\n          if (scoUserData['cmi.core.score.raw']) {\n            value = 'completed';\n          }\n        }\n        if (element == 'cmi.core.score.raw') {\n          if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {\n            lessonStatusInserted = true;\n            yield _this11.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed');\n          }\n        }\n      }\n      if (scoUserData[element] && element == 'x.start.time') {\n        // Don't update x.start.time, keep the original value.\n        return;\n      }\n      try {\n        yield _this11.insertTrackToDB(db, userId, scormId, scoId, attempt, element, value);\n      } catch (error) {\n        if (lessonStatusInserted) {\n          // Rollback previous insert.\n          yield _this11.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete');\n        }\n        throw error;\n      }\n    })();\n  }\n  insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, synchronous) {\n    const entry = {\n      userid: userId,\n      scormid: scormId,\n      scoid: scoId,\n      attempt,\n      element: element,\n      value: value === undefined ? null : JSON.stringify(value),\n      timemodified: CoreTimeUtils.timestamp(),\n      synced: 0\n    };\n    if (synchronous) {\n      // The insert operation is always asynchronous, always return true.\n      db.insertRecord(TRACKS_TABLE_NAME, entry);\n      return true;\n    } else {\n      return db.insertRecord(TRACKS_TABLE_NAME, entry);\n    }\n  }\n  /**\n   * Insert a track in the offline tracks store, returning a synchronous value.\n   * Please use this function only if synchronous is a must. It's recommended to use insertTrack.\n   * This function is based on Moodle's scorm_insert_track.\n   *\n   * @param scormId SCORM ID.\n   * @param scoId SCO ID.\n   * @param attempt Attempt number.\n   * @param element Name of the element to insert.\n   * @param value Value of the element to insert.\n   * @param forceCompleted True if SCORM forces completed.\n   * @param scoData User data for the given SCO.\n   * @param userId User ID. If not set use current user.\n   * @returns Promise resolved when the insert is done.\n   */\n  insertTrackSync(scormId, scoId, attempt, element, value, forceCompleted, scoData, userId) {\n    userId = userId || CoreSites.getCurrentSiteUserId();\n    if (!CoreSites.isLoggedIn()) {\n      // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.\n      return false;\n    }\n    const scoUserData = (scoData === null || scoData === void 0 ? void 0 : scoData.userdata) || {};\n    const db = CoreSites.getRequiredCurrentSite().getDb();\n    let lessonStatusInserted = false;\n    if (forceCompleted) {\n      if (element == 'cmi.core.lesson_status' && value == 'incomplete') {\n        if (scoUserData['cmi.core.score.raw']) {\n          value = 'completed';\n        }\n      }\n      if (element == 'cmi.core.score.raw') {\n        if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {\n          lessonStatusInserted = true;\n          if (!this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed', true)) {\n            return false;\n          }\n        }\n      }\n    }\n    if (scoUserData[element] && element == 'x.start.time') {\n      // Don't update x.start.time, keep the original value.\n      return true;\n    }\n    if (!this.insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, true)) {\n      // Insert failed.\n      if (lessonStatusInserted) {\n        // Rollback previous insert.\n        this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete', true);\n      }\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Mark all the entries from a SCO and attempt as synced.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param scoId SCO ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when marked.\n   */\n  markAsSynced(scormId, attempt, scoId, siteId, userId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      _this12.logger.debug(`Mark SCO ${scoId} as synced for attempt ${attempt} in SCORM ${scormId}`);\n      yield site.getDb().updateRecords(TRACKS_TABLE_NAME, {\n        synced: 1\n      }, {\n        scormid: scormId,\n        userid: userId,\n        attempt,\n        scoid: scoId,\n        synced: 0\n      });\n    })();\n  }\n  /**\n   * Parse an attempt.\n   *\n   * @param attempt Attempt to parse.\n   * @returns Parsed attempt.\n   */\n  parseAttempt(attempt) {\n    return _objectSpread(_objectSpread({}, attempt), {}, {\n      snapshot: attempt.snapshot ? CoreTextUtils.parseJSON(attempt.snapshot) : null\n    });\n  }\n  /**\n   * Parse tracks.\n   *\n   * @param tracks Tracks to parse.\n   * @returns Parsed tracks.\n   */\n  parseTracks(tracks) {\n    return tracks.map(track => _objectSpread(_objectSpread({}, track), {}, {\n      value: track.value ? CoreTextUtils.parseJSON(track.value) : null\n    }));\n  }\n  /**\n   * Removes the default data form user data.\n   *\n   * @param userData User data.\n   * @returns User data without default data.\n   */\n  removeDefaultData(userData) {\n    const result = CoreUtils.clone(userData);\n    for (const key in result) {\n      result[key].defaultdata = {};\n    }\n    return result;\n  }\n  /**\n   * Saves a SCORM tracking record in offline.\n   *\n   * @param scorm SCORM.\n   * @param scoId Sco ID.\n   * @param attempt Attempt number.\n   * @param tracks Tracking data to store.\n   * @param userData User data for this attempt and SCO.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when data is saved.\n   */\n  saveTracks(scorm, scoId, attempt, tracks, userData, siteId, userId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      // Block the SCORM so it can't be synced.\n      CoreSync.blockOperation(AddonModScormProvider.COMPONENT, scorm.id, 'saveTracksOffline', siteId);\n      try {\n        // Insert all the tracks.\n        yield Promise.all(tracks.map(track => _this13.insertTrack(scorm.id, scoId, attempt, track.element, track.value, scorm.forcecompleted, userData[scoId], siteId, userId)));\n      } finally {\n        // Unblock the SCORM operation.\n        CoreSync.unblockOperation(AddonModScormProvider.COMPONENT, scorm.id, 'saveTracksOffline', siteId);\n      }\n    })();\n  }\n  /**\n   * Saves a SCORM tracking record in offline returning a synchronous value.\n   * Please use this function only if synchronous is a must. It's recommended to use saveTracks.\n   *\n   * @param scorm SCORM.\n   * @param scoId Sco ID.\n   * @param attempt Attempt number.\n   * @param tracks Tracking data to store.\n   * @param userData User data for this attempt and SCO.\n   * @returns True if data to insert is valid, false otherwise. Returning true doesn't mean that the data\n   *         has been stored, this function can return true but the insertion can still fail somehow.\n   */\n  saveTracksSync(scorm, scoId, attempt, tracks, userData, userId) {\n    userId = userId || CoreSites.getCurrentSiteUserId();\n    let success = true;\n    tracks.forEach(track => {\n      const trackSuccess = this.insertTrackSync(scorm.id, scoId, attempt, track.element, track.value, scorm.forcecompleted, userData[scoId], userId);\n      success = success && trackSuccess;\n    });\n    return success;\n  }\n  /**\n   * Check for a parameter in userData and return it if it's set or return 'ifempty' if it's empty.\n   * Based on Moodle's scorm_isset function.\n   *\n   * @param userData Contains user's data.\n   * @param param Name of parameter that should be checked.\n   * @param ifEmpty Value to be replaced with if param is not set.\n   * @returns Value from userData[param] if set, ifEmpty otherwise.\n   */\n  scormIsset(userData, param, ifEmpty = '') {\n    if (userData[param] !== undefined) {\n      return userData[param];\n    }\n    return ifEmpty;\n  }\n  /**\n   * Set an attempt's snapshot.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param userData User data to store as snapshot.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when snapshot has been stored.\n   */\n  setAttemptSnapshot(scormId, attempt, userData, siteId, userId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      _this14.logger.debug(`Set snapshot for attempt ${attempt} in SCORM ${scormId}`);\n      const newData = {\n        timemodified: CoreTimeUtils.timestamp(),\n        snapshot: JSON.stringify(_this14.removeDefaultData(userData))\n      };\n      yield site.getDb().updateRecords(ATTEMPTS_TABLE_NAME, newData, {\n        scormid: scormId,\n        userid: userId,\n        attempt\n      });\n    })();\n  }\n}\n_class = AddonModScormOfflineProvider;\n_class.ɵfac = function AddonModScormOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModScormOffline = makeSingleton(AddonModScormOfflineProvider);","map":{"version":3,"names":["CoreUser","CoreSites","CoreSync","CoreTextUtils","CoreTimeUtils","CoreUtils","makeSingleton","CoreLogger","ATTEMPTS_TABLE_NAME","TRACKS_TABLE_NAME","AddonModScormProvider","AddonModScormOfflineProvider","constructor","logger","getInstance","changeAttemptNumber","scormId","attempt","newAttempt","siteId","userId","_this","_asyncToGenerator","site","getSite","getUserId","debug","db","getDb","currentAttemptConditions","scormid","userid","newAttemptConditions","newAttemptData","timemodified","timestamp","blockOperation","COMPONENT","id","updateRecords","newTrackData","synced","error","unblockOperation","createNewAttempt","scorm","userData","snapshot","_this2","entry","courseid","course","timecreated","JSON","stringify","removeDefaultData","insertRecord","promises","key","sco","tracks","element","userdata","push","value","saveTracks","scoid","Promise","all","deleteAttempt","_this3","conditions","deleteRecords","formatInteractions","scoUserData","formatted","score_raw","status","total_time","session_time","roundToDecimals","Number","getAllAttempts","_this4","getSiteDb","attempts","getAllRecords","map","parseAttempt","getAttempt","_this5","attemptRecord","getRecord","getAttemptCreationTime","_this6","_unused","getAttempts","_this7","getRecords","getAttemptSnapshot","_this8","undefined","_unused2","getLaunchUrlsFromScos","scos","response","forEach","launch","getScormStoredData","excludeSynced","excludeNotSynced","_this9","parseTracks","getScormUserData","_this10","fullName","userName","_site$getInfo","_site$getInfo2","getInfo","fullname","username","profile","ignoreErrors","getProfile","entries","launchUrls","_entry$value","scoId","_userId","defaultdata","scormIsset","student_id","student_name","mode","credit","insertTrack","forceCompleted","scoData","_this11","lessonStatusInserted","insertTrackToDB","synchronous","insertTrackSync","getCurrentSiteUserId","isLoggedIn","getRequiredCurrentSite","markAsSynced","_this12","_objectSpread","parseJSON","track","result","clone","_this13","forcecompleted","saveTracksSync","success","trackSuccess","param","ifEmpty","setAttemptSnapshot","_this14","newData","factory","ɵfac","providedIn","AddonModScormOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/scorm/services/scorm-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport {\n    AddonModScormAttemptDBRecord,\n    AddonModScormOfflineDBCommonData,\n    AddonModScormTrackDBRecord,\n    ATTEMPTS_TABLE_NAME,\n    TRACKS_TABLE_NAME,\n} from './database/scorm';\nimport {\n    AddonModScormDataEntry,\n    AddonModScormDataValue,\n    AddonModScormProvider,\n    AddonModScormScorm,\n    AddonModScormScoUserData,\n    AddonModScormUserDataMap,\n    AddonModScormWSSco,\n} from './scorm';\n\n/**\n * Service to handle offline SCORM.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModScormOfflineProvider {\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('AddonModScormOfflineProvider');\n    }\n\n    /**\n     * Changes an attempt number in the data stored in offline.\n     * This function is used to convert attempts into new attempts, so the stored snapshot will be removed and\n     * entries will be marked as not synced.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Number of the attempt to change.\n     * @param newAttempt New attempt number.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the attempt number changes.\n     */\n    async changeAttemptNumber(\n        scormId: number,\n        attempt: number,\n        newAttempt: number,\n        siteId?: string,\n        userId?: number,\n    ): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        this.logger.debug(`Change attempt number from ${attempt} to ${newAttempt} in SCORM ${scormId}`);\n\n        // Update the attempt number.\n        const db = site.getDb();\n        const currentAttemptConditions: AddonModScormOfflineDBCommonData = {\n            scormid: scormId,\n            userid: userId,\n            attempt,\n        };\n        const newAttemptConditions: AddonModScormOfflineDBCommonData = {\n            scormid: scormId,\n            userid: userId,\n            attempt: newAttempt,\n        };\n        const newAttemptData: Partial<AddonModScormAttemptDBRecord> = {\n            attempt: newAttempt,\n            timemodified: CoreTimeUtils.timestamp(),\n        };\n\n        // Block the SCORM so it can't be synced.\n        CoreSync.blockOperation(AddonModScormProvider.COMPONENT, scormId, 'changeAttemptNumber', site.id);\n\n        try {\n            await db.updateRecords(ATTEMPTS_TABLE_NAME, newAttemptData, currentAttemptConditions);\n\n            try {\n                // Now update the attempt number of all the tracks and mark them as not synced.\n                const newTrackData: Partial<AddonModScormTrackDBRecord> = {\n                    attempt: newAttempt,\n                    synced: 0,\n                };\n\n                await db.updateRecords(TRACKS_TABLE_NAME, newTrackData, currentAttemptConditions);\n            } catch (error) {\n                // Failed to update the tracks, restore the old attempt number.\n                await db.updateRecords(ATTEMPTS_TABLE_NAME, { attempt }, newAttemptConditions);\n\n                throw error;\n            }\n        } finally {\n            // Unblock the SCORM.\n            CoreSync.unblockOperation(AddonModScormProvider.COMPONENT, scormId, 'changeAttemptNumber', site.id);\n        }\n    }\n\n    /**\n     * Creates a new offline attempt. It can be created from scratch or as a copy of another attempt.\n     *\n     * @param scorm SCORM.\n     * @param attempt Number of the new attempt.\n     * @param userData User data to store in the attempt.\n     * @param snapshot Optional. Snapshot to store in the attempt.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the new attempt is created.\n     */\n    async createNewAttempt(\n        scorm: AddonModScormScorm,\n        attempt: number,\n        userData: AddonModScormUserDataMap,\n        snapshot?: AddonModScormUserDataMap,\n        siteId?: string,\n        userId?: number,\n    ): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        this.logger.debug(`Creating new offline attempt ${attempt} in SCORM ${scorm.id}`);\n\n        // Block the SCORM so it can't be synced.\n        CoreSync.blockOperation(AddonModScormProvider.COMPONENT, scorm.id, 'createNewAttempt', site.id);\n\n        // Create attempt in DB.\n        const db = site.getDb();\n        const entry: AddonModScormAttemptDBRecord = {\n            scormid: scorm.id,\n            userid: userId,\n            attempt,\n            courseid: scorm.course,\n            timecreated: CoreTimeUtils.timestamp(),\n            timemodified: CoreTimeUtils.timestamp(),\n            snapshot: null,\n        };\n\n        if (snapshot) {\n            // Save a snapshot of the data we had when we created the attempt.\n            // Remove the default data, we don't want to store it.\n            entry.snapshot = JSON.stringify(this.removeDefaultData(snapshot));\n        }\n\n        try {\n            await db.insertRecord(ATTEMPTS_TABLE_NAME, entry);\n\n            // Store all the data in userData.\n            const promises: Promise<void>[] = [];\n\n            for (const key in userData) {\n                const sco = userData[key];\n                const tracks: AddonModScormDataEntry[] = [];\n\n                for (const element in sco.userdata) {\n                    tracks.push({ element, value: sco.userdata[element] });\n                }\n\n                promises.push(this.saveTracks(scorm, sco.scoid, attempt, tracks, userData, site.id, userId));\n            }\n\n            await Promise.all(promises);\n        } finally {\n            // Unblock the SCORM.\n            CoreSync.unblockOperation(AddonModScormProvider.COMPONENT, scorm.id, 'createNewAttempt', site.id);\n        }\n    }\n\n    /**\n     * Delete all the stored data from an attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when all the data has been deleted.\n     */\n    async deleteAttempt(scormId: number, attempt: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        this.logger.debug(`Delete offline attempt ${attempt} in SCORM ${scormId}`);\n\n        const db = site.getDb();\n        const conditions: AddonModScormOfflineDBCommonData = {\n            scormid: scormId,\n            userid: userId,\n            attempt,\n        };\n\n        await Promise.all([\n            db.deleteRecords(ATTEMPTS_TABLE_NAME, conditions),\n            db.deleteRecords(TRACKS_TABLE_NAME, conditions),\n        ]);\n    }\n\n    /**\n     * Helper function to return a formatted list of interactions for reports.\n     * This function is based in Moodle's scorm_format_interactions.\n     *\n     * @param scoUserData Userdata from a certain SCO.\n     * @returns Formatted userdata.\n     */\n    protected formatInteractions(scoUserData: Record<string, AddonModScormDataValue>): Record<string, AddonModScormDataValue> {\n        const formatted: Record<string, AddonModScormDataValue> = {};\n\n        // Defined in order to unify scorm1.2 and scorm2004.\n        formatted.score_raw = '';\n        formatted.status = '';\n        formatted.total_time = '00:00:00';\n        formatted.session_time = '00:00:00';\n\n        for (const element in scoUserData) {\n            let value = scoUserData[element];\n\n            // Ignore elements that are calculated.\n            if (element == 'score_raw' || element == 'status' || element == 'total_time' || element == 'session_time') {\n                continue;\n            }\n\n            formatted[element] = value;\n            switch (element) {\n                case 'cmi.core.lesson_status':\n                case 'cmi.completion_status':\n                    if (value == 'not attempted') {\n                        value = 'notattempted';\n                    }\n                    formatted.status = value;\n                    break;\n\n                case 'cmi.core.score.raw':\n                case 'cmi.score.raw':\n                    formatted.score_raw = CoreTextUtils.roundToDecimals(Number(value), 2); // Round to 2 decimals max.\n                    break;\n\n                case 'cmi.core.session_time':\n                case 'cmi.session_time':\n                    formatted.session_time = value;\n                    break;\n\n                case 'cmi.core.total_time':\n                case 'cmi.total_time':\n                    formatted.total_time = value;\n                    break;\n                default:\n                    // Nothing to do.\n            }\n        }\n\n        return formatted;\n    }\n\n    /**\n     * Get all the offline attempts in a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the offline attempts are retrieved.\n     */\n    async getAllAttempts(siteId?: string): Promise<AddonModScormOfflineAttempt[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        const attempts = await db.getAllRecords<AddonModScormAttemptDBRecord>(ATTEMPTS_TABLE_NAME);\n\n        return attempts.map((attempt) => this.parseAttempt(attempt));\n    }\n\n    /**\n     * Get an offline attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved with the attempt.\n     */\n    async getAttempt(scormId: number, attempt: number, siteId?: string, userId?: number): Promise<AddonModScormOfflineAttempt> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const attemptRecord = await site.getDb().getRecord<AddonModScormAttemptDBRecord>(ATTEMPTS_TABLE_NAME, {\n            scormid: scormId,\n            userid: userId,\n            attempt,\n        });\n\n        return this.parseAttempt(attemptRecord);\n    }\n\n    /**\n     * Get the creation time of an attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved with time the attempt was created, undefined if attempt not found.\n     */\n    async getAttemptCreationTime(scormId: number, attempt: number, siteId?: string, userId?: number): Promise<number | undefined> {\n        try {\n            const attemptRecord = await this.getAttempt(scormId, attempt, siteId, userId);\n\n            return attemptRecord.timecreated;\n        } catch {\n            return;\n        }\n    }\n\n    /**\n     * Get the offline attempts done by a user in the given SCORM.\n     *\n     * @param scormId SCORM ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the offline attempts are retrieved.\n     */\n    async getAttempts(scormId: number, siteId?: string, userId?: number): Promise<AddonModScormOfflineAttempt[]> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const attempts = await site.getDb().getRecords<AddonModScormAttemptDBRecord>(ATTEMPTS_TABLE_NAME, {\n            scormid: scormId,\n            userid: userId,\n        });\n\n        return attempts.map((attempt) => this.parseAttempt(attempt));\n    }\n\n    /**\n     * Get the snapshot of an attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved with the snapshot or undefined if no snapshot.\n     */\n    async getAttemptSnapshot(\n        scormId: number,\n        attempt: number,\n        siteId?: string,\n        userId?: number,\n    ): Promise<AddonModScormUserDataMap | undefined> {\n        try {\n            const attemptRecord = await this.getAttempt(scormId, attempt, siteId, userId);\n\n            return attemptRecord.snapshot || undefined;\n        } catch {\n            return;\n        }\n    }\n\n    /**\n     * Get launch URLs from a list of SCOs, indexing them by SCO ID.\n     *\n     * @param scos List of SCOs.\n     * @returns Launch URLs indexed by SCO ID.\n     */\n    protected getLaunchUrlsFromScos(scos: AddonModScormWSSco[]): Record<number, string> {\n        scos = scos || [];\n\n        const response: Record<number, string> = {};\n\n        scos.forEach((sco) => {\n            response[sco.id] = sco.launch;\n        });\n\n        return response;\n    }\n\n    /**\n     * Get data stored in local DB for a certain scorm and attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param excludeSynced Whether it should only return not synced entries.\n     * @param excludeNotSynced Whether it should only return synced entries.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved with the entries.\n     */\n    async getScormStoredData(\n        scormId: number,\n        attempt: number,\n        excludeSynced?: boolean,\n        excludeNotSynced?: boolean,\n        siteId?: string,\n        userId?: number,\n    ): Promise<AddonModScormOfflineTrack[]> {\n        if (excludeSynced && excludeNotSynced) {\n            return [];\n        }\n\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const conditions: Partial<AddonModScormTrackDBRecord> = {\n            scormid: scormId,\n            userid: userId,\n            attempt,\n        };\n\n        if (excludeSynced) {\n            conditions.synced = 0;\n        } else if (excludeNotSynced) {\n            conditions.synced = 1;\n        }\n\n        const tracks = await site.getDb().getRecords<AddonModScormTrackDBRecord>(TRACKS_TABLE_NAME, conditions);\n\n        return this.parseTracks(tracks);\n    }\n\n    /**\n     * Get the user data for a certain SCORM and offline attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param scos SCOs returned by AddonModScormProvider.getScos. If not supplied, this function will only return the\n     *             SCOs that have something stored and cmi.launch_data will be undefined.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the user data is retrieved.\n     */\n    async getScormUserData(\n        scormId: number,\n        attempt: number,\n        scos?: AddonModScormWSSco[],\n        siteId?: string,\n        userId?: number,\n    ): Promise<AddonModScormUserDataMap> {\n        scos = scos || [];\n\n        let fullName = '';\n        let userName = '';\n\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        // Get username and fullname.\n        if (userId == site.getUserId()) {\n            fullName = site.getInfo()?.fullname || '';\n            userName = site.getInfo()?.username || '';\n        } else {\n            const profile = await CoreUtils.ignoreErrors(CoreUser.getProfile(userId));\n\n            fullName = profile?.fullname || '';\n            userName = profile?.username || '';\n        }\n\n        // Get user data.\n        const entries = await this.getScormStoredData(scormId, attempt, false, false, siteId, userId);\n        const response: AddonModScormUserDataMap = {};\n        const launchUrls = this.getLaunchUrlsFromScos(scos);\n\n        // Gather user data retrieved from DB, grouping it by scoid.\n        entries.forEach((entry) => {\n            const scoId = entry.scoid;\n\n            if (!response[scoId]) {\n                // Initialize SCO.\n                response[scoId] = {\n                    scoid: scoId,\n                    userdata: {\n                        userid: userId ?? site.getUserId(),\n                        scoid: scoId,\n                        timemodified: 0,\n                    },\n                    defaultdata: {},\n                };\n            }\n\n            response[scoId].userdata[entry.element] = entry.value ?? '';\n            if (entry.timemodified > Number(response[scoId].userdata.timemodified)) {\n                response[scoId].userdata.timemodified = entry.timemodified;\n            }\n        });\n\n        // Format each user data retrieved.\n        for (const scoId in response) {\n            const sco = response[scoId];\n            sco.userdata = this.formatInteractions(sco.userdata);\n        }\n\n        // Create empty entries for the SCOs without user data stored.\n        scos.forEach((sco) => {\n            if (!response[sco.id]) {\n                response[sco.id] = {\n                    scoid: sco.id,\n                    userdata: {\n                        status: '',\n                        score_raw: '', // eslint-disable-line @typescript-eslint/naming-convention\n                    },\n                    defaultdata: {},\n                };\n            }\n        });\n\n        // Calculate defaultdata.\n        for (const scoId in response) {\n            const sco = response[scoId];\n\n            sco.defaultdata = {};\n            sco.defaultdata['cmi.core.student_id'] = userName;\n            sco.defaultdata['cmi.core.student_name'] = fullName;\n            sco.defaultdata['cmi.core.lesson_mode'] = 'normal'; // Overridden in player.\n            sco.defaultdata['cmi.core.credit'] = 'credit'; // Overridden in player.\n\n            if (sco.userdata.status === '') {\n                sco.defaultdata['cmi.core.entry'] = 'ab-initio';\n            } else if (sco.userdata['cmi.core.exit'] === 'suspend') {\n                sco.defaultdata['cmi.core.entry'] = 'resume';\n            } else {\n                sco.defaultdata['cmi.core.entry'] = '';\n            }\n\n            sco.defaultdata['cmi.student_data.mastery_score'] = this.scormIsset(sco.userdata, 'masteryscore');\n            sco.defaultdata['cmi.student_data.max_time_allowed'] = this.scormIsset(sco.userdata, 'max_time_allowed');\n            sco.defaultdata['cmi.student_data.time_limit_action'] = this.scormIsset(sco.userdata, 'time_limit_action');\n            sco.defaultdata['cmi.core.total_time'] = this.scormIsset(sco.userdata, 'cmi.core.total_time', '00:00:00');\n            sco.defaultdata['cmi.launch_data'] = launchUrls[sco.scoid];\n\n            // Now handle standard userdata items.\n            sco.defaultdata['cmi.core.lesson_location'] = this.scormIsset(sco.userdata, 'cmi.core.lesson_location');\n            sco.defaultdata['cmi.core.lesson_status'] = this.scormIsset(sco.userdata, 'cmi.core.lesson_status');\n            sco.defaultdata['cmi.core.score.raw'] = this.scormIsset(sco.userdata, 'cmi.core.score.raw');\n            sco.defaultdata['cmi.core.score.max'] = this.scormIsset(sco.userdata, 'cmi.core.score.max');\n            sco.defaultdata['cmi.core.score.min'] = this.scormIsset(sco.userdata, 'cmi.core.score.min');\n            sco.defaultdata['cmi.core.exit'] = this.scormIsset(sco.userdata, 'cmi.core.exit');\n            sco.defaultdata['cmi.suspend_data'] = this.scormIsset(sco.userdata, 'cmi.suspend_data');\n            sco.defaultdata['cmi.comments'] = this.scormIsset(sco.userdata, 'cmi.comments');\n            sco.defaultdata['cmi.student_preference.language'] = this.scormIsset(sco.userdata, 'cmi.student_preference.language');\n            sco.defaultdata['cmi.student_preference.audio'] = this.scormIsset(sco.userdata, 'cmi.student_preference.audio', '0');\n            sco.defaultdata['cmi.student_preference.speed'] = this.scormIsset(sco.userdata, 'cmi.student_preference.speed', '0');\n            sco.defaultdata['cmi.student_preference.text'] = this.scormIsset(sco.userdata, 'cmi.student_preference.text', '0');\n\n            // Some data needs to be both in default data and user data.\n            sco.userdata.student_id = userName;\n            sco.userdata.student_name = fullName;\n            sco.userdata.mode = sco.defaultdata['cmi.core.lesson_mode'];\n            sco.userdata.credit = sco.defaultdata['cmi.core.credit'];\n            sco.userdata.entry = sco.defaultdata['cmi.core.entry'];\n        }\n\n        return response;\n    }\n\n    /**\n     * Insert a track in the offline tracks store.\n     * This function is based on Moodle's scorm_insert_track.\n     *\n     * @param scormId SCORM ID.\n     * @param scoId SCO ID.\n     * @param attempt Attempt number.\n     * @param element Name of the element to insert.\n     * @param value Value to insert.\n     * @param forceCompleted True if SCORM forces completed.\n     * @param scoData User data for the given SCO.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not set use site's current user.\n     * @returns Promise resolved when the insert is done.\n     */\n    protected async insertTrack(\n        scormId: number,\n        scoId: number,\n        attempt: number,\n        element: string,\n        value?: string | number,\n        forceCompleted?: boolean,\n        scoData?: AddonModScormScoUserData,\n        siteId?: string,\n        userId?: number,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        const scoUserData = scoData?.userdata || {};\n        const db = site.getDb();\n        let lessonStatusInserted = false;\n\n        if (forceCompleted) {\n            if (element == 'cmi.core.lesson_status' && value == 'incomplete') {\n                if (scoUserData['cmi.core.score.raw']) {\n                    value = 'completed';\n                }\n            }\n            if (element == 'cmi.core.score.raw') {\n                if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {\n                    lessonStatusInserted = true;\n\n                    await this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed');\n                }\n            }\n        }\n\n        if (scoUserData[element] && element == 'x.start.time') {\n            // Don't update x.start.time, keep the original value.\n            return;\n        }\n\n        try {\n            await this.insertTrackToDB(db, userId, scormId, scoId, attempt, element, value);\n        } catch (error) {\n            if (lessonStatusInserted) {\n                // Rollback previous insert.\n                await this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete');\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Insert a track in the DB.\n     *\n     * @param db Site's DB.\n     * @param userId User ID.\n     * @param scormId SCORM ID.\n     * @param scoId SCO ID.\n     * @param attempt Attempt number.\n     * @param element Name of the element to insert.\n     * @param value Value of the element to insert.\n     * @param synchronous True if insert should NOT return a promise. Please use it only if synchronous is a must.\n     * @returns Returns a promise if synchronous=false, otherwise returns a boolean.\n     */\n    protected insertTrackToDB(\n        db: SQLiteDB,\n        userId: number,\n        scormId: number,\n        scoId: number,\n        attempt: number,\n        element: string,\n        value: AddonModScormDataValue | undefined,\n        synchronous: true,\n    ): boolean;\n    protected insertTrackToDB(\n        db: SQLiteDB,\n        userId: number,\n        scormId: number,\n        scoId: number,\n        attempt: number,\n        element: string,\n        value?: AddonModScormDataValue,\n        synchronous?: false,\n    ): Promise<number>;\n    protected insertTrackToDB(\n        db: SQLiteDB,\n        userId: number,\n        scormId: number,\n        scoId: number,\n        attempt: number,\n        element: string,\n        value?: AddonModScormDataValue,\n        synchronous?: boolean,\n    ): boolean | Promise<number> {\n        const entry: AddonModScormTrackDBRecord = {\n            userid: userId,\n            scormid: scormId,\n            scoid: scoId,\n            attempt,\n            element: element,\n            value: value === undefined ? null : JSON.stringify(value),\n            timemodified: CoreTimeUtils.timestamp(),\n            synced: 0,\n        };\n\n        if (synchronous) {\n            // The insert operation is always asynchronous, always return true.\n            db.insertRecord(TRACKS_TABLE_NAME, entry);\n\n            return true;\n        } else {\n            return db.insertRecord(TRACKS_TABLE_NAME, entry);\n        }\n    }\n\n    /**\n     * Insert a track in the offline tracks store, returning a synchronous value.\n     * Please use this function only if synchronous is a must. It's recommended to use insertTrack.\n     * This function is based on Moodle's scorm_insert_track.\n     *\n     * @param scormId SCORM ID.\n     * @param scoId SCO ID.\n     * @param attempt Attempt number.\n     * @param element Name of the element to insert.\n     * @param value Value of the element to insert.\n     * @param forceCompleted True if SCORM forces completed.\n     * @param scoData User data for the given SCO.\n     * @param userId User ID. If not set use current user.\n     * @returns Promise resolved when the insert is done.\n     */\n    protected insertTrackSync(\n        scormId: number,\n        scoId: number,\n        attempt: number,\n        element: string,\n        value?: AddonModScormDataValue,\n        forceCompleted?: boolean,\n        scoData?: AddonModScormScoUserData,\n        userId?: number,\n    ): boolean {\n        userId = userId || CoreSites.getCurrentSiteUserId();\n\n        if (!CoreSites.isLoggedIn()) {\n            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.\n            return false;\n        }\n\n        const scoUserData = scoData?.userdata || {};\n        const db = CoreSites.getRequiredCurrentSite().getDb();\n        let lessonStatusInserted = false;\n\n        if (forceCompleted) {\n            if (element == 'cmi.core.lesson_status' && value == 'incomplete') {\n                if (scoUserData['cmi.core.score.raw']) {\n                    value = 'completed';\n                }\n            }\n            if (element == 'cmi.core.score.raw') {\n                if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {\n                    lessonStatusInserted = true;\n\n                    if (!this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed', true)) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        if (scoUserData[element] && element == 'x.start.time') {\n            // Don't update x.start.time, keep the original value.\n            return true;\n        }\n\n        if (!this.insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, true)) {\n            // Insert failed.\n            if (lessonStatusInserted) {\n                // Rollback previous insert.\n                this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete', true);\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Mark all the entries from a SCO and attempt as synced.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param scoId SCO ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when marked.\n     */\n    async markAsSynced(scormId: number, attempt: number, scoId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        this.logger.debug(`Mark SCO ${scoId} as synced for attempt ${attempt} in SCORM ${scormId}`);\n\n        await site.getDb().updateRecords(TRACKS_TABLE_NAME, { synced: 1 }, <Partial<AddonModScormTrackDBRecord>> {\n            scormid: scormId,\n            userid: userId,\n            attempt,\n            scoid: scoId,\n            synced: 0,\n        });\n    }\n\n    /**\n     * Parse an attempt.\n     *\n     * @param attempt Attempt to parse.\n     * @returns Parsed attempt.\n     */\n    protected parseAttempt(attempt: AddonModScormAttemptDBRecord): AddonModScormOfflineAttempt {\n        return {\n            ...attempt,\n            snapshot: attempt.snapshot ? CoreTextUtils.parseJSON(attempt.snapshot) : null,\n        };\n    }\n\n    /**\n     * Parse tracks.\n     *\n     * @param tracks Tracks to parse.\n     * @returns Parsed tracks.\n     */\n    protected parseTracks(tracks: AddonModScormTrackDBRecord[]): AddonModScormOfflineTrack[] {\n        return tracks.map((track) => ({\n            ...track,\n            value: track.value ? CoreTextUtils.parseJSON(track.value) : null,\n        }));\n    }\n\n    /**\n     * Removes the default data form user data.\n     *\n     * @param userData User data.\n     * @returns User data without default data.\n     */\n    protected removeDefaultData(userData: AddonModScormUserDataMap): AddonModScormUserDataMap {\n        const result: AddonModScormUserDataMap = CoreUtils.clone(userData);\n\n        for (const key in result) {\n            result[key].defaultdata = {};\n        }\n\n        return result;\n    }\n\n    /**\n     * Saves a SCORM tracking record in offline.\n     *\n     * @param scorm SCORM.\n     * @param scoId Sco ID.\n     * @param attempt Attempt number.\n     * @param tracks Tracking data to store.\n     * @param userData User data for this attempt and SCO.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when data is saved.\n     */\n    async saveTracks(\n        scorm: AddonModScormScorm,\n        scoId: number,\n        attempt: number,\n        tracks: AddonModScormDataEntry[],\n        userData: AddonModScormUserDataMap,\n        siteId?: string,\n        userId?: number,\n    ): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        // Block the SCORM so it can't be synced.\n        CoreSync.blockOperation(AddonModScormProvider.COMPONENT, scorm.id, 'saveTracksOffline', siteId);\n\n        try {\n            // Insert all the tracks.\n            await Promise.all(tracks.map((track) => this.insertTrack(\n                scorm.id,\n                scoId,\n                attempt,\n                track.element,\n                track.value,\n                scorm.forcecompleted,\n                userData[scoId],\n                siteId,\n                userId,\n            )));\n        } finally {\n            // Unblock the SCORM operation.\n            CoreSync.unblockOperation(AddonModScormProvider.COMPONENT, scorm.id, 'saveTracksOffline', siteId);\n        }\n    }\n\n    /**\n     * Saves a SCORM tracking record in offline returning a synchronous value.\n     * Please use this function only if synchronous is a must. It's recommended to use saveTracks.\n     *\n     * @param scorm SCORM.\n     * @param scoId Sco ID.\n     * @param attempt Attempt number.\n     * @param tracks Tracking data to store.\n     * @param userData User data for this attempt and SCO.\n     * @returns True if data to insert is valid, false otherwise. Returning true doesn't mean that the data\n     *         has been stored, this function can return true but the insertion can still fail somehow.\n     */\n    saveTracksSync(\n        scorm: AddonModScormScorm,\n        scoId: number,\n        attempt: number,\n        tracks: AddonModScormDataEntry[],\n        userData: AddonModScormUserDataMap,\n        userId?: number,\n    ): boolean {\n        userId = userId || CoreSites.getCurrentSiteUserId();\n        let success = true;\n\n        tracks.forEach((track) => {\n            const trackSuccess = this.insertTrackSync(\n                scorm.id,\n                scoId,\n                attempt,\n                track.element,\n                track.value,\n                scorm.forcecompleted,\n                userData[scoId],\n                userId,\n            );\n\n            success = success && trackSuccess;\n        });\n\n        return success;\n    }\n\n    /**\n     * Check for a parameter in userData and return it if it's set or return 'ifempty' if it's empty.\n     * Based on Moodle's scorm_isset function.\n     *\n     * @param userData Contains user's data.\n     * @param param Name of parameter that should be checked.\n     * @param ifEmpty Value to be replaced with if param is not set.\n     * @returns Value from userData[param] if set, ifEmpty otherwise.\n     */\n    protected scormIsset(\n        userData: Record<string, AddonModScormDataValue>,\n        param: string,\n        ifEmpty: AddonModScormDataValue = '',\n    ): AddonModScormDataValue {\n        if (userData[param] !== undefined) {\n            return userData[param];\n        }\n\n        return ifEmpty;\n    }\n\n    /**\n     * Set an attempt's snapshot.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param userData User data to store as snapshot.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when snapshot has been stored.\n     */\n    async setAttemptSnapshot(\n        scormId: number,\n        attempt: number,\n        userData: AddonModScormUserDataMap,\n        siteId?: string,\n        userId?: number,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        this.logger.debug(`Set snapshot for attempt ${attempt} in SCORM ${scormId}`);\n\n        const newData: Partial<AddonModScormAttemptDBRecord> = {\n            timemodified: CoreTimeUtils.timestamp(),\n            snapshot: JSON.stringify(this.removeDefaultData(userData)),\n        };\n\n        await site.getDb().updateRecords(ATTEMPTS_TABLE_NAME, newData, <Partial<AddonModScormAttemptDBRecord>> {\n            scormid: scormId,\n            userid: userId,\n            attempt,\n        });\n    }\n\n}\n\nexport const AddonModScormOffline = makeSingleton(AddonModScormOfflineProvider);\n\n/**\n * SCORM offline attempt data.\n */\nexport type AddonModScormOfflineAttempt = Omit<AddonModScormAttemptDBRecord, 'snapshot'> & {\n    snapshot?: AddonModScormUserDataMap | null;\n};\n\n/**\n * SCORM offline track data.\n */\nexport type AddonModScormOfflineTrack = Omit<AddonModScormTrackDBRecord, 'value'> & {\n    value?: string | number | null;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}