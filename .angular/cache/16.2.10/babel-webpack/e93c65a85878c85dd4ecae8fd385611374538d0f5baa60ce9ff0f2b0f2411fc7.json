{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton } from '@singletons';\nimport { SURVEY_TABLE } from './database/survey';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle Offline survey.\n */\nexport class AddonModSurveyOfflineProvider {\n  /**\n   * Delete a survey answers.\n   *\n   * @param surveyId Survey ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the answers belong to. If not defined, current user in site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteSurveyAnswers(surveyId, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.getDb().deleteRecords(SURVEY_TABLE, {\n        surveyid: surveyId,\n        userid: userId\n      });\n    })();\n  }\n  /**\n   * Get all the stored data from all the surveys.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with answers.\n   */\n  getAllData(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entries = yield site.getDb().getAllRecords(SURVEY_TABLE);\n      return entries.map(entry => Object.assign(entry, {\n        answers: CoreTextUtils.parseJSON(entry.answers)\n      }));\n    })();\n  }\n  /**\n   * Get a survey stored answers.\n   *\n   * @param surveyId Survey ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the answers belong to. If not defined, current user in site.\n   * @returns Promise resolved with the answers.\n   */\n  getSurveyAnswers(surveyId, siteId, userId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const entry = yield _this.getSurveyData(surveyId, siteId, userId);\n        return entry.answers || [];\n      } catch (_unused) {\n        return [];\n      }\n    })();\n  }\n  /**\n   * Get a survey stored data.\n   *\n   * @param surveyId Survey ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the answers belong to. If not defined, current user in site.\n   * @returns Promise resolved with the data.\n   */\n  getSurveyData(surveyId, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const entry = yield site.getDb().getRecord(SURVEY_TABLE, {\n        surveyid: surveyId,\n        userid: userId\n      });\n      return Object.assign(entry, {\n        answers: CoreTextUtils.parseJSON(entry.answers)\n      });\n    })();\n  }\n  /**\n   * Check if there are offline answers to send.\n   *\n   * @param surveyId Survey ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the answers belong to. If not defined, current user in site.\n   * @returns Promise resolved with boolean: true if has offline answers, false otherwise.\n   */\n  hasAnswers(surveyId, siteId, userId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const answers = yield _this2.getSurveyAnswers(surveyId, siteId, userId);\n      return !!answers.length;\n    })();\n  }\n  /**\n   * Save answers to be sent later.\n   *\n   * @param surveyId Survey ID.\n   * @param name Survey name.\n   * @param courseId Course ID the survey belongs to.\n   * @param answers Answers.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the answers belong to. If not defined, current user in site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  saveAnswers(surveyId, name, courseId, answers, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const entry = {\n        surveyid: surveyId,\n        name: name,\n        courseid: courseId,\n        userid: userId,\n        answers: JSON.stringify(answers),\n        timecreated: Date.now()\n      };\n      yield site.getDb().insertRecord(SURVEY_TABLE, entry);\n    })();\n  }\n}\n_class = AddonModSurveyOfflineProvider;\n_class.ɵfac = function AddonModSurveyOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModSurveyOffline = makeSingleton(AddonModSurveyOfflineProvider);","map":{"version":3,"names":["CoreSites","CoreTextUtils","makeSingleton","SURVEY_TABLE","AddonModSurveyOfflineProvider","deleteSurveyAnswers","surveyId","siteId","userId","_asyncToGenerator","site","getSite","getUserId","getDb","deleteRecords","surveyid","userid","getAllData","entries","getAllRecords","map","entry","Object","assign","answers","parseJSON","getSurveyAnswers","_this","getSurveyData","_unused","getRecord","hasAnswers","_this2","length","saveAnswers","name","courseId","courseid","JSON","stringify","timecreated","Date","now","insertRecord","factory","ɵfac","providedIn","AddonModSurveyOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/survey/services/survey-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton } from '@singletons';\nimport { AddonModSurveyAnswersDBRecord, SURVEY_TABLE } from './database/survey';\nimport { AddonModSurveySubmitAnswerData } from './survey';\n\n/**\n * Service to handle Offline survey.\n */\n@Injectable( { providedIn: 'root' })\nexport class AddonModSurveyOfflineProvider {\n\n    /**\n     * Delete a survey answers.\n     *\n     * @param surveyId Survey ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the answers belong to. If not defined, current user in site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    async deleteSurveyAnswers(surveyId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.getDb().deleteRecords(SURVEY_TABLE, { surveyid: surveyId, userid: userId });\n    }\n\n    /**\n     * Get all the stored data from all the surveys.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with answers.\n     */\n    async getAllData(siteId?: string): Promise<AddonModSurveyAnswersDBRecordFormatted[]> {\n        const site = await CoreSites.getSite(siteId);\n        const entries = await site.getDb().getAllRecords<AddonModSurveyAnswersDBRecord>(SURVEY_TABLE);\n\n        return entries.map((entry) => Object.assign(entry, {\n            answers: CoreTextUtils.parseJSON<AddonModSurveySubmitAnswerData[]>(entry.answers),\n        }));\n    }\n\n    /**\n     * Get a survey stored answers.\n     *\n     * @param surveyId Survey ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the answers belong to. If not defined, current user in site.\n     * @returns Promise resolved with the answers.\n     */\n    async getSurveyAnswers(surveyId: number, siteId?: string, userId?: number): Promise<AddonModSurveySubmitAnswerData[]> {\n        try {\n            const entry = await this.getSurveyData(surveyId, siteId, userId);\n\n            return entry.answers || [];\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Get a survey stored data.\n     *\n     * @param surveyId Survey ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the answers belong to. If not defined, current user in site.\n     * @returns Promise resolved with the data.\n     */\n    async getSurveyData(surveyId: number, siteId?: string, userId?: number): Promise<AddonModSurveyAnswersDBRecordFormatted> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const entry = await site.getDb().getRecord<AddonModSurveyAnswersDBRecord>(\n            SURVEY_TABLE,\n            { surveyid: surveyId, userid: userId },\n        );\n\n        return Object.assign(entry, {\n            answers: CoreTextUtils.parseJSON<AddonModSurveySubmitAnswerData[]>(entry.answers),\n        });\n    }\n\n    /**\n     * Check if there are offline answers to send.\n     *\n     * @param surveyId Survey ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the answers belong to. If not defined, current user in site.\n     * @returns Promise resolved with boolean: true if has offline answers, false otherwise.\n     */\n    async hasAnswers(surveyId: number, siteId?: string, userId?: number): Promise<boolean> {\n        const answers = await this.getSurveyAnswers(surveyId, siteId, userId);\n\n        return !!answers.length;\n    }\n\n    /**\n     * Save answers to be sent later.\n     *\n     * @param surveyId Survey ID.\n     * @param name Survey name.\n     * @param courseId Course ID the survey belongs to.\n     * @param answers Answers.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the answers belong to. If not defined, current user in site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async saveAnswers(\n        surveyId: number,\n        name: string,\n        courseId: number,\n        answers: AddonModSurveySubmitAnswerData[],\n        siteId?: string,\n        userId?: number,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const entry: AddonModSurveyAnswersDBRecord = {\n            surveyid: surveyId,\n            name: name,\n            courseid: courseId,\n            userid: userId,\n            answers: JSON.stringify(answers),\n            timecreated: Date.now(),\n        };\n\n        await site.getDb().insertRecord(SURVEY_TABLE, entry);\n    }\n\n}\nexport const AddonModSurveyOffline = makeSingleton(AddonModSurveyOfflineProvider);\n\nexport type AddonModSurveyAnswersDBRecordFormatted = Omit<AddonModSurveyAnswersDBRecord, 'answers'> & {\n    answers: AddonModSurveySubmitAnswerData[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}