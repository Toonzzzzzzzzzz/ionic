{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreSwipeSlidesItemsManagerSource } from './swipe-slides-items-manager-source';\n/**\n * Items collection source data for \"swipe slides\".\n */\nexport class CoreSwipeSlidesDynamicItemsManagerSource extends CoreSwipeSlidesItemsManagerSource {\n  constructor() {\n    super(...arguments);\n    // Items being loaded, to prevent loading them twice.\n    this.loadingItems = {};\n  }\n  /**\n   * @inheritdoc\n   */\n  load(selectedItem) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.loaded && _this.initialItem) {\n        // Load the initial item.\n        yield _this.loadItem(_this.initialItem);\n      } else if (_this.loaded && selectedItem) {\n        // Reload selected item if needed.\n        yield _this.loadItem(selectedItem);\n      }\n      _this.setLoaded();\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  loadItems() {\n    return _asyncToGenerator(function* () {\n      // Not used in dynamic slides.\n      return [];\n    })();\n  }\n  /**\n   * Load a certain item and preload next and previous ones.\n   *\n   * @param item Item to load.\n   * @returns Promise resolved when done.\n   */\n  loadItem(item) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const previousItem = _this2.getPreviousItem(item);\n      const nextItem = _this2.getNextItem(item);\n      yield Promise.all([_this2.loadItemInList(item, false), previousItem && _this2.loadItemInList(previousItem, true), nextItem && _this2.loadItemInList(nextItem, true)]);\n    })();\n  }\n  /**\n   * Load or preload a certain item and add it to the list.\n   *\n   * @param item Item to load.\n   * @param preload Whether to preload.\n   * @returns Promise resolved when done.\n   */\n  loadItemInList(item, preload = false) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const preloadedItem = yield _this3.performLoadItemData(item, preload);\n      if (!preloadedItem) {\n        return;\n      }\n      // Add the item at the right position.\n      const existingItem = _this3.getItem(_this3.getItemId(item));\n      if (existingItem) {\n        // Already in list, no need to add it.\n        return;\n      }\n      if (!_this3.items) {\n        _this3.items = [];\n      }\n      const previousItem = _this3.getPreviousItem(item);\n      const nextItem = _this3.getNextItem(item);\n      const previousItemId = previousItem ? _this3.getItemId(previousItem) : null;\n      const nextItemId = nextItem ? _this3.getItemId(nextItem) : null;\n      const added = _this3.items.some((item, index) => {\n        const itemId = _this3.getItemId(item);\n        let indexToInsert = -1;\n        if (itemId === previousItemId) {\n          // Previous item found, add the item after it.\n          indexToInsert = index + 1;\n        }\n        if (itemId === nextItemId) {\n          // Next item found, add the item before it.\n          indexToInsert = index;\n        }\n        if (indexToInsert > -1) {\n          var _this3$items;\n          (_this3$items = _this3.items) === null || _this3$items === void 0 || _this3$items.splice(indexToInsert, 0, preloadedItem);\n          return true;\n        }\n      });\n      if (!added) {\n        // Previous and next items not found, this probably means the array is still empty. Add it at the end.\n        _this3.items.push(preloadedItem);\n      }\n      _this3.notifyItemsUpdated();\n    })();\n  }\n  /**\n   * Load or preload a certain item data.\n   * This helper function will check some common cases so they don't have to be replicated in all loadItemData implementations.\n   *\n   * @param item Item to load.\n   * @param preload Whether to preload.\n   * @returns Promise resolved with item. Resolve with null if already loading or item is not valid (e.g. there are no more items)\n   */\n  performLoadItemData(item, preload) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const itemId = _this4.getItemId(item);\n      if (_this4.loadingItems[itemId]) {\n        // Already loading, ignore it.\n        return null;\n      }\n      const existingItem = _this4.getItem(itemId);\n      if (existingItem && (existingItem.loaded && !existingItem.dirty || preload)) {\n        // Already loaded, or preloading an already preloaded item.\n        return existingItem;\n      }\n      // Load the item.\n      _this4.loadingItems[itemId] = true;\n      try {\n        const itemData = yield _this4.loadItemData(item, preload);\n        if (itemData && !preload) {\n          itemData.loaded = true;\n          itemData.dirty = false;\n        }\n        if (existingItem && itemData) {\n          // Update item that is already in list.\n          Object.assign(existingItem, itemData);\n          return existingItem;\n        }\n        return itemData;\n      } finally {\n        _this4.loadingItems[itemId] = false;\n      }\n    })();\n  }\n  /**\n   * Mark all items as dirty.\n   */\n  markAllItemsDirty() {\n    var _this$getItems;\n    (_this$getItems = this.getItems()) === null || _this$getItems === void 0 || _this$getItems.forEach(item => {\n      item.dirty = true;\n    });\n  }\n  /**\n   * Mark all items as not loaded.\n   */\n  markAllItemsUnloaded() {\n    var _this$getItems2;\n    (_this$getItems2 = this.getItems()) === null || _this$getItems2 === void 0 || _this$getItems2.forEach(item => {\n      item.loaded = false;\n    });\n  }\n}","map":{"version":3,"names":["CoreSwipeSlidesItemsManagerSource","CoreSwipeSlidesDynamicItemsManagerSource","constructor","loadingItems","load","selectedItem","_this","_asyncToGenerator","loaded","initialItem","loadItem","setLoaded","loadItems","item","_this2","previousItem","getPreviousItem","nextItem","getNextItem","Promise","all","loadItemInList","preload","_this3","preloadedItem","performLoadItemData","existingItem","getItem","getItemId","items","previousItemId","nextItemId","added","some","index","itemId","indexToInsert","_this3$items","splice","push","notifyItemsUpdated","_this4","dirty","itemData","loadItemData","Object","assign","markAllItemsDirty","_this$getItems","getItems","forEach","markAllItemsUnloaded","_this$getItems2"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/items-management/swipe-slides-dynamic-items-manager-source.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreSwipeSlidesItemsManagerSource } from './swipe-slides-items-manager-source';\n\n/**\n * Items collection source data for \"swipe slides\".\n */\nexport abstract class CoreSwipeSlidesDynamicItemsManagerSource<Item extends CoreSwipeSlidesDynamicItem>\n    extends CoreSwipeSlidesItemsManagerSource<Item> {\n\n    // Items being loaded, to prevent loading them twice.\n    protected loadingItems: Record<string, boolean> = {};\n\n    /**\n     * @inheritdoc\n     */\n    async load(selectedItem?: Item | null): Promise<void> {\n        if (!this.loaded && this.initialItem) {\n            // Load the initial item.\n            await this.loadItem(this.initialItem);\n        } else if (this.loaded && selectedItem) {\n            // Reload selected item if needed.\n            await this.loadItem(selectedItem);\n        }\n\n        this.setLoaded();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected async loadItems(): Promise<Item[]> {\n        // Not used in dynamic slides.\n        return [];\n    }\n\n    /**\n     * Load a certain item and preload next and previous ones.\n     *\n     * @param item Item to load.\n     * @returns Promise resolved when done.\n     */\n    async loadItem(item: Item): Promise<void> {\n        const previousItem = this.getPreviousItem(item);\n        const nextItem = this.getNextItem(item);\n\n        await Promise.all([\n            this.loadItemInList(item, false),\n            previousItem && this.loadItemInList(previousItem, true),\n            nextItem && this.loadItemInList(nextItem, true),\n        ]);\n    }\n\n    /**\n     * Load or preload a certain item and add it to the list.\n     *\n     * @param item Item to load.\n     * @param preload Whether to preload.\n     * @returns Promise resolved when done.\n     */\n    async loadItemInList(item: Item, preload = false): Promise<void> {\n        const preloadedItem = await this.performLoadItemData(item, preload);\n        if (!preloadedItem) {\n            return;\n        }\n\n        // Add the item at the right position.\n        const existingItem = this.getItem(this.getItemId(item));\n        if (existingItem) {\n            // Already in list, no need to add it.\n            return;\n        }\n\n        if (!this.items) {\n            this.items = [];\n        }\n\n        const previousItem = this.getPreviousItem(item);\n        const nextItem = this.getNextItem(item);\n        const previousItemId = previousItem ? this.getItemId(previousItem) : null;\n        const nextItemId = nextItem ? this.getItemId(nextItem) : null;\n\n        const added = this.items.some((item, index) => {\n            const itemId = this.getItemId(item);\n            let indexToInsert = -1;\n            if (itemId === previousItemId) {\n                // Previous item found, add the item after it.\n                indexToInsert = index + 1;\n            }\n\n            if (itemId === nextItemId) {\n                // Next item found, add the item before it.\n                indexToInsert = index;\n            }\n\n            if (indexToInsert > -1) {\n                this.items?.splice(indexToInsert, 0, preloadedItem);\n\n                return true;\n            }\n        });\n\n        if (!added) {\n            // Previous and next items not found, this probably means the array is still empty. Add it at the end.\n            this.items.push(preloadedItem);\n        }\n\n        this.notifyItemsUpdated();\n    }\n\n    /**\n     * Load or preload a certain item data.\n     * This helper function will check some common cases so they don't have to be replicated in all loadItemData implementations.\n     *\n     * @param item Item to load.\n     * @param preload Whether to preload.\n     * @returns Promise resolved with item. Resolve with null if already loading or item is not valid (e.g. there are no more items)\n     */\n    protected async performLoadItemData(item: Item, preload: boolean): Promise<Item | null> {\n        const itemId = this.getItemId(item);\n\n        if (this.loadingItems[itemId]) {\n            // Already loading, ignore it.\n            return null;\n        }\n\n        const existingItem = this.getItem(itemId);\n        if (existingItem && ((existingItem.loaded && !existingItem.dirty) || preload)) {\n            // Already loaded, or preloading an already preloaded item.\n            return existingItem;\n        }\n\n        // Load the item.\n        this.loadingItems[itemId] = true;\n\n        try {\n            const itemData = await this.loadItemData(item, preload);\n\n            if (itemData && !preload) {\n                itemData.loaded = true;\n                itemData.dirty = false;\n            }\n\n            if (existingItem && itemData) {\n                // Update item that is already in list.\n                Object.assign(existingItem, itemData);\n\n                return existingItem;\n            }\n\n            return itemData;\n        } finally {\n            this.loadingItems[itemId] = false;\n        }\n    }\n\n    /**\n     * Mark all items as dirty.\n     */\n    markAllItemsDirty(): void {\n        this.getItems()?.forEach(item => {\n            item.dirty = true;\n        });\n    }\n\n    /**\n     * Mark all items as not loaded.\n     */\n    markAllItemsUnloaded(): void {\n        this.getItems()?.forEach(item => {\n            item.loaded = false;\n        });\n    }\n\n    /**\n     * Load or preload a certain item data.\n     *\n     * @param item Basic data about the item to load.\n     * @param preload Whether to preload.\n     * @returns Promise resolved with item. Resolve with null if item is not valid (e.g. there are no more items).\n     */\n    abstract loadItemData(item: Item, preload: boolean): Promise<Item | null>;\n\n    /**\n     * Return the data to identify the previous item.\n     *\n     * @param item Data about the item.\n     * @returns Previous item data. Null if no previous item.\n     */\n    abstract getPreviousItem(item: Item): Item | null;\n\n    /**\n     * Return the data to identify the next item.\n     *\n     * @param item Data about the item.\n     * @returns Next item data. Null if no next item.\n     */\n    abstract getNextItem(item: Item): Item | null;\n\n}\n\nexport type CoreSwipeSlidesDynamicItem = {\n    loaded?: boolean; // Whether the item has been loaded. This value can affect UI (e.g. to display a spinner).\n    dirty?: boolean; // Whether the item data needs to be reloaded. This value usually shouldn't affect UI.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}