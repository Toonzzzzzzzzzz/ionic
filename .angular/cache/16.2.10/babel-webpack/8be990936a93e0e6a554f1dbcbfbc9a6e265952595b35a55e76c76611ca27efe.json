{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreApp } from '@services/app';\nimport { CoreNetwork } from '@services/network';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils, ToastDuration } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreLogger } from '@singletons/logger';\nimport { Translate } from '@singletons';\nimport { CoreLang } from '@services/lang';\nimport { CoreSites } from '@services/sites';\nimport { CoreSilentError } from '../errors/silenterror';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { Observable, Subject, firstValueFrom } from 'rxjs';\nimport { finalize, map, mergeMap } from 'rxjs/operators';\nimport { CoreSiteError } from '@classes/errors/siteerror';\nimport { CoreUserAuthenticatedSupportConfig } from '@features/user/classes/support/authenticated-support-config';\nimport { CoreUnauthenticatedSite } from './unauthenticated-site';\nimport { Md5 } from 'ts-md5';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreErrorLogs } from '@singletons/error-logs';\n/**\n * Class that represents a site (combination of site + user) where the user has authenticated but the site hasn't been validated\n * yet, it might be a site not supported by the app.\n */\nexport class CoreAuthenticatedSite extends CoreUnauthenticatedSite {\n  /**\n   * Create a site.\n   *\n   * @param siteUrl Site URL.\n   * @param token Site's WS token.\n   * @param otherData Other data.\n   */\n  constructor(siteUrl, token, otherData = {}) {\n    super(siteUrl, otherData.publicConfig);\n    this.cleanUnicode = false;\n    this.offlineDisabled = false;\n    this.memoryCache = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.ongoingRequests = {};\n    this.requestQueue = [];\n    this.requestQueueTimeout = null;\n    this.logger = CoreLogger.getInstance('CoreAuthenticaedSite');\n    this.token = token;\n    this.privateToken = otherData.privateToken;\n  }\n  /**\n   * Get site token.\n   *\n   * @returns Site token.\n   */\n  getToken() {\n    return this.token;\n  }\n  /**\n   * @inheritdoc\n   */\n  getInfo() {\n    return this.infos;\n  }\n  /**\n   * Get site private token.\n   *\n   * @returns Site private token.\n   */\n  getPrivateToken() {\n    return this.privateToken;\n  }\n  /**\n   * Get site user's ID.\n   *\n   * @returns User's ID.\n   */\n  getUserId() {\n    if (!this.infos) {\n      // Shouldn't happen for authenticated sites.\n      throw new CoreError('Site info could not be fetched.');\n    }\n    return this.infos.userid;\n  }\n  /**\n   * Get site Course ID for frontpage course. If not declared it will return 1 as default.\n   *\n   * @returns Site Home ID.\n   */\n  getSiteHomeId() {\n    var _this$infos;\n    return ((_this$infos = this.infos) === null || _this$infos === void 0 ? void 0 : _this$infos.siteid) || 1;\n  }\n  /**\n   * Set site token.\n   *\n   * @param token New token.\n   */\n  setToken(token) {\n    this.token = token;\n  }\n  /**\n   * Set site private token.\n   *\n   * @param privateToken New private token.\n   */\n  setPrivateToken(privateToken) {\n    this.privateToken = privateToken;\n  }\n  /**\n   * Check if user logged out from the site and needs to authenticate again.\n   *\n   * @returns Whether is logged out.\n   */\n  isLoggedOut() {\n    return false;\n  }\n  /**\n   * Set site info.\n   *\n   * @param infos New info.\n   */\n  setInfo(infos) {\n    this.infos = infos;\n    // Index function by name to speed up wsAvailable method.\n    if (infos !== null && infos !== void 0 && infos.functions) {\n      infos.functionsByName = CoreUtils.arrayToObject(infos.functions, 'name');\n    }\n  }\n  /**\n   * Check if current user is Admin.\n   * Works properly since v3.8. See more in: {@link https://tracker.moodle.org/browse/MDL-65550}\n   *\n   * @returns Whether the user is Admin.\n   */\n  isAdmin() {\n    var _this$getInfo$useriss, _this$getInfo;\n    return (_this$getInfo$useriss = (_this$getInfo = this.getInfo()) === null || _this$getInfo === void 0 ? void 0 : _this$getInfo.userissiteadmin) !== null && _this$getInfo$useriss !== void 0 ? _this$getInfo$useriss : false;\n  }\n  /**\n   * Can the user access their private files?\n   *\n   * @returns Whether can access my files.\n   */\n  canAccessMyFiles() {\n    const info = this.getInfo();\n    return !!(info && (info.usercanmanageownfiles === undefined || info.usercanmanageownfiles));\n  }\n  /**\n   * Can the user download files?\n   *\n   * @returns Whether can download files.\n   */\n  canDownloadFiles() {\n    const info = this.getInfo();\n    return !!(info !== null && info !== void 0 && info.downloadfiles) && (info === null || info === void 0 ? void 0 : info.downloadfiles) > 0;\n  }\n  /**\n   * Can the user use an advanced feature?\n   *\n   * @param featureName The name of the feature.\n   * @param whenUndefined The value to return when the parameter is undefined.\n   * @returns Whether can use advanced feature.\n   */\n  canUseAdvancedFeature(featureName, whenUndefined = true) {\n    const info = this.getInfo();\n    if ((info === null || info === void 0 ? void 0 : info.advancedfeatures) === undefined) {\n      return whenUndefined;\n    }\n    const feature = info.advancedfeatures.find(item => item.name === featureName);\n    if (!feature) {\n      return whenUndefined;\n    }\n    return feature.value !== 0;\n  }\n  /**\n   * Can the user upload files?\n   *\n   * @returns Whether can upload files.\n   */\n  canUploadFiles() {\n    const info = this.getInfo();\n    return !!(info !== null && info !== void 0 && info.uploadfiles) && (info === null || info === void 0 ? void 0 : info.uploadfiles) > 0;\n  }\n  /**\n   * Fetch site info from the Moodle site.\n   *\n   * @returns A promise to be resolved when the site info is retrieved.\n   */\n  fetchSiteInfo() {\n    // The get_site_info WS call won't be cached.\n    const preSets = {\n      getFromCache: false,\n      saveToCache: false,\n      skipQueue: true\n    };\n    // Reset clean Unicode to check if it's supported again.\n    this.cleanUnicode = false;\n    return this.read('core_webservice_get_site_info', {}, preSets);\n  }\n  /**\n   * Read some data from the Moodle site using WS. Requests are cached by default.\n   *\n   * @param method WS method to use.\n   * @param data Data to send to the WS.\n   * @param preSets Extra options.\n   * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  read(method, data, preSets) {\n    return firstValueFrom(this.readObservable(method, data, preSets));\n  }\n  /**\n   * Read some data from the Moodle site using WS. Requests are cached by default.\n   *\n   * @param method WS method to use.\n   * @param data Data to send to the WS.\n   * @param preSets Extra options.\n   * @returns Observable returning the WS data.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readObservable(method, data, preSets) {\n    var _preSets$getFromCache, _preSets$saveToCache, _preSets$reusePending;\n    preSets = preSets || {};\n    preSets.getFromCache = (_preSets$getFromCache = preSets.getFromCache) !== null && _preSets$getFromCache !== void 0 ? _preSets$getFromCache : true;\n    preSets.saveToCache = (_preSets$saveToCache = preSets.saveToCache) !== null && _preSets$saveToCache !== void 0 ? _preSets$saveToCache : true;\n    preSets.reusePending = (_preSets$reusePending = preSets.reusePending) !== null && _preSets$reusePending !== void 0 ? _preSets$reusePending : true;\n    return this.requestObservable(method, data, preSets);\n  }\n  /**\n   * Sends some data to the Moodle site using WS. Requests are NOT cached by default.\n   *\n   * @param method WS method to use.\n   * @param data Data to send to the WS.\n   * @param preSets Extra options.\n   * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  write(method, data, preSets) {\n    return firstValueFrom(this.writeObservable(method, data, preSets));\n  }\n  /**\n   * Sends some data to the Moodle site using WS. Requests are NOT cached by default.\n   *\n   * @param method WS method to use.\n   * @param data Data to send to the WS.\n   * @param preSets Extra options.\n   * @returns Observable returning the WS data.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  writeObservable(method, data, preSets) {\n    var _preSets$getFromCache2, _preSets$saveToCache2, _preSets$emergencyCac;\n    preSets = preSets || {};\n    preSets.getFromCache = (_preSets$getFromCache2 = preSets.getFromCache) !== null && _preSets$getFromCache2 !== void 0 ? _preSets$getFromCache2 : false;\n    preSets.saveToCache = (_preSets$saveToCache2 = preSets.saveToCache) !== null && _preSets$saveToCache2 !== void 0 ? _preSets$saveToCache2 : false;\n    preSets.emergencyCache = (_preSets$emergencyCac = preSets.emergencyCache) !== null && _preSets$emergencyCac !== void 0 ? _preSets$emergencyCac : false;\n    return this.requestObservable(method, data, preSets);\n  }\n  /**\n   * WS request to the site.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra options.\n   * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  request(method, data, preSets) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return firstValueFrom(_this.requestObservable(method, data, preSets));\n    })();\n  }\n  /**\n   * WS request to the site.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra options.\n   * @returns Observable returning the WS data.\n   * @description\n   *\n   * Sends a webservice request to the site. This method will automatically add the\n   * required parameters and pass it on to the low level API in CoreWSProvider.call().\n   *\n   * Caching is also implemented, when enabled this method will returned a cached version of the request if the\n   * data hasn't expired.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  requestObservable(method, data, preSets) {\n    if (this.isLoggedOut() && !CoreAuthenticatedSite.ALLOWED_LOGGEDOUT_WS.includes(method)) {\n      // Site is logged out, it cannot call WebServices.\n      this.triggerSiteEvent(CoreEvents.SESSION_EXPIRED, {});\n      // Use a silent error, the SESSION_EXPIRED event will display a message if needed.\n      throw new CoreSilentError(Translate.instant('core.lostconnection'));\n    }\n    data = data || {};\n    if (!CoreNetwork.isOnline() && this.offlineDisabled) {\n      throw new CoreError(Translate.instant('core.errorofflinedisabled'));\n    }\n    // Check if the method is available.\n    // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.\n    if (this.getInfo() && !this.wsAvailable(method)) {\n      this.logger.error(`WS function '${method}' is not available.`);\n      throw new CoreError(Translate.instant('core.wsfunctionnotavailable'));\n    }\n    const wsPreSets = {\n      wsToken: this.token || '',\n      siteUrl: this.siteUrl,\n      cleanUnicode: this.cleanUnicode,\n      typeExpected: preSets.typeExpected,\n      responseExpected: preSets.responseExpected,\n      splitRequest: preSets.splitRequest\n    };\n    if (wsPreSets.cleanUnicode && CoreTextUtils.hasUnicodeData(data)) {\n      // Data will be cleaned, notify the user.\n      CoreDomUtils.showToast('core.unicodenotsupported', true, ToastDuration.LONG);\n    } else {\n      // No need to clean data in this call.\n      wsPreSets.cleanUnicode = false;\n    }\n    if (this.offlineDisabled) {\n      // Offline is disabled, don't use cache.\n      preSets.getFromCache = false;\n      preSets.saveToCache = false;\n      preSets.emergencyCache = false;\n    }\n    // Enable text filtering by default.\n    data.moodlewssettingfilter = preSets.filter === false ? false : true;\n    data.moodlewssettingfileurl = preSets.rewriteurls === false ? false : true;\n    // Convert arguments to strings before starting the cache process.\n    data = CoreWS.convertValuesToString(data, wsPreSets.cleanUnicode);\n    if (data == null) {\n      // Empty cleaned text found.\n      throw new CoreError(Translate.instant('core.unicodenotsupportedcleanerror'));\n    }\n    const cacheId = this.getCacheId(method, data);\n    // Check for an ongoing identical request.\n    const ongoingRequest = this.getOngoingRequest(cacheId, preSets);\n    if (ongoingRequest) {\n      return ongoingRequest;\n    }\n    const observable = this.performRequest(method, data, preSets, wsPreSets).pipe(\n    // Return a clone of the original object, this may prevent errors if in the callback the object is modified.\n    map(data => CoreUtils.clone(data)));\n    this.setOngoingRequest(cacheId, preSets, observable);\n    return observable.pipe(finalize(() => {\n      this.clearOngoingRequest(cacheId, preSets, observable);\n    }));\n  }\n  /**\n   * Get an ongoing request if there's one already.\n   *\n   * @param cacheId Cache ID.\n   * @param preSets Presets.\n   * @returns Ongoing request if it exists.\n   */\n  getOngoingRequest(cacheId, preSets) {\n    if (preSets.updateInBackground) {\n      var _this$ongoingRequests;\n      return (_this$ongoingRequests = this.ongoingRequests[cacheId]) === null || _this$ongoingRequests === void 0 ? void 0 : _this$ongoingRequests[OngoingRequestType.UPDATE_IN_BACKGROUND];\n    } else if (preSets.getFromCache) {\n      var _this$ongoingRequests2;\n      // Only reuse ongoing request when using cache.\n      return (_this$ongoingRequests2 = this.ongoingRequests[cacheId]) === null || _this$ongoingRequests2 === void 0 ? void 0 : _this$ongoingRequests2[OngoingRequestType.STANDARD];\n    }\n  }\n  /**\n   * Store an ongoing request in memory.\n   *\n   * @param cacheId Cache ID.\n   * @param preSets Presets.\n   * @param request Request to store.\n   */\n  setOngoingRequest(cacheId, preSets, request) {\n    var _this$ongoingRequests3;\n    this.ongoingRequests[cacheId] = (_this$ongoingRequests3 = this.ongoingRequests[cacheId]) !== null && _this$ongoingRequests3 !== void 0 ? _this$ongoingRequests3 : {};\n    if (preSets.updateInBackground) {\n      this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND] = request;\n    } else {\n      this.ongoingRequests[cacheId][OngoingRequestType.STANDARD] = request;\n    }\n  }\n  /**\n   * Clear the ongoing request unless it has changed (e.g. a new request that ignores cache).\n   *\n   * @param cacheId Cache ID.\n   * @param preSets Presets.\n   * @param request Current request.\n   */\n  clearOngoingRequest(cacheId, preSets, request) {\n    var _this$ongoingRequests4;\n    this.ongoingRequests[cacheId] = (_this$ongoingRequests4 = this.ongoingRequests[cacheId]) !== null && _this$ongoingRequests4 !== void 0 ? _this$ongoingRequests4 : {};\n    if (preSets.updateInBackground) {\n      if (this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND] === request) {\n        delete this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND];\n      }\n    } else {\n      if (this.ongoingRequests[cacheId][OngoingRequestType.STANDARD] === request) {\n        delete this.ongoingRequests[cacheId][OngoingRequestType.STANDARD];\n      }\n    }\n  }\n  /**\n   * Perform a request, getting the response either from cache or WebService.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra options related to the site.\n   * @param wsPreSets Extra options related to the WS call.\n   * @returns Observable returning the WS data.\n   */\n  performRequest(method, data, preSets, wsPreSets) {\n    var _this2 = this;\n    const subject = new Subject();\n    const run = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        try {\n          let response;\n          let cachedData;\n          try {\n            cachedData = yield _this2.getFromCache(method, data, preSets, false);\n            response = cachedData.response;\n          } catch (_unused) {\n            // Not found or expired, call WS.\n            response = yield _this2.getFromWS(method, data, preSets, wsPreSets);\n          }\n          if (typeof response === 'object' && response !== null && ('exception' in response && response.exception !== undefined || 'errorcode' in response && response.errorcode !== undefined)) {\n            subject.error(new CoreWSError(response));\n          } else {\n            subject.next(response);\n          }\n          if (preSets.updateInBackground && !CoreConstants.CONFIG.disableCallWSInBackground && cachedData && !cachedData.expirationIgnored && cachedData.expirationTime !== undefined && Date.now() > cachedData.expirationTime) {\n            // Update the data in background.\n            setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n              try {\n                preSets = _objectSpread(_objectSpread({}, preSets), {}, {\n                  emergencyCache: false\n                });\n                const newData = yield _this2.getFromWS(method, data, preSets, wsPreSets);\n                subject.next(newData);\n              } catch (error) {\n                // Ignore errors when updating in background.\n                _this2.logger.error('Error updating WS data in background', error);\n              } finally {\n                subject.complete();\n              }\n            }));\n          } else {\n            // No need to update in background, complete the observable.\n            subject.complete();\n          }\n        } catch (error) {\n          subject.error(error);\n        }\n      });\n      return function run() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    run();\n    return subject;\n  }\n  /**\n   * Get a request response from WS, if it fails it might try to get it from emergency cache.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra options related to the site.\n   * @param wsPreSets Extra options related to the WS call.\n   * @returns Promise resolved with the response.\n   */\n  getFromWS(method, data,\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  preSets, wsPreSets) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (preSets.forceOffline) {\n        // Don't call the WS, just fail.\n        throw new CoreError(Translate.instant('core.cannotconnect'));\n      }\n      try {\n        const response = yield _this3.callOrEnqueueWS(method, data, preSets, wsPreSets);\n        if (preSets.saveToCache) {\n          _this3.saveToCache(method, data, response, preSets);\n        }\n        return response;\n      } catch (error) {\n        let useSilentError = false;\n        if (CoreUtils.isExpiredTokenError(error)) {\n          // Session expired, trigger event.\n          _this3.triggerSiteEvent(CoreEvents.SESSION_EXPIRED, {});\n          // Change error message. Try to get data from cache, the event will handle the error.\n          error.message = Translate.instant('core.lostconnection');\n          useSilentError = true; // Use a silent error, the SESSION_EXPIRED event will display a message if needed.\n        } else if (error.errorcode === 'userdeleted' || error.errorcode === 'wsaccessuserdeleted') {\n          // User deleted, trigger event.\n          _this3.triggerSiteEvent(CoreEvents.USER_DELETED, {\n            params: data\n          });\n          error.message = Translate.instant('core.userdeleted');\n          throw new CoreWSError(error);\n        } else if (error.errorcode === 'wsaccessusersuspended') {\n          // User suspended, trigger event.\n          _this3.triggerSiteEvent(CoreEvents.USER_SUSPENDED, {\n            params: data\n          });\n          error.message = Translate.instant('core.usersuspended');\n          throw new CoreWSError(error);\n        } else if (error.errorcode === 'wsaccessusernologin') {\n          // User suspended, trigger event.\n          _this3.triggerSiteEvent(CoreEvents.USER_NO_LOGIN, {\n            params: data\n          });\n          error.message = Translate.instant('core.usernologin');\n          throw new CoreWSError(error);\n        } else if (error.errorcode === 'forcepasswordchangenotice') {\n          // Password Change Forced, trigger event. Try to get data from cache, the event will handle the error.\n          _this3.triggerSiteEvent(CoreEvents.PASSWORD_CHANGE_FORCED, {});\n          error.message = Translate.instant('core.forcepasswordchangenotice');\n          useSilentError = true; // Use a silent error, the change password page already displays the appropiate info.\n        } else if (error.errorcode === 'usernotfullysetup') {\n          // User not fully setup, trigger event. Try to get data from cache, the event will handle the error.\n          _this3.triggerSiteEvent(CoreEvents.USER_NOT_FULLY_SETUP, {});\n          error.message = Translate.instant('core.usernotfullysetup');\n          useSilentError = true; // Use a silent error, the complete profile page already displays the appropiate info.\n        } else if (error.errorcode === 'sitepolicynotagreed') {\n          // Site policy not agreed, trigger event.\n          _this3.triggerSiteEvent(CoreEvents.SITE_POLICY_NOT_AGREED, {});\n          error.message = Translate.instant('core.login.sitepolicynotagreederror');\n          throw new CoreWSError(error);\n        } else if (error.errorcode === 'dmlwriteexception' && CoreTextUtils.hasUnicodeData(data)) {\n          if (!_this3.cleanUnicode) {\n            // Try again cleaning unicode.\n            _this3.cleanUnicode = true;\n            return _this3.request(method, data, preSets);\n          }\n          // This should not happen.\n          error.message = Translate.instant('core.unicodenotsupported');\n          throw new CoreWSError(error);\n        } else if (error.exception === 'required_capability_exception' || error.errorcode === 'nopermission' || error.errorcode === 'notingroup') {\n          // Translate error messages with missing strings.\n          if (error.message === 'error/nopermission') {\n            error.message = Translate.instant('core.nopermissionerror');\n          } else if (error.message === 'error/notingroup') {\n            error.message = Translate.instant('core.notingroup');\n          }\n          if (preSets.saveToCache) {\n            // Save the error instead of deleting the cache entry so the same content is displayed in offline.\n            _this3.saveToCache(method, data, error, preSets);\n          }\n          throw new CoreWSError(error);\n        } else if (preSets.cacheErrors && preSets.cacheErrors.indexOf(error.errorcode) != -1) {\n          // Save the error instead of deleting the cache entry so the same content is displayed in offline.\n          _this3.saveToCache(method, data, error, preSets);\n          throw new CoreWSError(error);\n        } else if (preSets.emergencyCache === false) {\n          _this3.logger.debug(`WS call '${method}' failed. Emergency cache is forbidden, rejecting.`);\n          throw new CoreWSError(error);\n        }\n        if (preSets.deleteCacheIfWSError && CoreUtils.isWebServiceError(error)) {\n          // Delete the cache entry and return the entry. Don't block the user with the delete.\n          CoreUtils.ignoreErrors(_this3.deleteFromCache(method, data, preSets));\n          throw new CoreWSError(error);\n        }\n        _this3.logger.debug(`WS call '${method}' failed. Trying to use the emergency cache.`);\n        preSets = _objectSpread(_objectSpread({}, preSets), {}, {\n          omitExpires: true,\n          getFromCache: true\n        });\n        try {\n          const cachedData = yield _this3.getFromCache(method, data, preSets, true);\n          if (typeof cachedData.response === 'object' && cachedData.response !== null && ('exception' in cachedData.response && cachedData.response.exception !== undefined || 'errorcode' in cachedData.response && cachedData.response.errorcode !== undefined)) {\n            throw new CoreWSError(cachedData.response);\n          }\n          return cachedData.response;\n        } catch (_unused2) {\n          if (useSilentError) {\n            throw new CoreSilentError(error.message);\n          }\n          throw new CoreWSError(error);\n        }\n      }\n    })();\n  }\n  /**\n   * Get a request response from WS.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra options related to the site.\n   * @param wsPreSets Extra options related to the WS call.\n   * @returns Promise resolved with the response.\n   */\n  callOrEnqueueWS(method, data,\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  preSets, wsPreSets) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _this4$token, _preSets$lang;\n      // Call the WS.\n      const initialToken = (_this4$token = _this4.token) !== null && _this4$token !== void 0 ? _this4$token : '';\n      // Send the language to use. Do it after checking cache to prevent losing offline data when changing language.\n      // Moodle uses underscore instead of dash.\n      data = _objectSpread(_objectSpread({}, data), {}, {\n        moodlewssettinglang: CoreLang.formatLanguage((_preSets$lang = preSets.lang) !== null && _preSets$lang !== void 0 ? _preSets$lang : yield CoreLang.getCurrentLanguage(), \"lms\" /* CoreLangFormat.LMS */)\n      });\n\n      try {\n        return yield _this4.callOrEnqueueRequest(method, data, preSets, wsPreSets);\n      } catch (error) {\n        if (CoreUtils.isExpiredTokenError(error)) {\n          if (initialToken !== _this4.token) {\n            var _this4$token2;\n            // Token has changed, retry with the new token.\n            wsPreSets.wsToken = (_this4$token2 = _this4.token) !== null && _this4$token2 !== void 0 ? _this4$token2 : '';\n            return yield _this4.callOrEnqueueRequest(method, data, preSets, wsPreSets);\n          } else if (CoreApp.isSSOAuthenticationOngoing()) {\n            // There's an SSO authentication ongoing, wait for it to finish and try again.\n            yield CoreApp.waitForSSOAuthentication();\n            return yield _this4.callOrEnqueueRequest(method, data, preSets, wsPreSets);\n          }\n        }\n        if ((error === null || error === void 0 ? void 0 : error.errorcode) === 'invalidparameter' && method === 'core_webservice_get_site_info') {\n          // Retry without passing the lang, this parameter isn't supported in 3.4 or older sites\n          // and we need this WS call to be able to determine if the site is supported or not.\n          delete data.moodlewssettinglang;\n          return yield _this4.callOrEnqueueRequest(method, data, preSets, wsPreSets);\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Adds a request to the queue or calls it immediately when not using the queue.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra options related to the site.\n   * @param wsPreSets Extra options related to the WS call.\n   * @returns Promise resolved with the response when the WS is called.\n   */\n  callOrEnqueueRequest(method, data,\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  preSets, wsPreSets) {\n    if (preSets.skipQueue || !this.wsAvailable('tool_mobile_call_external_functions')) {\n      return CoreWS.call(method, data, wsPreSets);\n    }\n    const cacheId = this.getCacheId(method, data);\n    // Check if there is an identical request waiting in the queue (read requests only by default).\n    if (preSets.reusePending) {\n      const request = this.requestQueue.find(request => request.cacheId == cacheId);\n      if (request) {\n        return request.deferred;\n      }\n    }\n    const request = {\n      cacheId,\n      method,\n      data,\n      preSets,\n      wsPreSets,\n      deferred: new CorePromisedValue()\n    };\n    return this.enqueueRequest(request);\n  }\n  /**\n   * Adds a request to the queue.\n   *\n   * @param request The request to enqueue.\n   * @returns Promise resolved with the response when the WS is called.\n   */\n  enqueueRequest(request) {\n    this.requestQueue.push(request);\n    if (this.requestQueue.length >= CoreConstants.CONFIG.wsrequestqueuelimit) {\n      this.processRequestQueue();\n    } else if (!this.requestQueueTimeout) {\n      this.requestQueueTimeout = window.setTimeout(() => this.processRequestQueue(), CoreConstants.CONFIG.wsrequestqueuedelay);\n    }\n    return request.deferred;\n  }\n  /**\n   * Call the enqueued web service requests.\n   */\n  processRequestQueue() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      _this5.logger.debug(`Processing request queue (${_this5.requestQueue.length} requests)`);\n      // Clear timeout if set.\n      if (_this5.requestQueueTimeout) {\n        clearTimeout(_this5.requestQueueTimeout);\n        _this5.requestQueueTimeout = null;\n      }\n      // Extract all requests from the queue.\n      const requests = _this5.requestQueue;\n      _this5.requestQueue = [];\n      if (requests.length == 1 && !CoreAuthenticatedSite.REQUEST_QUEUE_FORCE_WS) {\n        // Only one request, do a regular web service call.\n        try {\n          const data = yield CoreWS.call(requests[0].method, requests[0].data, requests[0].wsPreSets);\n          requests[0].deferred.resolve(data);\n        } catch (error) {\n          requests[0].deferred.reject(error);\n        }\n        return;\n      }\n      let lang;\n      const requestsData = {\n        requests: requests.map(request => {\n          const args = {};\n          const settings = {};\n          // Separate WS settings from function arguments.\n          Object.keys(request.data).forEach(key => {\n            let value = request.data[key];\n            const match = /^moodlews(setting.*)$/.exec(key);\n            if (match) {\n              if (match[1] == 'settingfilter' || match[1] == 'settingfileurl') {\n                // Undo special treatment of these settings in CoreWSProvider.convertValuesToString.\n                value = value == 'true' ? '1' : '0';\n              } else if (match[1] == 'settinglang') {\n                // Use the lang globally to avoid exceptions with languages not installed.\n                lang = value;\n                return;\n              }\n              settings[match[1]] = value;\n            } else {\n              args[key] = value;\n            }\n          });\n          return _objectSpread({\n            function: request.method,\n            arguments: JSON.stringify(args)\n          }, settings);\n        })\n      };\n      requestsData.moodlewssettinglang = lang;\n      const wsPresets = {\n        siteUrl: _this5.siteUrl,\n        wsToken: _this5.token || ''\n      };\n      try {\n        const data = yield CoreWS.call('tool_mobile_call_external_functions', requestsData, wsPresets);\n        if (!data || !data.responses) {\n          throw new CoreSiteError({\n            supportConfig: new CoreUserAuthenticatedSupportConfig(_this5),\n            message: Translate.instant('core.siteunavailablehelp', {\n              site: _this5.siteUrl\n            }),\n            errorcode: 'invalidresponse',\n            errorDetails: Translate.instant('core.errorinvalidresponse', {\n              method: 'tool_mobile_call_external_functions'\n            })\n          });\n        }\n        requests.forEach((request, i) => {\n          const response = data.responses[i];\n          if (!response) {\n            // Request not executed, enqueue again.\n            _this5.enqueueRequest(request);\n          } else if (response.error) {\n            var _response$exception;\n            const rejectReason = CoreTextUtils.parseJSON(response.exception || '');\n            request.deferred.reject(rejectReason);\n            CoreErrorLogs.addErrorLog({\n              method: request.method,\n              type: 'CoreSiteError',\n              message: (_response$exception = response.exception) !== null && _response$exception !== void 0 ? _response$exception : '',\n              time: new Date().getTime(),\n              data: request.data\n            });\n          } else {\n            let responseData = response.data ? CoreTextUtils.parseJSON(response.data) : {};\n            // Match the behaviour of CoreWSProvider.call when no response is expected.\n            const responseExpected = wsPresets.responseExpected === undefined || wsPresets.responseExpected;\n            if (!responseExpected && (responseData == null || responseData === '')) {\n              responseData = {};\n            }\n            request.deferred.resolve(responseData);\n          }\n        });\n      } catch (error) {\n        // Error not specific to a single request, reject all promises.\n        requests.forEach(request => {\n          var _String;\n          CoreErrorLogs.addErrorLog({\n            method: request.method,\n            type: 'CoreSiteError',\n            message: (_String = String(error)) !== null && _String !== void 0 ? _String : '',\n            time: new Date().getTime(),\n            data: request.data\n          });\n          request.deferred.reject(error);\n        });\n      }\n    })();\n  }\n  /**\n   * Check if a WS is available in this site.\n   *\n   * @param method WS name.\n   * @returns Whether the WS is available.\n   */\n  wsAvailable(method) {\n    var _this$infos2;\n    return !!((_this$infos2 = this.infos) !== null && _this$infos2 !== void 0 && (_this$infos2 = _this$infos2.functionsByName) !== null && _this$infos2 !== void 0 && _this$infos2[method]);\n  }\n  /**\n   * Get cache ID.\n   *\n   * @param method The WebService method.\n   * @param data Arguments to pass to the method.\n   * @returns Cache ID.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getCacheId(method, data) {\n    return Md5.hashAsciiStr(method + ':' + CoreUtils.sortAndStringify(data));\n  }\n  /**\n   * Get a WS response from cache.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra options.\n   * @param emergency Whether it's an \"emergency\" cache call (WS call failed).\n   * @returns Cached data.\n   */\n  getFromCache(method, data,\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  preSets, emergency) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (!preSets.getFromCache) {\n        throw new CoreError('Get from cache is disabled.');\n      }\n      const id = _this6.getCacheId(method, data);\n      let entry;\n      if (preSets.getCacheUsingCacheKey || emergency && preSets.getEmergencyCacheUsingCacheKey) {\n        var _preSets$cacheKey;\n        const entries = yield _this6.getCacheEntriesByKey((_preSets$cacheKey = preSets.cacheKey) !== null && _preSets$cacheKey !== void 0 ? _preSets$cacheKey : '');\n        if (!entries.length) {\n          // Cache key not found, get by params sent.\n          entry = yield _this6.getCacheEntryById(id);\n        } else {\n          if (entries.length > 1) {\n            // More than one entry found. Search the one with same ID as this call.\n            entry = entries.find(entry => entry.id == id);\n          }\n          if (!entry) {\n            entry = entries[0];\n          }\n        }\n      } else {\n        entry = yield _this6.getCacheEntryById(id);\n      }\n      if (entry === undefined) {\n        throw new CoreError('Cache entry not valid.');\n      }\n      const now = Date.now();\n      let expirationTime;\n      const forceCache = preSets.omitExpires || preSets.forceOffline || !CoreNetwork.isOnline();\n      if (!forceCache) {\n        expirationTime = entry.expirationTime + _this6.getExpirationDelay(preSets.updateFrequency);\n        if (preSets.updateInBackground && !CoreConstants.CONFIG.disableCallWSInBackground) {\n          var _CoreConstants$CONFIG;\n          // Use a extended expiration time.\n          const extendedTime = entry.expirationTime + ((_CoreConstants$CONFIG = CoreConstants.CONFIG.callWSInBackgroundExpirationTime) !== null && _CoreConstants$CONFIG !== void 0 ? _CoreConstants$CONFIG : CoreConstants.SECONDS_WEEK * 1000);\n          if (now > extendedTime) {\n            _this6.logger.debug('Cached element found, but it is expired even for call WS in background.');\n            throw new CoreError('Cache entry is expired.');\n          }\n        } else if (now > expirationTime) {\n          _this6.logger.debug('Cached element found, but it is expired');\n          throw new CoreError('Cache entry is expired.');\n        }\n      }\n      if (entry.data !== undefined) {\n        if (!expirationTime) {\n          _this6.logger.info(`Cached element found, id: ${id}. Expiration time ignored.`);\n        } else {\n          const expires = (expirationTime - now) / 1000;\n          _this6.logger.info(`Cached element found, id: ${id}. Expires in expires in ${expires} seconds`);\n        }\n        return {\n          response: CoreTextUtils.parseJSON(entry.data, {}),\n          expirationIgnored: forceCache,\n          expirationTime\n        };\n      }\n      throw new CoreError('Cache entry not valid.');\n    })();\n  }\n  /**\n   * Get cache entry by ID.\n   *\n   * @param id Cache ID.\n   * @returns Cache entry.\n   */\n  getCacheEntryById(id) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this7.memoryCache[id]) {\n        throw new CoreError('Cache entry not found.');\n      }\n      return _this7.memoryCache[id];\n    })();\n  }\n  /**\n   * Get cache entries by key.\n   *\n   * @param key Cache key.\n   * @returns Cache entries.\n   */\n  getCacheEntriesByKey(key) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return Object.values(_this8.memoryCache).filter(entry => entry.key === key);\n    })();\n  }\n  /**\n   * Save a WS response to cache.\n   *\n   * @param method The WebService method.\n   * @param data Arguments to pass to the method.\n   * @param response The WS response.\n   * @param preSets Extra options.\n   * @returns Promise resolved when the response is saved.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  saveToCache(method, data, response, preSets) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (preSets.uniqueCacheKey) {\n        // Cache key must be unique, delete all entries with same cache key.\n        yield CoreUtils.ignoreErrors(_this9.deleteFromCache(method, data, preSets, true));\n      }\n      // Since 3.7, the expiration time contains the time the entry is modified instead of the expiration time.\n      // We decided to reuse this field to prevent modifying the database table.\n      const id = _this9.getCacheId(method, data);\n      const entry = {\n        id,\n        data: JSON.stringify(response),\n        expirationTime: Date.now()\n      };\n      if (preSets.cacheKey) {\n        entry.key = preSets.cacheKey;\n      }\n      if (preSets.component) {\n        entry.component = preSets.component;\n        if (preSets.componentId) {\n          entry.componentId = preSets.componentId;\n        }\n      }\n      yield _this9.storeCacheEntry(entry);\n    })();\n  }\n  /**\n   * Store a cache entry.\n   *\n   * @param entry Entry to store.\n   */\n  storeCacheEntry(entry) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      _this10.memoryCache[entry.id] = entry;\n    })();\n  }\n  /**\n   * Delete a WS cache entry or entries.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra options.\n   * @param allCacheKey True to delete all entries with the cache key, false to delete only by ID.\n   * @returns Promise resolved when the entries are deleted.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  deleteFromCache(method, data, preSets, allCacheKey) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (allCacheKey) {\n        var _preSets$cacheKey2;\n        const entriesToDelete = yield _this11.getCacheEntriesByKey((_preSets$cacheKey2 = preSets.cacheKey) !== null && _preSets$cacheKey2 !== void 0 ? _preSets$cacheKey2 : '');\n        entriesToDelete.forEach(entry => {\n          delete _this11.memoryCache[entry.id];\n        });\n      } else {\n        delete _this11.memoryCache[_this11.getCacheId(method, data)];\n      }\n    })();\n  }\n  /**\n   * Invalidates all the cache entries.\n   *\n   * @returns Promise resolved when the cache entries are invalidated.\n   */\n  invalidateWsCache() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        for (const id in _this12.memoryCache) {\n          _this12.memoryCache[id].expirationTime = 0;\n        }\n      } finally {\n        _this12.triggerSiteEvent(CoreEvents.WS_CACHE_INVALIDATED, {});\n      }\n    })();\n  }\n  /**\n   * Invalidates all the cache entries with a certain key.\n   *\n   * @param key Key to search.\n   * @returns Promise resolved when the cache entries are invalidated.\n   */\n  invalidateWsCacheForKey(key) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (!key) {\n        return;\n      }\n      _this13.logger.debug('Invalidate cache for key: ' + key);\n      const entries = yield _this13.getCacheEntriesByKey(key);\n      entries.forEach(entry => {\n        entry.expirationTime = 0;\n      });\n    })();\n  }\n  /**\n   * Invalidates all the cache entries in an array of keys.\n   *\n   * @param keys Keys to search.\n   * @returns Promise resolved when the cache entries are invalidated.\n   */\n  invalidateMultipleWsCacheForKey(keys) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (!keys || !keys.length) {\n        return;\n      }\n      _this14.logger.debug('Invalidating multiple cache keys');\n      yield Promise.all(keys.map(key => _this14.invalidateWsCacheForKey(key)));\n    })();\n  }\n  /**\n   * Invalidates all the cache entries whose key starts with a certain value.\n   *\n   * @param key Key to search.\n   * @returns Promise resolved when the cache entries are invalidated.\n   */\n  invalidateWsCacheForKeyStartingWith(key) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      if (!key) {\n        return;\n      }\n      _this15.logger.debug('Invalidate cache for key starting with: ' + key);\n      Object.values(_this15.memoryCache).filter(entry => {\n        var _entry$key;\n        return (_entry$key = entry.key) === null || _entry$key === void 0 ? void 0 : _entry$key.startsWith(key);\n      }).forEach(entry => {\n        entry.expirationTime = 0;\n      });\n    })();\n  }\n  /**\n   * Returns the URL to the documentation of the app, based on Moodle version and current language.\n   *\n   * @param page Docs page to go to.\n   * @returns Promise resolved with the Moodle docs URL.\n   */\n  getDocsUrl(page) {\n    var _this$infos3;\n    const release = (_this$infos3 = this.infos) !== null && _this$infos3 !== void 0 && _this$infos3.release ? this.infos.release : undefined;\n    return CoreUrlUtils.getDocsUrl(release, page);\n  }\n  /**\n   * @inheritdoc\n   */\n  getPublicConfig(options = {}) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const ignoreCache = 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */ || 3 /* CoreSitesReadingStrategy.PREFER_NETWORK */;\n      if (!ignoreCache && _this16.publicConfig) {\n        return _this16.publicConfig;\n      }\n      const method = 'tool_mobile_get_public_config';\n      const cacheId = _this16.getCacheId(method, {});\n      const cachePreSets = _objectSpread({\n        getFromCache: true,\n        saveToCache: true,\n        emergencyCache: true,\n        cacheKey: _this16.getPublicConfigCacheKey()\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      if (_this16.offlineDisabled) {\n        // Offline is disabled, don't use cache.\n        cachePreSets.getFromCache = false;\n        cachePreSets.saveToCache = false;\n        cachePreSets.emergencyCache = false;\n      }\n      // Check for an ongoing identical request if we're not ignoring cache.\n      // Check for an ongoing identical request.\n      const ongoingRequest = _this16.getOngoingRequest(cacheId, cachePreSets);\n      if (ongoingRequest) {\n        return firstValueFrom(ongoingRequest);\n      }\n      const subject = new Subject();\n      const observable = subject.pipe(\n      // Return a clone of the original object, this may prevent errors if in the callback the object is modified.\n      map(data => CoreUtils.clone(data)), finalize(() => {\n        _this16.clearOngoingRequest(cacheId, cachePreSets, observable);\n      }));\n      _this16.setOngoingRequest(cacheId, cachePreSets, observable);\n      _this16.getFromCache(method, {}, cachePreSets, false).then(cachedData => cachedData.response).catch( /*#__PURE__*/_asyncToGenerator(function* () {\n        if (cachePreSets.forceOffline) {\n          // Don't call the WS, just fail.\n          throw new CoreError(Translate.instant('core.cannotconnect'));\n        }\n        // Call the WS.\n        try {\n          const config = yield _this16.requestPublicConfig();\n          if (cachePreSets.saveToCache) {\n            _this16.saveToCache(method, {}, config, cachePreSets);\n          }\n          return config;\n        } catch (error) {\n          if (cachePreSets.emergencyCache === false) {\n            throw error;\n          }\n          cachePreSets.omitExpires = true;\n          cachePreSets.getFromCache = true;\n          try {\n            const cachedData = yield _this16.getFromCache(method, {}, cachePreSets, true);\n            return cachedData.response;\n          } catch (_unused3) {\n            throw error;\n          }\n        }\n      })).then(response => {\n        // The app doesn't store exceptions for this call, it's safe to assume type CoreSitePublicConfigResponse.\n        response = response;\n        _this16.setPublicConfig(response);\n        subject.next(response);\n        subject.complete();\n        return;\n      }).catch(error => {\n        subject.error(error);\n      });\n      return firstValueFrom(observable);\n    })();\n  }\n  /**\n   * Get cache key for getPublicConfig WS calls.\n   *\n   * @returns Cache key.\n   */\n  getPublicConfigCacheKey() {\n    return 'tool_mobile_get_public_config';\n  }\n  /**\n   * Check if GET method is supported for AJAX calls.\n   *\n   * @returns Whether it's supported.\n   */\n  isAjaxGetSupported() {\n    return !!this.getInfo() && this.isVersionGreaterEqualThan('3.8');\n  }\n  /**\n   * Check if the site version is greater than one or several versions.\n   * This function accepts a string or an array of strings. If array, the last version must be the highest.\n   *\n   * @param versions Version or list of versions to check.\n   * @returns Whether it's greater or equal, false otherwise.\n   * @description\n   * If a string is supplied (e.g. '3.2.1'), it will check if the site version is greater or equal than this version.\n   *\n   * If an array of versions is supplied, it will check if the site version is greater or equal than the last version,\n   * or if it's higher or equal than any of the other releases supplied but lower than the next major release. The last\n   * version of the array must be the highest version.\n   * For example, if the values supplied are ['3.0.5', '3.2.3', '3.3.1'] the function will return true if the site version\n   * is either:\n   *     - Greater or equal than 3.3.1.\n   *     - Greater or equal than 3.2.3 but lower than 3.3.\n   *     - Greater or equal than 3.0.5 but lower than 3.1.\n   *\n   * This function only accepts versions from 2.4.0 and above. If any of the versions supplied isn't found, it will assume\n   * it's the last released major version.\n   */\n  isVersionGreaterEqualThan(versions) {\n    const info = this.getInfo();\n    if (!info || !info.version) {\n      return false;\n    }\n    const siteVersion = Number(info.version);\n    if (Array.isArray(versions)) {\n      if (!versions.length) {\n        return false;\n      }\n      for (let i = 0; i < versions.length; i++) {\n        const versionNumber = this.getVersionNumber(versions[i]);\n        if (i == versions.length - 1) {\n          // It's the last version, check only if site version is greater than this one.\n          return siteVersion >= versionNumber;\n        } else {\n          // Check if site version if bigger than this number but lesser than next major.\n          if (siteVersion >= versionNumber && siteVersion < this.getNextMajorVersionNumber(versions[i])) {\n            return true;\n          }\n        }\n      }\n    } else if (typeof versions == 'string') {\n      // Compare with this version.\n      return siteVersion >= this.getVersionNumber(versions);\n    }\n    return false;\n  }\n  /**\n   * Get a version number from a release version.\n   * If release version is valid but not found in the list of Moodle releases, it will use the last released major version.\n   *\n   * @param version Release version to convert to version number.\n   * @returns Version number, 0 if invalid.\n   */\n  getVersionNumber(version) {\n    const data = this.getMajorAndMinor(version);\n    if (!data) {\n      // Invalid version.\n      return 0;\n    }\n    if (CoreAuthenticatedSite.MOODLE_RELEASES[data.major] === undefined) {\n      // Major version not found. Use the last one.\n      const major = Object.keys(CoreAuthenticatedSite.MOODLE_RELEASES).pop();\n      if (!major) {\n        return 0;\n      }\n      data.major = major;\n    }\n    return CoreAuthenticatedSite.MOODLE_RELEASES[data.major] + data.minor;\n  }\n  /**\n   * Given a release version, return the major and minor versions.\n   *\n   * @param version Release version (e.g. '3.1.0').\n   * @returns Object with major and minor. Returns false if invalid version.\n   */\n  getMajorAndMinor(version) {\n    const match = version.match(/^(\\d+)(\\.(\\d+)(\\.\\d+)?)?/);\n    if (!match || !match[1]) {\n      // Invalid version.\n      return false;\n    }\n    return {\n      major: match[1] + '.' + (match[3] || '0'),\n      minor: parseInt(match[5], 10) || 0\n    };\n  }\n  /**\n   * Given a release version, return the next major version number.\n   *\n   * @param version Release version (e.g. '3.1.0').\n   * @returns Next major version number.\n   */\n  getNextMajorVersionNumber(version) {\n    const data = this.getMajorAndMinor(version);\n    const releases = Object.keys(CoreAuthenticatedSite.MOODLE_RELEASES);\n    if (!data) {\n      // Invalid version.\n      return 0;\n    }\n    const position = releases.indexOf(data.major);\n    if (position == -1 || position == releases.length - 1) {\n      // Major version not found or it's the last one. Use the last one.\n      return CoreAuthenticatedSite.MOODLE_RELEASES[releases[position]];\n    }\n    return CoreAuthenticatedSite.MOODLE_RELEASES[releases[position + 1]];\n  }\n  /**\n   * Get a certain cache expiration delay.\n   *\n   * @param updateFrequency The update frequency of the entry.\n   * @returns Expiration delay.\n   */\n  getExpirationDelay(updateFrequency) {\n    updateFrequency = updateFrequency || CoreAuthenticatedSite.FREQUENCY_USUALLY;\n    let expirationDelay = CoreAuthenticatedSite.UPDATE_FREQUENCIES[updateFrequency] || CoreAuthenticatedSite.UPDATE_FREQUENCIES[CoreAuthenticatedSite.FREQUENCY_USUALLY];\n    if (CoreNetwork.isNetworkAccessLimited()) {\n      // Not WiFi, increase the expiration delay a 50% to decrease the data usage in this case.\n      expirationDelay *= 1.5;\n    }\n    return expirationDelay;\n  }\n  /**\n   * Trigger an event.\n   *\n   * @param eventName Event name.\n   * @param data Event data.\n   */\n  triggerSiteEvent(eventName, data) {\n    CoreEvents.trigger(eventName, data);\n  }\n}\n/**\n * Operator to chain requests when using observables.\n *\n * @param readingStrategy Reading strategy used for the current request.\n * @param callback Callback called with the result of current request and the reading strategy to use in next requests.\n * @returns Operator.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n_class = CoreAuthenticatedSite;\n_class.REQUEST_QUEUE_FORCE_WS = false;\n// Use \"tool_mobile_call_external_functions\" even for calling a single function.\n// Constants for cache update frequency.\n_class.FREQUENCY_USUALLY = 0;\n_class.FREQUENCY_OFTEN = 1;\n_class.FREQUENCY_SOMETIMES = 2;\n_class.FREQUENCY_RARELY = 3;\n_class.MINIMUM_MOODLE_VERSION = '3.5';\n// Versions of Moodle releases.\n_class.MOODLE_RELEASES = {\n  '3.5': 2018051700,\n  '3.6': 2018120300,\n  '3.7': 2019052000,\n  '3.8': 2019111800,\n  '3.9': 2020061500,\n  '3.10': 2020110900,\n  '3.11': 2021051700,\n  '4.0': 2022041900,\n  '4.1': 2022112800,\n  '4.2': 2023042400,\n  '4.3': 2023100900\n};\n// Possible cache update frequencies.\n_class.UPDATE_FREQUENCIES = [CoreConstants.CONFIG.cache_update_frequency_usually || 420000, CoreConstants.CONFIG.cache_update_frequency_often || 1200000, CoreConstants.CONFIG.cache_update_frequency_sometimes || 3600000, CoreConstants.CONFIG.cache_update_frequency_rarely || 43200000];\n// WS that we allow to call even if the site is logged out.\n_class.ALLOWED_LOGGEDOUT_WS = ['core_user_remove_user_device'];\nexport function chainRequests(readingStrategy, callback) {\n  return source => new Observable(subscriber => {\n    let firstValue = true;\n    let isCompleted = false;\n    return source.subscribe({\n      next: function () {\n        var _ref4 = _asyncToGenerator(function* (value) {\n          if (readingStrategy !== 4 /* CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE */) {\n            // Just use same strategy.\n            subscriber.next({\n              data: value,\n              readingStrategy\n            });\n            return;\n          }\n          if (!firstValue) {\n            // Second (last) value. Chained requests should have used cached data already, just return 1 value now.\n            subscriber.next({\n              data: value\n            });\n            return;\n          }\n          firstValue = false;\n          // Wait to see if the observable is completed (no more values).\n          yield CoreUtils.nextTick();\n          if (isCompleted) {\n            // Current request only returns cached data. Let chained requests update in background.\n            subscriber.next({\n              data: value,\n              readingStrategy\n            });\n          } else {\n            // Current request will update in background. Prefer cached data in the chained requests.\n            subscriber.next({\n              data: value,\n              readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */\n            });\n          }\n        });\n        return function next(_x) {\n          return _ref4.apply(this, arguments);\n        };\n      }(),\n      error: error => subscriber.error(error),\n      complete: function () {\n        var _ref5 = _asyncToGenerator(function* () {\n          isCompleted = true;\n          yield CoreUtils.nextTick();\n          subscriber.complete();\n        });\n        return function complete() {\n          return _ref5.apply(this, arguments);\n        };\n      }()\n    });\n  }).pipe(mergeMap(({\n    data,\n    readingStrategy\n  }) => callback(data, readingStrategy)));\n}\n/**\n * Type of ongoing requests stored in memory to avoid duplicating them.\n */\nvar OngoingRequestType;\n(function (OngoingRequestType) {\n  OngoingRequestType[OngoingRequestType[\"STANDARD\"] = 0] = \"STANDARD\";\n  OngoingRequestType[OngoingRequestType[\"UPDATE_IN_BACKGROUND\"] = 1] = \"UPDATE_IN_BACKGROUND\";\n})(OngoingRequestType || (OngoingRequestType = {}));","map":{"version":3,"names":["CoreApp","CoreNetwork","CoreEvents","CoreWS","CoreDomUtils","ToastDuration","CoreTextUtils","CoreUtils","CoreConstants","CoreError","CoreWSError","CoreLogger","Translate","CoreLang","CoreSites","CoreSilentError","CorePromisedValue","Observable","Subject","firstValueFrom","finalize","map","mergeMap","CoreSiteError","CoreUserAuthenticatedSupportConfig","CoreUnauthenticatedSite","Md5","CoreUrlUtils","CoreErrorLogs","CoreAuthenticatedSite","constructor","siteUrl","token","otherData","publicConfig","cleanUnicode","offlineDisabled","memoryCache","ongoingRequests","requestQueue","requestQueueTimeout","logger","getInstance","privateToken","getToken","getInfo","infos","getPrivateToken","getUserId","userid","getSiteHomeId","_this$infos","siteid","setToken","setPrivateToken","isLoggedOut","setInfo","functions","functionsByName","arrayToObject","isAdmin","_this$getInfo$useriss","_this$getInfo","userissiteadmin","canAccessMyFiles","info","usercanmanageownfiles","undefined","canDownloadFiles","downloadfiles","canUseAdvancedFeature","featureName","whenUndefined","advancedfeatures","feature","find","item","name","value","canUploadFiles","uploadfiles","fetchSiteInfo","preSets","getFromCache","saveToCache","skipQueue","read","method","data","readObservable","_preSets$getFromCache","_preSets$saveToCache","_preSets$reusePending","reusePending","requestObservable","write","writeObservable","_preSets$getFromCache2","_preSets$saveToCache2","_preSets$emergencyCac","emergencyCache","request","_this","_asyncToGenerator","ALLOWED_LOGGEDOUT_WS","includes","triggerSiteEvent","SESSION_EXPIRED","instant","isOnline","wsAvailable","error","wsPreSets","wsToken","typeExpected","responseExpected","splitRequest","hasUnicodeData","showToast","LONG","moodlewssettingfilter","filter","moodlewssettingfileurl","rewriteurls","convertValuesToString","cacheId","getCacheId","ongoingRequest","getOngoingRequest","observable","performRequest","pipe","clone","setOngoingRequest","clearOngoingRequest","updateInBackground","_this$ongoingRequests","OngoingRequestType","UPDATE_IN_BACKGROUND","_this$ongoingRequests2","STANDARD","_this$ongoingRequests3","_this$ongoingRequests4","_this2","subject","run","_ref","response","cachedData","_unused","getFromWS","exception","errorcode","next","CONFIG","disableCallWSInBackground","expirationIgnored","expirationTime","Date","now","setTimeout","_objectSpread","newData","complete","apply","arguments","_this3","forceOffline","callOrEnqueueWS","useSilentError","isExpiredTokenError","message","USER_DELETED","params","USER_SUSPENDED","USER_NO_LOGIN","PASSWORD_CHANGE_FORCED","USER_NOT_FULLY_SETUP","SITE_POLICY_NOT_AGREED","cacheErrors","indexOf","debug","deleteCacheIfWSError","isWebServiceError","ignoreErrors","deleteFromCache","omitExpires","_unused2","_this4","_this4$token","_preSets$lang","initialToken","moodlewssettinglang","formatLanguage","lang","getCurrentLanguage","callOrEnqueueRequest","_this4$token2","isSSOAuthenticationOngoing","waitForSSOAuthentication","call","deferred","enqueueRequest","push","length","wsrequestqueuelimit","processRequestQueue","window","wsrequestqueuedelay","_this5","clearTimeout","requests","REQUEST_QUEUE_FORCE_WS","resolve","reject","requestsData","args","settings","Object","keys","forEach","key","match","exec","function","JSON","stringify","wsPresets","responses","supportConfig","site","errorDetails","i","_response$exception","rejectReason","parseJSON","addErrorLog","type","time","getTime","responseData","_String","String","_this$infos2","hashAsciiStr","sortAndStringify","emergency","_this6","id","entry","getCacheUsingCacheKey","getEmergencyCacheUsingCacheKey","_preSets$cacheKey","entries","getCacheEntriesByKey","cacheKey","getCacheEntryById","forceCache","getExpirationDelay","updateFrequency","_CoreConstants$CONFIG","extendedTime","callWSInBackgroundExpirationTime","SECONDS_WEEK","expires","_this7","_this8","values","_this9","uniqueCacheKey","component","componentId","storeCacheEntry","_this10","allCacheKey","_this11","_preSets$cacheKey2","entriesToDelete","invalidateWsCache","_this12","WS_CACHE_INVALIDATED","invalidateWsCacheForKey","_this13","invalidateMultipleWsCacheForKey","_this14","Promise","all","invalidateWsCacheForKeyStartingWith","_this15","_entry$key","startsWith","getDocsUrl","page","_this$infos3","release","getPublicConfig","options","_this16","ignoreCache","cachePreSets","getPublicConfigCacheKey","getReadingStrategyPreSets","readingStrategy","then","catch","config","requestPublicConfig","_unused3","setPublicConfig","isAjaxGetSupported","isVersionGreaterEqualThan","versions","version","siteVersion","Number","Array","isArray","versionNumber","getVersionNumber","getNextMajorVersionNumber","getMajorAndMinor","MOODLE_RELEASES","major","pop","minor","parseInt","releases","position","FREQUENCY_USUALLY","expirationDelay","UPDATE_FREQUENCIES","isNetworkAccessLimited","eventName","trigger","_class","FREQUENCY_OFTEN","FREQUENCY_SOMETIMES","FREQUENCY_RARELY","MINIMUM_MOODLE_VERSION","cache_update_frequency_usually","cache_update_frequency_often","cache_update_frequency_sometimes","cache_update_frequency_rarely","chainRequests","callback","source","subscriber","firstValue","isCompleted","subscribe","_ref4","nextTick","_x","_ref5"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/sites/authenticated-site.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreApp } from '@services/app';\nimport { CoreNetwork } from '@services/network';\nimport { CoreEventData, CoreEvents } from '@singletons/events';\nimport {\n    CoreWS,\n    CoreWSPreSets,\n    CoreWSPreSetsSplitRequest,\n    CoreWSTypeExpected,\n} from '@services/ws';\nimport { CoreDomUtils, ToastDuration } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreLogger } from '@singletons/logger';\nimport { Translate } from '@singletons';\nimport { CoreLang, CoreLangFormat } from '@services/lang';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSilentError } from '../errors/silenterror';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { Observable, ObservableInput, ObservedValueOf, OperatorFunction, Subject, firstValueFrom } from 'rxjs';\nimport { finalize, map, mergeMap } from 'rxjs/operators';\nimport { CoreSiteError } from '@classes/errors/siteerror';\nimport { CoreUserAuthenticatedSupportConfig } from '@features/user/classes/support/authenticated-support-config';\nimport { CoreSiteInfo, CoreSiteInfoResponse, CoreSitePublicConfigResponse, CoreUnauthenticatedSite } from './unauthenticated-site';\nimport { Md5 } from 'ts-md5';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreSiteWSCacheRecord } from '@services/database/sites';\nimport { CoreErrorLogs } from '@singletons/error-logs';\n\n/**\n * Class that represents a site (combination of site + user) where the user has authenticated but the site hasn't been validated\n * yet, it might be a site not supported by the app.\n */\nexport class CoreAuthenticatedSite extends CoreUnauthenticatedSite {\n\n    static readonly REQUEST_QUEUE_FORCE_WS = false; // Use \"tool_mobile_call_external_functions\" even for calling a single function.\n\n    // Constants for cache update frequency.\n    static readonly FREQUENCY_USUALLY = 0;\n    static readonly FREQUENCY_OFTEN = 1;\n    static readonly FREQUENCY_SOMETIMES = 2;\n    static readonly FREQUENCY_RARELY = 3;\n\n    static readonly MINIMUM_MOODLE_VERSION = '3.5';\n\n    // Versions of Moodle releases.\n    static readonly MOODLE_RELEASES = {\n        '3.5': 2018051700,\n        '3.6': 2018120300,\n        '3.7': 2019052000,\n        '3.8': 2019111800,\n        '3.9': 2020061500,\n        '3.10': 2020110900,\n        '3.11': 2021051700,\n        '4.0': 2022041900,\n        '4.1': 2022112800,\n        '4.2': 2023042400,\n        '4.3': 2023100900,\n    };\n\n    // Possible cache update frequencies.\n    protected static readonly UPDATE_FREQUENCIES = [\n        CoreConstants.CONFIG.cache_update_frequency_usually || 420000,\n        CoreConstants.CONFIG.cache_update_frequency_often || 1200000,\n        CoreConstants.CONFIG.cache_update_frequency_sometimes || 3600000,\n        CoreConstants.CONFIG.cache_update_frequency_rarely || 43200000,\n    ];\n\n    // WS that we allow to call even if the site is logged out.\n    protected static readonly ALLOWED_LOGGEDOUT_WS = [\n        'core_user_remove_user_device',\n    ];\n\n    token: string;\n    privateToken?: string;\n    infos?: CoreSiteInfo;\n\n    protected logger: CoreLogger;\n    protected cleanUnicode = false;\n    protected offlineDisabled = false;\n    private memoryCache: Record<string, CoreSiteWSCacheRecord> = {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected ongoingRequests: Record<string, Record<OngoingRequestType, WSObservable<any> | undefined>> = {};\n    protected requestQueue: RequestQueueItem[] = [];\n    protected requestQueueTimeout: number | null = null;\n\n    /**\n     * Create a site.\n     *\n     * @param siteUrl Site URL.\n     * @param token Site's WS token.\n     * @param otherData Other data.\n     */\n    constructor(\n        siteUrl: string,\n        token: string,\n        otherData: CoreAuthenticatedSiteOptionalData = {},\n    ) {\n        super(siteUrl, otherData.publicConfig);\n\n        this.logger = CoreLogger.getInstance('CoreAuthenticaedSite');\n        this.token = token;\n        this.privateToken = otherData.privateToken;\n    }\n\n    /**\n     * Get site token.\n     *\n     * @returns Site token.\n     */\n    getToken(): string {\n        return this.token;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getInfo(): CoreSiteInfo | undefined {\n        return this.infos;\n    }\n\n    /**\n     * Get site private token.\n     *\n     * @returns Site private token.\n     */\n    getPrivateToken(): string | undefined {\n        return this.privateToken;\n    }\n\n    /**\n     * Get site user's ID.\n     *\n     * @returns User's ID.\n     */\n    getUserId(): number {\n        if (!this.infos) {\n            // Shouldn't happen for authenticated sites.\n            throw new CoreError('Site info could not be fetched.');\n        }\n\n        return this.infos.userid;\n    }\n\n    /**\n     * Get site Course ID for frontpage course. If not declared it will return 1 as default.\n     *\n     * @returns Site Home ID.\n     */\n    getSiteHomeId(): number {\n        return this.infos?.siteid || 1;\n    }\n\n    /**\n     * Set site token.\n     *\n     * @param token New token.\n     */\n    setToken(token: string): void {\n        this.token = token;\n    }\n\n    /**\n     * Set site private token.\n     *\n     * @param privateToken New private token.\n     */\n    setPrivateToken(privateToken: string): void {\n        this.privateToken = privateToken;\n    }\n\n    /**\n     * Check if user logged out from the site and needs to authenticate again.\n     *\n     * @returns Whether is logged out.\n     */\n    isLoggedOut(): boolean {\n        return false;\n    }\n\n    /**\n     * Set site info.\n     *\n     * @param infos New info.\n     */\n    setInfo(infos?: CoreSiteInfo): void {\n        this.infos = infos;\n\n        // Index function by name to speed up wsAvailable method.\n        if (infos?.functions) {\n            infos.functionsByName = CoreUtils.arrayToObject(infos.functions, 'name');\n        }\n    }\n\n    /**\n     * Check if current user is Admin.\n     * Works properly since v3.8. See more in: {@link https://tracker.moodle.org/browse/MDL-65550}\n     *\n     * @returns Whether the user is Admin.\n     */\n    isAdmin(): boolean {\n        return this.getInfo()?.userissiteadmin ?? false;\n    }\n\n    /**\n     * Can the user access their private files?\n     *\n     * @returns Whether can access my files.\n     */\n    canAccessMyFiles(): boolean {\n        const info = this.getInfo();\n\n        return !!(info && (info.usercanmanageownfiles === undefined || info.usercanmanageownfiles));\n    }\n\n    /**\n     * Can the user download files?\n     *\n     * @returns Whether can download files.\n     */\n    canDownloadFiles(): boolean {\n        const info = this.getInfo();\n\n        return !!info?.downloadfiles && info?.downloadfiles > 0;\n    }\n\n    /**\n     * Can the user use an advanced feature?\n     *\n     * @param featureName The name of the feature.\n     * @param whenUndefined The value to return when the parameter is undefined.\n     * @returns Whether can use advanced feature.\n     */\n    canUseAdvancedFeature(featureName: string, whenUndefined: boolean = true): boolean {\n        const info = this.getInfo();\n\n        if (info?.advancedfeatures === undefined) {\n            return whenUndefined;\n        }\n\n        const feature = info.advancedfeatures.find((item) => item.name === featureName);\n\n        if (!feature) {\n            return whenUndefined;\n        }\n\n        return feature.value !== 0;\n    }\n\n    /**\n     * Can the user upload files?\n     *\n     * @returns Whether can upload files.\n     */\n    canUploadFiles(): boolean {\n        const info = this.getInfo();\n\n        return !!info?.uploadfiles && info?.uploadfiles > 0;\n    }\n\n    /**\n     * Fetch site info from the Moodle site.\n     *\n     * @returns A promise to be resolved when the site info is retrieved.\n     */\n    fetchSiteInfo(): Promise<CoreSiteInfoResponse> {\n        // The get_site_info WS call won't be cached.\n        const preSets = {\n            getFromCache: false,\n            saveToCache: false,\n            skipQueue: true,\n        };\n\n        // Reset clean Unicode to check if it's supported again.\n        this.cleanUnicode = false;\n\n        return this.read('core_webservice_get_site_info', {}, preSets);\n    }\n\n    /**\n     * Read some data from the Moodle site using WS. Requests are cached by default.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    read<T = unknown>(method: string, data: any, preSets?: CoreSiteWSPreSets): Promise<T> {\n        return firstValueFrom(this.readObservable<T>(method, data, preSets));\n    }\n\n    /**\n     * Read some data from the Moodle site using WS. Requests are cached by default.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @returns Observable returning the WS data.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    readObservable<T = unknown>(method: string, data: any, preSets?: CoreSiteWSPreSets): WSObservable<T> {\n        preSets = preSets || {};\n        preSets.getFromCache = preSets.getFromCache ?? true;\n        preSets.saveToCache = preSets.saveToCache ?? true;\n        preSets.reusePending = preSets.reusePending ?? true;\n\n        return this.requestObservable<T>(method, data, preSets);\n    }\n\n    /**\n     * Sends some data to the Moodle site using WS. Requests are NOT cached by default.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    write<T = unknown>(method: string, data: any, preSets?: CoreSiteWSPreSets): Promise<T> {\n        return firstValueFrom(this.writeObservable<T>(method, data, preSets));\n    }\n\n    /**\n     * Sends some data to the Moodle site using WS. Requests are NOT cached by default.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @returns Observable returning the WS data.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    writeObservable<T = unknown>(method: string, data: any, preSets?: CoreSiteWSPreSets): WSObservable<T> {\n        preSets = preSets || {};\n        preSets.getFromCache = preSets.getFromCache ?? false;\n        preSets.saveToCache = preSets.saveToCache ?? false;\n        preSets.emergencyCache = preSets.emergencyCache ?? false;\n\n        return this.requestObservable<T>(method, data, preSets);\n    }\n\n    /**\n     * WS request to the site.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options.\n     * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request<T = unknown>(method: string, data: any, preSets: CoreSiteWSPreSets): Promise<T> {\n        return firstValueFrom(this.requestObservable<T>(method, data, preSets));\n    }\n\n    /**\n     * WS request to the site.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options.\n     * @returns Observable returning the WS data.\n     * @description\n     *\n     * Sends a webservice request to the site. This method will automatically add the\n     * required parameters and pass it on to the low level API in CoreWSProvider.call().\n     *\n     * Caching is also implemented, when enabled this method will returned a cached version of the request if the\n     * data hasn't expired.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    requestObservable<T = unknown>(method: string, data: any, preSets: CoreSiteWSPreSets): WSObservable<T> {\n        if (this.isLoggedOut() && !CoreAuthenticatedSite.ALLOWED_LOGGEDOUT_WS.includes(method)) {\n            // Site is logged out, it cannot call WebServices.\n            this.triggerSiteEvent(CoreEvents.SESSION_EXPIRED, {});\n\n            // Use a silent error, the SESSION_EXPIRED event will display a message if needed.\n            throw new CoreSilentError(Translate.instant('core.lostconnection'));\n        }\n\n        data = data || {};\n\n        if (!CoreNetwork.isOnline() && this.offlineDisabled) {\n            throw new CoreError(Translate.instant('core.errorofflinedisabled'));\n        }\n\n        // Check if the method is available.\n        // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.\n        if (this.getInfo() && !this.wsAvailable(method)) {\n            this.logger.error(`WS function '${method}' is not available.`);\n\n            throw new CoreError(Translate.instant('core.wsfunctionnotavailable'));\n        }\n\n        const wsPreSets: CoreWSPreSets = {\n            wsToken: this.token || '',\n            siteUrl: this.siteUrl,\n            cleanUnicode: this.cleanUnicode,\n            typeExpected: preSets.typeExpected,\n            responseExpected: preSets.responseExpected,\n            splitRequest: preSets.splitRequest,\n        };\n\n        if (wsPreSets.cleanUnicode && CoreTextUtils.hasUnicodeData(data)) {\n            // Data will be cleaned, notify the user.\n            CoreDomUtils.showToast('core.unicodenotsupported', true, ToastDuration.LONG);\n        } else {\n            // No need to clean data in this call.\n            wsPreSets.cleanUnicode = false;\n        }\n\n        if (this.offlineDisabled) {\n            // Offline is disabled, don't use cache.\n            preSets.getFromCache = false;\n            preSets.saveToCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        // Enable text filtering by default.\n        data.moodlewssettingfilter = preSets.filter === false ? false : true;\n        data.moodlewssettingfileurl = preSets.rewriteurls === false ? false : true;\n\n        // Convert arguments to strings before starting the cache process.\n        data = CoreWS.convertValuesToString(data, wsPreSets.cleanUnicode);\n        if (data == null) {\n            // Empty cleaned text found.\n            throw new CoreError(Translate.instant('core.unicodenotsupportedcleanerror'));\n        }\n\n        const cacheId = this.getCacheId(method, data);\n\n        // Check for an ongoing identical request.\n        const ongoingRequest = this.getOngoingRequest<T>(cacheId, preSets);\n        if (ongoingRequest) {\n            return ongoingRequest;\n        }\n\n        const observable = this.performRequest<T>(method, data, preSets, wsPreSets).pipe(\n            // Return a clone of the original object, this may prevent errors if in the callback the object is modified.\n            map((data) => CoreUtils.clone(data)),\n        );\n\n        this.setOngoingRequest(cacheId, preSets, observable);\n\n        return observable.pipe(\n            finalize(() => {\n                this.clearOngoingRequest(cacheId, preSets, observable);\n            }),\n        );\n    }\n\n    /**\n     * Get an ongoing request if there's one already.\n     *\n     * @param cacheId Cache ID.\n     * @param preSets Presets.\n     * @returns Ongoing request if it exists.\n     */\n    protected getOngoingRequest<T = unknown>(cacheId: string, preSets: CoreSiteWSPreSets): WSObservable<T> | undefined {\n        if (preSets.updateInBackground) {\n            return this.ongoingRequests[cacheId]?.[OngoingRequestType.UPDATE_IN_BACKGROUND];\n        } else if (preSets.getFromCache) { // Only reuse ongoing request when using cache.\n            return this.ongoingRequests[cacheId]?.[OngoingRequestType.STANDARD];\n        }\n    }\n\n    /**\n     * Store an ongoing request in memory.\n     *\n     * @param cacheId Cache ID.\n     * @param preSets Presets.\n     * @param request Request to store.\n     */\n    protected setOngoingRequest<T = unknown>(cacheId: string, preSets: CoreSiteWSPreSets, request: WSObservable<T>): void {\n        this.ongoingRequests[cacheId] = this.ongoingRequests[cacheId] ?? {};\n\n        if (preSets.updateInBackground) {\n            this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND] = request;\n        } else {\n            this.ongoingRequests[cacheId][OngoingRequestType.STANDARD] = request;\n        }\n    }\n\n    /**\n     * Clear the ongoing request unless it has changed (e.g. a new request that ignores cache).\n     *\n     * @param cacheId Cache ID.\n     * @param preSets Presets.\n     * @param request Current request.\n     */\n    protected clearOngoingRequest<T = unknown>(cacheId: string, preSets: CoreSiteWSPreSets, request: WSObservable<T>): void {\n        this.ongoingRequests[cacheId] = this.ongoingRequests[cacheId] ?? {};\n\n        if (preSets.updateInBackground) {\n            if (this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND] === request) {\n                delete this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND];\n            }\n        } else {\n            if (this.ongoingRequests[cacheId][OngoingRequestType.STANDARD] === request) {\n                delete this.ongoingRequests[cacheId][OngoingRequestType.STANDARD];\n            }\n        }\n    }\n\n    /**\n     * Perform a request, getting the response either from cache or WebService.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options related to the site.\n     * @param wsPreSets Extra options related to the WS call.\n     * @returns Observable returning the WS data.\n     */\n    protected performRequest<T = unknown>(\n        method: string,\n        data: unknown,\n        preSets: CoreSiteWSPreSets,\n        wsPreSets: CoreWSPreSets,\n    ): WSObservable<T> {\n        const subject = new Subject<T>();\n\n        const run = async () => {\n            try {\n                let response: T | WSCachedError;\n                let cachedData: WSCachedData<T> | undefined;\n\n                try {\n                    cachedData = await this.getFromCache<T>(method, data, preSets, false);\n                    response = cachedData.response;\n                } catch {\n                    // Not found or expired, call WS.\n                    response = await this.getFromWS<T>(method, data, preSets, wsPreSets);\n                }\n\n                if (\n                    typeof response === 'object' && response !== null &&\n                    (\n                        ('exception' in response && response.exception !== undefined) ||\n                        ('errorcode' in response && response.errorcode !== undefined)\n                    )\n                ) {\n                    subject.error(new CoreWSError(response));\n                } else {\n                    subject.next(<T> response);\n                }\n\n                if (\n                    preSets.updateInBackground &&\n                    !CoreConstants.CONFIG.disableCallWSInBackground &&\n                    cachedData &&\n                    !cachedData.expirationIgnored &&\n                    cachedData.expirationTime !== undefined &&\n                    Date.now() > cachedData.expirationTime\n                ) {\n                    // Update the data in background.\n                    setTimeout(async () => {\n                        try {\n                            preSets = {\n                                ...preSets,\n                                emergencyCache: false,\n                            };\n\n                            const newData = await this.getFromWS<T>(method, data, preSets, wsPreSets);\n\n                            subject.next(newData);\n                        } catch (error) {\n                            // Ignore errors when updating in background.\n                            this.logger.error('Error updating WS data in background', error);\n                        } finally {\n                            subject.complete();\n                        }\n                    });\n                } else {\n                    // No need to update in background, complete the observable.\n                    subject.complete();\n                }\n            } catch (error) {\n                subject.error(error);\n            }\n        };\n\n        run();\n\n        return subject;\n    }\n\n    /**\n     * Get a request response from WS, if it fails it might try to get it from emergency cache.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options related to the site.\n     * @param wsPreSets Extra options related to the WS call.\n     * @returns Promise resolved with the response.\n     */\n    protected async getFromWS<T = unknown>(\n        method: string,\n        data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        preSets: CoreSiteWSPreSets,\n        wsPreSets: CoreWSPreSets,\n    ): Promise<T> {\n        if (preSets.forceOffline) {\n            // Don't call the WS, just fail.\n            throw new CoreError(Translate.instant('core.cannotconnect'));\n        }\n\n        try {\n            const response = await this.callOrEnqueueWS<T>(method, data, preSets, wsPreSets);\n\n            if (preSets.saveToCache) {\n                this.saveToCache(method, data, response, preSets);\n            }\n\n            return response;\n        } catch (error) {\n            let useSilentError = false;\n\n            if (CoreUtils.isExpiredTokenError(error)) {\n                // Session expired, trigger event.\n                this.triggerSiteEvent(CoreEvents.SESSION_EXPIRED, {});\n                // Change error message. Try to get data from cache, the event will handle the error.\n                error.message = Translate.instant('core.lostconnection');\n                useSilentError = true; // Use a silent error, the SESSION_EXPIRED event will display a message if needed.\n            } else if (error.errorcode === 'userdeleted' || error.errorcode === 'wsaccessuserdeleted') {\n                // User deleted, trigger event.\n                this.triggerSiteEvent(CoreEvents.USER_DELETED, { params: data });\n                error.message = Translate.instant('core.userdeleted');\n\n                throw new CoreWSError(error);\n            } else if (error.errorcode === 'wsaccessusersuspended') {\n                // User suspended, trigger event.\n                this.triggerSiteEvent(CoreEvents.USER_SUSPENDED, { params: data });\n                error.message = Translate.instant('core.usersuspended');\n\n                throw new CoreWSError(error);\n            } else if (error.errorcode === 'wsaccessusernologin') {\n                // User suspended, trigger event.\n                this.triggerSiteEvent(CoreEvents.USER_NO_LOGIN, { params: data });\n                error.message = Translate.instant('core.usernologin');\n\n                throw new CoreWSError(error);\n            } else if (error.errorcode === 'forcepasswordchangenotice') {\n                // Password Change Forced, trigger event. Try to get data from cache, the event will handle the error.\n                this.triggerSiteEvent(CoreEvents.PASSWORD_CHANGE_FORCED, {});\n                error.message = Translate.instant('core.forcepasswordchangenotice');\n                useSilentError = true; // Use a silent error, the change password page already displays the appropiate info.\n            } else if (error.errorcode === 'usernotfullysetup') {\n                // User not fully setup, trigger event. Try to get data from cache, the event will handle the error.\n                this.triggerSiteEvent(CoreEvents.USER_NOT_FULLY_SETUP, {});\n                error.message = Translate.instant('core.usernotfullysetup');\n                useSilentError = true; // Use a silent error, the complete profile page already displays the appropiate info.\n            } else if (error.errorcode === 'sitepolicynotagreed') {\n                // Site policy not agreed, trigger event.\n                this.triggerSiteEvent(CoreEvents.SITE_POLICY_NOT_AGREED, {});\n                error.message = Translate.instant('core.login.sitepolicynotagreederror');\n\n                throw new CoreWSError(error);\n            } else if (error.errorcode === 'dmlwriteexception' && CoreTextUtils.hasUnicodeData(data)) {\n                if (!this.cleanUnicode) {\n                    // Try again cleaning unicode.\n                    this.cleanUnicode = true;\n\n                    return this.request<T>(method, data, preSets);\n                }\n                // This should not happen.\n                error.message = Translate.instant('core.unicodenotsupported');\n\n                throw new CoreWSError(error);\n            } else if (error.exception === 'required_capability_exception' || error.errorcode === 'nopermission' ||\n                    error.errorcode === 'notingroup') {\n                // Translate error messages with missing strings.\n                if (error.message === 'error/nopermission') {\n                    error.message = Translate.instant('core.nopermissionerror');\n                } else if (error.message === 'error/notingroup') {\n                    error.message = Translate.instant('core.notingroup');\n                }\n\n                if (preSets.saveToCache) {\n                    // Save the error instead of deleting the cache entry so the same content is displayed in offline.\n                    this.saveToCache(method, data, error, preSets);\n                }\n\n                throw new CoreWSError(error);\n            } else if (preSets.cacheErrors && preSets.cacheErrors.indexOf(error.errorcode) != -1) {\n                // Save the error instead of deleting the cache entry so the same content is displayed in offline.\n                this.saveToCache(method, data, error, preSets);\n\n                throw new CoreWSError(error);\n            } else if (preSets.emergencyCache === false) {\n                this.logger.debug(`WS call '${method}' failed. Emergency cache is forbidden, rejecting.`);\n\n                throw new CoreWSError(error);\n            }\n\n            if (preSets.deleteCacheIfWSError && CoreUtils.isWebServiceError(error)) {\n                // Delete the cache entry and return the entry. Don't block the user with the delete.\n                CoreUtils.ignoreErrors(this.deleteFromCache(method, data, preSets));\n\n                throw new CoreWSError(error);\n            }\n\n            this.logger.debug(`WS call '${method}' failed. Trying to use the emergency cache.`);\n            preSets = {\n                ...preSets,\n                omitExpires: true,\n                getFromCache: true,\n            };\n\n            try {\n                const cachedData = await this.getFromCache<T>(method, data, preSets, true);\n\n                if (\n                    typeof cachedData.response === 'object' && cachedData.response !== null &&\n                    (\n                        ('exception' in cachedData.response && cachedData.response.exception !== undefined) ||\n                        ('errorcode' in cachedData.response && cachedData.response.errorcode !== undefined)\n                    )\n                ) {\n                    throw new CoreWSError(cachedData.response);\n                }\n\n                return <T> cachedData.response;\n            } catch {\n                if (useSilentError) {\n                    throw new CoreSilentError(error.message);\n                }\n\n                throw new CoreWSError(error);\n            }\n        }\n    }\n\n    /**\n     * Get a request response from WS.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options related to the site.\n     * @param wsPreSets Extra options related to the WS call.\n     * @returns Promise resolved with the response.\n     */\n    protected async callOrEnqueueWS<T = unknown>(\n        method: string,\n        data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        preSets: CoreSiteWSPreSets,\n        wsPreSets: CoreWSPreSets,\n    ): Promise<T> {\n        // Call the WS.\n        const initialToken = this.token ?? '';\n\n        // Send the language to use. Do it after checking cache to prevent losing offline data when changing language.\n        // Moodle uses underscore instead of dash.\n        data = {\n            ...data,\n            moodlewssettinglang: CoreLang.formatLanguage(preSets.lang ?? await CoreLang.getCurrentLanguage(), CoreLangFormat.LMS),\n        };\n\n        try {\n            return await this.callOrEnqueueRequest<T>(method, data, preSets, wsPreSets);\n        } catch (error) {\n            if (CoreUtils.isExpiredTokenError(error)) {\n                if (initialToken !== this.token) {\n                    // Token has changed, retry with the new token.\n                    wsPreSets.wsToken = this.token ?? '';\n\n                    return await this.callOrEnqueueRequest<T>(method, data, preSets, wsPreSets);\n                } else if (CoreApp.isSSOAuthenticationOngoing()) {\n                    // There's an SSO authentication ongoing, wait for it to finish and try again.\n                    await CoreApp.waitForSSOAuthentication();\n\n                    return await this.callOrEnqueueRequest<T>(method, data, preSets, wsPreSets);\n                }\n            }\n\n            if (error?.errorcode === 'invalidparameter' && method === 'core_webservice_get_site_info') {\n                // Retry without passing the lang, this parameter isn't supported in 3.4 or older sites\n                // and we need this WS call to be able to determine if the site is supported or not.\n                delete data.moodlewssettinglang;\n\n                return await this.callOrEnqueueRequest<T>(method, data, preSets, wsPreSets);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Adds a request to the queue or calls it immediately when not using the queue.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options related to the site.\n     * @param wsPreSets Extra options related to the WS call.\n     * @returns Promise resolved with the response when the WS is called.\n     */\n    protected callOrEnqueueRequest<T = unknown>(\n        method: string,\n        data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        preSets: CoreSiteWSPreSets,\n        wsPreSets: CoreWSPreSets,\n    ): Promise<T> {\n        if (preSets.skipQueue || !this.wsAvailable('tool_mobile_call_external_functions')) {\n            return CoreWS.call<T>(method, data, wsPreSets);\n        }\n\n        const cacheId = this.getCacheId(method, data);\n\n        // Check if there is an identical request waiting in the queue (read requests only by default).\n        if (preSets.reusePending) {\n            const request = this.requestQueue.find((request) => request.cacheId == cacheId);\n            if (request) {\n                return request.deferred;\n            }\n        }\n\n        const request: RequestQueueItem<T> = {\n            cacheId,\n            method,\n            data,\n            preSets,\n            wsPreSets,\n            deferred: new CorePromisedValue(),\n        };\n\n        return this.enqueueRequest(request);\n    }\n\n    /**\n     * Adds a request to the queue.\n     *\n     * @param request The request to enqueue.\n     * @returns Promise resolved with the response when the WS is called.\n     */\n    protected enqueueRequest<T>(request: RequestQueueItem<T>): Promise<T> {\n        this.requestQueue.push(request);\n\n        if (this.requestQueue.length >= CoreConstants.CONFIG.wsrequestqueuelimit) {\n            this.processRequestQueue();\n        } else if (!this.requestQueueTimeout) {\n            this.requestQueueTimeout = window.setTimeout(\n                () => this.processRequestQueue(),\n                CoreConstants.CONFIG.wsrequestqueuedelay,\n            );\n        }\n\n        return request.deferred;\n    }\n\n    /**\n     * Call the enqueued web service requests.\n     */\n    protected async processRequestQueue(): Promise<void> {\n        this.logger.debug(`Processing request queue (${this.requestQueue.length} requests)`);\n\n        // Clear timeout if set.\n        if (this.requestQueueTimeout) {\n            clearTimeout(this.requestQueueTimeout);\n            this.requestQueueTimeout = null;\n        }\n\n        // Extract all requests from the queue.\n        const requests = this.requestQueue;\n        this.requestQueue = [];\n\n        if (requests.length == 1 && !CoreAuthenticatedSite.REQUEST_QUEUE_FORCE_WS) {\n            // Only one request, do a regular web service call.\n            try {\n                const data = await CoreWS.call(requests[0].method, requests[0].data, requests[0].wsPreSets);\n\n                requests[0].deferred.resolve(data);\n            } catch (error) {\n                requests[0].deferred.reject(error);\n            }\n\n            return;\n        }\n\n        let lang: string | undefined;\n        const requestsData: Record<string, unknown> = {\n            requests: requests.map((request) => {\n                const args = {};\n                const settings = {};\n\n                // Separate WS settings from function arguments.\n                Object.keys(request.data).forEach((key) => {\n                    let value = request.data[key];\n                    const match = /^moodlews(setting.*)$/.exec(key);\n                    if (match) {\n                        if (match[1] == 'settingfilter' || match[1] == 'settingfileurl') {\n                            // Undo special treatment of these settings in CoreWSProvider.convertValuesToString.\n                            value = (value == 'true' ? '1' : '0');\n                        } else if (match[1] == 'settinglang') {\n                            // Use the lang globally to avoid exceptions with languages not installed.\n                            lang = value;\n\n                            return;\n                        }\n                        settings[match[1]] = value;\n                    } else {\n                        args[key] = value;\n                    }\n                });\n\n                return {\n                    function: request.method,\n                    arguments: JSON.stringify(args),\n                    ...settings,\n                };\n            }),\n        };\n        requestsData.moodlewssettinglang = lang;\n\n        const wsPresets: CoreWSPreSets = {\n            siteUrl: this.siteUrl,\n            wsToken: this.token || '',\n        };\n\n        try {\n            const data = await CoreWS.call<CoreSiteCallExternalFunctionsResult>(\n                'tool_mobile_call_external_functions',\n                requestsData,\n                wsPresets,\n            );\n\n            if (!data || !data.responses) {\n                throw new CoreSiteError({\n                    supportConfig: new CoreUserAuthenticatedSupportConfig(this),\n                    message: Translate.instant('core.siteunavailablehelp', { site: this.siteUrl }),\n                    errorcode: 'invalidresponse',\n                    errorDetails: Translate.instant('core.errorinvalidresponse', { method: 'tool_mobile_call_external_functions' }),\n                });\n            }\n\n            requests.forEach((request, i) => {\n                const response = data.responses[i];\n\n                if (!response) {\n                    // Request not executed, enqueue again.\n                    this.enqueueRequest(request);\n                } else if (response.error) {\n                    const rejectReason = CoreTextUtils.parseJSON(response.exception || '') as Error | undefined;\n                    request.deferred.reject(rejectReason);\n                    CoreErrorLogs.addErrorLog({\n                        method: request.method,\n                        type: 'CoreSiteError',\n                        message: response.exception ?? '',\n                        time: new Date().getTime(),\n                        data: request.data,\n                    });\n                } else {\n                    let responseData = response.data ? CoreTextUtils.parseJSON(response.data) : {};\n                    // Match the behaviour of CoreWSProvider.call when no response is expected.\n                    const responseExpected = wsPresets.responseExpected === undefined || wsPresets.responseExpected;\n                    if (!responseExpected && (responseData == null || responseData === '')) {\n                        responseData = {};\n                    }\n                    request.deferred.resolve(responseData);\n                }\n            });\n        } catch (error) {\n            // Error not specific to a single request, reject all promises.\n            requests.forEach((request) => {\n                CoreErrorLogs.addErrorLog({\n                    method: request.method,\n                    type: 'CoreSiteError',\n                    message: String(error) ?? '',\n                    time: new Date().getTime(),\n                    data: request.data,\n                });\n                request.deferred.reject(error);\n            });\n        }\n    }\n\n    /**\n     * Check if a WS is available in this site.\n     *\n     * @param method WS name.\n     * @returns Whether the WS is available.\n     */\n    wsAvailable(method: string): boolean {\n        return !!this.infos?.functionsByName?.[method];\n    }\n\n    /**\n     * Get cache ID.\n     *\n     * @param method The WebService method.\n     * @param data Arguments to pass to the method.\n     * @returns Cache ID.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected getCacheId(method: string, data: any): string {\n        return <string> Md5.hashAsciiStr(method + ':' + CoreUtils.sortAndStringify(data));\n    }\n\n    /**\n     * Get a WS response from cache.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options.\n     * @param emergency Whether it's an \"emergency\" cache call (WS call failed).\n     * @returns Cached data.\n     */\n    protected async getFromCache<T = unknown>(\n        method: string,\n        data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        preSets: CoreSiteWSPreSets,\n        emergency?: boolean,\n    ): Promise<WSCachedData<T>> {\n        if (!preSets.getFromCache) {\n            throw new CoreError('Get from cache is disabled.');\n        }\n\n        const id = this.getCacheId(method, data);\n        let entry: CoreSiteWSCacheRecord | undefined;\n\n        if (preSets.getCacheUsingCacheKey || (emergency && preSets.getEmergencyCacheUsingCacheKey)) {\n            const entries = await this.getCacheEntriesByKey(preSets.cacheKey ?? '');\n\n            if (!entries.length) {\n                // Cache key not found, get by params sent.\n                entry = await this.getCacheEntryById(id);\n            } else {\n                if (entries.length > 1) {\n                    // More than one entry found. Search the one with same ID as this call.\n                    entry = entries.find((entry) => entry.id == id);\n                }\n\n                if (!entry) {\n                    entry = entries[0];\n                }\n            }\n        } else {\n            entry = await this.getCacheEntryById(id);\n        }\n\n        if (entry === undefined) {\n            throw new CoreError('Cache entry not valid.');\n        }\n\n        const now = Date.now();\n        let expirationTime: number | undefined;\n\n        const forceCache = preSets.omitExpires || preSets.forceOffline || !CoreNetwork.isOnline();\n\n        if (!forceCache) {\n            expirationTime = entry.expirationTime + this.getExpirationDelay(preSets.updateFrequency);\n\n            if (preSets.updateInBackground && !CoreConstants.CONFIG.disableCallWSInBackground) {\n                // Use a extended expiration time.\n                const extendedTime = entry.expirationTime +\n                    (CoreConstants.CONFIG.callWSInBackgroundExpirationTime ?? CoreConstants.SECONDS_WEEK * 1000);\n\n                if (now > extendedTime) {\n                    this.logger.debug('Cached element found, but it is expired even for call WS in background.');\n\n                    throw new CoreError('Cache entry is expired.');\n                }\n            } else if (now > expirationTime) {\n                this.logger.debug('Cached element found, but it is expired');\n\n                throw new CoreError('Cache entry is expired.');\n            }\n        }\n\n        if (entry.data !== undefined) {\n            if (!expirationTime) {\n                this.logger.info(`Cached element found, id: ${id}. Expiration time ignored.`);\n            } else {\n                const expires = (expirationTime - now) / 1000;\n                this.logger.info(`Cached element found, id: ${id}. Expires in expires in ${expires} seconds`);\n            }\n\n            return {\n                response: <T> CoreTextUtils.parseJSON(entry.data, {}),\n                expirationIgnored: forceCache,\n                expirationTime,\n            };\n        }\n\n        throw new CoreError('Cache entry not valid.');\n    }\n\n    /**\n     * Get cache entry by ID.\n     *\n     * @param id Cache ID.\n     * @returns Cache entry.\n     */\n    protected async getCacheEntryById(id: string): Promise<CoreSiteWSCacheRecord> {\n        if (!this.memoryCache[id]) {\n            throw new CoreError('Cache entry not found.');\n        }\n\n        return this.memoryCache[id];\n    }\n\n    /**\n     * Get cache entries by key.\n     *\n     * @param key Cache key.\n     * @returns Cache entries.\n     */\n    protected async getCacheEntriesByKey(key: string): Promise<CoreSiteWSCacheRecord[]> {\n        return Object.values(this.memoryCache).filter(entry => entry.key === key);\n    }\n\n    /**\n     * Save a WS response to cache.\n     *\n     * @param method The WebService method.\n     * @param data Arguments to pass to the method.\n     * @param response The WS response.\n     * @param preSets Extra options.\n     * @returns Promise resolved when the response is saved.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected async saveToCache(method: string, data: any, response: any, preSets: CoreSiteWSPreSets): Promise<void> {\n        if (preSets.uniqueCacheKey) {\n            // Cache key must be unique, delete all entries with same cache key.\n            await CoreUtils.ignoreErrors(this.deleteFromCache(method, data, preSets, true));\n        }\n\n        // Since 3.7, the expiration time contains the time the entry is modified instead of the expiration time.\n        // We decided to reuse this field to prevent modifying the database table.\n        const id = this.getCacheId(method, data);\n        const entry: CoreSiteWSCacheRecord = {\n            id,\n            data: JSON.stringify(response),\n            expirationTime: Date.now(),\n        };\n\n        if (preSets.cacheKey) {\n            entry.key = preSets.cacheKey;\n        }\n\n        if (preSets.component) {\n            entry.component = preSets.component;\n            if (preSets.componentId) {\n                entry.componentId = preSets.componentId;\n            }\n        }\n\n        await this.storeCacheEntry(entry);\n    }\n\n    /**\n     * Store a cache entry.\n     *\n     * @param entry Entry to store.\n     */\n    protected async storeCacheEntry(entry: CoreSiteWSCacheRecord): Promise<void> {\n        this.memoryCache[entry.id] = entry;\n    }\n\n    /**\n     * Delete a WS cache entry or entries.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options.\n     * @param allCacheKey True to delete all entries with the cache key, false to delete only by ID.\n     * @returns Promise resolved when the entries are deleted.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected async deleteFromCache(method: string, data: any, preSets: CoreSiteWSPreSets, allCacheKey?: boolean): Promise<void> {\n        if (allCacheKey) {\n            const entriesToDelete = await this.getCacheEntriesByKey(preSets.cacheKey ?? '');\n\n            entriesToDelete.forEach(entry => {\n                delete this.memoryCache[entry.id];\n            });\n        } else {\n            delete this.memoryCache[this.getCacheId(method, data)];\n        }\n    }\n\n    /**\n     * Invalidates all the cache entries.\n     *\n     * @returns Promise resolved when the cache entries are invalidated.\n     */\n    async invalidateWsCache(): Promise<void> {\n        try {\n            for (const id in this.memoryCache) {\n                this.memoryCache[id].expirationTime = 0;\n            }\n        } finally {\n            this.triggerSiteEvent(CoreEvents.WS_CACHE_INVALIDATED, {});\n        }\n    }\n\n    /**\n     * Invalidates all the cache entries with a certain key.\n     *\n     * @param key Key to search.\n     * @returns Promise resolved when the cache entries are invalidated.\n     */\n    async invalidateWsCacheForKey(key: string): Promise<void> {\n        if (!key) {\n            return;\n        }\n\n        this.logger.debug('Invalidate cache for key: ' + key);\n\n        const entries = await this.getCacheEntriesByKey(key);\n        entries.forEach(entry => {\n            entry.expirationTime = 0;\n        });\n    }\n\n    /**\n     * Invalidates all the cache entries in an array of keys.\n     *\n     * @param keys Keys to search.\n     * @returns Promise resolved when the cache entries are invalidated.\n     */\n    async invalidateMultipleWsCacheForKey(keys: string[]): Promise<void> {\n        if (!keys || !keys.length) {\n            return;\n        }\n\n        this.logger.debug('Invalidating multiple cache keys');\n        await Promise.all(keys.map((key) => this.invalidateWsCacheForKey(key)));\n    }\n\n    /**\n     * Invalidates all the cache entries whose key starts with a certain value.\n     *\n     * @param key Key to search.\n     * @returns Promise resolved when the cache entries are invalidated.\n     */\n    async invalidateWsCacheForKeyStartingWith(key: string): Promise<void> {\n        if (!key) {\n            return;\n        }\n\n        this.logger.debug('Invalidate cache for key starting with: ' + key);\n        Object.values(this.memoryCache).filter(entry => entry.key?.startsWith(key)).forEach(entry => {\n            entry.expirationTime = 0;\n        });\n    }\n\n    /**\n     * Returns the URL to the documentation of the app, based on Moodle version and current language.\n     *\n     * @param page Docs page to go to.\n     * @returns Promise resolved with the Moodle docs URL.\n     */\n    getDocsUrl(page?: string): Promise<string> {\n        const release = this.infos?.release ? this.infos.release : undefined;\n\n        return CoreUrlUtils.getDocsUrl(release, page);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getPublicConfig(options: { readingStrategy?: CoreSitesReadingStrategy } = {}): Promise<CoreSitePublicConfigResponse> {\n        const ignoreCache = CoreSitesReadingStrategy.ONLY_NETWORK || CoreSitesReadingStrategy.PREFER_NETWORK;\n        if (!ignoreCache && this.publicConfig) {\n            return this.publicConfig;\n        }\n\n        const method = 'tool_mobile_get_public_config';\n        const cacheId = this.getCacheId(method, {});\n        const cachePreSets: CoreSiteWSPreSets = {\n            getFromCache: true,\n            saveToCache: true,\n            emergencyCache: true,\n            cacheKey: this.getPublicConfigCacheKey(),\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        if (this.offlineDisabled) {\n            // Offline is disabled, don't use cache.\n            cachePreSets.getFromCache = false;\n            cachePreSets.saveToCache = false;\n            cachePreSets.emergencyCache = false;\n        }\n\n        // Check for an ongoing identical request if we're not ignoring cache.\n\n        // Check for an ongoing identical request.\n        const ongoingRequest = this.getOngoingRequest<CoreSitePublicConfigResponse>(cacheId, cachePreSets);\n        if (ongoingRequest) {\n            return firstValueFrom(ongoingRequest);\n        }\n\n        const subject = new Subject<CoreSitePublicConfigResponse>();\n        const observable = subject.pipe(\n            // Return a clone of the original object, this may prevent errors if in the callback the object is modified.\n            map((data) => CoreUtils.clone(data)),\n            finalize(() => {\n                this.clearOngoingRequest(cacheId, cachePreSets, observable);\n            }),\n        );\n\n        this.setOngoingRequest(cacheId, cachePreSets, observable);\n\n        this.getFromCache<CoreSitePublicConfigResponse>(method, {}, cachePreSets, false)\n            .then(cachedData => cachedData.response)\n            .catch(async () => {\n                if (cachePreSets.forceOffline) {\n                    // Don't call the WS, just fail.\n                    throw new CoreError(Translate.instant('core.cannotconnect'));\n                }\n\n                // Call the WS.\n                try {\n                    const config = await this.requestPublicConfig();\n\n                    if (cachePreSets.saveToCache) {\n                        this.saveToCache(method, {}, config, cachePreSets);\n                    }\n\n                    return config;\n                } catch (error) {\n                    if (cachePreSets.emergencyCache === false) {\n                        throw error;\n                    }\n\n                    cachePreSets.omitExpires = true;\n                    cachePreSets.getFromCache = true;\n\n                    try {\n                        const cachedData = await this.getFromCache<CoreSitePublicConfigResponse>(method, {}, cachePreSets, true);\n\n                        return cachedData.response;\n                    } catch {\n                        throw error;\n                    }\n                }\n            }).then((response) => {\n                // The app doesn't store exceptions for this call, it's safe to assume type CoreSitePublicConfigResponse.\n                response = <CoreSitePublicConfigResponse> response;\n\n                this.setPublicConfig(response);\n                subject.next(response);\n                subject.complete();\n\n                return;\n            }).catch((error) => {\n                subject.error(error);\n            });\n\n        return firstValueFrom(observable);\n    }\n\n    /**\n     * Get cache key for getPublicConfig WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getPublicConfigCacheKey(): string {\n        return 'tool_mobile_get_public_config';\n    }\n\n    /**\n     * Check if GET method is supported for AJAX calls.\n     *\n     * @returns Whether it's supported.\n     */\n    protected isAjaxGetSupported(): boolean {\n        return !!this.getInfo() && this.isVersionGreaterEqualThan('3.8');\n    }\n\n    /**\n     * Check if the site version is greater than one or several versions.\n     * This function accepts a string or an array of strings. If array, the last version must be the highest.\n     *\n     * @param versions Version or list of versions to check.\n     * @returns Whether it's greater or equal, false otherwise.\n     * @description\n     * If a string is supplied (e.g. '3.2.1'), it will check if the site version is greater or equal than this version.\n     *\n     * If an array of versions is supplied, it will check if the site version is greater or equal than the last version,\n     * or if it's higher or equal than any of the other releases supplied but lower than the next major release. The last\n     * version of the array must be the highest version.\n     * For example, if the values supplied are ['3.0.5', '3.2.3', '3.3.1'] the function will return true if the site version\n     * is either:\n     *     - Greater or equal than 3.3.1.\n     *     - Greater or equal than 3.2.3 but lower than 3.3.\n     *     - Greater or equal than 3.0.5 but lower than 3.1.\n     *\n     * This function only accepts versions from 2.4.0 and above. If any of the versions supplied isn't found, it will assume\n     * it's the last released major version.\n     */\n    isVersionGreaterEqualThan(versions: string | string[]): boolean {\n        const info = this.getInfo();\n\n        if (!info || !info.version) {\n            return false;\n        }\n\n        const siteVersion = Number(info.version);\n\n        if (Array.isArray(versions)) {\n            if (!versions.length) {\n                return false;\n            }\n\n            for (let i = 0; i < versions.length; i++) {\n                const versionNumber = this.getVersionNumber(versions[i]);\n                if (i == versions.length - 1) {\n                    // It's the last version, check only if site version is greater than this one.\n                    return siteVersion >= versionNumber;\n                } else {\n                    // Check if site version if bigger than this number but lesser than next major.\n                    if (siteVersion >= versionNumber && siteVersion < this.getNextMajorVersionNumber(versions[i])) {\n                        return true;\n                    }\n                }\n            }\n        } else if (typeof versions == 'string') {\n            // Compare with this version.\n            return siteVersion >= this.getVersionNumber(versions);\n        }\n\n        return false;\n    }\n\n    /**\n     * Get a version number from a release version.\n     * If release version is valid but not found in the list of Moodle releases, it will use the last released major version.\n     *\n     * @param version Release version to convert to version number.\n     * @returns Version number, 0 if invalid.\n     */\n    protected getVersionNumber(version: string): number {\n        const data = this.getMajorAndMinor(version);\n\n        if (!data) {\n            // Invalid version.\n            return 0;\n        }\n\n        if (CoreAuthenticatedSite.MOODLE_RELEASES[data.major] === undefined) {\n            // Major version not found. Use the last one.\n            const major = Object.keys(CoreAuthenticatedSite.MOODLE_RELEASES).pop();\n            if (!major) {\n                return 0;\n            }\n\n            data.major = major;\n        }\n\n        return CoreAuthenticatedSite.MOODLE_RELEASES[data.major] + data.minor;\n    }\n\n    /**\n     * Given a release version, return the major and minor versions.\n     *\n     * @param version Release version (e.g. '3.1.0').\n     * @returns Object with major and minor. Returns false if invalid version.\n     */\n    protected getMajorAndMinor(version: string): {major: string; minor: number} | false {\n        const match = version.match(/^(\\d+)(\\.(\\d+)(\\.\\d+)?)?/);\n        if (!match || !match[1]) {\n            // Invalid version.\n            return false;\n        }\n\n        return {\n            major: match[1] + '.' + (match[3] || '0'),\n            minor: parseInt(match[5], 10) || 0,\n        };\n    }\n\n    /**\n     * Given a release version, return the next major version number.\n     *\n     * @param version Release version (e.g. '3.1.0').\n     * @returns Next major version number.\n     */\n    protected getNextMajorVersionNumber(version: string): number {\n        const data = this.getMajorAndMinor(version);\n        const releases = Object.keys(CoreAuthenticatedSite.MOODLE_RELEASES);\n\n        if (!data) {\n            // Invalid version.\n            return 0;\n        }\n\n        const position = releases.indexOf(data.major);\n\n        if (position == -1 || position == releases.length - 1) {\n            // Major version not found or it's the last one. Use the last one.\n            return CoreAuthenticatedSite.MOODLE_RELEASES[releases[position]];\n        }\n\n        return CoreAuthenticatedSite.MOODLE_RELEASES[releases[position + 1]];\n    }\n\n    /**\n     * Get a certain cache expiration delay.\n     *\n     * @param updateFrequency The update frequency of the entry.\n     * @returns Expiration delay.\n     */\n    getExpirationDelay(updateFrequency?: number): number {\n        updateFrequency = updateFrequency || CoreAuthenticatedSite.FREQUENCY_USUALLY;\n        let expirationDelay = CoreAuthenticatedSite.UPDATE_FREQUENCIES[updateFrequency] ||\n        CoreAuthenticatedSite.UPDATE_FREQUENCIES[CoreAuthenticatedSite.FREQUENCY_USUALLY];\n\n        if (CoreNetwork.isNetworkAccessLimited()) {\n            // Not WiFi, increase the expiration delay a 50% to decrease the data usage in this case.\n            expirationDelay *= 1.5;\n        }\n\n        return expirationDelay;\n    }\n\n    /**\n     * Trigger an event.\n     *\n     * @param eventName Event name.\n     * @param data Event data.\n     */\n    protected triggerSiteEvent<Fallback = unknown, Event extends string = string>(\n        eventName: Event,\n        data?: CoreEventData<Event, Fallback>,\n    ): void {\n        CoreEvents.trigger(eventName, data);\n    }\n\n}\n\n/**\n * Operator to chain requests when using observables.\n *\n * @param readingStrategy Reading strategy used for the current request.\n * @param callback Callback called with the result of current request and the reading strategy to use in next requests.\n * @returns Operator.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function chainRequests<T, O extends ObservableInput<any>>(\n    readingStrategy: CoreSitesReadingStrategy | undefined,\n    callback: (data: T, readingStrategy?: CoreSitesReadingStrategy) => O,\n): OperatorFunction<T, ObservedValueOf<O>> {\n    return (source: WSObservable<T>) => new Observable<{ data: T; readingStrategy?: CoreSitesReadingStrategy }>(subscriber => {\n        let firstValue = true;\n        let isCompleted = false;\n\n        return source.subscribe({\n            next: async (value) => {\n                if (readingStrategy !== CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE) {\n                    // Just use same strategy.\n                    subscriber.next({ data: value, readingStrategy });\n\n                    return;\n                }\n\n                if (!firstValue) {\n                    // Second (last) value. Chained requests should have used cached data already, just return 1 value now.\n                    subscriber.next({\n                        data: value,\n                    });\n\n                    return;\n                }\n\n                firstValue = false;\n\n                // Wait to see if the observable is completed (no more values).\n                await CoreUtils.nextTick();\n\n                if (isCompleted) {\n                    // Current request only returns cached data. Let chained requests update in background.\n                    subscriber.next({ data: value, readingStrategy });\n                } else {\n                    // Current request will update in background. Prefer cached data in the chained requests.\n                    subscriber.next({\n                        data: value,\n                        readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n                    });\n                }\n            },\n            error: (error) => subscriber.error(error),\n            complete: async () => {\n                isCompleted = true;\n\n                await CoreUtils.nextTick();\n\n                subscriber.complete();\n            },\n        });\n    }).pipe(\n        mergeMap(({ data, readingStrategy }) => callback(data, readingStrategy)),\n    );\n}\n\n/**\n * Optional data to create an authenticated site.\n */\nexport type CoreAuthenticatedSiteOptionalData = {\n    privateToken?: string;\n    publicConfig?: CoreSitePublicConfigResponse;\n};\n\n/**\n * PreSets accepted by the WS call.\n */\nexport type CoreSiteWSPreSets = {\n    /**\n     * Get the value from the cache if it's still valid.\n     */\n    getFromCache?: boolean;\n\n    /**\n     * Save the result to the cache.\n     */\n    saveToCache?: boolean;\n\n    /**\n     * Ignore cache expiration.\n     */\n    omitExpires?: boolean;\n\n    /**\n     * Use the cache when a request fails. Defaults to true.\n     */\n    emergencyCache?: boolean;\n\n    /**\n     * If true, the app won't call the WS. If the data isn't cached, the call will fail.\n     */\n    forceOffline?: boolean;\n\n    /**\n     * Extra key to add to the cache when storing this call, to identify the entry.\n     */\n    cacheKey?: string;\n\n    /**\n     * Whether it should use cache key to retrieve the cached data instead of the request params.\n     */\n    getCacheUsingCacheKey?: boolean;\n\n    /**\n     * Same as getCacheUsingCacheKey, but for emergency cache.\n     */\n    getEmergencyCacheUsingCacheKey?: boolean;\n\n    /**\n     * If true, the cache entry will be deleted if the WS call returns an exception.\n     */\n    deleteCacheIfWSError?: boolean;\n\n    /**\n     * Whether it should only be 1 entry for this cache key (all entries with same key will be deleted).\n     */\n    uniqueCacheKey?: boolean;\n\n    /**\n     * Whether to filter WS response (moodlewssettingfilter). Defaults to true.\n     */\n    filter?: boolean;\n\n    /**\n     * Whether to rewrite URLs (moodlewssettingfileurl). Defaults to true.\n     */\n    rewriteurls?: boolean;\n\n    /**\n     * Language to send to the WebService (moodlewssettinglang). Defaults to app's language.\n     */\n    lang?: string;\n\n    /**\n     * Defaults to true. Set to false when the expected response is null.\n     */\n    responseExpected?: boolean;\n\n    /**\n     * Defaults to 'object'. Use it when you expect a type that's not an object|array.\n     */\n    typeExpected?: CoreWSTypeExpected;\n\n    /**\n     * Wehther a pending request in the queue matching the same function and arguments can be reused instead of adding\n     * a new request to the queue. Defaults to true for read requests.\n     */\n    reusePending?: boolean;\n\n    /**\n     * Whether the request will be be sent immediately as a single request. Defaults to false.\n     */\n    skipQueue?: boolean;\n\n    /**\n     * Cache the response if it returns an errorcode present in this list.\n     */\n    cacheErrors?: string[];\n\n    /**\n     * Update frequency. This value determines how often the cached data will be updated. Possible values:\n     * CoreSite.FREQUENCY_USUALLY, CoreSite.FREQUENCY_OFTEN, CoreSite.FREQUENCY_SOMETIMES, CoreSite.FREQUENCY_RARELY.\n     * Defaults to CoreSite.FREQUENCY_USUALLY.\n     */\n    updateFrequency?: number;\n\n    /**\n     * Component name. Optionally included if this request is being made on behalf of a specific\n     * component (e.g. activity).\n     */\n    component?: string;\n\n    /**\n     * Component id. Optionally included when 'component' is set.\n     */\n    componentId?: number;\n\n    /**\n     * Whether to split a request if it has too many parameters. Sending too many parameters to the site\n     * can cause the request to fail (see PHP's max_input_vars).\n     */\n    splitRequest?: CoreWSPreSetsSplitRequest;\n\n    /**\n     * If true, the app will return cached data even if it's expired and then it'll call the WS in the background.\n     * Only enabled if CoreConstants.CONFIG.disableCallWSInBackground isn't true.\n     */\n    updateInBackground?: boolean;\n};\n\n/**\n * Info of a request waiting in the queue.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RequestQueueItem<T = any> = {\n    cacheId: string;\n    method: string;\n    data: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n    preSets: CoreSiteWSPreSets;\n    wsPreSets: CoreWSPreSets;\n    deferred: CorePromisedValue<T>;\n};\n\n/**\n * Result of WS tool_mobile_call_external_functions.\n */\nexport type CoreSiteCallExternalFunctionsResult = {\n    responses: {\n        error: boolean; // Whether an exception was thrown.\n        data?: string; // JSON-encoded response data.\n        exception?: string; // JSON-encoed exception info.\n    }[];\n};\n\n/**\n * Info about cached data.\n */\ntype WSCachedData<T> = {\n    response: T | WSCachedError; // The WS response data, or an error if the WS returned an error and it was cached.\n    expirationIgnored: boolean; // Whether the expiration time was ignored.\n    expirationTime?: number; // Entry expiration time (only if not ignored).\n};\n\n/**\n * Error data stored in cache.\n */\ntype WSCachedError = {\n    exception?: string;\n    errorcode?: string;\n};\n\n/**\n * Observable returned when calling WebServices.\n * If the request uses the \"update in background\" feature, it will return 2 values: first the cached one, and then the one\n * coming from the server. After this, it will complete.\n * Otherwise, it will only return 1 value, either coming from cache or from the server. After this, it will complete.\n */\nexport type WSObservable<T> = Observable<T>;\n\n/**\n * Type of ongoing requests stored in memory to avoid duplicating them.\n */\nenum OngoingRequestType {\n    STANDARD = 0,\n    UPDATE_IN_BACKGROUND = 1,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}