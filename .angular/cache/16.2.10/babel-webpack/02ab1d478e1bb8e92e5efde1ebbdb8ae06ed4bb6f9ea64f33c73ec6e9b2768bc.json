{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModWikiOffline } from './wiki-offline';\nimport { AddonModWikiSyncProvider } from './wiki-sync';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModWiki:';\n/**\n * Service that provides some features for wikis.\n */\nexport class AddonModWikiProvider {\n  // Milliseconds.\n  constructor() {\n    this.subwikiListsCache = {};\n    this.wikiFirstViewedPage = {};\n    // Clear subwiki lists cache on logout.\n    CoreEvents.on(CoreEvents.LOGIN, () => {\n      this.clearSubwikiList();\n    });\n  }\n  /**\n   * Clear subwiki list cache for a certain wiki or all of them.\n   *\n   * @param wikiId wiki Id, if not provided all will be cleared.\n   */\n  clearSubwikiList(wikiId) {\n    if (wikiId === undefined) {\n      this.subwikiListsCache = {};\n    } else {\n      delete this.subwikiListsCache[wikiId];\n    }\n  }\n  /**\n   * Delete and return the edited page data if any.\n   *\n   * @returns Edited page data, undefined if no data.\n   */\n  consumeEditedPageData() {\n    const editedPage = this.editedPage;\n    delete this.editedPage;\n    return editedPage;\n  }\n  /**\n   * Save wiki contents on a page or section.\n   *\n   * @param pageId Page ID.\n   * @param content content to be saved.\n   * @param section section to get.\n   * @returns Promise resolved with the page ID.\n   */\n  editPage(pageId, content, section, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        pageid: pageId,\n        content: content\n      };\n      if (section) {\n        params.section = section;\n      }\n      const response = yield site.write('mod_wiki_edit_page', params);\n      return response.pageid;\n    })();\n  }\n  /**\n   * Get the first page opened for a wiki in the app if it isn't the current one.\n   *\n   * @param wikiId Wiki ID.\n   * @param path Path.\n   * @returns The first wiki page opened if any.\n   */\n  getFirstWikiPageOpened(wikiId, path) {\n    const tab = CoreNavigator.getMainMenuTabFromPath(path);\n    if (!tab) {\n      return;\n    }\n    if (this.wikiFirstViewedPage[tab] && this.wikiFirstViewedPage[tab][wikiId] !== path) {\n      return this.wikiFirstViewedPage[tab][wikiId];\n    }\n  }\n  /**\n   * Get a wiki page contents.\n   *\n   * @param pageId Page ID.\n   * @param options Other options.\n   * @returns Promise resolved with the page data.\n   */\n  getPageContents(pageId, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        pageid: pageId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this.getPageContentsCacheKey(pageId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModWikiProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_wiki_get_page_contents', params, preSets);\n      return response.page;\n    })();\n  }\n  /**\n   * Get cache key for wiki Pages Contents WS calls.\n   *\n   * @param pageId Wiki Page ID.\n   * @returns Cache key.\n   */\n  getPageContentsCacheKey(pageId) {\n    return ROOT_CACHE_KEY + 'page:' + pageId;\n  }\n  /**\n   * Get a wiki page contents for editing. It does not cache calls.\n   *\n   * @param pageId Page ID.\n   * @param section Section to get.\n   * @param lockOnly Just renew lock and not return content.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with page contents.\n   */\n  getPageForEditing(pageId, section, lockOnly, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        pageid: pageId\n      };\n      if (section) {\n        params.section = section;\n      }\n      if (lockOnly) {\n        params.lockonly = true;\n      }\n      const response = yield site.write('mod_wiki_get_page_for_editing', params);\n      return response.pagesection;\n    })();\n  }\n  /**\n   * Gets the list of files from a specific subwiki.\n   *\n   * @param wikiId Wiki ID.\n   * @param options Other options.\n   * @returns Promise resolved with subwiki files.\n   */\n  getSubwikiFiles(wikiId, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const groupId = options.groupId || -1;\n      const userId = options.userId || 0;\n      const params = {\n        wikiid: wikiId,\n        groupid: groupId,\n        userid: userId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this2.getSubwikiFilesCacheKey(wikiId, groupId, userId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModWikiProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_wiki_get_subwiki_files', params, preSets);\n      return response.files;\n    })();\n  }\n  /**\n   * Get cache key for wiki Subwiki Files WS calls.\n   *\n   * @param wikiId Wiki ID.\n   * @param groupId Group ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getSubwikiFilesCacheKey(wikiId, groupId, userId) {\n    return this.getSubwikiFilesCacheKeyPrefix(wikiId) + ':' + groupId + ':' + userId;\n  }\n  /**\n   * Get cache key for all wiki Subwiki Files WS calls.\n   *\n   * @param wikiId Wiki ID.\n   * @returns Cache key.\n   */\n  getSubwikiFilesCacheKeyPrefix(wikiId) {\n    return ROOT_CACHE_KEY + 'subwikifiles:' + wikiId;\n  }\n  /**\n   * Get a list of subwikis and related data for a certain wiki from the cache.\n   *\n   * @param wikiId wiki Id\n   * @returns Subwiki list and related data.\n   */\n  getSubwikiList(wikiId) {\n    return this.subwikiListsCache[wikiId];\n  }\n  /**\n   * Get the list of Pages of a SubWiki.\n   *\n   * @param wikiId Wiki ID.\n   * @param options Other options.\n   * @returns Promise resolved with wiki subwiki pages.\n   */\n  getSubwikiPages(wikiId, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const groupId = options.groupId || -1;\n      const userId = options.userId || 0;\n      const sortBy = options.sortBy || 'title';\n      const sortDirection = options.sortDirection || 'ASC';\n      const params = {\n        wikiid: wikiId,\n        groupid: groupId,\n        userid: userId,\n        options: {\n          sortby: sortBy,\n          sortdirection: sortDirection,\n          includecontent: options.includeContent ? 1 : 0\n        }\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this3.getSubwikiPagesCacheKey(wikiId, groupId, userId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModWikiProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_wiki_get_subwiki_pages', params, preSets);\n      return response.pages;\n    })();\n  }\n  /**\n   * Get cache key for wiki Subwiki Pages WS calls.\n   *\n   * @param wikiId Wiki ID.\n   * @param groupId Group ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getSubwikiPagesCacheKey(wikiId, groupId, userId) {\n    return this.getSubwikiPagesCacheKeyPrefix(wikiId) + ':' + groupId + ':' + userId;\n  }\n  /**\n   * Get cache key for all wiki Subwiki Pages WS calls.\n   *\n   * @param wikiId Wiki ID.\n   * @returns Cache key.\n   */\n  getSubwikiPagesCacheKeyPrefix(wikiId) {\n    return ROOT_CACHE_KEY + 'subwikipages:' + wikiId;\n  }\n  /**\n   * Get all the subwikis of a wiki.\n   *\n   * @param wikiId Wiki ID.\n   * @param options Other options.\n   * @returns Promise resolved with subwikis.\n   */\n  getSubwikis(wikiId, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        wikiid: wikiId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this4.getSubwikisCacheKey(wikiId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModWikiProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_wiki_get_subwikis', params, preSets);\n      return response.subwikis.map(subwiki => _objectSpread(_objectSpread({}, subwiki), {}, {\n        groupid: Number(subwiki.groupid) // Convert groupid to number.\n      }));\n    })();\n  }\n  /**\n   * Get cache key for get wiki subWikis WS calls.\n   *\n   * @param wikiId Wiki ID.\n   * @returns Cache key.\n   */\n  getSubwikisCacheKey(wikiId) {\n    return ROOT_CACHE_KEY + 'subwikis:' + wikiId;\n  }\n  /**\n   * Get a wiki by module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the wiki is retrieved.\n   */\n  getWiki(courseId, cmId, options = {}) {\n    return this.getWikiByField(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a wiki with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the wiki is retrieved.\n   */\n  getWikiByField(courseId, key, value, options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this5.getWikiDataCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModWikiProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_wiki_get_wikis_by_courses', params, preSets);\n      const currentWiki = response.wikis.find(wiki => wiki[key] == value);\n      if (currentWiki) {\n        return currentWiki;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get a wiki by wiki ID.\n   *\n   * @param courseId Course ID.\n   * @param id Wiki ID.\n   * @param options Other options.\n   * @returns Promise resolved when the wiki is retrieved.\n   */\n  getWikiById(courseId, id, options = {}) {\n    return this.getWikiByField(courseId, 'id', id, options);\n  }\n  /**\n   * Get cache key for wiki data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getWikiDataCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'wiki:' + courseId;\n  }\n  /**\n   * Gets a list of files to download for a wiki, using a format similar to module.contents from get_course_contents.\n   *\n   * @param wiki Wiki.\n   * @param options Other options.\n   * @returns Promise resolved with the list of files.\n   */\n  getWikiFileList(wiki, options = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      let files = [];\n      const modOptions = _objectSpread({\n        cmId: wiki.coursemodule\n      }, options);\n      const subwikis = yield _this6.getSubwikis(wiki.id, modOptions);\n      yield Promise.all(subwikis.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (subwiki) {\n          const subwikiOptions = _objectSpread({\n            groupId: subwiki.groupid,\n            userId: subwiki.userid\n          }, modOptions);\n          const subwikiFiles = yield _this6.getSubwikiFiles(subwiki.wikiid, subwikiOptions);\n          files = files.concat(subwikiFiles);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return files;\n    })();\n  }\n  /**\n   * Gets a list of all pages for a Wiki.\n   *\n   * @param wiki Wiki.\n   * @param options Other options.\n   * @returns Page list.\n   */\n  getWikiPageList(wiki, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      let pages = [];\n      const modOptions = _objectSpread({\n        cmId: wiki.coursemodule\n      }, options);\n      const subwikis = yield _this7.getSubwikis(wiki.id, modOptions);\n      yield Promise.all(subwikis.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (subwiki) {\n          const subwikiPages = yield _this7.getSubwikiPages(subwiki.wikiid, _objectSpread({\n            groupId: subwiki.groupid,\n            userId: subwiki.userid\n          }, modOptions));\n          pages = pages.concat(subwikiPages);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      return pages;\n    })();\n  }\n  /**\n   * Invalidate the prefetched content except files.\n   * To invalidate files, use invalidateFiles.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const wiki = yield _this8.getWiki(courseId, moduleId, {\n        siteId\n      });\n      yield Promise.all([_this8.invalidateWikiData(courseId, siteId), _this8.invalidateSubwikis(wiki.id, siteId), _this8.invalidateSubwikiPages(wiki.id, siteId), _this8.invalidateSubwikiFiles(wiki.id, siteId)]);\n    })();\n  }\n  /**\n   * Invalidates page content WS call for a certain page.\n   *\n   * @param pageId Wiki Page ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidatePage(pageId, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this9.getPageContentsCacheKey(pageId));\n    })();\n  }\n  /**\n   * Invalidates all the subwiki files WS calls for a certain wiki.\n   *\n   * @param wikiId Wiki ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateSubwikiFiles(wikiId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this10.getSubwikiFilesCacheKeyPrefix(wikiId));\n    })();\n  }\n  /**\n   * Invalidates all the subwiki pages WS calls for a certain wiki.\n   *\n   * @param wikiId Wiki ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateSubwikiPages(wikiId, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this11.getSubwikiPagesCacheKeyPrefix(wikiId));\n    })();\n  }\n  /**\n   * Invalidates all the get subwikis WS calls for a certain wiki.\n   *\n   * @param wikiId Wiki ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateSubwikis(wikiId, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      _this12.clearSubwikiList(wikiId);\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this12.getSubwikisCacheKey(wikiId));\n    })();\n  }\n  /**\n   * Invalidates wiki data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateWikiData(courseId, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this13.getWikiDataCacheKey(courseId));\n    })();\n  }\n  /**\n   * Check if a page title is already used.\n   *\n   * @param wikiId Wiki ID.\n   * @param subwikiId Subwiki ID.\n   * @param title Page title.\n   * @param options Other options.\n   * @returns Promise resolved with true if used, resolved with false if not used or cannot determine.\n   */\n  isTitleUsed(wikiId, subwikiId, title, options = {}) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // First get the subwiki.\n        const subwikis = yield _this14.getSubwikis(wikiId, options);\n        // Search the subwiki.\n        const subwiki = subwikis.find(subwiki => subwiki.id == subwikiId);\n        if (!subwiki) {\n          return false;\n        }\n        // Now get all the pages of the subwiki.\n        const pages = yield _this14.getSubwikiPages(wikiId, _objectSpread({\n          groupId: subwiki.groupid,\n          userId: subwiki.userid\n        }, options));\n        // Check if there's any page with the same title.\n        const page = pages.find(page => page.title == title);\n        return !!page;\n      } catch (_unused) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Report a wiki page as being viewed.\n   *\n   * @param id Page ID.\n   * @param wikiId Wiki ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logPageView(id, wikiId, siteId) {\n    const params = {\n      pageid: id\n    };\n    return CoreCourseLogHelper.log('mod_wiki_view_page', params, AddonModWikiProvider.COMPONENT, wikiId, siteId);\n  }\n  /**\n   * Report the wiki as being viewed.\n   *\n   * @param id Wiki ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(id, siteId) {\n    const params = {\n      wikiid: id\n    };\n    return CoreCourseLogHelper.log('mod_wiki_view_wiki', params, AddonModWikiProvider.COMPONENT, id, siteId);\n  }\n  /**\n   * Create a new page on a subwiki.\n   *\n   * @param title Title to create the page.\n   * @param content Content to save on the page.\n   * @param options Other options.\n   * @returns Promise resolved with page ID if page was created in server, -1 if stored in device.\n   */\n  newPage(title, content, options = {}) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a new page to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* () {\n          if (options.wikiId && options.subwikiId) {\n            // We have wiki ID, check if there's already an online page with this title and subwiki.\n            const used = yield CoreUtils.ignoreErrors(_this15.isTitleUsed(options.wikiId, options.subwikiId, title, {\n              cmId: options.cmId,\n              readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n              siteId: options.siteId\n            }));\n            if (used) {\n              throw new CoreError(Translate.instant('addon.mod_wiki.pageexists'));\n            }\n          }\n          yield AddonModWikiOffline.saveNewPage(title, content, options.subwikiId, options.wikiId, options.userId, options.groupId, options.siteId);\n          return -1;\n        });\n        return function storeOffline() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      // Discard stored content for this page. If it exists it means the user is editing it.\n      yield AddonModWikiOffline.deleteNewPage(title, options.subwikiId, options.wikiId, options.userId, options.groupId, options.siteId);\n      try {\n        // Try to create it in online.\n        return yield _this15.newPageOnline(title, content, options);\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that the page cannot be added.\n          throw error;\n        }\n        // Couldn't connect to server, store in offline.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Create a new page on a subwiki. It will fail if offline or cannot connect.\n   *\n   * @param title Title to create the page.\n   * @param content Content to save on the page.\n   * @param options Other options.\n   * @returns Promise resolved with the page ID if created, rejected otherwise.\n   */\n  newPageOnline(title, content, options = {}) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        title: title,\n        content: content,\n        contentformat: 'html'\n      };\n      const subwikiId = AddonModWikiOffline.convertToPositiveNumber(options.subwikiId);\n      const wikiId = AddonModWikiOffline.convertToPositiveNumber(options.wikiId);\n      if (subwikiId && subwikiId > 0) {\n        params.subwikiid = subwikiId;\n      } else if (wikiId) {\n        params.wikiid = wikiId;\n        params.userid = AddonModWikiOffline.convertToPositiveNumber(options.userId);\n        params.groupid = AddonModWikiOffline.convertToPositiveNumber(options.groupId);\n      }\n      const response = yield site.write('mod_wiki_new_page', params);\n      return response.pageid;\n    })();\n  }\n  /**\n   * Set edited page data.\n   *\n   * @param data Data.\n   */\n  setEditedPageData(data) {\n    this.editedPage = data;\n  }\n  /**\n   * Save subwiki list for a wiki to the cache.\n   *\n   * @param wikiId Wiki Id.\n   * @param subwikis List of subwikis.\n   * @param count Number of subwikis in the subwikis list.\n   * @param subwikiId Subwiki Id currently selected.\n   * @param userId User Id currently selected.\n   * @param groupId Group Id currently selected.\n   */\n  setSubwikiList(wikiId, subwikis, count, subwikiId, userId, groupId) {\n    this.subwikiListsCache[wikiId] = {\n      count: count,\n      subwikiSelected: subwikiId,\n      userSelected: userId,\n      groupSelected: groupId,\n      subwikis: subwikis\n    };\n  }\n  /**\n   * Sort an array of wiki pages by title.\n   *\n   * @param pages Pages to sort.\n   * @param desc True to sort in descendent order, false to sort in ascendent order. Defaults to false.\n   * @returns Sorted pages.\n   */\n  sortPagesByTitle(pages, desc) {\n    return pages.sort((a, b) => {\n      let result = a.title >= b.title ? 1 : -1;\n      if (desc) {\n        result = -result;\n      }\n      return result;\n    });\n  }\n  /**\n   * Check if a wiki has a certain subwiki.\n   *\n   * @param wikiId Wiki ID.\n   * @param subwikiId Subwiki ID to search.\n   * @param options Other options.\n   * @returns Promise resolved with true if it has subwiki, resolved with false otherwise.\n   */\n  wikiHasSubwiki(wikiId, subwikiId, options = {}) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // Get the subwikis to check if any of them matches the one passed as param.\n        const subwikis = yield _this16.getSubwikis(wikiId, options);\n        const subwiki = subwikis.find(subwiki => subwiki.id == subwikiId);\n        return !!subwiki;\n      } catch (_unused2) {\n        // Not found, return false.\n        return false;\n      }\n    })();\n  }\n  /**\n   * If this page is the first opened page for a wiki, remove the stored path so it's no longer the first viewed page.\n   *\n   * @param wikiId Wiki ID.\n   * @param path Path.\n   */\n  wikiPageClosed(wikiId, path) {\n    const tab = CoreNavigator.getMainMenuTabFromPath(path);\n    if (!tab) {\n      return;\n    }\n    this.wikiFirstViewedPage[tab] = this.wikiFirstViewedPage[tab] || {};\n    if (this.wikiFirstViewedPage[tab][wikiId] === path) {\n      delete this.wikiFirstViewedPage[tab][wikiId];\n    }\n  }\n  /**\n   * If this page is the first opened page for a wiki, save its path so we can go back to it.\n   *\n   * @param wikiId Wiki ID.\n   * @param path Path.\n   */\n  wikiPageOpened(wikiId, path) {\n    const tab = CoreNavigator.getMainMenuTabFromPath(path);\n    if (!tab) {\n      return;\n    }\n    this.wikiFirstViewedPage[tab] = this.wikiFirstViewedPage[tab] || {};\n    if (this.wikiFirstViewedPage[tab][wikiId]) {\n      // There's already an opened page for this wiki.\n      return;\n    }\n    this.wikiFirstViewedPage[tab][wikiId] = path;\n  }\n}\n_class = AddonModWikiProvider;\n_class.COMPONENT = 'mmaModWiki';\n_class.PAGE_CREATED_EVENT = 'addon_mod_wiki_page_created';\n_class.RENEW_LOCK_TIME = 30000;\n_class.ɵfac = function AddonModWikiProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModWiki = makeSingleton(AddonModWikiProvider);","map":{"version":3,"names":["CoreError","CoreSite","CoreCourseLogHelper","CoreNetwork","CoreNavigator","CoreSites","CoreSitesReadingStrategy","CoreUtils","makeSingleton","Translate","CoreEvents","AddonModWikiOffline","AddonModWikiSyncProvider","ROOT_CACHE_KEY","AddonModWikiProvider","constructor","subwikiListsCache","wikiFirstViewedPage","on","LOGIN","clearSubwikiList","wikiId","undefined","consumeEditedPageData","editedPage","editPage","pageId","content","section","siteId","_asyncToGenerator","site","getSite","params","pageid","response","write","getFirstWikiPageOpened","path","tab","getMainMenuTabFromPath","getPageContents","options","_this","preSets","_objectSpread","cacheKey","getPageContentsCacheKey","updateFrequency","FREQUENCY_SOMETIMES","component","COMPONENT","componentId","cmId","getReadingStrategyPreSets","readingStrategy","read","page","getPageForEditing","lockOnly","lockonly","pagesection","getSubwikiFiles","_this2","groupId","userId","wikiid","groupid","userid","getSubwikiFilesCacheKey","files","getSubwikiFilesCacheKeyPrefix","getSubwikiList","getSubwikiPages","_this3","sortBy","sortDirection","sortby","sortdirection","includecontent","includeContent","getSubwikiPagesCacheKey","pages","getSubwikiPagesCacheKeyPrefix","getSubwikis","_this4","getSubwikisCacheKey","FREQUENCY_RARELY","subwikis","map","subwiki","Number","getWiki","courseId","getWikiByField","key","value","_this5","courseids","getWikiDataCacheKey","currentWiki","wikis","find","wiki","instant","getWikiById","id","getWikiFileList","_this6","getCurrentSiteId","modOptions","coursemodule","Promise","all","_ref","subwikiOptions","subwikiFiles","concat","_x","apply","arguments","getWikiPageList","_this7","_ref2","subwikiPages","_x2","invalidateContent","moduleId","_this8","invalidateWikiData","invalidateSubwikis","invalidateSubwikiPages","invalidateSubwikiFiles","invalidatePage","_this9","invalidateWsCacheForKey","_this10","invalidateWsCacheForKeyStartingWith","_this11","_this12","_this13","isTitleUsed","subwikiId","title","_this14","_unused","logPageView","log","logView","newPage","_this15","storeOffline","_ref3","used","ignoreErrors","saveNewPage","isOnline","deleteNewPage","newPageOnline","error","isWebServiceError","contentformat","convertToPositiveNumber","subwikiid","setEditedPageData","data","setSubwikiList","count","subwikiSelected","userSelected","groupSelected","sortPagesByTitle","desc","sort","a","b","result","wikiHasSubwiki","_this16","_unused2","wikiPageClosed","wikiPageOpened","_class","PAGE_CREATED_EVENT","RENEW_LOCK_TIME","factory","ɵfac","providedIn","AddonModWiki"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/wiki/services/wiki.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreTagItem } from '@features/tag/services/tag';\nimport { CoreNetwork } from '@services/network';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile, CoreWSExternalWarning, CoreWSFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModWikiPageDBRecord } from './database/wiki';\nimport { AddonModWikiOffline } from './wiki-offline';\nimport { AddonModWikiAutoSyncData, AddonModWikiManualSyncData, AddonModWikiSyncProvider } from './wiki-sync';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaModWiki:';\n\n/**\n * Service that provides some features for wikis.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModWikiProvider {\n\n    static readonly COMPONENT = 'mmaModWiki';\n    static readonly PAGE_CREATED_EVENT = 'addon_mod_wiki_page_created';\n    static readonly RENEW_LOCK_TIME = 30000; // Milliseconds.\n\n    protected subwikiListsCache: {[wikiId: number]: AddonModWikiSubwikiListData} = {};\n    protected wikiFirstViewedPage: Record<string, Record<number, string>> = {};\n    protected editedPage?: AddonModWikiEditedPageData;\n\n    constructor() {\n        // Clear subwiki lists cache on logout.\n        CoreEvents.on(CoreEvents.LOGIN, () => {\n            this.clearSubwikiList();\n        });\n    }\n\n    /**\n     * Clear subwiki list cache for a certain wiki or all of them.\n     *\n     * @param wikiId wiki Id, if not provided all will be cleared.\n     */\n    clearSubwikiList(wikiId?: number): void {\n        if (wikiId === undefined) {\n            this.subwikiListsCache = {};\n        } else {\n            delete this.subwikiListsCache[wikiId];\n        }\n    }\n\n    /**\n     * Delete and return the edited page data if any.\n     *\n     * @returns Edited page data, undefined if no data.\n     */\n    consumeEditedPageData(): AddonModWikiEditedPageData | undefined {\n        const editedPage = this.editedPage;\n        delete this.editedPage;\n\n        return editedPage;\n    }\n\n    /**\n     * Save wiki contents on a page or section.\n     *\n     * @param pageId Page ID.\n     * @param content content to be saved.\n     * @param section section to get.\n     * @returns Promise resolved with the page ID.\n     */\n    async editPage(pageId: number, content: string, section?: string, siteId?: string): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModWikiEditPageWSParams = {\n            pageid: pageId,\n            content: content,\n        };\n\n        if (section) {\n            params.section = section;\n        }\n\n        const response = await site.write<AddonModWikiEditPageWSResponse>('mod_wiki_edit_page', params);\n\n        return response.pageid;\n    }\n\n    /**\n     * Get the first page opened for a wiki in the app if it isn't the current one.\n     *\n     * @param wikiId Wiki ID.\n     * @param path Path.\n     * @returns The first wiki page opened if any.\n     */\n    getFirstWikiPageOpened(wikiId: number, path: string): string | undefined {\n        const tab = CoreNavigator.getMainMenuTabFromPath(path);\n        if (!tab) {\n            return;\n        }\n\n        if (this.wikiFirstViewedPage[tab] && this.wikiFirstViewedPage[tab][wikiId] !== path) {\n            return this.wikiFirstViewedPage[tab][wikiId];\n        }\n    }\n\n    /**\n     * Get a wiki page contents.\n     *\n     * @param pageId Page ID.\n     * @param options Other options.\n     * @returns Promise resolved with the page data.\n     */\n    async getPageContents(pageId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModWikiPageContents> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModWikiGetPageContentsWSParams = {\n            pageid: pageId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getPageContentsCacheKey(pageId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModWikiProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModWikiGetPageContentsWSResponse>('mod_wiki_get_page_contents', params, preSets);\n\n        return response.page;\n    }\n\n    /**\n     * Get cache key for wiki Pages Contents WS calls.\n     *\n     * @param pageId Wiki Page ID.\n     * @returns Cache key.\n     */\n    protected getPageContentsCacheKey(pageId: number): string {\n        return ROOT_CACHE_KEY + 'page:' + pageId;\n    }\n\n    /**\n     * Get a wiki page contents for editing. It does not cache calls.\n     *\n     * @param pageId Page ID.\n     * @param section Section to get.\n     * @param lockOnly Just renew lock and not return content.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with page contents.\n     */\n    async getPageForEditing(\n        pageId: number,\n        section?: string,\n        lockOnly?: boolean,\n        siteId?: string,\n    ): Promise<AddonModWikiWSEditPageSection> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModWikiGetPageForEditingWSParams = {\n            pageid: pageId,\n        };\n        if (section) {\n            params.section = section;\n        }\n        if (lockOnly) {\n            params.lockonly = true;\n        }\n\n        const response = await site.write<AddonModWikiGetPageForEditingWSResponse>('mod_wiki_get_page_for_editing', params);\n\n        return response.pagesection;\n    }\n\n    /**\n     * Gets the list of files from a specific subwiki.\n     *\n     * @param wikiId Wiki ID.\n     * @param options Other options.\n     * @returns Promise resolved with subwiki files.\n     */\n    async getSubwikiFiles(wikiId: number, options: AddonModWikiGetSubwikiFilesOptions = {}): Promise<CoreWSFile[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const groupId = options.groupId || -1;\n        const userId = options.userId || 0;\n\n        const params: AddonModWikiGetSubwikiFilesWSParams = {\n            wikiid: wikiId,\n            groupid: groupId,\n            userid: userId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getSubwikiFilesCacheKey(wikiId, groupId, userId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModWikiProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModWikiGetSubwikiFilesWSResponse>('mod_wiki_get_subwiki_files', params, preSets);\n\n        return response.files;\n    }\n\n    /**\n     * Get cache key for wiki Subwiki Files WS calls.\n     *\n     * @param wikiId Wiki ID.\n     * @param groupId Group ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getSubwikiFilesCacheKey(wikiId: number, groupId: number, userId: number): string {\n        return this.getSubwikiFilesCacheKeyPrefix(wikiId) + ':' + groupId + ':' + userId;\n    }\n\n    /**\n     * Get cache key for all wiki Subwiki Files WS calls.\n     *\n     * @param wikiId Wiki ID.\n     * @returns Cache key.\n     */\n    protected getSubwikiFilesCacheKeyPrefix(wikiId: number): string {\n        return ROOT_CACHE_KEY + 'subwikifiles:' + wikiId;\n    }\n\n    /**\n     * Get a list of subwikis and related data for a certain wiki from the cache.\n     *\n     * @param wikiId wiki Id\n     * @returns Subwiki list and related data.\n     */\n    getSubwikiList(wikiId: number): AddonModWikiSubwikiListData {\n        return this.subwikiListsCache[wikiId];\n    }\n\n    /**\n     * Get the list of Pages of a SubWiki.\n     *\n     * @param wikiId Wiki ID.\n     * @param options Other options.\n     * @returns Promise resolved with wiki subwiki pages.\n     */\n    async getSubwikiPages(wikiId: number, options: AddonModWikiGetSubwikiPagesOptions = {}): Promise<AddonModWikiSubwikiPage[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const groupId = options.groupId || -1;\n        const userId = options.userId || 0;\n        const sortBy = options.sortBy || 'title';\n        const sortDirection = options.sortDirection || 'ASC';\n\n        const params: AddonModWikiGetSubwikiPagesWSParams = {\n            wikiid: wikiId,\n            groupid: groupId,\n            userid: userId,\n            options: {\n                sortby: sortBy,\n                sortdirection: sortDirection,\n                includecontent: options.includeContent ? 1 : 0,\n            },\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getSubwikiPagesCacheKey(wikiId, groupId, userId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModWikiProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModWikiGetSubwikiPagesWSResponse>('mod_wiki_get_subwiki_pages', params, preSets);\n\n        return response.pages;\n    }\n\n    /**\n     * Get cache key for wiki Subwiki Pages WS calls.\n     *\n     * @param wikiId Wiki ID.\n     * @param groupId Group ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getSubwikiPagesCacheKey(wikiId: number, groupId: number, userId: number): string {\n        return this.getSubwikiPagesCacheKeyPrefix(wikiId) + ':' + groupId + ':' + userId;\n    }\n\n    /**\n     * Get cache key for all wiki Subwiki Pages WS calls.\n     *\n     * @param wikiId Wiki ID.\n     * @returns Cache key.\n     */\n    protected getSubwikiPagesCacheKeyPrefix(wikiId: number): string {\n        return ROOT_CACHE_KEY + 'subwikipages:' + wikiId;\n    }\n\n    /**\n     * Get all the subwikis of a wiki.\n     *\n     * @param wikiId Wiki ID.\n     * @param options Other options.\n     * @returns Promise resolved with subwikis.\n     */\n    async getSubwikis(wikiId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModWikiSubwiki[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModWikiGetSubwikisWSParams = {\n            wikiid: wikiId,\n        };\n        const preSets = {\n            cacheKey: this.getSubwikisCacheKey(wikiId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModWikiProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModWikiGetSubwikisWSResponse>('mod_wiki_get_subwikis', params, preSets);\n\n        return response.subwikis.map(subwiki => ({\n            ...subwiki,\n            groupid: Number(subwiki.groupid), // Convert groupid to number.\n        }));\n    }\n\n    /**\n     * Get cache key for get wiki subWikis WS calls.\n     *\n     * @param wikiId Wiki ID.\n     * @returns Cache key.\n     */\n    protected getSubwikisCacheKey(wikiId: number): string {\n        return ROOT_CACHE_KEY + 'subwikis:' + wikiId;\n    }\n\n    /**\n     * Get a wiki by module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the wiki is retrieved.\n     */\n    getWiki(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModWikiWiki> {\n        return this.getWikiByField(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a wiki with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the wiki is retrieved.\n     */\n    protected async getWikiByField(\n        courseId: number,\n        key: string,\n        value: unknown,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModWikiWiki> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModWikiGetWikisByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getWikiDataCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModWikiProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModWikiGetWikisByCoursesWSResponse>('mod_wiki_get_wikis_by_courses', params, preSets);\n\n        const currentWiki = response.wikis.find((wiki) => wiki[key] == value);\n        if (currentWiki) {\n            return currentWiki;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get a wiki by wiki ID.\n     *\n     * @param courseId Course ID.\n     * @param id Wiki ID.\n     * @param options Other options.\n     * @returns Promise resolved when the wiki is retrieved.\n     */\n    getWikiById(courseId: number, id: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModWikiWiki> {\n        return this.getWikiByField(courseId, 'id', id, options);\n    }\n\n    /**\n     * Get cache key for wiki data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getWikiDataCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'wiki:' + courseId;\n    }\n\n    /**\n     * Gets a list of files to download for a wiki, using a format similar to module.contents from get_course_contents.\n     *\n     * @param wiki Wiki.\n     * @param options Other options.\n     * @returns Promise resolved with the list of files.\n     */\n    async getWikiFileList(wiki: AddonModWikiWiki, options: CoreSitesCommonWSOptions = {}): Promise<CoreWSFile[]> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        let files: CoreWSFile[] = [];\n        const modOptions = {\n            cmId: wiki.coursemodule,\n            ...options, // Include all options.\n        };\n\n        const subwikis = await this.getSubwikis(wiki.id, modOptions);\n\n        await Promise.all(subwikis.map(async (subwiki) => {\n            const subwikiOptions = {\n                groupId: subwiki.groupid,\n                userId: subwiki.userid,\n                ...modOptions, // Include all options.\n            };\n\n            const subwikiFiles = await this.getSubwikiFiles(subwiki.wikiid, subwikiOptions);\n\n            files = files.concat(subwikiFiles);\n        }));\n\n        return files;\n    }\n\n    /**\n     * Gets a list of all pages for a Wiki.\n     *\n     * @param wiki Wiki.\n     * @param options Other options.\n     * @returns Page list.\n     */\n    async getWikiPageList(wiki: AddonModWikiWiki, options: CoreSitesCommonWSOptions = {}): Promise<AddonModWikiSubwikiPage[]> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        let pages: AddonModWikiSubwikiPage[] = [];\n        const modOptions = {\n            cmId: wiki.coursemodule,\n            ...options, // Include all options.\n        };\n\n        const subwikis = await this.getSubwikis(wiki.id, modOptions);\n\n        await Promise.all(subwikis.map(async (subwiki) => {\n            const subwikiPages = await this.getSubwikiPages(subwiki.wikiid, {\n                groupId: subwiki.groupid,\n                userId: subwiki.userid,\n                ...modOptions, // Include all options.\n            });\n\n            pages = pages.concat(subwikiPages);\n        }));\n\n        return pages;\n    }\n\n    /**\n     * Invalidate the prefetched content except files.\n     * To invalidate files, use invalidateFiles.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const wiki = await this.getWiki(courseId, moduleId, { siteId });\n\n        await Promise.all([\n            this.invalidateWikiData(courseId, siteId),\n            this.invalidateSubwikis(wiki.id, siteId),\n            this.invalidateSubwikiPages(wiki.id, siteId),\n            this.invalidateSubwikiFiles(wiki.id, siteId),\n        ]);\n    }\n\n    /**\n     * Invalidates page content WS call for a certain page.\n     *\n     * @param pageId Wiki Page ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidatePage(pageId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getPageContentsCacheKey(pageId));\n    }\n\n    /**\n     * Invalidates all the subwiki files WS calls for a certain wiki.\n     *\n     * @param wikiId Wiki ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateSubwikiFiles(wikiId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getSubwikiFilesCacheKeyPrefix(wikiId));\n    }\n\n    /**\n     * Invalidates all the subwiki pages WS calls for a certain wiki.\n     *\n     * @param wikiId Wiki ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateSubwikiPages(wikiId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getSubwikiPagesCacheKeyPrefix(wikiId));\n    }\n\n    /**\n     * Invalidates all the get subwikis WS calls for a certain wiki.\n     *\n     * @param wikiId Wiki ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateSubwikis(wikiId: number, siteId?: string): Promise<void> {\n        this.clearSubwikiList(wikiId);\n\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getSubwikisCacheKey(wikiId));\n    }\n\n    /**\n     * Invalidates wiki data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateWikiData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getWikiDataCacheKey(courseId));\n    }\n\n    /**\n     * Check if a page title is already used.\n     *\n     * @param wikiId Wiki ID.\n     * @param subwikiId Subwiki ID.\n     * @param title Page title.\n     * @param options Other options.\n     * @returns Promise resolved with true if used, resolved with false if not used or cannot determine.\n     */\n    async isTitleUsed(\n        wikiId: number,\n        subwikiId: number,\n        title: string,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<boolean> {\n        try {\n            // First get the subwiki.\n            const subwikis = await this.getSubwikis(wikiId, options);\n\n            // Search the subwiki.\n            const subwiki = subwikis.find((subwiki) => subwiki.id == subwikiId);\n\n            if (!subwiki) {\n                return false;\n            }\n\n            // Now get all the pages of the subwiki.\n            const pages = await this.getSubwikiPages(wikiId, {\n                groupId: subwiki.groupid,\n                userId: subwiki.userid,\n                ...options, // Include all options.\n            });\n\n            // Check if there's any page with the same title.\n            const page = pages.find((page) => page.title == title);\n\n            return !!page;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Report a wiki page as being viewed.\n     *\n     * @param id Page ID.\n     * @param wikiId Wiki ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logPageView(id: number, wikiId: number, siteId?: string): Promise<void> {\n        const params: AddonModWikiViewPageWSParams = {\n            pageid: id,\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_wiki_view_page',\n            params,\n            AddonModWikiProvider.COMPONENT,\n            wikiId,\n            siteId,\n        );\n    }\n\n    /**\n     * Report the wiki as being viewed.\n     *\n     * @param id Wiki ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logView(id: number, siteId?: string): Promise<void> {\n        const params: AddonModWikiViewWikiWSParams = {\n            wikiid: id,\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_wiki_view_wiki',\n            params,\n            AddonModWikiProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Create a new page on a subwiki.\n     *\n     * @param title Title to create the page.\n     * @param content Content to save on the page.\n     * @param options Other options.\n     * @returns Promise resolved with page ID if page was created in server, -1 if stored in device.\n     */\n    async newPage(title: string, content: string, options: AddonModWikiNewPageOptions = {}): Promise<number> {\n\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a new page to be synchronized later.\n        const storeOffline = async (): Promise<number> => {\n            if (options.wikiId && options.subwikiId) {\n                // We have wiki ID, check if there's already an online page with this title and subwiki.\n                const used = await CoreUtils.ignoreErrors(this.isTitleUsed(options.wikiId, options.subwikiId, title, {\n                    cmId: options.cmId,\n                    readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n                    siteId: options.siteId,\n                }));\n\n                if (used) {\n                    throw new CoreError(Translate.instant('addon.mod_wiki.pageexists'));\n                }\n            }\n\n            await AddonModWikiOffline.saveNewPage(\n                title,\n                content,\n                options.subwikiId,\n                options.wikiId,\n                options.userId,\n                options.groupId,\n                options.siteId,\n            );\n\n            return -1;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        // Discard stored content for this page. If it exists it means the user is editing it.\n        await AddonModWikiOffline.deleteNewPage(\n            title,\n            options.subwikiId,\n            options.wikiId,\n            options.userId,\n            options.groupId,\n            options.siteId,\n        );\n\n        try {\n            // Try to create it in online.\n            return await this.newPageOnline(title, content, options);\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that the page cannot be added.\n                throw error;\n            }\n\n            // Couldn't connect to server, store in offline.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Create a new page on a subwiki. It will fail if offline or cannot connect.\n     *\n     * @param title Title to create the page.\n     * @param content Content to save on the page.\n     * @param options Other options.\n     * @returns Promise resolved with the page ID if created, rejected otherwise.\n     */\n    async newPageOnline(title: string, content: string, options: AddonModWikiNewPageOnlineOptions = {}): Promise<number> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModWikiNewPageWSParams = {\n            title: title,\n            content: content,\n            contentformat: 'html',\n        };\n\n        const subwikiId = AddonModWikiOffline.convertToPositiveNumber(options.subwikiId);\n        const wikiId = AddonModWikiOffline.convertToPositiveNumber(options.wikiId);\n\n        if (subwikiId && subwikiId > 0) {\n            params.subwikiid = subwikiId;\n        } else if (wikiId) {\n            params.wikiid = wikiId;\n            params.userid = AddonModWikiOffline.convertToPositiveNumber(options.userId);\n            params.groupid = AddonModWikiOffline.convertToPositiveNumber(options.groupId);\n        }\n\n        const response = await site.write<AddonModWikiNewPageWSResponse>('mod_wiki_new_page', params);\n\n        return response.pageid;\n    }\n\n    /**\n     * Set edited page data.\n     *\n     * @param data Data.\n     */\n    setEditedPageData(data: AddonModWikiEditedPageData): void {\n        this.editedPage = data;\n    }\n\n    /**\n     * Save subwiki list for a wiki to the cache.\n     *\n     * @param wikiId Wiki Id.\n     * @param subwikis List of subwikis.\n     * @param count Number of subwikis in the subwikis list.\n     * @param subwikiId Subwiki Id currently selected.\n     * @param userId User Id currently selected.\n     * @param groupId Group Id currently selected.\n     */\n    setSubwikiList(\n        wikiId: number,\n        subwikis: AddonModWikiSubwikiListGrouping[],\n        count: number,\n        subwikiId: number,\n        userId: number,\n        groupId: number,\n    ): void {\n        this.subwikiListsCache[wikiId] = {\n            count: count,\n            subwikiSelected: subwikiId,\n            userSelected: userId,\n            groupSelected: groupId,\n            subwikis: subwikis,\n        };\n    }\n\n    /**\n     * Sort an array of wiki pages by title.\n     *\n     * @param pages Pages to sort.\n     * @param desc True to sort in descendent order, false to sort in ascendent order. Defaults to false.\n     * @returns Sorted pages.\n     */\n    sortPagesByTitle<T extends AddonModWikiSubwikiPage | AddonModWikiPageDBRecord>(\n        pages: T[],\n        desc?: boolean,\n    ): T[] {\n        return pages.sort((a, b) => {\n            let result = a.title >= b.title ? 1 : -1;\n\n            if (desc) {\n                result = -result;\n            }\n\n            return result;\n        });\n    }\n\n    /**\n     * Check if a wiki has a certain subwiki.\n     *\n     * @param wikiId Wiki ID.\n     * @param subwikiId Subwiki ID to search.\n     * @param options Other options.\n     * @returns Promise resolved with true if it has subwiki, resolved with false otherwise.\n     */\n    async wikiHasSubwiki(wikiId: number, subwikiId: number, options: CoreCourseCommonModWSOptions = {}): Promise<boolean> {\n        try {\n            // Get the subwikis to check if any of them matches the one passed as param.\n            const subwikis = await this.getSubwikis(wikiId, options);\n\n            const subwiki = subwikis.find((subwiki) => subwiki.id == subwikiId);\n\n            return !!subwiki;\n        } catch {\n            // Not found, return false.\n            return false;\n        }\n    }\n\n    /**\n     * If this page is the first opened page for a wiki, remove the stored path so it's no longer the first viewed page.\n     *\n     * @param wikiId Wiki ID.\n     * @param path Path.\n     */\n    wikiPageClosed(wikiId: number, path: string): void {\n        const tab = CoreNavigator.getMainMenuTabFromPath(path);\n        if (!tab) {\n            return;\n        }\n\n        this.wikiFirstViewedPage[tab] = this.wikiFirstViewedPage[tab] || {};\n\n        if (this.wikiFirstViewedPage[tab][wikiId] === path) {\n            delete this.wikiFirstViewedPage[tab][wikiId];\n        }\n    }\n\n    /**\n     * If this page is the first opened page for a wiki, save its path so we can go back to it.\n     *\n     * @param wikiId Wiki ID.\n     * @param path Path.\n     */\n    wikiPageOpened(wikiId: number, path: string): void {\n        const tab = CoreNavigator.getMainMenuTabFromPath(path);\n        if (!tab) {\n            return;\n        }\n\n        this.wikiFirstViewedPage[tab] = this.wikiFirstViewedPage[tab] || {};\n\n        if (this.wikiFirstViewedPage[tab][wikiId]) {\n            // There's already an opened page for this wiki.\n            return;\n        }\n\n        this.wikiFirstViewedPage[tab][wikiId] = path;\n    }\n\n}\n\nexport const AddonModWiki = makeSingleton(AddonModWikiProvider);\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonModWikiProvider.PAGE_CREATED_EVENT]: AddonModWikiPageCreatedData;\n        [AddonModWikiSyncProvider.AUTO_SYNCED]: AddonModWikiAutoSyncData;\n        [AddonModWikiSyncProvider.MANUAL_SYNCED]: AddonModWikiManualSyncData;\n    }\n\n}\n\n/**\n * Options to pass to getSubwikiFiles.\n */\nexport type AddonModWikiGetSubwikiFilesOptions = CoreCourseCommonModWSOptions & {\n    userId?: number; // User to get files from.\n    groupId?: number; // Group to get files from.\n};\n\n/**\n * Options to pass to getSubwikiPages.\n */\nexport type AddonModWikiGetSubwikiPagesOptions = CoreCourseCommonModWSOptions & {\n    userId?: number; // User to get pages from.\n    groupId?: number; // Group to get pages from.\n    sortBy?: string; // The attribute to sort the returned list. Defaults to 'title'.\n    sortDirection?: string; // Direction to sort the returned list (ASC | DESC). Defaults to 'ASC'.\n    includeContent?: boolean; // Whether the pages have to include their content.\n};\n\n/**\n * Options to pass to newPageOnline.\n */\nexport type AddonModWikiNewPageOnlineOptions = {\n    subwikiId?: number; // Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n    wikiId?: number; // Wiki ID. Optional, will be used to create a new subwiki if subwikiId not supplied.\n    userId?: number; // User ID. Optional, will be used to create a new subwiki if subwikiId not supplied.\n    groupId?: number; // Group ID. Optional, will be used to create a new subwiki if subwikiId not supplied.\n    siteId?: string; // Site ID. If not defined, current site.\n};\n\n/**\n * Options to pass to newPage.\n */\nexport type AddonModWikiNewPageOptions = AddonModWikiNewPageOnlineOptions & {\n    cmId?: number; // Module ID.\n};\n\nexport type AddonModWikiSubwikiListData = {\n    count: number; // Number of subwikis.\n    subwikiSelected: number; // Subwiki ID currently selected.\n    userSelected: number; // User of the subwiki currently selected.\n    groupSelected: number; // Group of the subwiki currently selected.\n    subwikis: AddonModWikiSubwikiListGrouping[]; // List of subwikis, grouped by a certain label.\n};\n\nexport type AddonModWikiSubwikiListGrouping = {\n    label: string;\n    subwikis: AddonModWikiSubwikiListSubwiki[];\n};\n\nexport type AddonModWikiSubwikiListSubwiki = {\n    name: string;\n    id: number;\n    userid: number;\n    groupid: number;\n    groupLabel: string;\n    canedit: boolean;\n};\n\n/**\n * Params of mod_wiki_edit_page WS.\n */\nexport type AddonModWikiEditPageWSParams = {\n    pageid: number; // Page ID.\n    content: string; // Page contents.\n    section?: string; // Section page title.\n};\n\n/**\n * Data returned by mod_wiki_edit_page WS.\n */\nexport type AddonModWikiEditPageWSResponse = {\n    pageid: number; // Edited page id.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_wiki_get_page_contents WS.\n */\nexport type AddonModWikiGetPageContentsWSParams = {\n    pageid: number; // Page ID.\n};\n\n/**\n * Data returned by mod_wiki_get_page_contents WS.\n */\nexport type AddonModWikiGetPageContentsWSResponse = {\n    page: AddonModWikiPageContents; // Page.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Page data returned by mod_wiki_get_page_contents WS.\n */\nexport type AddonModWikiPageContents = {\n    id: number; // Page ID.\n    wikiid: number; // Page's wiki ID.\n    subwikiid: number; // Page's subwiki ID.\n    groupid: number; // Page's group ID.\n    userid: number; // Page's user ID.\n    title: string; // Page title.\n    cachedcontent: string; // Page contents.\n    contentformat?: number; // Cachedcontent format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    caneditpage: boolean; // True if user can edit the page.\n    version?: number; // Latest version of the page.\n    tags?: CoreTagItem[]; // Tags.\n};\n\n/**\n * Params of mod_wiki_get_page_for_editing WS.\n */\nexport type AddonModWikiGetPageForEditingWSParams = {\n    pageid: number; // Page ID to edit.\n    section?: string; // Section page title.\n    lockonly?: boolean; // Just renew lock and not return content.\n};\n\n/**\n * Data returned by mod_wiki_get_page_for_editing WS.\n */\nexport type AddonModWikiGetPageForEditingWSResponse = {\n    pagesection: AddonModWikiWSEditPageSection;\n};\n\n/**\n * Page section data returned by mod_wiki_get_page_for_editing WS.\n */\nexport type AddonModWikiWSEditPageSection = {\n    content?: string; // The contents of the page-section to be edited.\n    contentformat?: string; // Format of the original content of the page.\n    version: number; // Latest version of the page.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_wiki_get_subwiki_files WS.\n */\nexport type AddonModWikiGetSubwikiFilesWSParams = {\n    wikiid: number; // Wiki instance ID.\n    groupid?: number; // Subwiki's group ID, -1 means current group. It will be ignored if the wiki doesn't use groups.\n    userid?: number; // Subwiki's user ID, 0 means current user. It will be ignored in collaborative wikis.\n};\n\n/**\n * Data returned by mod_wiki_get_subwiki_files WS.\n */\nexport type AddonModWikiGetSubwikiFilesWSResponse = {\n    files: CoreWSExternalFile[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_wiki_get_subwiki_pages WS.\n */\nexport type AddonModWikiGetSubwikiPagesWSParams = {\n    wikiid: number; // Wiki instance ID.\n    groupid?: number; // Subwiki's group ID, -1 means current group. It will be ignored if the wiki doesn't use groups.\n    userid?: number; // Subwiki's user ID, 0 means current user. It will be ignored in collaborative wikis.\n    options?: {\n        sortby?: string; // Field to sort by (id, title, ...).\n        sortdirection?: string; // Sort direction: ASC or DESC.\n        includecontent?: number; // Include each page contents or just the contents size.\n    }; // Options.\n};\n\n/**\n * Data returned by mod_wiki_get_subwiki_pages WS.\n */\nexport type AddonModWikiGetSubwikiPagesWSResponse = {\n    pages: AddonModWikiSubwikiPage[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Page data returned by mod_wiki_get_subwiki_pages WS.\n */\nexport type AddonModWikiSubwikiPage = {\n    id: number; // Page ID.\n    subwikiid: number; // Page's subwiki ID.\n    title: string; // Page title.\n    timecreated: number; // Time of creation.\n    timemodified: number; // Time of last modification.\n    timerendered: number; // Time of last renderization.\n    userid: number; // ID of the user that last modified the page.\n    pageviews: number; // Number of times the page has been viewed.\n    readonly: number; // 1 if readonly, 0 otherwise.\n    caneditpage: boolean; // True if user can edit the page.\n    firstpage: boolean; // True if it's the first page.\n    cachedcontent?: string; // Page contents.\n    contentformat?: number; // Cachedcontent format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    contentsize?: number; // Size of page contents in bytes (doesn't include size of attached files).\n    tags?: CoreTagItem[]; // Tags.\n};\n\n/**\n * Params of mod_wiki_get_subwikis WS.\n */\nexport type AddonModWikiGetSubwikisWSParams = {\n    wikiid: number; // Wiki instance ID.\n};\n\n/**\n * Data returned by mod_wiki_get_subwikis WS.\n */\nexport type AddonModWikiGetSubwikisWSResponse = {\n    subwikis: AddonModWikiSubwikiWSData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Subwiki data returned by mod_wiki_get_subwikis WS.\n */\nexport type AddonModWikiSubwikiWSData = {\n    id: number; // Subwiki ID.\n    wikiid: number; // Wiki ID.\n    groupid: string; // Group ID.\n    userid: number; // User ID.\n    canedit: boolean; // True if user can edit the subwiki.\n};\n\n/**\n * Subwiki data with some calculated data.\n */\nexport type AddonModWikiSubwiki = Omit<AddonModWikiSubwikiWSData, 'groupid'> & {\n    groupid: number; // Group ID.\n};\n\n/**\n * Params of mod_wiki_get_wikis_by_courses WS.\n */\nexport type AddonModWikiGetWikisByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_wiki_get_wikis_by_courses WS.\n */\nexport type AddonModWikiGetWikisByCoursesWSResponse = {\n    wikis: AddonModWikiWiki[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Wiki data returned by mod_wiki_get_wikis_by_courses WS.\n */\nexport type AddonModWikiWiki = {\n    id: number; // Wiki ID.\n    coursemodule: number; // Course module ID.\n    course: number; // Course ID.\n    name: string; // Wiki name.\n    intro?: string; // Wiki intro.\n    introformat?: number; // Wiki intro format. format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    timecreated?: number; // Time of creation.\n    timemodified?: number; // Time of last modification.\n    firstpagetitle?: string; // First page title.\n    wikimode?: string; // Wiki mode (individual, collaborative).\n    defaultformat?: string; // Wiki's default format (html, creole, nwiki).\n    forceformat?: number; // 1 if format is forced, 0 otherwise.\n    editbegin?: number; // Edit begin.\n    editend?: number; // Edit end.\n    section?: number; // Course section ID.\n    visible?: number; // 1 if visible, 0 otherwise.\n    groupmode?: number; // Group mode.\n    groupingid?: number; // Group ID.\n    cancreatepages: boolean; // True if user can create pages.\n};\n\n/**\n * Params of mod_wiki_view_page WS.\n */\nexport type AddonModWikiViewPageWSParams = {\n    pageid: number; // Wiki page ID.\n};\n\n/**\n * Params of mod_wiki_view_wiki WS.\n */\nexport type AddonModWikiViewWikiWSParams = {\n    wikiid: number; // Wiki instance ID.\n};\n\n/**\n * Params of mod_wiki_new_page WS.\n */\nexport type AddonModWikiNewPageWSParams = {\n    title: string; // New page title.\n    content: string; // Page contents.\n    contentformat?: string; // Page contents format. If an invalid format is provided, default wiki format is used.\n    subwikiid?: number; // Page's subwiki ID.\n    wikiid?: number; // Page's wiki ID. Used if subwiki does not exists.\n    userid?: number; // Subwiki's user ID. Used if subwiki does not exists.\n    groupid?: number; // Subwiki's group ID. Used if subwiki does not exists.\n};\n\n/**\n * Data returned by mod_wiki_new_page WS.\n */\nexport type AddonModWikiNewPageWSResponse = {\n    pageid: number; // New page id.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data passed to PAGE_CREATED event.\n */\nexport type AddonModWikiPageCreatedData = {\n    pageId: number;\n    subwikiId: number;\n    pageTitle: string;\n};\n\n/**\n * Data about a page that was just edited.\n */\nexport type AddonModWikiEditedPageData = {\n    cmId?: number;\n    courseId?: number;\n    wikiId: number;\n    pageTitle: string;\n    subwikiId?: number;\n    userId?: number;\n    groupId?: number;\n    pageId?: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}