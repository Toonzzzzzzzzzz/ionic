{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreDelegate } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./handlers/default-filter\";\n/**\n * Delegate to register filters.\n */\nexport class CoreFilterDelegateService extends CoreDelegate {\n  constructor(defaultHandler) {\n    super('CoreFilterDelegate', true);\n    this.defaultHandler = defaultHandler;\n    this.featurePrefix = 'CoreFilterDelegate_';\n    this.handlerNameProperty = 'filterName';\n  }\n  /**\n   * Apply a list of filters to some content.\n   *\n   * @param text The text to filter.\n   * @param filters Filters to apply.\n   * @param options Options passed to the filters.\n   * @param skipFilters Names of filters that shouldn't be applied.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the filtered text.\n   */\n  filterText(text, filters, options, skipFilters, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Wait for filters to be initialized.\n      yield _this.handlersInitPromise;\n      const site = yield CoreSites.getSite(siteId);\n      filters = filters || [];\n      options = options || {};\n      for (let i = 0; i < filters.length; i++) {\n        const filter = filters[i];\n        if (!_this.isEnabledAndShouldApply(filter, options, site, skipFilters)) {\n          continue;\n        }\n        try {\n          const newText = yield _this.executeFunctionOnEnabled(filter.filter, 'filter', [text, filter, options, siteId]);\n          text = newText || text;\n        } catch (error) {\n          _this.logger.error('Error applying filter' + filter.filter, error);\n        }\n      }\n      // Remove <nolink> tags for XHTML compatibility.\n      text = text.replace(/<\\/?nolink>/gi, '');\n      return text;\n    })();\n  }\n  /**\n   * Get filters that have an enabled handler.\n   *\n   * @param contextLevel Context level of the filters.\n   * @param instanceId Instance ID.\n   * @returns Filters.\n   */\n  getEnabledFilters(contextLevel, instanceId) {\n    const filters = [];\n    for (const name in this.enabledHandlers) {\n      const handler = this.enabledHandlers[name];\n      filters.push({\n        contextid: -1,\n        contextlevel: contextLevel,\n        filter: handler.filterName,\n        inheritedstate: 1,\n        instanceid: instanceId,\n        localstate: 1\n      });\n    }\n    return filters;\n  }\n  /**\n   * Let filters handle an HTML element.\n   *\n   * @param container The HTML container to handle.\n   * @param filters Filters to apply.\n   * @param viewContainerRef The ViewContainerRef where the container is.\n   * @param options Options passed to the filters.\n   * @param skipFilters Names of filters that shouldn't be applied.\n   * @param component Component.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  handleHtml(container, filters, viewContainerRef, options, skipFilters, component, componentId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // Wait for filters to be initialized.\n      yield _this2.handlersInitPromise;\n      const site = yield CoreSites.getSite(siteId);\n      filters = filters || [];\n      options = options || {};\n      for (let i = 0; i < filters.length; i++) {\n        const filter = filters[i];\n        if (!_this2.isEnabledAndShouldApply(filter, options, site, skipFilters)) {\n          continue;\n        }\n        try {\n          yield _this2.executeFunctionOnEnabled(filter.filter, 'handleHtml', [container, filter, options, viewContainerRef, component, componentId, siteId]);\n        } catch (error) {\n          _this2.logger.error('Error handling HTML' + filter.filter, error);\n        }\n      }\n    })();\n  }\n  /**\n   * Check if a filter is enabled and should be applied.\n   *\n   * @param filter Filter to apply.\n   * @param options Options passed to the filters.\n   * @param site Site.\n   * @param skipFilters Names of filters that shouldn't be applied.\n   * @returns Whether the filter is enabled and should be applied.\n   */\n  isEnabledAndShouldApply(filter, options, site, skipFilters) {\n    if (filter.localstate == -1 || filter.localstate == 0 && filter.inheritedstate == -1) {\n      // Filter is disabled, ignore it.\n      return false;\n    }\n    if (!this.shouldFilterBeApplied(filter, options, site)) {\n      // Filter shouldn't be applied.\n      return false;\n    }\n    if (skipFilters && skipFilters.indexOf(filter.filter) != -1) {\n      // Skip this filter.\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if at least 1 filter should be applied in a certain site and with certain options.\n   *\n   * @param filters Filters to check.\n   * @param options Options passed to the filters.\n   * @param site Site. If not defined, current site.\n   * @returns Promise resolved with true: whether the filter should be applied.\n   */\n  shouldBeApplied(filters, options, site) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Wait for filters to be initialized.\n      yield _this3.handlersInitPromise;\n      for (let i = 0; i < filters.length; i++) {\n        if (_this3.shouldFilterBeApplied(filters[i], options, site)) {\n          return true;\n        }\n      }\n      return false;\n    })();\n  }\n  /**\n   * Check whether a filter should be applied in a certain site and with certain options.\n   *\n   * @param filter Filter to check.\n   * @param options Options passed to the filters.\n   * @param site Site. If not defined, current site.\n   * @returns Whether the filter should be applied.\n   */\n  shouldFilterBeApplied(filter, options, site) {\n    if (!this.hasHandler(filter.filter, true)) {\n      return false;\n    }\n    return !!this.executeFunctionOnEnabled(filter.filter, 'shouldBeApplied', [options, site]);\n  }\n}\n_class = CoreFilterDelegateService;\n_class.ɵfac = function CoreFilterDelegateService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.CoreFilterDefaultHandler));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFilterDelegate = makeSingleton(CoreFilterDelegateService);","map":{"version":3,"names":["CoreSites","CoreDelegate","makeSingleton","CoreFilterDelegateService","constructor","defaultHandler","featurePrefix","handlerNameProperty","filterText","text","filters","options","skipFilters","siteId","_this","_asyncToGenerator","handlersInitPromise","site","getSite","i","length","filter","isEnabledAndShouldApply","newText","executeFunctionOnEnabled","error","logger","replace","getEnabledFilters","contextLevel","instanceId","name","enabledHandlers","handler","push","contextid","contextlevel","filterName","inheritedstate","instanceid","localstate","handleHtml","container","viewContainerRef","component","componentId","_this2","shouldFilterBeApplied","indexOf","shouldBeApplied","_this3","hasHandler","i0","ɵɵinject","i1","CoreFilterDefaultHandler","factory","ɵfac","providedIn","CoreFilterDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/filter/services/filter-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, ViewContainerRef } from '@angular/core';\n\nimport { CoreSites } from '@services/sites';\nimport { CoreFilterFilter, CoreFilterFormatTextOptions } from './filter';\nimport { CoreFilterDefaultHandler } from './handlers/default-filter';\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton } from '@singletons';\n\n/**\n * Interface that all filter handlers must implement.\n */\nexport interface CoreFilterHandler extends CoreDelegateHandler {\n    /**\n     * Name of the filter. It should match the \"filter\" field returned in core_filters_get_available_in_context.\n     */\n    filterName: string;\n\n    /**\n     * Filter some text.\n     *\n     * @param text The text to filter.\n     * @param filter The filter.\n     * @param options Options passed to the filters.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Filtered text (or promise resolved with the filtered text).\n     */\n    filter(text: string, filter: CoreFilterFilter, options: CoreFilterFormatTextOptions, siteId?: string): string | Promise<string>;\n\n    /**\n     * Handle HTML. This function is called after \"filter\", and it will receive an HTMLElement containing the text that was\n     * filtered.\n     *\n     * @param container The HTML container to handle.\n     * @param filter The filter.\n     * @param options Options passed to the filters.\n     * @param viewContainerRef The ViewContainerRef where the container is.\n     * @param component Component.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns If async, promise resolved when done.\n     */\n    handleHtml?(\n        container: HTMLElement,\n        filter: CoreFilterFilter,\n        options: CoreFilterFormatTextOptions,\n        viewContainerRef: ViewContainerRef,\n        component?: string,\n        componentId?: string | number,\n        siteId?: string,\n    ): void | Promise<void>;\n\n    /**\n     * Check if the filter should be applied in a certain site based on some filter options.\n     *\n     * @param options Options.\n     * @param site Site.\n     * @returns Whether filter should be applied.\n     */\n    shouldBeApplied(options: CoreFilterFormatTextOptions, site?: CoreSite): boolean;\n}\n\n/**\n * Delegate to register filters.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFilterDelegateService extends CoreDelegate<CoreFilterHandler> {\n\n    protected featurePrefix = 'CoreFilterDelegate_';\n    protected handlerNameProperty = 'filterName';\n\n    constructor(protected defaultHandler: CoreFilterDefaultHandler) {\n        super('CoreFilterDelegate', true);\n    }\n\n    /**\n     * Apply a list of filters to some content.\n     *\n     * @param text The text to filter.\n     * @param filters Filters to apply.\n     * @param options Options passed to the filters.\n     * @param skipFilters Names of filters that shouldn't be applied.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the filtered text.\n     */\n    async filterText(\n        text: string,\n        filters?: CoreFilterFilter[],\n        options?: CoreFilterFormatTextOptions,\n        skipFilters?: string[],\n        siteId?: string,\n    ): Promise<string> {\n\n        // Wait for filters to be initialized.\n        await this.handlersInitPromise;\n\n        const site = await CoreSites.getSite(siteId);\n\n        filters = filters || [];\n        options = options || {};\n\n        for (let i = 0; i < filters.length; i++) {\n            const filter = filters[i];\n            if (!this.isEnabledAndShouldApply(filter, options, site, skipFilters)) {\n                continue;\n            }\n\n            try {\n                const newText = await this.executeFunctionOnEnabled<string>(\n                    filter.filter,\n                    'filter',\n                    [text, filter, options, siteId],\n                );\n\n                text = newText || text;\n            } catch (error) {\n                this.logger.error('Error applying filter' + filter.filter, error);\n            }\n        }\n\n        // Remove <nolink> tags for XHTML compatibility.\n        text = text.replace(/<\\/?nolink>/gi, '');\n\n        return text;\n    }\n\n    /**\n     * Get filters that have an enabled handler.\n     *\n     * @param contextLevel Context level of the filters.\n     * @param instanceId Instance ID.\n     * @returns Filters.\n     */\n    getEnabledFilters(contextLevel: string, instanceId: number): CoreFilterFilter[] {\n        const filters: CoreFilterFilter[] = [];\n\n        for (const name in this.enabledHandlers) {\n            const handler = <CoreFilterHandler> this.enabledHandlers[name];\n\n            filters.push({\n                contextid: -1,\n                contextlevel: contextLevel,\n                filter: handler.filterName,\n                inheritedstate: 1,\n                instanceid: instanceId,\n                localstate: 1,\n            });\n        }\n\n        return filters;\n    }\n\n    /**\n     * Let filters handle an HTML element.\n     *\n     * @param container The HTML container to handle.\n     * @param filters Filters to apply.\n     * @param viewContainerRef The ViewContainerRef where the container is.\n     * @param options Options passed to the filters.\n     * @param skipFilters Names of filters that shouldn't be applied.\n     * @param component Component.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async handleHtml(\n        container: HTMLElement,\n        filters: CoreFilterFilter[],\n        viewContainerRef?: ViewContainerRef,\n        options?: CoreFilterFormatTextOptions,\n        skipFilters?: string[],\n        component?: string,\n        componentId?: string | number,\n        siteId?: string,\n    ): Promise<void> {\n\n        // Wait for filters to be initialized.\n        await this.handlersInitPromise;\n\n        const site = await CoreSites.getSite(siteId);\n\n        filters = filters || [];\n        options = options || {};\n\n        for (let i = 0; i < filters.length; i++) {\n            const filter = filters[i];\n            if (!this.isEnabledAndShouldApply(filter, options, site, skipFilters)) {\n                continue;\n            }\n\n            try {\n                await this.executeFunctionOnEnabled<void>(\n                    filter.filter,\n                    'handleHtml',\n                    [container, filter, options, viewContainerRef, component, componentId, siteId],\n                );\n            } catch (error) {\n                this.logger.error('Error handling HTML' + filter.filter, error);\n            }\n        }\n    }\n\n    /**\n     * Check if a filter is enabled and should be applied.\n     *\n     * @param filter Filter to apply.\n     * @param options Options passed to the filters.\n     * @param site Site.\n     * @param skipFilters Names of filters that shouldn't be applied.\n     * @returns Whether the filter is enabled and should be applied.\n     */\n    isEnabledAndShouldApply(\n        filter: CoreFilterFilter,\n        options: CoreFilterFormatTextOptions,\n        site: CoreSite,\n        skipFilters?: string[],\n    ): boolean {\n\n        if (filter.localstate == -1 || (filter.localstate == 0 && filter.inheritedstate == -1)) {\n            // Filter is disabled, ignore it.\n            return false;\n        }\n\n        if (!this.shouldFilterBeApplied(filter, options, site)) {\n            // Filter shouldn't be applied.\n            return false;\n        }\n\n        if (skipFilters && skipFilters.indexOf(filter.filter) != -1) {\n            // Skip this filter.\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if at least 1 filter should be applied in a certain site and with certain options.\n     *\n     * @param filters Filters to check.\n     * @param options Options passed to the filters.\n     * @param site Site. If not defined, current site.\n     * @returns Promise resolved with true: whether the filter should be applied.\n     */\n    async shouldBeApplied(filters: CoreFilterFilter[], options: CoreFilterFormatTextOptions, site?: CoreSite): Promise<boolean> {\n        // Wait for filters to be initialized.\n        await this.handlersInitPromise;\n\n        for (let i = 0; i < filters.length; i++) {\n            if (this.shouldFilterBeApplied(filters[i], options, site)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check whether a filter should be applied in a certain site and with certain options.\n     *\n     * @param filter Filter to check.\n     * @param options Options passed to the filters.\n     * @param site Site. If not defined, current site.\n     * @returns Whether the filter should be applied.\n     */\n    protected shouldFilterBeApplied(filter: CoreFilterFilter, options: CoreFilterFormatTextOptions, site?: CoreSite): boolean {\n        if (!this.hasHandler(filter.filter, true)) {\n            return false;\n        }\n\n        return !!(this.executeFunctionOnEnabled<boolean>(filter.filter, 'shouldBeApplied', [options, site]));\n    }\n\n}\n\nexport const CoreFilterDelegate = makeSingleton(CoreFilterDelegateService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}