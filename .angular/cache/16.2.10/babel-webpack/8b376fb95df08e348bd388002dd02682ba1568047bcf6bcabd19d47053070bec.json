{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreGroups } from '@services/groups';\nimport { CorePluginFileDelegate } from '@services/plugin-file-delegate';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModLesson, AddonModLessonProvider } from '../lesson';\nimport { AddonModLessonSync } from '../lesson-sync';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to prefetch lessons.\n */\nexport class AddonModLessonPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n  constructor() {\n    super(...arguments);\n    this.name = 'AddonModLesson';\n    this.modName = 'lesson';\n    this.component = AddonModLessonProvider.COMPONENT;\n    // Don't check timers to decrease positives. If a user performs some action it will be reflected in other items.\n    this.updatesNames = /^configuration$|^.*files$|^grades$|^gradeitems$|^pages$|^answers$|^questionattempts$|^pagesviewed$/;\n  }\n  /**\n   * Get the download size of a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @returns Promise resolved with the size.\n   */\n  getDownloadSize(module, courseId, single) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const siteId = CoreSites.getCurrentSiteId();\n      let lesson = yield AddonModLesson.getLesson(courseId, module.id, {\n        siteId\n      });\n      // Get the lesson password if it's needed.\n      const passwordData = yield _this.getLessonPassword(lesson.id, {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        askPassword: single,\n        siteId\n      });\n      lesson = passwordData.lesson || lesson;\n      // Get intro files and media files.\n      let files = lesson.mediafiles || [];\n      files = files.concat(_this.getIntroFilesFromInstance(module, lesson));\n      const result = yield CorePluginFileDelegate.getFilesDownloadSize(files);\n      // Get the pages to calculate the size.\n      const pages = yield AddonModLesson.getPages(lesson.id, {\n        cmId: module.id,\n        password: passwordData.password,\n        siteId\n      });\n      pages.forEach(page => {\n        result.size += page.filessizetotal;\n      });\n      return result;\n    })();\n  }\n  /**\n   * Get the lesson password if needed. If not stored, it can ask the user to enter it.\n   *\n   * @param lessonId Lesson ID.\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  getLessonPassword(lessonId, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      // Get access information to check if password is needed.\n      const accessInfo = yield AddonModLesson.getAccessInformation(lessonId, options);\n      if (!accessInfo.preventaccessreasons.length) {\n        // Password not needed.\n        return {\n          accessInfo\n        };\n      }\n      const passwordNeeded = accessInfo.preventaccessreasons.length == 1 && AddonModLesson.isPasswordProtected(accessInfo);\n      if (!passwordNeeded) {\n        // Lesson cannot be played, reject.\n        throw new CoreError(accessInfo.preventaccessreasons[0].message);\n      }\n      // The lesson requires a password. Check if there is one in DB.\n      let password = yield CoreUtils.ignoreErrors(AddonModLesson.getStoredPassword(lessonId));\n      if (password) {\n        try {\n          return yield _this2.validatePassword(lessonId, accessInfo, password, options);\n        } catch (_unused) {\n          // Error validating it.\n        }\n      }\n      // Ask for the password if allowed.\n      if (!options.askPassword) {\n        // Cannot ask for password, reject.\n        throw new CoreError(accessInfo.preventaccessreasons[0].message);\n      }\n      // Create and show the modal.\n      const response = yield CoreDomUtils.promptPassword({\n        title: 'addon.mod_lesson.enterpassword',\n        placeholder: 'core.login.password',\n        submit: 'addon.mod_lesson.continue'\n      });\n      password = response.password;\n      return _this2.validatePassword(lessonId, accessInfo, password, options);\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId The course ID the module belongs to.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId) {\n    return _asyncToGenerator(function* () {\n      // Only invalidate the data that doesn't ignore cache when prefetching.\n      yield Promise.all([AddonModLesson.invalidateLessonData(courseId), CoreCourse.invalidateModule(moduleId), CoreGroups.invalidateActivityAllowedGroups(moduleId)]);\n    })();\n  }\n  /**\n   * Invalidate WS calls needed to determine module status.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when invalidated.\n   */\n  invalidateModule(module, courseId) {\n    return _asyncToGenerator(function* () {\n      // Invalidate data to determine if module is downloadable.\n      const siteId = CoreSites.getCurrentSiteId();\n      const lesson = yield AddonModLesson.getLesson(courseId, module.id, {\n        readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n        siteId\n      });\n      yield Promise.all([AddonModLesson.invalidateLessonData(courseId, siteId), AddonModLesson.invalidateAccessInformation(lesson.id, siteId)]);\n    })();\n  }\n  /**\n   * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Whether the module can be downloaded. The promise should never be rejected.\n   */\n  isDownloadable(module, courseId) {\n    return _asyncToGenerator(function* () {\n      const siteId = CoreSites.getCurrentSiteId();\n      const lesson = yield AddonModLesson.getLesson(courseId, module.id, {\n        siteId\n      });\n      const accessInfo = yield AddonModLesson.getAccessInformation(lesson.id, {\n        cmId: module.id,\n        siteId\n      });\n      // If it's a student and lesson isn't offline, it isn't downloadable.\n      if (!accessInfo.canviewreports && !AddonModLesson.isLessonOffline(lesson)) {\n        return false;\n      }\n      // It's downloadable if there are no prevent access reasons or there is just 1 and it's password.\n      return !accessInfo.preventaccessreasons.length || accessInfo.preventaccessreasons.length == 1 && AddonModLesson.isPasswordProtected(accessInfo);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  prefetch(module, courseId, single) {\n    return this.prefetchPackage(module, courseId, siteId => this.prefetchLesson(module, courseId, !!single, siteId));\n  }\n  /**\n   * Prefetch a lesson.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  prefetchLesson(module, courseId, single, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const commonOptions = {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      const modOptions = _objectSpread({\n        cmId: module.id\n      }, commonOptions);\n      let lesson = yield AddonModLesson.getLesson(courseId, module.id, commonOptions);\n      // Get the lesson password if it's needed.\n      const passwordData = yield _this3.getLessonPassword(lesson.id, {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        askPassword: single,\n        siteId\n      });\n      lesson = passwordData.lesson || lesson;\n      let accessInfo = passwordData.accessInfo;\n      const password = passwordData.password;\n      if (AddonModLesson.isLessonOffline(lesson) && !AddonModLesson.leftDuringTimed(accessInfo)) {\n        // The user didn't left during a timed session. Call launch retake to make sure there is a started retake.\n        accessInfo = yield _this3.launchRetake(lesson.id, password, modOptions, siteId);\n      }\n      const promises = [];\n      // Download intro files and media files.\n      let files = lesson.mediafiles || [];\n      files = files.concat(_this3.getIntroFilesFromInstance(module, lesson));\n      promises.push(CoreFilepool.addFilesToQueue(siteId, files, _this3.component, module.id));\n      if (AddonModLesson.isLessonOffline(lesson)) {\n        promises.push(_this3.prefetchPlayData(lesson, password, accessInfo.attemptscount, modOptions));\n      }\n      if (accessInfo.canviewreports) {\n        promises.push(_this3.prefetchGroupInfo(module.id, lesson.id, modOptions));\n        promises.push(_this3.prefetchReportsData(module.id, lesson.id, modOptions));\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Launch a retake and return the updated access information.\n   *\n   * @param lessonId Lesson ID.\n   * @param password Password (if needed).\n   * @param modOptions Options.\n   * @param siteId Site ID.\n   * @returns Access information.\n   */\n  launchRetake(lessonId, password, modOptions, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // The user didn't left during a timed session. Call launch retake to make sure there is a started retake.\n      yield AddonModLesson.launchRetake(lessonId, password, undefined, false, siteId);\n      const results = yield Promise.all([CoreUtils.ignoreErrors(CoreFilepool.updatePackageDownloadTime(siteId, _this4.component, module.id)), AddonModLesson.getAccessInformation(lessonId, modOptions)]);\n      return results[1];\n    })();\n  }\n  /**\n   * Prefetch data to play the lesson in offline.\n   *\n   * @param lesson Lesson.\n   * @param password Password (if needed).\n   * @param retake Retake to prefetch.\n   * @param modOptions Options.\n   * @returns Promise resolved when done.\n   */\n  prefetchPlayData(lesson, password, retake, modOptions) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const passwordOptions = _objectSpread({\n        password\n      }, modOptions);\n      yield Promise.all([_this5.prefetchPagesData(lesson, passwordOptions),\n      // Prefetch user timers to be able to calculate timemodified in offline.\n      CoreUtils.ignoreErrors(AddonModLesson.getTimers(lesson.id, modOptions)),\n      // Prefetch viewed pages in last retake to calculate progress.\n      AddonModLesson.getContentPagesViewedOnline(lesson.id, retake, modOptions),\n      // Prefetch question attempts in last retake for offline calculations.\n      AddonModLesson.getQuestionsAttemptsOnline(lesson.id, retake, modOptions)]);\n    })();\n  }\n  /**\n   * Prefetch data related to pages.\n   *\n   * @param lesson Lesson.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  prefetchPagesData(lesson, options) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const pages = yield AddonModLesson.getPages(lesson.id, options);\n      let hasRandomBranch = false;\n      // Get the data for each page.\n      const promises = pages.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (data) {\n          // Check if any page has a RANDOMBRANCH jump.\n          if (!hasRandomBranch) {\n            hasRandomBranch = data.jumps.some(jump => jump === AddonModLessonProvider.LESSON_RANDOMBRANCH);\n          }\n          // Get the page data. We don't pass accessInfo because we don't need to calculate the offline data.\n          const pageData = yield AddonModLesson.getPageData(lesson, data.page.id, _objectSpread({\n            includeContents: true,\n            includeOfflineData: false\n          }, options));\n          // Download the page files.\n          let pageFiles = pageData.contentfiles || [];\n          pageData.answers.forEach(answer => {\n            pageFiles = pageFiles.concat(answer.answerfiles);\n            pageFiles = pageFiles.concat(answer.responsefiles);\n          });\n          yield CoreFilepool.addFilesToQueue(options.siteId, pageFiles, _this6.component, module.id);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      // Prefetch the list of possible jumps for offline navigation. Do it here because we know hasRandomBranch.\n      promises.push(_this6.prefetchPossibleJumps(lesson.id, hasRandomBranch, options));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Prefetch possible jumps.\n   *\n   * @param lessonId Lesson ID.\n   * @param hasRandomBranch Whether any page has a random branch jump.\n   * @param modOptions Options.\n   * @returns Promise resolved when done.\n   */\n  prefetchPossibleJumps(lessonId, hasRandomBranch, modOptions) {\n    return _asyncToGenerator(function* () {\n      try {\n        yield AddonModLesson.getPagesPossibleJumps(lessonId, modOptions);\n      } catch (error) {\n        if (hasRandomBranch) {\n          // The WebSevice probably failed because RANDOMBRANCH aren't supported if the user hasn't seen any page.\n          throw new CoreError(Translate.instant('addon.mod_lesson.errorprefetchrandombranch'));\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Prefetch group info.\n   *\n   * @param moduleId Module ID.\n   * @param lessonId Lesson ID.\n   * @param modOptions Options.\n   * @returns Promise resolved when done.\n   */\n  prefetchGroupInfo(moduleId, lessonId, modOptions) {\n    return _asyncToGenerator(function* () {\n      const groupInfo = yield CoreGroups.getActivityGroupInfo(moduleId, false, undefined, modOptions.siteId, true);\n      yield Promise.all(groupInfo.groups.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (group) {\n          yield AddonModLesson.getRetakesOverview(lessonId, _objectSpread({\n            groupId: group.id\n          }, modOptions));\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()) || []);\n    })();\n  }\n  /**\n   * Prefetch reports data.\n   *\n   * @param moduleId Module ID.\n   * @param lessonId Lesson ID.\n   * @param modOptions Options.\n   * @returns Promise resolved when done.\n   */\n  prefetchReportsData(moduleId, lessonId, modOptions) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      // Always get all participants, even if there are no groups.\n      const data = yield AddonModLesson.getRetakesOverview(lessonId, modOptions);\n      if (!data || !data.students) {\n        return;\n      }\n      // Prefetch the last retake for each user.\n      yield Promise.all(data.students.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (student) {\n          var _student$attempts;\n          const lastRetake = (_student$attempts = student.attempts) === null || _student$attempts === void 0 ? void 0 : _student$attempts[student.attempts.length - 1];\n          if (!lastRetake) {\n            return;\n          }\n          const attempt = yield AddonModLesson.getUserRetake(lessonId, lastRetake.try, _objectSpread({\n            userId: student.id\n          }, modOptions));\n          if (!(attempt !== null && attempt !== void 0 && attempt.answerpages)) {\n            return;\n          }\n          // Download embedded files in essays.\n          const files = [];\n          attempt.answerpages.forEach(answerPage => {\n            var _answerPage$answerdat;\n            if (!answerPage.page || answerPage.page.qtype != AddonModLessonProvider.LESSON_PAGE_ESSAY) {\n              return;\n            }\n            (_answerPage$answerdat = answerPage.answerdata) === null || _answerPage$answerdat === void 0 || (_answerPage$answerdat = _answerPage$answerdat.answers) === null || _answerPage$answerdat === void 0 || _answerPage$answerdat.forEach(answer => {\n              files.push(...CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(answer[0]));\n            });\n          });\n          yield CoreFilepool.addFilesToQueue(modOptions.siteId, files, _this7.component, moduleId);\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Validate the password.\n   *\n   * @param lessonId Lesson ID.\n   * @param accessInfo Lesson access info.\n   * @param password Password to check.\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  validatePassword(lessonId, accessInfo, password, options = {}) {\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      const lesson = yield AddonModLesson.getLessonWithPassword(lessonId, _objectSpread({\n        password\n      }, options));\n      // Password is ok, store it and return the data.\n      yield AddonModLesson.storePassword(lesson.id, password, options.siteId);\n      return {\n        password,\n        lesson,\n        accessInfo\n      };\n    })();\n  }\n  /**\n   * Sync a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  sync(module, courseId, siteId) {\n    return AddonModLessonSync.syncLesson(module.instance, false, false, siteId);\n  }\n}\n_class = AddonModLessonPrefetchHandlerService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵAddonModLessonPrefetchHandlerService_BaseFactory;\n  return function AddonModLessonPrefetchHandlerService_Factory(t) {\n    return (ɵAddonModLessonPrefetchHandlerService_BaseFactory || (ɵAddonModLessonPrefetchHandlerService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModLessonPrefetchHandler = makeSingleton(AddonModLessonPrefetchHandlerService);","map":{"version":3,"names":["CoreError","CoreCourseActivityPrefetchHandlerBase","CoreCourse","CoreFilepool","CoreGroups","CorePluginFileDelegate","CoreSites","CoreDomUtils","CoreUtils","makeSingleton","Translate","AddonModLesson","AddonModLessonProvider","AddonModLessonSync","AddonModLessonPrefetchHandlerService","constructor","name","modName","component","COMPONENT","updatesNames","getDownloadSize","module","courseId","single","_this","_asyncToGenerator","siteId","getCurrentSiteId","lesson","getLesson","id","passwordData","getLessonPassword","readingStrategy","askPassword","files","mediafiles","concat","getIntroFilesFromInstance","result","getFilesDownloadSize","pages","getPages","cmId","password","forEach","page","size","filessizetotal","lessonId","options","_this2","accessInfo","getAccessInformation","preventaccessreasons","length","passwordNeeded","isPasswordProtected","message","ignoreErrors","getStoredPassword","validatePassword","_unused","response","promptPassword","title","placeholder","submit","invalidateContent","moduleId","Promise","all","invalidateLessonData","invalidateModule","invalidateActivityAllowedGroups","invalidateAccessInformation","isDownloadable","canviewreports","isLessonOffline","prefetch","prefetchPackage","prefetchLesson","_this3","commonOptions","modOptions","_objectSpread","leftDuringTimed","launchRetake","promises","push","addFilesToQueue","prefetchPlayData","attemptscount","prefetchGroupInfo","prefetchReportsData","_this4","undefined","results","updatePackageDownloadTime","retake","_this5","passwordOptions","prefetchPagesData","getTimers","getContentPagesViewedOnline","getQuestionsAttemptsOnline","_this6","hasRandomBranch","map","_ref","data","jumps","some","jump","LESSON_RANDOMBRANCH","pageData","getPageData","includeContents","includeOfflineData","pageFiles","contentfiles","answers","answer","answerfiles","responsefiles","_x","apply","arguments","prefetchPossibleJumps","getPagesPossibleJumps","error","instant","groupInfo","getActivityGroupInfo","groups","_ref2","group","getRetakesOverview","groupId","_x2","_this7","students","_ref3","student","_student$attempts","lastRetake","attempts","attempt","getUserRetake","try","userId","answerpages","answerPage","_answerPage$answerdat","qtype","LESSON_PAGE_ESSAY","answerdata","extractDownloadableFilesFromHtmlAsFakeFileObjects","_x3","getLessonWithPassword","storePassword","sync","syncLesson","instance","t","factory","ɵfac","providedIn","AddonModLessonPrefetchHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/lesson/services/handlers/prefetch.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\n\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourse, CoreCourseCommonModWSOptions, CoreCourseAnyModuleData } from '@features/course/services/course';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreGroups } from '@services/groups';\nimport { CoreFileSizeSum, CorePluginFileDelegate } from '@services/plugin-file-delegate';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport {\n    AddonModLesson,\n    AddonModLessonGetAccessInformationWSResponse,\n    AddonModLessonLessonWSData,\n    AddonModLessonPasswordOptions,\n    AddonModLessonProvider,\n} from '../lesson';\nimport { AddonModLessonSync, AddonModLessonSyncResult } from '../lesson-sync';\n\n/**\n * Handler to prefetch lessons.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModLessonPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n\n    name = 'AddonModLesson';\n    modName = 'lesson';\n    component = AddonModLessonProvider.COMPONENT;\n    // Don't check timers to decrease positives. If a user performs some action it will be reflected in other items.\n    updatesNames = /^configuration$|^.*files$|^grades$|^gradeitems$|^pages$|^answers$|^questionattempts$|^pagesviewed$/;\n\n    /**\n     * Get the download size of a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @returns Promise resolved with the size.\n     */\n    async getDownloadSize(module: CoreCourseAnyModuleData, courseId: number, single?: boolean): Promise<CoreFileSizeSum> {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        let lesson = await AddonModLesson.getLesson(courseId, module.id, { siteId });\n\n        // Get the lesson password if it's needed.\n        const passwordData = await this.getLessonPassword(lesson.id, {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            askPassword: single,\n            siteId,\n        });\n\n        lesson = passwordData.lesson || lesson;\n\n        // Get intro files and media files.\n        let files: CoreWSFile[] = lesson.mediafiles || [];\n        files = files.concat(this.getIntroFilesFromInstance(module, lesson));\n\n        const result = await CorePluginFileDelegate.getFilesDownloadSize(files);\n\n        // Get the pages to calculate the size.\n        const pages = await AddonModLesson.getPages(lesson.id, {\n            cmId: module.id,\n            password: passwordData.password,\n            siteId,\n        });\n\n        pages.forEach((page) => {\n            result.size += page.filessizetotal;\n        });\n\n        return result;\n    }\n\n    /**\n     * Get the lesson password if needed. If not stored, it can ask the user to enter it.\n     *\n     * @param lessonId Lesson ID.\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    async getLessonPassword(\n        lessonId: number,\n        options: AddonModLessonGetPasswordOptions = {},\n    ): Promise<AddonModLessonGetPasswordResult> {\n\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        // Get access information to check if password is needed.\n        const accessInfo = await AddonModLesson.getAccessInformation(lessonId, options);\n\n        if (!accessInfo.preventaccessreasons.length) {\n            // Password not needed.\n            return { accessInfo };\n        }\n\n        const passwordNeeded = accessInfo.preventaccessreasons.length == 1 &&\n            AddonModLesson.isPasswordProtected(accessInfo);\n\n        if (!passwordNeeded) {\n            // Lesson cannot be played, reject.\n            throw new CoreError(accessInfo.preventaccessreasons[0].message);\n        }\n\n        // The lesson requires a password. Check if there is one in DB.\n        let password = await CoreUtils.ignoreErrors(AddonModLesson.getStoredPassword(lessonId));\n\n        if (password) {\n            try {\n                return await this.validatePassword(lessonId, accessInfo, password, options);\n            } catch {\n                // Error validating it.\n            }\n        }\n\n        // Ask for the password if allowed.\n        if (!options.askPassword) {\n            // Cannot ask for password, reject.\n            throw new CoreError(accessInfo.preventaccessreasons[0].message);\n        }\n\n        // Create and show the modal.\n        const response = await CoreDomUtils.promptPassword({\n            title: 'addon.mod_lesson.enterpassword',\n            placeholder: 'core.login.password',\n            submit: 'addon.mod_lesson.continue',\n        });\n        password = response.password;\n\n        return this.validatePassword(lessonId, accessInfo, password, options);\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId The course ID the module belongs to.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        // Only invalidate the data that doesn't ignore cache when prefetching.\n        await Promise.all([\n            AddonModLesson.invalidateLessonData(courseId),\n            CoreCourse.invalidateModule(moduleId),\n            CoreGroups.invalidateActivityAllowedGroups(moduleId),\n        ]);\n    }\n\n    /**\n     * Invalidate WS calls needed to determine module status.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when invalidated.\n     */\n    async invalidateModule(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        // Invalidate data to determine if module is downloadable.\n        const siteId = CoreSites.getCurrentSiteId();\n\n        const lesson = await AddonModLesson.getLesson(courseId, module.id, {\n            readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n            siteId,\n        });\n\n        await Promise.all([\n            AddonModLesson.invalidateLessonData(courseId, siteId),\n            AddonModLesson.invalidateAccessInformation(lesson.id, siteId),\n        ]);\n    }\n\n    /**\n     * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Whether the module can be downloaded. The promise should never be rejected.\n     */\n    async isDownloadable(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        const lesson = await AddonModLesson.getLesson(courseId, module.id, { siteId });\n        const accessInfo = await AddonModLesson.getAccessInformation(lesson.id, { cmId: module.id, siteId });\n\n        // If it's a student and lesson isn't offline, it isn't downloadable.\n        if (!accessInfo.canviewreports && !AddonModLesson.isLessonOffline(lesson)) {\n            return false;\n        }\n\n        // It's downloadable if there are no prevent access reasons or there is just 1 and it's password.\n        return !accessInfo.preventaccessreasons.length ||\n            (accessInfo.preventaccessreasons.length == 1 && AddonModLesson.isPasswordProtected(accessInfo));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    prefetch(module: CoreCourseAnyModuleData, courseId: number, single?: boolean): Promise<void> {\n        return this.prefetchPackage(module, courseId, (siteId) => this.prefetchLesson(module, courseId, !!single, siteId));\n    }\n\n    /**\n     * Prefetch a lesson.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchLesson(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        single: boolean,\n        siteId: string,\n    ): Promise<void> {\n        const commonOptions = {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n        const modOptions = {\n            cmId: module.id,\n            ...commonOptions, // Include all common options.\n        };\n\n        let lesson = await AddonModLesson.getLesson(courseId, module.id, commonOptions);\n\n        // Get the lesson password if it's needed.\n        const passwordData = await this.getLessonPassword(lesson.id, {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            askPassword: single,\n            siteId,\n        });\n\n        lesson = passwordData.lesson || lesson;\n        let accessInfo = passwordData.accessInfo;\n        const password = passwordData.password;\n\n        if (AddonModLesson.isLessonOffline(lesson) && !AddonModLesson.leftDuringTimed(accessInfo)) {\n            // The user didn't left during a timed session. Call launch retake to make sure there is a started retake.\n            accessInfo = await this.launchRetake(lesson.id, password, modOptions, siteId);\n        }\n\n        const promises: Promise<void>[] = [];\n\n        // Download intro files and media files.\n        let files: CoreWSFile[] = (lesson.mediafiles || []);\n        files = files.concat(this.getIntroFilesFromInstance(module, lesson));\n        promises.push(CoreFilepool.addFilesToQueue(siteId, files, this.component, module.id));\n\n        if (AddonModLesson.isLessonOffline(lesson)) {\n            promises.push(this.prefetchPlayData(lesson, password, accessInfo.attemptscount, modOptions));\n        }\n\n        if (accessInfo.canviewreports) {\n            promises.push(this.prefetchGroupInfo(module.id, lesson.id, modOptions));\n            promises.push(this.prefetchReportsData(module.id, lesson.id, modOptions));\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Launch a retake and return the updated access information.\n     *\n     * @param lessonId Lesson ID.\n     * @param password Password (if needed).\n     * @param modOptions Options.\n     * @param siteId Site ID.\n     * @returns Access information.\n     */\n    protected async launchRetake(\n        lessonId: number,\n        password: string | undefined,\n        modOptions: CoreCourseCommonModWSOptions,\n        siteId: string,\n    ): Promise<AddonModLessonGetAccessInformationWSResponse> {\n        // The user didn't left during a timed session. Call launch retake to make sure there is a started retake.\n        await AddonModLesson.launchRetake(lessonId, password, undefined, false, siteId);\n\n        const results = await Promise.all([\n            CoreUtils.ignoreErrors(CoreFilepool.updatePackageDownloadTime(siteId, this.component, module.id)),\n            AddonModLesson.getAccessInformation(lessonId, modOptions),\n        ]);\n\n        return results[1];\n    }\n\n    /**\n     * Prefetch data to play the lesson in offline.\n     *\n     * @param lesson Lesson.\n     * @param password Password (if needed).\n     * @param retake Retake to prefetch.\n     * @param modOptions Options.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchPlayData(\n        lesson: AddonModLessonLessonWSData,\n        password: string | undefined,\n        retake: number,\n        modOptions: CoreCourseCommonModWSOptions,\n    ): Promise<void> {\n        const passwordOptions = {\n            password,\n            ...modOptions, // Include all mod options.\n        };\n\n        await Promise.all([\n            this.prefetchPagesData(lesson, passwordOptions),\n            // Prefetch user timers to be able to calculate timemodified in offline.\n            CoreUtils.ignoreErrors(AddonModLesson.getTimers(lesson.id, modOptions)),\n            // Prefetch viewed pages in last retake to calculate progress.\n            AddonModLesson.getContentPagesViewedOnline(lesson.id, retake, modOptions),\n            // Prefetch question attempts in last retake for offline calculations.\n            AddonModLesson.getQuestionsAttemptsOnline(lesson.id, retake, modOptions),\n        ]);\n    }\n\n    /**\n     * Prefetch data related to pages.\n     *\n     * @param lesson Lesson.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchPagesData(\n        lesson: AddonModLessonLessonWSData,\n        options: AddonModLessonPasswordOptions,\n    ): Promise<void> {\n        const pages = await AddonModLesson.getPages(lesson.id, options);\n\n        let hasRandomBranch = false;\n\n        // Get the data for each page.\n        const promises = pages.map(async (data) => {\n            // Check if any page has a RANDOMBRANCH jump.\n            if (!hasRandomBranch) {\n                hasRandomBranch = data.jumps.some((jump) => jump === AddonModLessonProvider.LESSON_RANDOMBRANCH);\n            }\n\n            // Get the page data. We don't pass accessInfo because we don't need to calculate the offline data.\n            const pageData = await AddonModLesson.getPageData(lesson, data.page.id, {\n                includeContents: true,\n                includeOfflineData: false,\n                ...options, // Include all options.\n            });\n\n            // Download the page files.\n            let pageFiles = pageData.contentfiles || [];\n\n            pageData.answers.forEach((answer) => {\n                pageFiles = pageFiles.concat(answer.answerfiles);\n                pageFiles = pageFiles.concat(answer.responsefiles);\n            });\n\n            await CoreFilepool.addFilesToQueue(options.siteId!, pageFiles, this.component, module.id);\n        });\n\n        // Prefetch the list of possible jumps for offline navigation. Do it here because we know hasRandomBranch.\n        promises.push(this.prefetchPossibleJumps(lesson.id, hasRandomBranch, options));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Prefetch possible jumps.\n     *\n     * @param lessonId Lesson ID.\n     * @param hasRandomBranch Whether any page has a random branch jump.\n     * @param modOptions Options.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchPossibleJumps(\n        lessonId: number,\n        hasRandomBranch: boolean,\n        modOptions: CoreCourseCommonModWSOptions,\n    ): Promise<void> {\n        try {\n            await AddonModLesson.getPagesPossibleJumps(lessonId, modOptions);\n        } catch (error) {\n            if (hasRandomBranch) {\n                // The WebSevice probably failed because RANDOMBRANCH aren't supported if the user hasn't seen any page.\n                throw new CoreError(Translate.instant('addon.mod_lesson.errorprefetchrandombranch'));\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Prefetch group info.\n     *\n     * @param moduleId Module ID.\n     * @param lessonId Lesson ID.\n     * @param modOptions Options.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchGroupInfo(\n        moduleId: number,\n        lessonId: number,\n        modOptions: CoreCourseCommonModWSOptions,\n    ): Promise<void> {\n        const groupInfo = await CoreGroups.getActivityGroupInfo(moduleId, false, undefined, modOptions.siteId, true);\n\n        await Promise.all(groupInfo.groups.map(async (group) => {\n            await AddonModLesson.getRetakesOverview(lessonId, {\n                groupId: group.id,\n                ...modOptions, // Include all options.\n            });\n        }) || []);\n    }\n\n    /**\n     * Prefetch reports data.\n     *\n     * @param moduleId Module ID.\n     * @param lessonId Lesson ID.\n     * @param modOptions Options.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchReportsData(\n        moduleId: number,\n        lessonId: number,\n        modOptions: CoreCourseCommonModWSOptions,\n    ): Promise<void> {\n        // Always get all participants, even if there are no groups.\n        const data = await AddonModLesson.getRetakesOverview(lessonId, modOptions);\n        if (!data || !data.students) {\n            return;\n        }\n\n        // Prefetch the last retake for each user.\n        await Promise.all(data.students.map(async (student) => {\n            const lastRetake = student.attempts?.[student.attempts.length - 1];\n            if (!lastRetake) {\n                return;\n            }\n\n            const attempt = await AddonModLesson.getUserRetake(lessonId, lastRetake.try, {\n                userId: student.id,\n                ...modOptions, // Include all options.\n            });\n\n            if (!attempt?.answerpages) {\n                return;\n            }\n\n            // Download embedded files in essays.\n            const files: CoreWSFile[] = [];\n            attempt.answerpages.forEach((answerPage) => {\n                if (!answerPage.page || answerPage.page.qtype != AddonModLessonProvider.LESSON_PAGE_ESSAY) {\n                    return;\n                }\n\n                answerPage.answerdata?.answers?.forEach((answer) => {\n                    files.push(...CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(answer[0]));\n                });\n            });\n\n            await CoreFilepool.addFilesToQueue(modOptions.siteId!, files, this.component, moduleId);\n        }));\n    }\n\n    /**\n     * Validate the password.\n     *\n     * @param lessonId Lesson ID.\n     * @param accessInfo Lesson access info.\n     * @param password Password to check.\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    protected async validatePassword(\n        lessonId: number,\n        accessInfo: AddonModLessonGetAccessInformationWSResponse,\n        password: string,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModLessonGetPasswordResult> {\n\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        const lesson = await AddonModLesson.getLessonWithPassword(lessonId, {\n            password,\n            ...options, // Include all options.\n        });\n\n        // Password is ok, store it and return the data.\n        await AddonModLesson.storePassword(lesson.id, password, options.siteId);\n\n        return {\n            password,\n            lesson,\n            accessInfo,\n        };\n    }\n\n    /**\n     * Sync a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    sync(module: CoreCourseAnyModuleData, courseId: number, siteId?: string): Promise<AddonModLessonSyncResult> {\n        return AddonModLessonSync.syncLesson(module.instance, false, false, siteId);\n    }\n\n}\n\nexport const AddonModLessonPrefetchHandler = makeSingleton(AddonModLessonPrefetchHandlerService);\n\n/**\n * Options to pass to get lesson password.\n */\nexport type AddonModLessonGetPasswordOptions = CoreCourseCommonModWSOptions & {\n    askPassword?: boolean; // True if we should ask for password if needed, false otherwise.\n};\n\n/**\n * Result of getLessonPassword.\n */\nexport type AddonModLessonGetPasswordResult = {\n    password?: string;\n    lesson?: AddonModLessonLessonWSData;\n    accessInfo: AddonModLessonGetAccessInformationWSResponse;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}