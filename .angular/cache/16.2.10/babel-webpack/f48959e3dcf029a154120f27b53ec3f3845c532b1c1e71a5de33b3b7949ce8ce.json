{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreRatingSync } from '@features/rating/services/rating-sync';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModGlossary, AddonModGlossaryProvider } from './glossary';\nimport { AddonModGlossaryHelper } from './glossary-helper';\nimport { AddonModGlossaryOffline } from './glossary-offline';\nimport { CoreFileUploader } from '@features/fileuploader/services/fileuploader';\nimport * as i0 from \"@angular/core\";\nexport const GLOSSARY_AUTO_SYNCED = 'addon_mod_glossary_auto_synced';\n/**\n * Service to sync glossaries.\n */\nexport class AddonModGlossarySyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModGlossarySyncProvider');\n    this.componentTranslatableString = 'glossary';\n  }\n  /**\n   * Try to synchronize all the glossaries in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   */\n  syncAllGlossaries(siteId, force) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this.syncOnSites('all glossaries', siteId => _this.syncAllGlossariesFunc(!!force, siteId), siteId);\n    })();\n  }\n  /**\n   * Sync all glossaries on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   */\n  syncAllGlossariesFunc(force, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield Promise.all([_this2.syncAllGlossariesEntries(force, siteId), _this2.syncRatings(undefined, force, siteId)]);\n    })();\n  }\n  /**\n   * Sync entries of all glossaries on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   */\n  syncAllGlossariesEntries(force, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const entries = yield AddonModGlossaryOffline.getAllOfflineEntries(siteId);\n      // Do not sync same glossary twice.\n      const treated = {};\n      yield Promise.all(entries.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (entry) {\n          if (treated[entry.glossaryid]) {\n            return;\n          }\n          treated[entry.glossaryid] = true;\n          const result = force ? yield _this3.syncGlossaryEntries(entry.glossaryid, entry.userid, siteId) : yield _this3.syncGlossaryEntriesIfNeeded(entry.glossaryid, entry.userid, siteId);\n          if (result !== null && result !== void 0 && result.updated) {\n            // Sync successful, send event.\n            CoreEvents.trigger(GLOSSARY_AUTO_SYNCED, {\n              glossaryId: entry.glossaryid,\n              userId: entry.userid,\n              warnings: result.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Sync a glossary only if a certain time has passed since the last time.\n   *\n   * @param glossaryId Glossary ID.\n   * @param userId User the entry belong to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the glossary is synced or if it doesn't need to be synced.\n   */\n  syncGlossaryEntriesIfNeeded(glossaryId, userId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const syncId = _this4.getGlossarySyncId(glossaryId, userId);\n      const needed = yield _this4.isSyncNeeded(syncId, siteId);\n      if (needed) {\n        return _this4.syncGlossaryEntries(glossaryId, userId, siteId);\n      }\n    })();\n  }\n  /**\n   * Synchronize all offline entries of a glossary.\n   *\n   * @param glossaryId Glossary ID to be synced.\n   * @param userId User the entries belong to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncGlossaryEntries(glossaryId, userId, siteId) {\n    userId = userId || CoreSites.getCurrentSiteUserId();\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const syncId = this.getGlossarySyncId(glossaryId, userId);\n    const currentSyncPromise = this.getOngoingSync(syncId, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for this glossary, return the promise.\n      return currentSyncPromise;\n    }\n    // Verify that glossary isn't blocked.\n    if (CoreSync.isBlocked(AddonModGlossaryProvider.COMPONENT, syncId, siteId)) {\n      this.logger.debug('Cannot sync glossary ' + glossaryId + ' because it is blocked.');\n      throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', {\n        $a: this.componentTranslate\n      }));\n    }\n    this.logger.debug('Try to sync glossary ' + glossaryId + ' for user ' + userId);\n    const syncPromise = this.performSyncGlossaryEntries(glossaryId, userId, siteId);\n    return this.addOngoingSync(syncId, syncPromise, siteId);\n  }\n  performSyncGlossaryEntries(glossaryId, userId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      const syncId = _this5.getGlossarySyncId(glossaryId, userId);\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModGlossaryProvider.COMPONENT, glossaryId, siteId));\n      // Get offline responses to be sent.\n      const entries = yield CoreUtils.ignoreErrors(AddonModGlossaryOffline.getGlossaryOfflineEntries(glossaryId, siteId, userId), []);\n      if (!entries.length) {\n        // Nothing to sync.\n        yield CoreUtils.ignoreErrors(_this5.setSyncTime(syncId, siteId));\n        return result;\n      } else if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      let courseId;\n      yield Promise.all(entries.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (data) {\n          courseId = courseId || data.courseid;\n          try {\n            // First of all upload the attachments (if any).\n            const itemId = yield _this5.uploadAttachments(glossaryId, data, siteId);\n            // Now try to add the entry.\n            yield AddonModGlossary.addEntryOnline(glossaryId, data.concept, data.definition, data.options, itemId, siteId);\n            result.updated = true;\n            yield _this5.deleteAddEntry(glossaryId, data.concept, data.timecreated, siteId);\n          } catch (error) {\n            if (!CoreUtils.isWebServiceError(error)) {\n              // Couldn't connect to server, reject.\n              throw error;\n            }\n            // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.\n            result.updated = true;\n            yield _this5.deleteAddEntry(glossaryId, data.concept, data.timecreated, siteId);\n            // Responses deleted, add a warning.\n            _this5.addOfflineDataDeletedWarning(result.warnings, data.concept, error);\n          }\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      if (result.updated && courseId) {\n        // Data has been sent to server. Now invalidate the WS calls.\n        try {\n          const glossary = yield AddonModGlossary.getGlossaryById(courseId, glossaryId);\n          yield AddonModGlossary.invalidateGlossaryEntries(glossary, true);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n      }\n      // Sync finished, set sync time.\n      yield CoreUtils.ignoreErrors(_this5.setSyncTime(syncId, siteId));\n      return result;\n    })();\n  }\n  /**\n   * Synchronize offline ratings.\n   *\n   * @param cmId Course module to be synced. If not defined, sync all glossaries.\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncRatings(cmId, force, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const results = yield CoreRatingSync.syncRatings('mod_glossary', 'entry', \"module\" /* ContextLevel.MODULE */, cmId, 0, force, siteId);\n      let updated = false;\n      const warnings = [];\n      yield CoreUtils.allPromises(results.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (result) {\n          if (result.updated.length) {\n            updated = true;\n            // Invalidate entry of updated ratings.\n            yield Promise.all(result.updated.map(itemId => AddonModGlossary.invalidateEntry(itemId, siteId)));\n          }\n          if (result.warnings.length) {\n            const glossary = yield AddonModGlossary.getGlossary(result.itemSet.courseId, result.itemSet.instanceId, {\n              siteId\n            });\n            result.warnings.forEach(warning => {\n              _this6.addOfflineDataDeletedWarning(warnings, glossary.name, warning);\n            });\n          }\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return {\n        updated,\n        warnings\n      };\n    })();\n  }\n  /**\n   * Delete a new entry.\n   *\n   * @param glossaryId Glossary ID.\n   * @param concept Glossary entry concept.\n   * @param timeCreated Time to allow duplicated entries.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  deleteAddEntry(glossaryId, concept, timeCreated, siteId) {\n    return _asyncToGenerator(function* () {\n      yield Promise.all([AddonModGlossaryOffline.deleteOfflineEntry(glossaryId, timeCreated, siteId), AddonModGlossaryHelper.deleteStoredFiles(glossaryId, concept, timeCreated, siteId)]);\n    })();\n  }\n  /**\n   * Upload attachments of an offline entry.\n   *\n   * @param glossaryId Glossary ID.\n   * @param entry Offline entry.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with draftid if uploaded, resolved with 0 if nothing to upload.\n   */\n  uploadAttachments(glossaryId, entry, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!entry.attachments) {\n        // No attachments.\n        return 0;\n      }\n      // Has some attachments to sync.\n      let files = entry.attachments.online || [];\n      if (entry.attachments.offline) {\n        // Has offline files.\n        const storedFiles = yield CoreUtils.ignoreErrors(AddonModGlossaryHelper.getStoredFiles(glossaryId, entry.concept, entry.timecreated, siteId), []);\n        files = files.concat(storedFiles);\n      }\n      return CoreFileUploader.uploadOrReuploadFiles(files, AddonModGlossaryProvider.COMPONENT, glossaryId, siteId);\n    })();\n  }\n  /**\n   * Get the ID of a glossary sync.\n   *\n   * @param glossaryId Glossary ID.\n   * @param userId User the entries belong to.. If not defined, current user.\n   * @returns Sync ID.\n   */\n  getGlossarySyncId(glossaryId, userId) {\n    userId = userId || CoreSites.getCurrentSiteUserId();\n    return 'glossary#' + glossaryId + '#' + userId;\n  }\n}\n_class = AddonModGlossarySyncProvider;\n_class.ɵfac = function AddonModGlossarySyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModGlossarySync = makeSingleton(AddonModGlossarySyncProvider);","map":{"version":3,"names":["CoreSyncBlockedError","CoreNetworkError","CoreCourseActivitySyncBaseProvider","CoreCourseLogHelper","CoreRatingSync","CoreNetwork","CoreSites","CoreSync","CoreUtils","makeSingleton","Translate","CoreEvents","AddonModGlossary","AddonModGlossaryProvider","AddonModGlossaryHelper","AddonModGlossaryOffline","CoreFileUploader","GLOSSARY_AUTO_SYNCED","AddonModGlossarySyncProvider","constructor","componentTranslatableString","syncAllGlossaries","siteId","force","_this","_asyncToGenerator","syncOnSites","syncAllGlossariesFunc","_this2","getCurrentSiteId","Promise","all","syncAllGlossariesEntries","syncRatings","undefined","_this3","entries","getAllOfflineEntries","treated","map","_ref","entry","glossaryid","result","syncGlossaryEntries","userid","syncGlossaryEntriesIfNeeded","updated","trigger","glossaryId","userId","warnings","_x","apply","arguments","_this4","syncId","getGlossarySyncId","needed","isSyncNeeded","getCurrentSiteUserId","currentSyncPromise","getOngoingSync","isBlocked","COMPONENT","logger","debug","instant","$a","componentTranslate","syncPromise","performSyncGlossaryEntries","addOngoingSync","_this5","ignoreErrors","syncActivity","getGlossaryOfflineEntries","length","setSyncTime","isOnline","courseId","_ref2","data","courseid","itemId","uploadAttachments","addEntryOnline","concept","definition","options","deleteAddEntry","timecreated","error","isWebServiceError","addOfflineDataDeletedWarning","_x2","glossary","getGlossaryById","invalidateGlossaryEntries","_unused","cmId","_this6","results","allPromises","_ref3","invalidateEntry","getGlossary","itemSet","instanceId","forEach","warning","name","_x3","timeCreated","deleteOfflineEntry","deleteStoredFiles","attachments","files","online","offline","storedFiles","getStoredFiles","concat","uploadOrReuploadFiles","factory","ɵfac","providedIn","AddonModGlossarySync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/glossary/services/glossary-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { ContextLevel } from '@/core/constants';\nimport { Injectable } from '@angular/core';\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreRatingSync } from '@features/rating/services/rating-sync';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModGlossary, AddonModGlossaryProvider } from './glossary';\nimport { AddonModGlossaryHelper } from './glossary-helper';\nimport { AddonModGlossaryOffline, AddonModGlossaryOfflineEntry } from './glossary-offline';\nimport { CoreFileUploader } from '@features/fileuploader/services/fileuploader';\nimport { CoreFileEntry } from '@services/file-helper';\n\nexport const GLOSSARY_AUTO_SYNCED = 'addon_mod_glossary_auto_synced';\n\n/**\n * Service to sync glossaries.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModGlossarySyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModGlossarySyncResult> {\n\n    protected componentTranslatableString = 'glossary';\n\n    constructor() {\n        super('AddonModGlossarySyncProvider');\n    }\n\n    /**\n     * Try to synchronize all the glossaries in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     */\n    async syncAllGlossaries(siteId?: string, force?: boolean): Promise<void> {\n        await this.syncOnSites('all glossaries', (siteId) => this.syncAllGlossariesFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all glossaries on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     */\n    protected async syncAllGlossariesFunc(force: boolean, siteId: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await Promise.all([\n            this.syncAllGlossariesEntries(force, siteId),\n            this.syncRatings(undefined, force, siteId),\n        ]);\n    }\n\n    /**\n     * Sync entries of all glossaries on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     */\n    protected async syncAllGlossariesEntries(force: boolean, siteId: string): Promise<void> {\n        const entries = await AddonModGlossaryOffline.getAllOfflineEntries(siteId);\n\n        // Do not sync same glossary twice.\n        const treated: Record<number, boolean> = {};\n\n        await Promise.all(entries.map(async (entry) => {\n            if (treated[entry.glossaryid]) {\n                return;\n            }\n\n            treated[entry.glossaryid] = true;\n\n            const result = force ?\n                await this.syncGlossaryEntries(entry.glossaryid, entry.userid, siteId) :\n                await this.syncGlossaryEntriesIfNeeded(entry.glossaryid, entry.userid, siteId);\n\n            if (result?.updated) {\n                // Sync successful, send event.\n                CoreEvents.trigger(GLOSSARY_AUTO_SYNCED, {\n                    glossaryId: entry.glossaryid,\n                    userId: entry.userid,\n                    warnings: result.warnings,\n                }, siteId);\n            }\n        }));\n    }\n\n    /**\n     * Sync a glossary only if a certain time has passed since the last time.\n     *\n     * @param glossaryId Glossary ID.\n     * @param userId User the entry belong to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the glossary is synced or if it doesn't need to be synced.\n     */\n    async syncGlossaryEntriesIfNeeded(\n        glossaryId: number,\n        userId: number,\n        siteId?: string,\n    ): Promise<AddonModGlossarySyncResult | undefined> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const syncId = this.getGlossarySyncId(glossaryId, userId);\n\n        const needed = await this.isSyncNeeded(syncId, siteId);\n\n        if (needed) {\n            return this.syncGlossaryEntries(glossaryId, userId, siteId);\n        }\n    }\n\n    /**\n     * Synchronize all offline entries of a glossary.\n     *\n     * @param glossaryId Glossary ID to be synced.\n     * @param userId User the entries belong to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    syncGlossaryEntries(glossaryId: number, userId?: number, siteId?: string): Promise<AddonModGlossarySyncResult> {\n        userId = userId || CoreSites.getCurrentSiteUserId();\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const syncId = this.getGlossarySyncId(glossaryId, userId);\n        const currentSyncPromise = this.getOngoingSync(syncId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this glossary, return the promise.\n            return currentSyncPromise;\n        }\n\n        // Verify that glossary isn't blocked.\n        if (CoreSync.isBlocked(AddonModGlossaryProvider.COMPONENT, syncId, siteId)) {\n            this.logger.debug('Cannot sync glossary ' + glossaryId + ' because it is blocked.');\n\n            throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));\n        }\n\n        this.logger.debug('Try to sync glossary ' + glossaryId + ' for user ' + userId);\n\n        const syncPromise = this.performSyncGlossaryEntries(glossaryId, userId, siteId);\n\n        return this.addOngoingSync(syncId, syncPromise, siteId);\n    }\n\n    protected async performSyncGlossaryEntries(\n        glossaryId: number,\n        userId: number,\n        siteId: string,\n    ): Promise<AddonModGlossarySyncResult> {\n        const result: AddonModGlossarySyncResult = {\n            warnings: [],\n            updated: false,\n        };\n        const syncId = this.getGlossarySyncId(glossaryId, userId);\n\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModGlossaryProvider.COMPONENT, glossaryId, siteId));\n\n        // Get offline responses to be sent.\n        const entries = await CoreUtils.ignoreErrors(\n            AddonModGlossaryOffline.getGlossaryOfflineEntries(glossaryId, siteId, userId),\n            <AddonModGlossaryOfflineEntry[]> [],\n        );\n\n        if (!entries.length) {\n            // Nothing to sync.\n            await CoreUtils.ignoreErrors(this.setSyncTime(syncId, siteId));\n\n            return result;\n        } else if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        let courseId: number | undefined;\n\n        await Promise.all(entries.map(async (data) => {\n            courseId = courseId || data.courseid;\n\n            try {\n                // First of all upload the attachments (if any).\n                const itemId = await this.uploadAttachments(glossaryId, data, siteId);\n\n                // Now try to add the entry.\n                await AddonModGlossary.addEntryOnline(glossaryId, data.concept, data.definition, data.options, itemId, siteId);\n\n                result.updated = true;\n\n                await this.deleteAddEntry(glossaryId, data.concept, data.timecreated, siteId);\n            } catch (error) {\n                if (!CoreUtils.isWebServiceError(error)) {\n                    // Couldn't connect to server, reject.\n                    throw error;\n                }\n\n                // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.\n                result.updated = true;\n\n                await this.deleteAddEntry(glossaryId, data.concept, data.timecreated, siteId);\n\n                // Responses deleted, add a warning.\n                this.addOfflineDataDeletedWarning(result.warnings, data.concept, error);\n            }\n        }));\n\n        if (result.updated && courseId) {\n            // Data has been sent to server. Now invalidate the WS calls.\n            try {\n                const glossary = await AddonModGlossary.getGlossaryById(courseId, glossaryId);\n\n                await AddonModGlossary.invalidateGlossaryEntries(glossary, true);\n            } catch {\n                // Ignore errors.\n            }\n        }\n\n        // Sync finished, set sync time.\n        await CoreUtils.ignoreErrors(this.setSyncTime(syncId, siteId));\n\n        return result;\n    }\n\n    /**\n     * Synchronize offline ratings.\n     *\n     * @param cmId Course module to be synced. If not defined, sync all glossaries.\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    async syncRatings(cmId?: number, force?: boolean, siteId?: string): Promise<AddonModGlossarySyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const results = await CoreRatingSync.syncRatings('mod_glossary', 'entry', ContextLevel.MODULE, cmId, 0, force, siteId);\n\n        let updated = false;\n        const warnings: string[] = [];\n\n        await CoreUtils.allPromises(results.map(async (result) => {\n            if (result.updated.length) {\n                updated = true;\n\n                // Invalidate entry of updated ratings.\n                await Promise.all(result.updated.map((itemId) => AddonModGlossary.invalidateEntry(itemId, siteId)));\n            }\n\n            if (result.warnings.length) {\n                const glossary = await AddonModGlossary.getGlossary(result.itemSet.courseId, result.itemSet.instanceId, { siteId });\n\n                result.warnings.forEach((warning) => {\n                    this.addOfflineDataDeletedWarning(warnings, glossary.name, warning);\n                });\n            }\n        }));\n\n        return { updated, warnings };\n    }\n\n    /**\n     * Delete a new entry.\n     *\n     * @param glossaryId Glossary ID.\n     * @param concept Glossary entry concept.\n     * @param timeCreated Time to allow duplicated entries.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    protected async deleteAddEntry(glossaryId: number, concept: string, timeCreated: number, siteId?: string): Promise<void> {\n        await Promise.all([\n            AddonModGlossaryOffline.deleteOfflineEntry(glossaryId, timeCreated, siteId),\n            AddonModGlossaryHelper.deleteStoredFiles(glossaryId, concept, timeCreated, siteId),\n        ]);\n    }\n\n    /**\n     * Upload attachments of an offline entry.\n     *\n     * @param glossaryId Glossary ID.\n     * @param entry Offline entry.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with draftid if uploaded, resolved with 0 if nothing to upload.\n     */\n    protected async uploadAttachments(glossaryId: number, entry: AddonModGlossaryOfflineEntry, siteId?: string): Promise<number> {\n        if (!entry.attachments) {\n            // No attachments.\n            return 0;\n        }\n\n        // Has some attachments to sync.\n        let files: CoreFileEntry[] = entry.attachments.online || [];\n\n        if (entry.attachments.offline) {\n            // Has offline files.\n            const storedFiles = await CoreUtils.ignoreErrors(\n                AddonModGlossaryHelper.getStoredFiles(glossaryId, entry.concept, entry.timecreated, siteId),\n                [], // Folder not found, no files to add.\n            );\n\n            files = files.concat(storedFiles);\n        }\n\n        return CoreFileUploader.uploadOrReuploadFiles(files, AddonModGlossaryProvider.COMPONENT, glossaryId, siteId);\n    }\n\n    /**\n     * Get the ID of a glossary sync.\n     *\n     * @param glossaryId Glossary ID.\n     * @param userId User the entries belong to.. If not defined, current user.\n     * @returns Sync ID.\n     */\n    protected getGlossarySyncId(glossaryId: number, userId?: number): string {\n        userId = userId || CoreSites.getCurrentSiteUserId();\n\n        return 'glossary#' + glossaryId + '#' + userId;\n    }\n\n}\n\nexport const AddonModGlossarySync = makeSingleton(AddonModGlossarySyncProvider);\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [GLOSSARY_AUTO_SYNCED]: AddonModGlossaryAutoSyncedData;\n    }\n\n}\n\n/**\n * Data returned by a glossary sync.\n */\nexport type AddonModGlossarySyncResult = CoreSyncResult;\n\n/**\n * Data passed to GLOSSARY_AUTO_SYNCED event.\n */\nexport type AddonModGlossaryAutoSyncedData = {\n    glossaryId: number;\n    userId: number;\n    warnings: string[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}