{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreXAPIOffline } from './offline';\nimport { makeSingleton } from '@singletons';\nimport { CoreXAPIItemAgent } from '../classes/item-agent';\nimport { CoreXAPIIRI } from '../classes/iri';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreLogger } from '@singletons/logger';\nimport * as i0 from \"@angular/core\";\nexport const XAPI_STATE_DELETED = 'STATE_DELETED';\n/**\n * Service to provide XAPI functionalities.\n */\nexport class CoreXAPIProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('CoreXAPIProvider');\n  }\n  /**\n   * Returns whether or not WS to post XAPI statement is available.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if ws is available, false otherwise.\n   * @since 3.9\n   */\n  canPostStatements(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this.canPostStatementsInSite(site);\n    })();\n  }\n  /**\n   * Returns whether or not WS to post XAPI statement is available in a certain site.\n   *\n   * @param site Site. If not defined, current site.\n   * @returns Promise resolved with true if ws is available, false otherwise.\n   * @since 3.9\n   */\n  canPostStatementsInSite(site) {\n    site = site || CoreSites.getCurrentSite();\n    return !!(site && site.wsAvailable('core_xapi_statement_post'));\n  }\n  /**\n   * Delete a state both online and offline.\n   *\n   * @param component Component.\n   * @param activityIRI XAPI activity ID IRI.\n   * @param agent The xAPI agent data.\n   * @param stateId The xAPI state ID.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  deleteState(component, activityIRI, agent, stateId, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          const itemIdString = yield CoreXAPIIRI.extract(activityIRI, 'activity', options.siteId);\n          const itemId = Number(itemIdString);\n          if (isNaN(itemId)) {\n            throw new CoreError('Invalid activity ID sent to xAPI delete state.');\n          }\n          // Save an offline state as deleted.\n          yield CoreXAPIOffline.saveState(component, itemId, stateId, XAPI_STATE_DELETED, options);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline() || options.offline) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        yield _this2.deleteStateOnline(component, activityIRI, JSON.stringify(agent), stateId, options);\n        const itemIdString = yield CoreXAPIIRI.extract(activityIRI, 'activity', options.siteId);\n        const itemId = Number(itemIdString);\n        if (!isNaN(itemId)) {\n          // Delete offline state if it exists.\n          yield CoreUtils.ignoreErrors(CoreXAPIOffline.deleteStates(component, {\n            itemId,\n            stateId,\n            registration: options.registration,\n            siteId: options.siteId\n          }));\n        }\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that the state cannot be deleted.\n          throw error;\n        }\n        // Couldn't connect to server, store it offline.\n        try {\n          return yield storeOffline();\n        } catch (offlineError) {\n          _this2.logger.error('Error storing a DELETED xAPI state in offline storage.', offlineError);\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Delete state. It will fail if offline or cannot connect.\n   *\n   * @param component Component.\n   * @param activityIRI XAPI activity ID IRI.\n   * @param agent The xAPI agent json.\n   * @param stateId The xAPI state ID.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  deleteStateOnline(component, activityIRI, agent, stateId, options = {}) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const data = {\n        component,\n        activityId: activityIRI,\n        agent,\n        stateId,\n        registration: options.registration\n      };\n      return site.write('core_xapi_delete_state', data, {\n        typeExpected: 'boolean'\n      });\n    })();\n  }\n  /**\n   * Get state from WS.\n   *\n   * @param component Component.\n   * @param activityId Activity ID.\n   * @param stateId The xAPI state ID.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  getState(component, activityId, stateId, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        var _offlineState$stateda;\n        const offlineState = yield CoreXAPIOffline.getState(component, activityId, stateId, options);\n        return offlineState.statedata !== XAPI_STATE_DELETED ? (_offlineState$stateda = offlineState.statedata) !== null && _offlineState$stateda !== void 0 ? _offlineState$stateda : null : null;\n      } catch (_unused) {\n        // No offline state.\n      }\n      return _this3.getStateFromServer(component, activityId, stateId, options);\n    })();\n  }\n  /**\n   * Get cache key for H5P get state WS calls.\n   *\n   * @param siteUrl Site URL.\n   * @param component Component.\n   * @param activityId Activity ID.\n   * @param stateId The xAPI state ID.\n   * @param registration Registration ID.\n   * @returns Cache key.\n   */\n  getStateCacheKey(siteUrl, component, activityId, stateId, registration) {\n    return `${CoreXAPIProvider.ROOT_CACHE_KEY}state:${component}:${activityId}:${stateId}:${registration !== null && registration !== void 0 ? registration : ''}`;\n  }\n  /**\n   * Get state from WS.\n   *\n   * @param component Component.\n   * @param activityId Activity ID.\n   * @param stateId The xAPI state ID.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  getStateFromServer(component, activityId, stateId, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const [site, activityIRI] = yield Promise.all([CoreSites.getSite(options.siteId), CoreXAPIIRI.generate(activityId, 'activity')]);\n      const data = {\n        component,\n        activityId: activityIRI,\n        agent: JSON.stringify(CoreXAPIItemAgent.createFromSite(site).getData()),\n        stateId,\n        registration: options.registration\n      };\n      const preSets = _objectSpread({\n        typeExpected: 'jsonstring',\n        cacheKey: _this4.getStateCacheKey(site.getURL(), component, activityId, stateId, options.registration),\n        component: options.appComponent,\n        componentId: options.appComponentId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('core_xapi_get_state', data, preSets);\n    })();\n  }\n  /**\n   * Get states after a certain timestamp. It will fail if offline or cannot connect.\n   *\n   * @param component Component.\n   * @param activityId Activity ID.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  getStatesSince(component, activityId, options = {}) {\n    return _asyncToGenerator(function* () {\n      const [site, activityIRI] = yield Promise.all([CoreSites.getSite(options.siteId), CoreXAPIIRI.generate(activityId, 'activity')]);\n      const data = {\n        component,\n        activityId: activityIRI,\n        agent: JSON.stringify(CoreXAPIItemAgent.createFromSite(site).getData()),\n        registration: options.registration\n      };\n      if (options.since) {\n        data.since = String(Math.floor(options.since / 1000));\n      }\n      return site.write('core_xapi_get_states', data);\n    })();\n  }\n  /**\n   * Get URL for XAPI events.\n   *\n   * @param contextId Context ID.\n   * @param type Type (e.g. 'activity').\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   * @deprecated since 4.2. Use CoreXAPIIRI.generate instead.\n   */\n  getUrl(contextId, type, siteId) {\n    return _asyncToGenerator(function* () {\n      return CoreXAPIIRI.generate(contextId, type, siteId);\n    })();\n  }\n  /**\n   * Invalidates a state.\n   *\n   * @param component Component.\n   * @param activityId Activity ID.\n   * @param stateId The xAPI state ID.\n   * @param options Options.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateState(component, activityId, stateId, options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      yield site.invalidateWsCacheForKey(_this5.getStateCacheKey(site.getURL(), component, activityId, stateId, options.registration));\n    })();\n  }\n  /**\n   * Post statements.\n   *\n   * @param contextId Context ID.\n   * @param component Component.\n   * @param json JSON string to send.\n   * @param options Options.\n   * @returns Promise resolved with boolean: true if response was sent to server, false if stored in device.\n   */\n  postStatements(contextId, component, json, options = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          yield CoreXAPIOffline.saveStatements(contextId, component, json, options);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline() || options.offline) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        yield _this6.postStatementsOnline(component, json, options.siteId);\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that statements cannot be submitted.\n          throw error;\n        } else {\n          // Couldn't connect to server, store it offline.\n          return storeOffline();\n        }\n      }\n    })();\n  }\n  /**\n   * Post statements. It will fail if offline or cannot connect.\n   *\n   * @param component Component.\n   * @param json JSON string to send.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  postStatementsOnline(component, json, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const data = {\n        component: component,\n        requestjson: json\n      };\n      return site.write('core_xapi_statement_post', data);\n    })();\n  }\n  /**\n   * Post state. It will fail if offline or cannot connect.\n   *\n   * @param component Component.\n   * @param activityIRI XAPI activity ID IRI.\n   * @param agent The xAPI agent data.\n   * @param stateId The xAPI state ID.\n   * @param stateData JSON object with the state data.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  postState(component, activityIRI, agent, stateId, stateData, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* () {\n          const itemIdString = yield CoreXAPIIRI.extract(activityIRI, 'activity', options.siteId);\n          const itemId = Number(itemIdString);\n          if (isNaN(itemId)) {\n            throw new CoreError('Invalid activity ID sent to xAPI post state.');\n          }\n          yield CoreXAPIOffline.saveState(component, itemId, stateId, stateData, options);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline() || options.offline) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        yield _this7.postStateOnline(component, activityIRI, JSON.stringify(agent), stateId, stateData, options);\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that state cannot be submitted.\n          throw error;\n        }\n        // Couldn't connect to server, store it offline.\n        try {\n          return yield storeOffline();\n        } catch (offlineError) {\n          _this7.logger.error('Error storing xAPI state in offline storage.', offlineError);\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Post state. It will fail if offline or cannot connect.\n   *\n   * @param component Component.\n   * @param activityIRI XAPI activity ID IRI.\n   * @param agent The xAPI agent json.\n   * @param stateId The xAPI state ID.\n   * @param stateData JSON object with the state data.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  postStateOnline(component, activityIRI, agent, stateId, stateData, options = {}) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const data = {\n        component,\n        activityId: activityIRI,\n        agent,\n        stateId,\n        stateData,\n        registration: options.registration\n      };\n      return site.write('core_xapi_post_state', data, {\n        typeExpected: 'boolean'\n      });\n    })();\n  }\n}\n_class = CoreXAPIProvider;\n_class.ROOT_CACHE_KEY = 'CoreXAPI:';\n_class.ɵfac = function CoreXAPIProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreXAPI = makeSingleton(CoreXAPIProvider);","map":{"version":3,"names":["CoreNetwork","CoreSites","CoreUtils","CoreXAPIOffline","makeSingleton","CoreXAPIItemAgent","CoreXAPIIRI","CoreError","CoreLogger","XAPI_STATE_DELETED","CoreXAPIProvider","constructor","logger","getInstance","canPostStatements","siteId","_this","_asyncToGenerator","site","getSite","canPostStatementsInSite","getCurrentSite","wsAvailable","deleteState","component","activityIRI","agent","stateId","options","_this2","getCurrentSiteId","storeOffline","_ref","itemIdString","extract","itemId","Number","isNaN","saveState","apply","arguments","isOnline","offline","deleteStateOnline","JSON","stringify","ignoreErrors","deleteStates","registration","error","isWebServiceError","offlineError","data","activityId","write","typeExpected","getState","_this3","_offlineState$stateda","offlineState","statedata","_unused","getStateFromServer","getStateCacheKey","siteUrl","ROOT_CACHE_KEY","_this4","Promise","all","generate","createFromSite","getData","preSets","_objectSpread","cacheKey","getURL","appComponent","componentId","appComponentId","getReadingStrategyPreSets","readingStrategy","read","getStatesSince","since","String","Math","floor","getUrl","contextId","type","invalidateState","_this5","invalidateWsCacheForKey","postStatements","json","_this6","_ref2","saveStatements","postStatementsOnline","requestjson","postState","stateData","_this7","_ref3","postStateOnline","_class","factory","ɵfac","providedIn","CoreXAPI"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/xapi/services/xapi.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesCommonWSOptions } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreXAPIOffline, CoreXAPIOfflineSaveStatementsOptions } from './offline';\nimport { makeSingleton } from '@singletons';\nimport { CoreXAPIItemAgent } from '../classes/item-agent';\nimport { CoreXAPIIRI } from '../classes/iri';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nexport const XAPI_STATE_DELETED = 'STATE_DELETED';\n\n/**\n * Service to provide XAPI functionalities.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreXAPIProvider {\n\n    static readonly ROOT_CACHE_KEY = 'CoreXAPI:';\n\n    protected logger = CoreLogger.getInstance('CoreXAPIProvider');\n\n    /**\n     * Returns whether or not WS to post XAPI statement is available.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if ws is available, false otherwise.\n     * @since 3.9\n     */\n    async canPostStatements(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.canPostStatementsInSite(site);\n    }\n\n    /**\n     * Returns whether or not WS to post XAPI statement is available in a certain site.\n     *\n     * @param site Site. If not defined, current site.\n     * @returns Promise resolved with true if ws is available, false otherwise.\n     * @since 3.9\n     */\n    canPostStatementsInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!(site && site.wsAvailable('core_xapi_statement_post'));\n    }\n\n    /**\n     * Delete a state both online and offline.\n     *\n     * @param component Component.\n     * @param activityIRI XAPI activity ID IRI.\n     * @param agent The xAPI agent data.\n     * @param stateId The xAPI state ID.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async deleteState(\n        component: string,\n        activityIRI: string,\n        agent: Record<string, unknown>,\n        stateId: string,\n        options: CoreXAPIStateSendDataOptions = {},\n    ): Promise<boolean> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        const storeOffline = async (): Promise<boolean> => {\n            const itemIdString = await CoreXAPIIRI.extract(activityIRI, 'activity', options.siteId);\n            const itemId = Number(itemIdString);\n\n            if (isNaN(itemId)) {\n                throw new CoreError('Invalid activity ID sent to xAPI delete state.');\n            }\n\n            // Save an offline state as deleted.\n            await CoreXAPIOffline.saveState(component, itemId, stateId, XAPI_STATE_DELETED, options);\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline() || options.offline) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            await this.deleteStateOnline(component, activityIRI, JSON.stringify(agent), stateId, options);\n\n            const itemIdString = await CoreXAPIIRI.extract(activityIRI, 'activity', options.siteId);\n            const itemId = Number(itemIdString);\n\n            if (!isNaN(itemId)) {\n                // Delete offline state if it exists.\n                await CoreUtils.ignoreErrors(CoreXAPIOffline.deleteStates(component, {\n                    itemId,\n                    stateId,\n                    registration: options.registration,\n                    siteId: options.siteId,\n                }));\n            }\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that the state cannot be deleted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store it offline.\n            try {\n                return await storeOffline();\n            } catch (offlineError) {\n                this.logger.error('Error storing a DELETED xAPI state in offline storage.', offlineError);\n\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Delete state. It will fail if offline or cannot connect.\n     *\n     * @param component Component.\n     * @param activityIRI XAPI activity ID IRI.\n     * @param agent The xAPI agent json.\n     * @param stateId The xAPI state ID.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async deleteStateOnline(\n        component: string,\n        activityIRI: string,\n        agent: string,\n        stateId: string,\n        options: CoreXAPIStateOptions = {},\n    ): Promise<boolean> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const data: CoreXAPIDeleteStateWSParams = {\n            component,\n            activityId: activityIRI,\n            agent,\n            stateId,\n            registration: options.registration,\n        };\n\n        return site.write('core_xapi_delete_state', data, { typeExpected: 'boolean' });\n    }\n\n    /**\n     * Get state from WS.\n     *\n     * @param component Component.\n     * @param activityId Activity ID.\n     * @param stateId The xAPI state ID.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async getState(\n        component: string,\n        activityId: number,\n        stateId: string,\n        options: CoreXAPIGetStateOptions = {},\n    ): Promise<string | null> {\n        try {\n            const offlineState = await CoreXAPIOffline.getState(component, activityId, stateId, options);\n\n            return offlineState.statedata !== XAPI_STATE_DELETED ? (offlineState.statedata ?? null) : null;\n        } catch {\n            // No offline state.\n        }\n\n        return this.getStateFromServer(component, activityId, stateId, options);\n    }\n\n    /**\n     * Get cache key for H5P get state WS calls.\n     *\n     * @param siteUrl Site URL.\n     * @param component Component.\n     * @param activityId Activity ID.\n     * @param stateId The xAPI state ID.\n     * @param registration Registration ID.\n     * @returns Cache key.\n     */\n    protected getStateCacheKey(\n        siteUrl: string,\n        component: string,\n        activityId: number,\n        stateId: string,\n        registration?: string,\n    ): string {\n        return `${CoreXAPIProvider.ROOT_CACHE_KEY}state:${component}:${activityId}:${stateId}:${registration ?? ''}`;\n    }\n\n    /**\n     * Get state from WS.\n     *\n     * @param component Component.\n     * @param activityId Activity ID.\n     * @param stateId The xAPI state ID.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async getStateFromServer(\n        component: string,\n        activityId: number,\n        stateId: string,\n        options: CoreXAPIGetStateOptions = {},\n    ): Promise<string | null> {\n        const [site, activityIRI] = await Promise.all([\n            CoreSites.getSite(options.siteId),\n            CoreXAPIIRI.generate(activityId, 'activity'),\n        ]);\n\n        const data: CoreXAPIGetStateWSParams = {\n            component,\n            activityId: activityIRI,\n            agent: JSON.stringify(CoreXAPIItemAgent.createFromSite(site).getData()),\n            stateId,\n            registration: options.registration,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            typeExpected: 'jsonstring',\n            cacheKey: this.getStateCacheKey(\n                site.getURL(),\n                component,\n                activityId,\n                stateId,\n                options.registration,\n            ),\n            component: options.appComponent,\n            componentId: options.appComponentId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('core_xapi_get_state', data, preSets);\n    }\n\n    /**\n     * Get states after a certain timestamp. It will fail if offline or cannot connect.\n     *\n     * @param component Component.\n     * @param activityId Activity ID.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async getStatesSince(\n        component: string,\n        activityId: number,\n        options: CoreXAPIGetStatesOptions = {},\n    ): Promise<string[]> {\n        const [site, activityIRI] = await Promise.all([\n            CoreSites.getSite(options.siteId),\n            CoreXAPIIRI.generate(activityId, 'activity'),\n        ]);\n\n        const data: CoreXAPIGetStatesWSParams = {\n            component,\n            activityId: activityIRI,\n            agent: JSON.stringify(CoreXAPIItemAgent.createFromSite(site).getData()),\n            registration: options.registration,\n        };\n        if (options.since) {\n            data.since = String(Math.floor(options.since / 1000));\n        }\n\n        return site.write<string[]>('core_xapi_get_states', data);\n    }\n\n    /**\n     * Get URL for XAPI events.\n     *\n     * @param contextId Context ID.\n     * @param type Type (e.g. 'activity').\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     * @deprecated since 4.2. Use CoreXAPIIRI.generate instead.\n     */\n    async getUrl(contextId: number, type: string, siteId?: string): Promise<string> {\n        return CoreXAPIIRI.generate(contextId, type, siteId);\n    }\n\n    /**\n     * Invalidates a state.\n     *\n     * @param component Component.\n     * @param activityId Activity ID.\n     * @param stateId The xAPI state ID.\n     * @param options Options.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateState(\n        component: string,\n        activityId: number,\n        stateId: string,\n        options: CoreXAPIStateOptions = {},\n    ): Promise<void> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        await site.invalidateWsCacheForKey(this.getStateCacheKey(\n            site.getURL(),\n            component,\n            activityId,\n            stateId,\n            options.registration,\n        ));\n    }\n\n    /**\n     * Post statements.\n     *\n     * @param contextId Context ID.\n     * @param component Component.\n     * @param json JSON string to send.\n     * @param options Options.\n     * @returns Promise resolved with boolean: true if response was sent to server, false if stored in device.\n     */\n    async postStatements(\n        contextId: number,\n        component: string,\n        json: string,\n        options: CoreXAPIPostStatementsOptions = {},\n    ): Promise<boolean> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        const storeOffline = async (): Promise<boolean> => {\n            await CoreXAPIOffline.saveStatements(contextId, component, json, options);\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline() || options.offline) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            await this.postStatementsOnline(component, json, options.siteId);\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that statements cannot be submitted.\n                throw error;\n            } else {\n                // Couldn't connect to server, store it offline.\n                return storeOffline();\n            }\n        }\n    }\n\n    /**\n     * Post statements. It will fail if offline or cannot connect.\n     *\n     * @param component Component.\n     * @param json JSON string to send.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async postStatementsOnline(component: string, json: string, siteId?: string): Promise<boolean[]> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const data: CoreXAPIStatementPostWSParams = {\n            component: component,\n            requestjson: json,\n        };\n\n        return site.write('core_xapi_statement_post', data);\n    }\n\n    /**\n     * Post state. It will fail if offline or cannot connect.\n     *\n     * @param component Component.\n     * @param activityIRI XAPI activity ID IRI.\n     * @param agent The xAPI agent data.\n     * @param stateId The xAPI state ID.\n     * @param stateData JSON object with the state data.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async postState(\n        component: string,\n        activityIRI: string,\n        agent: Record<string, unknown>,\n        stateId: string,\n        stateData: string,\n        options: CoreXAPIStateSendDataOptions = {},\n    ): Promise<boolean> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        const storeOffline = async (): Promise<boolean> => {\n            const itemIdString = await CoreXAPIIRI.extract(activityIRI, 'activity', options.siteId);\n            const itemId = Number(itemIdString);\n\n            if (isNaN(itemId)) {\n                throw new CoreError('Invalid activity ID sent to xAPI post state.');\n            }\n\n            await CoreXAPIOffline.saveState(component, itemId, stateId, stateData, options);\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline() || options.offline) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            await this.postStateOnline(component, activityIRI, JSON.stringify(agent), stateId, stateData, options);\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that state cannot be submitted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store it offline.\n            try {\n                return await storeOffline();\n            } catch (offlineError) {\n                this.logger.error('Error storing xAPI state in offline storage.', offlineError);\n\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Post state. It will fail if offline or cannot connect.\n     *\n     * @param component Component.\n     * @param activityIRI XAPI activity ID IRI.\n     * @param agent The xAPI agent json.\n     * @param stateId The xAPI state ID.\n     * @param stateData JSON object with the state data.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async postStateOnline(\n        component: string,\n        activityIRI: string,\n        agent: string,\n        stateId: string,\n        stateData: string,\n        options: CoreXAPIStateOptions = {},\n    ): Promise<boolean> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const data: CoreXAPIPostStateWSParams = {\n            component,\n            activityId: activityIRI,\n            agent,\n            stateId,\n            stateData,\n            registration: options.registration,\n        };\n\n        return site.write('core_xapi_post_state', data, { typeExpected: 'boolean' });\n    }\n\n}\n\nexport const CoreXAPI = makeSingleton(CoreXAPIProvider);\n\n/**\n * Options to pass to postStatements function.\n */\nexport type CoreXAPIPostStatementsOptions = CoreXAPIOfflineSaveStatementsOptions & {\n    offline?: boolean; // Whether to force storing it in offline.\n};\n\n/**\n * Params of core_xapi_statement_post WS.\n */\nexport type CoreXAPIStatementPostWSParams = {\n    component: string; // Component name.\n    requestjson: string; // Json object with all the statements to post.\n};\n\n/**\n * Options to pass to state functions.\n */\nexport type CoreXAPIStateOptions = {\n    registration?: string; // The xAPI registration UUID.\n    siteId?: string;\n};\n\n/**\n * Options to pass to getState function.\n */\nexport type CoreXAPIGetStateOptions = CoreXAPIStateOptions & CoreSitesCommonWSOptions & {\n    appComponent?: string; // The app component to link the WS call to.\n    appComponentId?: number; // The app component ID to link the WS call to.\n};\n\n/**\n * Options to pass to getStatesSince function.\n */\nexport type CoreXAPIGetStatesOptions = CoreXAPIStateOptions & {\n    since?: number; // Timestamp (in milliseconds) to filter the states.\n};\n\n/**\n * Options to pass to postState and deleteState functions.\n */\nexport type CoreXAPIStateSendDataOptions = CoreXAPIStateOptions & {\n    offline?: boolean; // Whether to force storing it in offline.\n};\n\n/**\n * Params of core_xapi_post_state WS.\n */\nexport type CoreXAPIPostStateWSParams = {\n    component: string; // Component name.\n    activityId: string; // XAPI activity ID IRI.\n    agent: string; // The xAPI agent json.\n    stateId: string; // The xAPI state ID.\n    stateData: string; // JSON object with the state data.\n    registration?: string; // The xAPI registration UUID.\n};\n\n/**\n * Params of core_xapi_delete_state WS.\n */\nexport type CoreXAPIDeleteStateWSParams = {\n    component: string; // Component name.\n    activityId: string; // XAPI activity ID IRI.\n    agent: string; // The xAPI agent json.\n    stateId: string; // The xAPI state ID.\n    registration?: string; // The xAPI registration UUID.\n};\n\n/**\n * Params of core_xapi_get_state WS.\n */\nexport type CoreXAPIGetStateWSParams = {\n    component: string; // Component name.\n    activityId: string; // XAPI activity ID IRI.\n    agent: string; // The xAPI agent json.\n    stateId: string; // The xAPI state ID.\n    registration?: string; // The xAPI registration UUID.\n};\n\n/**\n * Params of core_xapi_get_states WS.\n */\nexport type CoreXAPIGetStatesWSParams = {\n    component: string; // Component name.\n    activityId: string; // XAPI activity ID IRI.\n    agent: string; // The xAPI agent json.\n    registration?: string; // The xAPI registration UUID.\n    since?: string; // Filter ids stored since the timestamp (exclusive).\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}