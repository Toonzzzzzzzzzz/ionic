{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSites } from '@services/sites';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreText } from '@singletons/text';\nimport { CoreUrl } from '@singletons/url';\nimport * as i0 from \"@angular/core\";\n/**\n * Delegate to register handlers to handle links.\n */\nexport class CoreContentLinksDelegateService {\n  constructor() {\n    this.handlers = {}; // All registered handlers.\n    this.logger = CoreLogger.getInstance('CoreContentLinksDelegate');\n  }\n  /**\n   * Get the list of possible actions to do for a URL.\n   *\n   * @param url URL to handle.\n   * @param courseId Course ID related to the URL. Optional but recommended.\n   * @param username Username to use to filter sites.\n   * @param data Extra data to handle the URL.\n   * @returns Promise resolved with the actions.\n   */\n  getActionsFor(url, courseId, username, data) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!url) {\n        return [];\n      }\n      // Get the list of sites the URL belongs to.\n      const siteIds = yield CoreSites.getSiteIdsFromUrl(url, true, username);\n      if (!siteIds.length) {\n        // No sites, no actions.\n        return [];\n      }\n      const site = yield CoreSites.getSite(siteIds[0]);\n      const linkActions = [];\n      const promises = [];\n      const params = CoreUrlUtils.extractUrlParams(url);\n      const relativeUrl = CoreText.addStartingSlash(CoreUrl.toRelativeURL(site.getURL(), url));\n      for (const name in _this.handlers) {\n        const handler = _this.handlers[name];\n        const checkAll = handler.checkAllUsers;\n        const isEnabledFn = siteId => _this.isHandlerEnabled(handler, relativeUrl, params, courseId, siteId);\n        if (!handler.handles(relativeUrl)) {\n          // Invalid handler or it doesn't handle the URL. Stop.\n          continue;\n        }\n        // Filter the site IDs using the isEnabled function.\n        promises.push(CoreUtils.filterEnabledSites(siteIds, isEnabledFn, checkAll).then( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (siteIds) {\n            if (!siteIds.length) {\n              // No sites supported, no actions.\n              return;\n            }\n            const actions = yield handler.getActions(siteIds, relativeUrl, params, courseId, data);\n            if (actions && actions.length) {\n              // Set default values if any value isn't supplied.\n              actions.forEach(action => {\n                action.message = action.message || 'core.view';\n                action.icon = action.icon || 'fas-eye';\n                action.sites = action.sites || siteIds;\n                // Wrap the action function in our own function to treat logged out sites.\n                const actionFunction = action.action;\n                action.action = /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator(function* (siteId) {\n                    const site = yield CoreSites.getSite(siteId);\n                    if (!site.isLoggedOut()) {\n                      // Call the action now.\n                      return actionFunction(siteId);\n                    }\n                    // Site is logged out, authenticate first before treating the URL.\n                    const willReload = yield CoreSites.logoutForRedirect(siteId, {\n                      urlToOpen: url\n                    });\n                    if (!willReload) {\n                      // Load the site with the redirect data.\n                      yield CoreSites.loadSite(siteId, {\n                        urlToOpen: url\n                      });\n                    }\n                  });\n                  return function (_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n              });\n              // Add them to the list.\n              linkActions.push({\n                priority: handler.priority || 0,\n                actions: actions\n              });\n            }\n            return;\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      }\n      try {\n        yield CoreUtils.allPromises(promises);\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      // Sort link actions by priority.\n      return _this.sortActionsByPriority(linkActions);\n    })();\n  }\n  /**\n   * Get the site URL if the URL is supported by any handler.\n   *\n   * @param url URL to handle.\n   * @returns Site URL if the URL is supported by any handler, undefined otherwise.\n   */\n  getSiteUrl(url) {\n    if (!url) {\n      return;\n    }\n    // Check if any handler supports this URL.\n    for (const name in this.handlers) {\n      const handler = this.handlers[name];\n      const siteUrl = handler.getSiteUrl(url);\n      if (siteUrl) {\n        return siteUrl;\n      }\n    }\n  }\n  /**\n   * Check if a handler is enabled for a certain site and URL.\n   *\n   * @param handler Handler to check.\n   * @param url The URL to check.  It's a relative URL, it won't include the site URL.\n   * @param params The params of the URL\n   * @param courseId Course ID the URL belongs to (can be undefined).\n   * @param siteId The site ID to check.\n   * @returns Promise resolved with boolean: whether the handler is enabled.\n   */\n  isHandlerEnabled(handler, url, params, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      let disabled = false;\n      if (handler.featureName) {\n        // Check if the feature is disabled.\n        disabled = yield CoreSites.isFeatureDisabled(handler.featureName, siteId);\n      }\n      if (disabled) {\n        return false;\n      }\n      if (!handler.isEnabled) {\n        // Handler doesn't implement isEnabled, assume it's enabled.\n        return true;\n      }\n      return handler.isEnabled(siteId, url, params, courseId);\n    })();\n  }\n  /**\n   * Register a handler.\n   *\n   * @param handler The handler to register.\n   * @returns True if registered successfully, false otherwise.\n   */\n  registerHandler(handler) {\n    if (this.handlers[handler.name] !== undefined) {\n      this.logger.log(`Addon '${handler.name}' already registered`);\n      return false;\n    }\n    this.logger.log(`Registered addon '${handler.name}'`);\n    this.handlers[handler.name] = handler;\n    return true;\n  }\n  /**\n   * Sort actions by priority.\n   *\n   * @param actions Actions to sort.\n   * @returns Sorted actions.\n   */\n  sortActionsByPriority(actions) {\n    let sorted = [];\n    // Sort by priority.\n    actions = actions.sort((a, b) => (a.priority || 0) <= (b.priority || 0) ? 1 : -1);\n    // Fill result array.\n    actions.forEach(entry => {\n      sorted = sorted.concat(entry.actions);\n    });\n    return sorted;\n  }\n}\n_class = CoreContentLinksDelegateService;\n_class.ɵfac = function CoreContentLinksDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreContentLinksDelegate = makeSingleton(CoreContentLinksDelegateService);","map":{"version":3,"names":["CoreLogger","CoreSites","CoreUrlUtils","CoreUtils","makeSingleton","CoreText","CoreUrl","CoreContentLinksDelegateService","constructor","handlers","logger","getInstance","getActionsFor","url","courseId","username","data","_this","_asyncToGenerator","siteIds","getSiteIdsFromUrl","length","site","getSite","linkActions","promises","params","extractUrlParams","relativeUrl","addStartingSlash","toRelativeURL","getURL","name","handler","checkAll","checkAllUsers","isEnabledFn","siteId","isHandlerEnabled","handles","push","filterEnabledSites","then","_ref","actions","getActions","forEach","action","message","icon","sites","actionFunction","_ref2","isLoggedOut","willReload","logoutForRedirect","urlToOpen","loadSite","_x2","apply","arguments","priority","_x","allPromises","_unused","sortActionsByPriority","getSiteUrl","siteUrl","disabled","featureName","isFeatureDisabled","isEnabled","registerHandler","undefined","log","sorted","sort","a","b","entry","concat","factory","ɵfac","providedIn","CoreContentLinksDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/contentlinks/services/contentlinks-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSites } from '@services/sites';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreText } from '@singletons/text';\nimport { CoreUrl } from '@singletons/url';\n\n/**\n * Interface that all handlers must implement.\n */\nexport interface CoreContentLinksHandler {\n    /**\n     * A name to identify the handler.\n     */\n    name: string;\n\n    /**\n     * Handler's priority. The highest priority is treated first.\n     */\n    priority?: number;\n\n    /**\n     * Whether the isEnabled function should be called for all the users in a site. It should be true only if the isEnabled call\n     * can return different values for different users in same site.\n     */\n    checkAllUsers?: boolean;\n\n    /**\n     * Name of the feature this handler is related to.\n     * It will be used to check if the feature is disabled (@see CoreSite.isFeatureDisabled).\n     */\n    featureName?: string;\n\n    /**\n     * Get the list of actions for a link (url).\n     *\n     * @param siteIds List of sites the URL belongs to.\n     * @param url The URL to treat.  It's a relative URL, it won't include the site URL.\n     * @param params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}\n     * @param courseId Course ID related to the URL. Optional but recommended.\n     * @param data Extra data to handle the URL.\n     * @returns List of (or promise resolved with list of) actions.\n     */\n    getActions(\n        siteIds: string[],\n        url: string,\n        params: Record<string, string>,\n        courseId?: number,\n        data?: unknown,\n    ): CoreContentLinksAction[] | Promise<CoreContentLinksAction[]>;\n\n    /**\n     * Check if a URL is handled by this handler.\n     *\n     * @param url The URL to check. It's a relative URL, it won't include the site URL.\n     * @returns Whether the URL is handled by this handler\n     */\n    handles(url: string): boolean;\n\n    /**\n     * If the URL is handled by this handler, return the site URL.\n     *\n     * @param url The URL to check.\n     * @returns Site URL if it is handled, undefined otherwise.\n     */\n    getSiteUrl(url: string): string | undefined;\n\n    /**\n     * Check if the handler is enabled for a certain site (site + user) and a URL.\n     * If not defined, defaults to true.\n     *\n     * @param siteId The site ID.\n     * @param url The URL to treat.  It's a relative URL, it won't include the site URL.\n     * @param params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}\n     * @param courseId Course ID related to the URL. Optional but recommended.\n     * @returns Whether the handler is enabled for the URL and site.\n     */\n    isEnabled?(siteId: string, url: string, params: Record<string, string>, courseId?: number): Promise<boolean>;\n}\n\n/**\n * Action to perform when a link is clicked.\n */\nexport interface CoreContentLinksAction {\n    /**\n     * A message to identify the action. Default: 'core.view'.\n     */\n    message?: string;\n\n    /**\n     * Name of the icon of the action. Default: 'fas-eye'.\n     */\n    icon?: string;\n\n    /**\n     * IDs of the sites that support the action.\n     */\n    sites?: string[];\n\n    /**\n     * Action to perform when the link is clicked.\n     *\n     * @param siteId The site ID.\n     */\n    action(siteId: string): void;\n}\n\n/**\n * Actions and priority for a handler and URL.\n */\nexport interface CoreContentLinksHandlerActions {\n    /**\n     * Handler's priority.\n     */\n    priority: number;\n\n    /**\n     * List of actions.\n     */\n    actions: CoreContentLinksAction[];\n}\n\n/**\n * Delegate to register handlers to handle links.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreContentLinksDelegateService {\n\n    protected logger: CoreLogger;\n    protected handlers: { [s: string]: CoreContentLinksHandler } = {}; // All registered handlers.\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreContentLinksDelegate');\n    }\n\n    /**\n     * Get the list of possible actions to do for a URL.\n     *\n     * @param url URL to handle.\n     * @param courseId Course ID related to the URL. Optional but recommended.\n     * @param username Username to use to filter sites.\n     * @param data Extra data to handle the URL.\n     * @returns Promise resolved with the actions.\n     */\n    async getActionsFor(url: string, courseId?: number, username?: string, data?: unknown): Promise<CoreContentLinksAction[]> {\n        if (!url) {\n            return [];\n        }\n\n        // Get the list of sites the URL belongs to.\n        const siteIds = await CoreSites.getSiteIdsFromUrl(url, true, username);\n        if (!siteIds.length) {\n            // No sites, no actions.\n            return [];\n        }\n\n        const site = await CoreSites.getSite(siteIds[0]);\n\n        const linkActions: CoreContentLinksHandlerActions[] = [];\n        const promises: Promise<void>[] = [];\n        const params = CoreUrlUtils.extractUrlParams(url);\n        const relativeUrl = CoreText.addStartingSlash(CoreUrl.toRelativeURL(site.getURL(), url));\n\n        for (const name in this.handlers) {\n            const handler = this.handlers[name];\n            const checkAll = handler.checkAllUsers;\n            const isEnabledFn = (siteId: string) => this.isHandlerEnabled(handler, relativeUrl, params, courseId, siteId);\n\n            if (!handler.handles(relativeUrl)) {\n                // Invalid handler or it doesn't handle the URL. Stop.\n                continue;\n            }\n\n            // Filter the site IDs using the isEnabled function.\n            promises.push(CoreUtils.filterEnabledSites(siteIds, isEnabledFn, checkAll).then(async (siteIds) => {\n                if (!siteIds.length) {\n                    // No sites supported, no actions.\n                    return;\n                }\n\n                const actions = await handler.getActions(siteIds, relativeUrl, params, courseId, data);\n\n                if (actions && actions.length) {\n                    // Set default values if any value isn't supplied.\n                    actions.forEach((action) => {\n                        action.message = action.message || 'core.view';\n                        action.icon = action.icon || 'fas-eye';\n                        action.sites = action.sites || siteIds;\n\n                        // Wrap the action function in our own function to treat logged out sites.\n                        const actionFunction = action.action;\n                        action.action = async (siteId) => {\n                            const site = await CoreSites.getSite(siteId);\n\n                            if (!site.isLoggedOut()) {\n                                // Call the action now.\n                                return actionFunction(siteId);\n                            }\n\n                            // Site is logged out, authenticate first before treating the URL.\n                            const willReload = await CoreSites.logoutForRedirect(siteId, {\n                                urlToOpen: url,\n                            });\n\n                            if (!willReload) {\n                                // Load the site with the redirect data.\n                                await CoreSites.loadSite(siteId, {\n                                    urlToOpen: url,\n                                });\n                            }\n                        };\n                    });\n\n                    // Add them to the list.\n                    linkActions.push({\n                        priority: handler.priority || 0,\n                        actions: actions,\n                    });\n                }\n\n                return;\n            }));\n        }\n        try {\n            await CoreUtils.allPromises(promises);\n        } catch {\n            // Ignore errors.\n        }\n\n        // Sort link actions by priority.\n        return this.sortActionsByPriority(linkActions);\n    }\n\n    /**\n     * Get the site URL if the URL is supported by any handler.\n     *\n     * @param url URL to handle.\n     * @returns Site URL if the URL is supported by any handler, undefined otherwise.\n     */\n    getSiteUrl(url: string): string | void {\n        if (!url) {\n            return;\n        }\n\n        // Check if any handler supports this URL.\n        for (const name in this.handlers) {\n            const handler = this.handlers[name];\n            const siteUrl = handler.getSiteUrl(url);\n\n            if (siteUrl) {\n                return siteUrl;\n            }\n        }\n    }\n\n    /**\n     * Check if a handler is enabled for a certain site and URL.\n     *\n     * @param handler Handler to check.\n     * @param url The URL to check.  It's a relative URL, it won't include the site URL.\n     * @param params The params of the URL\n     * @param courseId Course ID the URL belongs to (can be undefined).\n     * @param siteId The site ID to check.\n     * @returns Promise resolved with boolean: whether the handler is enabled.\n     */\n    protected async isHandlerEnabled(\n        handler: CoreContentLinksHandler,\n        url: string,\n        params: Record<string, string>,\n        courseId: number | undefined,\n        siteId: string,\n    ): Promise<boolean> {\n\n        let disabled = false;\n        if (handler.featureName) {\n            // Check if the feature is disabled.\n            disabled = await CoreSites.isFeatureDisabled(handler.featureName, siteId);\n        }\n\n        if (disabled) {\n            return false;\n        }\n\n        if (!handler.isEnabled) {\n            // Handler doesn't implement isEnabled, assume it's enabled.\n            return true;\n        }\n\n        return handler.isEnabled(siteId, url, params, courseId);\n    }\n\n    /**\n     * Register a handler.\n     *\n     * @param handler The handler to register.\n     * @returns True if registered successfully, false otherwise.\n     */\n    registerHandler(handler: CoreContentLinksHandler): boolean {\n        if (this.handlers[handler.name] !== undefined) {\n            this.logger.log(`Addon '${handler.name}' already registered`);\n\n            return false;\n        }\n        this.logger.log(`Registered addon '${handler.name}'`);\n        this.handlers[handler.name] = handler;\n\n        return true;\n    }\n\n    /**\n     * Sort actions by priority.\n     *\n     * @param actions Actions to sort.\n     * @returns Sorted actions.\n     */\n    protected sortActionsByPriority(actions: CoreContentLinksHandlerActions[]): CoreContentLinksAction[] {\n        let sorted: CoreContentLinksAction[] = [];\n\n        // Sort by priority.\n        actions = actions.sort((a, b) => (a.priority || 0) <= (b.priority || 0) ? 1 : -1);\n\n        // Fill result array.\n        actions.forEach((entry) => {\n            sorted = sorted.concat(entry.actions);\n        });\n\n        return sorted;\n    }\n\n}\n\nexport const CoreContentLinksDelegate = makeSingleton(CoreContentLinksDelegateService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}