{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreUserOffline } from './user-offline';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreError } from '@classes/errors/error';\nimport { USERS_TABLE_NAME } from './database/user';\nimport { CoreUserHelper } from './user-helper';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmUser:';\n/**\n * Profile picture updated event.\n */\nexport const USER_PROFILE_REFRESHED = 'CoreUserProfileRefreshed';\n/**\n * Profile picture updated event.\n */\nexport const USER_PROFILE_PICTURE_UPDATED = 'CoreUserProfilePictureUpdated';\n/**\n * Value set in timezone when using the server's timezone.\n */\nexport const USER_PROFILE_SERVER_TIMEZONE = '99';\n/**\n * Fake ID for a \"no reply\" user.\n */\nexport const USER_NOREPLY_USER = -10;\n/**\n * Service to provide user functionalities.\n */\nexport class CoreUserProvider {\n  // Max of participants to retrieve in each WS call.\n  constructor() {\n    this.logger = CoreLogger.getInstance('CoreUserProvider');\n    CoreEvents.on(CoreEvents.USER_DELETED, data => this.handleUserKickedOutEvent(data));\n    CoreEvents.on(CoreEvents.USER_SUSPENDED, data => this.handleUserKickedOutEvent(data));\n    CoreEvents.on(CoreEvents.USER_NO_LOGIN, data => this.handleUserKickedOutEvent(data));\n  }\n  /**\n   * Check if WS to search participants is available in site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it's available.\n   * @since 3.8\n   */\n  canSearchParticipants(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this.canSearchParticipantsInSite(site);\n    })();\n  }\n  /**\n   * Check if WS to search participants is available in site.\n   *\n   * @param site Site. If not defined, current site.\n   * @returns Whether it's available.\n   * @since 3.8\n   */\n  canSearchParticipantsInSite(site) {\n    var _site;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site = site) !== null && _site !== void 0 && _site.wsAvailable('core_enrol_search_users'));\n  }\n  /**\n   * Change the given user profile picture.\n   *\n   * @param draftItemId New picture draft item id.\n   * @param userId User ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolve with the new profileimageurl\n   */\n  changeProfilePicture(draftItemId, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        draftitemid: draftItemId,\n        delete: false,\n        userid: userId\n      };\n      const result = yield site.write('core_user_update_picture', params);\n      if (!result.success || !result.profileimageurl) {\n        return Promise.reject(null);\n      }\n      return result.profileimageurl;\n    })();\n  }\n  /**\n   * Handle an event where a user was kicked out of the site.\n   *\n   * @param data Event data.\n   */\n  handleUserKickedOutEvent(data) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // Search for userid in params.\n      let userId = 0;\n      if (data.params.userid) {\n        userId = data.params.userid;\n      } else if (data.params.userids) {\n        userId = data.params.userids[0];\n      } else if (data.params.field === 'id' && data.params.values && data.params.values.length) {\n        userId = data.params.values[0];\n      } else if (data.params.userlist && data.params.userlist.length) {\n        userId = data.params.userlist[0].userid;\n      }\n      if (userId > 0) {\n        yield _this2.deleteStoredUser(userId, data.siteId);\n      }\n    })();\n  }\n  /**\n   * Store user basic information in local DB to be retrieved if the WS call fails.\n   *\n   * @param userId User ID.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolve when the user is deleted.\n   */\n  deleteStoredUser(userId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (isNaN(userId)) {\n        throw new CoreError('Invalid user ID.');\n      }\n      const site = yield CoreSites.getSite(siteId);\n      yield Promise.all([_this3.invalidateUserCache(userId, site.getId()), site.getDb().deleteRecords(USERS_TABLE_NAME, {\n        id: userId\n      })]);\n    })();\n  }\n  /**\n   * Get participants for a certain course.\n   *\n   * @param courseId ID of the course.\n   * @param limitFrom Position of the first participant to get.\n   * @param limitNumber Number of participants to get.\n   * @param siteId Site Id. If not defined, use current site.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved when the participants are retrieved.\n   */\n  getParticipants(courseId, limitFrom = 0, limitNumber = CoreUserProvider.PARTICIPANTS_LIST_LIMIT, siteId, ignoreCache) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      _this4.logger.debug(`Get participants for course '${courseId}' starting at '${limitFrom}'`);\n      const params = {\n        courseid: courseId,\n        options: [{\n          name: 'limitfrom',\n          value: String(limitFrom)\n        }, {\n          name: 'limitnumber',\n          value: String(limitNumber)\n        }, {\n          name: 'sortby',\n          value: 'siteorder'\n        }]\n      };\n      const preSets = {\n        cacheKey: _this4.getParticipantsListCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const users = yield site.read('core_enrol_get_enrolled_users', params, preSets);\n      const canLoadMore = users.length >= limitNumber;\n      _this4.storeUsers(users, siteId);\n      return {\n        participants: users,\n        canLoadMore: canLoadMore\n      };\n    })();\n  }\n  /**\n   * Get cache key for participant list WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getParticipantsListCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'list:' + courseId;\n  }\n  /**\n   * Get user profile. The type of profile retrieved depends on the params.\n   *\n   * @param userId User's ID.\n   * @param courseId Course ID to get course profile, undefined or 0 to get site profile.\n   * @param forceLocal True to retrieve the user data from local DB, false to retrieve it from WS.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolved with the user data.\n   */\n  getProfile(userId, courseId, forceLocal = false, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (forceLocal) {\n        try {\n          return yield _this5.getUserFromLocalDb(userId, siteId);\n        } catch (_unused) {\n          return _this5.getUserFromWS(userId, courseId, siteId);\n        }\n      }\n      try {\n        return yield _this5.getUserFromWS(userId, courseId, siteId);\n      } catch (error) {\n        try {\n          return yield _this5.getUserFromLocalDb(userId, siteId);\n        } catch (_unused2) {\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Get cache key for a user WS call.\n   *\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getUserCacheKey(userId) {\n    return ROOT_CACHE_KEY + 'data:' + userId;\n  }\n  /**\n   * Get user basic information from local DB.\n   *\n   * @param userId User ID.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolve when the user is retrieved.\n   */\n  getUserFromLocalDb(userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecord(USERS_TABLE_NAME, {\n        id: userId\n      });\n    })();\n  }\n  /**\n   * Get a user fullname, using a default text if user not found.\n   *\n   * @param userId User ID.\n   * @param courseId Course ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved with user name.\n   */\n  getUserFullNameWithDefault(userId, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const user = yield CoreUser.getProfile(userId, courseId, true, siteId);\n        return user.fullname;\n      } catch (_unused3) {\n        return Translate.instant('core.user.userwithid', {\n          id: userId\n        });\n      }\n    })();\n  }\n  /**\n   * Get user profile from WS.\n   *\n   * @param userId User ID.\n   * @param courseId Course ID to get course profile, undefined or 0 to get site profile.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolve when the user is retrieved.\n   */\n  getUserFromWS(userId, courseId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const preSets = {\n        cacheKey: _this6.getUserCacheKey(userId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      let users;\n      // Determine WS and data to use.\n      if (courseId && courseId != site.getSiteHomeId()) {\n        _this6.logger.debug(`Get participant with ID '${userId}' in course '${courseId}`);\n        const params = {\n          userlist: [{\n            userid: userId,\n            courseid: courseId\n          }]\n        };\n        users = yield site.read('core_user_get_course_user_profiles', params, preSets);\n      } else {\n        _this6.logger.debug(`Get user with ID '${userId}'`);\n        const params = {\n          field: 'id',\n          values: [String(userId)]\n        };\n        users = yield site.read('core_user_get_users_by_field', params, preSets);\n      }\n      if (users.length == 0) {\n        // Shouldn't happen.\n        throw new CoreError('Cannot retrieve user info.');\n      }\n      const user = users[0];\n      if (user.country) {\n        user.country = CoreUtils.getCountryName(user.country);\n      }\n      _this6.storeUser(user.id, user.fullname, user.profileimageurl);\n      return user;\n    })();\n  }\n  /**\n   * Get a user preference (online or offline).\n   *\n   * @param name Name of the preference.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Preference value or null if preference not set.\n   */\n  getUserPreference(name, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const preference = yield CoreUtils.ignoreErrors(CoreUserOffline.getPreference(name, siteId));\n      if (preference && !CoreNetwork.isOnline()) {\n        // Offline, return stored value.\n        return preference.value;\n      }\n      const wsValue = yield _this7.getUserPreferenceOnline(name, siteId);\n      if (preference && preference.value != preference.onlinevalue && preference.onlinevalue == wsValue) {\n        // Sync is pending for this preference, return stored value.\n        return preference.value;\n      }\n      if (!wsValue) {\n        return null;\n      }\n      yield CoreUserOffline.setPreference(name, wsValue, wsValue);\n      return wsValue;\n    })();\n  }\n  /**\n   * Get cache key for a user preference WS call.\n   *\n   * @param name Preference name.\n   * @returns Cache key.\n   */\n  getUserPreferenceCacheKey(name) {\n    return ROOT_CACHE_KEY + 'preference:' + name;\n  }\n  /**\n   * Get a user preference online.\n   *\n   * @param name Name of the preference.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Preference value or null if preference not set.\n   */\n  getUserPreferenceOnline(name, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        name\n      };\n      const preSets = {\n        cacheKey: _this8.getUserPreferenceCacheKey(name),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      const result = yield site.read('core_user_get_user_preferences', params, preSets);\n      return result.preferences[0] ? result.preferences[0].value : null;\n    })();\n  }\n  /**\n   * Invalidates user WS calls.\n   *\n   * @param userId User ID.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserCache(userId, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this9.getUserCacheKey(userId));\n    })();\n  }\n  /**\n   * Invalidates participant list for a certain course.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the list is invalidated.\n   */\n  invalidateParticipantsList(courseId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this10.getParticipantsListCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidate user preference.\n   *\n   * @param name Name of the preference.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserPreference(name, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this11.getUserPreferenceCacheKey(name));\n    })();\n  }\n  /**\n   * Check if course participants is disabled in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n   */\n  isParticipantsDisabled(siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this12.isParticipantsDisabledInSite(site);\n    })();\n  }\n  /**\n   * Check if course participants is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether it's disabled.\n   */\n  isParticipantsDisabledInSite(site) {\n    var _site2;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site2 = site) !== null && _site2 !== void 0 && _site2.isFeatureDisabled('CoreCourseOptionsDelegate_CoreUserParticipants'));\n  }\n  /**\n   * Returns whether or not participants is enabled for a certain course.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n   */\n  isPluginEnabledForCourse(courseId, siteId) {\n    if (!courseId) {\n      throw new CoreError('Invalid course ID.');\n    }\n    // Retrieving one participant will fail if browsing users is disabled by capabilities.\n    return CoreUtils.promiseWorks(this.getParticipants(courseId, 0, 1, siteId));\n  }\n  /**\n   * Check if update profile picture is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns True if disabled, false otherwise.\n   */\n  isUpdatePictureDisabledInSite(site) {\n    var _site3;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site3 = site) !== null && _site3 !== void 0 && _site3.isFeatureDisabled('CoreUserDelegate_picture'));\n  }\n  /**\n   * Log User Profile View in Moodle.\n   *\n   * @param userId User ID.\n   * @param courseId Course ID.\n   * @returns Promise resolved when done.\n   */\n  logView(userId, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userid: userId\n      };\n      if (courseId) {\n        params.courseid = courseId;\n      }\n      return site.write('core_user_view_user_profile', params);\n    })();\n  }\n  /**\n   * Log Participants list view in Moodle.\n   *\n   * @param courseId Course ID.\n   * @returns Promise resolved when done.\n   */\n  logParticipantsView(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        courseid: courseId\n      };\n      return site.write('core_user_view_user_list', params);\n    })();\n  }\n  /**\n   * Prefetch user profiles and their images from a certain course. It prevents duplicates.\n   *\n   * @param userIds List of user IDs.\n   * @param courseId Course the users belong to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when prefetched.\n   */\n  prefetchProfiles(userIds, courseId, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!siteId) {\n        return;\n      }\n      const treated = {};\n      yield Promise.all(userIds.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (userId) {\n          if (userId === null || !siteId) {\n            return;\n          }\n          userId = Number(userId); // Make sure it's a number.\n          // Prevent repeats and errors.\n          if (isNaN(userId) || treated[userId] || userId <= 0) {\n            return;\n          }\n          treated[userId] = true;\n          try {\n            const profile = yield _this13.getProfile(userId, courseId, false, siteId);\n            if (profile.profileimageurl) {\n              yield CoreFilepool.addToQueueByUrl(siteId, profile.profileimageurl);\n            }\n          } catch (error) {\n            _this13.logger.warn(`Ignore error when prefetching user ${userId}`, error);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Prefetch user avatars. It prevents duplicates.\n   *\n   * @param entries List of entries that have the images.\n   * @param propertyName The name of the property that contains the image.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when prefetched.\n   */\n  prefetchUserAvatars(entries, propertyName, siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!siteId) {\n        return;\n      }\n      const treated = {};\n      const promises = entries.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (entry) {\n          const imageUrl = entry[propertyName];\n          if (!imageUrl || treated[imageUrl] || !siteId) {\n            // It doesn't have an image or it has already been treated.\n            return;\n          }\n          // Do not prefetch when initials are set and image is default.\n          if ('firstname' in entry || 'lastname' in entry) {\n            const initials = CoreUserHelper.getUserInitials(entry);\n            if (initials && imageUrl && CoreUrlUtils.isThemeImageUrl(imageUrl)) {\n              return;\n            }\n          }\n          treated[imageUrl] = true;\n          try {\n            yield CoreFilepool.addToQueueByUrl(siteId, imageUrl);\n          } catch (ex) {\n            _this14.logger.warn(`Ignore error when prefetching user avatar ${imageUrl}`, entry, ex);\n          }\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Search participants in a certain course.\n   *\n   * @param courseId ID of the course.\n   * @param search The string to search.\n   * @param searchAnywhere Whether to find a match anywhere or only at the beginning.\n   * @param page Page to get.\n   * @param perPage Number of participants to get.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the participants are retrieved.\n   * @since 3.8\n   */\n  searchParticipants(courseId, search, searchAnywhere = true, page = 0, perPage = CoreUserProvider.PARTICIPANTS_LIST_LIMIT, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        courseid: courseId,\n        search: search,\n        searchanywhere: !!searchAnywhere,\n        page: page,\n        perpage: perPage\n      };\n      const preSets = {\n        getFromCache: false // Always try to get updated data. If it fails, it will get it from cache.\n      };\n\n      const users = yield site.read('core_enrol_search_users', params, preSets);\n      const canLoadMore = users.length >= perPage;\n      _this15.storeUsers(users, siteId);\n      return {\n        participants: users,\n        canLoadMore: canLoadMore\n      };\n    })();\n  }\n  /**\n   * Store user basic information in local DB to be retrieved if the WS call fails.\n   *\n   * @param userId User ID.\n   * @param fullname User full name.\n   * @param avatar User avatar URL.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolve when the user is stored.\n   */\n  storeUser(userId, fullname, avatar, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const userRecord = {\n        id: userId,\n        fullname: fullname,\n        profileimageurl: avatar\n      };\n      yield site.getDb().insertRecord(USERS_TABLE_NAME, userRecord);\n    })();\n  }\n  /**\n   * Store users basic information in local DB.\n   *\n   * @param users Users to store.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolve when the user is stored.\n   */\n  storeUsers(users, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all(users.map(user => {\n        if (!user.id || isNaN(Number(user.id))) {\n          return;\n        }\n        return _this16.storeUser(Number(user.id), user.fullname, user.profileimageurl, siteId);\n      }));\n    })();\n  }\n  /**\n   * Set a user preference (online or offline).\n   *\n   * @param name Name of the preference.\n   * @param value Value of the preference.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved on success.\n   */\n  setUserPreference(name, value, siteId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!CoreNetwork.isOnline()) {\n        // Offline, just update the preference.\n        return CoreUserOffline.setPreference(name, value);\n      }\n      try {\n        // Update the preference in the site.\n        const preferences = [{\n          type: name,\n          value\n        }];\n        yield _this17.updateUserPreferences(preferences, undefined, undefined, siteId);\n        // Update preference and invalidate data.\n        yield Promise.all([CoreUserOffline.setPreference(name, value, value), CoreUtils.ignoreErrors(_this17.invalidateUserPreference(name))]);\n      } catch (error) {\n        // Preference not saved online. Update the offline one.\n        yield CoreUserOffline.setPreference(name, value);\n      }\n    })();\n  }\n  /**\n   * Update a preference for a user.\n   *\n   * @param name Preference name.\n   * @param value Preference new value.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success.\n   */\n  updateUserPreference(name, value, userId, siteId) {\n    const preferences = [{\n      type: name,\n      value: value\n    }];\n    return this.updateUserPreferences(preferences, undefined, userId, siteId);\n  }\n  /**\n   * Update some preferences for a user.\n   *\n   * @param preferences List of preferences.\n   * @param disableNotifications Whether to disable all notifications. Undefined to not update this value.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success.\n   */\n  updateUserPreferences(preferences, disableNotifications, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const params = {\n        userid: userId,\n        preferences: preferences\n      };\n      const preSets = {\n        responseExpected: false\n      };\n      if (disableNotifications !== undefined) {\n        params.emailstop = disableNotifications ? 1 : 0;\n      }\n      yield site.write('core_user_update_user_preferences', params, preSets);\n    })();\n  }\n}\n_class = CoreUserProvider;\n_class.PARTICIPANTS_LIST_LIMIT = 50;\n_class.ɵfac = function CoreUserProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreUser = makeSingleton(CoreUserProvider);","map":{"version":3,"names":["CoreNetwork","CoreFilepool","CoreSites","CoreUtils","CoreUserOffline","CoreLogger","CoreSite","makeSingleton","Translate","CoreEvents","CoreError","USERS_TABLE_NAME","CoreUserHelper","CoreUrlUtils","ROOT_CACHE_KEY","USER_PROFILE_REFRESHED","USER_PROFILE_PICTURE_UPDATED","USER_PROFILE_SERVER_TIMEZONE","USER_NOREPLY_USER","CoreUserProvider","constructor","logger","getInstance","on","USER_DELETED","data","handleUserKickedOutEvent","USER_SUSPENDED","USER_NO_LOGIN","canSearchParticipants","siteId","_this","_asyncToGenerator","site","getSite","canSearchParticipantsInSite","_site","getCurrentSite","wsAvailable","changeProfilePicture","draftItemId","userId","params","draftitemid","delete","userid","result","write","success","profileimageurl","Promise","reject","_this2","userids","field","values","length","userlist","deleteStoredUser","_this3","isNaN","all","invalidateUserCache","getId","getDb","deleteRecords","id","getParticipants","courseId","limitFrom","limitNumber","PARTICIPANTS_LIST_LIMIT","ignoreCache","_this4","debug","courseid","options","name","value","String","preSets","cacheKey","getParticipantsListCacheKey","updateFrequency","FREQUENCY_RARELY","getFromCache","emergencyCache","users","read","canLoadMore","storeUsers","participants","getProfile","forceLocal","_this5","getCurrentSiteId","getUserFromLocalDb","_unused","getUserFromWS","error","_unused2","getUserCacheKey","getRecord","getUserFullNameWithDefault","user","CoreUser","fullname","_unused3","instant","_this6","getSiteHomeId","country","getCountryName","storeUser","getUserPreference","_this7","preference","ignoreErrors","getPreference","isOnline","wsValue","getUserPreferenceOnline","onlinevalue","setPreference","getUserPreferenceCacheKey","_this8","FREQUENCY_SOMETIMES","preferences","_this9","invalidateWsCacheForKey","invalidateParticipantsList","_this10","invalidateUserPreference","_this11","isParticipantsDisabled","_this12","isParticipantsDisabledInSite","_site2","isFeatureDisabled","isPluginEnabledForCourse","promiseWorks","isUpdatePictureDisabledInSite","_site3","logView","logParticipantsView","prefetchProfiles","userIds","_this13","treated","map","_ref","Number","profile","addToQueueByUrl","warn","_x","apply","arguments","prefetchUserAvatars","entries","propertyName","_this14","promises","_ref2","entry","imageUrl","initials","getUserInitials","isThemeImageUrl","ex","_x2","searchParticipants","search","searchAnywhere","page","perPage","_this15","searchanywhere","perpage","avatar","userRecord","insertRecord","_this16","setUserPreference","_this17","type","updateUserPreferences","undefined","updateUserPreference","disableNotifications","getUserId","responseExpected","emailstop","_class","factory","ɵfac","providedIn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/user/services/user.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreUserOffline } from './user-offline';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents, CoreEventSiteData, CoreEventUserDeletedData, CoreEventUserSuspendedData } from '@singletons/events';\nimport { CoreStatusWithWarningsWSResponse, CoreWSExternalWarning } from '@services/ws';\nimport { CoreError } from '@classes/errors/error';\nimport { USERS_TABLE_NAME, CoreUserDBRecord } from './database/user';\nimport { CoreUserHelper } from './user-helper';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmUser:';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [USER_PROFILE_REFRESHED]: CoreUserProfileRefreshedData;\n        [USER_PROFILE_PICTURE_UPDATED]: CoreUserProfilePictureUpdatedData;\n    }\n\n}\n\n/**\n * Profile picture updated event.\n */\nexport const USER_PROFILE_REFRESHED = 'CoreUserProfileRefreshed';\n\n/**\n * Profile picture updated event.\n */\nexport const USER_PROFILE_PICTURE_UPDATED = 'CoreUserProfilePictureUpdated';\n\n/**\n * Value set in timezone when using the server's timezone.\n */\nexport const USER_PROFILE_SERVER_TIMEZONE = '99';\n\n/**\n * Fake ID for a \"no reply\" user.\n */\nexport const USER_NOREPLY_USER = -10;\n\n/**\n * Service to provide user functionalities.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreUserProvider {\n\n    static readonly PARTICIPANTS_LIST_LIMIT = 50; // Max of participants to retrieve in each WS call.\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreUserProvider');\n\n        CoreEvents.on(CoreEvents.USER_DELETED, data => this.handleUserKickedOutEvent(data));\n        CoreEvents.on(CoreEvents.USER_SUSPENDED, data => this.handleUserKickedOutEvent(data));\n        CoreEvents.on(CoreEvents.USER_NO_LOGIN, data => this.handleUserKickedOutEvent(data));\n    }\n\n    /**\n     * Check if WS to search participants is available in site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it's available.\n     * @since 3.8\n     */\n    async canSearchParticipants(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.canSearchParticipantsInSite(site);\n    }\n\n    /**\n     * Check if WS to search participants is available in site.\n     *\n     * @param site Site. If not defined, current site.\n     * @returns Whether it's available.\n     * @since 3.8\n     */\n    canSearchParticipantsInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site?.wsAvailable('core_enrol_search_users');\n    }\n\n    /**\n     * Change the given user profile picture.\n     *\n     * @param draftItemId New picture draft item id.\n     * @param userId User ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolve with the new profileimageurl\n     */\n    async changeProfilePicture(draftItemId: number, userId: number, siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreUserUpdatePictureWSParams = {\n            draftitemid: draftItemId,\n            delete: false,\n            userid: userId,\n        };\n\n        const result = await site.write<CoreUserUpdatePictureWSResponse>('core_user_update_picture', params);\n\n        if (!result.success || !result.profileimageurl) {\n            return Promise.reject(null);\n        }\n\n        return result.profileimageurl;\n    }\n\n    /**\n     * Handle an event where a user was kicked out of the site.\n     *\n     * @param data Event data.\n     */\n    async handleUserKickedOutEvent(\n        data: CoreEventSiteData & (CoreEventUserDeletedData | CoreEventUserSuspendedData),\n    ): Promise<void> {\n        // Search for userid in params.\n        let userId = 0;\n\n        if (data.params.userid) {\n            userId = data.params.userid;\n        } else if (data.params.userids) {\n            userId = data.params.userids[0];\n        } else if (data.params.field === 'id' && data.params.values && data.params.values.length) {\n            userId = data.params.values[0];\n        } else if (data.params.userlist && data.params.userlist.length) {\n            userId = data.params.userlist[0].userid;\n        }\n\n        if (userId > 0) {\n            await this.deleteStoredUser(userId, data.siteId);\n        }\n    }\n\n    /**\n     * Store user basic information in local DB to be retrieved if the WS call fails.\n     *\n     * @param userId User ID.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolve when the user is deleted.\n     */\n    async deleteStoredUser(userId: number, siteId?: string): Promise<void> {\n        if (isNaN(userId)) {\n            throw new CoreError('Invalid user ID.');\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        await Promise.all([\n            this.invalidateUserCache(userId, site.getId()),\n            site.getDb().deleteRecords(USERS_TABLE_NAME, { id: userId }),\n        ]);\n    }\n\n    /**\n     * Get participants for a certain course.\n     *\n     * @param courseId ID of the course.\n     * @param limitFrom Position of the first participant to get.\n     * @param limitNumber Number of participants to get.\n     * @param siteId Site Id. If not defined, use current site.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved when the participants are retrieved.\n     */\n    async getParticipants(\n        courseId: number,\n        limitFrom: number = 0,\n        limitNumber: number = CoreUserProvider.PARTICIPANTS_LIST_LIMIT,\n        siteId?: string,\n        ignoreCache?: boolean,\n    ): Promise<{participants: CoreUserParticipant[]; canLoadMore: boolean}> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        this.logger.debug(`Get participants for course '${courseId}' starting at '${limitFrom}'`);\n\n        const params: CoreEnrolGetEnrolledUsersWSParams = {\n            courseid: courseId,\n            options: [\n                {\n                    name: 'limitfrom',\n                    value: String(limitFrom),\n                },\n                {\n                    name: 'limitnumber',\n                    value: String(limitNumber),\n                },\n                {\n                    name: 'sortby',\n                    value: 'siteorder',\n                },\n            ],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getParticipantsListCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n\n        if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        const users = await site.read<CoreEnrolGetEnrolledUsersWSResponse>('core_enrol_get_enrolled_users', params, preSets);\n\n        const canLoadMore = users.length >= limitNumber;\n        this.storeUsers(users, siteId);\n\n        return { participants: users, canLoadMore: canLoadMore };\n    }\n\n    /**\n     * Get cache key for participant list WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getParticipantsListCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'list:' + courseId;\n    }\n\n    /**\n     * Get user profile. The type of profile retrieved depends on the params.\n     *\n     * @param userId User's ID.\n     * @param courseId Course ID to get course profile, undefined or 0 to get site profile.\n     * @param forceLocal True to retrieve the user data from local DB, false to retrieve it from WS.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolved with the user data.\n     */\n    async getProfile(\n        userId: number,\n        courseId?: number,\n        forceLocal: boolean = false,\n        siteId?: string,\n    ): Promise<CoreUserProfile> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (forceLocal) {\n            try {\n                return await this.getUserFromLocalDb(userId, siteId);\n            } catch {\n                return this.getUserFromWS(userId, courseId, siteId);\n            }\n        }\n\n        try {\n            return await this.getUserFromWS(userId, courseId, siteId);\n        } catch (error) {\n            try {\n                return await this.getUserFromLocalDb(userId, siteId);\n            } catch {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Get cache key for a user WS call.\n     *\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getUserCacheKey(userId: number): string {\n        return ROOT_CACHE_KEY + 'data:' + userId;\n    }\n\n    /**\n     * Get user basic information from local DB.\n     *\n     * @param userId User ID.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolve when the user is retrieved.\n     */\n    protected async getUserFromLocalDb(userId: number, siteId?: string): Promise<CoreUserDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecord(USERS_TABLE_NAME, { id: userId });\n    }\n\n    /**\n     * Get a user fullname, using a default text if user not found.\n     *\n     * @param userId User ID.\n     * @param courseId Course ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved with user name.\n     */\n    async getUserFullNameWithDefault(userId: number, courseId?: number, siteId?: string): Promise<string> {\n        try {\n            const user = await CoreUser.getProfile(userId, courseId, true, siteId);\n\n            return user.fullname;\n\n        } catch {\n            return Translate.instant('core.user.userwithid', { id: userId });\n        }\n    }\n\n    /**\n     * Get user profile from WS.\n     *\n     * @param userId User ID.\n     * @param courseId Course ID to get course profile, undefined or 0 to get site profile.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolve when the user is retrieved.\n     */\n    protected async getUserFromWS(\n        userId: number,\n        courseId?: number,\n        siteId?: string,\n    ): Promise<CoreUserCourseProfile | CoreUserData> {\n        const site = await CoreSites.getSite(siteId);\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getUserCacheKey(userId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n        let users: CoreUserData[] | CoreUserCourseProfile[] | undefined;\n\n        // Determine WS and data to use.\n        if (courseId && courseId != site.getSiteHomeId()) {\n            this.logger.debug(`Get participant with ID '${userId}' in course '${courseId}`);\n\n            const params: CoreUserGetCourseUserProfilesWSParams = {\n                userlist: [\n                    {\n                        userid: userId,\n                        courseid: courseId,\n                    },\n                ],\n            };\n\n            users = await site.read<CoreUserGetCourseUserProfilesWSResponse>('core_user_get_course_user_profiles', params, preSets);\n        } else {\n            this.logger.debug(`Get user with ID '${userId}'`);\n\n            const params: CoreUserGetUsersByFieldWSParams = {\n                field: 'id',\n                values: [String(userId)],\n            };\n\n            users = await site.read<CoreUserGetUsersByFieldWSResponse>('core_user_get_users_by_field', params, preSets);\n        }\n\n        if (users.length == 0) {\n            // Shouldn't happen.\n            throw new CoreError('Cannot retrieve user info.');\n        }\n\n        const user: CoreUserData | CoreUserCourseProfile = users[0];\n        if (user.country) {\n            user.country = CoreUtils.getCountryName(user.country);\n        }\n        this.storeUser(user.id, user.fullname, user.profileimageurl);\n\n        return user;\n    }\n\n    /**\n     * Get a user preference (online or offline).\n     *\n     * @param name Name of the preference.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Preference value or null if preference not set.\n     */\n    async getUserPreference(name: string, siteId?: string): Promise<string | null> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const preference = await CoreUtils.ignoreErrors(CoreUserOffline.getPreference(name, siteId));\n\n        if (preference && !CoreNetwork.isOnline()) {\n            // Offline, return stored value.\n            return preference.value;\n        }\n\n        const wsValue = await this.getUserPreferenceOnline(name, siteId);\n\n        if (preference && preference.value != preference.onlinevalue && preference.onlinevalue == wsValue) {\n            // Sync is pending for this preference, return stored value.\n            return preference.value;\n        }\n\n        if (!wsValue) {\n            return null;\n        }\n\n        await CoreUserOffline.setPreference(name, wsValue, wsValue);\n\n        return wsValue;\n    }\n\n    /**\n     * Get cache key for a user preference WS call.\n     *\n     * @param name Preference name.\n     * @returns Cache key.\n     */\n    protected getUserPreferenceCacheKey(name: string): string {\n        return ROOT_CACHE_KEY + 'preference:' + name;\n    }\n\n    /**\n     * Get a user preference online.\n     *\n     * @param name Name of the preference.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Preference value or null if preference not set.\n     */\n    async getUserPreferenceOnline(name: string, siteId?: string): Promise<string | null> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreUserGetUserPreferencesWSParams = {\n            name,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getUserPreferenceCacheKey(name),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n\n        const result = await site.read<CoreUserGetUserPreferencesWSResponse>('core_user_get_user_preferences', params, preSets);\n\n        return result.preferences[0] ? result.preferences[0].value : null;\n    }\n\n    /**\n     * Invalidates user WS calls.\n     *\n     * @param userId User ID.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserCache(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getUserCacheKey(userId));\n    }\n\n    /**\n     * Invalidates participant list for a certain course.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the list is invalidated.\n     */\n    async invalidateParticipantsList(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getParticipantsListCacheKey(courseId));\n    }\n\n    /**\n     * Invalidate user preference.\n     *\n     * @param name Name of the preference.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserPreference(name: string, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getUserPreferenceCacheKey(name));\n    }\n\n    /**\n     * Check if course participants is disabled in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n     */\n    async isParticipantsDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.isParticipantsDisabledInSite(site);\n    }\n\n    /**\n     * Check if course participants is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether it's disabled.\n     */\n    isParticipantsDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site?.isFeatureDisabled('CoreCourseOptionsDelegate_CoreUserParticipants');\n    }\n\n    /**\n     * Returns whether or not participants is enabled for a certain course.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n     */\n    isPluginEnabledForCourse(courseId: number, siteId?: string): Promise<boolean> {\n        if (!courseId) {\n            throw new CoreError('Invalid course ID.');\n        }\n\n        // Retrieving one participant will fail if browsing users is disabled by capabilities.\n        return CoreUtils.promiseWorks(this.getParticipants(courseId, 0, 1, siteId));\n    }\n\n    /**\n     * Check if update profile picture is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns True if disabled, false otherwise.\n     */\n    isUpdatePictureDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site?.isFeatureDisabled('CoreUserDelegate_picture');\n    }\n\n    /**\n     * Log User Profile View in Moodle.\n     *\n     * @param userId User ID.\n     * @param courseId Course ID.\n     * @returns Promise resolved when done.\n     */\n    async logView(userId: number, courseId?: number, siteId?: string): Promise<CoreStatusWithWarningsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreUserViewUserProfileWSParams = {\n            userid: userId,\n        };\n\n        if (courseId) {\n            params.courseid = courseId;\n        }\n\n        return site.write('core_user_view_user_profile', params);\n    }\n\n    /**\n     * Log Participants list view in Moodle.\n     *\n     * @param courseId Course ID.\n     * @returns Promise resolved when done.\n     */\n    async logParticipantsView(courseId: number, siteId?: string): Promise<CoreStatusWithWarningsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreUserViewUserListWSParams = {\n            courseid: courseId,\n        };\n\n        return site.write('core_user_view_user_list', params);\n    }\n\n    /**\n     * Prefetch user profiles and their images from a certain course. It prevents duplicates.\n     *\n     * @param userIds List of user IDs.\n     * @param courseId Course the users belong to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when prefetched.\n     */\n    async prefetchProfiles(userIds: number[], courseId?: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!siteId) {\n            return;\n        }\n\n        const treated: Record<string, boolean> = {};\n\n        await Promise.all(userIds.map(async (userId) => {\n            if (userId === null || !siteId) {\n                return;\n            }\n\n            userId = Number(userId); // Make sure it's a number.\n\n            // Prevent repeats and errors.\n            if (isNaN(userId) || treated[userId] || userId <= 0) {\n                return;\n            }\n\n            treated[userId] = true;\n\n            try {\n                const profile = await this.getProfile(userId, courseId, false, siteId);\n\n                if (profile.profileimageurl) {\n                    await CoreFilepool.addToQueueByUrl(siteId, profile.profileimageurl);\n                }\n            } catch (error) {\n                this.logger.warn(`Ignore error when prefetching user ${userId}`, error);\n            }\n        }));\n    }\n\n    /**\n     * Prefetch user avatars. It prevents duplicates.\n     *\n     * @param entries List of entries that have the images.\n     * @param propertyName The name of the property that contains the image.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when prefetched.\n     */\n    async prefetchUserAvatars(entries: Record<string, unknown>[], propertyName: string, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!siteId) {\n            return;\n        }\n\n        const treated: Record<string, boolean> = {};\n\n        const promises = entries.map(async (entry) => {\n            const imageUrl = <string> entry[propertyName];\n\n            if (!imageUrl || treated[imageUrl] || !siteId) {\n                // It doesn't have an image or it has already been treated.\n                return;\n            }\n\n            // Do not prefetch when initials are set and image is default.\n            if ('firstname' in entry || 'lastname' in entry) {\n                const initials = CoreUserHelper.getUserInitials(entry);\n                if (initials && imageUrl && CoreUrlUtils.isThemeImageUrl(imageUrl)) {\n                    return;\n                }\n            }\n\n            treated[imageUrl] = true;\n\n            try {\n                await CoreFilepool.addToQueueByUrl(siteId, imageUrl);\n            } catch (ex) {\n                this.logger.warn(`Ignore error when prefetching user avatar ${imageUrl}`, entry, ex);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Search participants in a certain course.\n     *\n     * @param courseId ID of the course.\n     * @param search The string to search.\n     * @param searchAnywhere Whether to find a match anywhere or only at the beginning.\n     * @param page Page to get.\n     * @param perPage Number of participants to get.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the participants are retrieved.\n     * @since 3.8\n     */\n    async searchParticipants(\n        courseId: number,\n        search: string,\n        searchAnywhere: boolean = true,\n        page: number = 0,\n        perPage: number = CoreUserProvider.PARTICIPANTS_LIST_LIMIT,\n        siteId?: string,\n    ): Promise<{participants: CoreUserData[]; canLoadMore: boolean}> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreEnrolSearchUsersWSParams = {\n            courseid: courseId,\n            search: search,\n            searchanywhere: !!searchAnywhere,\n            page: page,\n            perpage: perPage,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            getFromCache: false, // Always try to get updated data. If it fails, it will get it from cache.\n        };\n\n        const users = await site.read<CoreEnrolSearchUsersWSResponse>('core_enrol_search_users', params, preSets);\n\n        const canLoadMore = users.length >= perPage;\n        this.storeUsers(users, siteId);\n\n        return { participants: users, canLoadMore: canLoadMore };\n    }\n\n    /**\n     * Store user basic information in local DB to be retrieved if the WS call fails.\n     *\n     * @param userId User ID.\n     * @param fullname User full name.\n     * @param avatar User avatar URL.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolve when the user is stored.\n     */\n    protected async storeUser(userId: number, fullname: string, avatar?: string, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const userRecord: CoreUserDBRecord = {\n            id: userId,\n            fullname: fullname,\n            profileimageurl: avatar,\n        };\n\n        await site.getDb().insertRecord(USERS_TABLE_NAME, userRecord);\n    }\n\n    /**\n     * Store users basic information in local DB.\n     *\n     * @param users Users to store.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolve when the user is stored.\n     */\n    async storeUsers(users: CoreUserBasicData[], siteId?: string): Promise<void> {\n\n        await Promise.all(users.map((user) => {\n            if (!user.id || isNaN(Number(user.id))) {\n                return;\n            }\n\n            return this.storeUser(Number(user.id), user.fullname, user.profileimageurl, siteId);\n        }));\n    }\n\n    /**\n     * Set a user preference (online or offline).\n     *\n     * @param name Name of the preference.\n     * @param value Value of the preference.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved on success.\n     */\n    async setUserPreference(name: string, value: string, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!CoreNetwork.isOnline()) {\n            // Offline, just update the preference.\n            return CoreUserOffline.setPreference(name, value);\n        }\n\n        try {\n            // Update the preference in the site.\n            const preferences = [\n                { type: name, value },\n            ];\n\n            await this.updateUserPreferences(preferences, undefined, undefined, siteId);\n\n            // Update preference and invalidate data.\n            await Promise.all([\n                CoreUserOffline.setPreference(name, value, value),\n                CoreUtils.ignoreErrors(this.invalidateUserPreference(name)),\n            ]);\n        } catch (error) {\n            // Preference not saved online. Update the offline one.\n            await CoreUserOffline.setPreference(name, value);\n        }\n    }\n\n    /**\n     * Update a preference for a user.\n     *\n     * @param name Preference name.\n     * @param value Preference new value.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success.\n     */\n    updateUserPreference(name: string, value: string | undefined, userId?: number, siteId?: string): Promise<void> {\n        const preferences = [\n            {\n                type: name,\n                value: value,\n            },\n        ];\n\n        return this.updateUserPreferences(preferences, undefined, userId, siteId);\n    }\n\n    /**\n     * Update some preferences for a user.\n     *\n     * @param preferences List of preferences.\n     * @param disableNotifications Whether to disable all notifications. Undefined to not update this value.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success.\n     */\n    async updateUserPreferences(\n        preferences: { type: string; value: string | undefined }[],\n        disableNotifications?: boolean,\n        userId?: number,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        const params: CoreUserUpdateUserPreferencesWSParams = {\n            userid: userId,\n            preferences: preferences,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            responseExpected: false,\n        };\n\n        if (disableNotifications !== undefined) {\n            params.emailstop = disableNotifications ? 1 : 0;\n        }\n\n        await site.write('core_user_update_user_preferences', params, preSets);\n    }\n\n}\nexport const CoreUser = makeSingleton(CoreUserProvider);\n\n/**\n * Data passed to PROFILE_REFRESHED event.\n */\nexport type CoreUserProfileRefreshedData = {\n    courseId?: number; // Course the user profile belongs to.\n    userId: number; // User ID.\n    user?: CoreUserProfile; // User affected.\n};\n\n/**\n * Data passed to PROFILE_PICTURE_UPDATED event.\n */\nexport type CoreUserProfilePictureUpdatedData = {\n    userId: number; // User ID.\n    picture: string | undefined; // New picture URL.\n};\n\n/**\n * Basic data of a user.\n */\nexport type CoreUserBasicData = {\n    id: number; // ID of the user.\n    fullname: string; // The fullname of the user.\n    profileimageurl?: string; // User image profile URL - big version.\n};\n\n/**\n * User preference.\n */\nexport type CoreUserPreference = {\n    name: string; // The name of the preference.\n    value: string; // The value of the preferenc.\n};\n\n/**\n * User custom profile field.\n */\nexport type CoreUserProfileField = {\n    type: string; // The type of the custom field - text field, checkbox...\n    value: string; // The value of the custom field.\n    displayvalue?: string; // @since 4.2. Formatted value of the custom field.\n    name: string; // The name of the custom field.\n    shortname: string; // The shortname of the custom field - to be able to build the field class in the code.\n};\n\n/**\n * User group.\n */\nexport type CoreUserGroup = {\n    id: number; // Group id.\n    name: string; // Group name.\n    description: string; // Group description.\n    descriptionformat: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n};\n\n/**\n * User role.\n */\nexport type CoreUserRole = {\n    roleid: number; // Role id.\n    name: string; // Role name.\n    shortname: string; // Role shortname.\n    sortorder: number; // Role sortorder.\n};\n\n/**\n * Basic data of a course the user is enrolled in.\n */\nexport type CoreUserEnrolledCourse = {\n    id: number; // Id of the course.\n    fullname: string; // Fullname of the course.\n    shortname: string; // Shortname of the course.\n};\n\n/**\n * Common data returned by user_description function.\n */\nexport type CoreUserData = {\n    id: number; // ID of the user.\n    username?: string; // The username.\n    firstname?: string; // The first name(s) of the user.\n    lastname?: string; // The family name of the user.\n    fullname: string; // The fullname of the user.\n    email?: string; // An email address - allow email as root@localhost.\n    address?: string; // Postal address.\n    phone1?: string; // Phone 1.\n    phone2?: string; // Phone 2.\n    icq?: string; // Icq number.\n    skype?: string; // Skype id.\n    yahoo?: string; // Yahoo id.\n    aim?: string; // Aim id.\n    msn?: string; // Msn number.\n    department?: string; // Department.\n    institution?: string; // Institution.\n    idnumber?: string; // An arbitrary ID code number perhaps from the institution.\n    interests?: string; // User interests (separated by commas).\n    firstaccess?: number; // First access to the site (0 if never).\n    lastaccess?: number; // Last access to the site (0 if never).\n    auth?: string; // Auth plugins include manual, ldap, etc.\n    suspended?: boolean; // Suspend user account, either false to enable user login or true to disable it.\n    confirmed?: boolean; // Active user: 1 if confirmed, 0 otherwise.\n    lang?: string; // Language code such as \"en\", must exist on server.\n    calendartype?: string; // Calendar type such as \"gregorian\", must exist on server.\n    theme?: string; // Theme name such as \"standard\", must exist on server.\n    timezone?: string; // Timezone code such as Australia/Perth, or 99 for default.\n    mailformat?: number; // Mail format code is 0 for plain text, 1 for HTML etc.\n    description?: string; // User profile description.\n    descriptionformat?: number; // Int format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    city?: string; // Home city of the user.\n    url?: string; // URL of the user.\n    country?: string; // Home country code of the user, such as AU or CZ.\n    profileimageurlsmall: string; // User image profile URL - small version.\n    profileimageurl: string; // User image profile URL - big version.\n    customfields?: CoreUserProfileField[]; // User custom fields (also known as user profile fields).\n    preferences?: CoreUserPreference[]; // Users preferences.\n};\n\n/**\n * Data returned by user_summary_exporter.\n */\nexport type CoreUserSummary = {\n    id: number; // Id.\n    email: string; // Email.\n    idnumber: string; // Idnumber.\n    phone1: string; // Phone1.\n    phone2: string; // Phone2.\n    department: string; // Department.\n    institution: string; // Institution.\n    fullname: string; // Fullname.\n    identity: string; // Identity.\n    profileurl: string; // Profileurl.\n    profileimageurl: string; // Profileimageurl.\n    profileimageurlsmall: string; // Profileimageurlsmall.\n};\n\n/**\n * User data returned by core_enrol_get_enrolled_users WS.\n */\nexport type CoreUserParticipant = CoreUserBasicData & {\n    username?: string; // Username policy is defined in Moodle security config.\n    firstname?: string; // The first name(s) of the user.\n    lastname?: string; // The family name of the user.\n    email?: string; // An email address - allow email as root@localhost.\n    address?: string; // Postal address.\n    phone1?: string; // Phone 1.\n    phone2?: string; // Phone 2.\n    icq?: string; // Icq number.\n    skype?: string; // Skype id.\n    yahoo?: string; // Yahoo id.\n    aim?: string; // Aim id.\n    msn?: string; // Msn number.\n    department?: string; // Department.\n    institution?: string; // Institution.\n    idnumber?: string; // An arbitrary ID code number perhaps from the institution.\n    interests?: string; // User interests (separated by commas).\n    firstaccess?: number; // First access to the site (0 if never).\n    lastaccess?: number; // Last access to the site (0 if never).\n    lastcourseaccess?: number | null; // @since 3.7. Last access to the course (0 if never).\n    description?: string; // User profile description.\n    descriptionformat?: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    city?: string; // Home city of the user.\n    url?: string; // URL of the user.\n    country?: string; // Home country code of the user, such as AU or CZ.\n    profileimageurlsmall?: string; // User image profile URL - small version.\n    customfields?: CoreUserProfileField[]; // User custom fields (also known as user profil fields).\n    groups?: CoreUserGroup[]; // User groups.\n    roles?: CoreUserRole[]; // User roles.\n    preferences?: CoreUserPreference[]; // User preferences.\n    enrolledcourses?: CoreUserEnrolledCourse[]; // Courses where the user is enrolled.\n};\n\n/**\n * User data returned by core_user_get_course_user_profiles WS.\n */\nexport type CoreUserCourseProfile = CoreUserData & {\n    groups?: CoreUserGroup[]; // User groups.\n    roles?: CoreUserRole[]; // User roles.\n    enrolledcourses?: CoreUserEnrolledCourse[]; // Courses where the user is enrolled.\n};\n\n/**\n * User data returned by getProfile.\n */\nexport type CoreUserProfile = (CoreUserBasicData & Partial<CoreUserData>) | CoreUserCourseProfile;\n\n/**\n * Params of core_user_update_picture WS.\n */\ntype CoreUserUpdatePictureWSParams = {\n    draftitemid: number; // Id of the user draft file to use as image.\n    delete?: boolean; // If we should delete the user picture.\n    userid?: number; // Id of the user, 0 for current user.\n};\n\n/**\n * Data returned by core_user_update_picture WS.\n */\ntype CoreUserUpdatePictureWSResponse = {\n    success: boolean; // True if the image was updated, false otherwise.\n    profileimageurl?: string; // New profile user image url.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_enrol_get_enrolled_users WS.\n */\ntype CoreEnrolGetEnrolledUsersWSParams = {\n    courseid: number; // Course id.\n    options?: {\n        name: string; // Option name.\n        value: string; // Option value.\n    }[];\n};\n\n/**\n * Data returned by core_enrol_get_enrolled_users WS.\n */\ntype CoreEnrolGetEnrolledUsersWSResponse = CoreUserParticipant[];\n\n/**\n * Params of core_user_get_course_user_profiles WS.\n */\ntype CoreUserGetCourseUserProfilesWSParams = {\n    userlist: {\n        userid: number; // Userid.\n        courseid: number; // Courseid.\n    }[];\n};\n\n/**\n * Data returned by core_user_get_course_user_profiles WS.\n */\ntype CoreUserGetCourseUserProfilesWSResponse = CoreUserCourseProfile[];\n\n/**\n * Params of core_user_get_users_by_field WS.\n */\ntype CoreUserGetUsersByFieldWSParams = {\n    field: string; // The search field can be 'id' or 'idnumber' or 'username' or 'email'.\n    values: string[];\n};\n/**\n * Data returned by core_user_get_users_by_field WS.\n */\ntype CoreUserGetUsersByFieldWSResponse = CoreUserData[];\n\n/**\n * Params of core_user_get_user_preferences WS.\n */\ntype CoreUserGetUserPreferencesWSParams = {\n    name?: string; // Preference name, empty for all.\n    userid?: number; // Id of the user, default to current user.\n};\n\n/**\n * Data returned by core_user_get_user_preferences WS.\n */\ntype CoreUserGetUserPreferencesWSResponse = {\n    preferences: { // User custom fields (also known as user profile fields).\n        name: string; // The name of the preference.\n        value: string | null; // The value of the preference.\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_user_view_user_list WS.\n */\ntype CoreUserViewUserListWSParams = {\n    courseid: number; // Id of the course, 0 for site.\n};\n\n/**\n * Params of core_user_view_user_profile WS.\n */\ntype CoreUserViewUserProfileWSParams = {\n    userid: number; // Id of the user, 0 for current user.\n    courseid?: number; // Id of the course, default site course.\n};\n\n/**\n * Params of core_user_update_user_preferences WS.\n */\ntype CoreUserUpdateUserPreferencesWSParams = {\n    userid?: number; // Id of the user, default to current user.\n    emailstop?: number; // Enable or disable notifications for this user.\n    preferences?: { // User preferences.\n        type: string; // The name of the preference.\n        value?: string; // The value of the preference, do not set this field if you want to remove (unset) the current value.\n    }[];\n};\n\n/**\n * Params of core_enrol_search_users WS.\n */\ntype CoreEnrolSearchUsersWSParams = {\n    courseid: number; // Course id.\n    search: string; // Query.\n    searchanywhere: boolean; // Find a match anywhere, or only at the beginning.\n    page: number; // Page number.\n    perpage: number; // Number per page.\n};\n\n/**\n * Data returned by core_enrol_search_users WS.\n */\ntype CoreEnrolSearchUsersWSResponse = CoreUserData[];\n"],"mappings":";;AAgBA,SAASA,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,eAAe,QAAQ,gBAAgB;AAChD,SAASC,UAAU,QAAQ,oBAAoB;AAC/C,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,aAAa,EAAEC,SAAS,QAAQ,aAAa;AACtD,SAASC,UAAU,QAAiF,oBAAoB;AAExH,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,gBAAgB,QAA0B,iBAAiB;AACpE,SAASC,cAAc,QAAQ,eAAe;AAC9C,SAASC,YAAY,QAAQ,qBAAqB;;AAGlD,MAAMC,cAAc,GAAG,SAAS;AAgBhC;;;AAGA,OAAO,MAAMC,sBAAsB,GAAG,0BAA0B;AAEhE;;;AAGA,OAAO,MAAMC,4BAA4B,GAAG,+BAA+B;AAE3E;;;AAGA,OAAO,MAAMC,4BAA4B,GAAG,IAAI;AAEhD;;;AAGA,OAAO,MAAMC,iBAAiB,GAAG,CAAC,EAAE;AAEpC;;;AAIA,OAAM,MAAOC,gBAAgB;EAEqB;EAI9CC,YAAA;IACI,IAAI,CAACC,MAAM,GAAGhB,UAAU,CAACiB,WAAW,CAAC,kBAAkB,CAAC;IAExDb,UAAU,CAACc,EAAE,CAACd,UAAU,CAACe,YAAY,EAAEC,IAAI,IAAI,IAAI,CAACC,wBAAwB,CAACD,IAAI,CAAC,CAAC;IACnFhB,UAAU,CAACc,EAAE,CAACd,UAAU,CAACkB,cAAc,EAAEF,IAAI,IAAI,IAAI,CAACC,wBAAwB,CAACD,IAAI,CAAC,CAAC;IACrFhB,UAAU,CAACc,EAAE,CAACd,UAAU,CAACmB,aAAa,EAAEH,IAAI,IAAI,IAAI,CAACC,wBAAwB,CAACD,IAAI,CAAC,CAAC;EACxF;EAEA;;;;;;;EAOMI,qBAAqBA,CAACC,MAAe;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MACvC,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,OAAOC,KAAI,CAACI,2BAA2B,CAACF,IAAI,CAAC;IAAC;EAClD;EAEA;;;;;;;EAOAE,2BAA2BA,CAACF,IAAe;IAAA,IAAAG,KAAA;IACvCH,IAAI,GAAGA,IAAI,IAAI/B,SAAS,CAACmC,cAAc,EAAE;IAEzC,OAAO,CAAC,GAAAD,KAAA,GAACH,IAAI,cAAAG,KAAA,eAAJA,KAAA,CAAME,WAAW,CAAC,yBAAyB,CAAC;EACzD;EAEA;;;;;;;;EAQMC,oBAAoBA,CAACC,WAAmB,EAAEC,MAAc,EAAEX,MAAe;IAAA,OAAAE,iBAAA;MAC3E,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMY,MAAM,GAAkC;QAC1CC,WAAW,EAAEH,WAAW;QACxBI,MAAM,EAAE,KAAK;QACbC,MAAM,EAAEJ;OACX;MAED,MAAMK,MAAM,SAASb,IAAI,CAACc,KAAK,CAAkC,0BAA0B,EAAEL,MAAM,CAAC;MAEpG,IAAI,CAACI,MAAM,CAACE,OAAO,IAAI,CAACF,MAAM,CAACG,eAAe,EAAE;QAC5C,OAAOC,OAAO,CAACC,MAAM,CAAC,IAAI,CAAC;;MAG/B,OAAOL,MAAM,CAACG,eAAe;IAAC;EAClC;EAEA;;;;;EAKMvB,wBAAwBA,CAC1BD,IAAiF;IAAA,IAAA2B,MAAA;IAAA,OAAApB,iBAAA;MAEjF;MACA,IAAIS,MAAM,GAAG,CAAC;MAEd,IAAIhB,IAAI,CAACiB,MAAM,CAACG,MAAM,EAAE;QACpBJ,MAAM,GAAGhB,IAAI,CAACiB,MAAM,CAACG,MAAM;OAC9B,MAAM,IAAIpB,IAAI,CAACiB,MAAM,CAACW,OAAO,EAAE;QAC5BZ,MAAM,GAAGhB,IAAI,CAACiB,MAAM,CAACW,OAAO,CAAC,CAAC,CAAC;OAClC,MAAM,IAAI5B,IAAI,CAACiB,MAAM,CAACY,KAAK,KAAK,IAAI,IAAI7B,IAAI,CAACiB,MAAM,CAACa,MAAM,IAAI9B,IAAI,CAACiB,MAAM,CAACa,MAAM,CAACC,MAAM,EAAE;QACtFf,MAAM,GAAGhB,IAAI,CAACiB,MAAM,CAACa,MAAM,CAAC,CAAC,CAAC;OACjC,MAAM,IAAI9B,IAAI,CAACiB,MAAM,CAACe,QAAQ,IAAIhC,IAAI,CAACiB,MAAM,CAACe,QAAQ,CAACD,MAAM,EAAE;QAC5Df,MAAM,GAAGhB,IAAI,CAACiB,MAAM,CAACe,QAAQ,CAAC,CAAC,CAAC,CAACZ,MAAM;;MAG3C,IAAIJ,MAAM,GAAG,CAAC,EAAE;QACZ,MAAMW,MAAI,CAACM,gBAAgB,CAACjB,MAAM,EAAEhB,IAAI,CAACK,MAAM,CAAC;;IACnD;EACL;EAEA;;;;;;;EAOM4B,gBAAgBA,CAACjB,MAAc,EAAEX,MAAe;IAAA,IAAA6B,MAAA;IAAA,OAAA3B,iBAAA;MAClD,IAAI4B,KAAK,CAACnB,MAAM,CAAC,EAAE;QACf,MAAM,IAAI/B,SAAS,CAAC,kBAAkB,CAAC;;MAG3C,MAAMuB,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMoB,OAAO,CAACW,GAAG,CAAC,CACdF,MAAI,CAACG,mBAAmB,CAACrB,MAAM,EAAER,IAAI,CAAC8B,KAAK,EAAE,CAAC,EAC9C9B,IAAI,CAAC+B,KAAK,EAAE,CAACC,aAAa,CAACtD,gBAAgB,EAAE;QAAEuD,EAAE,EAAEzB;MAAM,CAAE,CAAC,CAC/D,CAAC;IAAC;EACP;EAEA;;;;;;;;;;EAUM0B,eAAeA,CACjBC,QAAgB,EAChBC,SAAA,GAAoB,CAAC,EACrBC,WAAA,GAAsBnD,gBAAgB,CAACoD,uBAAuB,EAC9DzC,MAAe,EACf0C,WAAqB;IAAA,IAAAC,MAAA;IAAA,OAAAzC,iBAAA;MAGrB,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C2C,MAAI,CAACpD,MAAM,CAACqD,KAAK,CAAC,gCAAgCN,QAAQ,kBAAkBC,SAAS,GAAG,CAAC;MAEzF,MAAM3B,MAAM,GAAsC;QAC9CiC,QAAQ,EAAEP,QAAQ;QAClBQ,OAAO,EAAE,CACL;UACIC,IAAI,EAAE,WAAW;UACjBC,KAAK,EAAEC,MAAM,CAACV,SAAS;SAC1B,EACD;UACIQ,IAAI,EAAE,aAAa;UACnBC,KAAK,EAAEC,MAAM,CAACT,WAAW;SAC5B,EACD;UACIO,IAAI,EAAE,QAAQ;UACdC,KAAK,EAAE;SACV;OAER;MACD,MAAME,OAAO,GAAsB;QAC/BC,QAAQ,EAAER,MAAI,CAACS,2BAA2B,CAACd,QAAQ,CAAC;QACpDe,eAAe,EAAE7E,QAAQ,CAAC8E;OAC7B;MAED,IAAIZ,WAAW,EAAE;QACbQ,OAAO,CAACK,YAAY,GAAG,KAAK;QAC5BL,OAAO,CAACM,cAAc,GAAG,KAAK;;MAGlC,MAAMC,KAAK,SAAStD,IAAI,CAACuD,IAAI,CAAsC,+BAA+B,EAAE9C,MAAM,EAAEsC,OAAO,CAAC;MAEpH,MAAMS,WAAW,GAAGF,KAAK,CAAC/B,MAAM,IAAIc,WAAW;MAC/CG,MAAI,CAACiB,UAAU,CAACH,KAAK,EAAEzD,MAAM,CAAC;MAE9B,OAAO;QAAE6D,YAAY,EAAEJ,KAAK;QAAEE,WAAW,EAAEA;MAAW,CAAE;IAAC;EAC7D;EAEA;;;;;;EAMUP,2BAA2BA,CAACd,QAAgB;IAClD,OAAOtD,cAAc,GAAG,OAAO,GAAGsD,QAAQ;EAC9C;EAEA;;;;;;;;;EASMwB,UAAUA,CACZnD,MAAc,EACd2B,QAAiB,EACjByB,UAAA,GAAsB,KAAK,EAC3B/D,MAAe;IAAA,IAAAgE,MAAA;IAAA,OAAA9D,iBAAA;MAEfF,MAAM,GAAGA,MAAM,IAAI5B,SAAS,CAAC6F,gBAAgB,EAAE;MAE/C,IAAIF,UAAU,EAAE;QACZ,IAAI;UACA,aAAaC,MAAI,CAACE,kBAAkB,CAACvD,MAAM,EAAEX,MAAM,CAAC;SACvD,CAAC,OAAAmE,OAAA,EAAM;UACJ,OAAOH,MAAI,CAACI,aAAa,CAACzD,MAAM,EAAE2B,QAAQ,EAAEtC,MAAM,CAAC;;;MAI3D,IAAI;QACA,aAAagE,MAAI,CAACI,aAAa,CAACzD,MAAM,EAAE2B,QAAQ,EAAEtC,MAAM,CAAC;OAC5D,CAAC,OAAOqE,KAAK,EAAE;QACZ,IAAI;UACA,aAAaL,MAAI,CAACE,kBAAkB,CAACvD,MAAM,EAAEX,MAAM,CAAC;SACvD,CAAC,OAAAsE,QAAA,EAAM;UACJ,MAAMD,KAAK;;;IAElB;EACL;EAEA;;;;;;EAMUE,eAAeA,CAAC5D,MAAc;IACpC,OAAO3B,cAAc,GAAG,OAAO,GAAG2B,MAAM;EAC5C;EAEA;;;;;;;EAOgBuD,kBAAkBA,CAACvD,MAAc,EAAEX,MAAe;IAAA,OAAAE,iBAAA;MAC9D,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,OAAOG,IAAI,CAAC+B,KAAK,EAAE,CAACsC,SAAS,CAAC3F,gBAAgB,EAAE;QAAEuD,EAAE,EAAEzB;MAAM,CAAE,CAAC;IAAC;EACpE;EAEA;;;;;;;;EAQM8D,0BAA0BA,CAAC9D,MAAc,EAAE2B,QAAiB,EAAEtC,MAAe;IAAA,OAAAE,iBAAA;MAC/E,IAAI;QACA,MAAMwE,IAAI,SAASC,QAAQ,CAACb,UAAU,CAACnD,MAAM,EAAE2B,QAAQ,EAAE,IAAI,EAAEtC,MAAM,CAAC;QAEtE,OAAO0E,IAAI,CAACE,QAAQ;OAEvB,CAAC,OAAAC,QAAA,EAAM;QACJ,OAAOnG,SAAS,CAACoG,OAAO,CAAC,sBAAsB,EAAE;UAAE1C,EAAE,EAAEzB;QAAM,CAAE,CAAC;;IACnE;EACL;EAEA;;;;;;;;EAQgByD,aAAaA,CACzBzD,MAAc,EACd2B,QAAiB,EACjBtC,MAAe;IAAA,IAAA+E,MAAA;IAAA,OAAA7E,iBAAA;MAEf,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMkD,OAAO,GAAsB;QAC/BC,QAAQ,EAAE4B,MAAI,CAACR,eAAe,CAAC5D,MAAM,CAAC;QACtC0C,eAAe,EAAE7E,QAAQ,CAAC8E;OAC7B;MACD,IAAIG,KAA2D;MAE/D;MACA,IAAInB,QAAQ,IAAIA,QAAQ,IAAInC,IAAI,CAAC6E,aAAa,EAAE,EAAE;QAC9CD,MAAI,CAACxF,MAAM,CAACqD,KAAK,CAAC,4BAA4BjC,MAAM,gBAAgB2B,QAAQ,EAAE,CAAC;QAE/E,MAAM1B,MAAM,GAA0C;UAClDe,QAAQ,EAAE,CACN;YACIZ,MAAM,EAAEJ,MAAM;YACdkC,QAAQ,EAAEP;WACb;SAER;QAEDmB,KAAK,SAAStD,IAAI,CAACuD,IAAI,CAA0C,oCAAoC,EAAE9C,MAAM,EAAEsC,OAAO,CAAC;OAC1H,MAAM;QACH6B,MAAI,CAACxF,MAAM,CAACqD,KAAK,CAAC,qBAAqBjC,MAAM,GAAG,CAAC;QAEjD,MAAMC,MAAM,GAAoC;UAC5CY,KAAK,EAAE,IAAI;UACXC,MAAM,EAAE,CAACwB,MAAM,CAACtC,MAAM,CAAC;SAC1B;QAED8C,KAAK,SAAStD,IAAI,CAACuD,IAAI,CAAoC,8BAA8B,EAAE9C,MAAM,EAAEsC,OAAO,CAAC;;MAG/G,IAAIO,KAAK,CAAC/B,MAAM,IAAI,CAAC,EAAE;QACnB;QACA,MAAM,IAAI9C,SAAS,CAAC,4BAA4B,CAAC;;MAGrD,MAAM8F,IAAI,GAAyCjB,KAAK,CAAC,CAAC,CAAC;MAC3D,IAAIiB,IAAI,CAACO,OAAO,EAAE;QACdP,IAAI,CAACO,OAAO,GAAG5G,SAAS,CAAC6G,cAAc,CAACR,IAAI,CAACO,OAAO,CAAC;;MAEzDF,MAAI,CAACI,SAAS,CAACT,IAAI,CAACtC,EAAE,EAAEsC,IAAI,CAACE,QAAQ,EAAEF,IAAI,CAACvD,eAAe,CAAC;MAE5D,OAAOuD,IAAI;IAAC;EAChB;EAEA;;;;;;;EAOMU,iBAAiBA,CAACrC,IAAY,EAAE/C,MAAe;IAAA,IAAAqF,MAAA;IAAA,OAAAnF,iBAAA;MACjDF,MAAM,GAAGA,MAAM,IAAI5B,SAAS,CAAC6F,gBAAgB,EAAE;MAE/C,MAAMqB,UAAU,SAASjH,SAAS,CAACkH,YAAY,CAACjH,eAAe,CAACkH,aAAa,CAACzC,IAAI,EAAE/C,MAAM,CAAC,CAAC;MAE5F,IAAIsF,UAAU,IAAI,CAACpH,WAAW,CAACuH,QAAQ,EAAE,EAAE;QACvC;QACA,OAAOH,UAAU,CAACtC,KAAK;;MAG3B,MAAM0C,OAAO,SAASL,MAAI,CAACM,uBAAuB,CAAC5C,IAAI,EAAE/C,MAAM,CAAC;MAEhE,IAAIsF,UAAU,IAAIA,UAAU,CAACtC,KAAK,IAAIsC,UAAU,CAACM,WAAW,IAAIN,UAAU,CAACM,WAAW,IAAIF,OAAO,EAAE;QAC/F;QACA,OAAOJ,UAAU,CAACtC,KAAK;;MAG3B,IAAI,CAAC0C,OAAO,EAAE;QACV,OAAO,IAAI;;MAGf,MAAMpH,eAAe,CAACuH,aAAa,CAAC9C,IAAI,EAAE2C,OAAO,EAAEA,OAAO,CAAC;MAE3D,OAAOA,OAAO;IAAC;EACnB;EAEA;;;;;;EAMUI,yBAAyBA,CAAC/C,IAAY;IAC5C,OAAO/D,cAAc,GAAG,aAAa,GAAG+D,IAAI;EAChD;EAEA;;;;;;;EAOM4C,uBAAuBA,CAAC5C,IAAY,EAAE/C,MAAe;IAAA,IAAA+F,MAAA;IAAA,OAAA7F,iBAAA;MACvD,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMY,MAAM,GAAuC;QAC/CmC;OACH;MACD,MAAMG,OAAO,GAAsB;QAC/BC,QAAQ,EAAE4C,MAAI,CAACD,yBAAyB,CAAC/C,IAAI,CAAC;QAC9CM,eAAe,EAAE7E,QAAQ,CAACwH;OAC7B;MAED,MAAMhF,MAAM,SAASb,IAAI,CAACuD,IAAI,CAAuC,gCAAgC,EAAE9C,MAAM,EAAEsC,OAAO,CAAC;MAEvH,OAAOlC,MAAM,CAACiF,WAAW,CAAC,CAAC,CAAC,GAAGjF,MAAM,CAACiF,WAAW,CAAC,CAAC,CAAC,CAACjD,KAAK,GAAG,IAAI;IAAC;EACtE;EAEA;;;;;;;EAOMhB,mBAAmBA,CAACrB,MAAc,EAAEX,MAAe;IAAA,IAAAkG,MAAA;IAAA,OAAAhG,iBAAA;MACrD,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMG,IAAI,CAACgG,uBAAuB,CAACD,MAAI,CAAC3B,eAAe,CAAC5D,MAAM,CAAC,CAAC;IAAC;EACrE;EAEA;;;;;;;EAOMyF,0BAA0BA,CAAC9D,QAAgB,EAAEtC,MAAe;IAAA,IAAAqG,OAAA;IAAA,OAAAnG,iBAAA;MAC9D,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMG,IAAI,CAACgG,uBAAuB,CAACE,OAAI,CAACjD,2BAA2B,CAACd,QAAQ,CAAC,CAAC;IAAC;EACnF;EAEA;;;;;;;EAOMgE,wBAAwBA,CAACvD,IAAY,EAAE/C,MAAe;IAAA,IAAAuG,OAAA;IAAA,OAAArG,iBAAA;MACxD,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMG,IAAI,CAACgG,uBAAuB,CAACI,OAAI,CAACT,yBAAyB,CAAC/C,IAAI,CAAC,CAAC;IAAC;EAC7E;EAEA;;;;;;EAMMyD,sBAAsBA,CAACxG,MAAe;IAAA,IAAAyG,OAAA;IAAA,OAAAvG,iBAAA;MACxC,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,OAAOyG,OAAI,CAACC,4BAA4B,CAACvG,IAAI,CAAC;IAAC;EACnD;EAEA;;;;;;EAMAuG,4BAA4BA,CAACvG,IAAe;IAAA,IAAAwG,MAAA;IACxCxG,IAAI,GAAGA,IAAI,IAAI/B,SAAS,CAACmC,cAAc,EAAE;IAEzC,OAAO,CAAC,GAAAoG,MAAA,GAACxG,IAAI,cAAAwG,MAAA,eAAJA,MAAA,CAAMC,iBAAiB,CAAC,gDAAgD,CAAC;EACtF;EAEA;;;;;;;EAOAC,wBAAwBA,CAACvE,QAAgB,EAAEtC,MAAe;IACtD,IAAI,CAACsC,QAAQ,EAAE;MACX,MAAM,IAAI1D,SAAS,CAAC,oBAAoB,CAAC;;IAG7C;IACA,OAAOP,SAAS,CAACyI,YAAY,CAAC,IAAI,CAACzE,eAAe,CAACC,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAEtC,MAAM,CAAC,CAAC;EAC/E;EAEA;;;;;;EAMA+G,6BAA6BA,CAAC5G,IAAe;IAAA,IAAA6G,MAAA;IACzC7G,IAAI,GAAGA,IAAI,IAAI/B,SAAS,CAACmC,cAAc,EAAE;IAEzC,OAAO,CAAC,GAAAyG,MAAA,GAAC7G,IAAI,cAAA6G,MAAA,eAAJA,MAAA,CAAMJ,iBAAiB,CAAC,0BAA0B,CAAC;EAChE;EAEA;;;;;;;EAOMK,OAAOA,CAACtG,MAAc,EAAE2B,QAAiB,EAAEtC,MAAe;IAAA,OAAAE,iBAAA;MAC5D,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMY,MAAM,GAAoC;QAC5CG,MAAM,EAAEJ;OACX;MAED,IAAI2B,QAAQ,EAAE;QACV1B,MAAM,CAACiC,QAAQ,GAAGP,QAAQ;;MAG9B,OAAOnC,IAAI,CAACc,KAAK,CAAC,6BAA6B,EAAEL,MAAM,CAAC;IAAC;EAC7D;EAEA;;;;;;EAMMsG,mBAAmBA,CAAC5E,QAAgB,EAAEtC,MAAe;IAAA,OAAAE,iBAAA;MACvD,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMY,MAAM,GAAiC;QACzCiC,QAAQ,EAAEP;OACb;MAED,OAAOnC,IAAI,CAACc,KAAK,CAAC,0BAA0B,EAAEL,MAAM,CAAC;IAAC;EAC1D;EAEA;;;;;;;;EAQMuG,gBAAgBA,CAACC,OAAiB,EAAE9E,QAAiB,EAAEtC,MAAe;IAAA,IAAAqH,OAAA;IAAA,OAAAnH,iBAAA;MACxEF,MAAM,GAAGA,MAAM,IAAI5B,SAAS,CAAC6F,gBAAgB,EAAE;MAE/C,IAAI,CAACjE,MAAM,EAAE;QACT;;MAGJ,MAAMsH,OAAO,GAA4B,EAAE;MAE3C,MAAMlG,OAAO,CAACW,GAAG,CAACqF,OAAO,CAACG,GAAG;QAAA,IAAAC,IAAA,GAAAtH,iBAAA,CAAC,WAAOS,MAAM,EAAI;UAC3C,IAAIA,MAAM,KAAK,IAAI,IAAI,CAACX,MAAM,EAAE;YAC5B;;UAGJW,MAAM,GAAG8G,MAAM,CAAC9G,MAAM,CAAC,CAAC,CAAC;UAEzB;UACA,IAAImB,KAAK,CAACnB,MAAM,CAAC,IAAI2G,OAAO,CAAC3G,MAAM,CAAC,IAAIA,MAAM,IAAI,CAAC,EAAE;YACjD;;UAGJ2G,OAAO,CAAC3G,MAAM,CAAC,GAAG,IAAI;UAEtB,IAAI;YACA,MAAM+G,OAAO,SAASL,OAAI,CAACvD,UAAU,CAACnD,MAAM,EAAE2B,QAAQ,EAAE,KAAK,EAAEtC,MAAM,CAAC;YAEtE,IAAI0H,OAAO,CAACvG,eAAe,EAAE;cACzB,MAAMhD,YAAY,CAACwJ,eAAe,CAAC3H,MAAM,EAAE0H,OAAO,CAACvG,eAAe,CAAC;;WAE1E,CAAC,OAAOkD,KAAK,EAAE;YACZgD,OAAI,CAAC9H,MAAM,CAACqI,IAAI,CAAC,sCAAsCjH,MAAM,EAAE,EAAE0D,KAAK,CAAC;;QAE/E,CAAC;QAAA,iBAAAwD,EAAA;UAAA,OAAAL,IAAA,CAAAM,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC,CAAC;IAAC;EACR;EAEA;;;;;;;;EAQMC,mBAAmBA,CAACC,OAAkC,EAAEC,YAAoB,EAAElI,MAAe;IAAA,IAAAmI,OAAA;IAAA,OAAAjI,iBAAA;MAC/FF,MAAM,GAAGA,MAAM,IAAI5B,SAAS,CAAC6F,gBAAgB,EAAE;MAE/C,IAAI,CAACjE,MAAM,EAAE;QACT;;MAGJ,MAAMsH,OAAO,GAA4B,EAAE;MAE3C,MAAMc,QAAQ,GAAGH,OAAO,CAACV,GAAG;QAAA,IAAAc,KAAA,GAAAnI,iBAAA,CAAC,WAAOoI,KAAK,EAAI;UACzC,MAAMC,QAAQ,GAAYD,KAAK,CAACJ,YAAY,CAAC;UAE7C,IAAI,CAACK,QAAQ,IAAIjB,OAAO,CAACiB,QAAQ,CAAC,IAAI,CAACvI,MAAM,EAAE;YAC3C;YACA;;UAGJ;UACA,IAAI,WAAW,IAAIsI,KAAK,IAAI,UAAU,IAAIA,KAAK,EAAE;YAC7C,MAAME,QAAQ,GAAG1J,cAAc,CAAC2J,eAAe,CAACH,KAAK,CAAC;YACtD,IAAIE,QAAQ,IAAID,QAAQ,IAAIxJ,YAAY,CAAC2J,eAAe,CAACH,QAAQ,CAAC,EAAE;cAChE;;;UAIRjB,OAAO,CAACiB,QAAQ,CAAC,GAAG,IAAI;UAExB,IAAI;YACA,MAAMpK,YAAY,CAACwJ,eAAe,CAAC3H,MAAM,EAAEuI,QAAQ,CAAC;WACvD,CAAC,OAAOI,EAAE,EAAE;YACTR,OAAI,CAAC5I,MAAM,CAACqI,IAAI,CAAC,6CAA6CW,QAAQ,EAAE,EAAED,KAAK,EAAEK,EAAE,CAAC;;QAE5F,CAAC;QAAA,iBAAAC,GAAA;UAAA,OAAAP,KAAA,CAAAP,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC;MAEF,MAAM3G,OAAO,CAACW,GAAG,CAACqG,QAAQ,CAAC;IAAC;EAChC;EAEA;;;;;;;;;;;;EAYMS,kBAAkBA,CACpBvG,QAAgB,EAChBwG,MAAc,EACdC,cAAA,GAA0B,IAAI,EAC9BC,IAAA,GAAe,CAAC,EAChBC,OAAA,GAAkB5J,gBAAgB,CAACoD,uBAAuB,EAC1DzC,MAAe;IAAA,IAAAkJ,OAAA;IAAA,OAAAhJ,iBAAA;MAEf,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMY,MAAM,GAAiC;QACzCiC,QAAQ,EAAEP,QAAQ;QAClBwG,MAAM,EAAEA,MAAM;QACdK,cAAc,EAAE,CAAC,CAACJ,cAAc;QAChCC,IAAI,EAAEA,IAAI;QACVI,OAAO,EAAEH;OACZ;MACD,MAAM/F,OAAO,GAAsB;QAC/BK,YAAY,EAAE,KAAK,CAAE;OACxB;;MAED,MAAME,KAAK,SAAStD,IAAI,CAACuD,IAAI,CAAiC,yBAAyB,EAAE9C,MAAM,EAAEsC,OAAO,CAAC;MAEzG,MAAMS,WAAW,GAAGF,KAAK,CAAC/B,MAAM,IAAIuH,OAAO;MAC3CC,OAAI,CAACtF,UAAU,CAACH,KAAK,EAAEzD,MAAM,CAAC;MAE9B,OAAO;QAAE6D,YAAY,EAAEJ,KAAK;QAAEE,WAAW,EAAEA;MAAW,CAAE;IAAC;EAC7D;EAEA;;;;;;;;;EASgBwB,SAASA,CAACxE,MAAc,EAAEiE,QAAgB,EAAEyE,MAAe,EAAErJ,MAAe;IAAA,OAAAE,iBAAA;MACxF,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMsJ,UAAU,GAAqB;QACjClH,EAAE,EAAEzB,MAAM;QACViE,QAAQ,EAAEA,QAAQ;QAClBzD,eAAe,EAAEkI;OACpB;MAED,MAAMlJ,IAAI,CAAC+B,KAAK,EAAE,CAACqH,YAAY,CAAC1K,gBAAgB,EAAEyK,UAAU,CAAC;IAAC;EAClE;EAEA;;;;;;;EAOM1F,UAAUA,CAACH,KAA0B,EAAEzD,MAAe;IAAA,IAAAwJ,OAAA;IAAA,OAAAtJ,iBAAA;MAExD,MAAMkB,OAAO,CAACW,GAAG,CAAC0B,KAAK,CAAC8D,GAAG,CAAE7C,IAAI,IAAI;QACjC,IAAI,CAACA,IAAI,CAACtC,EAAE,IAAIN,KAAK,CAAC2F,MAAM,CAAC/C,IAAI,CAACtC,EAAE,CAAC,CAAC,EAAE;UACpC;;QAGJ,OAAOoH,OAAI,CAACrE,SAAS,CAACsC,MAAM,CAAC/C,IAAI,CAACtC,EAAE,CAAC,EAAEsC,IAAI,CAACE,QAAQ,EAAEF,IAAI,CAACvD,eAAe,EAAEnB,MAAM,CAAC;MACvF,CAAC,CAAC,CAAC;IAAC;EACR;EAEA;;;;;;;;EAQMyJ,iBAAiBA,CAAC1G,IAAY,EAAEC,KAAa,EAAEhD,MAAe;IAAA,IAAA0J,OAAA;IAAA,OAAAxJ,iBAAA;MAChEF,MAAM,GAAGA,MAAM,IAAI5B,SAAS,CAAC6F,gBAAgB,EAAE;MAE/C,IAAI,CAAC/F,WAAW,CAACuH,QAAQ,EAAE,EAAE;QACzB;QACA,OAAOnH,eAAe,CAACuH,aAAa,CAAC9C,IAAI,EAAEC,KAAK,CAAC;;MAGrD,IAAI;QACA;QACA,MAAMiD,WAAW,GAAG,CAChB;UAAE0D,IAAI,EAAE5G,IAAI;UAAEC;QAAK,CAAE,CACxB;QAED,MAAM0G,OAAI,CAACE,qBAAqB,CAAC3D,WAAW,EAAE4D,SAAS,EAAEA,SAAS,EAAE7J,MAAM,CAAC;QAE3E;QACA,MAAMoB,OAAO,CAACW,GAAG,CAAC,CACdzD,eAAe,CAACuH,aAAa,CAAC9C,IAAI,EAAEC,KAAK,EAAEA,KAAK,CAAC,EACjD3E,SAAS,CAACkH,YAAY,CAACmE,OAAI,CAACpD,wBAAwB,CAACvD,IAAI,CAAC,CAAC,CAC9D,CAAC;OACL,CAAC,OAAOsB,KAAK,EAAE;QACZ;QACA,MAAM/F,eAAe,CAACuH,aAAa,CAAC9C,IAAI,EAAEC,KAAK,CAAC;;IACnD;EACL;EAEA;;;;;;;;;EASA8G,oBAAoBA,CAAC/G,IAAY,EAAEC,KAAyB,EAAErC,MAAe,EAAEX,MAAe;IAC1F,MAAMiG,WAAW,GAAG,CAChB;MACI0D,IAAI,EAAE5G,IAAI;MACVC,KAAK,EAAEA;KACV,CACJ;IAED,OAAO,IAAI,CAAC4G,qBAAqB,CAAC3D,WAAW,EAAE4D,SAAS,EAAElJ,MAAM,EAAEX,MAAM,CAAC;EAC7E;EAEA;;;;;;;;;EASM4J,qBAAqBA,CACvB3D,WAA0D,EAC1D8D,oBAA8B,EAC9BpJ,MAAe,EACfX,MAAe;IAAA,OAAAE,iBAAA;MAEf,MAAMC,IAAI,SAAS/B,SAAS,CAACgC,OAAO,CAACJ,MAAM,CAAC;MAE5CW,MAAM,GAAGA,MAAM,IAAIR,IAAI,CAAC6J,SAAS,EAAE;MAEnC,MAAMpJ,MAAM,GAA0C;QAClDG,MAAM,EAAEJ,MAAM;QACdsF,WAAW,EAAEA;OAChB;MACD,MAAM/C,OAAO,GAAsB;QAC/B+G,gBAAgB,EAAE;OACrB;MAED,IAAIF,oBAAoB,KAAKF,SAAS,EAAE;QACpCjJ,MAAM,CAACsJ,SAAS,GAAGH,oBAAoB,GAAG,CAAC,GAAG,CAAC;;MAGnD,MAAM5J,IAAI,CAACc,KAAK,CAAC,mCAAmC,EAAEL,MAAM,EAAEsC,OAAO,CAAC;IAAC;EAC3E;;SA9vBS7D,gBAAgB;AAET8K,MAAA,CAAA1H,uBAAuB,GAAG,EAAE;;mBAFnCpD,MAAgB;AAAA;;SAAhBA,MAAgB;EAAA+K,OAAA,EAAhB/K,MAAgB,CAAAgL,IAAA;EAAAC,UAAA,EADH;AAAM;AAkwBhC,OAAO,MAAM3F,QAAQ,GAAGlG,aAAa,CAACY,gBAAgB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}