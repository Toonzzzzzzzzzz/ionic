{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreGradesHelper } from '@features/grades/services/grades-helper';\nimport { CoreQuestion } from '@features/question/services/question';\nimport { CoreQuestionDelegate } from '@features/question/services/question-delegate';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { AddonModQuizAccessRuleDelegate } from './access-rules-delegate';\nimport { AddonModQuizOffline } from './quiz-offline';\nimport { AddonModQuizSyncProvider } from './quiz-sync';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModQuiz:';\n/**\n * Service that provides some features for quiz.\n */\nexport class AddonModQuizProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('AddonModQuizProvider');\n  }\n  /**\n   * Formats a grade to be displayed.\n   *\n   * @param grade Grade.\n   * @param decimals Decimals to use.\n   * @returns Grade to display.\n   */\n  formatGrade(grade, decimals) {\n    if (grade === undefined || grade === -1 || grade === null || isNaN(grade)) {\n      return Translate.instant('addon.mod_quiz.notyetgraded');\n    }\n    return CoreUtils.formatFloat(CoreTextUtils.roundToDecimals(grade, decimals));\n  }\n  /**\n   * Get attempt questions. Returns all of them or just the ones in certain pages.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param preflightData Preflight required data (like password).\n   * @param options Other options.\n   * @returns Promise resolved with the questions.\n   */\n  getAllQuestionsData(quiz, attempt, preflightData, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const questions = {};\n      const isSequential = _this.isNavigationSequential(quiz);\n      const pages = options.pages || _this.getPagesFromLayout(attempt.layout);\n      yield Promise.all(pages.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (page) {\n          if (isSequential && page < (attempt.currentpage || 0)) {\n            // Sequential quiz, cannot get pages before the current one.\n            return;\n          }\n          // Get the questions in the page.\n          const data = yield _this.getAttemptData(attempt.id, page, preflightData, options);\n          // Add the questions to the result object.\n          data.questions.forEach(question => {\n            questions[question.slot] = question;\n          });\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return questions;\n    })();\n  }\n  /**\n   * Get cache key for get attempt access information WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @param attemptId Attempt ID.\n   * @returns Cache key.\n   */\n  getAttemptAccessInformationCacheKey(quizId, attemptId) {\n    return this.getAttemptAccessInformationCommonCacheKey(quizId) + ':' + attemptId;\n  }\n  /**\n   * Get common cache key for get attempt access information WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @returns Cache key.\n   */\n  getAttemptAccessInformationCommonCacheKey(quizId) {\n    return ROOT_CACHE_KEY + 'attemptAccessInformation:' + quizId;\n  }\n  /**\n   * Get access information for an attempt.\n   *\n   * @param quizId Quiz ID.\n   * @param attemptId Attempt ID. 0 for user's last attempt.\n   * @param options Other options.\n   * @returns Promise resolved with the access information.\n   */\n  getAttemptAccessInformation(quizId, attemptId, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        quizid: quizId,\n        attemptid: attemptId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this2.getAttemptAccessInformationCacheKey(quizId, attemptId),\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_quiz_get_attempt_access_information', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for get attempt data WS calls.\n   *\n   * @param attemptId Attempt ID.\n   * @param page Page.\n   * @returns Cache key.\n   */\n  getAttemptDataCacheKey(attemptId, page) {\n    return this.getAttemptDataCommonCacheKey(attemptId) + ':' + page;\n  }\n  /**\n   * Get common cache key for get attempt data WS calls.\n   *\n   * @param attemptId Attempt ID.\n   * @returns Cache key.\n   */\n  getAttemptDataCommonCacheKey(attemptId) {\n    return ROOT_CACHE_KEY + 'attemptData:' + attemptId;\n  }\n  /**\n   * Get an attempt's data.\n   *\n   * @param attemptId Attempt ID.\n   * @param page Page number.\n   * @param preflightData Preflight required data (like password).\n   * @param options Other options.\n   * @returns Promise resolved with the attempt data.\n   */\n  getAttemptData(attemptId, page, preflightData, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        attemptid: attemptId,\n        page: page,\n        preflightdata: CoreUtils.objectToArrayOfObjects(preflightData, 'name', 'value', true)\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this3.getAttemptDataCacheKey(attemptId, page),\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const result = yield site.read('mod_quiz_get_attempt_data', params, preSets);\n      result.questions = CoreQuestion.parseQuestions(result.questions);\n      return result;\n    })();\n  }\n  /**\n   * Get an attempt's due date.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @returns Attempt's due date, 0 if no due date or invalid data.\n   */\n  getAttemptDueDate(quiz, attempt) {\n    var _quiz$graceperiod;\n    const deadlines = [];\n    if (quiz.timelimit && attempt.timestart) {\n      deadlines.push(attempt.timestart + quiz.timelimit);\n    }\n    if (quiz.timeclose) {\n      deadlines.push(quiz.timeclose);\n    }\n    if (!deadlines.length) {\n      return 0;\n    }\n    // Get min due date.\n    const dueDate = Math.min.apply(null, deadlines);\n    if (!dueDate) {\n      return 0;\n    }\n    switch (attempt.state) {\n      case AddonModQuizProvider.ATTEMPT_IN_PROGRESS:\n        return dueDate * 1000;\n      case AddonModQuizProvider.ATTEMPT_OVERDUE:\n        return (dueDate + ((_quiz$graceperiod = quiz.graceperiod) !== null && _quiz$graceperiod !== void 0 ? _quiz$graceperiod : 0)) * 1000;\n      default:\n        this.logger.warn('Unexpected state when getting due date: ' + attempt.state);\n        return 0;\n    }\n  }\n  /**\n   * Get an attempt's warning because of due date.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @returns Attempt's warning, undefined if no due date.\n   */\n  getAttemptDueDateWarning(quiz, attempt) {\n    const dueDate = this.getAttemptDueDate(quiz, attempt);\n    if (attempt.state === AddonModQuizProvider.ATTEMPT_OVERDUE) {\n      return Translate.instant('addon.mod_quiz.overduemustbesubmittedby', {\n        $a: CoreTimeUtils.userDate(dueDate)\n      });\n    } else if (dueDate) {\n      return Translate.instant('addon.mod_quiz.mustbesubmittedby', {\n        $a: CoreTimeUtils.userDate(dueDate)\n      });\n    }\n  }\n  /**\n   * Turn attempt's state into a readable state, including some extra data depending on the state.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @returns List of state sentences.\n   */\n  getAttemptReadableState(quiz, attempt) {\n    var _attempt$timefinish;\n    if (attempt.finishedOffline) {\n      return [Translate.instant('addon.mod_quiz.finishnotsynced')];\n    }\n    switch (attempt.state) {\n      case AddonModQuizProvider.ATTEMPT_IN_PROGRESS:\n        return [Translate.instant('addon.mod_quiz.stateinprogress')];\n      case AddonModQuizProvider.ATTEMPT_OVERDUE:\n        {\n          const sentences = [];\n          const dueDate = this.getAttemptDueDate(quiz, attempt);\n          sentences.push(Translate.instant('addon.mod_quiz.stateoverdue'));\n          if (dueDate) {\n            sentences.push(Translate.instant('addon.mod_quiz.stateoverduedetails', {\n              $a: CoreTimeUtils.userDate(dueDate)\n            }));\n          }\n          return sentences;\n        }\n      case AddonModQuizProvider.ATTEMPT_FINISHED:\n        return [Translate.instant('addon.mod_quiz.statefinished'), Translate.instant('addon.mod_quiz.statefinisheddetails', {\n          $a: CoreTimeUtils.userDate(((_attempt$timefinish = attempt.timefinish) !== null && _attempt$timefinish !== void 0 ? _attempt$timefinish : 0) * 1000)\n        })];\n      case AddonModQuizProvider.ATTEMPT_ABANDONED:\n        return [Translate.instant('addon.mod_quiz.stateabandoned')];\n      default:\n        return [];\n    }\n  }\n  /**\n   * Turn attempt's state into a readable state name, without any more data.\n   *\n   * @param state State.\n   * @returns Readable state name.\n   */\n  getAttemptReadableStateName(state) {\n    switch (state) {\n      case AddonModQuizProvider.ATTEMPT_IN_PROGRESS:\n        return Translate.instant('addon.mod_quiz.stateinprogress');\n      case AddonModQuizProvider.ATTEMPT_OVERDUE:\n        return Translate.instant('addon.mod_quiz.stateoverdue');\n      case AddonModQuizProvider.ATTEMPT_FINISHED:\n        return Translate.instant('addon.mod_quiz.statefinished');\n      case AddonModQuizProvider.ATTEMPT_ABANDONED:\n        return Translate.instant('addon.mod_quiz.stateabandoned');\n      default:\n        return '';\n    }\n  }\n  /**\n   * Get cache key for get attempt review WS calls.\n   *\n   * @param attemptId Attempt ID.\n   * @param page Page.\n   * @returns Cache key.\n   */\n  getAttemptReviewCacheKey(attemptId, page) {\n    return this.getAttemptReviewCommonCacheKey(attemptId) + ':' + page;\n  }\n  /**\n   * Get common cache key for get attempt review WS calls.\n   *\n   * @param attemptId Attempt ID.\n   * @returns Cache key.\n   */\n  getAttemptReviewCommonCacheKey(attemptId) {\n    return ROOT_CACHE_KEY + 'attemptReview:' + attemptId;\n  }\n  /**\n   * Get an attempt's review.\n   *\n   * @param attemptId Attempt ID.\n   * @param options Other options.\n   * @returns Promise resolved with the attempt review.\n   */\n  getAttemptReview(attemptId, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const page = options.page === undefined ? -1 : options.page;\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        attemptid: attemptId,\n        page: page\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this4.getAttemptReviewCacheKey(attemptId, page),\n        cacheErrors: ['noreview'],\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const result = yield site.read('mod_quiz_get_attempt_review', params, preSets);\n      result.questions = CoreQuestion.parseQuestions(result.questions);\n      return result;\n    })();\n  }\n  /**\n   * Get cache key for get attempt summary WS calls.\n   *\n   * @param attemptId Attempt ID.\n   * @returns Cache key.\n   */\n  getAttemptSummaryCacheKey(attemptId) {\n    return ROOT_CACHE_KEY + 'attemptSummary:' + attemptId;\n  }\n  /**\n   * Get an attempt's summary.\n   *\n   * @param attemptId Attempt ID.\n   * @param preflightData Preflight required data (like password).\n   * @param options Other options.\n   * @returns Promise resolved with the list of questions for the attempt summary.\n   */\n  getAttemptSummary(attemptId, preflightData, options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        attemptid: attemptId,\n        preflightdata: CoreUtils.objectToArrayOfObjects(preflightData, 'name', 'value', true)\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this5.getAttemptSummaryCacheKey(attemptId),\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_quiz_get_attempt_summary', params, preSets);\n      const questions = CoreQuestion.parseQuestions(response.questions);\n      if (options.loadLocal) {\n        return AddonModQuizOffline.loadQuestionsLocalStates(attemptId, questions, site.getId());\n      }\n      return questions;\n    })();\n  }\n  /**\n   * Get cache key for get combined review options WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getCombinedReviewOptionsCacheKey(quizId, userId) {\n    return this.getCombinedReviewOptionsCommonCacheKey(quizId) + ':' + userId;\n  }\n  /**\n   * Get common cache key for get combined review options WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @returns Cache key.\n   */\n  getCombinedReviewOptionsCommonCacheKey(quizId) {\n    return ROOT_CACHE_KEY + 'combinedReviewOptions:' + quizId;\n  }\n  /**\n   * Get a quiz combined review options.\n   *\n   * @param quizId Quiz ID.\n   * @param options Other options.\n   * @returns Promise resolved with the combined review options.\n   */\n  getCombinedReviewOptions(quizId, options = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const userId = options.userId || site.getUserId();\n      const params = {\n        quizid: quizId,\n        userid: userId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this6.getCombinedReviewOptionsCacheKey(quizId, userId),\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_quiz_get_combined_review_options', params, preSets);\n      // Convert the arrays to objects with name -> value.\n      return {\n        someoptions: CoreUtils.objectToKeyValueMap(response.someoptions, 'name', 'value'),\n        alloptions: CoreUtils.objectToKeyValueMap(response.alloptions, 'name', 'value'),\n        warnings: response.warnings\n      };\n    })();\n  }\n  /**\n   * Get cache key for get feedback for grade WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @param grade Grade.\n   * @returns Cache key.\n   */\n  getFeedbackForGradeCacheKey(quizId, grade) {\n    return this.getFeedbackForGradeCommonCacheKey(quizId) + ':' + grade;\n  }\n  /**\n   * Get common cache key for get feedback for grade WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @returns Cache key.\n   */\n  getFeedbackForGradeCommonCacheKey(quizId) {\n    return ROOT_CACHE_KEY + 'feedbackForGrade:' + quizId;\n  }\n  /**\n   * Get the feedback for a certain grade.\n   *\n   * @param quizId Quiz ID.\n   * @param grade Grade.\n   * @param options Other options.\n   * @returns Promise resolved with the feedback.\n   */\n  getFeedbackForGrade(quizId, grade, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        quizid: quizId,\n        grade: grade\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this7.getFeedbackForGradeCacheKey(quizId, grade),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_quiz_get_quiz_feedback_for_grade', params, preSets);\n    })();\n  }\n  /**\n   * Determine the correct number of decimal places required to format a grade.\n   * Based on Moodle's quiz_get_grade_format.\n   *\n   * @param quiz Quiz.\n   * @returns Number of decimals.\n   */\n  getGradeDecimals(quiz) {\n    if (quiz.questiondecimalpoints === undefined) {\n      quiz.questiondecimalpoints = -1;\n    }\n    if (quiz.questiondecimalpoints == -1) {\n      var _quiz$decimalpoints;\n      return (_quiz$decimalpoints = quiz.decimalpoints) !== null && _quiz$decimalpoints !== void 0 ? _quiz$decimalpoints : 1;\n    }\n    return quiz.questiondecimalpoints;\n  }\n  /**\n   * Gets a quiz grade and feedback from the gradebook.\n   *\n   * @param courseId Course ID.\n   * @param moduleId Quiz module ID.\n   * @param ignoreCache Whether it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved with an object containing the grade and the feedback.\n   */\n  getGradeFromGradebook(courseId, moduleId, ignoreCache, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const items = yield CoreGradesHelper.getGradeModuleItems(courseId, moduleId, userId, undefined, siteId, ignoreCache);\n      return items.shift();\n    })();\n  }\n  /**\n   * Given a list of attempts, returns the last finished attempt.\n   *\n   * @param attempts Attempts sorted. First attempt should be the first on the list.\n   * @returns Last finished attempt.\n   */\n  getLastFinishedAttemptFromList(attempts) {\n    if (!attempts) {\n      return;\n    }\n    for (let i = attempts.length - 1; i >= 0; i--) {\n      const attempt = attempts[i];\n      if (this.isAttemptFinished(attempt.state)) {\n        return attempt;\n      }\n    }\n  }\n  /**\n   * Given a list of questions, check if the quiz can be submitted.\n   * Will return an array with the messages to prevent the submit. Empty array if quiz can be submitted.\n   *\n   * @param questions Questions.\n   * @returns List of prevent submit messages. Empty array if quiz can be submitted.\n   */\n  getPreventSubmitMessages(questions) {\n    const messages = [];\n    questions.forEach(question => {\n      if (question.type != 'random' && !CoreQuestionDelegate.isQuestionSupported(question.type)) {\n        // The question isn't supported.\n        messages.push(Translate.instant('core.question.questionmessage', {\n          $a: question.slot,\n          $b: Translate.instant('core.question.errorquestionnotsupported', {\n            $a: question.type\n          })\n        }));\n      } else {\n        let message = CoreQuestionDelegate.getPreventSubmitMessage(question);\n        if (message) {\n          message = Translate.instant(message);\n          messages.push(Translate.instant('core.question.questionmessage', {\n            $a: question.slot,\n            $b: message\n          }));\n        }\n      }\n    });\n    return messages;\n  }\n  /**\n   * Get cache key for quiz data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getQuizDataCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'quiz:' + courseId;\n  }\n  /**\n   * Get a Quiz with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the Quiz is retrieved.\n   */\n  getQuizByField(courseId, key, value, options = {}) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this8.getQuizDataCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModQuizProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_quiz_get_quizzes_by_courses', params, preSets);\n      // Search the quiz.\n      const quiz = response.quizzes.find(quiz => quiz[key] == value);\n      if (!quiz) {\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n      }\n      return quiz;\n    })();\n  }\n  /**\n   * Get a quiz by module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the quiz is retrieved.\n   */\n  getQuiz(courseId, cmId, options = {}) {\n    return this.getQuizByField(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a quiz by quiz ID.\n   *\n   * @param courseId Course ID.\n   * @param id Quiz ID.\n   * @param options Other options.\n   * @returns Promise resolved when the quiz is retrieved.\n   */\n  getQuizById(courseId, id, options = {}) {\n    return this.getQuizByField(courseId, 'id', id, options);\n  }\n  /**\n   * Get cache key for get quiz access information WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @returns Cache key.\n   */\n  getQuizAccessInformationCacheKey(quizId) {\n    return ROOT_CACHE_KEY + 'quizAccessInformation:' + quizId;\n  }\n  /**\n   * Get access information for an attempt.\n   *\n   * @param quizId Quiz ID.\n   * @param options Other options.\n   * @returns Promise resolved with the access information.\n   */\n  getQuizAccessInformation(quizId, options = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        quizid: quizId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this9.getQuizAccessInformationCacheKey(quizId),\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_quiz_get_quiz_access_information', params, preSets);\n    })();\n  }\n  /**\n   * Get a readable Quiz grade method.\n   *\n   * @param method Grading method.\n   * @returns Readable grading method.\n   */\n  getQuizGradeMethod(method) {\n    if (method === undefined) {\n      return '';\n    }\n    if (typeof method == 'string') {\n      method = parseInt(method, 10);\n    }\n    switch (method) {\n      case AddonModQuizProvider.GRADEHIGHEST:\n        return Translate.instant('addon.mod_quiz.gradehighest');\n      case AddonModQuizProvider.GRADEAVERAGE:\n        return Translate.instant('addon.mod_quiz.gradeaverage');\n      case AddonModQuizProvider.ATTEMPTFIRST:\n        return Translate.instant('addon.mod_quiz.attemptfirst');\n      case AddonModQuizProvider.ATTEMPTLAST:\n        return Translate.instant('addon.mod_quiz.attemptlast');\n      default:\n        return '';\n    }\n  }\n  /**\n   * Get cache key for get quiz required qtypes WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @returns Cache key.\n   */\n  getQuizRequiredQtypesCacheKey(quizId) {\n    return ROOT_CACHE_KEY + 'quizRequiredQtypes:' + quizId;\n  }\n  /**\n   * Get the potential question types that would be required for a given quiz.\n   *\n   * @param quizId Quiz ID.\n   * @param options Other options.\n   * @returns Promise resolved with the access information.\n   */\n  getQuizRequiredQtypes(quizId, options = {}) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        quizid: quizId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this10.getQuizRequiredQtypesCacheKey(quizId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_quiz_get_quiz_required_qtypes', params, preSets);\n      return response.questiontypes;\n    })();\n  }\n  /**\n   * Given an attempt's layout, return the list of pages.\n   *\n   * @param layout Attempt's layout.\n   * @returns Pages.\n   * @description\n   * An attempt's layout is a string with the question numbers separated by commas. A 0 indicates a change of page.\n   * Example: 1,2,3,0,4,5,6,0\n   * In the example above, first page has questions 1, 2 and 3. Second page has questions 4, 5 and 6.\n   *\n   * This function returns a list of pages.\n   */\n  getPagesFromLayout(layout) {\n    if (!layout) {\n      return [];\n    }\n    const split = layout.split(',');\n    const pages = [];\n    let page = 0;\n    for (let i = 0; i < split.length; i++) {\n      if (split[i] == '0') {\n        pages.push(page);\n        page++;\n      }\n    }\n    return pages;\n  }\n  /**\n   * Given an attempt's layout and a list of questions identified by question slot,\n   * return the list of pages that have at least 1 of the questions.\n   *\n   * @param layout Attempt's layout.\n   * @param questions List of questions. It needs to be an object where the keys are question slot.\n   * @returns Pages.\n   * @description\n   * An attempt's layout is a string with the question numbers separated by commas. A 0 indicates a change of page.\n   * Example: 1,2,3,0,4,5,6,0\n   * In the example above, first page has questions 1, 2 and 3. Second page has questions 4, 5 and 6.\n   *\n   * This function returns a list of pages.\n   */\n  getPagesFromLayoutAndQuestions(layout, questions) {\n    const split = layout.split(',');\n    const pages = [];\n    let page = 0;\n    let pageAdded = false;\n    for (let i = 0; i < split.length; i++) {\n      const value = Number(split[i]);\n      if (value == 0) {\n        page++;\n        pageAdded = false;\n      } else if (!pageAdded && questions[value]) {\n        pages.push(page);\n        pageAdded = true;\n      }\n    }\n    return pages;\n  }\n  /**\n   * Given a list of question types, returns the types that aren't supported.\n   *\n   * @param questionTypes Question types to check.\n   * @returns Not supported question types.\n   */\n  getUnsupportedQuestions(questionTypes) {\n    const notSupported = [];\n    questionTypes.forEach(type => {\n      if (type != 'random' && !CoreQuestionDelegate.isQuestionSupported(type)) {\n        notSupported.push(type);\n      }\n    });\n    return notSupported;\n  }\n  /**\n   * Given a list of access rules names, returns the rules that aren't supported.\n   *\n   * @param rulesNames Rules to check.\n   * @returns Not supported rules names.\n   */\n  getUnsupportedRules(rulesNames) {\n    const notSupported = [];\n    rulesNames.forEach(name => {\n      if (!AddonModQuizAccessRuleDelegate.isAccessRuleSupported(name)) {\n        notSupported.push(name);\n      }\n    });\n    return notSupported;\n  }\n  /**\n   * Get cache key for get user attempts WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getUserAttemptsCacheKey(quizId, userId) {\n    return this.getUserAttemptsCommonCacheKey(quizId) + ':' + userId;\n  }\n  /**\n   * Get common cache key for get user attempts WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @returns Cache key.\n   */\n  getUserAttemptsCommonCacheKey(quizId) {\n    return ROOT_CACHE_KEY + 'userAttempts:' + quizId;\n  }\n  /**\n   * Get quiz attempts for a certain user.\n   *\n   * @param quizId Quiz ID.\n   * @param options Other options.\n   * @returns Promise resolved with the attempts.\n   */\n  getUserAttempts(quizId, options = {}) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const status = options.status || 'all';\n      const includePreviews = options.includePreviews === undefined ? true : options.includePreviews;\n      const site = yield CoreSites.getSite(options.siteId);\n      const userId = options.userId || site.getUserId();\n      const params = {\n        quizid: quizId,\n        userid: userId,\n        status: status,\n        includepreviews: !!includePreviews\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this11.getUserAttemptsCacheKey(quizId, userId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_quiz_get_user_attempts', params, preSets);\n      return response.attempts;\n    })();\n  }\n  /**\n   * Get cache key for get user best grade WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getUserBestGradeCacheKey(quizId, userId) {\n    return this.getUserBestGradeCommonCacheKey(quizId) + ':' + userId;\n  }\n  /**\n   * Get common cache key for get user best grade WS calls.\n   *\n   * @param quizId Quiz ID.\n   * @returns Cache key.\n   */\n  getUserBestGradeCommonCacheKey(quizId) {\n    return ROOT_CACHE_KEY + 'userBestGrade:' + quizId;\n  }\n  /**\n   * Get best grade in a quiz for a certain user.\n   *\n   * @param quizId Quiz ID.\n   * @param options Other options.\n   * @returns Promise resolved with the best grade data.\n   */\n  getUserBestGrade(quizId, options = {}) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const userId = options.userId || site.getUserId();\n      const params = {\n        quizid: quizId,\n        userid: userId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this12.getUserBestGradeCacheKey(quizId, userId),\n        component: AddonModQuizProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_quiz_get_user_best_grade', params, preSets);\n    })();\n  }\n  /**\n   * Invalidates all the data related to a certain quiz.\n   *\n   * @param quizId Quiz ID.\n   * @param courseId Course ID.\n   * @param attemptId Attempt ID to invalidate some WS calls.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllQuizData(quizId, courseId, attemptId, siteId, userId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const promises = [];\n      promises.push(_this13.invalidateAttemptAccessInformation(quizId, siteId));\n      promises.push(_this13.invalidateCombinedReviewOptionsForUser(quizId, siteId, userId));\n      promises.push(_this13.invalidateFeedback(quizId, siteId));\n      promises.push(_this13.invalidateQuizAccessInformation(quizId, siteId));\n      promises.push(_this13.invalidateQuizRequiredQtypes(quizId, siteId));\n      promises.push(_this13.invalidateUserAttemptsForUser(quizId, siteId, userId));\n      promises.push(_this13.invalidateUserBestGradeForUser(quizId, siteId, userId));\n      if (attemptId) {\n        promises.push(_this13.invalidateAttemptData(attemptId, siteId));\n        promises.push(_this13.invalidateAttemptReview(attemptId, siteId));\n        promises.push(_this13.invalidateAttemptSummary(attemptId, siteId));\n      }\n      if (courseId) {\n        promises.push(_this13.invalidateGradeFromGradebook(courseId, siteId, userId));\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidates attempt access information for all attempts in a quiz.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAttemptAccessInformation(quizId, siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this14.getAttemptAccessInformationCommonCacheKey(quizId));\n    })();\n  }\n  /**\n   * Invalidates attempt access information for an attempt.\n   *\n   * @param quizId Quiz ID.\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAttemptAccessInformationForAttempt(quizId, attemptId, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this15.getAttemptAccessInformationCacheKey(quizId, attemptId));\n    })();\n  }\n  /**\n   * Invalidates attempt data for all pages.\n   *\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAttemptData(attemptId, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this16.getAttemptDataCommonCacheKey(attemptId));\n    })();\n  }\n  /**\n   * Invalidates attempt data for a certain page.\n   *\n   * @param attemptId Attempt ID.\n   * @param page Page.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAttemptDataForPage(attemptId, page, siteId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this17.getAttemptDataCacheKey(attemptId, page));\n    })();\n  }\n  /**\n   * Invalidates attempt review for all pages.\n   *\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAttemptReview(attemptId, siteId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this18.getAttemptReviewCommonCacheKey(attemptId));\n    })();\n  }\n  /**\n   * Invalidates attempt review for a certain page.\n   *\n   * @param attemptId Attempt ID.\n   * @param page Page.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAttemptReviewForPage(attemptId, page, siteId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this19.getAttemptReviewCacheKey(attemptId, page));\n    })();\n  }\n  /**\n   * Invalidates attempt summary.\n   *\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAttemptSummary(attemptId, siteId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this20.getAttemptSummaryCacheKey(attemptId));\n    })();\n  }\n  /**\n   * Invalidates combined review options for all users.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCombinedReviewOptions(quizId, siteId) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this21.getCombinedReviewOptionsCommonCacheKey(quizId));\n    })();\n  }\n  /**\n   * Invalidates combined review options for a certain user.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCombinedReviewOptionsForUser(quizId, siteId, userId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.invalidateWsCacheForKey(_this22.getCombinedReviewOptionsCacheKey(quizId, userId || site.getUserId()));\n    })();\n  }\n  /**\n   * Invalidate the prefetched content except files.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Get required data to call the invalidate functions.\n      const quiz = yield _this23.getQuiz(courseId, moduleId, {\n        readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n        siteId\n      });\n      const attempts = yield _this23.getUserAttempts(quiz.id, {\n        cmId: moduleId,\n        siteId\n      });\n      // Now invalidate it.\n      const lastAttemptId = attempts.length ? attempts[attempts.length - 1].id : undefined;\n      yield _this23.invalidateAllQuizData(quiz.id, courseId, lastAttemptId, siteId);\n    })();\n  }\n  /**\n   * Invalidates feedback for all grades of a quiz.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateFeedback(quizId, siteId) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this24.getFeedbackForGradeCommonCacheKey(quizId));\n    })();\n  }\n  /**\n   * Invalidates feedback for a certain grade.\n   *\n   * @param quizId Quiz ID.\n   * @param grade Grade.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateFeedbackForGrade(quizId, grade, siteId) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this25.getFeedbackForGradeCacheKey(quizId, grade));\n    })();\n  }\n  /**\n   * Invalidates grade from gradebook for a certain user.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateGradeFromGradebook(courseId, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield CoreGradesHelper.invalidateGradeModuleItems(courseId, userId || site.getUserId(), undefined, siteId);\n    })();\n  }\n  /**\n   * Invalidates quiz access information for a quiz.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateQuizAccessInformation(quizId, siteId) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this26.getQuizAccessInformationCacheKey(quizId));\n    })();\n  }\n  /**\n   * Invalidates required qtypes for a quiz.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateQuizRequiredQtypes(quizId, siteId) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this27.getQuizRequiredQtypesCacheKey(quizId));\n    })();\n  }\n  /**\n   * Invalidates user attempts for all users.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserAttempts(quizId, siteId) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this28.getUserAttemptsCommonCacheKey(quizId));\n    })();\n  }\n  /**\n   * Invalidates user attempts for a certain user.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserAttemptsForUser(quizId, siteId, userId) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this29.getUserAttemptsCacheKey(quizId, userId || site.getUserId()));\n    })();\n  }\n  /**\n   * Invalidates user best grade for all users.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserBestGrade(quizId, siteId) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this30.getUserBestGradeCommonCacheKey(quizId));\n    })();\n  }\n  /**\n   * Invalidates user best grade for a certain user.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserBestGradeForUser(quizId, siteId, userId) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this31.getUserBestGradeCacheKey(quizId, userId || site.getUserId()));\n    })();\n  }\n  /**\n   * Invalidates quiz data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateQuizData(courseId, siteId) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this32.getQuizDataCacheKey(courseId));\n    })();\n  }\n  /**\n   * Check if an attempt is finished based on its state.\n   *\n   * @param state Attempt's state.\n   * @returns Whether it's finished.\n   */\n  isAttemptFinished(state) {\n    return state == AddonModQuizProvider.ATTEMPT_FINISHED || state == AddonModQuizProvider.ATTEMPT_ABANDONED;\n  }\n  /**\n   * Check if an attempt is finished in offline but not synced.\n   *\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if finished in offline but not synced, false otherwise.\n   */\n  isAttemptFinishedOffline(attemptId, siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const attempt = yield AddonModQuizOffline.getAttemptById(attemptId, siteId);\n        return !!attempt.finished;\n      } catch (_unused) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Check if an attempt is nearly over. We consider an attempt nearly over or over if:\n   * - Is not in progress\n   * OR\n   * - It finished before autosaveperiod passes.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @returns Whether it's nearly over or over.\n   */\n  isAttemptTimeNearlyOver(quiz, attempt) {\n    if (attempt.state != AddonModQuizProvider.ATTEMPT_IN_PROGRESS) {\n      // Attempt not in progress, return true.\n      return true;\n    }\n    const dueDate = this.getAttemptDueDate(quiz, attempt);\n    const autoSavePeriod = quiz.autosaveperiod || 0;\n    if (dueDate > 0 && Date.now() + autoSavePeriod >= dueDate) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Check if last attempt is offline and unfinished.\n   *\n   * @param quiz Quiz data.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, user current site's user.\n   * @returns Promise resolved with boolean: true if last offline attempt is unfinished, false otherwise.\n   */\n  isLastAttemptOfflineUnfinished(quiz, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const attempts = yield AddonModQuizOffline.getQuizAttempts(quiz.id, siteId, userId);\n        const last = attempts.pop();\n        return !!last && !last.finished;\n      } catch (_unused2) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Check if a quiz navigation is sequential.\n   *\n   * @param quiz Quiz.\n   * @returns Whether navigation is sequential.\n   */\n  isNavigationSequential(quiz) {\n    return quiz.navmethod == 'sequential';\n  }\n  /**\n   * Check if a question is blocked.\n   *\n   * @param question Question.\n   * @returns Whether it's blocked.\n   */\n  isQuestionBlocked(question) {\n    const element = CoreDomUtils.convertToElement(question.html);\n    return !!element.querySelector('.mod_quiz-blocked_question_warning');\n  }\n  /**\n   * Check if a quiz is enabled to be used in offline.\n   *\n   * @param quiz Quiz.\n   * @returns Whether offline is enabled.\n   */\n  isQuizOffline(quiz) {\n    var _CoreSites$getCurrent;\n    // Don't allow downloading the quiz if offline is disabled to prevent wasting a lot of data when opening it.\n    return !!quiz.allowofflineattempts && !this.isNavigationSequential(quiz) && !((_CoreSites$getCurrent = CoreSites.getCurrentSite()) !== null && _CoreSites$getCurrent !== void 0 && _CoreSites$getCurrent.isOfflineDisabled());\n  }\n  /**\n   * Report an attempt as being viewed. It did not store logs offline because order of the log is important.\n   *\n   * @param attemptId Attempt ID.\n   * @param page Page number.\n   * @param preflightData Preflight required data (like password).\n   * @param offline Whether attempt is offline.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logViewAttempt(attemptId, page = 0, preflightData = {}, offline, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        attemptid: attemptId,\n        page: page,\n        preflightdata: CoreUtils.objectToArrayOfObjects(preflightData, 'name', 'value')\n      };\n      const promises = [];\n      promises.push(site.write('mod_quiz_view_attempt', params));\n      if (offline) {\n        promises.push(AddonModQuizOffline.setAttemptCurrentPage(attemptId, page, site.getId()));\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Report an attempt's review as being viewed.\n   *\n   * @param attemptId Attempt ID.\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logViewAttemptReview(attemptId, quizId, siteId) {\n    const params = {\n      attemptid: attemptId\n    };\n    return CoreCourseLogHelper.log('mod_quiz_view_attempt_review', params, AddonModQuizProvider.COMPONENT, quizId, siteId);\n  }\n  /**\n   * Report an attempt's summary as being viewed.\n   *\n   * @param attemptId Attempt ID.\n   * @param preflightData Preflight required data (like password).\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logViewAttemptSummary(attemptId, preflightData, quizId, siteId) {\n    const params = {\n      attemptid: attemptId,\n      preflightdata: CoreUtils.objectToArrayOfObjects(preflightData, 'name', 'value')\n    };\n    return CoreCourseLogHelper.log('mod_quiz_view_attempt_summary', params, AddonModQuizProvider.COMPONENT, quizId, siteId);\n  }\n  /**\n   * Report a quiz as being viewed.\n   *\n   * @param id Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logViewQuiz(id, siteId) {\n    const params = {\n      quizid: id\n    };\n    return CoreCourseLogHelper.log('mod_quiz_view_quiz', params, AddonModQuizProvider.COMPONENT, id, siteId);\n  }\n  /**\n   * Process an attempt, saving its data.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param data Data to save.\n   * @param preflightData Preflight required data (like password).\n   * @param finish Whether to finish the quiz.\n   * @param timeUp Whether the quiz time is up, false otherwise.\n   * @param offline Whether the attempt is offline.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  processAttempt(quiz, attempt, data, preflightData, finish, timeUp, offline, siteId) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      if (offline) {\n        return _this33.processAttemptOffline(quiz, attempt, data, preflightData, finish, siteId);\n      }\n      yield _this33.processAttemptOnline(attempt.id, data, preflightData, finish, timeUp, siteId);\n    })();\n  }\n  /**\n   * Process an online attempt, saving its data.\n   *\n   * @param attemptId Attempt ID.\n   * @param data Data to save.\n   * @param preflightData Preflight required data (like password).\n   * @param finish Whether to finish the quiz.\n   * @param timeUp Whether the quiz time is up, false otherwise.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  processAttemptOnline(attemptId, data, preflightData, finish, timeUp, siteId) {\n    return _asyncToGenerator(function* () {\n      var _response$warnings;\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        attemptid: attemptId,\n        data: CoreUtils.objectToArrayOfObjects(data, 'name', 'value'),\n        finishattempt: !!finish,\n        timeup: !!timeUp,\n        preflightdata: CoreUtils.objectToArrayOfObjects(preflightData, 'name', 'value')\n      };\n      const response = yield site.write('mod_quiz_process_attempt', params);\n      if ((_response$warnings = response.warnings) !== null && _response$warnings !== void 0 && _response$warnings.length) {\n        // Reject with the first warning.\n        throw new CoreWSError(response.warnings[0]);\n      }\n      return response.state;\n    })();\n  }\n  /**\n   * Process an offline attempt, saving its data.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param data Data to save.\n   * @param preflightData Preflight required data (like password).\n   * @param finish Whether to finish the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  processAttemptOffline(quiz, attempt, data, preflightData, finish, siteId) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      // Get attempt summary to have the list of questions.\n      const questionsArray = yield _this34.getAttemptSummary(attempt.id, preflightData, {\n        cmId: quiz.coursemodule,\n        loadLocal: true,\n        readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n        siteId\n      });\n      // Convert the question array to an object.\n      const questions = CoreUtils.arrayToObject(questionsArray, 'slot');\n      return AddonModQuizOffline.processAttempt(quiz, attempt, questions, data, finish, siteId);\n    })();\n  }\n  /**\n   * Check if it's a graded quiz. Based on Moodle's quiz_has_grades.\n   *\n   * @param quiz Quiz.\n   * @returns Whether quiz is graded.\n   */\n  quizHasGrades(quiz) {\n    var _quiz$grade, _quiz$sumgrades;\n    return ((_quiz$grade = quiz.grade) !== null && _quiz$grade !== void 0 ? _quiz$grade : 0) >= 0.000005 && ((_quiz$sumgrades = quiz.sumgrades) !== null && _quiz$sumgrades !== void 0 ? _quiz$sumgrades : 0) >= 0.000005;\n  }\n  /**\n   * Convert the raw grade into a grade out of the maximum grade for this quiz.\n   * Based on Moodle's quiz_rescale_grade.\n   *\n   * @param rawGrade The unadjusted grade, for example attempt.sumgrades.\n   * @param quiz Quiz.\n   * @param format True to format the results for display, 'question' to format a question grade\n   *               (different number of decimal places), false to not format it.\n   * @returns Grade to display.\n   */\n  rescaleGrade(rawGrade, quiz, format = true) {\n    let grade;\n    const rawGradeNum = typeof rawGrade === 'string' ? parseFloat(rawGrade) : rawGrade;\n    if (rawGradeNum !== undefined && rawGradeNum !== null && !isNaN(rawGradeNum)) {\n      if (quiz.sumgrades && quiz.sumgrades >= 0.000005) {\n        var _quiz$grade2;\n        grade = rawGradeNum * ((_quiz$grade2 = quiz.grade) !== null && _quiz$grade2 !== void 0 ? _quiz$grade2 : 0) / quiz.sumgrades;\n      } else {\n        grade = 0;\n      }\n    }\n    if (grade === null || grade === undefined) {\n      return;\n    }\n    if (format === 'question') {\n      return this.formatGrade(grade, this.getGradeDecimals(quiz));\n    } else if (format) {\n      var _quiz$decimalpoints2;\n      return this.formatGrade(grade, (_quiz$decimalpoints2 = quiz.decimalpoints) !== null && _quiz$decimalpoints2 !== void 0 ? _quiz$decimalpoints2 : 1);\n    }\n    return String(grade);\n  }\n  /**\n   * Save an attempt data.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param data Data to save.\n   * @param preflightData Preflight required data (like password).\n   * @param offline Whether attempt is offline.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  saveAttempt(quiz, attempt, data, preflightData, offline, siteId) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (offline) {\n          return yield _this35.processAttemptOffline(quiz, attempt, data, preflightData, false, siteId);\n        }\n        yield _this35.saveAttemptOnline(attempt.id, data, preflightData, siteId);\n      } catch (error) {\n        _this35.logger.error(error);\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Save an attempt data.\n   *\n   * @param attemptId Attempt ID.\n   * @param data Data to save.\n   * @param preflightData Preflight required data (like password).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  saveAttemptOnline(attemptId, data, preflightData, siteId) {\n    return _asyncToGenerator(function* () {\n      var _response$warnings2;\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        attemptid: attemptId,\n        data: CoreUtils.objectToArrayOfObjects(data, 'name', 'value'),\n        preflightdata: CoreUtils.objectToArrayOfObjects(preflightData, 'name', 'value')\n      };\n      const response = yield site.write('mod_quiz_save_attempt', params);\n      if ((_response$warnings2 = response.warnings) !== null && _response$warnings2 !== void 0 && _response$warnings2.length) {\n        // Reject with the first warning.\n        throw new CoreWSError(response.warnings[0]);\n      } else if (!response.status) {\n        // It shouldn't happen that status is false and no warnings were returned.\n        throw new CoreError('Cannot save data.');\n      }\n    })();\n  }\n  /**\n   * Check if time left should be shown.\n   *\n   * @param rules List of active rules names.\n   * @param attempt Attempt.\n   * @param endTime The attempt end time (in seconds).\n   * @returns Whether time left should be displayed.\n   */\n  shouldShowTimeLeft(rules, attempt, endTime) {\n    const timeNow = CoreTimeUtils.timestamp();\n    if (attempt.state != AddonModQuizProvider.ATTEMPT_IN_PROGRESS) {\n      return false;\n    }\n    return AddonModQuizAccessRuleDelegate.shouldShowTimeLeft(rules, attempt, endTime, timeNow);\n  }\n  /**\n   * Start an attempt.\n   *\n   * @param quizId Quiz ID.\n   * @param preflightData Preflight required data (like password).\n   * @param forceNew Whether to force a new attempt or not.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the attempt data.\n   */\n  startAttempt(quizId, preflightData, forceNew, siteId) {\n    return _asyncToGenerator(function* () {\n      var _response$warnings3;\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        quizid: quizId,\n        preflightdata: CoreUtils.objectToArrayOfObjects(preflightData, 'name', 'value'),\n        forcenew: !!forceNew\n      };\n      const response = yield site.write('mod_quiz_start_attempt', params);\n      if ((_response$warnings3 = response.warnings) !== null && _response$warnings3 !== void 0 && _response$warnings3.length) {\n        // Reject with the first warning.\n        throw new CoreWSError(response.warnings[0]);\n      }\n      return response.attempt;\n    })();\n  }\n}\n_class = AddonModQuizProvider;\n_class.COMPONENT = 'mmaModQuiz';\n_class.ATTEMPT_FINISHED_EVENT = 'addon_mod_quiz_attempt_finished';\n// Grade methods.\n_class.GRADEHIGHEST = 1;\n_class.GRADEAVERAGE = 2;\n_class.ATTEMPTFIRST = 3;\n_class.ATTEMPTLAST = 4;\n// Question options.\n_class.QUESTION_OPTIONS_MAX_ONLY = 1;\n_class.QUESTION_OPTIONS_MARK_AND_MAX = 2;\n// Attempt state.\n_class.ATTEMPT_IN_PROGRESS = 'inprogress';\n_class.ATTEMPT_OVERDUE = 'overdue';\n_class.ATTEMPT_FINISHED = 'finished';\n_class.ATTEMPT_ABANDONED = 'abandoned';\n// Show the countdown timer if there is less than this amount of time left before the the quiz close date.\n_class.QUIZ_SHOW_TIME_BEFORE_DEADLINE = 3600;\n_class.ɵfac = function AddonModQuizProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModQuiz = makeSingleton(AddonModQuizProvider);","map":{"version":3,"names":["CoreError","CoreWSError","CoreSite","CoreCourseLogHelper","CoreGradesHelper","CoreQuestion","CoreQuestionDelegate","CoreSites","CoreSitesReadingStrategy","CoreDomUtils","CoreTextUtils","CoreTimeUtils","CoreUtils","makeSingleton","Translate","CoreLogger","AddonModQuizAccessRuleDelegate","AddonModQuizOffline","AddonModQuizSyncProvider","ROOT_CACHE_KEY","AddonModQuizProvider","constructor","logger","getInstance","formatGrade","grade","decimals","undefined","isNaN","instant","formatFloat","roundToDecimals","getAllQuestionsData","quiz","attempt","preflightData","options","_this","_asyncToGenerator","questions","isSequential","isNavigationSequential","pages","getPagesFromLayout","layout","Promise","all","map","_ref","page","currentpage","data","getAttemptData","id","forEach","question","slot","_x","apply","arguments","getAttemptAccessInformationCacheKey","quizId","attemptId","getAttemptAccessInformationCommonCacheKey","getAttemptAccessInformation","_this2","site","getSite","siteId","params","quizid","attemptid","preSets","_objectSpread","cacheKey","component","COMPONENT","componentId","cmId","getReadingStrategyPreSets","readingStrategy","read","getAttemptDataCacheKey","getAttemptDataCommonCacheKey","_this3","preflightdata","objectToArrayOfObjects","result","parseQuestions","getAttemptDueDate","_quiz$graceperiod","deadlines","timelimit","timestart","push","timeclose","length","dueDate","Math","min","state","ATTEMPT_IN_PROGRESS","ATTEMPT_OVERDUE","graceperiod","warn","getAttemptDueDateWarning","$a","userDate","getAttemptReadableState","_attempt$timefinish","finishedOffline","sentences","ATTEMPT_FINISHED","timefinish","ATTEMPT_ABANDONED","getAttemptReadableStateName","getAttemptReviewCacheKey","getAttemptReviewCommonCacheKey","getAttemptReview","_this4","cacheErrors","getAttemptSummaryCacheKey","getAttemptSummary","_this5","response","loadLocal","loadQuestionsLocalStates","getId","getCombinedReviewOptionsCacheKey","userId","getCombinedReviewOptionsCommonCacheKey","getCombinedReviewOptions","_this6","getUserId","userid","someoptions","objectToKeyValueMap","alloptions","warnings","getFeedbackForGradeCacheKey","getFeedbackForGradeCommonCacheKey","getFeedbackForGrade","_this7","updateFrequency","FREQUENCY_RARELY","getGradeDecimals","questiondecimalpoints","_quiz$decimalpoints","decimalpoints","getGradeFromGradebook","courseId","moduleId","ignoreCache","items","getGradeModuleItems","shift","getLastFinishedAttemptFromList","attempts","i","isAttemptFinished","getPreventSubmitMessages","messages","type","isQuestionSupported","$b","message","getPreventSubmitMessage","getQuizDataCacheKey","getQuizByField","key","value","_this8","courseids","quizzes","find","getQuiz","getQuizById","getQuizAccessInformationCacheKey","getQuizAccessInformation","_this9","getQuizGradeMethod","method","parseInt","GRADEHIGHEST","GRADEAVERAGE","ATTEMPTFIRST","ATTEMPTLAST","getQuizRequiredQtypesCacheKey","getQuizRequiredQtypes","_this10","FREQUENCY_SOMETIMES","questiontypes","split","getPagesFromLayoutAndQuestions","pageAdded","Number","getUnsupportedQuestions","questionTypes","notSupported","getUnsupportedRules","rulesNames","name","isAccessRuleSupported","getUserAttemptsCacheKey","getUserAttemptsCommonCacheKey","getUserAttempts","_this11","status","includePreviews","includepreviews","getUserBestGradeCacheKey","getUserBestGradeCommonCacheKey","getUserBestGrade","_this12","invalidateAllQuizData","_this13","getCurrentSiteId","promises","invalidateAttemptAccessInformation","invalidateCombinedReviewOptionsForUser","invalidateFeedback","invalidateQuizAccessInformation","invalidateQuizRequiredQtypes","invalidateUserAttemptsForUser","invalidateUserBestGradeForUser","invalidateAttemptData","invalidateAttemptReview","invalidateAttemptSummary","invalidateGradeFromGradebook","_this14","invalidateWsCacheForKeyStartingWith","invalidateAttemptAccessInformationForAttempt","_this15","invalidateWsCacheForKey","_this16","invalidateAttemptDataForPage","_this17","_this18","invalidateAttemptReviewForPage","_this19","_this20","invalidateCombinedReviewOptions","_this21","_this22","invalidateContent","_this23","lastAttemptId","_this24","invalidateFeedbackForGrade","_this25","invalidateGradeModuleItems","_this26","_this27","invalidateUserAttempts","_this28","_this29","invalidateUserBestGrade","_this30","_this31","invalidateQuizData","_this32","isAttemptFinishedOffline","getAttemptById","finished","_unused","isAttemptTimeNearlyOver","autoSavePeriod","autosaveperiod","Date","now","isLastAttemptOfflineUnfinished","getQuizAttempts","last","pop","_unused2","navmethod","isQuestionBlocked","element","convertToElement","html","querySelector","isQuizOffline","_CoreSites$getCurrent","allowofflineattempts","getCurrentSite","isOfflineDisabled","logViewAttempt","offline","write","setAttemptCurrentPage","logViewAttemptReview","log","logViewAttemptSummary","logViewQuiz","processAttempt","finish","timeUp","_this33","processAttemptOffline","processAttemptOnline","_response$warnings","finishattempt","timeup","_this34","questionsArray","coursemodule","arrayToObject","quizHasGrades","_quiz$grade","_quiz$sumgrades","sumgrades","rescaleGrade","rawGrade","format","rawGradeNum","parseFloat","_quiz$grade2","_quiz$decimalpoints2","String","saveAttempt","_this35","saveAttemptOnline","error","_response$warnings2","shouldShowTimeLeft","rules","endTime","timeNow","timestamp","startAttempt","forceNew","_response$warnings3","forcenew","_class","ATTEMPT_FINISHED_EVENT","QUESTION_OPTIONS_MAX_ONLY","QUESTION_OPTIONS_MARK_AND_MAX","QUIZ_SHOW_TIME_BEFORE_DEADLINE","factory","ɵfac","providedIn","AddonModQuiz"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/quiz/services/quiz.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { SafeNumber } from '@/core/utils/types';\nimport { Injectable } from '@angular/core';\n\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreGradesFormattedItem, CoreGradesHelper } from '@features/grades/services/grades-helper';\nimport {\n    CoreQuestion,\n    CoreQuestionQuestionParsed,\n    CoreQuestionQuestionWSData,\n    CoreQuestionsAnswers,\n} from '@features/question/services/question';\nimport { CoreQuestionDelegate } from '@features/question/services/question-delegate';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreStatusWithWarningsWSResponse, CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { AddonModQuizAccessRuleDelegate } from './access-rules-delegate';\nimport { AddonModQuizAttempt } from './quiz-helper';\nimport { AddonModQuizOffline, AddonModQuizQuestionsWithAnswers } from './quiz-offline';\nimport { AddonModQuizAutoSyncData, AddonModQuizSyncProvider } from './quiz-sync';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaModQuiz:';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonModQuizProvider.ATTEMPT_FINISHED_EVENT]: AddonModQuizAttemptFinishedData;\n        [AddonModQuizSyncProvider.AUTO_SYNCED]: AddonModQuizAutoSyncData;\n    }\n\n}\n\n/**\n * Service that provides some features for quiz.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModQuizProvider {\n\n    static readonly COMPONENT = 'mmaModQuiz';\n    static readonly ATTEMPT_FINISHED_EVENT = 'addon_mod_quiz_attempt_finished';\n\n    // Grade methods.\n    static readonly GRADEHIGHEST = 1;\n    static readonly GRADEAVERAGE = 2;\n    static readonly ATTEMPTFIRST = 3;\n    static readonly ATTEMPTLAST  = 4;\n\n    // Question options.\n    static readonly QUESTION_OPTIONS_MAX_ONLY = 1;\n    static readonly QUESTION_OPTIONS_MARK_AND_MAX = 2;\n\n    // Attempt state.\n    static readonly ATTEMPT_IN_PROGRESS = 'inprogress';\n    static readonly ATTEMPT_OVERDUE     = 'overdue';\n    static readonly ATTEMPT_FINISHED    = 'finished';\n    static readonly ATTEMPT_ABANDONED   = 'abandoned';\n\n    // Show the countdown timer if there is less than this amount of time left before the the quiz close date.\n    static readonly QUIZ_SHOW_TIME_BEFORE_DEADLINE = 3600;\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('AddonModQuizProvider');\n    }\n\n    /**\n     * Formats a grade to be displayed.\n     *\n     * @param grade Grade.\n     * @param decimals Decimals to use.\n     * @returns Grade to display.\n     */\n    formatGrade(grade?: number | null, decimals?: number): string {\n        if (grade === undefined || grade === -1 || grade === null || isNaN(grade)) {\n            return Translate.instant('addon.mod_quiz.notyetgraded');\n        }\n\n        return CoreUtils.formatFloat(CoreTextUtils.roundToDecimals(grade, decimals));\n    }\n\n    /**\n     * Get attempt questions. Returns all of them or just the ones in certain pages.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param preflightData Preflight required data (like password).\n     * @param options Other options.\n     * @returns Promise resolved with the questions.\n     */\n    async getAllQuestionsData(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData,\n        preflightData: Record<string, string>,\n        options: AddonModQuizAllQuestionsDataOptions = {},\n    ): Promise<Record<number, CoreQuestionQuestionParsed>> {\n\n        const questions: Record<number, CoreQuestionQuestionParsed> = {};\n        const isSequential = this.isNavigationSequential(quiz);\n        const pages = options.pages || this.getPagesFromLayout(attempt.layout);\n\n        await Promise.all(pages.map(async (page) => {\n            if (isSequential && page < (attempt.currentpage || 0)) {\n                // Sequential quiz, cannot get pages before the current one.\n                return;\n            }\n\n            // Get the questions in the page.\n            const data = await this.getAttemptData(attempt.id, page, preflightData, options);\n\n            // Add the questions to the result object.\n            data.questions.forEach((question) => {\n                questions[question.slot] = question;\n            });\n        }));\n\n        return questions;\n    }\n\n    /**\n     * Get cache key for get attempt access information WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @param attemptId Attempt ID.\n     * @returns Cache key.\n     */\n    protected getAttemptAccessInformationCacheKey(quizId: number, attemptId: number): string {\n        return this.getAttemptAccessInformationCommonCacheKey(quizId) + ':' + attemptId;\n    }\n\n    /**\n     * Get common cache key for get attempt access information WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @returns Cache key.\n     */\n    protected getAttemptAccessInformationCommonCacheKey(quizId: number): string {\n        return ROOT_CACHE_KEY + 'attemptAccessInformation:' + quizId;\n    }\n\n    /**\n     * Get access information for an attempt.\n     *\n     * @param quizId Quiz ID.\n     * @param attemptId Attempt ID. 0 for user's last attempt.\n     * @param options Other options.\n     * @returns Promise resolved with the access information.\n     */\n    async getAttemptAccessInformation(\n        quizId: number,\n        attemptId: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModQuizGetAttemptAccessInformationWSResponse> {\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModQuizGetAttemptAccessInformationWSParams = {\n            quizid: quizId,\n            attemptid: attemptId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAttemptAccessInformationCacheKey(quizId, attemptId),\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_quiz_get_attempt_access_information', params, preSets);\n    }\n\n    /**\n     * Get cache key for get attempt data WS calls.\n     *\n     * @param attemptId Attempt ID.\n     * @param page Page.\n     * @returns Cache key.\n     */\n    protected getAttemptDataCacheKey(attemptId: number, page: number): string {\n        return this.getAttemptDataCommonCacheKey(attemptId) + ':' + page;\n    }\n\n    /**\n     * Get common cache key for get attempt data WS calls.\n     *\n     * @param attemptId Attempt ID.\n     * @returns Cache key.\n     */\n    protected getAttemptDataCommonCacheKey(attemptId: number): string {\n        return ROOT_CACHE_KEY + 'attemptData:' + attemptId;\n    }\n\n    /**\n     * Get an attempt's data.\n     *\n     * @param attemptId Attempt ID.\n     * @param page Page number.\n     * @param preflightData Preflight required data (like password).\n     * @param options Other options.\n     * @returns Promise resolved with the attempt data.\n     */\n    async getAttemptData(\n        attemptId: number,\n        page: number,\n        preflightData: Record<string, string>,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModQuizGetAttemptDataResponse> {\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModQuizGetAttemptDataWSParams = {\n            attemptid: attemptId,\n            page: page,\n            preflightdata: CoreUtils.objectToArrayOfObjects<AddonModQuizPreflightDataWSParam>(\n                preflightData,\n                'name',\n                'value',\n                true,\n            ),\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAttemptDataCacheKey(attemptId, page),\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const result = await site.read<AddonModQuizGetAttemptDataWSResponse>('mod_quiz_get_attempt_data', params, preSets);\n\n        result.questions = CoreQuestion.parseQuestions(result.questions);\n\n        return result;\n    }\n\n    /**\n     * Get an attempt's due date.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @returns Attempt's due date, 0 if no due date or invalid data.\n     */\n    getAttemptDueDate(quiz: AddonModQuizQuizWSData, attempt: AddonModQuizAttemptWSData): number {\n        const deadlines: number[] = [];\n\n        if (quiz.timelimit && attempt.timestart) {\n            deadlines.push(attempt.timestart + quiz.timelimit);\n        }\n        if (quiz.timeclose) {\n            deadlines.push(quiz.timeclose);\n        }\n\n        if (!deadlines.length) {\n            return 0;\n        }\n\n        // Get min due date.\n        const dueDate: number = Math.min.apply(null, deadlines);\n        if (!dueDate) {\n            return 0;\n        }\n\n        switch (attempt.state) {\n            case AddonModQuizProvider.ATTEMPT_IN_PROGRESS:\n                return dueDate * 1000;\n\n            case AddonModQuizProvider.ATTEMPT_OVERDUE:\n                return (dueDate + (quiz.graceperiod ?? 0)) * 1000;\n\n            default:\n                this.logger.warn('Unexpected state when getting due date: ' + attempt.state);\n\n                return 0;\n        }\n    }\n\n    /**\n     * Get an attempt's warning because of due date.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @returns Attempt's warning, undefined if no due date.\n     */\n    getAttemptDueDateWarning(quiz: AddonModQuizQuizWSData, attempt: AddonModQuizAttemptWSData): string | undefined {\n        const dueDate = this.getAttemptDueDate(quiz, attempt);\n\n        if (attempt.state === AddonModQuizProvider.ATTEMPT_OVERDUE) {\n            return Translate.instant(\n                'addon.mod_quiz.overduemustbesubmittedby',\n                { $a: CoreTimeUtils.userDate(dueDate) },\n            );\n        } else if (dueDate) {\n            return Translate.instant('addon.mod_quiz.mustbesubmittedby', { $a: CoreTimeUtils.userDate(dueDate) });\n        }\n    }\n\n    /**\n     * Turn attempt's state into a readable state, including some extra data depending on the state.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @returns List of state sentences.\n     */\n    getAttemptReadableState(quiz: AddonModQuizQuizWSData, attempt: AddonModQuizAttempt): string[] {\n        if (attempt.finishedOffline) {\n            return [Translate.instant('addon.mod_quiz.finishnotsynced')];\n        }\n\n        switch (attempt.state) {\n            case AddonModQuizProvider.ATTEMPT_IN_PROGRESS:\n                return [Translate.instant('addon.mod_quiz.stateinprogress')];\n\n            case AddonModQuizProvider.ATTEMPT_OVERDUE: {\n                const sentences: string[] = [];\n                const dueDate = this.getAttemptDueDate(quiz, attempt);\n\n                sentences.push(Translate.instant('addon.mod_quiz.stateoverdue'));\n\n                if (dueDate) {\n                    sentences.push(Translate.instant(\n                        'addon.mod_quiz.stateoverduedetails',\n                        { $a: CoreTimeUtils.userDate(dueDate) },\n                    ));\n                }\n\n                return sentences;\n            }\n\n            case AddonModQuizProvider.ATTEMPT_FINISHED:\n                return [\n                    Translate.instant('addon.mod_quiz.statefinished'),\n                    Translate.instant(\n                        'addon.mod_quiz.statefinisheddetails',\n                        { $a: CoreTimeUtils.userDate((attempt.timefinish ?? 0) * 1000) },\n                    ),\n                ];\n\n            case AddonModQuizProvider.ATTEMPT_ABANDONED:\n                return [Translate.instant('addon.mod_quiz.stateabandoned')];\n\n            default:\n                return [];\n        }\n    }\n\n    /**\n     * Turn attempt's state into a readable state name, without any more data.\n     *\n     * @param state State.\n     * @returns Readable state name.\n     */\n    getAttemptReadableStateName(state: string): string {\n        switch (state) {\n            case AddonModQuizProvider.ATTEMPT_IN_PROGRESS:\n                return Translate.instant('addon.mod_quiz.stateinprogress');\n\n            case AddonModQuizProvider.ATTEMPT_OVERDUE:\n                return Translate.instant('addon.mod_quiz.stateoverdue');\n\n            case AddonModQuizProvider.ATTEMPT_FINISHED:\n                return Translate.instant('addon.mod_quiz.statefinished');\n\n            case AddonModQuizProvider.ATTEMPT_ABANDONED:\n                return Translate.instant('addon.mod_quiz.stateabandoned');\n\n            default:\n                return '';\n        }\n    }\n\n    /**\n     * Get cache key for get attempt review WS calls.\n     *\n     * @param attemptId Attempt ID.\n     * @param page Page.\n     * @returns Cache key.\n     */\n    protected getAttemptReviewCacheKey(attemptId: number, page: number): string {\n        return this.getAttemptReviewCommonCacheKey(attemptId) + ':' + page;\n    }\n\n    /**\n     * Get common cache key for get attempt review WS calls.\n     *\n     * @param attemptId Attempt ID.\n     * @returns Cache key.\n     */\n    protected getAttemptReviewCommonCacheKey(attemptId: number): string {\n        return ROOT_CACHE_KEY + 'attemptReview:' + attemptId;\n    }\n\n    /**\n     * Get an attempt's review.\n     *\n     * @param attemptId Attempt ID.\n     * @param options Other options.\n     * @returns Promise resolved with the attempt review.\n     */\n    async getAttemptReview(\n        attemptId: number,\n        options: AddonModQuizGetAttemptReviewOptions = {},\n    ): Promise<AddonModQuizGetAttemptReviewResponse> {\n        const page = options.page === undefined ? -1 : options.page;\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params = {\n            attemptid: attemptId,\n            page: page,\n        };\n        const preSets = {\n            cacheKey: this.getAttemptReviewCacheKey(attemptId, page),\n            cacheErrors: ['noreview'],\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const result = await site.read<AddonModQuizGetAttemptReviewWSResponse>('mod_quiz_get_attempt_review', params, preSets);\n\n        result.questions = CoreQuestion.parseQuestions(result.questions);\n\n        return result;\n    }\n\n    /**\n     * Get cache key for get attempt summary WS calls.\n     *\n     * @param attemptId Attempt ID.\n     * @returns Cache key.\n     */\n    protected getAttemptSummaryCacheKey(attemptId: number): string {\n        return ROOT_CACHE_KEY + 'attemptSummary:' + attemptId;\n    }\n\n    /**\n     * Get an attempt's summary.\n     *\n     * @param attemptId Attempt ID.\n     * @param preflightData Preflight required data (like password).\n     * @param options Other options.\n     * @returns Promise resolved with the list of questions for the attempt summary.\n     */\n    async getAttemptSummary(\n        attemptId: number,\n        preflightData: Record<string, string>,\n        options: AddonModQuizGetAttemptSummaryOptions = {},\n    ): Promise<CoreQuestionQuestionParsed[]> {\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModQuizGetAttemptSummaryWSParams = {\n            attemptid: attemptId,\n            preflightdata: CoreUtils.objectToArrayOfObjects<AddonModQuizPreflightDataWSParam>(\n                preflightData,\n                'name',\n                'value',\n                true,\n            ),\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAttemptSummaryCacheKey(attemptId),\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModQuizGetAttemptSummaryWSResponse>('mod_quiz_get_attempt_summary', params, preSets);\n\n        const questions = CoreQuestion.parseQuestions(response.questions);\n\n        if (options.loadLocal) {\n            return AddonModQuizOffline.loadQuestionsLocalStates(attemptId, questions, site.getId());\n        }\n\n        return questions;\n    }\n\n    /**\n     * Get cache key for get combined review options WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getCombinedReviewOptionsCacheKey(quizId: number, userId: number): string {\n        return this.getCombinedReviewOptionsCommonCacheKey(quizId) + ':' + userId;\n    }\n\n    /**\n     * Get common cache key for get combined review options WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @returns Cache key.\n     */\n    protected getCombinedReviewOptionsCommonCacheKey(quizId: number): string {\n        return ROOT_CACHE_KEY + 'combinedReviewOptions:' + quizId;\n    }\n\n    /**\n     * Get a quiz combined review options.\n     *\n     * @param quizId Quiz ID.\n     * @param options Other options.\n     * @returns Promise resolved with the combined review options.\n     */\n    async getCombinedReviewOptions(\n        quizId: number,\n        options: AddonModQuizUserOptions = {},\n    ): Promise<AddonModQuizCombinedReviewOptions> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const userId = options.userId || site.getUserId();\n        const params: AddonModQuizGetCombinedReviewOptionsWSParams = {\n            quizid: quizId,\n            userid: userId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCombinedReviewOptionsCacheKey(quizId, userId),\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModQuizGetCombinedReviewOptionsWSResponse>(\n            'mod_quiz_get_combined_review_options',\n            params,\n            preSets,\n        );\n\n        // Convert the arrays to objects with name -> value.\n        return {\n            someoptions: <Record<string, number>> CoreUtils.objectToKeyValueMap(response.someoptions, 'name', 'value'),\n            alloptions: <Record<string, number>> CoreUtils.objectToKeyValueMap(response.alloptions, 'name', 'value'),\n            warnings: response.warnings,\n        };\n    }\n\n    /**\n     * Get cache key for get feedback for grade WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @param grade Grade.\n     * @returns Cache key.\n     */\n    protected getFeedbackForGradeCacheKey(quizId: number, grade: number): string {\n        return this.getFeedbackForGradeCommonCacheKey(quizId) + ':' + grade;\n    }\n\n    /**\n     * Get common cache key for get feedback for grade WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @returns Cache key.\n     */\n    protected getFeedbackForGradeCommonCacheKey(quizId: number): string {\n        return ROOT_CACHE_KEY + 'feedbackForGrade:' + quizId;\n    }\n\n    /**\n     * Get the feedback for a certain grade.\n     *\n     * @param quizId Quiz ID.\n     * @param grade Grade.\n     * @param options Other options.\n     * @returns Promise resolved with the feedback.\n     */\n    async getFeedbackForGrade(\n        quizId: number,\n        grade: SafeNumber,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModQuizGetQuizFeedbackForGradeWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModQuizGetQuizFeedbackForGradeWSParams = {\n            quizid: quizId,\n            grade: grade,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getFeedbackForGradeCacheKey(quizId, grade),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_quiz_get_quiz_feedback_for_grade', params, preSets);\n    }\n\n    /**\n     * Determine the correct number of decimal places required to format a grade.\n     * Based on Moodle's quiz_get_grade_format.\n     *\n     * @param quiz Quiz.\n     * @returns Number of decimals.\n     */\n    getGradeDecimals(quiz: AddonModQuizQuizWSData): number {\n        if (quiz.questiondecimalpoints === undefined) {\n            quiz.questiondecimalpoints = -1;\n        }\n\n        if (quiz.questiondecimalpoints == -1) {\n            return quiz.decimalpoints ?? 1;\n        }\n\n        return quiz.questiondecimalpoints;\n    }\n\n    /**\n     * Gets a quiz grade and feedback from the gradebook.\n     *\n     * @param courseId Course ID.\n     * @param moduleId Quiz module ID.\n     * @param ignoreCache Whether it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved with an object containing the grade and the feedback.\n     */\n    async getGradeFromGradebook(\n        courseId: number,\n        moduleId: number,\n        ignoreCache?: boolean,\n        siteId?: string,\n        userId?: number,\n    ): Promise<CoreGradesFormattedItem | undefined> {\n\n        const items = await CoreGradesHelper.getGradeModuleItems(\n            courseId,\n            moduleId,\n            userId,\n            undefined,\n            siteId,\n            ignoreCache,\n        );\n\n        return items.shift();\n    }\n\n    /**\n     * Given a list of attempts, returns the last finished attempt.\n     *\n     * @param attempts Attempts sorted. First attempt should be the first on the list.\n     * @returns Last finished attempt.\n     */\n    getLastFinishedAttemptFromList(attempts?: AddonModQuizAttemptWSData[]): AddonModQuizAttemptWSData | undefined {\n        if (!attempts) {\n            return;\n        }\n\n        for (let i = attempts.length - 1; i >= 0; i--) {\n            const attempt = attempts[i];\n\n            if (this.isAttemptFinished(attempt.state)) {\n                return attempt;\n            }\n        }\n    }\n\n    /**\n     * Given a list of questions, check if the quiz can be submitted.\n     * Will return an array with the messages to prevent the submit. Empty array if quiz can be submitted.\n     *\n     * @param questions Questions.\n     * @returns List of prevent submit messages. Empty array if quiz can be submitted.\n     */\n    getPreventSubmitMessages(questions: CoreQuestionQuestionParsed[]): string[] {\n        const messages: string[] = [];\n\n        questions.forEach((question) => {\n            if (question.type != 'random' && !CoreQuestionDelegate.isQuestionSupported(question.type)) {\n                // The question isn't supported.\n                messages.push(Translate.instant('core.question.questionmessage', {\n                    $a: question.slot,\n                    $b: Translate.instant('core.question.errorquestionnotsupported', { $a: question.type }),\n                }));\n            } else {\n                let message = CoreQuestionDelegate.getPreventSubmitMessage(question);\n                if (message) {\n                    message = Translate.instant(message);\n                    messages.push(Translate.instant('core.question.questionmessage', { $a: question.slot, $b: message }));\n                }\n            }\n        });\n\n        return messages;\n    }\n\n    /**\n     * Get cache key for quiz data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getQuizDataCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'quiz:' + courseId;\n    }\n\n    /**\n     * Get a Quiz with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the Quiz is retrieved.\n     */\n    protected async getQuizByField(\n        courseId: number,\n        key: string,\n        value: unknown,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModQuizQuizWSData> {\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModQuizGetQuizzesByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getQuizDataCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModQuizProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModQuizGetQuizzesByCoursesWSResponse>(\n            'mod_quiz_get_quizzes_by_courses',\n            params,\n            preSets,\n        );\n\n        // Search the quiz.\n        const quiz = response.quizzes.find(quiz => quiz[key] == value);\n\n        if (!quiz) {\n            throw new CoreError(Translate.instant('core.course.modulenotfound'));\n        }\n\n        return quiz;\n    }\n\n    /**\n     * Get a quiz by module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the quiz is retrieved.\n     */\n    getQuiz(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModQuizQuizWSData> {\n        return this.getQuizByField(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a quiz by quiz ID.\n     *\n     * @param courseId Course ID.\n     * @param id Quiz ID.\n     * @param options Other options.\n     * @returns Promise resolved when the quiz is retrieved.\n     */\n    getQuizById(courseId: number, id: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModQuizQuizWSData> {\n        return this.getQuizByField(courseId, 'id', id, options);\n    }\n\n    /**\n     * Get cache key for get quiz access information WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @returns Cache key.\n     */\n    protected getQuizAccessInformationCacheKey(quizId: number): string {\n        return ROOT_CACHE_KEY + 'quizAccessInformation:' + quizId;\n    }\n\n    /**\n     * Get access information for an attempt.\n     *\n     * @param quizId Quiz ID.\n     * @param options Other options.\n     * @returns Promise resolved with the access information.\n     */\n    async getQuizAccessInformation(\n        quizId: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModQuizGetQuizAccessInformationWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModQuizGetQuizAccessInformationWSParams = {\n            quizid: quizId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getQuizAccessInformationCacheKey(quizId),\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_quiz_get_quiz_access_information', params, preSets);\n    }\n\n    /**\n     * Get a readable Quiz grade method.\n     *\n     * @param method Grading method.\n     * @returns Readable grading method.\n     */\n    getQuizGradeMethod(method?: number | string): string {\n        if (method === undefined) {\n            return '';\n        }\n\n        if (typeof method == 'string') {\n            method = parseInt(method, 10);\n        }\n\n        switch (method) {\n            case AddonModQuizProvider.GRADEHIGHEST:\n                return Translate.instant('addon.mod_quiz.gradehighest');\n            case AddonModQuizProvider.GRADEAVERAGE:\n                return Translate.instant('addon.mod_quiz.gradeaverage');\n            case AddonModQuizProvider.ATTEMPTFIRST:\n                return Translate.instant('addon.mod_quiz.attemptfirst');\n            case AddonModQuizProvider.ATTEMPTLAST:\n                return Translate.instant('addon.mod_quiz.attemptlast');\n            default:\n                return '';\n        }\n    }\n\n    /**\n     * Get cache key for get quiz required qtypes WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @returns Cache key.\n     */\n    protected getQuizRequiredQtypesCacheKey(quizId: number): string {\n        return ROOT_CACHE_KEY + 'quizRequiredQtypes:' + quizId;\n    }\n\n    /**\n     * Get the potential question types that would be required for a given quiz.\n     *\n     * @param quizId Quiz ID.\n     * @param options Other options.\n     * @returns Promise resolved with the access information.\n     */\n    async getQuizRequiredQtypes(quizId: number, options: CoreCourseCommonModWSOptions = {}): Promise<string[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModQuizGetQuizRequiredQtypesWSParams = {\n            quizid: quizId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getQuizRequiredQtypesCacheKey(quizId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModQuizGetQuizRequiredQtypesWSResponse>(\n            'mod_quiz_get_quiz_required_qtypes',\n            params,\n            preSets,\n        );\n\n        return response.questiontypes;\n    }\n\n    /**\n     * Given an attempt's layout, return the list of pages.\n     *\n     * @param layout Attempt's layout.\n     * @returns Pages.\n     * @description\n     * An attempt's layout is a string with the question numbers separated by commas. A 0 indicates a change of page.\n     * Example: 1,2,3,0,4,5,6,0\n     * In the example above, first page has questions 1, 2 and 3. Second page has questions 4, 5 and 6.\n     *\n     * This function returns a list of pages.\n     */\n    getPagesFromLayout(layout?: string): number[] {\n        if (!layout) {\n            return [];\n        }\n\n        const split = layout.split(',');\n        const pages: number[] = [];\n        let page = 0;\n\n        for (let i = 0; i < split.length; i++) {\n            if (split[i] == '0') {\n                pages.push(page);\n                page++;\n            }\n        }\n\n        return pages;\n    }\n\n    /**\n     * Given an attempt's layout and a list of questions identified by question slot,\n     * return the list of pages that have at least 1 of the questions.\n     *\n     * @param layout Attempt's layout.\n     * @param questions List of questions. It needs to be an object where the keys are question slot.\n     * @returns Pages.\n     * @description\n     * An attempt's layout is a string with the question numbers separated by commas. A 0 indicates a change of page.\n     * Example: 1,2,3,0,4,5,6,0\n     * In the example above, first page has questions 1, 2 and 3. Second page has questions 4, 5 and 6.\n     *\n     * This function returns a list of pages.\n     */\n    getPagesFromLayoutAndQuestions(layout: string, questions: AddonModQuizQuestionsWithAnswers): number[] {\n        const split = layout.split(',');\n        const pages: number[] = [];\n        let page = 0;\n        let pageAdded = false;\n\n        for (let i = 0; i < split.length; i++) {\n            const value = Number(split[i]);\n\n            if (value == 0) {\n                page++;\n                pageAdded = false;\n            } else if (!pageAdded && questions[value]) {\n                pages.push(page);\n                pageAdded = true;\n            }\n        }\n\n        return pages;\n    }\n\n    /**\n     * Given a list of question types, returns the types that aren't supported.\n     *\n     * @param questionTypes Question types to check.\n     * @returns Not supported question types.\n     */\n    getUnsupportedQuestions(questionTypes: string[]): string[] {\n        const notSupported: string[] = [];\n\n        questionTypes.forEach((type) => {\n            if (type != 'random' && !CoreQuestionDelegate.isQuestionSupported(type)) {\n                notSupported.push(type);\n            }\n        });\n\n        return notSupported;\n    }\n\n    /**\n     * Given a list of access rules names, returns the rules that aren't supported.\n     *\n     * @param rulesNames Rules to check.\n     * @returns Not supported rules names.\n     */\n    getUnsupportedRules(rulesNames: string[]): string[] {\n        const notSupported: string[] = [];\n\n        rulesNames.forEach((name) => {\n            if (!AddonModQuizAccessRuleDelegate.isAccessRuleSupported(name)) {\n                notSupported.push(name);\n            }\n        });\n\n        return notSupported;\n    }\n\n    /**\n     * Get cache key for get user attempts WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getUserAttemptsCacheKey(quizId: number, userId: number): string {\n        return this.getUserAttemptsCommonCacheKey(quizId) + ':' + userId;\n    }\n\n    /**\n     * Get common cache key for get user attempts WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @returns Cache key.\n     */\n    protected getUserAttemptsCommonCacheKey(quizId: number): string {\n        return ROOT_CACHE_KEY + 'userAttempts:' + quizId;\n    }\n\n    /**\n     * Get quiz attempts for a certain user.\n     *\n     * @param quizId Quiz ID.\n     * @param options Other options.\n     * @returns Promise resolved with the attempts.\n     */\n    async getUserAttempts(\n        quizId: number,\n        options: AddonModQuizGetUserAttemptsOptions = {},\n    ): Promise<AddonModQuizAttemptWSData[]> {\n\n        const status = options.status || 'all';\n        const includePreviews = options.includePreviews === undefined ? true : options.includePreviews;\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const userId = options.userId || site.getUserId();\n        const params: AddonModQuizGetUserAttemptsWSParams = {\n            quizid: quizId,\n            userid: userId,\n            status: status,\n            includepreviews: !!includePreviews,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getUserAttemptsCacheKey(quizId, userId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModQuizGetUserAttemptsWSResponse>('mod_quiz_get_user_attempts', params, preSets);\n\n        return response.attempts;\n    }\n\n    /**\n     * Get cache key for get user best grade WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getUserBestGradeCacheKey(quizId: number, userId: number): string {\n        return this.getUserBestGradeCommonCacheKey(quizId) + ':' + userId;\n    }\n\n    /**\n     * Get common cache key for get user best grade WS calls.\n     *\n     * @param quizId Quiz ID.\n     * @returns Cache key.\n     */\n    protected getUserBestGradeCommonCacheKey(quizId: number): string {\n        return ROOT_CACHE_KEY + 'userBestGrade:' + quizId;\n    }\n\n    /**\n     * Get best grade in a quiz for a certain user.\n     *\n     * @param quizId Quiz ID.\n     * @param options Other options.\n     * @returns Promise resolved with the best grade data.\n     */\n    async getUserBestGrade(quizId: number, options: AddonModQuizUserOptions = {}): Promise<AddonModQuizGetUserBestGradeWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const userId = options.userId || site.getUserId();\n        const params: AddonModQuizGetUserBestGradeWSParams = {\n            quizid: quizId,\n            userid: userId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getUserBestGradeCacheKey(quizId, userId),\n            component: AddonModQuizProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_quiz_get_user_best_grade', params, preSets);\n    }\n\n    /**\n     * Invalidates all the data related to a certain quiz.\n     *\n     * @param quizId Quiz ID.\n     * @param courseId Course ID.\n     * @param attemptId Attempt ID to invalidate some WS calls.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllQuizData(\n        quizId: number,\n        courseId?: number,\n        attemptId?: number,\n        siteId?: string,\n        userId?: number,\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const promises: Promise<void>[] = [];\n\n        promises.push(this.invalidateAttemptAccessInformation(quizId, siteId));\n        promises.push(this.invalidateCombinedReviewOptionsForUser(quizId, siteId, userId));\n        promises.push(this.invalidateFeedback(quizId, siteId));\n        promises.push(this.invalidateQuizAccessInformation(quizId, siteId));\n        promises.push(this.invalidateQuizRequiredQtypes(quizId, siteId));\n        promises.push(this.invalidateUserAttemptsForUser(quizId, siteId, userId));\n        promises.push(this.invalidateUserBestGradeForUser(quizId, siteId, userId));\n\n        if (attemptId) {\n            promises.push(this.invalidateAttemptData(attemptId, siteId));\n            promises.push(this.invalidateAttemptReview(attemptId, siteId));\n            promises.push(this.invalidateAttemptSummary(attemptId, siteId));\n        }\n\n        if (courseId) {\n            promises.push(this.invalidateGradeFromGradebook(courseId, siteId, userId));\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidates attempt access information for all attempts in a quiz.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAttemptAccessInformation(quizId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getAttemptAccessInformationCommonCacheKey(quizId));\n    }\n\n    /**\n     * Invalidates attempt access information for an attempt.\n     *\n     * @param quizId Quiz ID.\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAttemptAccessInformationForAttempt(quizId: number, attemptId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAttemptAccessInformationCacheKey(quizId, attemptId));\n    }\n\n    /**\n     * Invalidates attempt data for all pages.\n     *\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAttemptData(attemptId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getAttemptDataCommonCacheKey(attemptId));\n    }\n\n    /**\n     * Invalidates attempt data for a certain page.\n     *\n     * @param attemptId Attempt ID.\n     * @param page Page.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAttemptDataForPage(attemptId: number, page: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAttemptDataCacheKey(attemptId, page));\n    }\n\n    /**\n     * Invalidates attempt review for all pages.\n     *\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAttemptReview(attemptId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getAttemptReviewCommonCacheKey(attemptId));\n    }\n\n    /**\n     * Invalidates attempt review for a certain page.\n     *\n     * @param attemptId Attempt ID.\n     * @param page Page.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAttemptReviewForPage(attemptId: number, page: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAttemptReviewCacheKey(attemptId, page));\n    }\n\n    /**\n     * Invalidates attempt summary.\n     *\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAttemptSummary(attemptId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAttemptSummaryCacheKey(attemptId));\n    }\n\n    /**\n     * Invalidates combined review options for all users.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCombinedReviewOptions(quizId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getCombinedReviewOptionsCommonCacheKey(quizId));\n    }\n\n    /**\n     * Invalidates combined review options for a certain user.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCombinedReviewOptionsForUser(quizId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.invalidateWsCacheForKey(this.getCombinedReviewOptionsCacheKey(quizId, userId || site.getUserId()));\n    }\n\n    /**\n     * Invalidate the prefetched content except files.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Get required data to call the invalidate functions.\n        const quiz = await this.getQuiz(courseId, moduleId, {\n            readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n            siteId,\n        });\n\n        const attempts = await this.getUserAttempts(quiz.id, { cmId: moduleId, siteId });\n\n        // Now invalidate it.\n        const lastAttemptId = attempts.length ? attempts[attempts.length - 1].id : undefined;\n\n        await this.invalidateAllQuizData(quiz.id, courseId, lastAttemptId, siteId);\n    }\n\n    /**\n     * Invalidates feedback for all grades of a quiz.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateFeedback(quizId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getFeedbackForGradeCommonCacheKey(quizId));\n    }\n\n    /**\n     * Invalidates feedback for a certain grade.\n     *\n     * @param quizId Quiz ID.\n     * @param grade Grade.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateFeedbackForGrade(quizId: number, grade: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getFeedbackForGradeCacheKey(quizId, grade));\n    }\n\n    /**\n     * Invalidates grade from gradebook for a certain user.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateGradeFromGradebook(courseId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await CoreGradesHelper.invalidateGradeModuleItems(courseId, userId || site.getUserId(), undefined, siteId);\n    }\n\n    /**\n     * Invalidates quiz access information for a quiz.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateQuizAccessInformation(quizId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getQuizAccessInformationCacheKey(quizId));\n    }\n\n    /**\n     * Invalidates required qtypes for a quiz.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateQuizRequiredQtypes(quizId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getQuizRequiredQtypesCacheKey(quizId));\n    }\n\n    /**\n     * Invalidates user attempts for all users.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserAttempts(quizId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getUserAttemptsCommonCacheKey(quizId));\n    }\n\n    /**\n     * Invalidates user attempts for a certain user.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserAttemptsForUser(quizId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getUserAttemptsCacheKey(quizId, userId || site.getUserId()));\n    }\n\n    /**\n     * Invalidates user best grade for all users.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserBestGrade(quizId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getUserBestGradeCommonCacheKey(quizId));\n    }\n\n    /**\n     * Invalidates user best grade for a certain user.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserBestGradeForUser(quizId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getUserBestGradeCacheKey(quizId, userId || site.getUserId()));\n    }\n\n    /**\n     * Invalidates quiz data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateQuizData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getQuizDataCacheKey(courseId));\n    }\n\n    /**\n     * Check if an attempt is finished based on its state.\n     *\n     * @param state Attempt's state.\n     * @returns Whether it's finished.\n     */\n    isAttemptFinished(state?: string): boolean {\n        return state == AddonModQuizProvider.ATTEMPT_FINISHED || state == AddonModQuizProvider.ATTEMPT_ABANDONED;\n    }\n\n    /**\n     * Check if an attempt is finished in offline but not synced.\n     *\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if finished in offline but not synced, false otherwise.\n     */\n    async isAttemptFinishedOffline(attemptId: number, siteId?: string): Promise<boolean> {\n        try {\n            const attempt = await AddonModQuizOffline.getAttemptById(attemptId, siteId);\n\n            return !!attempt.finished;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Check if an attempt is nearly over. We consider an attempt nearly over or over if:\n     * - Is not in progress\n     * OR\n     * - It finished before autosaveperiod passes.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @returns Whether it's nearly over or over.\n     */\n    isAttemptTimeNearlyOver(quiz: AddonModQuizQuizWSData, attempt: AddonModQuizAttemptWSData): boolean {\n        if (attempt.state != AddonModQuizProvider.ATTEMPT_IN_PROGRESS) {\n            // Attempt not in progress, return true.\n            return true;\n        }\n\n        const dueDate = this.getAttemptDueDate(quiz, attempt);\n        const autoSavePeriod = quiz.autosaveperiod || 0;\n\n        if (dueDate > 0 && Date.now() + autoSavePeriod >= dueDate) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if last attempt is offline and unfinished.\n     *\n     * @param quiz Quiz data.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, user current site's user.\n     * @returns Promise resolved with boolean: true if last offline attempt is unfinished, false otherwise.\n     */\n    async isLastAttemptOfflineUnfinished(quiz: AddonModQuizQuizWSData, siteId?: string, userId?: number): Promise<boolean> {\n        try {\n            const attempts = await AddonModQuizOffline.getQuizAttempts(quiz.id, siteId, userId);\n\n            const last = attempts.pop();\n\n            return !!last && !last.finished;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Check if a quiz navigation is sequential.\n     *\n     * @param quiz Quiz.\n     * @returns Whether navigation is sequential.\n     */\n    isNavigationSequential(quiz: AddonModQuizQuizWSData): boolean {\n        return quiz.navmethod == 'sequential';\n    }\n\n    /**\n     * Check if a question is blocked.\n     *\n     * @param question Question.\n     * @returns Whether it's blocked.\n     */\n    isQuestionBlocked(question: CoreQuestionQuestionParsed): boolean {\n        const element = CoreDomUtils.convertToElement(question.html);\n\n        return !!element.querySelector('.mod_quiz-blocked_question_warning');\n    }\n\n    /**\n     * Check if a quiz is enabled to be used in offline.\n     *\n     * @param quiz Quiz.\n     * @returns Whether offline is enabled.\n     */\n    isQuizOffline(quiz: AddonModQuizQuizWSData): boolean {\n        // Don't allow downloading the quiz if offline is disabled to prevent wasting a lot of data when opening it.\n        return !!quiz.allowofflineattempts\n            && !this.isNavigationSequential(quiz)\n            && !CoreSites.getCurrentSite()?.isOfflineDisabled();\n    }\n\n    /**\n     * Report an attempt as being viewed. It did not store logs offline because order of the log is important.\n     *\n     * @param attemptId Attempt ID.\n     * @param page Page number.\n     * @param preflightData Preflight required data (like password).\n     * @param offline Whether attempt is offline.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logViewAttempt(\n        attemptId: number,\n        page: number = 0,\n        preflightData: Record<string, string> = {},\n        offline?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModQuizViewAttemptWSParams = {\n            attemptid: attemptId,\n            page: page,\n            preflightdata: CoreUtils.objectToArrayOfObjects<AddonModQuizPreflightDataWSParam>(\n                preflightData,\n                'name',\n                'value',\n            ),\n        };\n        const promises: Promise<unknown>[] = [];\n\n        promises.push(site.write('mod_quiz_view_attempt', params));\n        if (offline) {\n            promises.push(AddonModQuizOffline.setAttemptCurrentPage(attemptId, page, site.getId()));\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Report an attempt's review as being viewed.\n     *\n     * @param attemptId Attempt ID.\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logViewAttemptReview(attemptId: number, quizId: number, siteId?: string): Promise<void> {\n        const params: AddonModQuizViewAttemptReviewWSParams = {\n            attemptid: attemptId,\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_quiz_view_attempt_review',\n            params,\n            AddonModQuizProvider.COMPONENT,\n            quizId,\n            siteId,\n        );\n    }\n\n    /**\n     * Report an attempt's summary as being viewed.\n     *\n     * @param attemptId Attempt ID.\n     * @param preflightData Preflight required data (like password).\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logViewAttemptSummary(\n        attemptId: number,\n        preflightData: Record<string, string>,\n        quizId: number,\n        siteId?: string,\n    ): Promise<void> {\n        const params: AddonModQuizViewAttemptSummaryWSParams = {\n            attemptid: attemptId,\n            preflightdata: CoreUtils.objectToArrayOfObjects<AddonModQuizPreflightDataWSParam>(\n                preflightData,\n                'name',\n                'value',\n            ),\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_quiz_view_attempt_summary',\n            params,\n            AddonModQuizProvider.COMPONENT,\n            quizId,\n            siteId,\n        );\n    }\n\n    /**\n     * Report a quiz as being viewed.\n     *\n     * @param id Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logViewQuiz(id: number, siteId?: string): Promise<void> {\n        const params: AddonModQuizViewQuizWSParams = {\n            quizid: id,\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_quiz_view_quiz',\n            params,\n            AddonModQuizProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Process an attempt, saving its data.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param data Data to save.\n     * @param preflightData Preflight required data (like password).\n     * @param finish Whether to finish the quiz.\n     * @param timeUp Whether the quiz time is up, false otherwise.\n     * @param offline Whether the attempt is offline.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    async processAttempt(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData,\n        data: CoreQuestionsAnswers,\n        preflightData: Record<string, string>,\n        finish?: boolean,\n        timeUp?: boolean,\n        offline?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        if (offline) {\n            return this.processAttemptOffline(quiz, attempt, data, preflightData, finish, siteId);\n        }\n\n        await this.processAttemptOnline(attempt.id, data, preflightData, finish, timeUp, siteId);\n    }\n\n    /**\n     * Process an online attempt, saving its data.\n     *\n     * @param attemptId Attempt ID.\n     * @param data Data to save.\n     * @param preflightData Preflight required data (like password).\n     * @param finish Whether to finish the quiz.\n     * @param timeUp Whether the quiz time is up, false otherwise.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    protected async processAttemptOnline(\n        attemptId: number,\n        data: CoreQuestionsAnswers,\n        preflightData: Record<string, string>,\n        finish?: boolean,\n        timeUp?: boolean,\n        siteId?: string,\n    ): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModQuizProcessAttemptWSParams = {\n            attemptid: attemptId,\n            data: CoreUtils.objectToArrayOfObjects(data, 'name', 'value'),\n            finishattempt: !!finish,\n            timeup: !!timeUp,\n            preflightdata: CoreUtils.objectToArrayOfObjects<AddonModQuizPreflightDataWSParam>(\n                preflightData,\n                'name',\n                'value',\n            ),\n        };\n\n        const response = await site.write<AddonModQuizProcessAttemptWSResponse>('mod_quiz_process_attempt', params);\n\n        if (response.warnings?.length) {\n            // Reject with the first warning.\n            throw new CoreWSError(response.warnings[0]);\n        }\n\n        return response.state;\n    }\n\n    /**\n     * Process an offline attempt, saving its data.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param data Data to save.\n     * @param preflightData Preflight required data (like password).\n     * @param finish Whether to finish the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    protected async processAttemptOffline(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData,\n        data: CoreQuestionsAnswers,\n        preflightData: Record<string, string>,\n        finish?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n\n        // Get attempt summary to have the list of questions.\n        const questionsArray = await this.getAttemptSummary(attempt.id, preflightData, {\n            cmId: quiz.coursemodule,\n            loadLocal: true,\n            readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n            siteId,\n        });\n\n        // Convert the question array to an object.\n        const questions = CoreUtils.arrayToObject(questionsArray, 'slot');\n\n        return AddonModQuizOffline.processAttempt(quiz, attempt, questions, data, finish, siteId);\n    }\n\n    /**\n     * Check if it's a graded quiz. Based on Moodle's quiz_has_grades.\n     *\n     * @param quiz Quiz.\n     * @returns Whether quiz is graded.\n     */\n    quizHasGrades(quiz: AddonModQuizQuizWSData): boolean {\n        return (quiz.grade ?? 0) >= 0.000005 && (quiz.sumgrades ?? 0) >= 0.000005;\n    }\n\n    /**\n     * Convert the raw grade into a grade out of the maximum grade for this quiz.\n     * Based on Moodle's quiz_rescale_grade.\n     *\n     * @param rawGrade The unadjusted grade, for example attempt.sumgrades.\n     * @param quiz Quiz.\n     * @param format True to format the results for display, 'question' to format a question grade\n     *               (different number of decimal places), false to not format it.\n     * @returns Grade to display.\n     */\n    rescaleGrade(\n        rawGrade: string | number | undefined | null,\n        quiz: AddonModQuizQuizWSData,\n        format: boolean | string = true,\n    ): string | undefined {\n        let grade: number | undefined;\n\n        const rawGradeNum = typeof rawGrade === 'string' ? parseFloat(rawGrade) : rawGrade;\n        if (rawGradeNum !== undefined && rawGradeNum !== null && !isNaN(rawGradeNum)) {\n            if (quiz.sumgrades && quiz.sumgrades >= 0.000005) {\n                grade = rawGradeNum * (quiz.grade ?? 0) / quiz.sumgrades;\n            } else {\n                grade = 0;\n            }\n        }\n\n        if (grade === null || grade === undefined) {\n            return;\n        }\n\n        if (format === 'question') {\n            return this.formatGrade(grade, this.getGradeDecimals(quiz));\n        } else if (format) {\n            return this.formatGrade(grade, quiz.decimalpoints ?? 1);\n        }\n\n        return String(grade);\n    }\n\n    /**\n     * Save an attempt data.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param data Data to save.\n     * @param preflightData Preflight required data (like password).\n     * @param offline Whether attempt is offline.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    async saveAttempt(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData,\n        data: CoreQuestionsAnswers,\n        preflightData: Record<string, string>,\n        offline?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        try {\n            if (offline) {\n                return await this.processAttemptOffline(quiz, attempt, data, preflightData, false, siteId);\n            }\n\n            await this.saveAttemptOnline(attempt.id, data, preflightData, siteId);\n        } catch (error) {\n            this.logger.error(error);\n\n            throw error;\n        }\n    }\n\n    /**\n     * Save an attempt data.\n     *\n     * @param attemptId Attempt ID.\n     * @param data Data to save.\n     * @param preflightData Preflight required data (like password).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    protected async saveAttemptOnline(\n        attemptId: number,\n        data: CoreQuestionsAnswers,\n        preflightData: Record<string, string>,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModQuizSaveAttemptWSParams = {\n            attemptid: attemptId,\n            data: CoreUtils.objectToArrayOfObjects(data, 'name', 'value'),\n            preflightdata: CoreUtils.objectToArrayOfObjects<AddonModQuizPreflightDataWSParam>(\n                preflightData,\n                'name',\n                'value',\n            ),\n        };\n\n        const response = await site.write<CoreStatusWithWarningsWSResponse>('mod_quiz_save_attempt', params);\n\n        if (response.warnings?.length) {\n            // Reject with the first warning.\n            throw new CoreWSError(response.warnings[0]);\n        } else if (!response.status) {\n            // It shouldn't happen that status is false and no warnings were returned.\n            throw new CoreError('Cannot save data.');\n        }\n    }\n\n    /**\n     * Check if time left should be shown.\n     *\n     * @param rules List of active rules names.\n     * @param attempt Attempt.\n     * @param endTime The attempt end time (in seconds).\n     * @returns Whether time left should be displayed.\n     */\n    shouldShowTimeLeft(rules: string[], attempt: AddonModQuizAttemptWSData, endTime: number): boolean {\n        const timeNow = CoreTimeUtils.timestamp();\n\n        if (attempt.state != AddonModQuizProvider.ATTEMPT_IN_PROGRESS) {\n            return false;\n        }\n\n        return AddonModQuizAccessRuleDelegate.shouldShowTimeLeft(rules, attempt, endTime, timeNow);\n    }\n\n    /**\n     * Start an attempt.\n     *\n     * @param quizId Quiz ID.\n     * @param preflightData Preflight required data (like password).\n     * @param forceNew Whether to force a new attempt or not.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the attempt data.\n     */\n    async startAttempt(\n        quizId: number,\n        preflightData: Record<string, string>,\n        forceNew?: boolean,\n        siteId?: string,\n    ): Promise<AddonModQuizAttemptWSData> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModQuizStartAttemptWSParams = {\n            quizid: quizId,\n            preflightdata: CoreUtils.objectToArrayOfObjects<AddonModQuizPreflightDataWSParam>(\n                preflightData,\n                'name',\n                'value',\n            ),\n            forcenew: !!forceNew,\n        };\n\n        const response = await site.write<AddonModQuizStartAttemptWSResponse>('mod_quiz_start_attempt', params);\n\n        if (response.warnings?.length) {\n            // Reject with the first warning.\n            throw new CoreWSError(response.warnings[0]);\n        }\n\n        return response.attempt;\n    }\n\n}\n\nexport const AddonModQuiz = makeSingleton(AddonModQuizProvider);\n\n/**\n * Common options with user ID.\n */\nexport type AddonModQuizUserOptions = CoreCourseCommonModWSOptions & {\n    userId?: number; // User ID. If not defined use site's current user.\n};\n\n/**\n * Options to pass to getAllQuestionsData.\n */\nexport type AddonModQuizAllQuestionsDataOptions = CoreCourseCommonModWSOptions & {\n    pages?: number[]; // List of pages to get. If not defined, all pages.\n};\n\n/**\n * Options to pass to getAttemptReview.\n */\nexport type AddonModQuizGetAttemptReviewOptions = CoreCourseCommonModWSOptions & {\n    page?: number; // List of pages to get. If not defined, all pages.\n};\n\n/**\n * Options to pass to getAttemptSummary.\n */\nexport type AddonModQuizGetAttemptSummaryOptions = CoreCourseCommonModWSOptions & {\n    loadLocal?: boolean; // Whether it should load local state for each question.\n};\n\n/**\n * Options to pass to getUserAttempts.\n */\nexport type AddonModQuizGetUserAttemptsOptions = CoreCourseCommonModWSOptions & {\n    status?: string; // Status of the attempts to get. By default, 'all'.\n    includePreviews?: boolean; // Whether to include previews. Defaults to true.\n    userId?: number; // User ID. If not defined use site's current user.\n};\n\n/**\n * Preflight data in the format accepted by the WebServices.\n */\ntype AddonModQuizPreflightDataWSParam = {\n    name: string; // Data name.\n    value: string; // Data value.\n};\n\n/**\n * Params of mod_quiz_get_attempt_access_information WS.\n */\nexport type AddonModQuizGetAttemptAccessInformationWSParams = {\n    quizid: number; // Quiz instance id.\n    attemptid?: number; // Attempt id, 0 for the user last attempt if exists.\n};\n\n/**\n * Data returned by mod_quiz_get_attempt_access_information WS.\n */\nexport type AddonModQuizGetAttemptAccessInformationWSResponse = {\n    endtime?: number; // When the attempt must be submitted (determined by rules).\n    isfinished: boolean; // Whether there is no way the user will ever be allowed to attempt.\n    ispreflightcheckrequired?: boolean; // Whether a check is required before the user starts/continues his attempt.\n    preventnewattemptreasons: string[]; // List of reasons.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_get_attempt_data WS.\n */\nexport type AddonModQuizGetAttemptDataWSParams = {\n    attemptid: number; // Attempt id.\n    page: number; // Page number.\n    preflightdata?: AddonModQuizPreflightDataWSParam[]; // Preflight required data (like passwords).\n};\n\n/**\n * Data returned by mod_quiz_get_attempt_data WS.\n */\nexport type AddonModQuizGetAttemptDataWSResponse = {\n    attempt: AddonModQuizAttemptWSData;\n    messages: string[]; // Access messages, will only be returned for users with mod/quiz:preview capability.\n    nextpage: number; // Next page number.\n    questions: CoreQuestionQuestionWSData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Attempt data returned by several WebServices.\n */\nexport type AddonModQuizAttemptWSData = {\n    id: number; // Attempt id.\n    quiz?: number; // Foreign key reference to the quiz that was attempted.\n    userid?: number; // Foreign key reference to the user whose attempt this is.\n    attempt?: number; // Sequentially numbers this students attempts at this quiz.\n    uniqueid?: number; // Foreign key reference to the question_usage that holds the details of the the question_attempts.\n    layout?: string; // Attempt layout.\n    currentpage?: number; // Attempt current page.\n    preview?: number; // Whether is a preview attempt or not.\n    state?: string; // The current state of the attempts. 'inprogress', 'overdue', 'finished' or 'abandoned'.\n    timestart?: number; // Time when the attempt was started.\n    timefinish?: number; // Time when the attempt was submitted. 0 if the attempt has not been submitted yet.\n    timemodified?: number; // Last modified time.\n    timemodifiedoffline?: number; // Last modified time via webservices.\n    timecheckstate?: number; // Next time quiz cron should check attempt for state changes. NULL means never check.\n    sumgrades?: SafeNumber | null; // Total marks for this attempt.\n};\n\n/**\n * Get attempt data response with parsed questions.\n */\nexport type AddonModQuizGetAttemptDataResponse = Omit<AddonModQuizGetAttemptDataWSResponse, 'questions'> & {\n    questions: CoreQuestionQuestionParsed[];\n};\n\n/**\n * Params of mod_quiz_get_attempt_review WS.\n */\nexport type AddonModQuizGetAttemptReviewWSParams = {\n    attemptid: number; // Attempt id.\n    page?: number; // Page number, empty for all the questions in all the pages.\n};\n\n/**\n * Data returned by mod_quiz_get_attempt_review WS.\n */\nexport type AddonModQuizGetAttemptReviewWSResponse = {\n    grade: string; // Grade for the quiz (or empty or \"notyetgraded\").\n    attempt: AddonModQuizAttemptWSData;\n    additionaldata: AddonModQuizWSAdditionalData[];\n    questions: CoreQuestionQuestionWSData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Additional data returned by mod_quiz_get_attempt_review WS.\n */\nexport type AddonModQuizWSAdditionalData = {\n    id: string; // Id of the data.\n    title: string; // Data title.\n    content: string; // Data content.\n};\n\n/**\n * Get attempt review response with parsed questions.\n */\nexport type AddonModQuizGetAttemptReviewResponse = Omit<AddonModQuizGetAttemptReviewWSResponse, 'questions'> & {\n    questions: CoreQuestionQuestionParsed[];\n};\n\n/**\n * Params of mod_quiz_get_attempt_summary WS.\n */\nexport type AddonModQuizGetAttemptSummaryWSParams = {\n    attemptid: number; // Attempt id.\n    preflightdata?: AddonModQuizPreflightDataWSParam[]; // Preflight required data (like passwords).\n};\n\n/**\n * Data returned by mod_quiz_get_attempt_summary WS.\n */\nexport type AddonModQuizGetAttemptSummaryWSResponse = {\n    questions: CoreQuestionQuestionWSData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_get_combined_review_options WS.\n */\nexport type AddonModQuizGetCombinedReviewOptionsWSParams = {\n    quizid: number; // Quiz instance id.\n    userid?: number; // User id (empty for current user).\n};\n\n/**\n * Data returned by mod_quiz_get_combined_review_options WS.\n */\nexport type AddonModQuizGetCombinedReviewOptionsWSResponse = {\n    someoptions: AddonModQuizWSReviewOption[];\n    alloptions: AddonModQuizWSReviewOption[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Option data returned by mod_quiz_get_combined_review_options.\n */\nexport type AddonModQuizWSReviewOption = {\n    name: string; // Option name.\n    value: number; // Option value.\n};\n\n/**\n * Data returned by mod_quiz_get_combined_review_options WS, formatted to convert the options to objects.\n */\nexport type AddonModQuizCombinedReviewOptions = Omit<AddonModQuizGetCombinedReviewOptionsWSResponse, 'alloptions'|'someoptions'> & {\n    someoptions: Record<string, number>;\n    alloptions: Record<string, number>;\n};\n\n/**\n * Params of mod_quiz_get_quiz_feedback_for_grade WS.\n */\nexport type AddonModQuizGetQuizFeedbackForGradeWSParams = {\n    quizid: number; // Quiz instance id.\n    grade: number; // The grade to check.\n};\n\n/**\n * Data returned by mod_quiz_get_quiz_feedback_for_grade WS.\n */\nexport type AddonModQuizGetQuizFeedbackForGradeWSResponse = {\n    feedbacktext: string; // The comment that corresponds to this grade (empty for none).\n    feedbacktextformat?: number; // Feedbacktext format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    feedbackinlinefiles?: CoreWSExternalFile[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_get_quizzes_by_courses WS.\n */\nexport type AddonModQuizGetQuizzesByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_quiz_get_quizzes_by_courses WS.\n */\nexport type AddonModQuizGetQuizzesByCoursesWSResponse = {\n    quizzes: AddonModQuizQuizWSData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Quiz data returned by mod_quiz_get_quizzes_by_courses WS.\n */\nexport type AddonModQuizQuizWSData = {\n    id: number; // Standard Moodle primary key.\n    course: number; // Foreign key reference to the course this quiz is part of.\n    coursemodule: number; // Course module id.\n    name: string; // Quiz name.\n    intro?: string; // Quiz introduction text.\n    introformat?: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    timeopen?: number; // The time when this quiz opens. (0 = no restriction.).\n    timeclose?: number; // The time when this quiz closes. (0 = no restriction.).\n    timelimit?: number; // The time limit for quiz attempts, in seconds.\n    overduehandling?: string; // The method used to handle overdue attempts. 'autosubmit', 'graceperiod' or 'autoabandon'.\n    graceperiod?: number; // The amount of time (in seconds) after time limit during which attempts can still be submitted.\n    preferredbehaviour?: string; // The behaviour to ask questions to use.\n    canredoquestions?: number; // Allows students to redo any completed question within a quiz attempt.\n    attempts?: number; // The maximum number of attempts a student is allowed.\n    attemptonlast?: number; // Whether subsequent attempts start from the answer to the previous attempt (1) or start blank (0).\n    grademethod?: number; // One of the values QUIZ_GRADEHIGHEST, QUIZ_GRADEAVERAGE, QUIZ_ATTEMPTFIRST or QUIZ_ATTEMPTLAST.\n    decimalpoints?: number; // Number of decimal points to use when displaying grades.\n    questiondecimalpoints?: number; // Number of decimal points to use when displaying question grades.\n    reviewattempt?: number; // Whether users are allowed to review their quiz attempts at various times.\n    reviewcorrectness?: number; // Whether users are allowed to review their quiz attempts at various times.\n    reviewmarks?: number; // Whether users are allowed to review their quiz attempts at various times.\n    reviewspecificfeedback?: number; // Whether users are allowed to review their quiz attempts at various times.\n    reviewgeneralfeedback?: number; // Whether users are allowed to review their quiz attempts at various times.\n    reviewrightanswer?: number; // Whether users are allowed to review their quiz attempts at various times.\n    reviewoverallfeedback?: number; // Whether users are allowed to review their quiz attempts at various times.\n    questionsperpage?: number; // How often to insert a page break when editing the quiz, or when shuffling the question order.\n    navmethod?: string; // Any constraints on how the user is allowed to navigate around the quiz.\n    shuffleanswers?: number; // Whether the parts of the question should be shuffled, in those question types that support it.\n    sumgrades?: number | null; // The total of all the question instance maxmarks.\n    grade?: number; // The total that the quiz overall grade is scaled to be out of.\n    timecreated?: number; // The time when the quiz was added to the course.\n    timemodified?: number; // Last modified time.\n    password?: string; // A password that the student must enter before starting or continuing a quiz attempt.\n    subnet?: string; // Used to restrict the IP addresses from which this quiz can be attempted.\n    browsersecurity?: string; // Restriciton on the browser the student must use. E.g. 'securewindow'.\n    delay1?: number; // Delay that must be left between the first and second attempt, in seconds.\n    delay2?: number; // Delay that must be left between the second and subsequent attempt, in seconds.\n    showuserpicture?: number; // Option to show the user's picture during the attempt and on the review page.\n    showblocks?: number; // Whether blocks should be shown on the attempt.php and review.php pages.\n    completionattemptsexhausted?: number; // Mark quiz complete when the student has exhausted the maximum number of attempts.\n    completionpass?: number; // Whether to require passing grade.\n    allowofflineattempts?: number; // Whether to allow the quiz to be attempted offline in the mobile app.\n    autosaveperiod?: number; // Auto-save delay.\n    hasfeedback?: number; // Whether the quiz has any non-blank feedback text.\n    hasquestions?: number; // Whether the quiz has questions.\n    section?: number; // Course section id.\n    visible?: number; // Module visibility.\n    groupmode?: number; // Group mode.\n    groupingid?: number; // Grouping id.\n};\n\n/**\n * Params of mod_quiz_get_quiz_access_information WS.\n */\nexport type AddonModQuizGetQuizAccessInformationWSParams = {\n    quizid: number; // Quiz instance id.\n};\n\n/**\n * Data returned by mod_quiz_get_quiz_access_information WS.\n */\nexport type AddonModQuizGetQuizAccessInformationWSResponse = {\n    canattempt: boolean; // Whether the user can do the quiz or not.\n    canmanage: boolean; // Whether the user can edit the quiz settings or not.\n    canpreview: boolean; // Whether the user can preview the quiz or not.\n    canreviewmyattempts: boolean; // Whether the users can review their previous attempts or not.\n    canviewreports: boolean; // Whether the user can view the quiz reports or not.\n    accessrules: string[]; // List of rules.\n    activerulenames: string[]; // List of active rules.\n    preventaccessreasons: string[]; // List of reasons.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_get_quiz_required_qtypes WS.\n */\nexport type AddonModQuizGetQuizRequiredQtypesWSParams = {\n    quizid: number; // Quiz instance id.\n};\n\n/**\n * Data returned by mod_quiz_get_quiz_required_qtypes WS.\n */\nexport type AddonModQuizGetQuizRequiredQtypesWSResponse = {\n    questiontypes: string[]; // List of question types used in the quiz.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_get_user_attempts WS.\n */\nexport type AddonModQuizGetUserAttemptsWSParams = {\n    quizid: number; // Quiz instance id.\n    userid?: number; // User id, empty for current user.\n    status?: string; // Quiz status: all, finished or unfinished.\n    includepreviews?: boolean; // Whether to include previews or not.\n};\n\n/**\n * Data returned by mod_quiz_get_user_attempts WS.\n */\nexport type AddonModQuizGetUserAttemptsWSResponse = {\n    attempts: AddonModQuizAttemptWSData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_get_user_best_grade WS.\n */\nexport type AddonModQuizGetUserBestGradeWSParams = {\n    quizid: number; // Quiz instance id.\n    userid?: number; // User id.\n};\n\n/**\n * Data returned by mod_quiz_get_user_best_grade WS.\n */\nexport type AddonModQuizGetUserBestGradeWSResponse = {\n    hasgrade: boolean; // Whether the user has a grade on the given quiz.\n    grade?: SafeNumber; // The grade (only if the user has a grade).\n    gradetopass?: number; // @since 3.11. The grade to pass the quiz (only if set).\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_view_attempt WS.\n */\nexport type AddonModQuizViewAttemptWSParams = {\n    attemptid: number; // Attempt id.\n    page: number; // Page number.\n    preflightdata?: AddonModQuizPreflightDataWSParam[]; // Preflight required data (like passwords).\n};\n\n/**\n * Params of mod_quiz_process_attempt WS.\n */\nexport type AddonModQuizProcessAttemptWSParams = {\n    attemptid: number; // Attempt id.\n    data?: { // The data to be saved.\n        name: string; // Data name.\n        value: string; // Data value.\n    }[];\n    finishattempt?: boolean; // Whether to finish or not the attempt.\n    timeup?: boolean; // Whether the WS was called by a timer when the time is up.\n    preflightdata?: AddonModQuizPreflightDataWSParam[]; // Preflight required data (like passwords).\n};\n\n/**\n * Data returned by mod_quiz_process_attempt WS.\n */\nexport type AddonModQuizProcessAttemptWSResponse = {\n    state: string; // The new attempt state: inprogress, finished, overdue, abandoned.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_save_attempt WS.\n */\nexport type AddonModQuizSaveAttemptWSParams = {\n    attemptid: number; // Attempt id.\n    data: { // The data to be saved.\n        name: string; // Data name.\n        value: string; // Data value.\n    }[];\n    preflightdata?: AddonModQuizPreflightDataWSParam[]; // Preflight required data (like passwords).\n};\n\n/**\n * Params of mod_quiz_start_attempt WS.\n */\nexport type AddonModQuizStartAttemptWSParams = {\n    quizid: number; // Quiz instance id.\n    preflightdata?: AddonModQuizPreflightDataWSParam[]; // Preflight required data (like passwords).\n    forcenew?: boolean; // Whether to force a new attempt or not.\n};\n\n/**\n * Data returned by mod_quiz_start_attempt WS.\n */\nexport type AddonModQuizStartAttemptWSResponse = {\n    attempt: AddonModQuizAttemptWSData;\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_quiz_view_attempt_review WS.\n */\nexport type AddonModQuizViewAttemptReviewWSParams = {\n    attemptid: number; // Attempt id.\n};\n\n/**\n * Params of mod_quiz_view_attempt_summary WS.\n */\nexport type AddonModQuizViewAttemptSummaryWSParams = {\n    attemptid: number; // Attempt id.\n    preflightdata?: AddonModQuizPreflightDataWSParam[]; // Preflight required data (like passwords).\n};\n\n/**\n * Params of mod_quiz_view_quiz WS.\n */\nexport type AddonModQuizViewQuizWSParams = {\n    quizid: number; // Quiz instance id.\n};\n\n/**\n * Data passed to ATTEMPT_FINISHED_EVENT event.\n */\nexport type AddonModQuizAttemptFinishedData = {\n    quizId: number;\n    attemptId: number;\n    synced: boolean;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}