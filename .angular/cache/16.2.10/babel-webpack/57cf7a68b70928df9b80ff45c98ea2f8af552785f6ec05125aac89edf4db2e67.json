{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { makeSingleton } from '@singletons';\nimport { CorePushNotifications } from '../pushnotifications';\nimport * as i0 from \"@angular/core\";\n/**\n * Cron handler to force a register on a Moodle site when a site is manually synchronized.\n */\nexport class CorePushNotificationsRegisterCronHandlerService {\n  constructor() {\n    this.name = 'CorePushNotificationsRegisterCronHandler';\n  }\n  /**\n   * Check whether the sync can be executed manually. Call isSync if not defined.\n   *\n   * @returns Whether the sync can be executed manually.\n   */\n  canManualSync() {\n    return true; // Execute the handler when the site is manually synchronized.\n  }\n  /**\n   * Execute the process.\n   * Receives the ID of the site affected, undefined for all sites.\n   *\n   * @param siteId ID of the site affected, undefined for all sites.\n   * @returns Promise resolved when done, rejected if failure.\n   */\n  execute(siteId) {\n    return _asyncToGenerator(function* () {\n      if (!siteId || !CorePushNotifications.canRegisterOnMoodle()) {\n        // It's not a specific site, don't do anything.\n        return;\n      }\n      // Register the device again.\n      yield CorePushNotifications.registerDeviceOnMoodle(siteId, true);\n    })();\n  }\n  /**\n   * Get the time between consecutive executions.\n   *\n   * @returns Time between consecutive executions (in ms).\n   */\n  getInterval() {\n    return 86400000; // 1 day. We won't do anything with automatic execution, so use a big number.\n  }\n  /**\n   * Check whether it's a synchronization process or not. True if not defined.\n   *\n   * @returns Whether it's a synchronization process or not.\n   */\n  isSync() {\n    return false;\n  }\n}\n_class = CorePushNotificationsRegisterCronHandlerService;\n_class.ɵfac = function CorePushNotificationsRegisterCronHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CorePushNotificationsRegisterCronHandler = makeSingleton(CorePushNotificationsRegisterCronHandlerService);","map":{"version":3,"names":["makeSingleton","CorePushNotifications","CorePushNotificationsRegisterCronHandlerService","constructor","name","canManualSync","execute","siteId","_asyncToGenerator","canRegisterOnMoodle","registerDeviceOnMoodle","getInterval","isSync","factory","ɵfac","providedIn","CorePushNotificationsRegisterCronHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/pushnotifications/services/handlers/register-cron.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreCronHandler } from '@services/cron';\nimport { makeSingleton } from '@singletons';\nimport { CorePushNotifications } from '../pushnotifications';\n\n/**\n * Cron handler to force a register on a Moodle site when a site is manually synchronized.\n */\n@Injectable({ providedIn: 'root' })\nexport class CorePushNotificationsRegisterCronHandlerService implements CoreCronHandler {\n\n    name = 'CorePushNotificationsRegisterCronHandler';\n\n    /**\n     * Check whether the sync can be executed manually. Call isSync if not defined.\n     *\n     * @returns Whether the sync can be executed manually.\n     */\n    canManualSync(): boolean {\n        return true; // Execute the handler when the site is manually synchronized.\n    }\n\n    /**\n     * Execute the process.\n     * Receives the ID of the site affected, undefined for all sites.\n     *\n     * @param siteId ID of the site affected, undefined for all sites.\n     * @returns Promise resolved when done, rejected if failure.\n     */\n    async execute(siteId?: string): Promise<void> {\n        if (!siteId || !CorePushNotifications.canRegisterOnMoodle()) {\n            // It's not a specific site, don't do anything.\n            return;\n        }\n\n        // Register the device again.\n        await CorePushNotifications.registerDeviceOnMoodle(siteId, true);\n    }\n\n    /**\n     * Get the time between consecutive executions.\n     *\n     * @returns Time between consecutive executions (in ms).\n     */\n    getInterval(): number {\n        return 86400000; // 1 day. We won't do anything with automatic execution, so use a big number.\n    }\n\n    /**\n     * Check whether it's a synchronization process or not. True if not defined.\n     *\n     * @returns Whether it's a synchronization process or not.\n     */\n    isSync(): boolean {\n        return false;\n    }\n\n}\n\nexport const CorePushNotificationsRegisterCronHandler = makeSingleton(CorePushNotificationsRegisterCronHandlerService);\n"],"mappings":";;AAiBA,SAASA,aAAa,QAAQ,aAAa;AAC3C,SAASC,qBAAqB,QAAQ,sBAAsB;;AAE5D;;;AAIA,OAAM,MAAOC,+CAA+C;EAD5DC,YAAA;IAGI,KAAAC,IAAI,GAAG,0CAA0C;;EAEjD;;;;;EAKAC,aAAaA,CAAA;IACT,OAAO,IAAI,CAAC,CAAC;EACjB;EAEA;;;;;;;EAOMC,OAAOA,CAACC,MAAe;IAAA,OAAAC,iBAAA;MACzB,IAAI,CAACD,MAAM,IAAI,CAACN,qBAAqB,CAACQ,mBAAmB,EAAE,EAAE;QACzD;QACA;;MAGJ;MACA,MAAMR,qBAAqB,CAACS,sBAAsB,CAACH,MAAM,EAAE,IAAI,CAAC;IAAC;EACrE;EAEA;;;;;EAKAI,WAAWA,CAAA;IACP,OAAO,QAAQ,CAAC,CAAC;EACrB;EAEA;;;;;EAKAC,MAAMA,CAAA;IACF,OAAO,KAAK;EAChB;;SA9CSV,+CAA+C;;mBAA/CA,MAA+C;AAAA;;SAA/CA,MAA+C;EAAAW,OAAA,EAA/CX,MAA+C,CAAAY,IAAA;EAAAC,UAAA,EADlC;AAAM;AAmDhC,OAAO,MAAMC,wCAAwC,GAAGhB,aAAa,CAACE,+CAA+C,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}