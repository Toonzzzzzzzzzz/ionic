{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { BehaviorSubject } from 'rxjs';\nimport { Md5 } from 'ts-md5/dist/md5';\nimport { CoreFile } from '@services/file';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourse } from './course';\nimport { CoreCache } from '@classes/cache';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreDelegate } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreError } from '@classes/errors/error';\nimport { CHECK_UPDATES_TIMES_TABLE } from './database/module-prefetch';\nimport { CoreCourseHelper } from './course-helper';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmCourse:';\n/**\n * Delegate to register module prefetch handlers.\n */\nexport class CoreCourseModulePrefetchDelegateService extends CoreDelegate {\n  constructor() {\n    super('CoreCourseModulePrefetchDelegate', true);\n    this.statusCache = new CoreCache();\n    this.featurePrefix = 'CoreCourseModuleDelegate_';\n    this.handlerNameProperty = 'modName';\n    // Promises for check updates, to prevent performing the same request twice at the same time.\n    this.courseUpdatesPromises = {};\n    // Promises and observables for prefetching, to prevent downloading same section twice at the same time and notify progress.\n    this.prefetchData = {};\n  }\n  /**\n   * Initialize.\n   */\n  initialize() {\n    CoreEvents.on(CoreEvents.LOGOUT, () => this.clearStatusCache());\n    CoreEvents.on(CoreEvents.PACKAGE_STATUS_CHANGED, data => {\n      this.updateStatusCache(data.status, data.component, data.componentId);\n    }, CoreSites.getCurrentSiteId());\n    // If a file inside a module is downloaded/deleted, clear the corresponding cache.\n    CoreEvents.on(CoreEvents.COMPONENT_FILE_ACTION, data => {\n      if (!CoreFilepool.isFileEventDownloadedOrDeleted(data)) {\n        return;\n      }\n      this.statusCache.invalidate(CoreFilepool.getPackageId(data.component, data.componentId));\n    }, CoreSites.getCurrentSiteId());\n  }\n  /**\n   * Check if a certain module can use core_course_check_updates.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved with boolean: whether the module can use check updates WS.\n   */\n  canModuleUseCheckUpdates(module, courseId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this.getPrefetchHandlerFor(module.modname);\n      if (!handler) {\n        // Module not supported, cannot use check updates.\n        return false;\n      }\n      if (handler.canUseCheckUpdates) {\n        return handler.canUseCheckUpdates(module, courseId);\n      }\n      // By default, modules can use check updates.\n      return true;\n    })();\n  }\n  /**\n   * Clear the status cache.\n   */\n  clearStatusCache() {\n    this.statusCache.clear();\n  }\n  /**\n   * Creates the list of modules to check for get course updates.\n   *\n   * @param modules List of modules.\n   * @param courseId Course ID the modules belong to.\n   * @returns Promise resolved with the lists.\n   */\n  createToCheckList(modules, courseId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        toCheck: [],\n        cannotUse: []\n      };\n      const promises = modules.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (module) {\n          try {\n            const data = yield _this2.getModuleStatusAndDownloadTime(module, courseId);\n            if (data.status != CoreConstants.DOWNLOADED) {\n              return;\n            }\n            // Module is downloaded and not outdated. Check if it can check updates.\n            const canUse = yield _this2.canModuleUseCheckUpdates(module, courseId);\n            if (canUse) {\n              // Can use check updates, add it to the tocheck list.\n              result.toCheck.push({\n                contextlevel: 'module',\n                id: module.id,\n                since: data.downloadTime || 0\n              });\n            } else {\n              // Cannot use check updates, add it to the cannotUse array.\n              result.cannotUse.push(module);\n            }\n          } catch (_unused) {\n            // Ignore errors.\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      yield Promise.all(promises);\n      // Sort toCheck list.\n      result.toCheck.sort((a, b) => a.id >= b.id ? 1 : -1);\n      return result;\n    })();\n  }\n  /**\n   * Determines a module status based on current status, restoring downloads if needed.\n   *\n   * @param module Module.\n   * @param status Current status.\n   * @returns Module status.\n   */\n  determineModuleStatus(module, status) {\n    const handler = this.getPrefetchHandlerFor(module.modname);\n    const siteId = CoreSites.getCurrentSiteId();\n    if (!handler) {\n      return status;\n    }\n    if (status == CoreConstants.DOWNLOADING) {\n      // Check if the download is being handled.\n      if (!CoreFilepool.getPackageDownloadPromise(siteId, handler.component, module.id)) {\n        // Not handled, the app was probably restarted or something weird happened.\n        // Re-start download (files already on queue or already downloaded will be skipped).\n        handler.prefetch(module, module.course);\n      }\n    } else if (handler.determineStatus) {\n      // The handler implements a determineStatus function. Apply it.\n      return handler.determineStatus(module, status, true);\n    }\n    return status;\n  }\n  /**\n   * Download a module.\n   *\n   * @param module Module to download.\n   * @param courseId Course ID the module belongs to.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @returns Promise resolved when finished.\n   */\n  downloadModule(module, courseId, dirPath) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Check if the module has a prefetch handler.\n      const handler = _this3.getPrefetchHandlerFor(module.modname);\n      if (!handler) {\n        return;\n      }\n      yield _this3.syncModule(module, courseId);\n      yield handler.download(module, courseId, dirPath);\n    })();\n  }\n  /**\n   * Check for updates in a course.\n   *\n   * @param modules List of modules.\n   * @param courseId Course ID the modules belong to.\n   * @returns Promise resolved with the updates. If a module is set to false, it means updates cannot be\n   *         checked for that module in the current site.\n   */\n  getCourseUpdates(modules, courseId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Check if there's already a getCourseUpdates in progress.\n      const id = Md5.hashAsciiStr(courseId + '#' + JSON.stringify(modules));\n      const siteId = CoreSites.getCurrentSiteId();\n      if (_this4.courseUpdatesPromises[siteId] && _this4.courseUpdatesPromises[siteId][id] !== undefined) {\n        // There's already a get updates ongoing, return the promise.\n        return _this4.courseUpdatesPromises[siteId][id];\n      } else if (!_this4.courseUpdatesPromises[siteId]) {\n        _this4.courseUpdatesPromises[siteId] = {};\n      }\n      _this4.courseUpdatesPromises[siteId][id] = _this4.fetchCourseUpdates(modules, courseId, siteId);\n      try {\n        return yield _this4.courseUpdatesPromises[siteId][id];\n      } finally {\n        // Get updates finished, delete the promise.\n        delete _this4.courseUpdatesPromises[siteId][id];\n      }\n    })();\n  }\n  /**\n   * Fetch updates in a course.\n   *\n   * @param modules List of modules.\n   * @param courseId Course ID the modules belong to.\n   * @param siteId Site ID.\n   * @returns Promise resolved with the updates. If a module is set to false, it means updates cannot be\n   *         checked for that module in the site.\n   */\n  fetchCourseUpdates(modules, courseId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const data = yield _this5.createToCheckList(modules, courseId);\n      const result = {};\n      // Mark as false the modules that cannot use check updates WS.\n      data.cannotUse.forEach(module => {\n        result[module.id] = false;\n      });\n      if (!data.toCheck.length) {\n        // Nothing to check, no need to call the WS.\n        return result;\n      }\n      // Get the site, maybe the user changed site.\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        courseid: courseId,\n        tocheck: data.toCheck\n      };\n      const preSets = {\n        cacheKey: _this5.getCourseUpdatesCacheKey(courseId),\n        emergencyCache: false,\n        uniqueCacheKey: true,\n        splitRequest: {\n          param: 'tocheck',\n          maxLength: 10\n        }\n      };\n      try {\n        const response = yield site.read('core_course_check_updates', params, preSets);\n        // Store the last execution of the check updates call.\n        const entry = {\n          courseId: courseId,\n          time: CoreTimeUtils.timestamp()\n        };\n        CoreUtils.ignoreErrors(site.getDb().insertRecord(CHECK_UPDATES_TIMES_TABLE, entry));\n        return _this5.treatCheckUpdatesResult(data.toCheck, response, result);\n      } catch (error) {\n        // Cannot get updates.\n        // Get cached entries but discard modules with a download time higher than the last execution of check updates.\n        let entry;\n        try {\n          entry = yield site.getDb().getRecord(CHECK_UPDATES_TIMES_TABLE, {\n            courseId: courseId\n          });\n        } catch (_unused2) {\n          // No previous executions, return result as it is.\n          return result;\n        }\n        preSets.getCacheUsingCacheKey = true;\n        preSets.omitExpires = true;\n        const response = yield site.read('core_course_check_updates', params, preSets);\n        return _this5.treatCheckUpdatesResult(data.toCheck, response, result, entry.time);\n      }\n    })();\n  }\n  /**\n   * Check for updates in a course.\n   *\n   * @param courseId Course ID the modules belong to.\n   * @returns Promise resolved with the updates.\n   */\n  getCourseUpdatesByCourseId(courseId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // Get course sections and all their modules.\n      const sections = yield CoreCourse.getSections(courseId, false, true, {\n        omitExpires: true\n      });\n      return _this6.getCourseUpdates(CoreCourse.getSectionsModules(sections), courseId);\n    })();\n  }\n  /**\n   * Get cache key for course updates WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getCourseUpdatesCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'courseUpdates:' + courseId;\n  }\n  /**\n   * Get modules download size. Only treat the modules with status not downloaded or outdated.\n   *\n   * @param modules List of modules.\n   * @param courseId Course ID the modules belong to.\n   * @returns Promise resolved with the size.\n   */\n  getDownloadSize(modules, courseId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      // Get the status of each module.\n      const data = yield _this7.getModulesStatus(modules, courseId);\n      const downloadableModules = data[CoreConstants.NOT_DOWNLOADED].concat(data[CoreConstants.OUTDATED]);\n      const result = {\n        size: 0,\n        total: true\n      };\n      yield Promise.all(downloadableModules.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (module) {\n          const size = yield _this7.getModuleDownloadSize(module, courseId);\n          result.total = result.total && size.total;\n          result.size += size.size;\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      return result;\n    })();\n  }\n  /**\n   * Get the download size of a module.\n   *\n   * @param module Module to get size.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @returns Promise resolved with the size.\n   */\n  getModuleDownloadSize(module, courseId, single) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this8.getPrefetchHandlerFor(module.modname);\n      if (!handler) {\n        return {\n          size: 0,\n          total: false\n        };\n      }\n      const downloadable = yield _this8.isModuleDownloadable(module, courseId);\n      if (!downloadable) {\n        return {\n          size: 0,\n          total: true\n        };\n      }\n      const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n      const downloadSize = _this8.statusCache.getValue(packageId, 'downloadSize');\n      if (downloadSize !== undefined) {\n        return downloadSize;\n      }\n      try {\n        const size = yield handler.getDownloadSize(module, courseId, single);\n        return _this8.statusCache.setValue(packageId, 'downloadSize', size);\n      } catch (error) {\n        const cachedSize = _this8.statusCache.getValue(packageId, 'downloadSize', true);\n        if (cachedSize) {\n          return cachedSize;\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Get the download size of a module.\n   *\n   * @param module Module to get size.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved with the size.\n   */\n  getModuleDownloadedSize(module, courseId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this9.getPrefetchHandlerFor(module.modname);\n      if (!handler) {\n        return 0;\n      }\n      const downloadable = yield _this9.isModuleDownloadable(module, courseId);\n      if (!downloadable) {\n        return 0;\n      }\n      const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n      const downloadedSize = _this9.statusCache.getValue(packageId, 'downloadedSize');\n      if (downloadedSize !== undefined) {\n        return downloadedSize;\n      }\n      try {\n        let size = 0;\n        if (handler.getDownloadedSize) {\n          // Handler implements a method to calculate the downloaded size, use it.\n          size = yield handler.getDownloadedSize(module, courseId);\n        } else {\n          // Handler doesn't implement it, get the module files and check if they're downloaded.\n          const files = yield _this9.getModuleFiles(module, courseId);\n          const siteId = CoreSites.getCurrentSiteId();\n          // Retrieve file size if it's downloaded.\n          yield Promise.all(files.map( /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(function* (file) {\n              const path = yield CoreFilepool.getFilePathByUrl(siteId, CoreFileHelper.getFileUrl(file));\n              try {\n                const fileSize = yield CoreFile.getFileSize(path);\n                size += fileSize;\n              } catch (_unused3) {\n                // Error getting size. Check if the file is being downloaded.\n                const isDownloading = yield CoreFilepool.isFileDownloadingByUrl(siteId, CoreFileHelper.getFileUrl(file));\n                if (isDownloading) {\n                  // If downloading, count as downloaded.\n                  size += file.filesize || 0;\n                }\n              }\n            });\n            return function (_x3) {\n              return _ref3.apply(this, arguments);\n            };\n          }()));\n        }\n        return _this9.statusCache.setValue(packageId, 'downloadedSize', size);\n      } catch (_unused4) {\n        return _this9.statusCache.getValue(packageId, 'downloadedSize', true) || 0;\n      }\n    })();\n  }\n  /**\n   * Gets the estimated total size of data stored for a module. This includes\n   * the files downloaded for it (getModuleDownloadedSize) and also the total\n   * size of web service requests stored for it.\n   *\n   * @param module Module to get the size.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved with the total size (0 if unknown)\n   */\n  getModuleStoredSize(module, courseId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = CoreSites.getCurrentSite();\n      const handler = _this10.getPrefetchHandlerFor(module.modname);\n      const [downloadedSize, cachedSize] = yield Promise.all([_this10.getModuleDownloadedSize(module, courseId), handler && site ? site.getComponentCacheSize(handler.component, module.id) : 0]);\n      const totalSize = cachedSize + downloadedSize;\n      return isNaN(totalSize) ? 0 : totalSize;\n    })();\n  }\n  /**\n   * Get module files.\n   *\n   * @param module Module to get the files.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved with the list of files.\n   */\n  getModuleFiles(module, courseId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this11.getPrefetchHandlerFor(module.modname);\n      if (handler !== null && handler !== void 0 && handler.getFiles) {\n        // The handler defines a function to get files, use it.\n        return handler.getFiles(module, courseId);\n      } else if (handler !== null && handler !== void 0 && handler.loadContents) {\n        // The handler defines a function to load contents, use it before returning module contents.\n        yield handler.loadContents(module, courseId);\n        return module.contents || [];\n      } else {\n        return module.contents || [];\n      }\n    })();\n  }\n  /**\n   * Get the module status.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param updates Result of getCourseUpdates for all modules in the course. If not provided, it will be\n   *                calculated (slower). If it's false it means the site doesn't support check updates.\n   * @param refresh True if it should ignore the memory cache, not the WS cache.\n   * @param sectionId ID of the section the module belongs to.\n   * @returns Promise resolved with the status.\n   */\n  getModuleStatus(module, courseId, updates, refresh, sectionId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this12.getPrefetchHandlerFor(module.modname);\n      if (!handler) {\n        // No handler found, module not downloadable.\n        return CoreConstants.NOT_DOWNLOADABLE;\n      }\n      // Check if the status is cached.\n      const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n      const status = _this12.statusCache.getValue(packageId, 'status');\n      if (!refresh && status !== undefined) {\n        _this12.storeCourseAndSection(packageId, courseId, sectionId);\n        return _this12.determineModuleStatus(module, status);\n      }\n      const result = yield _this12.calculateModuleStatus(handler, module, courseId, updates, sectionId);\n      if (result.updateStatus) {\n        _this12.updateStatusCache(result.status, handler.component, module.id, courseId, sectionId);\n      }\n      return _this12.determineModuleStatus(module, result.status);\n    })();\n  }\n  /**\n   * Calculate a module status.\n   *\n   * @param handler Prefetch handler.\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param updates Result of getCourseUpdates for all modules in the course. If not provided, it will be\n   *                calculated (slower). If it's false it means the site doesn't support check updates.\n   * @param sectionId ID of the section the module belongs to.\n   * @returns Promise resolved with the status.\n   */\n  calculateModuleStatus(handler, module, courseId, updates, sectionId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      // Check if the module is downloadable.\n      const downloadable = yield _this13.isModuleDownloadable(module, courseId);\n      if (!downloadable) {\n        return {\n          status: CoreConstants.NOT_DOWNLOADABLE,\n          updateStatus: true\n        };\n      }\n      // Get the saved package status.\n      const siteId = CoreSites.getCurrentSiteId();\n      const currentStatus = yield CoreFilepool.getPackageStatus(siteId, handler.component, module.id);\n      let status = handler.determineStatus ? handler.determineStatus(module, currentStatus, true) : currentStatus;\n      if (status != CoreConstants.DOWNLOADED || updates === false) {\n        return {\n          status,\n          updateStatus: true\n        };\n      }\n      // Module is downloaded. Determine if there are updated in the module to show them outdated.\n      if (updates === undefined) {\n        try {\n          // We don't have course updates, calculate them.\n          updates = yield _this13.getCourseUpdatesByCourseId(courseId);\n        } catch (_unused5) {\n          // Error getting updates, show the stored status.\n          const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n          _this13.storeCourseAndSection(packageId, courseId, sectionId);\n          return {\n            status: currentStatus,\n            updateStatus: false\n          };\n        }\n      }\n      if (!updates || updates[module.id] === false) {\n        // Cannot check updates, always show outdated.\n        return {\n          status: CoreConstants.OUTDATED,\n          updateStatus: true\n        };\n      }\n      try {\n        // Check if the module has any update.\n        const hasUpdates = yield _this13.moduleHasUpdates(module, courseId, updates);\n        if (!hasUpdates) {\n          // No updates, keep current status.\n          return {\n            status,\n            updateStatus: true\n          };\n        }\n        // Has updates, mark the module as outdated.\n        status = CoreConstants.OUTDATED;\n        yield CoreUtils.ignoreErrors(CoreFilepool.storePackageStatus(siteId, status, handler.component, module.id));\n        return {\n          status,\n          updateStatus: true\n        };\n      } catch (_unused6) {\n        // Error checking if module has updates.\n        const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n        const status = _this13.statusCache.getValue(packageId, 'status', true);\n        return {\n          status: _this13.determineModuleStatus(module, status || CoreConstants.NOT_DOWNLOADED),\n          updateStatus: true\n        };\n      }\n    })();\n  }\n  /**\n   * Get the status of a list of modules, along with the lists of modules for each status.\n   *\n   * @param modules List of modules to prefetch.\n   * @param courseId Course ID the modules belong to.\n   * @param sectionId ID of the section the modules belong to.\n   * @param refresh True if it should always check the DB (slower).\n   * @param onlyToDisplay True if the status will only be used to determine which button should be displayed.\n   * @param checkUpdates Whether to use the WS to check updates. Defaults to true.\n   * @returns Promise resolved with the data.\n   */\n  getModulesStatus(modules, courseId, sectionId, refresh, onlyToDisplay, checkUpdates = true) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      let updates = false;\n      const result = {\n        total: 0,\n        status: CoreConstants.NOT_DOWNLOADABLE,\n        [CoreConstants.NOT_DOWNLOADED]: [],\n        [CoreConstants.DOWNLOADED]: [],\n        [CoreConstants.DOWNLOADING]: [],\n        [CoreConstants.OUTDATED]: []\n      };\n      if (checkUpdates) {\n        // Check updates in course. Don't use getCourseUpdates because the list of modules might not be the whole course list.\n        try {\n          updates = yield _this14.getCourseUpdatesByCourseId(courseId);\n        } catch (_unused7) {\n          // Cannot get updates.\n        }\n      }\n      yield Promise.all(modules.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (module) {\n          const handler = _this14.getPrefetchHandlerFor(module.modname);\n          if (!handler) {\n            return;\n          }\n          try {\n            const modStatus = yield _this14.getModuleStatus(module, courseId, updates, refresh);\n            if (!result[modStatus]) {\n              return;\n            }\n            result.status = CoreFilepool.determinePackagesStatus(result.status, modStatus);\n            result[modStatus].push(module);\n            result.total++;\n          } catch (error) {\n            const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n            const cacheStatus = _this14.statusCache.getValue(packageId, 'status', true);\n            if (cacheStatus === undefined) {\n              throw error;\n            }\n            if (!result[cacheStatus]) {\n              return;\n            }\n            result.status = CoreFilepool.determinePackagesStatus(result.status, cacheStatus);\n            result[cacheStatus].push(module);\n            result.total++;\n          }\n        });\n        return function (_x4) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n      return result;\n    })();\n  }\n  /**\n   * Get a module status and download time. It will only return the download time if the module is downloaded or outdated.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved with the data.\n   */\n  getModuleStatusAndDownloadTime(module, courseId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this15.getPrefetchHandlerFor(module.modname);\n      const siteId = CoreSites.getCurrentSiteId();\n      if (!handler) {\n        // No handler found, module not downloadable.\n        return {\n          status: CoreConstants.NOT_DOWNLOADABLE\n        };\n      }\n      // Get the status from the cache.\n      const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n      const status = _this15.statusCache.getValue(packageId, 'status');\n      if (status !== undefined && !CoreFileHelper.isStateDownloaded(status)) {\n        // Module isn't downloaded, just return the status.\n        return {\n          status\n        };\n      }\n      // Check if the module is downloadable.\n      const downloadable = yield _this15.isModuleDownloadable(module, courseId);\n      if (!downloadable) {\n        return {\n          status: CoreConstants.NOT_DOWNLOADABLE\n        };\n      }\n      try {\n        // Get the stored data to get the status and downloadTime.\n        const data = yield CoreFilepool.getPackageData(siteId, handler.component, module.id);\n        return {\n          status: data.status || CoreConstants.NOT_DOWNLOADED,\n          downloadTime: data.downloadTime || 0\n        };\n      } catch (_unused8) {\n        return {\n          status: CoreConstants.NOT_DOWNLOADED\n        };\n      }\n    })();\n  }\n  /**\n   * Get updates for a certain module.\n   * It will only return the updates if the module can use check updates and it's downloaded or outdated.\n   *\n   * @param module Module to check.\n   * @param courseId Course the module belongs to.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the updates.\n   */\n  getModuleUpdates(module, courseId, ignoreCache, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const data = yield _this16.getModuleStatusAndDownloadTime(module, courseId);\n      if (!CoreFileHelper.isStateDownloaded(data.status)) {\n        // Not downloaded, no updates.\n        return null;\n      }\n      // Module is downloaded. Check if it can check updates.\n      const canUse = yield _this16.canModuleUseCheckUpdates(module, courseId);\n      if (!canUse) {\n        // Can't use check updates, no updates.\n        return null;\n      }\n      const params = {\n        courseid: courseId,\n        tocheck: [{\n          contextlevel: 'module',\n          id: module.id,\n          since: data.downloadTime || 0\n        }]\n      };\n      const preSets = {\n        cacheKey: _this16.getModuleUpdatesCacheKey(courseId, module.id)\n      };\n      if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const response = yield site.read('core_course_check_updates', params, preSets);\n      if (!response.instances[0]) {\n        throw new CoreError('Could not get module updates.');\n      }\n      return response.instances[0];\n    })();\n  }\n  /**\n   * Get cache key for module updates WS calls.\n   *\n   * @param courseId Course ID.\n   * @param moduleId Module ID.\n   * @returns Cache key.\n   */\n  getModuleUpdatesCacheKey(courseId, moduleId) {\n    return this.getCourseUpdatesCacheKey(courseId) + ':' + moduleId;\n  }\n  /**\n   * Get a prefetch handler.\n   *\n   * @param moduleName The module name to work on.\n   * @returns Prefetch handler.\n   */\n  getPrefetchHandlerFor(moduleName) {\n    return this.getHandler(moduleName, true);\n  }\n  /**\n   * Invalidate check updates WS call.\n   *\n   * @param courseId Course ID.\n   * @returns Promise resolved when data is invalidated.\n   */\n  invalidateCourseUpdates(courseId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const site = CoreSites.getCurrentSite();\n      if (!site) {\n        return;\n      }\n      yield site.invalidateWsCacheForKey(_this17.getCourseUpdatesCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidate a list of modules in a course. This should only invalidate WS calls, not downloaded files.\n   *\n   * @param modules List of modules.\n   * @param courseId Course ID.\n   * @returns Promise resolved when modules are invalidated.\n   */\n  invalidateModules(modules, courseId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const promises = modules.map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (module) {\n          const handler = _this18.getPrefetchHandlerFor(module.modname);\n          if (!handler) {\n            return;\n          }\n          if (handler.invalidateModule) {\n            yield CoreUtils.ignoreErrors(handler.invalidateModule(module, courseId));\n          }\n          // Invalidate cache.\n          _this18.invalidateModuleStatusCache(module);\n        });\n        return function (_x5) {\n          return _ref5.apply(this, arguments);\n        };\n      }());\n      promises.push(_this18.invalidateCourseUpdates(courseId));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidates the cache for a given module.\n   *\n   * @param module Module to be invalidated.\n   */\n  invalidateModuleStatusCache(module) {\n    const handler = this.getPrefetchHandlerFor(module.modname);\n    if (handler) {\n      this.statusCache.invalidate(CoreFilepool.getPackageId(handler.component, module.id));\n    }\n  }\n  /**\n   * Invalidate check updates WS call for a certain module.\n   *\n   * @param courseId Course ID.\n   * @param moduleId Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data is invalidated.\n   */\n  invalidateModuleUpdates(courseId, moduleId, siteId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this19.getModuleUpdatesCacheKey(courseId, moduleId));\n    })();\n  }\n  /**\n   * Check if a list of modules is being downloaded.\n   *\n   * @param id An ID to identify the download.\n   * @returns True if it's being downloaded, false otherwise.\n   */\n  isBeingDownloaded(id) {\n    var _this$prefetchData$si;\n    const siteId = CoreSites.getCurrentSiteId();\n    return !!((_this$prefetchData$si = this.prefetchData[siteId]) !== null && _this$prefetchData$si !== void 0 && _this$prefetchData$si[id]);\n  }\n  /**\n   * Check if a module is downloadable.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved with true if downloadable, false otherwise.\n   */\n  isModuleDownloadable(module, courseId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      if ('uservisible' in module && !CoreCourseHelper.canUserViewModule(module)) {\n        // Module isn't visible by the user, cannot be downloaded.\n        return false;\n      }\n      const handler = _this20.getPrefetchHandlerFor(module.modname);\n      if (!handler) {\n        return false;\n      }\n      if (!handler.isDownloadable) {\n        // Function not defined, assume it's downloadable.\n        return true;\n      }\n      const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n      let downloadable = _this20.statusCache.getValue(packageId, 'downloadable');\n      if (downloadable !== undefined) {\n        return downloadable;\n      }\n      try {\n        downloadable = yield handler.isDownloadable(module, courseId);\n        return _this20.statusCache.setValue(packageId, 'downloadable', downloadable);\n      } catch (_unused9) {\n        // Something went wrong, assume it's not downloadable.\n        return false;\n      }\n    })();\n  }\n  /**\n   * Check if a module has updates based on the result of getCourseUpdates.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param updates Result of getCourseUpdates.\n   * @returns Promise resolved with boolean: whether the module has updates.\n   */\n  moduleHasUpdates(module, courseId, updates) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      var _handler$updatesNames;\n      const handler = _this21.getPrefetchHandlerFor(module.modname);\n      const moduleUpdates = updates[module.id];\n      if (handler !== null && handler !== void 0 && handler.hasUpdates) {\n        // Handler implements its own function to check the updates, use it.\n        return handler.hasUpdates(module, courseId, moduleUpdates);\n      } else if (!moduleUpdates || !moduleUpdates.updates || !moduleUpdates.updates.length) {\n        // Module doesn't have any update.\n        return false;\n      } else if (handler !== null && handler !== void 0 && (_handler$updatesNames = handler.updatesNames) !== null && _handler$updatesNames !== void 0 && _handler$updatesNames.test) {\n        // Check the update names defined by the handler.\n        for (let i = 0, len = moduleUpdates.updates.length; i < len; i++) {\n          if (handler.updatesNames.test(moduleUpdates.updates[i].name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      // Handler doesn't define hasUpdates or updatesNames and there is at least 1 update. Assume it has updates.\n      return true;\n    })();\n  }\n  /**\n   * Prefetch a module.\n   *\n   * @param module Module to prefetch.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @returns Promise resolved when finished.\n   */\n  prefetchModule(module, courseId, single) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this22.getPrefetchHandlerFor(module.modname);\n      if (!handler) {\n        return;\n      }\n      yield _this22.syncModule(module, courseId);\n      yield handler.prefetch(module, courseId, single);\n    })();\n  }\n  /**\n   * Sync a group of modules.\n   *\n   * @param modules Array of modules to sync.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when finished.\n   */\n  syncModules(modules, courseId) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield Promise.all(modules.map(module => _this23.syncModule(module, courseId)));\n      } finally {\n        // Invalidate course updates.\n        yield CoreUtils.ignoreErrors(_this23.invalidateCourseUpdates(courseId));\n      }\n    })();\n  }\n  /**\n   * Sync a module.\n   *\n   * @param module Module to sync.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when finished.\n   */\n  syncModule(module, courseId) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this24.getPrefetchHandlerFor(module.modname);\n      if (!(handler !== null && handler !== void 0 && handler.sync)) {\n        return;\n      }\n      const result = yield CoreUtils.ignoreErrors(handler.sync(module, courseId));\n      // Always invalidate status cache for this module. We cannot know if data was sent to server or not.\n      _this24.invalidateModuleStatusCache(module);\n      return result;\n    })();\n  }\n  /**\n   * Prefetches a list of modules using their prefetch handlers.\n   * If a prefetch already exists for this site and id, returns the current promise.\n   *\n   * @param id An ID to identify the download. It can be used to retrieve the download promise.\n   * @param modules List of modules to prefetch.\n   * @param courseId Course ID the modules belong to.\n   * @param onProgress Function to call everytime a module is downloaded.\n   * @returns Promise resolved when all modules have been prefetched.\n   */\n  prefetchModules(id, modules, courseId, onProgress) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      var _this25$prefetchData$;\n      const siteId = CoreSites.getCurrentSiteId();\n      const currentPrefetchData = (_this25$prefetchData$ = _this25.prefetchData[siteId]) === null || _this25$prefetchData$ === void 0 ? void 0 : _this25$prefetchData$[id];\n      if (currentPrefetchData) {\n        // There's a prefetch ongoing, return the current promise.\n        if (onProgress) {\n          currentPrefetchData.subscriptions.push(currentPrefetchData.observable.subscribe(onProgress));\n        }\n        return currentPrefetchData.promise;\n      }\n      let count = 0;\n      const total = modules.length;\n      const moduleIds = modules.map(module => module.id);\n      const prefetchData = {\n        observable: new BehaviorSubject({\n          count: count,\n          total: total\n        }),\n        promise: Promise.resolve(),\n        subscriptions: []\n      };\n      if (onProgress) {\n        prefetchData.observable.subscribe(onProgress);\n      }\n      const promises = modules.map( /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* (module) {\n          // Check if the module has a prefetch handler.\n          const handler = _this25.getPrefetchHandlerFor(module.modname);\n          if (!handler) {\n            return;\n          }\n          const downloadable = yield _this25.isModuleDownloadable(module, courseId);\n          if (!downloadable) {\n            return;\n          }\n          yield handler.prefetch(module, courseId);\n          const index = moduleIds.indexOf(module.id);\n          if (index > -1) {\n            moduleIds.splice(index, 1);\n            count++;\n            prefetchData.observable.next({\n              count: count,\n              total: total\n            });\n          }\n        });\n        return function (_x6) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n      // Set the promise.\n      prefetchData.promise = CoreUtils.allPromises(promises);\n      // Store the prefetch data in the list.\n      _this25.prefetchData[siteId] = _this25.prefetchData[siteId] || {};\n      _this25.prefetchData[siteId][id] = prefetchData;\n      try {\n        yield prefetchData.promise;\n      } finally {\n        // Unsubscribe all observers.\n        prefetchData.subscriptions.forEach(subscription => {\n          subscription.unsubscribe();\n        });\n        delete _this25.prefetchData[siteId][id];\n      }\n    })();\n  }\n  /**\n   * Remove module Files from handler.\n   *\n   * @param module Module to remove the files.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when done.\n   */\n  removeModuleFiles(module, courseId) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const handler = _this26.getPrefetchHandlerFor(module.modname);\n      const siteId = CoreSites.getCurrentSiteId();\n      if (handler !== null && handler !== void 0 && handler.removeFiles) {\n        // Handler implements a method to remove the files, use it.\n        yield handler.removeFiles(module, courseId);\n      } else {\n        // No method to remove files, use get files to try to remove the files.\n        const files = yield _this26.getModuleFiles(module, courseId);\n        yield Promise.all(files.map( /*#__PURE__*/function () {\n          var _ref7 = _asyncToGenerator(function* (file) {\n            yield CoreUtils.ignoreErrors(CoreFilepool.removeFileByUrl(siteId, CoreFileHelper.getFileUrl(file)));\n          });\n          return function (_x7) {\n            return _ref7.apply(this, arguments);\n          };\n        }()));\n      }\n      if (!handler) {\n        return;\n      }\n      // Update downloaded size.\n      const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n      _this26.statusCache.setValue(packageId, 'downloadedSize', 0);\n      // If module is downloadable, set not dowloaded status.\n      const downloadable = yield _this26.isModuleDownloadable(module, courseId);\n      if (!downloadable) {\n        return;\n      }\n      yield CoreFilepool.storePackageStatus(siteId, CoreConstants.NOT_DOWNLOADED, handler.component, module.id);\n    })();\n  }\n  /**\n   * Set an on progress function for the download of a list of modules.\n   *\n   * @param id An ID to identify the download.\n   * @param onProgress Function to call everytime a module is downloaded.\n   */\n  setOnProgress(id, onProgress) {\n    var _this$prefetchData$Co;\n    const currentData = (_this$prefetchData$Co = this.prefetchData[CoreSites.getCurrentSiteId()]) === null || _this$prefetchData$Co === void 0 ? void 0 : _this$prefetchData$Co[id];\n    if (currentData) {\n      // There's a prefetch ongoing, return the current promise.\n      currentData.subscriptions.push(currentData.observable.subscribe(onProgress));\n    }\n  }\n  /**\n   * If courseId or sectionId is set, save them in the cache.\n   *\n   * @param packageId The package ID.\n   * @param courseId Course ID.\n   * @param sectionId Section ID.\n   */\n  storeCourseAndSection(packageId, courseId, sectionId) {\n    if (courseId) {\n      this.statusCache.setValue(packageId, 'courseId', courseId);\n    }\n    if (sectionId && sectionId > 0) {\n      this.statusCache.setValue(packageId, 'sectionId', sectionId);\n    }\n  }\n  /**\n   * Treat the result of the check updates WS call.\n   *\n   * @param toCheckList List of modules to check (from createToCheckList).\n   * @param response WS call response.\n   * @param result Object where to store the result.\n   * @param previousTime Time of the previous check updates execution. If set, modules downloaded\n   *                     after this time will be ignored.\n   * @returns Result.\n   */\n  treatCheckUpdatesResult(toCheckList, response, result, previousTime) {\n    var _response$warnings;\n    // Format the response to index it by module ID.\n    CoreUtils.arrayToObject(response.instances, 'id', result);\n    // Treat warnings, adding the not supported modules.\n    (_response$warnings = response.warnings) === null || _response$warnings === void 0 || _response$warnings.forEach(warning => {\n      if (warning.warningcode == 'missingcallback') {\n        result[warning.itemid || -1] = false;\n      }\n    });\n    if (previousTime) {\n      // Remove from the list the modules downloaded after previousTime.\n      toCheckList.forEach(entry => {\n        if (result[entry.id] && entry.since > previousTime) {\n          delete result[entry.id];\n        }\n      });\n    }\n    return result;\n  }\n  /**\n   * Update the status of a module in the \"cache\".\n   *\n   * @param status New status.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param courseId Course ID of the module.\n   * @param sectionId Section ID of the module.\n   */\n  updateStatusCache(status, component, componentId, courseId, sectionId) {\n    const packageId = CoreFilepool.getPackageId(component, componentId);\n    const cachedStatus = this.statusCache.getValue(packageId, 'status', true);\n    // If courseId/sectionId is set, store it.\n    this.storeCourseAndSection(packageId, courseId, sectionId);\n    if (cachedStatus === undefined || cachedStatus === status) {\n      this.statusCache.setValue(packageId, 'status', status);\n      return;\n    }\n    // The status has changed, notify that the section has changed.\n    courseId = courseId || this.statusCache.getValue(packageId, 'courseId', true);\n    sectionId = sectionId || this.statusCache.getValue(packageId, 'sectionId', true);\n    // Invalidate and set again.\n    this.statusCache.invalidate(packageId);\n    this.statusCache.setValue(packageId, 'status', status);\n    if (courseId && sectionId) {\n      const data = {\n        sectionId,\n        courseId: courseId\n      };\n      CoreEvents.trigger(CoreEvents.SECTION_STATUS_CHANGED, data, CoreSites.getCurrentSiteId());\n    }\n  }\n}\n_class = CoreCourseModulePrefetchDelegateService;\n_class.ɵfac = function CoreCourseModulePrefetchDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCourseModulePrefetchDelegate = makeSingleton(CoreCourseModulePrefetchDelegateService);","map":{"version":3,"names":["BehaviorSubject","Md5","CoreFile","CoreFileHelper","CoreFilepool","CoreSites","CoreTimeUtils","CoreUtils","CoreCourse","CoreCache","CoreConstants","CoreDelegate","makeSingleton","CoreEvents","CoreError","CHECK_UPDATES_TIMES_TABLE","CoreCourseHelper","ROOT_CACHE_KEY","CoreCourseModulePrefetchDelegateService","constructor","statusCache","featurePrefix","handlerNameProperty","courseUpdatesPromises","prefetchData","initialize","on","LOGOUT","clearStatusCache","PACKAGE_STATUS_CHANGED","data","updateStatusCache","status","component","componentId","getCurrentSiteId","COMPONENT_FILE_ACTION","isFileEventDownloadedOrDeleted","invalidate","getPackageId","canModuleUseCheckUpdates","module","courseId","_this","_asyncToGenerator","handler","getPrefetchHandlerFor","modname","canUseCheckUpdates","clear","createToCheckList","modules","_this2","result","toCheck","cannotUse","promises","map","_ref","getModuleStatusAndDownloadTime","DOWNLOADED","canUse","push","contextlevel","id","since","downloadTime","_unused","_x","apply","arguments","Promise","all","sort","a","b","determineModuleStatus","siteId","DOWNLOADING","getPackageDownloadPromise","prefetch","course","determineStatus","downloadModule","dirPath","_this3","syncModule","download","getCourseUpdates","_this4","hashAsciiStr","JSON","stringify","undefined","fetchCourseUpdates","_this5","forEach","length","site","getSite","params","courseid","tocheck","preSets","cacheKey","getCourseUpdatesCacheKey","emergencyCache","uniqueCacheKey","splitRequest","param","maxLength","response","read","entry","time","timestamp","ignoreErrors","getDb","insertRecord","treatCheckUpdatesResult","error","getRecord","_unused2","getCacheUsingCacheKey","omitExpires","getCourseUpdatesByCourseId","_this6","sections","getSections","getSectionsModules","getDownloadSize","_this7","getModulesStatus","downloadableModules","NOT_DOWNLOADED","concat","OUTDATED","size","total","_ref2","getModuleDownloadSize","_x2","single","_this8","downloadable","isModuleDownloadable","packageId","downloadSize","getValue","setValue","cachedSize","getModuleDownloadedSize","_this9","downloadedSize","getDownloadedSize","files","getModuleFiles","_ref3","file","path","getFilePathByUrl","getFileUrl","fileSize","getFileSize","_unused3","isDownloading","isFileDownloadingByUrl","filesize","_x3","_unused4","getModuleStoredSize","_this10","getCurrentSite","getComponentCacheSize","totalSize","isNaN","_this11","getFiles","loadContents","contents","getModuleStatus","updates","refresh","sectionId","_this12","NOT_DOWNLOADABLE","storeCourseAndSection","calculateModuleStatus","updateStatus","_this13","currentStatus","getPackageStatus","_unused5","hasUpdates","moduleHasUpdates","storePackageStatus","_unused6","onlyToDisplay","checkUpdates","_this14","_unused7","_ref4","modStatus","determinePackagesStatus","cacheStatus","_x4","_this15","isStateDownloaded","getPackageData","_unused8","getModuleUpdates","ignoreCache","_this16","getModuleUpdatesCacheKey","getFromCache","instances","moduleId","moduleName","getHandler","invalidateCourseUpdates","_this17","invalidateWsCacheForKey","invalidateModules","_this18","_ref5","invalidateModule","invalidateModuleStatusCache","_x5","invalidateModuleUpdates","_this19","isBeingDownloaded","_this$prefetchData$si","_this20","canUserViewModule","isDownloadable","_unused9","_this21","_handler$updatesNames","moduleUpdates","updatesNames","test","i","len","name","prefetchModule","_this22","syncModules","_this23","_this24","sync","prefetchModules","onProgress","_this25","_this25$prefetchData$","currentPrefetchData","subscriptions","observable","subscribe","promise","count","moduleIds","resolve","_ref6","index","indexOf","splice","next","_x6","allPromises","subscription","unsubscribe","removeModuleFiles","_this26","removeFiles","_ref7","removeFileByUrl","_x7","setOnProgress","_this$prefetchData$Co","currentData","toCheckList","previousTime","_response$warnings","arrayToObject","warnings","warning","warningcode","itemid","cachedStatus","trigger","SECTION_STATUS_CHANGED","factory","ɵfac","providedIn","CoreCourseModulePrefetchDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/services/module-prefetch-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { Subject, BehaviorSubject, Subscription } from 'rxjs';\nimport { Md5 } from 'ts-md5/dist/md5';\n\nimport { CoreFile } from '@services/file';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourse, CoreCourseAnyModuleData, CoreCourseModuleContentFile } from './course';\nimport { CoreCache } from '@classes/cache';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents, CoreEventSectionStatusChangedData } from '@singletons/events';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSFile, CoreWSExternalWarning } from '@services/ws';\nimport { CHECK_UPDATES_TIMES_TABLE, CoreCourseCheckUpdatesDBRecord } from './database/module-prefetch';\nimport { CoreFileSizeSum } from '@services/plugin-file-delegate';\nimport { CoreCourseHelper, CoreCourseModuleData } from './course-helper';\n\nconst ROOT_CACHE_KEY = 'mmCourse:';\n\n/**\n * Delegate to register module prefetch handlers.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCourseModulePrefetchDelegateService extends CoreDelegate<CoreCourseModulePrefetchHandler> {\n\n    protected statusCache = new CoreCache();\n    protected featurePrefix = 'CoreCourseModuleDelegate_';\n    protected handlerNameProperty = 'modName';\n\n    // Promises for check updates, to prevent performing the same request twice at the same time.\n    protected courseUpdatesPromises: Record<string, Record<string, Promise<CourseUpdates>>> = {};\n\n    // Promises and observables for prefetching, to prevent downloading same section twice at the same time and notify progress.\n    protected prefetchData: Record<string, Record<string, OngoingPrefetch>> = {};\n\n    constructor() {\n        super('CoreCourseModulePrefetchDelegate', true);\n    }\n\n    /**\n     * Initialize.\n     */\n    initialize(): void {\n        CoreEvents.on(CoreEvents.LOGOUT, () => this.clearStatusCache());\n\n        CoreEvents.on(CoreEvents.PACKAGE_STATUS_CHANGED, (data) => {\n            this.updateStatusCache(data.status, data.component, data.componentId);\n        }, CoreSites.getCurrentSiteId());\n\n        // If a file inside a module is downloaded/deleted, clear the corresponding cache.\n        CoreEvents.on(CoreEvents.COMPONENT_FILE_ACTION, (data) => {\n            if (!CoreFilepool.isFileEventDownloadedOrDeleted(data)) {\n                return;\n            }\n\n            this.statusCache.invalidate(CoreFilepool.getPackageId(data.component, data.componentId));\n        }, CoreSites.getCurrentSiteId());\n    }\n\n    /**\n     * Check if a certain module can use core_course_check_updates.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved with boolean: whether the module can use check updates WS.\n     */\n    async canModuleUseCheckUpdates(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n\n        if (!handler) {\n            // Module not supported, cannot use check updates.\n            return false;\n        }\n\n        if (handler.canUseCheckUpdates) {\n            return handler.canUseCheckUpdates(module, courseId);\n        }\n\n        // By default, modules can use check updates.\n        return true;\n    }\n\n    /**\n     * Clear the status cache.\n     */\n    clearStatusCache(): void {\n        this.statusCache.clear();\n    }\n\n    /**\n     * Creates the list of modules to check for get course updates.\n     *\n     * @param modules List of modules.\n     * @param courseId Course ID the modules belong to.\n     * @returns Promise resolved with the lists.\n     */\n    protected async createToCheckList(modules: CoreCourseModuleData[], courseId: number): Promise<ToCheckList> {\n        const result: ToCheckList = {\n            toCheck: [],\n            cannotUse: [],\n        };\n\n        const promises = modules.map(async (module) => {\n            try {\n                const data = await this.getModuleStatusAndDownloadTime(module, courseId);\n                if (data.status != CoreConstants.DOWNLOADED) {\n                    return;\n                }\n\n                // Module is downloaded and not outdated. Check if it can check updates.\n                const canUse = await this.canModuleUseCheckUpdates(module, courseId);\n                if (canUse) {\n                    // Can use check updates, add it to the tocheck list.\n                    result.toCheck.push({\n                        contextlevel: 'module',\n                        id: module.id,\n                        since: data.downloadTime || 0,\n                    });\n                } else {\n                    // Cannot use check updates, add it to the cannotUse array.\n                    result.cannotUse.push(module);\n                }\n            } catch {\n                // Ignore errors.\n            }\n        });\n\n        await Promise.all(promises);\n\n        // Sort toCheck list.\n        result.toCheck.sort((a, b) => a.id >= b.id ? 1 : -1);\n\n        return result;\n    }\n\n    /**\n     * Determines a module status based on current status, restoring downloads if needed.\n     *\n     * @param module Module.\n     * @param status Current status.\n     * @returns Module status.\n     */\n    determineModuleStatus(module: CoreCourseAnyModuleData, status: string): string {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        const siteId = CoreSites.getCurrentSiteId();\n\n        if (!handler) {\n            return status;\n        }\n\n        if (status == CoreConstants.DOWNLOADING) {\n            // Check if the download is being handled.\n            if (!CoreFilepool.getPackageDownloadPromise(siteId, handler.component, module.id)) {\n                // Not handled, the app was probably restarted or something weird happened.\n                // Re-start download (files already on queue or already downloaded will be skipped).\n                handler.prefetch(module, module.course);\n            }\n        } else if (handler.determineStatus) {\n            // The handler implements a determineStatus function. Apply it.\n            return handler.determineStatus(module, status, true);\n        }\n\n        return status;\n    }\n\n    /**\n     * Download a module.\n     *\n     * @param module Module to download.\n     * @param courseId Course ID the module belongs to.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when finished.\n     */\n    async downloadModule(module: CoreCourseAnyModuleData, courseId: number, dirPath?: string): Promise<void> {\n        // Check if the module has a prefetch handler.\n        const handler = this.getPrefetchHandlerFor(module.modname);\n\n        if (!handler) {\n            return;\n        }\n\n        await this.syncModule(module, courseId);\n\n        await handler.download(module, courseId, dirPath);\n    }\n\n    /**\n     * Check for updates in a course.\n     *\n     * @param modules List of modules.\n     * @param courseId Course ID the modules belong to.\n     * @returns Promise resolved with the updates. If a module is set to false, it means updates cannot be\n     *         checked for that module in the current site.\n     */\n    async getCourseUpdates(modules: CoreCourseModuleData[], courseId: number): Promise<CourseUpdates> {\n        // Check if there's already a getCourseUpdates in progress.\n        const id = <string> Md5.hashAsciiStr(courseId + '#' + JSON.stringify(modules));\n        const siteId = CoreSites.getCurrentSiteId();\n\n        if (this.courseUpdatesPromises[siteId] && this.courseUpdatesPromises[siteId][id] !== undefined) {\n            // There's already a get updates ongoing, return the promise.\n            return this.courseUpdatesPromises[siteId][id];\n        } else if (!this.courseUpdatesPromises[siteId]) {\n            this.courseUpdatesPromises[siteId] = {};\n        }\n\n        this.courseUpdatesPromises[siteId][id] = this.fetchCourseUpdates(modules, courseId, siteId);\n\n        try {\n            return await this.courseUpdatesPromises[siteId][id];\n        } finally {\n            // Get updates finished, delete the promise.\n            delete this.courseUpdatesPromises[siteId][id];\n        }\n    }\n\n    /**\n     * Fetch updates in a course.\n     *\n     * @param modules List of modules.\n     * @param courseId Course ID the modules belong to.\n     * @param siteId Site ID.\n     * @returns Promise resolved with the updates. If a module is set to false, it means updates cannot be\n     *         checked for that module in the site.\n     */\n    protected async fetchCourseUpdates(\n        modules: CoreCourseModuleData[],\n        courseId: number,\n        siteId: string,\n    ): Promise<CourseUpdates> {\n        const data = await this.createToCheckList(modules, courseId);\n        const result: CourseUpdates = {};\n\n        // Mark as false the modules that cannot use check updates WS.\n        data.cannotUse.forEach((module) => {\n            result[module.id] = false;\n        });\n\n        if (!data.toCheck.length) {\n            // Nothing to check, no need to call the WS.\n            return result;\n        }\n\n        // Get the site, maybe the user changed site.\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreCourseCheckUpdatesWSParams = {\n            courseid: courseId,\n            tocheck: data.toCheck,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCourseUpdatesCacheKey(courseId),\n            emergencyCache: false, // If downloaded data has changed and offline, just fail. See MOBILE-2085.\n            uniqueCacheKey: true,\n            splitRequest: {\n                param: 'tocheck',\n                maxLength: 10,\n            },\n        };\n\n        try {\n            const response = await site.read<CoreCourseCheckUpdatesWSResponse>('core_course_check_updates', params, preSets);\n\n            // Store the last execution of the check updates call.\n            const entry: CoreCourseCheckUpdatesDBRecord = {\n                courseId: courseId,\n                time: CoreTimeUtils.timestamp(),\n            };\n            CoreUtils.ignoreErrors(site.getDb().insertRecord(CHECK_UPDATES_TIMES_TABLE, entry));\n\n            return this.treatCheckUpdatesResult(data.toCheck, response, result);\n        } catch (error) {\n            // Cannot get updates.\n            // Get cached entries but discard modules with a download time higher than the last execution of check updates.\n            let entry: CoreCourseCheckUpdatesDBRecord | undefined;\n            try {\n                entry = await site.getDb().getRecord<CoreCourseCheckUpdatesDBRecord>(\n                    CHECK_UPDATES_TIMES_TABLE,\n                    { courseId: courseId },\n                );\n            } catch {\n                // No previous executions, return result as it is.\n                return result;\n            }\n\n            preSets.getCacheUsingCacheKey = true;\n            preSets.omitExpires = true;\n\n            const response = await site.read<CoreCourseCheckUpdatesWSResponse>('core_course_check_updates', params, preSets);\n\n            return this.treatCheckUpdatesResult(data.toCheck, response, result, entry.time);\n        }\n    }\n\n    /**\n     * Check for updates in a course.\n     *\n     * @param courseId Course ID the modules belong to.\n     * @returns Promise resolved with the updates.\n     */\n    async getCourseUpdatesByCourseId(courseId: number): Promise<CourseUpdates> {\n        // Get course sections and all their modules.\n        const sections = await CoreCourse.getSections(courseId, false, true, { omitExpires: true });\n\n        return this.getCourseUpdates(CoreCourse.getSectionsModules(sections), courseId);\n    }\n\n    /**\n     * Get cache key for course updates WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getCourseUpdatesCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'courseUpdates:' + courseId;\n    }\n\n    /**\n     * Get modules download size. Only treat the modules with status not downloaded or outdated.\n     *\n     * @param modules List of modules.\n     * @param courseId Course ID the modules belong to.\n     * @returns Promise resolved with the size.\n     */\n    async getDownloadSize(modules: CoreCourseModuleData[], courseId: number): Promise<CoreFileSizeSum> {\n        // Get the status of each module.\n        const data = await this.getModulesStatus(modules, courseId);\n\n        const downloadableModules = data[CoreConstants.NOT_DOWNLOADED].concat(data[CoreConstants.OUTDATED]);\n        const result: CoreFileSizeSum = {\n            size: 0,\n            total: true,\n        };\n\n        await Promise.all(downloadableModules.map(async (module) => {\n            const size = await this.getModuleDownloadSize(module, courseId);\n\n            result.total = result.total && size.total;\n            result.size += size.size;\n        }));\n\n        return result;\n    }\n\n    /**\n     * Get the download size of a module.\n     *\n     * @param module Module to get size.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @returns Promise resolved with the size.\n     */\n    async getModuleDownloadSize(module: CoreCourseAnyModuleData, courseId: number, single?: boolean): Promise<CoreFileSizeSum> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n\n        if (!handler) {\n            return { size: 0, total: false };\n        }\n        const downloadable = await this.isModuleDownloadable(module, courseId);\n        if (!downloadable) {\n            return { size: 0, total: true };\n        }\n\n        const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n        const downloadSize = this.statusCache.getValue<CoreFileSizeSum>(packageId, 'downloadSize');\n        if (downloadSize !== undefined) {\n            return downloadSize;\n        }\n\n        try {\n            const size = await handler.getDownloadSize(module, courseId, single);\n\n            return this.statusCache.setValue(packageId, 'downloadSize', size);\n        } catch (error) {\n            const cachedSize = this.statusCache.getValue<CoreFileSizeSum>(packageId, 'downloadSize', true);\n            if (cachedSize) {\n                return cachedSize;\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Get the download size of a module.\n     *\n     * @param module Module to get size.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved with the size.\n     */\n    async getModuleDownloadedSize(module: CoreCourseAnyModuleData, courseId: number): Promise<number> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        if (!handler) {\n            return 0;\n        }\n\n        const downloadable = await this.isModuleDownloadable(module, courseId);\n        if (!downloadable) {\n            return 0;\n        }\n\n        const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n        const downloadedSize = this.statusCache.getValue<number>(packageId, 'downloadedSize');\n        if (downloadedSize !== undefined) {\n            return downloadedSize;\n        }\n\n        try {\n            let size = 0;\n\n            if (handler.getDownloadedSize) {\n                // Handler implements a method to calculate the downloaded size, use it.\n                size = await handler.getDownloadedSize(module, courseId);\n            } else {\n                // Handler doesn't implement it, get the module files and check if they're downloaded.\n                const files = await this.getModuleFiles(module, courseId);\n\n                const siteId = CoreSites.getCurrentSiteId();\n\n                // Retrieve file size if it's downloaded.\n                await Promise.all(files.map(async (file) => {\n                    const path = await CoreFilepool.getFilePathByUrl(siteId, CoreFileHelper.getFileUrl(file));\n\n                    try {\n                        const fileSize = await CoreFile.getFileSize(path);\n\n                        size += fileSize;\n                    } catch {\n                        // Error getting size. Check if the file is being downloaded.\n                        const isDownloading = await CoreFilepool.isFileDownloadingByUrl(siteId, CoreFileHelper.getFileUrl(file));\n                        if (isDownloading) {\n                            // If downloading, count as downloaded.\n                            size += file.filesize || 0;\n                        }\n                    }\n                }));\n            }\n\n            return this.statusCache.setValue(packageId, 'downloadedSize', size);\n        } catch {\n            return this.statusCache.getValue<number>(packageId, 'downloadedSize', true) || 0;\n        }\n    }\n\n    /**\n     * Gets the estimated total size of data stored for a module. This includes\n     * the files downloaded for it (getModuleDownloadedSize) and also the total\n     * size of web service requests stored for it.\n     *\n     * @param module Module to get the size.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved with the total size (0 if unknown)\n     */\n    async getModuleStoredSize(module: CoreCourseAnyModuleData, courseId: number): Promise<number> {\n        const site = CoreSites.getCurrentSite();\n        const handler = this.getPrefetchHandlerFor(module.modname);\n\n        const [downloadedSize, cachedSize] = await Promise.all([\n            this.getModuleDownloadedSize(module, courseId),\n            handler && site ? site.getComponentCacheSize(handler.component, module.id) : 0,\n        ]);\n\n        const totalSize = cachedSize + downloadedSize;\n\n        return isNaN(totalSize) ? 0 : totalSize;\n    }\n\n    /**\n     * Get module files.\n     *\n     * @param module Module to get the files.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved with the list of files.\n     */\n    async getModuleFiles(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n    ): Promise<(CoreWSFile | CoreCourseModuleContentFile)[]> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n\n        if (handler?.getFiles) {\n            // The handler defines a function to get files, use it.\n            return handler.getFiles(module, courseId);\n        } else if (handler?.loadContents) {\n            // The handler defines a function to load contents, use it before returning module contents.\n            await handler.loadContents(module, courseId);\n\n            return module.contents || [];\n        } else {\n            return module.contents || [];\n        }\n    }\n\n    /**\n     * Get the module status.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param updates Result of getCourseUpdates for all modules in the course. If not provided, it will be\n     *                calculated (slower). If it's false it means the site doesn't support check updates.\n     * @param refresh True if it should ignore the memory cache, not the WS cache.\n     * @param sectionId ID of the section the module belongs to.\n     * @returns Promise resolved with the status.\n     */\n    async getModuleStatus(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        updates?: CourseUpdates | false,\n        refresh?: boolean,\n        sectionId?: number,\n    ): Promise<string> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n\n        if (!handler) {\n            // No handler found, module not downloadable.\n            return CoreConstants.NOT_DOWNLOADABLE;\n        }\n\n        // Check if the status is cached.\n        const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n        const status = this.statusCache.getValue<string>(packageId, 'status');\n\n        if (!refresh && status !== undefined) {\n            this.storeCourseAndSection(packageId, courseId, sectionId);\n\n            return this.determineModuleStatus(module, status);\n        }\n\n        const result = await this.calculateModuleStatus(handler, module, courseId, updates, sectionId);\n        if (result.updateStatus) {\n            this.updateStatusCache(result.status, handler.component, module.id, courseId, sectionId);\n        }\n\n        return this.determineModuleStatus(module, result.status);\n    }\n\n    /**\n     * Calculate a module status.\n     *\n     * @param handler Prefetch handler.\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param updates Result of getCourseUpdates for all modules in the course. If not provided, it will be\n     *                calculated (slower). If it's false it means the site doesn't support check updates.\n     * @param sectionId ID of the section the module belongs to.\n     * @returns Promise resolved with the status.\n     */\n    protected async calculateModuleStatus(\n        handler: CoreCourseModulePrefetchHandler,\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        updates?: CourseUpdates | false,\n        sectionId?: number,\n    ): Promise<{status: string; updateStatus: boolean}> {\n        // Check if the module is downloadable.\n        const downloadable = await this.isModuleDownloadable(module, courseId);\n        if (!downloadable) {\n            return {\n                status: CoreConstants.NOT_DOWNLOADABLE,\n                updateStatus: true,\n            };\n        }\n\n        // Get the saved package status.\n        const siteId = CoreSites.getCurrentSiteId();\n        const currentStatus = await CoreFilepool.getPackageStatus(siteId, handler.component, module.id);\n\n        let status = handler.determineStatus ? handler.determineStatus(module, currentStatus, true) : currentStatus;\n        if (status != CoreConstants.DOWNLOADED || updates === false) {\n            return {\n                status,\n                updateStatus: true,\n            };\n        }\n\n        // Module is downloaded. Determine if there are updated in the module to show them outdated.\n        if (updates === undefined) {\n            try {\n                // We don't have course updates, calculate them.\n                updates = await this.getCourseUpdatesByCourseId(courseId);\n            } catch {\n                // Error getting updates, show the stored status.\n                const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n                this.storeCourseAndSection(packageId, courseId, sectionId);\n\n                return {\n                    status: currentStatus,\n                    updateStatus: false,\n                };\n            }\n        }\n\n        if (!updates || updates[module.id] === false) {\n            // Cannot check updates, always show outdated.\n            return {\n                status: CoreConstants.OUTDATED,\n                updateStatus: true,\n            };\n        }\n\n        try {\n            // Check if the module has any update.\n            const hasUpdates = await this.moduleHasUpdates(module, courseId, updates);\n\n            if (!hasUpdates) {\n                // No updates, keep current status.\n                return {\n                    status,\n                    updateStatus: true,\n                };\n            }\n\n            // Has updates, mark the module as outdated.\n            status = CoreConstants.OUTDATED;\n\n            await CoreUtils.ignoreErrors(\n                CoreFilepool.storePackageStatus(siteId, status, handler.component, module.id),\n            );\n\n            return {\n                status,\n                updateStatus: true,\n            };\n        } catch {\n            // Error checking if module has updates.\n            const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n            const status = this.statusCache.getValue<string>(packageId, 'status', true);\n\n            return {\n                status: this.determineModuleStatus(module, status || CoreConstants.NOT_DOWNLOADED),\n                updateStatus: true,\n            };\n        }\n    }\n\n    /**\n     * Get the status of a list of modules, along with the lists of modules for each status.\n     *\n     * @param modules List of modules to prefetch.\n     * @param courseId Course ID the modules belong to.\n     * @param sectionId ID of the section the modules belong to.\n     * @param refresh True if it should always check the DB (slower).\n     * @param onlyToDisplay True if the status will only be used to determine which button should be displayed.\n     * @param checkUpdates Whether to use the WS to check updates. Defaults to true.\n     * @returns Promise resolved with the data.\n     */\n    async getModulesStatus(\n        modules: CoreCourseModuleData[],\n        courseId: number,\n        sectionId?: number,\n        refresh?: boolean,\n        onlyToDisplay?: boolean,\n        checkUpdates: boolean = true,\n    ): Promise<CoreCourseModulesStatus> {\n\n        let updates: CourseUpdates | false = false;\n        const result: CoreCourseModulesStatus = {\n            total: 0,\n            status: CoreConstants.NOT_DOWNLOADABLE,\n            [CoreConstants.NOT_DOWNLOADED]: [],\n            [CoreConstants.DOWNLOADED]: [],\n            [CoreConstants.DOWNLOADING]: [],\n            [CoreConstants.OUTDATED]: [],\n        };\n\n        if (checkUpdates) {\n            // Check updates in course. Don't use getCourseUpdates because the list of modules might not be the whole course list.\n            try {\n                updates = await this.getCourseUpdatesByCourseId(courseId);\n            } catch {\n                // Cannot get updates.\n            }\n        }\n\n        await Promise.all(modules.map(async (module) => {\n            const handler = this.getPrefetchHandlerFor(module.modname);\n\n            if (!handler) {\n                return;\n            }\n\n            try {\n                const modStatus = await this.getModuleStatus(module, courseId, updates, refresh);\n\n                if (!result[modStatus]) {\n                    return;\n                }\n\n                result.status = CoreFilepool.determinePackagesStatus(result.status, modStatus);\n                result[modStatus].push(module);\n                result.total++;\n            } catch (error) {\n                const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n                const cacheStatus = this.statusCache.getValue<string>(packageId, 'status', true);\n                if (cacheStatus === undefined) {\n                    throw error;\n                }\n\n                if (!result[cacheStatus]) {\n                    return;\n                }\n\n                result.status = CoreFilepool.determinePackagesStatus(result.status, cacheStatus);\n                result[cacheStatus].push(module);\n                result.total++;\n            }\n        }));\n\n        return result;\n    }\n\n    /**\n     * Get a module status and download time. It will only return the download time if the module is downloaded or outdated.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved with the data.\n     */\n    protected async getModuleStatusAndDownloadTime(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n    ): Promise<{ status: string; downloadTime?: number }> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        const siteId = CoreSites.getCurrentSiteId();\n\n        if (!handler) {\n            // No handler found, module not downloadable.\n            return { status: CoreConstants.NOT_DOWNLOADABLE };\n        }\n\n        // Get the status from the cache.\n        const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n        const status = this.statusCache.getValue<string>(packageId, 'status');\n\n        if (status !== undefined && !CoreFileHelper.isStateDownloaded(status)) {\n            // Module isn't downloaded, just return the status.\n            return { status };\n        }\n\n        // Check if the module is downloadable.\n        const downloadable = await this.isModuleDownloadable(module, courseId);\n        if (!downloadable) {\n            return { status: CoreConstants.NOT_DOWNLOADABLE };\n        }\n\n        try {\n            // Get the stored data to get the status and downloadTime.\n            const data = await CoreFilepool.getPackageData(siteId, handler.component, module.id);\n\n            return {\n                status: data.status || CoreConstants.NOT_DOWNLOADED,\n                downloadTime: data.downloadTime || 0,\n            };\n        } catch {\n            return { status: CoreConstants.NOT_DOWNLOADED };\n        }\n    }\n\n    /**\n     * Get updates for a certain module.\n     * It will only return the updates if the module can use check updates and it's downloaded or outdated.\n     *\n     * @param module Module to check.\n     * @param courseId Course the module belongs to.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the updates.\n     */\n    async getModuleUpdates(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        ignoreCache?: boolean,\n        siteId?: string,\n    ): Promise<CheckUpdatesWSInstance | null> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const data = await this.getModuleStatusAndDownloadTime(module, courseId);\n        if (!CoreFileHelper.isStateDownloaded(data.status)) {\n            // Not downloaded, no updates.\n            return null;\n        }\n\n        // Module is downloaded. Check if it can check updates.\n        const canUse = await this.canModuleUseCheckUpdates(module, courseId);\n        if (!canUse) {\n            // Can't use check updates, no updates.\n            return null;\n        }\n\n        const params: CoreCourseCheckUpdatesWSParams = {\n            courseid: courseId,\n            tocheck: [\n                {\n                    contextlevel: 'module',\n                    id: module.id,\n                    since: data.downloadTime || 0,\n                },\n            ],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getModuleUpdatesCacheKey(courseId, module.id),\n        };\n\n        if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        const response = await site.read<CoreCourseCheckUpdatesWSResponse>('core_course_check_updates', params, preSets);\n        if (!response.instances[0]) {\n            throw new CoreError('Could not get module updates.');\n        }\n\n        return response.instances[0];\n    }\n\n    /**\n     * Get cache key for module updates WS calls.\n     *\n     * @param courseId Course ID.\n     * @param moduleId Module ID.\n     * @returns Cache key.\n     */\n    protected getModuleUpdatesCacheKey(courseId: number, moduleId: number): string {\n        return this.getCourseUpdatesCacheKey(courseId) + ':' + moduleId;\n    }\n\n    /**\n     * Get a prefetch handler.\n     *\n     * @param moduleName The module name to work on.\n     * @returns Prefetch handler.\n     */\n    getPrefetchHandlerFor(moduleName: string): CoreCourseModulePrefetchHandler | undefined {\n        return this.getHandler(moduleName, true);\n    }\n\n    /**\n     * Invalidate check updates WS call.\n     *\n     * @param courseId Course ID.\n     * @returns Promise resolved when data is invalidated.\n     */\n    async invalidateCourseUpdates(courseId: number): Promise<void> {\n        const site = CoreSites.getCurrentSite();\n        if (!site) {\n            return;\n        }\n\n        await site.invalidateWsCacheForKey(this.getCourseUpdatesCacheKey(courseId));\n    }\n\n    /**\n     * Invalidate a list of modules in a course. This should only invalidate WS calls, not downloaded files.\n     *\n     * @param modules List of modules.\n     * @param courseId Course ID.\n     * @returns Promise resolved when modules are invalidated.\n     */\n    async invalidateModules(modules: CoreCourseModuleData[], courseId: number): Promise<void> {\n\n        const promises = modules.map(async (module) => {\n            const handler = this.getPrefetchHandlerFor(module.modname);\n            if (!handler) {\n                return;\n            }\n\n            if (handler.invalidateModule) {\n                await CoreUtils.ignoreErrors(handler.invalidateModule(module, courseId));\n            }\n\n            // Invalidate cache.\n            this.invalidateModuleStatusCache(module);\n        });\n\n        promises.push(this.invalidateCourseUpdates(courseId));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidates the cache for a given module.\n     *\n     * @param module Module to be invalidated.\n     */\n    invalidateModuleStatusCache(module: CoreCourseAnyModuleData): void {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        if (handler) {\n            this.statusCache.invalidate(CoreFilepool.getPackageId(handler.component, module.id));\n        }\n    }\n\n    /**\n     * Invalidate check updates WS call for a certain module.\n     *\n     * @param courseId Course ID.\n     * @param moduleId Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data is invalidated.\n     */\n    async invalidateModuleUpdates(courseId: number, moduleId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getModuleUpdatesCacheKey(courseId, moduleId));\n    }\n\n    /**\n     * Check if a list of modules is being downloaded.\n     *\n     * @param id An ID to identify the download.\n     * @returns True if it's being downloaded, false otherwise.\n     */\n    isBeingDownloaded(id: string): boolean {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        return !!(this.prefetchData[siteId]?.[id]);\n    }\n\n    /**\n     * Check if a module is downloadable.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved with true if downloadable, false otherwise.\n     */\n    async isModuleDownloadable(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        if ('uservisible' in module && !CoreCourseHelper.canUserViewModule(module)) {\n            // Module isn't visible by the user, cannot be downloaded.\n            return false;\n        }\n\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        if (!handler) {\n            return false;\n        }\n\n        if (!handler.isDownloadable) {\n            // Function not defined, assume it's downloadable.\n            return true;\n        }\n\n        const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n        let downloadable = this.statusCache.getValue<boolean>(packageId, 'downloadable');\n\n        if (downloadable !== undefined) {\n            return downloadable;\n        }\n\n        try {\n            downloadable = await handler.isDownloadable(module, courseId);\n\n            return this.statusCache.setValue(packageId, 'downloadable', downloadable);\n        } catch {\n            // Something went wrong, assume it's not downloadable.\n            return false;\n        }\n    }\n\n    /**\n     * Check if a module has updates based on the result of getCourseUpdates.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param updates Result of getCourseUpdates.\n     * @returns Promise resolved with boolean: whether the module has updates.\n     */\n    async moduleHasUpdates(module: CoreCourseAnyModuleData, courseId: number, updates: CourseUpdates): Promise<boolean> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        const moduleUpdates = updates[module.id];\n\n        if (handler?.hasUpdates) {\n            // Handler implements its own function to check the updates, use it.\n            return handler.hasUpdates(module, courseId, moduleUpdates);\n        } else if (!moduleUpdates || !moduleUpdates.updates || !moduleUpdates.updates.length) {\n            // Module doesn't have any update.\n            return false;\n        } else if (handler?.updatesNames?.test) {\n            // Check the update names defined by the handler.\n            for (let i = 0, len = moduleUpdates.updates.length; i < len; i++) {\n                if (handler.updatesNames.test(moduleUpdates.updates[i].name)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // Handler doesn't define hasUpdates or updatesNames and there is at least 1 update. Assume it has updates.\n        return true;\n    }\n\n    /**\n     * Prefetch a module.\n     *\n     * @param module Module to prefetch.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @returns Promise resolved when finished.\n     */\n    async prefetchModule(module: CoreCourseAnyModuleData, courseId: number, single?: boolean): Promise<void> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        if (!handler) {\n            return;\n        }\n\n        await this.syncModule(module, courseId);\n\n        await handler.prefetch(module, courseId, single);\n    }\n\n    /**\n     * Sync a group of modules.\n     *\n     * @param modules Array of modules to sync.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when finished.\n     */\n    async syncModules(modules: CoreCourseModuleData[], courseId: number): Promise<void> {\n        try {\n            await Promise.all(modules.map((module) => this.syncModule(module, courseId)));\n        } finally {\n            // Invalidate course updates.\n            await CoreUtils.ignoreErrors(this.invalidateCourseUpdates(courseId));\n        }\n    }\n\n    /**\n     * Sync a module.\n     *\n     * @param module Module to sync.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when finished.\n     */\n    async syncModule<T = unknown>(module: CoreCourseAnyModuleData, courseId: number): Promise<T | undefined> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        if (!handler?.sync) {\n            return;\n        }\n\n        const result = await CoreUtils.ignoreErrors(handler.sync(module, courseId));\n\n        // Always invalidate status cache for this module. We cannot know if data was sent to server or not.\n        this.invalidateModuleStatusCache(module);\n\n        return <T> result;\n    }\n\n    /**\n     * Prefetches a list of modules using their prefetch handlers.\n     * If a prefetch already exists for this site and id, returns the current promise.\n     *\n     * @param id An ID to identify the download. It can be used to retrieve the download promise.\n     * @param modules List of modules to prefetch.\n     * @param courseId Course ID the modules belong to.\n     * @param onProgress Function to call everytime a module is downloaded.\n     * @returns Promise resolved when all modules have been prefetched.\n     */\n    async prefetchModules(\n        id: string,\n        modules: CoreCourseModuleData[],\n        courseId: number,\n        onProgress?: CoreCourseModulesProgressFunction,\n    ): Promise<void> {\n\n        const siteId = CoreSites.getCurrentSiteId();\n        const currentPrefetchData = this.prefetchData[siteId]?.[id];\n\n        if (currentPrefetchData) {\n            // There's a prefetch ongoing, return the current promise.\n            if (onProgress) {\n                currentPrefetchData.subscriptions.push(currentPrefetchData.observable.subscribe(onProgress));\n            }\n\n            return currentPrefetchData.promise;\n        }\n\n        let count = 0;\n        const total = modules.length;\n        const moduleIds = modules.map((module) => module.id);\n        const prefetchData: OngoingPrefetch = {\n            observable: new BehaviorSubject<CoreCourseModulesProgress>({ count: count, total: total }),\n            promise: Promise.resolve(),\n            subscriptions: [],\n        };\n\n        if (onProgress) {\n            prefetchData.observable.subscribe(onProgress);\n        }\n\n        const promises = modules.map(async (module) => {\n            // Check if the module has a prefetch handler.\n            const handler = this.getPrefetchHandlerFor(module.modname);\n            if (!handler) {\n                return;\n            }\n\n            const downloadable = await this.isModuleDownloadable(module, courseId);\n            if (!downloadable) {\n                return;\n            }\n\n            await handler.prefetch(module, courseId);\n\n            const index = moduleIds.indexOf(module.id);\n            if (index > -1) {\n                moduleIds.splice(index, 1);\n                count++;\n                prefetchData.observable.next({ count: count, total: total });\n            }\n        });\n\n        // Set the promise.\n        prefetchData.promise = CoreUtils.allPromises(promises);\n\n        // Store the prefetch data in the list.\n        this.prefetchData[siteId] = this.prefetchData[siteId] || {};\n        this.prefetchData[siteId][id] = prefetchData;\n\n        try {\n            await prefetchData.promise;\n        } finally {\n            // Unsubscribe all observers.\n            prefetchData.subscriptions.forEach((subscription) => {\n                subscription.unsubscribe();\n            });\n            delete this.prefetchData[siteId][id];\n        }\n    }\n\n    /**\n     * Remove module Files from handler.\n     *\n     * @param module Module to remove the files.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when done.\n     */\n    async removeModuleFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        const handler = this.getPrefetchHandlerFor(module.modname);\n        const siteId = CoreSites.getCurrentSiteId();\n\n        if (handler?.removeFiles) {\n            // Handler implements a method to remove the files, use it.\n            await handler.removeFiles(module, courseId);\n        } else {\n            // No method to remove files, use get files to try to remove the files.\n            const files = await this.getModuleFiles(module, courseId);\n\n            await Promise.all(files.map(async (file) => {\n                await CoreUtils.ignoreErrors(CoreFilepool.removeFileByUrl(siteId, CoreFileHelper.getFileUrl(file)));\n            }));\n        }\n\n        if (!handler) {\n            return;\n        }\n\n        // Update downloaded size.\n        const packageId = CoreFilepool.getPackageId(handler.component, module.id);\n        this.statusCache.setValue(packageId, 'downloadedSize', 0);\n\n        // If module is downloadable, set not dowloaded status.\n        const downloadable = await this.isModuleDownloadable(module, courseId);\n        if (!downloadable) {\n            return;\n        }\n\n        await CoreFilepool.storePackageStatus(siteId, CoreConstants.NOT_DOWNLOADED, handler.component, module.id);\n    }\n\n    /**\n     * Set an on progress function for the download of a list of modules.\n     *\n     * @param id An ID to identify the download.\n     * @param onProgress Function to call everytime a module is downloaded.\n     */\n    setOnProgress(id: string, onProgress: CoreCourseModulesProgressFunction): void {\n        const currentData = this.prefetchData[CoreSites.getCurrentSiteId()]?.[id];\n\n        if (currentData) {\n            // There's a prefetch ongoing, return the current promise.\n            currentData.subscriptions.push(currentData.observable.subscribe(onProgress));\n        }\n    }\n\n    /**\n     * If courseId or sectionId is set, save them in the cache.\n     *\n     * @param packageId The package ID.\n     * @param courseId Course ID.\n     * @param sectionId Section ID.\n     */\n    storeCourseAndSection(packageId: string, courseId?: number, sectionId?: number): void {\n        if (courseId) {\n            this.statusCache.setValue(packageId, 'courseId', courseId);\n        }\n        if (sectionId && sectionId > 0) {\n            this.statusCache.setValue(packageId, 'sectionId', sectionId);\n        }\n    }\n\n    /**\n     * Treat the result of the check updates WS call.\n     *\n     * @param toCheckList List of modules to check (from createToCheckList).\n     * @param response WS call response.\n     * @param result Object where to store the result.\n     * @param previousTime Time of the previous check updates execution. If set, modules downloaded\n     *                     after this time will be ignored.\n     * @returns Result.\n     */\n    protected treatCheckUpdatesResult(\n        toCheckList: CheckUpdatesToCheckWSParam[],\n        response: CoreCourseCheckUpdatesWSResponse,\n        result: CourseUpdates,\n        previousTime?: number,\n    ): CourseUpdates {\n        // Format the response to index it by module ID.\n        CoreUtils.arrayToObject<false | CheckUpdatesWSInstance>(response.instances, 'id', result);\n\n        // Treat warnings, adding the not supported modules.\n        response.warnings?.forEach((warning) => {\n            if (warning.warningcode == 'missingcallback') {\n                result[warning.itemid || -1] = false;\n            }\n        });\n\n        if (previousTime) {\n            // Remove from the list the modules downloaded after previousTime.\n            toCheckList.forEach((entry) => {\n                if (result[entry.id] && entry.since > previousTime) {\n                    delete result[entry.id];\n                }\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Update the status of a module in the \"cache\".\n     *\n     * @param status New status.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param courseId Course ID of the module.\n     * @param sectionId Section ID of the module.\n     */\n    updateStatusCache(\n        status: string,\n        component: string,\n        componentId?: string | number,\n        courseId?: number,\n        sectionId?: number,\n    ): void {\n        const packageId = CoreFilepool.getPackageId(component, componentId);\n        const cachedStatus = this.statusCache.getValue<string>(packageId, 'status', true);\n\n        // If courseId/sectionId is set, store it.\n        this.storeCourseAndSection(packageId, courseId, sectionId);\n\n        if (cachedStatus === undefined || cachedStatus === status) {\n            this.statusCache.setValue(packageId, 'status', status);\n\n            return;\n        }\n\n        // The status has changed, notify that the section has changed.\n        courseId = courseId || this.statusCache.getValue(packageId, 'courseId', true);\n        sectionId = sectionId || this.statusCache.getValue(packageId, 'sectionId', true);\n\n        // Invalidate and set again.\n        this.statusCache.invalidate(packageId);\n        this.statusCache.setValue(packageId, 'status', status);\n\n        if (courseId && sectionId) {\n            const data: CoreEventSectionStatusChangedData = {\n                sectionId,\n                courseId: courseId,\n            };\n            CoreEvents.trigger(CoreEvents.SECTION_STATUS_CHANGED, data, CoreSites.getCurrentSiteId());\n        }\n    }\n\n}\n\nexport const CoreCourseModulePrefetchDelegate = makeSingleton(CoreCourseModulePrefetchDelegateService);\n\n/**\n * Progress of downloading a list of modules.\n */\nexport type CoreCourseModulesProgress = {\n    /**\n     * Number of modules downloaded so far.\n     */\n    count: number;\n\n    /**\n     * Toal of modules to download.\n     */\n    total: number;\n};\n\n/**\n * Progress function for downloading a list of modules.\n *\n * @param data Progress data.\n */\nexport type CoreCourseModulesProgressFunction = (data: CoreCourseModulesProgress) => void;\n\n/**\n * Interface that all course prefetch handlers must implement.\n */\nexport interface CoreCourseModulePrefetchHandler extends CoreDelegateHandler {\n    /**\n     * Name of the handler.\n     */\n    name: string;\n\n    /**\n     * Name of the module. It should match the \"modname\" of the module returned in core_course_get_contents.\n     */\n    modName: string;\n\n    /**\n     * The handler's component.\n     */\n    component: string;\n\n    /**\n     * The RegExp to check updates. If a module has an update whose name matches this RegExp, the module will be marked\n     * as outdated. This RegExp is ignored if hasUpdates function is defined.\n     */\n    updatesNames?: RegExp;\n\n    /**\n     * Get the download size of a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @returns Promise resolved with the size.\n     */\n    getDownloadSize(module: CoreCourseAnyModuleData, courseId: number, single?: boolean): Promise<CoreFileSizeSum>;\n\n    /**\n     * Prefetch a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when done.\n     */\n    prefetch(module: CoreCourseAnyModuleData, courseId: number, single?: boolean, dirPath?: string): Promise<void>;\n\n    /**\n     * Download the module.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when all content is downloaded.\n     */\n    download(module: CoreCourseAnyModuleData, courseId: number, dirPath?: string): Promise<void>;\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    invalidateContent(moduleId: number, courseId: number): Promise<void>;\n\n    /**\n     * Check if a certain module can use core_course_check_updates to check if it has updates.\n     * If not defined, it will assume all modules can be checked.\n     * The modules that return false will always be shown as outdated when they're downloaded.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Whether the module can use check_updates. The promise should never be rejected.\n     */\n    canUseCheckUpdates?(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean>;\n\n    /**\n     * Return the status to show based on current status. E.g. a module might want to show outdated instead of downloaded.\n     * If not implemented, the original status will be returned.\n     *\n     * @param module Module.\n     * @param status The current status.\n     * @param canCheck Whether the site allows checking for updates. This parameter was deprecated since app 4.0.\n     * @returns Status to display.\n     */\n    determineStatus?(module: CoreCourseAnyModuleData, status: string, canCheck: true): string;\n\n    /**\n     * Get the downloaded size of a module. If not defined, we'll use getFiles to calculate it (it can be slow).\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Size, or promise resolved with the size.\n     */\n    getDownloadedSize?(module: CoreCourseAnyModuleData, courseId: number): Promise<number>;\n\n    /**\n     * Get the list of files of the module. If not defined, we'll assume they are in module.contents.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns List of files, or promise resolved with the files.\n     */\n    getFiles?(module: CoreCourseAnyModuleData, courseId: number): Promise<(CoreWSFile | CoreCourseModuleContentFile)[]>;\n\n    /**\n     * Check if a certain module has updates based on the result of check updates.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param moduleUpdates List of updates for the module.\n     * @returns Whether the module has updates. The promise should never be rejected.\n     */\n    hasUpdates?(module: CoreCourseAnyModuleData, courseId: number, moduleUpdates: false | CheckUpdatesWSInstance): Promise<boolean>;\n\n    /**\n     * Invalidate WS calls needed to determine module status (usually, to check if module is downloadable).\n     * It doesn't need to invalidate check updates. It should NOT invalidate files nor all the prefetched data.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when invalidated.\n     */\n    invalidateModule?(module: CoreCourseAnyModuleData, courseId: number): Promise<void>;\n\n    /**\n     * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Whether the module can be downloaded. The promise should never be rejected.\n     */\n    isDownloadable?(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean>;\n\n    /**\n     * Load module contents in module.contents if they aren't loaded already. This is meant for resources.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when done.\n     */\n    loadContents?(module: CoreCourseAnyModuleData, courseId: number): Promise<void>;\n\n    /**\n     * Remove module downloaded files. If not defined, we'll use getFiles to remove them (slow).\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when done.\n     */\n    removeFiles?(module: CoreCourseAnyModuleData, courseId: number): Promise<void>;\n\n    /**\n     * Sync a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    sync?(module: CoreCourseAnyModuleData, courseId: number, siteId?: string): Promise<unknown>;\n}\n\ntype ToCheckList = {\n    toCheck: CheckUpdatesToCheckWSParam[];\n    cannotUse: CoreCourseModuleData[];\n};\n\n/**\n * Course updates.\n */\ntype CourseUpdates = Record<number, false | CheckUpdatesWSInstance>;\n\n/**\n * Status data about a list of modules.\n */\nexport type CoreCourseModulesStatus = {\n    total: number; // Number of modules.\n    status: string; // Status of the list of modules.\n    [CoreConstants.NOT_DOWNLOADED]: CoreCourseModuleData[]; // Modules with state NOT_DOWNLOADED.\n    [CoreConstants.DOWNLOADED]: CoreCourseModuleData[]; // Modules with state DOWNLOADED.\n    [CoreConstants.DOWNLOADING]: CoreCourseModuleData[]; // Modules with state DOWNLOADING.\n    [CoreConstants.OUTDATED]: CoreCourseModuleData[]; // Modules with state OUTDATED.\n};\n\n/**\n * Data for an ongoing module prefetch.\n */\ntype OngoingPrefetch = {\n    promise: Promise<void>; // Prefetch promise.\n    observable: Subject<CoreCourseModulesProgress>; // Observable to notify the download progress.\n    subscriptions: Subscription[]; // Subscriptions that are currently listening the progress.\n};\n\n/**\n * Params of core_course_check_updates WS.\n */\nexport type CoreCourseCheckUpdatesWSParams = {\n    courseid: number; // Course id to check.\n    tocheck: CheckUpdatesToCheckWSParam[]; // Instances to check.\n    filter?: string[]; // Check only for updates in these areas.\n};\n\n/**\n * Data to send in tocheck parameter.\n */\ntype CheckUpdatesToCheckWSParam = {\n    contextlevel: string; // The context level for the file location. Only module supported right now.\n    id: number; // Context instance id.\n    since: number; // Check updates since this time stamp.\n};\n\n/**\n * Data returned by core_course_check_updates WS.\n */\nexport type CoreCourseCheckUpdatesWSResponse = {\n    instances: CheckUpdatesWSInstance[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Instance data returned by the WS.\n */\ntype CheckUpdatesWSInstance = {\n    contextlevel: string; // The context level.\n    id: number; // Instance id.\n    updates: {\n        name: string; // Name of the area updated.\n        timeupdated?: number; // Last time was updated.\n        itemids?: number[]; // The ids of the items updated.\n    }[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}