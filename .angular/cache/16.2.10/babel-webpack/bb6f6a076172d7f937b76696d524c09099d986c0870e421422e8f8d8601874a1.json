{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreFileUploader } from '@features/fileuploader/services/fileuploader';\nimport { CoreQuestion } from '@features/question/services/question';\nimport { CoreQuestionHelper } from '@features/question/services/question-helper';\nimport { CoreFileSession } from '@services/file-session';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonQtypeEssayComponent } from '../../component/essay';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to support essay question type.\n */\nexport class AddonQtypeEssayHandlerService {\n  constructor() {\n    this.name = 'AddonQtypeEssay';\n    this.type = 'qtype_essay';\n  }\n  /**\n   * @inheritdoc\n   */\n  clearTmpData(question, component, componentId) {\n    const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n    const files = CoreFileSession.getFiles(component, questionComponentId);\n    // Clear the files in session for this question.\n    CoreFileSession.clearFiles(component, questionComponentId);\n    // Now delete the local files from the tmp folder.\n    CoreFileUploader.clearTmpFiles(files);\n  }\n  /**\n   * @inheritdoc\n   */\n  deleteOfflineData(question, component, componentId, siteId) {\n    return CoreQuestionHelper.deleteStoredQuestionFiles(question, component, componentId, siteId);\n  }\n  /**\n   * @inheritdoc\n   */\n  getAdditionalDownloadableFiles(question) {\n    if (!question.responsefileareas) {\n      return [];\n    }\n    return question.responsefileareas.reduce((urlsList, area) => urlsList.concat(area.files || []), []);\n  }\n  /**\n   * Check whether the question allows text and/or attachments.\n   *\n   * @param question Question to check.\n   * @returns Allowed options.\n   */\n  getAllowedOptions(question) {\n    if (question.parsedSettings) {\n      return {\n        text: question.parsedSettings.responseformat != 'noinline',\n        attachments: question.parsedSettings.attachments != '0'\n      };\n    }\n    const element = CoreDomUtils.convertToElement(question.html);\n    return {\n      text: !!element.querySelector('textarea[name*=_answer]'),\n      attachments: !!element.querySelector('div[id*=filemanager]')\n    };\n  }\n  /**\n   * @inheritdoc\n   */\n  getBehaviour() {\n    return 'manualgraded';\n  }\n  /**\n   * @inheritdoc\n   */\n  getComponent() {\n    return AddonQtypeEssayComponent;\n  }\n  /**\n   * @inheritdoc\n   */\n  getPreventSubmitMessage(question) {\n    const element = CoreDomUtils.convertToElement(question.html);\n    const uploadFilesSupported = question.responsefileareas !== undefined;\n    if (!uploadFilesSupported && element.querySelector('div[id*=filemanager]')) {\n      // The question allows attachments. Since the app cannot attach files yet we will prevent submitting the question.\n      return 'core.question.errorattachmentsnotsupportedinsite';\n    }\n    if (!uploadFilesSupported && CoreQuestionHelper.hasDraftFileUrls(element.innerHTML)) {\n      return 'core.question.errorembeddedfilesnotsupportedinsite';\n    }\n  }\n  /**\n   * @inheritdoc\n   */\n  getValidationError(question, answers, onlineError) {\n    if (answers.answer === undefined) {\n      // Not answered in offline.\n      return onlineError;\n    }\n    if (!answers.answer) {\n      // Not answered yet, no error.\n      return;\n    }\n    return this.checkInputWordCount(question, answers.answer, onlineError);\n  }\n  /**\n   * Check the input word count and return a message to user when the number of words are outside the boundary settings.\n   *\n   * @param question The question.\n   * @param answer Object with the question answers (without prefix).\n   * @param onlineError Online validation error.\n   * @returns Error message if there's a validation error, undefined otherwise.\n   */\n  checkInputWordCount(question, answer, onlineError) {\n    if (!question.parsedSettings || question.parsedSettings.maxwordlimit === undefined || question.parsedSettings.minwordlimit === undefined) {\n      // Min/max not supported, use online error.\n      return onlineError;\n    }\n    const minWords = Number(question.parsedSettings.minwordlimit);\n    const maxWords = Number(question.parsedSettings.maxwordlimit);\n    if (!maxWords && !minWords) {\n      // No min and max, no error.\n      return;\n    }\n    // Count the number of words in the response string.\n    const count = CoreTextUtils.countWords(answer);\n    if (maxWords && count > maxWords) {\n      return Translate.instant('addon.qtype_essay.maxwordlimitboundary', {\n        $a: {\n          limit: maxWords,\n          count: count\n        }\n      });\n    } else if (count < minWords) {\n      return Translate.instant('addon.qtype_essay.minwordlimitboundary', {\n        $a: {\n          limit: minWords,\n          count: count\n        }\n      });\n    }\n  }\n  /**\n   * @inheritdoc\n   */\n  isCompleteResponse(question, answers, component, componentId) {\n    const hasTextAnswer = !!answers.answer;\n    const uploadFilesSupported = question.responsefileareas !== undefined;\n    const allowedOptions = this.getAllowedOptions(question);\n    if (hasTextAnswer && this.checkInputWordCount(question, answers.answer, undefined)) {\n      return 0;\n    }\n    if (!allowedOptions.attachments) {\n      return hasTextAnswer ? 1 : 0;\n    }\n    if (!uploadFilesSupported || !question.parsedSettings) {\n      // We can't know if the attachments are required or if the user added any in web.\n      return -1;\n    }\n    const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n    const attachments = CoreFileSession.getFiles(component, questionComponentId);\n    if (!allowedOptions.text) {\n      return attachments && attachments.length >= Number(question.parsedSettings.attachmentsrequired) ? 1 : 0;\n    }\n    return (hasTextAnswer || question.parsedSettings.responserequired == '0') && attachments && attachments.length >= Number(question.parsedSettings.attachmentsrequired) ? 1 : 0;\n  }\n  /**\n   * @inheritdoc\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  isGradableResponse(question, answers, component, componentId) {\n    if (question.responsefileareas === undefined) {\n      return -1;\n    }\n    const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n    const attachments = CoreFileSession.getFiles(component, questionComponentId);\n    // Determine if the given response has online text or attachments.\n    return answers.answer && answers.answer !== '' || attachments && attachments.length > 0 ? 1 : 0;\n  }\n  /**\n   * @inheritdoc\n   */\n  isSameResponse(question, prevAnswers, newAnswers, component, componentId) {\n    const uploadFilesSupported = question.responsefileareas !== undefined;\n    const allowedOptions = this.getAllowedOptions(question);\n    // First check the inline text.\n    const answerIsEqual = allowedOptions.text ? CoreUtils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer') : true;\n    if (!allowedOptions.attachments || !uploadFilesSupported || !answerIsEqual) {\n      // No need to check attachments.\n      return answerIsEqual;\n    }\n    // Check attachments now.\n    const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n    const attachments = CoreFileSession.getFiles(component, questionComponentId);\n    const originalAttachments = CoreQuestionHelper.getResponseFileAreaFiles(question, 'attachments');\n    return !CoreFileUploader.areFileListDifferent(attachments, originalAttachments);\n  }\n  /**\n   * @inheritdoc\n   */\n  prepareAnswers(question, answers, offline, component, componentId, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const element = CoreDomUtils.convertToElement(question.html);\n      const attachmentsInput = element.querySelector('.attachments input[name*=_attachments]');\n      // Search the textarea to get its name.\n      const textarea = element.querySelector('textarea[name*=_answer]');\n      if (textarea && answers[textarea.name] !== undefined) {\n        yield _this.prepareTextAnswer(question, answers, textarea, siteId);\n      }\n      if (attachmentsInput) {\n        yield _this.prepareAttachments(question, answers, offline, component, componentId, attachmentsInput, siteId);\n      }\n    })();\n  }\n  /**\n   * Prepare attachments.\n   *\n   * @param question Question.\n   * @param answers The answers retrieved from the form. Prepared answers must be stored in this object.\n   * @param offline Whether the data should be saved in offline.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @param attachmentsInput The HTML input containing the draft ID for attachments.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Return a promise resolved when done if async, void if sync.\n   */\n  prepareAttachments(question, answers, offline, component, componentId, attachmentsInput, siteId) {\n    return _asyncToGenerator(function* () {\n      // Treat attachments if any.\n      const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n      const attachments = CoreFileSession.getFiles(component, questionComponentId);\n      const draftId = Number(attachmentsInput.value);\n      if (offline) {\n        // Get the folder where to store the files.\n        const folderPath = CoreQuestion.getQuestionFolder(question.type, component, questionComponentId, siteId);\n        const result = yield CoreFileUploader.storeFilesToUpload(folderPath, attachments);\n        // Store the files in the answers.\n        answers[attachmentsInput.name + '_offline'] = JSON.stringify(result);\n      } else {\n        // Check if any attachment was deleted.\n        const originalAttachments = CoreQuestionHelper.getResponseFileAreaFiles(question, 'attachments');\n        const filesToDelete = CoreFileUploader.getFilesToDelete(originalAttachments, attachments);\n        if (filesToDelete.length > 0) {\n          // Delete files.\n          yield CoreFileUploader.deleteDraftFiles(draftId, filesToDelete, siteId);\n        }\n        yield CoreFileUploader.uploadFiles(draftId, attachments, siteId);\n      }\n    })();\n  }\n  /**\n   * Prepare data to send when performing a synchronization.\n   *\n   * @param question Question.\n   * @param answers Answers of the question, without the prefix.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  prepareSyncData(question, answers, component, componentId, siteId) {\n    return _asyncToGenerator(function* () {\n      const element = CoreDomUtils.convertToElement(question.html);\n      const attachmentsInput = element.querySelector('.attachments input[name*=_attachments]');\n      if (attachmentsInput) {\n        // Update the draft ID, the stored one could no longer be valid.\n        answers.attachments = attachmentsInput.value;\n      }\n      if (!answers || !answers.attachments_offline) {\n        return;\n      }\n      const attachmentsData = CoreTextUtils.parseJSON(answers.attachments_offline, {\n        online: [],\n        offline: 0\n      });\n      delete answers.attachments_offline;\n      // Check if any attachment was deleted.\n      const originalAttachments = CoreQuestionHelper.getResponseFileAreaFiles(question, 'attachments');\n      const filesToDelete = CoreFileUploader.getFilesToDelete(originalAttachments, attachmentsData.online);\n      if (filesToDelete.length > 0) {\n        // Delete files.\n        yield CoreFileUploader.deleteDraftFiles(Number(answers.attachments), filesToDelete, siteId);\n      }\n      if (!attachmentsData.offline) {\n        return;\n      }\n      // Upload the offline files.\n      const offlineFiles = yield CoreQuestionHelper.getStoredQuestionFiles(question, component, componentId, siteId);\n      yield CoreFileUploader.uploadFiles(Number(answers.attachments), [...attachmentsData.online, ...offlineFiles], siteId);\n    })();\n  }\n  /**\n   * Prepare the text answer.\n   *\n   * @param question Question.\n   * @param answers The answers retrieved from the form. Prepared answers must be stored in this object.\n   * @param textarea The textarea HTML element of the question.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  prepareTextAnswer(question, answers, textarea, siteId) {\n    return _asyncToGenerator(function* () {\n      if (CoreQuestionHelper.hasDraftFileUrls(question.html) && question.responsefileareas) {\n        // Restore draftfile URLs.\n        const site = yield CoreSites.getSite(siteId);\n        answers[textarea.name] = CoreTextUtils.restoreDraftfileUrls(site.getURL(), answers[textarea.name], question.html, CoreQuestionHelper.getResponseFileAreaFiles(question, 'answer'));\n      }\n      let isPlainText = false;\n      if (question.isPlainText !== undefined) {\n        isPlainText = question.isPlainText;\n      } else if (question.parsedSettings) {\n        isPlainText = question.parsedSettings.responseformat == 'monospaced' || question.parsedSettings.responseformat == 'plain';\n      } else {\n        const questionEl = CoreDomUtils.convertToElement(question.html);\n        isPlainText = !!questionEl.querySelector('.qtype_essay_monospaced') || !!questionEl.querySelector('.qtype_essay_plain');\n      }\n      if (!isPlainText) {\n        // Add some HTML to the text if needed.\n        answers[textarea.name] = CoreTextUtils.formatHtmlLines(answers[textarea.name] || '');\n      }\n    })();\n  }\n}\n_class = AddonQtypeEssayHandlerService;\n_class.ɵfac = function AddonQtypeEssayHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonQtypeEssayHandler = makeSingleton(AddonQtypeEssayHandlerService);","map":{"version":3,"names":["CoreFileUploader","CoreQuestion","CoreQuestionHelper","CoreFileSession","CoreSites","CoreDomUtils","CoreTextUtils","CoreUtils","makeSingleton","Translate","AddonQtypeEssayComponent","AddonQtypeEssayHandlerService","constructor","name","type","clearTmpData","question","component","componentId","questionComponentId","getQuestionComponentId","files","getFiles","clearFiles","clearTmpFiles","deleteOfflineData","siteId","deleteStoredQuestionFiles","getAdditionalDownloadableFiles","responsefileareas","reduce","urlsList","area","concat","getAllowedOptions","parsedSettings","text","responseformat","attachments","element","convertToElement","html","querySelector","getBehaviour","getComponent","getPreventSubmitMessage","uploadFilesSupported","undefined","hasDraftFileUrls","innerHTML","getValidationError","answers","onlineError","answer","checkInputWordCount","maxwordlimit","minwordlimit","minWords","Number","maxWords","count","countWords","instant","$a","limit","isCompleteResponse","hasTextAnswer","allowedOptions","length","attachmentsrequired","responserequired","isEnabled","_asyncToGenerator","isGradableResponse","isSameResponse","prevAnswers","newAnswers","answerIsEqual","sameAtKeyMissingIsBlank","originalAttachments","getResponseFileAreaFiles","areFileListDifferent","prepareAnswers","offline","_this","attachmentsInput","textarea","prepareTextAnswer","prepareAttachments","draftId","value","folderPath","getQuestionFolder","result","storeFilesToUpload","JSON","stringify","filesToDelete","getFilesToDelete","deleteDraftFiles","uploadFiles","prepareSyncData","attachments_offline","attachmentsData","parseJSON","online","offlineFiles","getStoredQuestionFiles","site","getSite","restoreDraftfileUrls","getURL","isPlainText","questionEl","formatHtmlLines","factory","ɵfac","providedIn","AddonQtypeEssayHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/qtype/essay/services/handlers/essay.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreFileUploader, CoreFileUploaderStoreFilesResult } from '@features/fileuploader/services/fileuploader';\nimport { AddonModQuizEssayQuestion } from '@features/question/classes/base-question-component';\nimport { CoreQuestion, CoreQuestionQuestionParsed, CoreQuestionsAnswers } from '@features/question/services/question';\nimport { CoreQuestionHandler } from '@features/question/services/question-delegate';\nimport { CoreQuestionHelper } from '@features/question/services/question-helper';\nimport { CoreFileSession } from '@services/file-session';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonQtypeEssayComponent } from '../../component/essay';\n\n/**\n * Handler to support essay question type.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonQtypeEssayHandlerService implements CoreQuestionHandler {\n\n    name = 'AddonQtypeEssay';\n    type = 'qtype_essay';\n\n    /**\n     * @inheritdoc\n     */\n    clearTmpData(question: CoreQuestionQuestionParsed, component: string, componentId: string | number): void {\n        const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n        const files = CoreFileSession.getFiles(component, questionComponentId);\n\n        // Clear the files in session for this question.\n        CoreFileSession.clearFiles(component, questionComponentId);\n\n        // Now delete the local files from the tmp folder.\n        CoreFileUploader.clearTmpFiles(files);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    deleteOfflineData(\n        question: CoreQuestionQuestionParsed,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<void> {\n        return CoreQuestionHelper.deleteStoredQuestionFiles(question, component, componentId, siteId);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getAdditionalDownloadableFiles(question: CoreQuestionQuestionParsed): CoreWSFile[] {\n        if (!question.responsefileareas) {\n            return [];\n        }\n\n        return question.responsefileareas.reduce((urlsList, area) => urlsList.concat(area.files || []), <CoreWSFile[]> []);\n    }\n\n    /**\n     * Check whether the question allows text and/or attachments.\n     *\n     * @param question Question to check.\n     * @returns Allowed options.\n     */\n    protected getAllowedOptions(question: CoreQuestionQuestionParsed): { text: boolean; attachments: boolean } {\n        if (question.parsedSettings) {\n            return {\n                text: question.parsedSettings.responseformat != 'noinline',\n                attachments: question.parsedSettings.attachments != '0',\n            };\n        }\n\n        const element = CoreDomUtils.convertToElement(question.html);\n\n        return {\n            text: !!element.querySelector('textarea[name*=_answer]'),\n            attachments: !!element.querySelector('div[id*=filemanager]'),\n        };\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getBehaviour(): string {\n        return 'manualgraded';\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getComponent(): Type<unknown> {\n        return AddonQtypeEssayComponent;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getPreventSubmitMessage(question: CoreQuestionQuestionParsed): string | undefined {\n        const element = CoreDomUtils.convertToElement(question.html);\n        const uploadFilesSupported = question.responsefileareas !== undefined;\n\n        if (!uploadFilesSupported && element.querySelector('div[id*=filemanager]')) {\n            // The question allows attachments. Since the app cannot attach files yet we will prevent submitting the question.\n            return 'core.question.errorattachmentsnotsupportedinsite';\n        }\n\n        if (!uploadFilesSupported && CoreQuestionHelper.hasDraftFileUrls(element.innerHTML)) {\n            return 'core.question.errorembeddedfilesnotsupportedinsite';\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getValidationError(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        onlineError: string | undefined,\n    ): string | undefined {\n        if (answers.answer === undefined) {\n            // Not answered in offline.\n            return onlineError;\n        }\n\n        if (!answers.answer) {\n            // Not answered yet, no error.\n            return;\n        }\n\n        return this.checkInputWordCount(question, <string> answers.answer, onlineError);\n    }\n\n    /**\n     * Check the input word count and return a message to user when the number of words are outside the boundary settings.\n     *\n     * @param question The question.\n     * @param answer Object with the question answers (without prefix).\n     * @param onlineError Online validation error.\n     * @returns Error message if there's a validation error, undefined otherwise.\n     */\n    protected checkInputWordCount(\n        question: CoreQuestionQuestionParsed,\n        answer: string,\n        onlineError: string | undefined,\n    ): string | undefined {\n        if (!question.parsedSettings || question.parsedSettings.maxwordlimit === undefined ||\n                question.parsedSettings.minwordlimit === undefined) {\n            // Min/max not supported, use online error.\n            return onlineError;\n        }\n\n        const minWords = Number(question.parsedSettings.minwordlimit);\n        const maxWords = Number(question.parsedSettings.maxwordlimit);\n\n        if (!maxWords && !minWords) {\n            // No min and max, no error.\n            return;\n        }\n\n        // Count the number of words in the response string.\n        const count = CoreTextUtils.countWords(answer);\n        if (maxWords && count > maxWords) {\n            return Translate.instant('addon.qtype_essay.maxwordlimitboundary', { $a: { limit: maxWords, count: count } });\n        } else if (count < minWords) {\n            return Translate.instant('addon.qtype_essay.minwordlimitboundary', { $a: { limit: minWords, count: count } });\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isCompleteResponse(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): number {\n\n        const hasTextAnswer = !!answers.answer;\n        const uploadFilesSupported = question.responsefileareas !== undefined;\n        const allowedOptions = this.getAllowedOptions(question);\n\n        if (hasTextAnswer && this.checkInputWordCount(question, <string> answers.answer, undefined)) {\n            return 0;\n        }\n\n        if (!allowedOptions.attachments) {\n            return hasTextAnswer ? 1 : 0;\n        }\n\n        if (!uploadFilesSupported || !question.parsedSettings) {\n            // We can't know if the attachments are required or if the user added any in web.\n            return -1;\n        }\n\n        const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n        const attachments = CoreFileSession.getFiles(component, questionComponentId);\n\n        if (!allowedOptions.text) {\n            return attachments && attachments.length >= Number(question.parsedSettings.attachmentsrequired) ? 1 : 0;\n        }\n\n        return ((hasTextAnswer || question.parsedSettings.responserequired == '0') &&\n                (attachments && attachments.length >= Number(question.parsedSettings.attachmentsrequired))) ? 1 : 0;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isGradableResponse(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): number {\n        if (question.responsefileareas === undefined) {\n            return -1;\n        }\n\n        const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n        const attachments = CoreFileSession.getFiles(component, questionComponentId);\n\n        // Determine if the given response has online text or attachments.\n        return (answers.answer && answers.answer !== '') || (attachments && attachments.length > 0) ? 1 : 0;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isSameResponse(\n        question: CoreQuestionQuestionParsed,\n        prevAnswers: CoreQuestionsAnswers,\n        newAnswers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): boolean {\n        const uploadFilesSupported = question.responsefileareas !== undefined;\n        const allowedOptions = this.getAllowedOptions(question);\n\n        // First check the inline text.\n        const answerIsEqual = allowedOptions.text ?\n            CoreUtils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer') : true;\n\n        if (!allowedOptions.attachments || !uploadFilesSupported || !answerIsEqual) {\n            // No need to check attachments.\n            return answerIsEqual;\n        }\n\n        // Check attachments now.\n        const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n        const attachments = CoreFileSession.getFiles(component, questionComponentId);\n        const originalAttachments = CoreQuestionHelper.getResponseFileAreaFiles(question, 'attachments');\n\n        return !CoreFileUploader.areFileListDifferent(attachments, originalAttachments);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async prepareAnswers(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        offline: boolean,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<void> {\n\n        const element = CoreDomUtils.convertToElement(question.html);\n        const attachmentsInput = <HTMLInputElement> element.querySelector('.attachments input[name*=_attachments]');\n\n        // Search the textarea to get its name.\n        const textarea = <HTMLTextAreaElement> element.querySelector('textarea[name*=_answer]');\n\n        if (textarea && answers[textarea.name] !== undefined) {\n            await this.prepareTextAnswer(question, answers, textarea, siteId);\n        }\n\n        if (attachmentsInput) {\n            await this.prepareAttachments(question, answers, offline, component, componentId, attachmentsInput, siteId);\n        }\n    }\n\n    /**\n     * Prepare attachments.\n     *\n     * @param question Question.\n     * @param answers The answers retrieved from the form. Prepared answers must be stored in this object.\n     * @param offline Whether the data should be saved in offline.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param attachmentsInput The HTML input containing the draft ID for attachments.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Return a promise resolved when done if async, void if sync.\n     */\n    async prepareAttachments(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        offline: boolean,\n        component: string,\n        componentId: string | number,\n        attachmentsInput: HTMLInputElement,\n        siteId?: string,\n    ): Promise<void> {\n\n        // Treat attachments if any.\n        const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n        const attachments = CoreFileSession.getFiles(component, questionComponentId);\n        const draftId = Number(attachmentsInput.value);\n\n        if (offline) {\n            // Get the folder where to store the files.\n            const folderPath = CoreQuestion.getQuestionFolder(question.type, component, questionComponentId, siteId);\n\n            const result = await CoreFileUploader.storeFilesToUpload(folderPath, attachments);\n\n            // Store the files in the answers.\n            answers[attachmentsInput.name + '_offline'] = JSON.stringify(result);\n        } else {\n            // Check if any attachment was deleted.\n            const originalAttachments = CoreQuestionHelper.getResponseFileAreaFiles(question, 'attachments');\n            const filesToDelete = CoreFileUploader.getFilesToDelete(originalAttachments, attachments);\n\n            if (filesToDelete.length > 0) {\n                // Delete files.\n                await CoreFileUploader.deleteDraftFiles(draftId, filesToDelete, siteId);\n            }\n\n            await CoreFileUploader.uploadFiles(draftId, attachments, siteId);\n        }\n    }\n\n    /**\n     * Prepare data to send when performing a synchronization.\n     *\n     * @param question Question.\n     * @param answers Answers of the question, without the prefix.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async prepareSyncData(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<void> {\n\n        const element = CoreDomUtils.convertToElement(question.html);\n        const attachmentsInput = <HTMLInputElement> element.querySelector('.attachments input[name*=_attachments]');\n\n        if (attachmentsInput) {\n            // Update the draft ID, the stored one could no longer be valid.\n            answers.attachments = attachmentsInput.value;\n        }\n\n        if (!answers || !answers.attachments_offline) {\n            return;\n        }\n\n        const attachmentsData: CoreFileUploaderStoreFilesResult = CoreTextUtils.parseJSON(\n            <string> answers.attachments_offline,\n            {\n                online: [],\n                offline: 0,\n            },\n        );\n        delete answers.attachments_offline;\n\n        // Check if any attachment was deleted.\n        const originalAttachments = CoreQuestionHelper.getResponseFileAreaFiles(question, 'attachments');\n        const filesToDelete = CoreFileUploader.getFilesToDelete(originalAttachments, attachmentsData.online);\n\n        if (filesToDelete.length > 0) {\n            // Delete files.\n            await CoreFileUploader.deleteDraftFiles(Number(answers.attachments), filesToDelete, siteId);\n        }\n\n        if (!attachmentsData.offline) {\n            return;\n        }\n\n        // Upload the offline files.\n        const offlineFiles =\n            <FileEntry[]> await CoreQuestionHelper.getStoredQuestionFiles(question, component, componentId, siteId);\n\n        await CoreFileUploader.uploadFiles(\n            Number(answers.attachments),\n            [...attachmentsData.online, ...offlineFiles],\n            siteId,\n        );\n    }\n\n    /**\n     * Prepare the text answer.\n     *\n     * @param question Question.\n     * @param answers The answers retrieved from the form. Prepared answers must be stored in this object.\n     * @param textarea The textarea HTML element of the question.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async prepareTextAnswer(\n        question: AddonModQuizEssayQuestion,\n        answers: CoreQuestionsAnswers,\n        textarea: HTMLTextAreaElement,\n        siteId?: string,\n    ): Promise<void> {\n        if (CoreQuestionHelper.hasDraftFileUrls(question.html) && question.responsefileareas) {\n            // Restore draftfile URLs.\n            const site = await CoreSites.getSite(siteId);\n\n            answers[textarea.name] = CoreTextUtils.restoreDraftfileUrls(\n                site.getURL(),\n                <string> answers[textarea.name],\n                question.html,\n                CoreQuestionHelper.getResponseFileAreaFiles(question, 'answer'),\n            );\n        }\n\n        let isPlainText = false;\n        if (question.isPlainText !== undefined) {\n            isPlainText = question.isPlainText;\n        } else if (question.parsedSettings) {\n            isPlainText = question.parsedSettings.responseformat == 'monospaced' ||\n                question.parsedSettings.responseformat == 'plain';\n        } else {\n            const questionEl = CoreDomUtils.convertToElement(question.html);\n            isPlainText = !!questionEl.querySelector('.qtype_essay_monospaced') || !!questionEl.querySelector('.qtype_essay_plain');\n        }\n\n        if (!isPlainText) {\n            // Add some HTML to the text if needed.\n            answers[textarea.name] = CoreTextUtils.formatHtmlLines(<string> answers[textarea.name] || '');\n        }\n    }\n\n}\n\nexport const AddonQtypeEssayHandler = makeSingleton(AddonQtypeEssayHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}