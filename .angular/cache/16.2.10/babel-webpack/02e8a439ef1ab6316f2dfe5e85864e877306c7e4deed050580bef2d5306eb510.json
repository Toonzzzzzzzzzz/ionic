{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { STATEMENTS_TABLE_NAME, STATES_TABLE_NAME } from './database/xapi';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline xAPI.\n */\nexport class CoreXAPIOfflineProvider {\n  /**\n   * Check if there are offline data to send for a context.\n   *\n   * @param contextId Context ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has offline data, false otherwise.\n   */\n  contextHasData(contextId, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const [hasStatements, hasSates] = yield Promise.all([_this.contextHasStatements(contextId, siteId), _this.itemHasStates(contextId, siteId)]);\n      return hasStatements || hasSates;\n    })();\n  }\n  /**\n   * Check if there are offline statements to send for a context.\n   *\n   * @param contextId Context ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has offline statements, false otherwise.\n   */\n  contextHasStatements(contextId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const statementsList = yield _this2.getContextStatements(contextId, siteId);\n      return statementsList && statementsList.length > 0;\n    })();\n  }\n  /**\n   * Delete certain statements.\n   *\n   * @param id ID of the statements.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteStatements(id, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      yield db.deleteRecords(STATEMENTS_TABLE_NAME, {\n        id\n      });\n    })();\n  }\n  /**\n   * Delete all statements of a certain context.\n   *\n   * @param contextId Context ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteStatementsForContext(contextId, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      yield db.deleteRecords(STATEMENTS_TABLE_NAME, {\n        contextid: contextId\n      });\n    })();\n  }\n  /**\n   * Delete all states from a component that fulfill the supplied condition.\n   *\n   * @param component Component.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  deleteStates(component, options = {}) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(options.siteId);\n      const conditions = {\n        component\n      };\n      if (options.itemId !== undefined) {\n        conditions.itemid = options.itemId;\n      }\n      if (options.stateId !== undefined) {\n        conditions.stateid = options.stateId;\n      }\n      if (options.registration !== undefined) {\n        conditions.registration = options.registration;\n      }\n      yield db.deleteRecords(STATES_TABLE_NAME, conditions);\n    })();\n  }\n  /**\n   * Get all offline statements.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with all the data.\n   */\n  getAllStatements(siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      return db.getRecords(STATEMENTS_TABLE_NAME, undefined, 'timecreated ASC');\n    })();\n  }\n  /**\n   * Get all offline states.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with all the data.\n   */\n  getAllStates(siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      return db.getRecords(STATES_TABLE_NAME, undefined, 'timemodified ASC');\n    })();\n  }\n  /**\n   * Get statements for a context.\n   *\n   * @param contextId Context ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the data.\n   */\n  getContextStatements(contextId, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      return db.getRecords(STATEMENTS_TABLE_NAME, {\n        contextid: contextId\n      }, 'timecreated ASC');\n    })();\n  }\n  /**\n   * Get states for an item.\n   *\n   * @param itemId item ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the data.\n   */\n  getItemStates(itemId, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      return db.getRecords(STATES_TABLE_NAME, {\n        itemid: itemId\n      }, 'timecreated ASC');\n    })();\n  }\n  /**\n   * Get certain statements.\n   *\n   * @param id ID of the statements.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the data.\n   */\n  getStatements(id, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      return db.getRecord(STATEMENTS_TABLE_NAME, {\n        id\n      });\n    })();\n  }\n  /**\n   * Get a certain state (if it exists).\n   *\n   * @param component Component.\n   * @param itemId The Agent Id (usually the plugin instance).\n   * @param stateId The xAPI state ID.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  getState(component, itemId, stateId, options = {}) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(options === null || options === void 0 ? void 0 : options.siteId);\n      const conditions = {\n        component,\n        itemid: itemId,\n        stateid: stateId\n      };\n      if (options.registration) {\n        conditions.registration = options.registration;\n      }\n      return db.getRecord(STATES_TABLE_NAME, conditions);\n    })();\n  }\n  /**\n   * Check if there are offline states to send for an item.\n   *\n   * @param itemId Item ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has offline states, false otherwise.\n   */\n  itemHasStates(itemId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const statesList = yield _this3.getItemStates(itemId, siteId);\n      return statesList && statesList.length > 0;\n    })();\n  }\n  /**\n   * Save state.\n   *\n   * @param component Component.\n   * @param itemId The Agent Id (usually the plugin instance).\n   * @param stateId The xAPI state ID.\n   * @param stateData JSON object with the state data.\n   * @param options Options.\n   * @returns Promise resolved when state is successfully saved.\n   */\n  saveState(component, itemId, stateId, stateData, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(options === null || options === void 0 ? void 0 : options.siteId);\n      const storedState = yield CoreUtils.ignoreErrors(_this4.getState(component, itemId, stateId, options));\n      if (storedState) {\n        const newData = {\n          statedata: stateData,\n          timemodified: Date.now()\n        };\n        const conditions = {\n          component,\n          itemid: itemId,\n          stateid: stateId,\n          registration: options === null || options === void 0 ? void 0 : options.registration\n        };\n        yield db.updateRecords(STATES_TABLE_NAME, newData, conditions);\n      } else {\n        const entry = {\n          component,\n          itemid: itemId,\n          stateid: stateId,\n          statedata: stateData,\n          timecreated: Date.now(),\n          timemodified: Date.now(),\n          courseid: options === null || options === void 0 ? void 0 : options.courseId,\n          extra: options === null || options === void 0 ? void 0 : options.extra\n        };\n        yield db.insertRecord(STATES_TABLE_NAME, entry);\n      }\n    })();\n  }\n  /**\n   * Save statements.\n   *\n   * @param contextId Context ID.\n   * @param component Component to send the statements to.\n   * @param statements Statements (JSON-encoded).\n   * @param options Options.\n   * @returns Promise resolved when statements are successfully saved.\n   */\n  saveStatements(contextId, component, statements, options) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(options === null || options === void 0 ? void 0 : options.siteId);\n      const entry = {\n        contextid: contextId,\n        component: component,\n        statements: statements,\n        timecreated: Date.now(),\n        courseid: options === null || options === void 0 ? void 0 : options.courseId,\n        extra: options === null || options === void 0 ? void 0 : options.extra\n      };\n      yield db.insertRecord(STATEMENTS_TABLE_NAME, entry);\n    })();\n  }\n}\n_class = CoreXAPIOfflineProvider;\n_class.ɵfac = function CoreXAPIOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreXAPIOffline = makeSingleton(CoreXAPIOfflineProvider);","map":{"version":3,"names":["CoreSites","CoreUtils","makeSingleton","STATEMENTS_TABLE_NAME","STATES_TABLE_NAME","CoreXAPIOfflineProvider","contextHasData","contextId","siteId","_this","_asyncToGenerator","hasStatements","hasSates","Promise","all","contextHasStatements","itemHasStates","_this2","statementsList","getContextStatements","length","deleteStatements","id","db","getSiteDb","deleteRecords","deleteStatementsForContext","contextid","deleteStates","component","options","conditions","itemId","undefined","itemid","stateId","stateid","registration","getAllStatements","getRecords","getAllStates","getItemStates","getStatements","getRecord","getState","_this3","statesList","saveState","stateData","_this4","storedState","ignoreErrors","newData","statedata","timemodified","Date","now","updateRecords","entry","timecreated","courseid","courseId","extra","insertRecord","saveStatements","statements","factory","ɵfac","providedIn","CoreXAPIOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/xapi/services/offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreXAPIStateDBRecord, CoreXAPIStatementDBRecord, STATEMENTS_TABLE_NAME, STATES_TABLE_NAME } from './database/xapi';\nimport { CoreXAPIStateOptions } from './xapi';\n\n/**\n * Service to handle offline xAPI.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreXAPIOfflineProvider {\n\n    /**\n     * Check if there are offline data to send for a context.\n     *\n     * @param contextId Context ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has offline data, false otherwise.\n     */\n    async contextHasData(contextId: number, siteId?: string): Promise<boolean> {\n        const [hasStatements, hasSates] = await Promise.all([\n            this.contextHasStatements(contextId, siteId),\n            this.itemHasStates(contextId, siteId),\n        ]);\n\n        return hasStatements || hasSates;\n    }\n\n    /**\n     * Check if there are offline statements to send for a context.\n     *\n     * @param contextId Context ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has offline statements, false otherwise.\n     */\n    async contextHasStatements(contextId: number, siteId?: string): Promise<boolean> {\n        const statementsList = await this.getContextStatements(contextId, siteId);\n\n        return statementsList && statementsList.length > 0;\n    }\n\n    /**\n     * Delete certain statements.\n     *\n     * @param id ID of the statements.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteStatements(id: number, siteId?: string): Promise<void> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        await db.deleteRecords(STATEMENTS_TABLE_NAME, { id });\n    }\n\n    /**\n     * Delete all statements of a certain context.\n     *\n     * @param contextId Context ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteStatementsForContext(contextId: number, siteId?: string): Promise<void> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        await db.deleteRecords(STATEMENTS_TABLE_NAME, { contextid: contextId });\n    }\n\n    /**\n     * Delete all states from a component that fulfill the supplied condition.\n     *\n     * @param component Component.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async deleteStates(\n        component: string,\n        options: CoreXAPIOfflineDeleteStatesOptions = {},\n    ): Promise<void> {\n        const db = await CoreSites.getSiteDb(options.siteId);\n\n        const conditions: Partial<CoreXAPIStateDBRecord> = {\n            component,\n        };\n        if (options.itemId !== undefined) {\n            conditions.itemid = options.itemId;\n        }\n        if (options.stateId !== undefined) {\n            conditions.stateid = options.stateId;\n        }\n        if (options.registration !== undefined) {\n            conditions.registration = options.registration;\n        }\n\n        await db.deleteRecords(STATES_TABLE_NAME, conditions);\n    }\n\n    /**\n     * Get all offline statements.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with all the data.\n     */\n    async getAllStatements(siteId?: string): Promise<CoreXAPIStatementDBRecord[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        return db.getRecords(STATEMENTS_TABLE_NAME, undefined, 'timecreated ASC');\n    }\n\n    /**\n     * Get all offline states.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with all the data.\n     */\n    async getAllStates(siteId?: string): Promise<CoreXAPIStateDBRecord[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        return db.getRecords(STATES_TABLE_NAME, undefined, 'timemodified ASC');\n    }\n\n    /**\n     * Get statements for a context.\n     *\n     * @param contextId Context ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the data.\n     */\n    async getContextStatements(contextId: number, siteId?: string): Promise<CoreXAPIStatementDBRecord[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        return db.getRecords<CoreXAPIStatementDBRecord>(STATEMENTS_TABLE_NAME, { contextid: contextId }, 'timecreated ASC');\n    }\n\n    /**\n     * Get states for an item.\n     *\n     * @param itemId item ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the data.\n     */\n    async getItemStates(itemId: number, siteId?: string): Promise<CoreXAPIStateDBRecord[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        return db.getRecords<CoreXAPIStateDBRecord>(STATES_TABLE_NAME, { itemid: itemId }, 'timecreated ASC');\n    }\n\n    /**\n     * Get certain statements.\n     *\n     * @param id ID of the statements.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the data.\n     */\n    async getStatements(id: number, siteId?: string): Promise<CoreXAPIStatementDBRecord> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        return db.getRecord<CoreXAPIStatementDBRecord>(STATEMENTS_TABLE_NAME, { id });\n    }\n\n    /**\n     * Get a certain state (if it exists).\n     *\n     * @param component Component.\n     * @param itemId The Agent Id (usually the plugin instance).\n     * @param stateId The xAPI state ID.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async getState(\n        component: string,\n        itemId: number,\n        stateId: string,\n        options: CoreXAPIStateOptions = {},\n    ): Promise<CoreXAPIStateDBRecord> {\n        const db = await CoreSites.getSiteDb(options?.siteId);\n\n        const conditions: Partial<CoreXAPIStateDBRecord> = {\n            component,\n            itemid: itemId,\n            stateid: stateId,\n        };\n        if (options.registration) {\n            conditions.registration = options.registration;\n        }\n\n        return db.getRecord(STATES_TABLE_NAME, conditions);\n    }\n\n    /**\n     * Check if there are offline states to send for an item.\n     *\n     * @param itemId Item ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has offline states, false otherwise.\n     */\n    async itemHasStates(itemId: number, siteId?: string): Promise<boolean> {\n        const statesList = await this.getItemStates(itemId, siteId);\n\n        return statesList && statesList.length > 0;\n    }\n\n    /**\n     * Save state.\n     *\n     * @param component Component.\n     * @param itemId The Agent Id (usually the plugin instance).\n     * @param stateId The xAPI state ID.\n     * @param stateData JSON object with the state data.\n     * @param options Options.\n     * @returns Promise resolved when state is successfully saved.\n     */\n    async saveState(\n        component: string,\n        itemId: number,\n        stateId: string,\n        stateData: string,\n        options: CoreXAPIOfflineSaveStateOptions = {},\n    ): Promise<void> {\n        const db = await CoreSites.getSiteDb(options?.siteId);\n\n        const storedState = await CoreUtils.ignoreErrors(this.getState(component, itemId, stateId, options));\n\n        if (storedState) {\n            const newData: Partial<CoreXAPIStateDBRecord> = {\n                statedata: stateData,\n                timemodified: Date.now(),\n            };\n            const conditions: Partial<CoreXAPIStateDBRecord> = {\n                component,\n                itemid: itemId,\n                stateid: stateId,\n                registration: options?.registration,\n            };\n\n            await db.updateRecords(STATES_TABLE_NAME, newData, conditions);\n        } else {\n            const entry: Omit<CoreXAPIStateDBRecord, 'id'> = {\n                component,\n                itemid: itemId,\n                stateid: stateId,\n                statedata: stateData,\n                timecreated: Date.now(),\n                timemodified: Date.now(),\n                courseid: options?.courseId,\n                extra: options?.extra,\n            };\n\n            await db.insertRecord(STATES_TABLE_NAME, entry);\n        }\n    }\n\n    /**\n     * Save statements.\n     *\n     * @param contextId Context ID.\n     * @param component Component to send the statements to.\n     * @param statements Statements (JSON-encoded).\n     * @param options Options.\n     * @returns Promise resolved when statements are successfully saved.\n     */\n    async saveStatements(\n        contextId: number,\n        component: string,\n        statements: string,\n        options?: CoreXAPIOfflineSaveStatementsOptions,\n    ): Promise<void> {\n        const db = await CoreSites.getSiteDb(options?.siteId);\n\n        const entry: Omit<CoreXAPIStatementDBRecord, 'id'> = {\n            contextid: contextId,\n            component: component,\n            statements: statements,\n            timecreated: Date.now(),\n            courseid: options?.courseId,\n            extra: options?.extra,\n        };\n\n        await db.insertRecord(STATEMENTS_TABLE_NAME, entry);\n    }\n\n}\n\nexport const CoreXAPIOffline = makeSingleton(CoreXAPIOfflineProvider);\n\n/**\n * Common options to pass to save functions.\n */\nexport type CoreXAPIOfflineSaveCommonOptions = {\n    courseId?: number; // Course ID if the context is inside a course.\n    extra?: string; // Extra data to store.\n    siteId?: string; // Site ID. If not defined, current site.\n};\n\n/**\n * Options to pass to saveStatements function.\n */\nexport type CoreXAPIOfflineSaveStatementsOptions = CoreXAPIOfflineSaveCommonOptions;\n\n/**\n * Options to pass to saveStatements function.\n */\nexport type CoreXAPIOfflineSaveStateOptions = CoreXAPIOfflineSaveCommonOptions & {\n    registration?: string; // The xAPI registration UUID.\n};\n\n/**\n * Options to pass to deleteStates function.\n */\nexport type CoreXAPIOfflineDeleteStatesOptions = CoreXAPIStateOptions & {\n    itemId?: number;\n    stateId?: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}