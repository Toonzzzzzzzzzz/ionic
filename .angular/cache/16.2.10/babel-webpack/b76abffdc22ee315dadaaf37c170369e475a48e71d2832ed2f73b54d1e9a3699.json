{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreFileUploader } from '@features/fileuploader/services/fileuploader';\nimport { CoreFile } from '@services/file';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { AlertController, ApplicationInit, makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSharedFilesListModalComponent } from '../components/list-modal/list-modal';\nimport { CoreSharedFiles } from './sharedfiles';\nimport { SHAREDFILES_PAGE_NAME } from '../sharedfiles.module';\nimport { CoreSharedFilesChooseSitePage } from '../pages/choose-site/choose-site';\nimport { CoreError } from '@classes/errors/error';\nimport { CorePlatform } from '@services/platform';\nimport * as i0 from \"@angular/core\";\n/**\n * Helper service to share files with the app.\n */\nexport class CoreSharedFilesHelperProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('CoreSharedFilesHelperProvider');\n  }\n  /**\n   * Initialize.\n   */\n  initialize() {\n    if (!CorePlatform.isIOS()) {\n      return;\n    }\n    let lastCheck = Date.now();\n    // Check if there are new files at app start and when the app is resumed.\n    this.searchIOSNewSharedFiles();\n    CorePlatform.resume.subscribe(() => {\n      // Wait a bit to make sure that APP_LAUNCHED_URL is treated before this callback.\n      setTimeout(() => {\n        if (Date.now() - lastCheck < 1000) {\n          // Last check less than 1s ago, don't do anything.\n          return;\n        }\n        lastCheck = Date.now();\n        this.searchIOSNewSharedFiles();\n      }, 200);\n    });\n    CoreEvents.on(CoreEvents.APP_LAUNCHED_URL, data => {\n      if (data.url.indexOf('file://') === 0) {\n        // We received a file in iOS, it's probably a shared file. Treat it.\n        lastCheck = Date.now();\n        this.searchIOSNewSharedFiles(data.url);\n      }\n    });\n  }\n  /**\n   * Ask a user if he wants to replace a file (using originalName) or rename it (using newName).\n   *\n   * @param originalName Original name.\n   * @param newName New name.\n   * @returns Promise resolved with the name to use when the user chooses. Rejected if user cancels.\n   */\n  askRenameReplace(originalName, newName) {\n    return _asyncToGenerator(function* () {\n      const alert = yield AlertController.create({\n        header: Translate.instant('core.sharedfiles.sharedfiles'),\n        message: Translate.instant('core.sharedfiles.chooseactionrepeatedfile', {\n          $a: newName\n        }),\n        buttons: [{\n          text: Translate.instant('core.sharedfiles.rename'),\n          role: 'rename'\n        }, {\n          text: Translate.instant('core.sharedfiles.replace'),\n          role: 'replace'\n        }]\n      });\n      yield alert.present();\n      const result = yield alert.onDidDismiss();\n      if (result.role == 'rename') {\n        return newName;\n      } else if (result.role == 'replace') {\n        return originalName;\n      } else {\n        // Canceled.\n        throw new CoreCanceledError();\n      }\n    })();\n  }\n  /**\n   * Go to the choose site view.\n   *\n   * @param filePath File path to send to the view.\n   * @param isInbox Whether the file is in the Inbox folder.\n   */\n  goToChooseSite(filePath, isInbox) {\n    if (CoreSites.isLoggedIn()) {\n      CoreNavigator.navigateToSitePath(`/${SHAREDFILES_PAGE_NAME}/choosesite`, {\n        params: {\n          filePath,\n          isInbox\n        }\n      });\n    } else {\n      CoreNavigator.navigate(`/${SHAREDFILES_PAGE_NAME}/choosesite`, {\n        params: {\n          filePath,\n          isInbox\n        }\n      });\n    }\n  }\n  /**\n   * Whether the user is already choosing a site to store a shared file.\n   *\n   * @returns Whether the user is already choosing a site to store a shared file.\n   */\n  isChoosingSite() {\n    return CoreNavigator.getCurrentRoute({\n      pageComponent: CoreSharedFilesChooseSitePage\n    }) !== null;\n  }\n  /**\n   * Open the view to select a shared file.\n   *\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @returns Promise resolved when a file is picked, rejected if file picker is closed without selecting a file.\n   */\n  pickSharedFile(mimetypes) {\n    return _asyncToGenerator(function* () {\n      const file = yield CoreDomUtils.openModal({\n        component: CoreSharedFilesListModalComponent,\n        cssClass: 'core-modal-fullscreen',\n        componentProps: {\n          mimetypes,\n          pick: true\n        }\n      });\n      if (!file) {\n        // User cancelled.\n        throw new CoreCanceledError();\n      }\n      const error = CoreFileUploader.isInvalidMimetype(mimetypes, file.fullPath);\n      if (error) {\n        throw new CoreError(error);\n      }\n      return {\n        path: file.fullPath,\n        treated: false\n      };\n    })();\n  }\n  /**\n   * Delete a shared file.\n   *\n   * @param fileEntry The file entry to delete.\n   * @param isInbox Whether the file is in the Inbox folder.\n   * @returns Promise resolved when done.\n   */\n  removeSharedFile(fileEntry, isInbox) {\n    if (isInbox) {\n      return CoreSharedFiles.deleteInboxFile(fileEntry);\n    } else {\n      return CoreFile.removeFileByFileEntry(fileEntry);\n    }\n  }\n  /**\n   * Checks if there is a new file received in iOS and move it to the shared folder of current site.\n   * If more than one site is found, the user will have to choose the site where to store it in.\n   * If more than one file is found, treat only the first one.\n   *\n   * @param path Path to a file received when launching the app.\n   * @returns Promise resolved when done.\n   */\n  searchIOSNewSharedFiles(path) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield ApplicationInit.donePromise;\n        if (_this.isChoosingSite()) {\n          // We're already treating a shared file. Abort.\n          return;\n        }\n        let fileEntry;\n        if (path) {\n          // The app was launched with the path to the file, get the file.\n          fileEntry = yield CoreFile.getExternalFile(path);\n        } else {\n          // No path received, search if there is any file in the Inbox folder.\n          fileEntry = yield CoreSharedFiles.checkIOSNewFiles();\n        }\n        if (!fileEntry) {\n          return;\n        }\n        const siteIds = yield CoreSites.getSitesIds();\n        if (!siteIds.length) {\n          // No sites stored, show error and delete the file.\n          CoreDomUtils.showErrorModal('core.sharedfiles.errorreceivefilenosites', true);\n          return _this.removeSharedFile(fileEntry, !path);\n        } else if (siteIds.length == 1) {\n          return _this.storeSharedFileInSite(fileEntry, siteIds[0], !path);\n        } else if (!_this.isChoosingSite()) {\n          _this.goToChooseSite(fileEntry.toURL(), !path);\n        }\n      } catch (error) {\n        if (error) {\n          _this.logger.error('Error searching iOS new shared files', error, path);\n        }\n      }\n    })();\n  }\n  /**\n   * Store a shared file in a site's shared files folder.\n   *\n   * @param fileEntry Shared file entry.\n   * @param siteId Site ID. If not defined, current site.\n   * @param isInbox Whether the file is in the Inbox folder.\n   * @returns Promise resolved when done.\n   */\n  storeSharedFileInSite(fileEntry, siteId, isInbox) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // First of all check if there's already a file with the same name in the shared files folder.\n      const sharedFilesDirPath = CoreSharedFiles.getSiteSharedFilesDirPath(siteId);\n      let newName = yield CoreFile.getUniqueNameInFolder(sharedFilesDirPath, fileEntry.name);\n      if (newName.toLowerCase() != fileEntry.name.toLowerCase()) {\n        // Repeated name. Ask the user what he wants to do.\n        newName = yield _this2.askRenameReplace(fileEntry.name, newName);\n      }\n      try {\n        yield CoreSharedFiles.storeFileInSite(fileEntry, newName, siteId);\n      } catch (error) {\n        CoreDomUtils.showErrorModal(error || 'Error moving file.');\n      } finally {\n        _this2.removeSharedFile(fileEntry, isInbox);\n        CoreDomUtils.showAlertTranslated('core.success', 'core.sharedfiles.successstorefile');\n      }\n    })();\n  }\n}\n_class = CoreSharedFilesHelperProvider;\n_class.ɵfac = function CoreSharedFilesHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreSharedFilesHelper = makeSingleton(CoreSharedFilesHelperProvider);","map":{"version":3,"names":["CoreCanceledError","CoreFileUploader","CoreFile","CoreNavigator","CoreSites","CoreDomUtils","AlertController","ApplicationInit","makeSingleton","Translate","CoreEvents","CoreLogger","CoreSharedFilesListModalComponent","CoreSharedFiles","SHAREDFILES_PAGE_NAME","CoreSharedFilesChooseSitePage","CoreError","CorePlatform","CoreSharedFilesHelperProvider","constructor","logger","getInstance","initialize","isIOS","lastCheck","Date","now","searchIOSNewSharedFiles","resume","subscribe","setTimeout","on","APP_LAUNCHED_URL","data","url","indexOf","askRenameReplace","originalName","newName","_asyncToGenerator","alert","create","header","instant","message","$a","buttons","text","role","present","result","onDidDismiss","goToChooseSite","filePath","isInbox","isLoggedIn","navigateToSitePath","params","navigate","isChoosingSite","getCurrentRoute","pageComponent","pickSharedFile","mimetypes","file","openModal","component","cssClass","componentProps","pick","error","isInvalidMimetype","fullPath","path","treated","removeSharedFile","fileEntry","deleteInboxFile","removeFileByFileEntry","_this","donePromise","getExternalFile","checkIOSNewFiles","siteIds","getSitesIds","length","showErrorModal","storeSharedFileInSite","toURL","siteId","_this2","getCurrentSiteId","sharedFilesDirPath","getSiteSharedFilesDirPath","getUniqueNameInFolder","name","toLowerCase","storeFileInSite","showAlertTranslated","factory","ɵfac","providedIn","CoreSharedFilesHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/sharedfiles/services/sharedfiles-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreFileUploader } from '@features/fileuploader/services/fileuploader';\nimport { CoreFileUploaderHandlerResult } from '@features/fileuploader/services/fileuploader-delegate';\nimport { CoreFile } from '@services/file';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { AlertController, ApplicationInit, makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSharedFilesListModalComponent } from '../components/list-modal/list-modal';\nimport { CoreSharedFiles } from './sharedfiles';\nimport { SHAREDFILES_PAGE_NAME } from '../sharedfiles.module';\nimport { CoreSharedFilesChooseSitePage } from '../pages/choose-site/choose-site';\nimport { CoreError } from '@classes/errors/error';\nimport { CorePlatform } from '@services/platform';\n\n/**\n * Helper service to share files with the app.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreSharedFilesHelperProvider {\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreSharedFilesHelperProvider');\n    }\n\n    /**\n     * Initialize.\n     */\n    initialize(): void {\n        if (!CorePlatform.isIOS()) {\n            return;\n        }\n\n        let lastCheck = Date.now();\n\n        // Check if there are new files at app start and when the app is resumed.\n        this.searchIOSNewSharedFiles();\n\n        CorePlatform.resume.subscribe(() => {\n            // Wait a bit to make sure that APP_LAUNCHED_URL is treated before this callback.\n            setTimeout(() => {\n                if (Date.now() - lastCheck < 1000) {\n                    // Last check less than 1s ago, don't do anything.\n                    return;\n                }\n\n                lastCheck = Date.now();\n                this.searchIOSNewSharedFiles();\n            }, 200);\n        });\n\n        CoreEvents.on(CoreEvents.APP_LAUNCHED_URL, (data) => {\n            if (data.url.indexOf('file://') === 0) {\n                // We received a file in iOS, it's probably a shared file. Treat it.\n                lastCheck = Date.now();\n                this.searchIOSNewSharedFiles(data.url);\n            }\n        });\n    }\n\n    /**\n     * Ask a user if he wants to replace a file (using originalName) or rename it (using newName).\n     *\n     * @param originalName Original name.\n     * @param newName New name.\n     * @returns Promise resolved with the name to use when the user chooses. Rejected if user cancels.\n     */\n    async askRenameReplace(originalName: string, newName: string): Promise<string> {\n        const alert = await AlertController.create({\n            header: Translate.instant('core.sharedfiles.sharedfiles'),\n            message: Translate.instant('core.sharedfiles.chooseactionrepeatedfile', { $a: newName }),\n            buttons: [\n                {\n                    text: Translate.instant('core.sharedfiles.rename'),\n                    role: 'rename',\n                },\n                {\n                    text: Translate.instant('core.sharedfiles.replace'),\n                    role: 'replace',\n                },\n            ],\n        });\n\n        await alert.present();\n\n        const result = await alert.onDidDismiss();\n\n        if (result.role == 'rename') {\n            return newName;\n        } else if (result.role == 'replace') {\n            return originalName;\n        } else {\n            // Canceled.\n            throw new CoreCanceledError();\n        }\n    }\n\n    /**\n     * Go to the choose site view.\n     *\n     * @param filePath File path to send to the view.\n     * @param isInbox Whether the file is in the Inbox folder.\n     */\n    goToChooseSite(filePath: string, isInbox?: boolean): void {\n        if (CoreSites.isLoggedIn()) {\n            CoreNavigator.navigateToSitePath(`/${SHAREDFILES_PAGE_NAME}/choosesite`, {\n                params: { filePath, isInbox },\n            });\n        } else {\n            CoreNavigator.navigate(`/${SHAREDFILES_PAGE_NAME}/choosesite`, {\n                params: { filePath, isInbox },\n            });\n        }\n    }\n\n    /**\n     * Whether the user is already choosing a site to store a shared file.\n     *\n     * @returns Whether the user is already choosing a site to store a shared file.\n     */\n    protected isChoosingSite(): boolean {\n        return CoreNavigator.getCurrentRoute({ pageComponent: CoreSharedFilesChooseSitePage }) !== null;\n    }\n\n    /**\n     * Open the view to select a shared file.\n     *\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns Promise resolved when a file is picked, rejected if file picker is closed without selecting a file.\n     */\n    async pickSharedFile(mimetypes?: string[]): Promise<CoreFileUploaderHandlerResult> {\n        const file = await CoreDomUtils.openModal<FileEntry>({\n            component: CoreSharedFilesListModalComponent,\n            cssClass: 'core-modal-fullscreen',\n            componentProps: { mimetypes, pick: true },\n        });\n\n        if (!file) {\n            // User cancelled.\n            throw new CoreCanceledError();\n        }\n\n        const error = CoreFileUploader.isInvalidMimetype(mimetypes, file.fullPath);\n        if (error) {\n            throw new CoreError(error);\n        }\n\n        return {\n            path: file.fullPath,\n            treated: false,\n        };\n    }\n\n    /**\n     * Delete a shared file.\n     *\n     * @param fileEntry The file entry to delete.\n     * @param isInbox Whether the file is in the Inbox folder.\n     * @returns Promise resolved when done.\n     */\n    protected removeSharedFile(fileEntry: FileEntry, isInbox?: boolean): Promise<void> {\n        if (isInbox) {\n            return CoreSharedFiles.deleteInboxFile(fileEntry);\n        } else {\n            return CoreFile.removeFileByFileEntry(fileEntry);\n        }\n    }\n\n    /**\n     * Checks if there is a new file received in iOS and move it to the shared folder of current site.\n     * If more than one site is found, the user will have to choose the site where to store it in.\n     * If more than one file is found, treat only the first one.\n     *\n     * @param path Path to a file received when launching the app.\n     * @returns Promise resolved when done.\n     */\n    async searchIOSNewSharedFiles(path?: string): Promise<void> {\n        try {\n            await ApplicationInit.donePromise;\n\n            if (this.isChoosingSite()) {\n                // We're already treating a shared file. Abort.\n                return;\n            }\n\n            let fileEntry: FileEntry | undefined;\n            if (path) {\n                // The app was launched with the path to the file, get the file.\n                fileEntry = await CoreFile.getExternalFile(path);\n            } else {\n                // No path received, search if there is any file in the Inbox folder.\n                fileEntry = await CoreSharedFiles.checkIOSNewFiles();\n            }\n\n            if (!fileEntry) {\n                return;\n            }\n\n            const siteIds = await CoreSites.getSitesIds();\n\n            if (!siteIds.length) {\n                // No sites stored, show error and delete the file.\n                CoreDomUtils.showErrorModal('core.sharedfiles.errorreceivefilenosites', true);\n\n                return this.removeSharedFile(fileEntry, !path);\n            } else if (siteIds.length == 1) {\n                return this.storeSharedFileInSite(fileEntry, siteIds[0], !path);\n            } else if (!this.isChoosingSite()) {\n                this.goToChooseSite(fileEntry.toURL(), !path);\n            }\n        } catch (error) {\n            if (error) {\n                this.logger.error('Error searching iOS new shared files', error, path);\n            }\n        }\n    }\n\n    /**\n     * Store a shared file in a site's shared files folder.\n     *\n     * @param fileEntry Shared file entry.\n     * @param siteId Site ID. If not defined, current site.\n     * @param isInbox Whether the file is in the Inbox folder.\n     * @returns Promise resolved when done.\n     */\n    async storeSharedFileInSite(fileEntry: FileEntry, siteId?: string, isInbox?: boolean): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // First of all check if there's already a file with the same name in the shared files folder.\n        const sharedFilesDirPath = CoreSharedFiles.getSiteSharedFilesDirPath(siteId);\n\n        let newName = await CoreFile.getUniqueNameInFolder(sharedFilesDirPath, fileEntry.name);\n\n        if (newName.toLowerCase() != fileEntry.name.toLowerCase()) {\n            // Repeated name. Ask the user what he wants to do.\n            newName = await this.askRenameReplace(fileEntry.name, newName);\n        }\n\n        try {\n            await CoreSharedFiles.storeFileInSite(fileEntry, newName, siteId);\n        } catch (error) {\n            CoreDomUtils.showErrorModal(error || 'Error moving file.');\n        } finally {\n            this.removeSharedFile(fileEntry, isInbox);\n            CoreDomUtils.showAlertTranslated('core.success', 'core.sharedfiles.successstorefile');\n        }\n    }\n\n}\n\nexport const CoreSharedFilesHelper = makeSingleton(CoreSharedFilesHelperProvider);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}