{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Singleton with helper functions for objects.\n */\nexport class CoreObject {\n  /**\n   * Returns a value of an object and deletes it from the object.\n   *\n   * @param obj Object.\n   * @param key Key of the value to consume.\n   * @returns Whether objects are equal.\n   */\n  static consumeKey(obj, key) {\n    const value = obj[key];\n    delete obj[key];\n    return value;\n  }\n  /**\n   * Check if two objects have the same shape and the same leaf values.\n   *\n   * @param a First object.\n   * @param b Second object.\n   * @returns Whether objects are equal.\n   */\n  static deepEquals(a, b) {\n    return JSON.stringify(a) === JSON.stringify(b);\n  }\n  /**\n   * Get all the properties names of an object, including the inherited ones except the ones from Object.prototype.\n   *\n   * @param object Object to get its properties.\n   * @returns Set of property names.\n   */\n  static getAllPropertyNames(object) {\n    if (typeof object !== 'object' || object === null || object === Object.prototype) {\n      // Not an object or we already reached root level.\n      return new Set([]);\n    }\n    const properties = CoreObject.getAllPropertyNames(Object.getPrototypeOf(object));\n    Object.getOwnPropertyNames(object).forEach(property => properties.add(property));\n    return properties;\n  }\n  /**\n   * Check whether the given object is empty.\n   *\n   * @param object Object.\n   * @returns Whether the given object is empty.\n   */\n  static isEmpty(object) {\n    return Object.keys(object).length === 0;\n  }\n  static only(obj, keysOrRegex) {\n    const newObject = {};\n    if (Array.isArray(keysOrRegex)) {\n      for (const key of keysOrRegex) {\n        newObject[key] = obj[key];\n      }\n    } else {\n      const originalKeys = Object.keys(obj);\n      for (const key of originalKeys) {\n        if (key.match(keysOrRegex)) {\n          newObject[key] = obj[key];\n        }\n      }\n    }\n    return newObject;\n  }\n  /**\n   * Create a new object without the specified keys.\n   *\n   * @param obj Object.\n   * @param keys Keys to remove from the new object.\n   * @returns New object without the specified keys.\n   */\n  static without(obj, keys) {\n    const newObject = _objectSpread({}, obj);\n    for (const key of keys) {\n      delete newObject[key];\n    }\n    return newObject;\n  }\n  /**\n   * Create a new object without empty values (null or undefined).\n   *\n   * @param obj Objet.\n   * @returns New object without empty values.\n   */\n  static withoutEmpty(obj) {\n    const cleanObj = {};\n    for (const [key, value] of Object.entries(obj)) {\n      if (value === null || value === undefined) {\n        continue;\n      }\n      cleanObj[key] = value;\n    }\n    return cleanObj;\n  }\n  /**\n   * Create a new object without undefined values.\n   *\n   * @param obj Objet.\n   * @returns New object without undefined values.\n   */\n  static withoutUndefined(obj) {\n    const cleanObj = {};\n    for (const [key, value] of Object.entries(obj)) {\n      if (value === undefined) {\n        continue;\n      }\n      cleanObj[key] = value;\n    }\n    return cleanObj;\n  }\n}","map":{"version":3,"names":["CoreObject","consumeKey","obj","key","value","deepEquals","a","b","JSON","stringify","getAllPropertyNames","object","Object","prototype","Set","properties","getPrototypeOf","getOwnPropertyNames","forEach","property","add","isEmpty","keys","length","only","keysOrRegex","newObject","Array","isArray","originalKeys","match","without","_objectSpread","withoutEmpty","cleanObj","entries","undefined","withoutUndefined"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/singletons/object.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Pretty } from '@/core/utils/types';\n\ntype ValueWithoutEmpty<T> = T extends null | undefined ? never : T;\ntype ValueWithoutUndefined<T> = T extends undefined ? never : T;\n\nexport type CoreObjectWithoutEmpty<T> = Pretty<{\n    [k in keyof T]: ValueWithoutEmpty<T[k]>;\n}>;\n\nexport type CoreObjectWithoutUndefined<T> = Pretty<{\n    [k in keyof T]: ValueWithoutUndefined<T[k]>;\n}>;\n\n/**\n * Singleton with helper functions for objects.\n */\nexport class CoreObject {\n\n    /**\n     * Returns a value of an object and deletes it from the object.\n     *\n     * @param obj Object.\n     * @param key Key of the value to consume.\n     * @returns Whether objects are equal.\n     */\n    static consumeKey<T, K extends keyof T>(obj: T, key: K): T[K] {\n        const value = obj[key];\n        delete obj[key];\n\n        return value;\n    }\n\n    /**\n     * Check if two objects have the same shape and the same leaf values.\n     *\n     * @param a First object.\n     * @param b Second object.\n     * @returns Whether objects are equal.\n     */\n    static deepEquals<T=unknown>(a: T, b: T): boolean {\n        return JSON.stringify(a) === JSON.stringify(b);\n    }\n\n    /**\n     * Get all the properties names of an object, including the inherited ones except the ones from Object.prototype.\n     *\n     * @param object Object to get its properties.\n     * @returns Set of property names.\n     */\n    static getAllPropertyNames(object: unknown): Set<string> {\n        if (typeof object !== 'object' || object === null || object === Object.prototype) {\n            // Not an object or we already reached root level.\n            return new Set<string>([]);\n        }\n\n        const properties = CoreObject.getAllPropertyNames(Object.getPrototypeOf(object));\n\n        Object.getOwnPropertyNames(object).forEach(property => properties.add(property));\n\n        return properties;\n    }\n\n    /**\n     * Check whether the given object is empty.\n     *\n     * @param object Object.\n     * @returns Whether the given object is empty.\n     */\n    static isEmpty(object: Record<string, unknown>): boolean {\n        return Object.keys(object).length === 0;\n    }\n\n    /**\n     * Return an object including only certain keys.\n     *\n     * @param obj Object.\n     * @param keysOrRegex If array is supplied, keys to include. Otherwise, regular expression used to filter keys.\n     * @returns New object with only the specified keys.\n     */\n    static only<T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;\n    static only<T extends object>(obj: T, regex: RegExp): Partial<T>;\n    static only<T extends object, K extends keyof T>(obj: T, keysOrRegex: K[] | RegExp): Pick<T, K> | Partial<T> {\n        const newObject: Partial<T> = {};\n\n        if (Array.isArray(keysOrRegex)) {\n            for (const key of keysOrRegex) {\n                newObject[key] = obj[key];\n            }\n        } else {\n            const originalKeys = Object.keys(obj);\n\n            for (const key of originalKeys) {\n                if (key.match(keysOrRegex)) {\n                    newObject[key] = obj[key];\n                }\n            }\n        }\n\n        return newObject;\n    }\n\n    /**\n     * Create a new object without the specified keys.\n     *\n     * @param obj Object.\n     * @param keys Keys to remove from the new object.\n     * @returns New object without the specified keys.\n     */\n    static without<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n        const newObject: T = { ...obj };\n\n        for (const key of keys) {\n            delete newObject[key];\n        }\n\n        return newObject;\n    }\n\n    /**\n     * Create a new object without empty values (null or undefined).\n     *\n     * @param obj Objet.\n     * @returns New object without empty values.\n     */\n    static withoutEmpty<T extends object>(obj: T): CoreObjectWithoutEmpty<T> {\n        const cleanObj = {};\n\n        for (const [key, value] of Object.entries(obj)) {\n            if (value === null || value === undefined) {\n                continue;\n            }\n\n            cleanObj[key] = value;\n        }\n\n        return cleanObj as CoreObjectWithoutEmpty<T>;\n    }\n\n    /**\n     * Create a new object without undefined values.\n     *\n     * @param obj Objet.\n     * @returns New object without undefined values.\n     */\n    static withoutUndefined<T extends object>(obj: T): CoreObjectWithoutUndefined<T> {\n        const cleanObj = {};\n\n        for (const [key, value] of Object.entries(obj)) {\n            if (value === undefined) {\n                continue;\n            }\n\n            cleanObj[key] = value;\n        }\n\n        return cleanObj as CoreObjectWithoutUndefined<T>;\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}