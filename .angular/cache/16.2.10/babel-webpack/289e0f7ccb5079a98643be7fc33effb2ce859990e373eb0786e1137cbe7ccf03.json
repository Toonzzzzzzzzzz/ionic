{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreFile } from '@services/file';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CorePath } from '@singletons/path';\nimport { CoreH5PCore } from './core';\nimport { CONTENTS_LIBRARIES_TABLE_NAME, CONTENT_TABLE_NAME } from '../services/database/h5p';\n/**\n * Equivalent to Moodle's implementation of H5PFileStorage.\n */\nexport class CoreH5PFileStorage {\n  /**\n   * Will concatenate all JavaScrips and Stylesheets into two files in order to improve page performance.\n   *\n   * @param files A set of all the assets required for content to display.\n   * @param key Hashed key for cached asset.\n   * @param folderName Name of the folder of the H5P package.\n   * @param siteId The site ID.\n   * @returns Promise resolved when done.\n   */\n  cacheAssets(files, key, folderName, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const cachedAssetsPath = _this.getCachedAssetsFolderPath(folderName, siteId);\n      // Treat each type in the assets.\n      yield Promise.all(Object.keys(files).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (type) {\n          const assets = files[type];\n          if (!assets || !assets.length) {\n            return;\n          }\n          // Create new file for cached assets.\n          const fileName = key + '.' + (type == 'scripts' ? 'js' : 'css');\n          const path = CorePath.concatenatePaths(cachedAssetsPath, fileName);\n          // Store concatenated content.\n          const content = yield _this.concatenateFiles(assets, type, cachedAssetsPath);\n          yield CoreFile.writeFile(path, content);\n          // Now update the files data.\n          files[type] = [{\n            path: CorePath.concatenatePaths(CoreH5PFileStorage.CACHED_ASSETS_FOLDER_NAME, fileName),\n            version: ''\n          }];\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Adds all files of a type into one file.\n   *\n   * @param assets A list of files.\n   * @param type The type of files in assets. Either 'scripts' or 'styles'.\n   * @param newFolder The new folder where the concatenated content will be stored.\n   * @returns Promise resolved with all of the files content in one string.\n   */\n  concatenateFiles(assets, type, newFolder) {\n    return _asyncToGenerator(function* () {\n      let content = '';\n      for (const i in assets) {\n        const asset = assets[i];\n        let fileContent = yield CoreFile.readFile(asset.path);\n        if (type == 'scripts') {\n          // No need to treat scripts, just append the content.\n          content += fileContent + ';\\n';\n          continue;\n        }\n        // Rewrite relative URLs used inside stylesheets.\n        const matches = fileContent.match(/url\\(['\"]?([^\"')]+)['\"]?\\)/ig);\n        const assetPath = asset.path.replace(/(^\\/|\\/$)/g, ''); // Path without start/end slashes.\n        const treated = {};\n        if (matches && matches.length) {\n          matches.forEach(match => {\n            const url = match.replace(/(url\\(['\"]?|['\"]?\\)$)/ig, '');\n            if (treated[url] || url.match(/^(data:|([a-z0-9]+:)?\\/)/i)) {\n              return; // Not relative or already treated, skip.\n            }\n\n            treated[url] = url;\n            const assetPathFolder = CoreFile.getFileAndDirectoryFromPath(assetPath).directory;\n            fileContent = fileContent.replace(new RegExp(CoreTextUtils.escapeForRegex(match), 'g'), 'url(\"' + CorePath.changeRelativePath(assetPathFolder, url, newFolder) + '\")');\n          });\n        }\n        content += fileContent + '\\n';\n      }\n      return content;\n    })();\n  }\n  /**\n   * Delete cached assets from file system.\n   *\n   * @param removedEntries Assets to remove.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteCachedAssets(removedEntries, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const promises = [];\n      removedEntries.forEach(entry => {\n        const cachedAssetsFolder = _this2.getCachedAssetsFolderPath(entry.foldername, site.getId());\n        ['js', 'css'].forEach(type => {\n          const path = CorePath.concatenatePaths(cachedAssetsFolder, entry.hash + '.' + type);\n          promises.push(CoreFile.removeFile(path));\n        });\n      });\n      // Ignore errors, maybe there's no cached asset of some type.\n      yield CoreUtils.ignoreErrors(CoreUtils.allPromises(promises));\n    })();\n  }\n  /**\n   * Deletes a content folder from the file system.\n   *\n   * @param folderName Folder name of the content.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteContentFolder(folderName, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreFile.removeDir(_this3.getContentFolderPath(folderName, siteId));\n    })();\n  }\n  /**\n   * Delete content indexes from filesystem.\n   *\n   * @param folderName Name of the folder of the H5P package.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteContentIndex(folderName, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreFile.removeFile(_this4.getContentIndexPath(folderName, siteId));\n    })();\n  }\n  /**\n   * Delete content indexes from filesystem.\n   *\n   * @param libraryId Library identifier.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteContentIndexesForLibrary(libraryId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const db = site.getDb();\n      // Get the folder names of all the packages that use this library.\n      const query = 'SELECT DISTINCT hc.foldername ' + 'FROM ' + CONTENTS_LIBRARIES_TABLE_NAME + ' hcl ' + 'JOIN ' + CONTENT_TABLE_NAME + ' hc ON hcl.h5pid = hc.id ' + 'WHERE hcl.libraryid = ?';\n      const queryArgs = [libraryId];\n      const result = yield db.execute(query, queryArgs);\n      yield Array.from(result.rows).map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (entry) {\n          try {\n            // Delete the index.html.\n            yield _this5.deleteContentIndex(entry.foldername, site.getId());\n          } catch (_unused) {\n            // Ignore errors.\n          }\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  /**\n   * Deletes a library from the file system.\n   *\n   * @param libraryData The library data.\n   * @param siteId Site ID.\n   * @param folderName Folder name. If not provided, it will be calculated.\n   * @returns Promise resolved when done.\n   */\n  deleteLibraryFolder(libraryData, siteId, folderName) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreFile.removeDir(_this6.getLibraryFolderPath(libraryData, siteId, folderName));\n    })();\n  }\n  /**\n   * Will check if there are cache assets available for content.\n   *\n   * @param key Hashed key for cached asset\n   * @returns Promise resolved with the files.\n   */\n  getCachedAssets(key) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      // Get JS and CSS cached assets if they exist.\n      const results = yield Promise.all([_this7.getCachedAsset(key, '.js'), _this7.getCachedAsset(key, '.css')]);\n      const files = {\n        scripts: results[0],\n        styles: results[1]\n      };\n      return files.scripts || files.styles ? files : null;\n    })();\n  }\n  /**\n   * Check if a cached asset file exists and, if so, return its data.\n   *\n   * @param key Key of the cached asset.\n   * @param extension Extension of the file to get.\n   * @returns Promise resolved with the list of assets (only one), undefined if not found.\n   */\n  getCachedAsset(key, extension) {\n    return _asyncToGenerator(function* () {\n      try {\n        const path = CorePath.concatenatePaths(CoreH5PFileStorage.CACHED_ASSETS_FOLDER_NAME, key + extension);\n        const size = yield CoreFile.getFileSize(path);\n        if (size > 0) {\n          return [{\n            path: path,\n            version: ''\n          }];\n        }\n      } catch (error) {\n        // Not found, nothing to do.\n      }\n    })();\n  }\n  /**\n   * Get relative path to a content cached assets.\n   *\n   * @param folderName Name of the folder of the content the assets belong to.\n   * @param siteId Site ID.\n   * @returns Path.\n   */\n  getCachedAssetsFolderPath(folderName, siteId) {\n    return CorePath.concatenatePaths(this.getContentFolderPath(folderName, siteId), CoreH5PFileStorage.CACHED_ASSETS_FOLDER_NAME);\n  }\n  /**\n   * Get a content folder name given the package URL.\n   *\n   * @param fileUrl Package URL.\n   * @param siteId Site ID.\n   * @returns Promise resolved with the folder name.\n   */\n  getContentFolderNameByUrl(fileUrl, siteId) {\n    return _asyncToGenerator(function* () {\n      const path = yield CoreFilepool.getFilePathByUrl(siteId, fileUrl);\n      const fileAndDir = CoreFile.getFileAndDirectoryFromPath(path);\n      return CoreMimetypeUtils.removeExtension(fileAndDir.name);\n    })();\n  }\n  /**\n   * Get a package content path.\n   *\n   * @param folderName Name of the folder of the H5P package.\n   * @param siteId The site ID.\n   * @returns Folder path.\n   */\n  getContentFolderPath(folderName, siteId) {\n    return CorePath.concatenatePaths(this.getExternalH5PFolderPath(siteId), 'packages/' + folderName + '/content');\n  }\n  /**\n   * Get the content index file.\n   *\n   * @param fileUrl URL of the H5P package.\n   * @param siteId The site ID. If not defined, current site.\n   * @returns Promise resolved with the file URL if exists, rejected otherwise.\n   */\n  getContentIndexFileUrl(fileUrl, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const folderName = yield _this8.getContentFolderNameByUrl(fileUrl, siteId);\n      const file = yield CoreFile.getFile(_this8.getContentIndexPath(folderName, siteId));\n      return file.toURL();\n    })();\n  }\n  /**\n   * Get the path to a content index.\n   *\n   * @param folderName Name of the folder of the H5P package.\n   * @param siteId The site ID.\n   * @returns Folder path.\n   */\n  getContentIndexPath(folderName, siteId) {\n    return CorePath.concatenatePaths(this.getContentFolderPath(folderName, siteId), 'index.html');\n  }\n  /**\n   * Get the path to the folder that contains the H5P core libraries.\n   *\n   * @returns Folder path.\n   */\n  getCoreH5PPath() {\n    return CorePath.concatenatePaths(CoreFile.getWWWPath(), '/assets/lib/h5p/');\n  }\n  /**\n   * Get the path to the dependency.\n   *\n   * @param dependency Dependency library.\n   * @returns The path to the dependency library\n   */\n  getDependencyPath(dependency) {\n    return 'libraries/' + CoreH5PCore.libraryToFolderName(dependency);\n  }\n  /**\n   * Get path to the folder containing H5P files extracted from packages.\n   *\n   * @param siteId The site ID.\n   * @returns Folder path.\n   */\n  getExternalH5PFolderPath(siteId) {\n    return CorePath.concatenatePaths(CoreFile.getSiteFolder(siteId), 'h5p');\n  }\n  /**\n   * Get libraries folder path.\n   *\n   * @param siteId The site ID.\n   * @returns Folder path.\n   */\n  getLibrariesFolderPath(siteId) {\n    return CorePath.concatenatePaths(this.getExternalH5PFolderPath(siteId), 'libraries');\n  }\n  /**\n   * Get a library's folder path.\n   *\n   * @param libraryData The library data.\n   * @param siteId The site ID.\n   * @param folderName Folder name. If not provided, it will be calculated.\n   * @returns Folder path.\n   */\n  getLibraryFolderPath(libraryData, siteId, folderName) {\n    if (!folderName) {\n      folderName = CoreH5PCore.libraryToFolderName(libraryData);\n    }\n    return CorePath.concatenatePaths(this.getLibrariesFolderPath(siteId), folderName);\n  }\n  /**\n   * Save the content in filesystem.\n   *\n   * @param contentPath Path to the current content folder (tmp).\n   * @param folderName Name to put to the content folder.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  saveContent(contentPath, folderName, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const folderPath = _this9.getContentFolderPath(folderName, siteId);\n      // Delete existing content for this package.\n      yield CoreUtils.ignoreErrors(CoreFile.removeDir(folderPath));\n      // Copy the new one.\n      yield CoreFile.moveDir(contentPath, folderPath);\n    })();\n  }\n  /**\n   * Save a library in filesystem.\n   *\n   * @param libraryData Library data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  saveLibrary(libraryData, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const folderPath = _this10.getLibraryFolderPath(libraryData, siteId);\n      // Delete existing library version.\n      try {\n        yield CoreFile.removeDir(folderPath);\n      } catch (_unused2) {\n        // Ignore errors, maybe it doesn't exist.\n      }\n      if (libraryData.uploadDirectory) {\n        // Copy the new one.\n        yield CoreFile.moveDir(libraryData.uploadDirectory, folderPath, true);\n      }\n    })();\n  }\n}\n_class = CoreH5PFileStorage;\n_class.CACHED_ASSETS_FOLDER_NAME = 'cachedassets';","map":{"version":3,"names":["CoreFile","CoreFilepool","CoreSites","CoreMimetypeUtils","CoreTextUtils","CoreUtils","CorePath","CoreH5PCore","CONTENTS_LIBRARIES_TABLE_NAME","CONTENT_TABLE_NAME","CoreH5PFileStorage","cacheAssets","files","key","folderName","siteId","_this","_asyncToGenerator","cachedAssetsPath","getCachedAssetsFolderPath","Promise","all","Object","keys","map","_ref","type","assets","length","fileName","path","concatenatePaths","content","concatenateFiles","writeFile","CACHED_ASSETS_FOLDER_NAME","version","_x","apply","arguments","newFolder","i","asset","fileContent","readFile","matches","match","assetPath","replace","treated","forEach","url","assetPathFolder","getFileAndDirectoryFromPath","directory","RegExp","escapeForRegex","changeRelativePath","deleteCachedAssets","removedEntries","_this2","site","getSite","promises","entry","cachedAssetsFolder","foldername","getId","hash","push","removeFile","ignoreErrors","allPromises","deleteContentFolder","_this3","removeDir","getContentFolderPath","deleteContentIndex","_this4","getContentIndexPath","deleteContentIndexesForLibrary","libraryId","_this5","db","getDb","query","queryArgs","result","execute","Array","from","rows","_ref2","_unused","_x2","deleteLibraryFolder","libraryData","_this6","getLibraryFolderPath","getCachedAssets","_this7","results","getCachedAsset","scripts","styles","extension","size","getFileSize","error","getContentFolderNameByUrl","fileUrl","getFilePathByUrl","fileAndDir","removeExtension","name","getExternalH5PFolderPath","getContentIndexFileUrl","_this8","getCurrentSiteId","file","getFile","toURL","getCoreH5PPath","getWWWPath","getDependencyPath","dependency","libraryToFolderName","getSiteFolder","getLibrariesFolderPath","saveContent","contentPath","_this9","folderPath","moveDir","saveLibrary","_this10","_unused2","uploadDirectory","_class"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/h5p/classes/file-storage.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreFile } from '@services/file';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CorePath } from '@singletons/path';\nimport {\n    CoreH5PCore,\n    CoreH5PDependencyAsset,\n    CoreH5PContentDependencyData,\n    CoreH5PDependenciesFiles,\n    CoreH5PLibraryBasicData,\n    CoreH5PContentMainLibraryData,\n} from './core';\nimport { CONTENTS_LIBRARIES_TABLE_NAME, CONTENT_TABLE_NAME, CoreH5PLibraryCachedAssetsDBRecord } from '../services/database/h5p';\nimport { CoreH5PLibraryBeingSaved } from './storage';\n\n/**\n * Equivalent to Moodle's implementation of H5PFileStorage.\n */\nexport class CoreH5PFileStorage {\n\n    static readonly CACHED_ASSETS_FOLDER_NAME = 'cachedassets';\n\n    /**\n     * Will concatenate all JavaScrips and Stylesheets into two files in order to improve page performance.\n     *\n     * @param files A set of all the assets required for content to display.\n     * @param key Hashed key for cached asset.\n     * @param folderName Name of the folder of the H5P package.\n     * @param siteId The site ID.\n     * @returns Promise resolved when done.\n     */\n    async cacheAssets(files: CoreH5PDependenciesFiles, key: string, folderName: string, siteId: string): Promise<void> {\n\n        const cachedAssetsPath = this.getCachedAssetsFolderPath(folderName, siteId);\n\n        // Treat each type in the assets.\n        await Promise.all(Object.keys(files).map(async (type) => {\n\n            const assets: CoreH5PDependencyAsset[] = files[type];\n\n            if (!assets || !assets.length) {\n                return;\n            }\n\n            // Create new file for cached assets.\n            const fileName = key + '.' + (type == 'scripts' ? 'js' : 'css');\n            const path = CorePath.concatenatePaths(cachedAssetsPath, fileName);\n\n            // Store concatenated content.\n            const content = await this.concatenateFiles(assets, type, cachedAssetsPath);\n\n            await CoreFile.writeFile(path, content);\n\n            // Now update the files data.\n            files[type] = [\n                {\n                    path: CorePath.concatenatePaths(CoreH5PFileStorage.CACHED_ASSETS_FOLDER_NAME, fileName),\n                    version: '',\n                },\n            ];\n        }));\n    }\n\n    /**\n     * Adds all files of a type into one file.\n     *\n     * @param assets A list of files.\n     * @param type The type of files in assets. Either 'scripts' or 'styles'.\n     * @param newFolder The new folder where the concatenated content will be stored.\n     * @returns Promise resolved with all of the files content in one string.\n     */\n    protected async concatenateFiles(assets: CoreH5PDependencyAsset[], type: string, newFolder: string): Promise<string> {\n        let content = '';\n\n        for (const i in assets) {\n            const asset = assets[i];\n\n            let fileContent = await CoreFile.readFile(asset.path);\n\n            if (type == 'scripts') {\n                // No need to treat scripts, just append the content.\n                content += fileContent + ';\\n';\n\n                continue;\n            }\n\n            // Rewrite relative URLs used inside stylesheets.\n            const matches = fileContent.match(/url\\(['\"]?([^\"')]+)['\"]?\\)/ig);\n            const assetPath = asset.path.replace(/(^\\/|\\/$)/g, ''); // Path without start/end slashes.\n            const treated: Record<string, string> = {};\n\n            if (matches && matches.length) {\n                matches.forEach((match) => {\n                    const url = match.replace(/(url\\(['\"]?|['\"]?\\)$)/ig, '');\n\n                    if (treated[url] || url.match(/^(data:|([a-z0-9]+:)?\\/)/i)) {\n                        return; // Not relative or already treated, skip.\n                    }\n\n                    treated[url] = url;\n                    const assetPathFolder = CoreFile.getFileAndDirectoryFromPath(assetPath).directory;\n\n                    fileContent = fileContent.replace(\n                        new RegExp(CoreTextUtils.escapeForRegex(match), 'g'),\n                        'url(\"' + CorePath.changeRelativePath(assetPathFolder, url, newFolder) + '\")',\n                    );\n                });\n            }\n\n            content += fileContent + '\\n';\n        }\n\n        return content;\n    }\n\n    /**\n     * Delete cached assets from file system.\n     *\n     * @param removedEntries Assets to remove.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteCachedAssets(removedEntries: CoreH5PLibraryCachedAssetsDBRecord[], siteId?: string): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const promises: Promise<void>[] = [];\n\n        removedEntries.forEach((entry) => {\n            const cachedAssetsFolder = this.getCachedAssetsFolderPath(entry.foldername, site.getId());\n\n            ['js', 'css'].forEach((type) => {\n                const path = CorePath.concatenatePaths(cachedAssetsFolder, entry.hash + '.' + type);\n\n                promises.push(CoreFile.removeFile(path));\n            });\n        });\n\n        // Ignore errors, maybe there's no cached asset of some type.\n        await CoreUtils.ignoreErrors(CoreUtils.allPromises(promises));\n    }\n\n    /**\n     * Deletes a content folder from the file system.\n     *\n     * @param folderName Folder name of the content.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteContentFolder(folderName: string, siteId: string): Promise<void> {\n        await CoreFile.removeDir(this.getContentFolderPath(folderName, siteId));\n    }\n\n    /**\n     * Delete content indexes from filesystem.\n     *\n     * @param folderName Name of the folder of the H5P package.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteContentIndex(folderName: string, siteId: string): Promise<void> {\n        await CoreFile.removeFile(this.getContentIndexPath(folderName, siteId));\n    }\n\n    /**\n     * Delete content indexes from filesystem.\n     *\n     * @param libraryId Library identifier.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteContentIndexesForLibrary(libraryId: number, siteId?: string): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const db = site.getDb();\n\n        // Get the folder names of all the packages that use this library.\n        const query = 'SELECT DISTINCT hc.foldername ' +\n                    'FROM ' + CONTENTS_LIBRARIES_TABLE_NAME + ' hcl ' +\n                    'JOIN ' + CONTENT_TABLE_NAME + ' hc ON hcl.h5pid = hc.id ' +\n                    'WHERE hcl.libraryid = ?';\n        const queryArgs = [libraryId];\n\n        const result = await db.execute(query, queryArgs);\n\n        await Array.from(result.rows).map(async (entry: {foldername: string}) => {\n            try {\n                // Delete the index.html.\n                await this.deleteContentIndex(entry.foldername, site.getId());\n            } catch {\n                // Ignore errors.\n            }\n        });\n    }\n\n    /**\n     * Deletes a library from the file system.\n     *\n     * @param libraryData The library data.\n     * @param siteId Site ID.\n     * @param folderName Folder name. If not provided, it will be calculated.\n     * @returns Promise resolved when done.\n     */\n    async deleteLibraryFolder(\n        libraryData: CoreH5PLibraryBasicData | CoreH5PContentMainLibraryData,\n        siteId: string,\n        folderName?: string,\n    ): Promise<void> {\n        await CoreFile.removeDir(this.getLibraryFolderPath(libraryData, siteId, folderName));\n    }\n\n    /**\n     * Will check if there are cache assets available for content.\n     *\n     * @param key Hashed key for cached asset\n     * @returns Promise resolved with the files.\n     */\n    async getCachedAssets(key: string): Promise<{scripts?: CoreH5PDependencyAsset[]; styles?: CoreH5PDependencyAsset[]} | null> {\n\n        // Get JS and CSS cached assets if they exist.\n        const results = await Promise.all([\n            this.getCachedAsset(key, '.js'),\n            this.getCachedAsset(key, '.css'),\n        ]);\n\n        const files = {\n            scripts: results[0],\n            styles: results[1],\n        };\n\n        return files.scripts || files.styles ? files : null;\n    }\n\n    /**\n     * Check if a cached asset file exists and, if so, return its data.\n     *\n     * @param key Key of the cached asset.\n     * @param extension Extension of the file to get.\n     * @returns Promise resolved with the list of assets (only one), undefined if not found.\n     */\n    protected async getCachedAsset(key: string, extension: string): Promise<CoreH5PDependencyAsset[] | undefined> {\n\n        try {\n            const path = CorePath.concatenatePaths(CoreH5PFileStorage.CACHED_ASSETS_FOLDER_NAME, key + extension);\n\n            const size = await CoreFile.getFileSize(path);\n\n            if (size > 0) {\n                return [\n                    {\n                        path: path,\n                        version: '',\n                    },\n                ];\n            }\n        } catch (error) {\n            // Not found, nothing to do.\n        }\n    }\n\n    /**\n     * Get relative path to a content cached assets.\n     *\n     * @param folderName Name of the folder of the content the assets belong to.\n     * @param siteId Site ID.\n     * @returns Path.\n     */\n    getCachedAssetsFolderPath(folderName: string, siteId: string): string {\n        return CorePath.concatenatePaths(\n            this.getContentFolderPath(folderName, siteId),\n            CoreH5PFileStorage.CACHED_ASSETS_FOLDER_NAME,\n        );\n    }\n\n    /**\n     * Get a content folder name given the package URL.\n     *\n     * @param fileUrl Package URL.\n     * @param siteId Site ID.\n     * @returns Promise resolved with the folder name.\n     */\n    async getContentFolderNameByUrl(fileUrl: string, siteId: string): Promise<string> {\n        const path = await CoreFilepool.getFilePathByUrl(siteId, fileUrl);\n\n        const fileAndDir = CoreFile.getFileAndDirectoryFromPath(path);\n\n        return CoreMimetypeUtils.removeExtension(fileAndDir.name);\n    }\n\n    /**\n     * Get a package content path.\n     *\n     * @param folderName Name of the folder of the H5P package.\n     * @param siteId The site ID.\n     * @returns Folder path.\n     */\n    getContentFolderPath(folderName: string, siteId: string): string {\n        return CorePath.concatenatePaths(\n            this.getExternalH5PFolderPath(siteId),\n            'packages/' + folderName + '/content',\n        );\n    }\n\n    /**\n     * Get the content index file.\n     *\n     * @param fileUrl URL of the H5P package.\n     * @param siteId The site ID. If not defined, current site.\n     * @returns Promise resolved with the file URL if exists, rejected otherwise.\n     */\n    async getContentIndexFileUrl(fileUrl: string, siteId?: string): Promise<string> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const folderName = await this.getContentFolderNameByUrl(fileUrl, siteId);\n\n        const file = await CoreFile.getFile(this.getContentIndexPath(folderName, siteId));\n\n        return file.toURL();\n    }\n\n    /**\n     * Get the path to a content index.\n     *\n     * @param folderName Name of the folder of the H5P package.\n     * @param siteId The site ID.\n     * @returns Folder path.\n     */\n    getContentIndexPath(folderName: string, siteId: string): string {\n        return CorePath.concatenatePaths(this.getContentFolderPath(folderName, siteId), 'index.html');\n    }\n\n    /**\n     * Get the path to the folder that contains the H5P core libraries.\n     *\n     * @returns Folder path.\n     */\n    getCoreH5PPath(): string {\n        return CorePath.concatenatePaths(CoreFile.getWWWPath(), '/assets/lib/h5p/');\n    }\n\n    /**\n     * Get the path to the dependency.\n     *\n     * @param dependency Dependency library.\n     * @returns The path to the dependency library\n     */\n    getDependencyPath(dependency: CoreH5PContentDependencyData): string {\n        return 'libraries/' + CoreH5PCore.libraryToFolderName(dependency);\n    }\n\n    /**\n     * Get path to the folder containing H5P files extracted from packages.\n     *\n     * @param siteId The site ID.\n     * @returns Folder path.\n     */\n    getExternalH5PFolderPath(siteId: string): string {\n        return CorePath.concatenatePaths(CoreFile.getSiteFolder(siteId), 'h5p');\n    }\n\n    /**\n     * Get libraries folder path.\n     *\n     * @param siteId The site ID.\n     * @returns Folder path.\n     */\n    getLibrariesFolderPath(siteId: string): string {\n        return CorePath.concatenatePaths(this.getExternalH5PFolderPath(siteId), 'libraries');\n    }\n\n    /**\n     * Get a library's folder path.\n     *\n     * @param libraryData The library data.\n     * @param siteId The site ID.\n     * @param folderName Folder name. If not provided, it will be calculated.\n     * @returns Folder path.\n     */\n    getLibraryFolderPath(\n        libraryData: CoreH5PLibraryBasicData | CoreH5PContentMainLibraryData,\n        siteId: string,\n        folderName?: string,\n    ): string {\n        if (!folderName) {\n            folderName = CoreH5PCore.libraryToFolderName(libraryData);\n        }\n\n        return CorePath.concatenatePaths(this.getLibrariesFolderPath(siteId), folderName);\n    }\n\n    /**\n     * Save the content in filesystem.\n     *\n     * @param contentPath Path to the current content folder (tmp).\n     * @param folderName Name to put to the content folder.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    async saveContent(contentPath: string, folderName: string, siteId: string): Promise<void> {\n        const folderPath = this.getContentFolderPath(folderName, siteId);\n\n        // Delete existing content for this package.\n        await CoreUtils.ignoreErrors(CoreFile.removeDir(folderPath));\n\n        // Copy the new one.\n        await CoreFile.moveDir(contentPath, folderPath);\n    }\n\n    /**\n     * Save a library in filesystem.\n     *\n     * @param libraryData Library data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async saveLibrary(libraryData: CoreH5PLibraryBeingSaved, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const folderPath = this.getLibraryFolderPath(libraryData, siteId);\n\n        // Delete existing library version.\n        try {\n            await CoreFile.removeDir(folderPath);\n        } catch {\n            // Ignore errors, maybe it doesn't exist.\n        }\n\n        if (libraryData.uploadDirectory) {\n            // Copy the new one.\n            await CoreFile.moveDir(libraryData.uploadDirectory, folderPath, true);\n        }\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}