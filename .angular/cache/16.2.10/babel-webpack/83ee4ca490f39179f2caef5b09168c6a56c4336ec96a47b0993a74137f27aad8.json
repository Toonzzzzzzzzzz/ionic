{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CorePromisedValue } from '@classes/promised-value';\n/**\n * Create a wrapper to hold an asynchronous instance.\n *\n * @param lazyConstructor Constructor to use the first time the instance is needed.\n * @returns Asynchronous instance wrapper.\n */\nfunction createAsyncInstanceWrapper(lazyConstructor) {\n  let promisedInstance = null;\n  let eagerInstance;\n  return {\n    get instance() {\n      var _promisedInstance$val, _promisedInstance;\n      return (_promisedInstance$val = (_promisedInstance = promisedInstance) === null || _promisedInstance === void 0 ? void 0 : _promisedInstance.value) !== null && _promisedInstance$val !== void 0 ? _promisedInstance$val : undefined;\n    },\n    get eagerInstance() {\n      return eagerInstance;\n    },\n    getInstance() {\n      return _asyncToGenerator(function* () {\n        if (!promisedInstance) {\n          promisedInstance = new CorePromisedValue();\n          if (lazyConstructor) {\n            const instance = yield lazyConstructor();\n            promisedInstance.resolve(instance);\n          }\n        }\n        return promisedInstance;\n      })();\n    },\n    getProperty(property) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const instance = yield _this.getInstance();\n        return instance[property];\n      })();\n    },\n    setInstance(instance) {\n      if (!promisedInstance) {\n        promisedInstance = new CorePromisedValue();\n      } else if (promisedInstance.isSettled()) {\n        promisedInstance.reset();\n      }\n      promisedInstance.resolve(instance);\n    },\n    setEagerInstance(instance) {\n      eagerInstance = instance;\n    },\n    setLazyConstructor(constructor) {\n      if (!promisedInstance) {\n        lazyConstructor = constructor;\n        return;\n      }\n      if (!promisedInstance.isResolved()) {\n        // eslint-disable-next-line promise/catch-or-return\n        Promise.resolve(constructor()).then(instance => {\n          var _promisedInstance2, _promisedInstance3;\n          return ((_promisedInstance2 = promisedInstance) === null || _promisedInstance2 === void 0 ? void 0 : _promisedInstance2.isResolved()) || ((_promisedInstance3 = promisedInstance) === null || _promisedInstance3 === void 0 ? void 0 : _promisedInstance3.resolve(instance));\n        });\n      }\n    },\n    resetInstance() {\n      if (!promisedInstance) {\n        return;\n      }\n      promisedInstance.reset();\n    }\n  };\n}\n/**\n * Check whether the given value is a method.\n *\n * @param value Value.\n * @returns Whether the given value is a method.\n */\nfunction isMethod(value) {\n  return typeof value === 'function';\n}\n/**\n * Create an asynchronous instance proxy, where all methods will be callable directly but will become asynchronous. If the\n * underlying instance hasn't been set, methods will be resolved once it is.\n *\n * @param lazyConstructor Constructor to use the first time the instance is needed.\n * @returns Asynchronous instance.\n */\nexport function asyncInstance(lazyConstructor) {\n  const wrapper = createAsyncInstanceWrapper(lazyConstructor);\n  return new Proxy(wrapper, {\n    get: (target, property, receiver) => {\n      if (property in target) {\n        return Reflect.get(target, property, receiver);\n      }\n      if (wrapper.instance) {\n        const value = Reflect.get(wrapper.instance, property, receiver);\n        return isMethod(value) ? /*#__PURE__*/_asyncToGenerator(function* (...args) {\n          return value.call(wrapper.instance, ...args);\n        }) : value;\n      }\n      if (wrapper.eagerInstance && property in wrapper.eagerInstance) {\n        return Reflect.get(wrapper.eagerInstance, property, receiver);\n      }\n      return /*#__PURE__*/_asyncToGenerator(function* (...args) {\n        const instance = yield wrapper.getInstance();\n        const method = Reflect.get(instance, property, receiver);\n        if (!isMethod(method)) {\n          throw new Error(`'${property.toString()}' is not a function`);\n        }\n        return method.call(instance, ...args);\n      });\n    }\n  });\n}","map":{"version":3,"names":["CorePromisedValue","createAsyncInstanceWrapper","lazyConstructor","promisedInstance","eagerInstance","instance","_promisedInstance$val","_promisedInstance","value","undefined","getInstance","_asyncToGenerator","resolve","getProperty","property","_this","setInstance","isSettled","reset","setEagerInstance","setLazyConstructor","constructor","isResolved","Promise","then","_promisedInstance2","_promisedInstance3","resetInstance","isMethod","asyncInstance","wrapper","Proxy","get","target","receiver","Reflect","args","call","method","Error","toString"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/utils/async-instance.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CorePromisedValue } from '@classes/promised-value';\n\n/**\n * Create a wrapper to hold an asynchronous instance.\n *\n * @param lazyConstructor Constructor to use the first time the instance is needed.\n * @returns Asynchronous instance wrapper.\n */\nfunction createAsyncInstanceWrapper<\n    TLazyInstance extends TEagerInstance,\n    TEagerInstance extends AsyncObject = Partial<TLazyInstance>\n>(\n    lazyConstructor?: () => TLazyInstance | Promise<TLazyInstance>,\n): AsyncInstanceWrapper<TLazyInstance, TEagerInstance> {\n    let promisedInstance: CorePromisedValue<TLazyInstance> | null = null;\n    let eagerInstance: TEagerInstance;\n\n    return {\n        get instance() {\n            return promisedInstance?.value ?? undefined;\n        },\n        get eagerInstance() {\n            return eagerInstance;\n        },\n        async getInstance() {\n            if (!promisedInstance) {\n                promisedInstance = new CorePromisedValue();\n\n                if (lazyConstructor) {\n                    const instance = await lazyConstructor();\n\n                    promisedInstance.resolve(instance);\n                }\n            }\n\n            return promisedInstance;\n        },\n        async getProperty(property) {\n            const instance = await this.getInstance();\n\n            return instance[property];\n        },\n        setInstance(instance) {\n            if (!promisedInstance) {\n                promisedInstance = new CorePromisedValue();\n            } else if (promisedInstance.isSettled()) {\n                promisedInstance.reset();\n            }\n\n            promisedInstance.resolve(instance);\n        },\n        setEagerInstance(instance) {\n            eagerInstance = instance;\n        },\n        setLazyConstructor(constructor) {\n            if (!promisedInstance) {\n                lazyConstructor = constructor;\n\n                return;\n            }\n\n            if (!promisedInstance.isResolved()) {\n                // eslint-disable-next-line promise/catch-or-return\n                Promise\n                    .resolve(constructor())\n                    .then(instance => promisedInstance?.isResolved() || promisedInstance?.resolve(instance));\n            }\n        },\n        resetInstance() {\n            if (!promisedInstance) {\n                return;\n            }\n\n            promisedInstance.reset();\n        },\n    };\n}\n\n/**\n * Check whether the given value is a method.\n *\n * @param value Value.\n * @returns Whether the given value is a method.\n */\nfunction isMethod(value: unknown): value is (...args: unknown[]) => unknown {\n    return typeof value === 'function';\n}\n\n/**\n * Asynchronous instance wrapper.\n */\nexport interface AsyncInstanceWrapper<\n    TLazyInstance extends TEagerInstance,\n    TEagerInstance extends AsyncObject = Partial<TLazyInstance>\n> {\n    instance?: TLazyInstance;\n    eagerInstance?: TEagerInstance;\n    getInstance(): Promise<TLazyInstance>;\n    getProperty<P extends keyof TLazyInstance>(property: P): Promise<TLazyInstance[P]>;\n    setInstance(instance: TLazyInstance): void;\n    setEagerInstance(eagerInstance: TEagerInstance): void;\n    setLazyConstructor(lazyConstructor: () => TLazyInstance | Promise<TLazyInstance>): void;\n    resetInstance(): void;\n}\n\nexport type AsyncObject = object;\n\n/**\n * Asynchronous version of a method.\n */\nexport type AsyncMethod<T> =\n    T extends (...args: infer Params) => infer Return\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ? T extends (...args: Params) => Promise<any>\n            ? T\n            : (...args: Params) => Promise<Return>\n        : never;\n\n/**\n * Asynchronous instance.\n *\n * All methods are converted to their asynchronous version, and properties are available asynchronously using\n * the getProperty method.\n */\nexport type AsyncInstance<TLazyInstance extends TEagerInstance, TEagerInstance extends AsyncObject = Partial<TLazyInstance>> =\n    AsyncInstanceWrapper<TLazyInstance, TEagerInstance> & {\n        [k in keyof TLazyInstance]: AsyncMethod<TLazyInstance[k]>;\n    };\n\n/**\n * Create an asynchronous instance proxy, where all methods will be callable directly but will become asynchronous. If the\n * underlying instance hasn't been set, methods will be resolved once it is.\n *\n * @param lazyConstructor Constructor to use the first time the instance is needed.\n * @returns Asynchronous instance.\n */\nexport function asyncInstance<TLazyInstance extends TEagerInstance, TEagerInstance extends AsyncObject = Partial<TLazyInstance>>(\n    lazyConstructor?: () => TLazyInstance | Promise<TLazyInstance>,\n): AsyncInstance<TLazyInstance, TEagerInstance> {\n    const wrapper = createAsyncInstanceWrapper<TLazyInstance, TEagerInstance>(lazyConstructor);\n\n    return new Proxy(wrapper, {\n        get: (target, property, receiver) => {\n            if (property in target) {\n                return Reflect.get(target, property, receiver);\n            }\n\n            if (wrapper.instance) {\n                const value = Reflect.get(wrapper.instance, property, receiver);\n\n                return isMethod(value)\n                    ? async (...args: unknown[]) => value.call(wrapper.instance, ...args)\n                    : value;\n            }\n\n            if (wrapper.eagerInstance && property in wrapper.eagerInstance) {\n                return Reflect.get(wrapper.eagerInstance, property, receiver);\n            }\n\n            return async (...args: unknown[]) => {\n                const instance = await wrapper.getInstance();\n                const method = Reflect.get(instance, property, receiver);\n\n                if (!isMethod(method)) {\n                    throw new Error(`'${property.toString()}' is not a function`);\n                }\n\n                return method.call(instance, ...args);\n            };\n        },\n    }) as AsyncInstance<TLazyInstance, TEagerInstance>;\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,iBAAiB,QAAQ,yBAAyB;AAE3D;;;;;;AAMA,SAASC,0BAA0BA,CAI/BC,eAA8D;EAE9D,IAAIC,gBAAgB,GAA4C,IAAI;EACpE,IAAIC,aAA6B;EAEjC,OAAO;IACH,IAAIC,QAAQA,CAAA;MAAA,IAAAC,qBAAA,EAAAC,iBAAA;MACR,QAAAD,qBAAA,IAAAC,iBAAA,GAAOJ,gBAAgB,cAAAI,iBAAA,uBAAhBA,iBAAA,CAAkBC,KAAK,cAAAF,qBAAA,cAAAA,qBAAA,GAAIG,SAAS;IAC/C,CAAC;IACD,IAAIL,aAAaA,CAAA;MACb,OAAOA,aAAa;IACxB,CAAC;IACKM,WAAWA,CAAA;MAAA,OAAAC,iBAAA;QACb,IAAI,CAACR,gBAAgB,EAAE;UACnBA,gBAAgB,GAAG,IAAIH,iBAAiB,EAAE;UAE1C,IAAIE,eAAe,EAAE;YACjB,MAAMG,QAAQ,SAASH,eAAe,EAAE;YAExCC,gBAAgB,CAACS,OAAO,CAACP,QAAQ,CAAC;;;QAI1C,OAAOF,gBAAgB;MAAC;IAC5B,CAAC;IACKU,WAAWA,CAACC,QAAQ;MAAA,IAAAC,KAAA;MAAA,OAAAJ,iBAAA;QACtB,MAAMN,QAAQ,SAASU,KAAI,CAACL,WAAW,EAAE;QAEzC,OAAOL,QAAQ,CAACS,QAAQ,CAAC;MAAC;IAC9B,CAAC;IACDE,WAAWA,CAACX,QAAQ;MAChB,IAAI,CAACF,gBAAgB,EAAE;QACnBA,gBAAgB,GAAG,IAAIH,iBAAiB,EAAE;OAC7C,MAAM,IAAIG,gBAAgB,CAACc,SAAS,EAAE,EAAE;QACrCd,gBAAgB,CAACe,KAAK,EAAE;;MAG5Bf,gBAAgB,CAACS,OAAO,CAACP,QAAQ,CAAC;IACtC,CAAC;IACDc,gBAAgBA,CAACd,QAAQ;MACrBD,aAAa,GAAGC,QAAQ;IAC5B,CAAC;IACDe,kBAAkBA,CAACC,WAAW;MAC1B,IAAI,CAAClB,gBAAgB,EAAE;QACnBD,eAAe,GAAGmB,WAAW;QAE7B;;MAGJ,IAAI,CAAClB,gBAAgB,CAACmB,UAAU,EAAE,EAAE;QAChC;QACAC,OAAO,CACFX,OAAO,CAACS,WAAW,EAAE,CAAC,CACtBG,IAAI,CAACnB,QAAQ;UAAA,IAAAoB,kBAAA,EAAAC,kBAAA;UAAA,OAAI,EAAAD,kBAAA,GAAAtB,gBAAgB,cAAAsB,kBAAA,uBAAhBA,kBAAA,CAAkBH,UAAU,EAAE,OAAAI,kBAAA,GAAIvB,gBAAgB,cAAAuB,kBAAA,uBAAhBA,kBAAA,CAAkBd,OAAO,CAACP,QAAQ,CAAC;QAAA,EAAC;;IAEpG,CAAC;IACDsB,aAAaA,CAAA;MACT,IAAI,CAACxB,gBAAgB,EAAE;QACnB;;MAGJA,gBAAgB,CAACe,KAAK,EAAE;IAC5B;GACH;AACL;AAEA;;;;;;AAMA,SAASU,QAAQA,CAACpB,KAAc;EAC5B,OAAO,OAAOA,KAAK,KAAK,UAAU;AACtC;AA2CA;;;;;;;AAOA,OAAM,SAAUqB,aAAaA,CACzB3B,eAA8D;EAE9D,MAAM4B,OAAO,GAAG7B,0BAA0B,CAAgCC,eAAe,CAAC;EAE1F,OAAO,IAAI6B,KAAK,CAACD,OAAO,EAAE;IACtBE,GAAG,EAAEA,CAACC,MAAM,EAAEnB,QAAQ,EAAEoB,QAAQ,KAAI;MAChC,IAAIpB,QAAQ,IAAImB,MAAM,EAAE;QACpB,OAAOE,OAAO,CAACH,GAAG,CAACC,MAAM,EAAEnB,QAAQ,EAAEoB,QAAQ,CAAC;;MAGlD,IAAIJ,OAAO,CAACzB,QAAQ,EAAE;QAClB,MAAMG,KAAK,GAAG2B,OAAO,CAACH,GAAG,CAACF,OAAO,CAACzB,QAAQ,EAAES,QAAQ,EAAEoB,QAAQ,CAAC;QAE/D,OAAON,QAAQ,CAACpB,KAAK,CAAC,gBAAAG,iBAAA,CAChB,WAAO,GAAGyB,IAAe;UAAA,OAAK5B,KAAK,CAAC6B,IAAI,CAACP,OAAO,CAACzB,QAAQ,EAAE,GAAG+B,IAAI,CAAC;QAAA,KACnE5B,KAAK;;MAGf,IAAIsB,OAAO,CAAC1B,aAAa,IAAIU,QAAQ,IAAIgB,OAAO,CAAC1B,aAAa,EAAE;QAC5D,OAAO+B,OAAO,CAACH,GAAG,CAACF,OAAO,CAAC1B,aAAa,EAAEU,QAAQ,EAAEoB,QAAQ,CAAC;;MAGjE,oBAAAvB,iBAAA,CAAO,WAAO,GAAGyB,IAAe,EAAI;QAChC,MAAM/B,QAAQ,SAASyB,OAAO,CAACpB,WAAW,EAAE;QAC5C,MAAM4B,MAAM,GAAGH,OAAO,CAACH,GAAG,CAAC3B,QAAQ,EAAES,QAAQ,EAAEoB,QAAQ,CAAC;QAExD,IAAI,CAACN,QAAQ,CAACU,MAAM,CAAC,EAAE;UACnB,MAAM,IAAIC,KAAK,CAAC,IAAIzB,QAAQ,CAAC0B,QAAQ,EAAE,qBAAqB,CAAC;;QAGjE,OAAOF,MAAM,CAACD,IAAI,CAAChC,QAAQ,EAAE,GAAG+B,IAAI,CAAC;MACzC,CAAC;IACL;GACH,CAAiD;AACtD"},"metadata":{},"sourceType":"module","externalDependencies":[]}