{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { makeSingleton } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport { SUBMISSIONS_GRADES_TABLE, SUBMISSIONS_TABLE } from './database/assign';\nimport { CoreArray } from '@singletons/array';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline assign.\n */\nexport class AddonModAssignOfflineProvider {\n  /**\n   * Delete a submission.\n   *\n   * @param assignId Assignment ID.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteSubmission(assignId, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.getDb().deleteRecords(SUBMISSIONS_TABLE, {\n        assignid: assignId,\n        userid: userId\n      });\n    })();\n  }\n  /**\n   * Delete a submission grade.\n   *\n   * @param assignId Assignment ID.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteSubmissionGrade(assignId, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.getDb().deleteRecords(SUBMISSIONS_GRADES_TABLE, {\n        assignid: assignId,\n        userid: userId\n      });\n    })();\n  }\n  /**\n   * Get all the assignments ids that have something to be synced.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with assignments id that have something to be synced.\n   */\n  getAllAssigns(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      promises.push(_this.getAllSubmissions(siteId));\n      promises.push(_this.getAllSubmissionsGrade(siteId));\n      const results = yield Promise.all(promises);\n      // Flatten array.\n      const flatten = CoreArray.flatten(results);\n      // Get assign id.\n      let assignIds = flatten.map(assign => assign.assignid);\n      // Get unique values.\n      assignIds = assignIds.filter((id, pos) => assignIds.indexOf(id) == pos);\n      return assignIds;\n    })();\n  }\n  /**\n   * Get all the stored submissions from all the assignments.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with submissions.\n   */\n  getAllSubmissions(siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.getAssignSubmissionsFormatted(undefined, siteId);\n    })();\n  }\n  /**\n   * Get all the stored submissions for a certain assignment.\n   *\n   * @param assignId Assignment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with submissions.\n   */\n  getAssignSubmissions(assignId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.getAssignSubmissionsFormatted({\n        assignid: assignId\n      }, siteId);\n    })();\n  }\n  /**\n   * Convenience helper function to get stored submissions formatted.\n   *\n   * @param conditions Query conditions.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with submissions.\n   */\n  getAssignSubmissionsFormatted(conditions = {}, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      const submissions = yield db.getRecords(SUBMISSIONS_TABLE, conditions);\n      // Parse the plugin data.\n      return submissions.map(submission => ({\n        assignid: submission.assignid,\n        userid: submission.userid,\n        courseid: submission.courseid,\n        plugindata: CoreTextUtils.parseJSON(submission.plugindata, {}),\n        onlinetimemodified: submission.onlinetimemodified,\n        timecreated: submission.timecreated,\n        timemodified: submission.timemodified,\n        submitted: submission.submitted,\n        submissionstatement: submission.submissionstatement\n      }));\n    })();\n  }\n  /**\n   * Get all the stored submissions grades from all the assignments.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with submissions grades.\n   */\n  getAllSubmissionsGrade(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4.getAssignSubmissionsGradeFormatted(undefined, siteId);\n    })();\n  }\n  /**\n   * Get all the stored submissions grades for a certain assignment.\n   *\n   * @param assignId Assignment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with submissions grades.\n   */\n  getAssignSubmissionsGrade(assignId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5.getAssignSubmissionsGradeFormatted({\n        assignid: assignId\n      }, siteId);\n    })();\n  }\n  /**\n   * Convenience helper function to get stored submissions grading formatted.\n   *\n   * @param conditions Query conditions.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with submissions grades.\n   */\n  getAssignSubmissionsGradeFormatted(conditions = {}, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      const submissions = yield db.getRecords(SUBMISSIONS_GRADES_TABLE, conditions);\n      // Parse the plugin data and outcomes.\n      return submissions.map(submission => ({\n        assignid: submission.assignid,\n        userid: submission.userid,\n        courseid: submission.courseid,\n        grade: submission.grade,\n        attemptnumber: submission.attemptnumber,\n        addattempt: submission.addattempt,\n        workflowstate: submission.workflowstate,\n        applytoall: submission.applytoall,\n        outcomes: CoreTextUtils.parseJSON(submission.outcomes, {}),\n        plugindata: CoreTextUtils.parseJSON(submission.plugindata, {}),\n        timemodified: submission.timemodified\n      }));\n    })();\n  }\n  /**\n   * Get a stored submission.\n   *\n   * @param assignId Assignment ID.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with submission.\n   */\n  getSubmission(assignId, userId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      userId = userId || CoreSites.getCurrentSiteUserId();\n      const submissions = yield _this6.getAssignSubmissionsFormatted({\n        assignid: assignId,\n        userid: userId\n      }, siteId);\n      if (submissions.length) {\n        return submissions[0];\n      }\n      throw new CoreError('No records found.');\n    })();\n  }\n  /**\n   * Get the path to the folder where to store files for an offline submission.\n   *\n   * @param assignId Assignment ID.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getSubmissionFolder(assignId, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const siteFolderPath = CoreFile.getSiteFolder(site.getId());\n      const submissionFolderPath = 'offlineassign/' + assignId + '/' + userId;\n      return CorePath.concatenatePaths(siteFolderPath, submissionFolderPath);\n    })();\n  }\n  /**\n   * Get a stored submission grade.\n   * Submission grades are not identified using attempt number so it can retrieve the feedback for a previous attempt.\n   *\n   * @param assignId Assignment ID.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with submission grade.\n   */\n  getSubmissionGrade(assignId, userId, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      userId = userId || CoreSites.getCurrentSiteUserId();\n      const submissions = yield _this7.getAssignSubmissionsGradeFormatted({\n        assignid: assignId,\n        userid: userId\n      }, siteId);\n      if (submissions.length) {\n        return submissions[0];\n      }\n      throw new CoreError('No records found.');\n    })();\n  }\n  /**\n   * Get the path to the folder where to store files for a certain plugin in an offline submission.\n   *\n   * @param assignId Assignment ID.\n   * @param pluginName Name of the plugin. Must be unique (both in submission and feedback plugins).\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getSubmissionPluginFolder(assignId, pluginName, userId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const folderPath = yield _this8.getSubmissionFolder(assignId, userId, siteId);\n      return CorePath.concatenatePaths(folderPath, pluginName);\n    })();\n  }\n  /**\n   * Check if the assignment has something to be synced.\n   *\n   * @param assignId Assignment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether the assignment has something to be synced.\n   */\n  hasAssignOfflineData(assignId, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      promises.push(_this9.getAssignSubmissions(assignId, siteId));\n      promises.push(_this9.getAssignSubmissionsGrade(assignId, siteId));\n      try {\n        const results = yield Promise.all(promises);\n        return results.some(result => result.length);\n      } catch (_unused) {\n        // No offline data found.\n        return false;\n      }\n    })();\n  }\n  /**\n   * Mark/Unmark a submission as being submitted.\n   *\n   * @param assignId Assignment ID.\n   * @param courseId Course ID the assign belongs to.\n   * @param submitted True to mark as submitted, false to mark as not submitted.\n   * @param acceptStatement True to accept the submission statement, false otherwise.\n   * @param timemodified The time the submission was last modified in online.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if marked, rejected if failure.\n   */\n  markSubmitted(assignId, courseId, submitted, acceptStatement, timemodified, userId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      let submission;\n      try {\n        const savedSubmission = yield _this10.getSubmission(assignId, userId, site.getId());\n        submission = Object.assign(savedSubmission, {\n          plugindata: savedSubmission.plugindata ? JSON.stringify(savedSubmission.plugindata) : '{}',\n          submitted: submitted ? 1 : 0,\n          submissionstatement: acceptStatement ? 1 : 0 // Mark the submission.\n        });\n      } catch (_unused2) {\n        // No submission, create an empty one.\n        const now = CoreTimeUtils.timestamp();\n        submission = {\n          assignid: assignId,\n          courseid: courseId,\n          userid: userId,\n          onlinetimemodified: timemodified,\n          timecreated: now,\n          timemodified: now,\n          plugindata: '{}',\n          submitted: submitted ? 1 : 0,\n          submissionstatement: acceptStatement ? 1 : 0 // Mark the submission.\n        };\n      }\n\n      return site.getDb().insertRecord(SUBMISSIONS_TABLE, submission);\n    })();\n  }\n  /**\n   * Save a submission to be sent later.\n   *\n   * @param assignId Assignment ID.\n   * @param courseId Course ID the assign belongs to.\n   * @param pluginData Data to save.\n   * @param timemodified The time the submission was last modified in online.\n   * @param submitted True if submission has been submitted, false otherwise.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  saveSubmission(assignId, courseId, pluginData, timemodified, submitted, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const now = CoreTimeUtils.timestamp();\n      const entry = {\n        assignid: assignId,\n        courseid: courseId,\n        plugindata: pluginData ? JSON.stringify(pluginData) : '{}',\n        userid: userId,\n        submitted: submitted ? 1 : 0,\n        timecreated: now,\n        timemodified: now,\n        onlinetimemodified: timemodified\n      };\n      return site.getDb().insertRecord(SUBMISSIONS_TABLE, entry);\n    })();\n  }\n  /**\n   * Save a grading to be sent later.\n   *\n   * @param assignId Assign ID.\n   * @param userId User ID.\n   * @param courseId Course ID the assign belongs to.\n   * @param grade Grade to submit.\n   * @param attemptNumber Number of the attempt being graded.\n   * @param addAttempt Admit the user to attempt again.\n   * @param workflowState Next workflow State.\n   * @param applyToAll If it's a team submission, whether the grade applies to all group members.\n   * @param outcomes Object including all outcomes values. If empty, any of them will be sent.\n   * @param pluginData Plugin data to save.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  submitGradingForm(assignId, userId, courseId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const now = CoreTimeUtils.timestamp();\n      const entry = {\n        assignid: assignId,\n        userid: userId,\n        courseid: courseId,\n        grade: grade,\n        attemptnumber: attemptNumber,\n        addattempt: addAttempt ? 1 : 0,\n        workflowstate: workflowState,\n        applytoall: applyToAll ? 1 : 0,\n        outcomes: outcomes ? JSON.stringify(outcomes) : '{}',\n        plugindata: pluginData ? JSON.stringify(pluginData) : '{}',\n        timemodified: now\n      };\n      return site.getDb().insertRecord(SUBMISSIONS_GRADES_TABLE, entry);\n    })();\n  }\n}\n_class = AddonModAssignOfflineProvider;\n_class.ɵfac = function AddonModAssignOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModAssignOffline = makeSingleton(AddonModAssignOfflineProvider);","map":{"version":3,"names":["CoreError","CoreFile","CoreSites","CoreTextUtils","CoreTimeUtils","makeSingleton","CorePath","SUBMISSIONS_GRADES_TABLE","SUBMISSIONS_TABLE","CoreArray","AddonModAssignOfflineProvider","deleteSubmission","assignId","userId","siteId","_asyncToGenerator","site","getSite","getUserId","getDb","deleteRecords","assignid","userid","deleteSubmissionGrade","getAllAssigns","_this","promises","push","getAllSubmissions","getAllSubmissionsGrade","results","Promise","all","flatten","assignIds","map","assign","filter","id","pos","indexOf","_this2","getAssignSubmissionsFormatted","undefined","getAssignSubmissions","_this3","conditions","db","getSiteDb","submissions","getRecords","submission","courseid","plugindata","parseJSON","onlinetimemodified","timecreated","timemodified","submitted","submissionstatement","_this4","getAssignSubmissionsGradeFormatted","getAssignSubmissionsGrade","_this5","grade","attemptnumber","addattempt","workflowstate","applytoall","outcomes","getSubmission","_this6","getCurrentSiteUserId","length","getSubmissionFolder","siteFolderPath","getSiteFolder","getId","submissionFolderPath","concatenatePaths","getSubmissionGrade","_this7","getSubmissionPluginFolder","pluginName","_this8","folderPath","hasAssignOfflineData","_this9","some","result","_unused","markSubmitted","courseId","acceptStatement","_this10","savedSubmission","Object","JSON","stringify","_unused2","now","timestamp","insertRecord","saveSubmission","pluginData","entry","submitGradingForm","attemptNumber","addAttempt","workflowState","applyToAll","factory","ɵfac","providedIn","AddonModAssignOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/assign/services/assign-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { SQLiteDBRecordValues } from '@classes/sqlitedb';\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { makeSingleton } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport { AddonModAssignOutcomes, AddonModAssignSavePluginData } from './assign';\nimport {\n    AddonModAssignSubmissionsDBRecord,\n    AddonModAssignSubmissionsGradingDBRecord,\n    SUBMISSIONS_GRADES_TABLE,\n    SUBMISSIONS_TABLE,\n} from './database/assign';\nimport { CoreArray } from '@singletons/array';\n\n/**\n * Service to handle offline assign.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModAssignOfflineProvider {\n\n    /**\n     * Delete a submission.\n     *\n     * @param assignId Assignment ID.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    async deleteSubmission(assignId: number, userId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.getDb().deleteRecords(\n            SUBMISSIONS_TABLE,\n            { assignid: assignId, userid: userId },\n        );\n    }\n\n    /**\n     * Delete a submission grade.\n     *\n     * @param assignId Assignment ID.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    async deleteSubmissionGrade(assignId: number, userId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.getDb().deleteRecords(\n            SUBMISSIONS_GRADES_TABLE,\n            { assignid: assignId, userid: userId },\n        );\n    }\n\n    /**\n     * Get all the assignments ids that have something to be synced.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with assignments id that have something to be synced.\n     */\n    async getAllAssigns(siteId?: string): Promise<number[]> {\n        const promises:\n        Promise<AddonModAssignSubmissionsDBRecordFormatted[] | AddonModAssignSubmissionsGradingDBRecordFormatted[]>[] = [];\n\n        promises.push(this.getAllSubmissions(siteId));\n        promises.push(this.getAllSubmissionsGrade(siteId));\n\n        const results = await Promise.all(promises);\n        // Flatten array.\n        const flatten = CoreArray\n            .flatten<AddonModAssignSubmissionsDBRecordFormatted | AddonModAssignSubmissionsGradingDBRecordFormatted>(results);\n\n        // Get assign id.\n        let assignIds: number[] = flatten.map((assign) => assign.assignid);\n        // Get unique values.\n        assignIds = assignIds.filter((id, pos) => assignIds.indexOf(id) == pos);\n\n        return assignIds;\n    }\n\n    /**\n     * Get all the stored submissions from all the assignments.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with submissions.\n     */\n    protected async getAllSubmissions(siteId?: string): Promise<AddonModAssignSubmissionsDBRecordFormatted[]> {\n        return this.getAssignSubmissionsFormatted(undefined, siteId);\n    }\n\n    /**\n     * Get all the stored submissions for a certain assignment.\n     *\n     * @param assignId Assignment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with submissions.\n     */\n    async getAssignSubmissions(assignId: number, siteId?: string): Promise<AddonModAssignSubmissionsDBRecordFormatted[]> {\n        return this.getAssignSubmissionsFormatted({ assignid: assignId }, siteId);\n    }\n\n    /**\n     * Convenience helper function to get stored submissions formatted.\n     *\n     * @param conditions Query conditions.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with submissions.\n     */\n    protected async getAssignSubmissionsFormatted(\n        conditions: SQLiteDBRecordValues = {},\n        siteId?: string,\n    ): Promise<AddonModAssignSubmissionsDBRecordFormatted[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        const submissions: AddonModAssignSubmissionsDBRecord[] = await db.getRecords(SUBMISSIONS_TABLE, conditions);\n\n        // Parse the plugin data.\n        return submissions.map((submission) => ({\n            assignid: submission.assignid,\n            userid: submission.userid,\n            courseid: submission.courseid,\n            plugindata: CoreTextUtils.parseJSON<AddonModAssignSavePluginData>(submission.plugindata, {}),\n            onlinetimemodified: submission.onlinetimemodified,\n            timecreated: submission.timecreated,\n            timemodified: submission.timemodified,\n            submitted: submission.submitted,\n            submissionstatement: submission.submissionstatement,\n        }));\n    }\n\n    /**\n     * Get all the stored submissions grades from all the assignments.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with submissions grades.\n     */\n    protected async getAllSubmissionsGrade(siteId?: string): Promise<AddonModAssignSubmissionsGradingDBRecordFormatted[]> {\n        return this.getAssignSubmissionsGradeFormatted(undefined, siteId);\n    }\n\n    /**\n     * Get all the stored submissions grades for a certain assignment.\n     *\n     * @param assignId Assignment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with submissions grades.\n     */\n    async getAssignSubmissionsGrade(\n        assignId: number,\n        siteId?: string,\n    ): Promise<AddonModAssignSubmissionsGradingDBRecordFormatted[]> {\n        return this.getAssignSubmissionsGradeFormatted({ assignid: assignId }, siteId);\n    }\n\n    /**\n     * Convenience helper function to get stored submissions grading formatted.\n     *\n     * @param conditions Query conditions.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with submissions grades.\n     */\n    protected async getAssignSubmissionsGradeFormatted(\n        conditions: SQLiteDBRecordValues = {},\n        siteId?: string,\n    ): Promise<AddonModAssignSubmissionsGradingDBRecordFormatted[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        const submissions: AddonModAssignSubmissionsGradingDBRecord[] = await db.getRecords(SUBMISSIONS_GRADES_TABLE, conditions);\n\n        // Parse the plugin data and outcomes.\n        return submissions.map((submission) => ({\n            assignid: submission.assignid,\n            userid: submission.userid,\n            courseid: submission.courseid,\n            grade: submission.grade,\n            attemptnumber: submission.attemptnumber,\n            addattempt: submission.addattempt,\n            workflowstate: submission.workflowstate,\n            applytoall: submission.applytoall,\n            outcomes: CoreTextUtils.parseJSON<AddonModAssignOutcomes>(submission.outcomes, {}),\n            plugindata: CoreTextUtils.parseJSON<AddonModAssignSavePluginData>(submission.plugindata, {}),\n            timemodified: submission.timemodified,\n        }));\n    }\n\n    /**\n     * Get a stored submission.\n     *\n     * @param assignId Assignment ID.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with submission.\n     */\n    async getSubmission(assignId: number, userId?: number, siteId?: string): Promise<AddonModAssignSubmissionsDBRecordFormatted> {\n        userId = userId || CoreSites.getCurrentSiteUserId();\n\n        const submissions = await this.getAssignSubmissionsFormatted({ assignid: assignId, userid: userId }, siteId);\n\n        if (submissions.length) {\n            return submissions[0];\n        }\n\n        throw new CoreError('No records found.');\n    }\n\n    /**\n     * Get the path to the folder where to store files for an offline submission.\n     *\n     * @param assignId Assignment ID.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    async getSubmissionFolder(assignId: number, userId?: number, siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n        const siteFolderPath = CoreFile.getSiteFolder(site.getId());\n        const submissionFolderPath = 'offlineassign/' + assignId + '/' + userId;\n\n        return CorePath.concatenatePaths(siteFolderPath, submissionFolderPath);\n    }\n\n    /**\n     * Get a stored submission grade.\n     * Submission grades are not identified using attempt number so it can retrieve the feedback for a previous attempt.\n     *\n     * @param assignId Assignment ID.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with submission grade.\n     */\n    async getSubmissionGrade(\n        assignId: number,\n        userId?: number,\n        siteId?: string,\n    ): Promise<AddonModAssignSubmissionsGradingDBRecordFormatted> {\n        userId = userId || CoreSites.getCurrentSiteUserId();\n\n        const submissions = await this.getAssignSubmissionsGradeFormatted({ assignid: assignId, userid: userId }, siteId);\n\n        if (submissions.length) {\n            return submissions[0];\n        }\n\n        throw new CoreError('No records found.');\n    }\n\n    /**\n     * Get the path to the folder where to store files for a certain plugin in an offline submission.\n     *\n     * @param assignId Assignment ID.\n     * @param pluginName Name of the plugin. Must be unique (both in submission and feedback plugins).\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    async getSubmissionPluginFolder(assignId: number, pluginName: string, userId?: number, siteId?: string): Promise<string> {\n        const folderPath = await this.getSubmissionFolder(assignId, userId, siteId);\n\n        return CorePath.concatenatePaths(folderPath, pluginName);\n    }\n\n    /**\n     * Check if the assignment has something to be synced.\n     *\n     * @param assignId Assignment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether the assignment has something to be synced.\n     */\n    async hasAssignOfflineData(assignId: number, siteId?: string): Promise<boolean> {\n        const promises:\n        Promise<AddonModAssignSubmissionsDBRecordFormatted[] | AddonModAssignSubmissionsGradingDBRecordFormatted[]>[] = [];\n\n        promises.push(this.getAssignSubmissions(assignId, siteId));\n        promises.push(this.getAssignSubmissionsGrade(assignId, siteId));\n\n        try {\n            const results = await Promise.all(promises);\n\n            return results.some((result) => result.length);\n        } catch {\n            // No offline data found.\n            return false;\n        }\n    }\n\n    /**\n     * Mark/Unmark a submission as being submitted.\n     *\n     * @param assignId Assignment ID.\n     * @param courseId Course ID the assign belongs to.\n     * @param submitted True to mark as submitted, false to mark as not submitted.\n     * @param acceptStatement True to accept the submission statement, false otherwise.\n     * @param timemodified The time the submission was last modified in online.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if marked, rejected if failure.\n     */\n    async markSubmitted(\n        assignId: number,\n        courseId: number,\n        submitted: boolean,\n        acceptStatement: boolean,\n        timemodified: number,\n        userId?: number,\n        siteId?: string,\n    ): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n        let submission: AddonModAssignSubmissionsDBRecord;\n        try {\n            const savedSubmission: AddonModAssignSubmissionsDBRecordFormatted =\n                await this.getSubmission(assignId, userId, site.getId());\n            submission = Object.assign(savedSubmission, {\n                plugindata: savedSubmission.plugindata ? JSON.stringify(savedSubmission.plugindata) : '{}',\n                submitted: submitted ? 1 : 0, // Mark the submission.\n                submissionstatement: acceptStatement ? 1 : 0, // Mark the submission.\n            });\n        } catch {\n            // No submission, create an empty one.\n            const now = CoreTimeUtils.timestamp();\n            submission = {\n                assignid: assignId,\n                courseid: courseId,\n                userid: userId,\n                onlinetimemodified: timemodified,\n                timecreated: now,\n                timemodified: now,\n                plugindata: '{}',\n                submitted: submitted ? 1 : 0, // Mark the submission.\n                submissionstatement: acceptStatement ? 1 : 0, // Mark the submission.\n            };\n        }\n\n        return site.getDb().insertRecord(SUBMISSIONS_TABLE, submission);\n    }\n\n    /**\n     * Save a submission to be sent later.\n     *\n     * @param assignId Assignment ID.\n     * @param courseId Course ID the assign belongs to.\n     * @param pluginData Data to save.\n     * @param timemodified The time the submission was last modified in online.\n     * @param submitted True if submission has been submitted, false otherwise.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async saveSubmission(\n        assignId: number,\n        courseId: number,\n        pluginData: AddonModAssignSavePluginData,\n        timemodified: number,\n        submitted: boolean,\n        userId?: number,\n        siteId?: string,\n    ): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        const now = CoreTimeUtils.timestamp();\n        const entry: AddonModAssignSubmissionsDBRecord = {\n            assignid: assignId,\n            courseid: courseId,\n            plugindata: pluginData ? JSON.stringify(pluginData) : '{}',\n            userid: userId,\n            submitted: submitted ? 1 : 0,\n            timecreated: now,\n            timemodified: now,\n            onlinetimemodified: timemodified,\n        };\n\n        return site.getDb().insertRecord(SUBMISSIONS_TABLE, entry);\n    }\n\n    /**\n     * Save a grading to be sent later.\n     *\n     * @param assignId Assign ID.\n     * @param userId User ID.\n     * @param courseId Course ID the assign belongs to.\n     * @param grade Grade to submit.\n     * @param attemptNumber Number of the attempt being graded.\n     * @param addAttempt Admit the user to attempt again.\n     * @param workflowState Next workflow State.\n     * @param applyToAll If it's a team submission, whether the grade applies to all group members.\n     * @param outcomes Object including all outcomes values. If empty, any of them will be sent.\n     * @param pluginData Plugin data to save.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async submitGradingForm(\n        assignId: number,\n        userId: number,\n        courseId: number,\n        grade: number,\n        attemptNumber: number,\n        addAttempt: boolean,\n        workflowState: string,\n        applyToAll: boolean,\n        outcomes: AddonModAssignOutcomes,\n        pluginData: AddonModAssignSavePluginData,\n        siteId?: string,\n    ): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n\n        const now = CoreTimeUtils.timestamp();\n        const entry: AddonModAssignSubmissionsGradingDBRecord = {\n            assignid: assignId,\n            userid: userId,\n            courseid: courseId,\n            grade: grade,\n            attemptnumber: attemptNumber,\n            addattempt: addAttempt ? 1 : 0,\n            workflowstate: workflowState,\n            applytoall: applyToAll ? 1 : 0,\n            outcomes: outcomes ? JSON.stringify(outcomes) : '{}',\n            plugindata: pluginData ? JSON.stringify(pluginData) : '{}',\n            timemodified: now,\n        };\n\n        return site.getDb().insertRecord(SUBMISSIONS_GRADES_TABLE, entry);\n    }\n\n}\nexport const AddonModAssignOffline = makeSingleton(AddonModAssignOfflineProvider);\n\nexport type AddonModAssignSubmissionsDBRecordFormatted = Omit<AddonModAssignSubmissionsDBRecord, 'plugindata'> & {\n    plugindata: AddonModAssignSavePluginData;\n};\n\nexport type AddonModAssignSubmissionsGradingDBRecordFormatted =\n    Omit<AddonModAssignSubmissionsGradingDBRecord, 'plugindata'|'outcomes'> & {\n        plugindata: AddonModAssignSavePluginData;\n        outcomes: AddonModAssignOutcomes;\n    };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}