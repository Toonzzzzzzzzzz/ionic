{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUser } from '@features/user/services/user';\nimport { AddonMessagesOffline } from './messages-offline';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { AddonMessagesSyncProvider } from './messages-sync';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaMessages:';\n/**\n * Service to handle messages.\n */\nexport class AddonMessagesProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('AddonMessages');\n  }\n  /**\n   * Add a contact.\n   *\n   * @param userId User ID of the person to add.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved when done.\n   * @deprecatedonmoodle since 3.6\n   */\n  addContact(userId, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userids: [userId]\n      };\n      yield site.write('core_message_create_contacts', params);\n      yield _this.invalidateAllContactsCache(site.getId());\n    })();\n  }\n  /**\n   * Block a user.\n   *\n   * @param userId User ID of the person to block.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved when done.\n   */\n  blockContact(userId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      try {\n        if (site.wsAvailable('core_message_block_user')) {\n          // Since Moodle 3.6\n          const params = {\n            userid: site.getUserId(),\n            blockeduserid: userId\n          };\n          yield site.write('core_message_block_user', params);\n        } else {\n          const params = {\n            userids: [userId]\n          };\n          yield site.write('core_message_block_contacts', params);\n        }\n        yield _this2.invalidateAllMemberInfo(userId, site);\n      } finally {\n        const data = {\n          userId,\n          userBlocked: true\n        };\n        CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n      }\n    })();\n  }\n  /**\n   * Confirm a contact request from another user.\n   *\n   * @param userId ID of the user who made the contact request.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved when done.\n   * @since 3.6\n   */\n  confirmContactRequest(userId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userid: userId,\n        requesteduserid: site.getUserId()\n      };\n      yield site.write('core_message_confirm_contact_request', params);\n      yield CoreUtils.allPromises([_this3.invalidateAllMemberInfo(userId, site), _this3.invalidateContactsCache(site.id), _this3.invalidateUserContacts(site.id), _this3.refreshContactRequestsCount(site.id)]).finally(() => {\n        const data = {\n          userId,\n          contactRequestConfirmed: true\n        };\n        CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n      });\n    })();\n  }\n  /**\n   * Send a contact request to another user.\n   *\n   * @param userId ID of the receiver of the contact request.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved when done.\n   * @since 3.6\n   */\n  createContactRequest(userId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // Use legacy function if not available.\n      if (!site.wsAvailable('core_message_create_contact_request')) {\n        yield _this4.addContact(userId, site.getId());\n      } else {\n        var _result$warnings;\n        const params = {\n          userid: site.getUserId(),\n          requesteduserid: userId\n        };\n        const result = yield site.write('core_message_create_contact_request', params);\n        if ((_result$warnings = result.warnings) !== null && _result$warnings !== void 0 && _result$warnings.length) {\n          throw new CoreWSError(result.warnings[0]);\n        }\n      }\n      yield _this4.invalidateAllMemberInfo(userId, site).finally(() => {\n        const data = {\n          userId,\n          contactRequestCreated: true\n        };\n        CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n      });\n    })();\n  }\n  /**\n   * Decline a contact request from another user.\n   *\n   * @param userId ID of the user who made the contact request.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved when done.\n   * @since 3.6\n   */\n  declineContactRequest(userId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userid: userId,\n        requesteduserid: site.getUserId()\n      };\n      yield site.write('core_message_decline_contact_request', params);\n      yield CoreUtils.allPromises([_this5.invalidateAllMemberInfo(userId, site), _this5.refreshContactRequestsCount(site.id)]).finally(() => {\n        const data = {\n          userId,\n          contactRequestDeclined: true\n        };\n        CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n      });\n    })();\n  }\n  /**\n   * Delete a conversation.\n   *\n   * @param conversationId Conversation to delete.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Promise resolved when the conversation has been deleted.\n   */\n  deleteConversation(conversationId, siteId, userId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.deleteConversations([conversationId], siteId, userId);\n    })();\n  }\n  /**\n   * Delete several conversations.\n   *\n   * @param conversationIds Conversations to delete.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Promise resolved when the conversations have been deleted.\n   */\n  deleteConversations(conversationIds, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const params = {\n        userid: userId,\n        conversationids: conversationIds\n      };\n      yield site.write('core_message_delete_conversations_by_id', params);\n      yield Promise.all(conversationIds.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (conversationId) {\n          try {\n            return AddonMessagesOffline.deleteConversationMessages(conversationId, site.getId());\n          } catch (_unused) {\n            // Ignore errors.\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Delete a message (online or offline).\n   *\n   * @param message Message to delete.\n   * @param deleteForAll Whether the message should be deleted for all users.\n   * @returns Promise resolved when the message has been deleted.\n   */\n  deleteMessage(message, deleteForAll) {\n    if ('id' in message) {\n      // Message has ID, it means it has been sent to the server.\n      if (deleteForAll) {\n        return this.deleteMessageForAllOnline(message.id);\n      } else {\n        return this.deleteMessageOnline(message.id, !!('read' in message && message.read));\n      }\n    }\n    // It's an offline message.\n    if (!('conversationid' in message)) {\n      return AddonMessagesOffline.deleteMessage(message.touserid, message.smallmessage, message.timecreated);\n    }\n    return AddonMessagesOffline.deleteConversationMessage(message.conversationid, message.text, message.timecreated);\n  }\n  /**\n   * Delete a message from the server.\n   *\n   * @param id Message ID.\n   * @param read True if message is read, false otherwise.\n   * @param userId User we want to delete the message for. If not defined, use current user.\n   * @returns Promise resolved when the message has been deleted.\n   */\n  deleteMessageOnline(id, read, userId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      var _CoreSites$getCurrent;\n      userId = userId || CoreSites.getCurrentSiteUserId();\n      const params = {\n        messageid: id,\n        userid: userId\n      };\n      if (read !== undefined) {\n        params.read = read;\n      }\n      yield (_CoreSites$getCurrent = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent === void 0 ? void 0 : _CoreSites$getCurrent.write('core_message_delete_message', params);\n      yield _this7.invalidateDiscussionCache(userId);\n    })();\n  }\n  /**\n   * Delete a message for all users.\n   *\n   * @param id Message ID.\n   * @param userId User we want to delete the message for. If not defined, use current user.\n   * @returns Promise resolved when the message has been deleted.\n   */\n  deleteMessageForAllOnline(id, userId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      var _CoreSites$getCurrent2;\n      userId = userId || CoreSites.getCurrentSiteUserId();\n      const params = {\n        messageid: id,\n        userid: userId\n      };\n      yield (_CoreSites$getCurrent2 = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent2 === void 0 ? void 0 : _CoreSites$getCurrent2.write('core_message_delete_message_for_all_users', params);\n      yield _this8.invalidateDiscussionCache(userId);\n    })();\n  }\n  /**\n   * Format a conversation.\n   *\n   * @param conversation Conversation to format.\n   * @param userId User ID viewing the conversation.\n   * @returns Formatted conversation.\n   */\n  formatConversation(conversation, userId) {\n    const numMessages = conversation.messages.length;\n    const lastMessage = numMessages ? conversation.messages[numMessages - 1] : null;\n    conversation.lastmessage = lastMessage ? lastMessage.text : undefined;\n    conversation.lastmessagedate = lastMessage ? lastMessage.timecreated : undefined;\n    conversation.sentfromcurrentuser = lastMessage ? lastMessage.useridfrom == userId : undefined;\n    if (conversation.type != AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP) {\n      const isIndividual = conversation.type == AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL;\n      const otherUser = conversation.members.find(member => isIndividual && member.id != userId || !isIndividual && member.id == userId);\n      if (otherUser) {\n        conversation.name = conversation.name ? conversation.name : otherUser.fullname;\n        conversation.imageurl = conversation.imageurl ? conversation.imageurl : otherUser.profileimageurl;\n        conversation.otherUser = otherUser;\n        conversation.userid = otherUser.id;\n        conversation.showonlinestatus = otherUser.showonlinestatus;\n        conversation.isonline = otherUser.isonline;\n        conversation.isblocked = otherUser.isblocked;\n        conversation.otherUser = otherUser;\n      }\n    }\n    return conversation;\n  }\n  /**\n   * Get the cache key for blocked contacts.\n   *\n   * @param userId The user who's contacts we're looking for.\n   * @returns Cache key.\n   */\n  getCacheKeyForBlockedContacts(userId) {\n    return ROOT_CACHE_KEY + 'blockedContacts:' + userId;\n  }\n  /**\n   * Get the cache key for contacts.\n   *\n   * @returns Cache key.\n   */\n  getCacheKeyForContacts() {\n    return ROOT_CACHE_KEY + 'contacts';\n  }\n  /**\n   * Get the cache key for comfirmed contacts.\n   *\n   * @returns Cache key.\n   */\n  getCacheKeyForUserContacts() {\n    return ROOT_CACHE_KEY + 'userContacts';\n  }\n  /**\n   * Get the cache key for contact requests.\n   *\n   * @returns Cache key.\n   */\n  getCacheKeyForContactRequests() {\n    return ROOT_CACHE_KEY + 'contactRequests';\n  }\n  /**\n   * Get the cache key for contact requests count.\n   *\n   * @returns Cache key.\n   */\n  getCacheKeyForContactRequestsCount() {\n    return ROOT_CACHE_KEY + 'contactRequestsCount';\n  }\n  /**\n   * Get the cache key for a discussion.\n   *\n   * @param userId The other person with whom the current user is having the discussion.\n   * @returns Cache key.\n   */\n  getCacheKeyForDiscussion(userId) {\n    return ROOT_CACHE_KEY + 'discussion:' + userId;\n  }\n  /**\n   * Get the cache key for the message count.\n   *\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getCacheKeyForMessageCount(userId) {\n    return ROOT_CACHE_KEY + 'count:' + userId;\n  }\n  /**\n   * Get the cache key for unread conversation counts.\n   *\n   * @returns Cache key.\n   */\n  getCacheKeyForUnreadConversationCounts() {\n    return ROOT_CACHE_KEY + 'unreadConversationCounts';\n  }\n  /**\n   * Get the cache key for the list of discussions.\n   *\n   * @returns Cache key.\n   */\n  getCacheKeyForDiscussions() {\n    return ROOT_CACHE_KEY + 'discussions';\n  }\n  /**\n   * Get cache key for get conversations.\n   *\n   * @param userId User ID.\n   * @param conversationId Conversation ID.\n   * @returns Cache key.\n   */\n  getCacheKeyForConversation(userId, conversationId) {\n    return ROOT_CACHE_KEY + 'conversation:' + userId + ':' + conversationId;\n  }\n  /**\n   * Get cache key for get conversations between users.\n   *\n   * @param userId User ID.\n   * @param otherUserId Other user ID.\n   * @returns Cache key.\n   */\n  getCacheKeyForConversationBetweenUsers(userId, otherUserId) {\n    return ROOT_CACHE_KEY + 'conversationBetweenUsers:' + userId + ':' + otherUserId;\n  }\n  /**\n   * Get cache key for get conversation members.\n   *\n   * @param userId User ID.\n   * @param conversationId Conversation ID.\n   * @returns Cache key.\n   */\n  getCacheKeyForConversationMembers(userId, conversationId) {\n    return ROOT_CACHE_KEY + 'conversationMembers:' + userId + ':' + conversationId;\n  }\n  /**\n   * Get cache key for get conversation messages.\n   *\n   * @param userId User ID.\n   * @param conversationId Conversation ID.\n   * @returns Cache key.\n   */\n  getCacheKeyForConversationMessages(userId, conversationId) {\n    return ROOT_CACHE_KEY + 'conversationMessages:' + userId + ':' + conversationId;\n  }\n  /**\n   * Get cache key for get conversations.\n   *\n   * @param userId User ID.\n   * @param type Filter by type.\n   * @param favourites Filter favourites.\n   * @returns Cache key.\n   */\n  getCacheKeyForConversations(userId, type, favourites) {\n    return this.getCommonCacheKeyForUserConversations(userId) + ':' + type + ':' + favourites;\n  }\n  /**\n   * Get cache key for conversation counts.\n   *\n   * @returns Cache key.\n   */\n  getCacheKeyForConversationCounts() {\n    return ROOT_CACHE_KEY + 'conversationCounts';\n  }\n  /**\n   * Get cache key for member info.\n   *\n   * @param userId User ID.\n   * @param otherUserId The other user ID.\n   * @returns Cache key.\n   */\n  getCacheKeyForMemberInfo(userId, otherUserId) {\n    return ROOT_CACHE_KEY + 'memberInfo:' + userId + ':' + otherUserId;\n  }\n  /**\n   * Get cache key for get self conversation.\n   *\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getCacheKeyForSelfConversation(userId) {\n    return ROOT_CACHE_KEY + 'selfconversation:' + userId;\n  }\n  /**\n   * Get common cache key for get user conversations.\n   *\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getCommonCacheKeyForUserConversations(userId) {\n    return this.getRootCacheKeyForConversations() + userId;\n  }\n  /**\n   * Get root cache key for get conversations.\n   *\n   * @returns Cache key.\n   */\n  getRootCacheKeyForConversations() {\n    return ROOT_CACHE_KEY + 'conversations:';\n  }\n  /**\n   * Get all the contacts of the current user.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the WS data.\n   * @deprecatedonmoodle since 3.6\n   */\n  getAllContacts(siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const contacts = yield _this9.getContacts(siteId);\n      try {\n        const blocked = yield _this9.getBlockedContacts(siteId);\n        contacts.blocked = blocked.users;\n        _this9.storeUsersFromAllContacts(contacts);\n        return contacts;\n      } catch (_unused2) {\n        // The WS for blocked contacts might fail, but we still want the contacts.\n        contacts.blocked = [];\n        _this9.storeUsersFromAllContacts(contacts);\n        return contacts;\n      }\n    })();\n  }\n  /**\n   * Get all the users blocked by the current user.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the WS data.\n   */\n  getBlockedContacts(siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const userId = site.getUserId();\n      const params = {\n        userid: userId\n      };\n      const preSets = {\n        cacheKey: _this10.getCacheKeyForBlockedContacts(userId),\n        updateFrequency: CoreSite.FREQUENCY_OFTEN\n      };\n      return site.read('core_message_get_blocked_users', params, preSets);\n    })();\n  }\n  /**\n   * Get the contacts of the current user.\n   *\n   * This excludes the blocked users.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the WS data.\n   * @deprecatedonmoodle since 3.6\n   */\n  getContacts(siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const preSets = {\n        cacheKey: _this11.getCacheKeyForContacts(),\n        updateFrequency: CoreSite.FREQUENCY_OFTEN\n      };\n      const contacts = yield site.read('core_message_get_contacts', undefined, preSets);\n      // Filter contacts with negative ID, they are notifications.\n      const validContacts = {\n        online: [],\n        offline: [],\n        strangers: []\n      };\n      for (const typeName in contacts) {\n        if (!validContacts[typeName]) {\n          validContacts[typeName] = [];\n        }\n        contacts[typeName].forEach(contact => {\n          if (contact.id > 0) {\n            validContacts[typeName].push(contact);\n          }\n        });\n      }\n      return validContacts;\n    })();\n  }\n  /**\n   * Get the list of user contacts.\n   *\n   * @param limitFrom Position of the first contact to fetch.\n   * @param limitNum Number of contacts to fetch. Default is AddonMessagesProvider.LIMIT_CONTACTS.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the list of user contacts.\n   * @since 3.6\n   */\n  getUserContacts(limitFrom = 0, limitNum = AddonMessagesProvider.LIMIT_CONTACTS, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userid: site.getUserId(),\n        limitfrom: limitFrom,\n        limitnum: limitNum <= 0 ? 0 : limitNum + 1\n      };\n      const preSets = {\n        cacheKey: _this12.getCacheKeyForUserContacts(),\n        updateFrequency: CoreSite.FREQUENCY_OFTEN\n      };\n      const contacts = yield site.read('core_message_get_user_contacts', params, preSets);\n      if (!contacts || !contacts.length) {\n        return {\n          contacts: [],\n          canLoadMore: false\n        };\n      }\n      CoreUser.storeUsers(contacts, site.id);\n      if (limitNum <= 0) {\n        return {\n          contacts,\n          canLoadMore: false\n        };\n      }\n      return {\n        contacts: contacts.slice(0, limitNum),\n        canLoadMore: contacts.length > limitNum\n      };\n    })();\n  }\n  /**\n   * Get the contact request sent to the current user.\n   *\n   * @param limitFrom Position of the first contact request to fetch.\n   * @param limitNum Number of contact requests to fetch. Default is AddonMessagesProvider.LIMIT_CONTACTS.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the list of contact requests.\n   * @since 3.6\n   */\n  getContactRequests(limitFrom = 0, limitNum = AddonMessagesProvider.LIMIT_CONTACTS, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userid: site.getUserId(),\n        limitfrom: limitFrom,\n        limitnum: limitNum <= 0 ? 0 : limitNum + 1\n      };\n      const preSets = {\n        cacheKey: _this13.getCacheKeyForContactRequests(),\n        updateFrequency: CoreSite.FREQUENCY_OFTEN\n      };\n      const requests = yield site.read('core_message_get_contact_requests', params, preSets);\n      if (!requests || !requests.length) {\n        return {\n          requests: [],\n          canLoadMore: false\n        };\n      }\n      CoreUser.storeUsers(requests, site.id);\n      if (limitNum <= 0) {\n        return {\n          requests,\n          canLoadMore: false\n        };\n      }\n      return {\n        requests: requests.slice(0, limitNum),\n        canLoadMore: requests.length > limitNum\n      };\n    })();\n  }\n  /**\n   * Get the number of contact requests sent to the current user.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved with the number of contact requests.\n   * @since 3.6\n   */\n  getContactRequestsCount(siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userid: site.getUserId()\n      };\n      const preSets = {\n        cacheKey: _this14.getCacheKeyForContactRequestsCount(),\n        typeExpected: 'number'\n      };\n      const data = {\n        count: yield site.read('core_message_get_received_contact_requests_count', params, preSets)\n      };\n      // Notify the new count so all badges are updated.\n      CoreEvents.trigger(AddonMessagesProvider.CONTACT_REQUESTS_COUNT_EVENT, data, site.id);\n      return data.count;\n    })();\n  }\n  /**\n   * Get a conversation by the conversation ID.\n   *\n   * @param conversationId Conversation ID to fetch.\n   * @param includeContactRequests Include contact requests.\n   * @param includePrivacyInfo Include privacy info.\n   * @param messageOffset Offset for messages list.\n   * @param messageLimit Limit of messages. Defaults to 1 (last message).\n   *                     We recommend getConversationMessages to get them.\n   * @param memberOffset Offset for members list.\n   * @param memberLimit Limit of members. Defaults to 2 (to be able to know the other user in individual ones).\n   *                    We recommend getConversationMembers to get them.\n   * @param newestFirst Whether to order messages by newest first.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Promise resolved with the response.\n   * @since 3.6\n   */\n  getConversation(conversationId, includeContactRequests = false, includePrivacyInfo = false, messageOffset = 0, messageLimit = 1, memberOffset = 0, memberLimit = 2, newestFirst = true, siteId, userId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const preSets = {\n        cacheKey: _this15.getCacheKeyForConversation(userId, conversationId)\n      };\n      const params = {\n        userid: userId,\n        conversationid: conversationId,\n        includecontactrequests: includeContactRequests,\n        includeprivacyinfo: includePrivacyInfo,\n        messageoffset: messageOffset,\n        messagelimit: messageLimit,\n        memberoffset: memberOffset,\n        memberlimit: memberLimit,\n        newestmessagesfirst: newestFirst\n      };\n      const conversation = yield site.read('core_message_get_conversation', params, preSets);\n      return _this15.formatConversation(conversation, userId);\n    })();\n  }\n  /**\n   * Get a conversation between two users.\n   *\n   * @param otherUserId The other user ID.\n   * @param includeContactRequests Include contact requests.\n   * @param includePrivacyInfo Include privacy info.\n   * @param messageOffset Offset for messages list.\n   * @param messageLimit Limit of messages. Defaults to 1 (last message).\n   *                     We recommend getConversationMessages to get them.\n   * @param memberOffset Offset for members list.\n   * @param memberLimit Limit of members. Defaults to 2 (to be able to know the other user in individual ones).\n   *                    We recommend getConversationMembers to get them.\n   * @param newestFirst Whether to order messages by newest first.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n   * @returns Promise resolved with the response.\n   * @since 3.6\n   */\n  getConversationBetweenUsers(otherUserId, includeContactRequests, includePrivacyInfo, messageOffset = 0, messageLimit = 1, memberOffset = 0, memberLimit = 2, newestFirst = true, siteId, userId, preferCache) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const preSets = {\n        cacheKey: _this16.getCacheKeyForConversationBetweenUsers(userId, otherUserId),\n        omitExpires: !!preferCache\n      };\n      const params = {\n        userid: userId,\n        otheruserid: otherUserId,\n        includecontactrequests: !!includeContactRequests,\n        includeprivacyinfo: !!includePrivacyInfo,\n        messageoffset: messageOffset,\n        messagelimit: messageLimit,\n        memberoffset: memberOffset,\n        memberlimit: memberLimit,\n        newestmessagesfirst: !!newestFirst\n      };\n      const conversation = yield site.read('core_message_get_conversation_between_users', params, preSets);\n      return _this16.formatConversation(conversation, userId);\n    })();\n  }\n  /**\n   * Get a conversation members.\n   *\n   * @param conversationId Conversation ID to fetch.\n   * @param limitFrom Offset for members list.\n   * @param limitTo Limit of members.\n   * @param includeContactRequests Include contact requests.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in.\n   * @returns Conversation members.\n   * @since 3.6\n   */\n  getConversationMembers(conversationId, limitFrom = 0, limitTo, includeContactRequests, siteId, userId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      var _limitTo;\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      limitTo = (_limitTo = limitTo) !== null && _limitTo !== void 0 ? _limitTo : AddonMessagesProvider.LIMIT_MESSAGES;\n      const preSets = {\n        cacheKey: _this17.getCacheKeyForConversationMembers(userId, conversationId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      const params = {\n        userid: userId,\n        conversationid: conversationId,\n        limitfrom: limitFrom,\n        limitnum: limitTo < 1 ? limitTo : limitTo + 1,\n        includecontactrequests: !!includeContactRequests,\n        includeprivacyinfo: true\n      };\n      const members = yield site.read('core_message_get_conversation_members', params, preSets);\n      if (limitTo < 1) {\n        return {\n          canLoadMore: false,\n          members: members\n        };\n      }\n      return {\n        canLoadMore: members.length > limitTo,\n        members: members.slice(0, limitTo)\n      };\n    })();\n  }\n  /**\n   * Get a conversation by the conversation ID.\n   *\n   * @param conversationId Conversation ID to fetch.\n   * @param options Options.\n   * @returns Promise resolved with the response.\n   * @since 3.6\n   */\n  getConversationMessages(conversationId, options = {}) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      var _options$limitTo, _options$newestFirst;\n      const site = yield CoreSites.getSite(options.siteId);\n      options.userId = options.userId || site.getUserId();\n      options.limitFrom = options.limitFrom || 0;\n      options.limitTo = (_options$limitTo = options.limitTo) !== null && _options$limitTo !== void 0 ? _options$limitTo : AddonMessagesProvider.LIMIT_MESSAGES;\n      options.timeFrom = options.timeFrom || 0;\n      options.newestFirst = (_options$newestFirst = options.newestFirst) !== null && _options$newestFirst !== void 0 ? _options$newestFirst : true;\n      const preSets = {\n        cacheKey: _this18.getCacheKeyForConversationMessages(options.userId, conversationId)\n      };\n      const params = {\n        currentuserid: options.userId,\n        convid: conversationId,\n        limitfrom: options.limitFrom,\n        limitnum: options.limitTo < 1 ? options.limitTo : options.limitTo + 1,\n        newest: !!options.newestFirst,\n        timefrom: options.timeFrom\n      };\n      if (options.limitFrom > 0) {\n        // Do not use cache when retrieving older messages.\n        // This is to prevent storing too much data and to prevent inconsistencies between \"pages\" loaded.\n        preSets.getFromCache = false;\n        preSets.saveToCache = false;\n        preSets.emergencyCache = false;\n      } else if (options.forceCache) {\n        preSets.omitExpires = true;\n      } else if (options.ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const result = yield site.read('core_message_get_conversation_messages', params, preSets);\n      if (options.limitTo < 1) {\n        result.canLoadMore = false;\n      } else {\n        result.canLoadMore = result.messages.length > options.limitTo;\n        result.messages = result.messages.slice(0, options.limitTo);\n      }\n      result.messages.forEach(message => {\n        // Convert time to milliseconds.\n        message.timecreated = message.timecreated ? message.timecreated * 1000 : 0;\n      });\n      if (options.excludePending) {\n        // No need to get offline messages, return the ones we have.\n        return result;\n      }\n      // Get offline messages.\n      const offlineMessages = yield AddonMessagesOffline.getConversationMessages(conversationId, options.userId, site.getId());\n      result.messages = result.messages.concat(offlineMessages);\n      return result;\n    })();\n  }\n  /**\n   * Get the discussions of a certain user. This function is used in Moodle sites higher than 3.6.\n   * If the site is older than 3.6, please use getDiscussions.\n   *\n   * @param type Filter by type.\n   * @param favourites Whether to restrict the results to contain NO favourite conversations (false), ONLY favourite\n   *                   conversation (true), or ignore any restriction altogether (undefined or null).\n   * @param limitFrom The offset to start at.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @param forceCache True if it should return cached data. Has priority over ignoreCache.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved with the conversations.\n   * @since 3.6\n   */\n  getConversations(type, favourites, limitFrom = 0, siteId, userId, forceCache, ignoreCache) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const preSets = {\n        cacheKey: _this19.getCacheKeyForConversations(userId, type, favourites)\n      };\n      const params = {\n        userid: userId,\n        limitfrom: limitFrom,\n        limitnum: AddonMessagesProvider.LIMIT_MESSAGES + 1\n      };\n      if (forceCache) {\n        preSets.omitExpires = true;\n      } else if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      if (type !== undefined && type != null) {\n        params.type = type;\n      }\n      if (favourites !== undefined && favourites != null) {\n        params.favourites = !!favourites;\n      }\n      if (site.isVersionGreaterEqualThan('3.7') && type != AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP) {\n        // Add self conversation to the list.\n        params.mergeself = true;\n      }\n      let response;\n      try {\n        response = yield site.read('core_message_get_conversations', params, preSets);\n      } catch (error) {\n        if (params.mergeself) {\n          // Try again without the new param. Maybe the user is offline and he has a previous request cached.\n          delete params.mergeself;\n          return site.read('core_message_get_conversations', params, preSets);\n        }\n        throw error;\n      }\n      // Format the conversations, adding some calculated fields.\n      const conversations = response.conversations.slice(0, AddonMessagesProvider.LIMIT_MESSAGES).map(conversation => _this19.formatConversation(conversation, userId));\n      return {\n        conversations,\n        canLoadMore: response.conversations.length > AddonMessagesProvider.LIMIT_MESSAGES\n      };\n    })();\n  }\n  /**\n   * Get conversation counts by type.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with favourite,\n   *         individual, group and self conversation counts.\n   * @since 3.6\n   */\n  getConversationCounts(siteId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const preSets = {\n        cacheKey: _this20.getCacheKeyForConversationCounts()\n      };\n      const result = yield site.read('core_message_get_conversation_counts', {}, preSets);\n      const counts = {\n        favourites: result.favourites,\n        individual: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL],\n        group: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP],\n        self: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_SELF] || 0\n      };\n      return counts;\n    })();\n  }\n  /**\n   * Return the current user's discussion with another user.\n   *\n   * @param userId The ID of the other user.\n   * @param excludePending True to exclude messages pending to be sent.\n   * @param lfReceivedUnread Number of unread received messages already fetched, so fetch will be done from this.\n   * @param lfReceivedRead Number of read received messages already fetched, so fetch will be done from this.\n   * @param lfSentUnread Number of unread sent messages already fetched, so fetch will be done from this.\n   * @param lfSentRead Number of read sent messages already fetched, so fetch will be done from this.\n   * @param notUsed Deprecated since 3.9.5\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with messages and a boolean telling if can load more messages.\n   */\n  getDiscussion(userId, excludePending, lfReceivedUnread = 0, lfReceivedRead = 0, lfSentUnread = 0, lfSentRead = 0, notUsed = false,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  siteId) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const result = {\n        messages: [],\n        canLoadMore: false\n      };\n      const preSets = {\n        cacheKey: _this21.getCacheKeyForDiscussion(userId)\n      };\n      const params = {\n        useridto: site.getUserId(),\n        useridfrom: userId,\n        limitnum: AddonMessagesProvider.LIMIT_MESSAGES\n      };\n      if (lfReceivedUnread > 0 || lfReceivedRead > 0 || lfSentUnread > 0 || lfSentRead > 0) {\n        // Do not use cache when retrieving older messages.\n        // This is to prevent storing too much data and to prevent inconsistencies between \"pages\" loaded.\n        preSets.getFromCache = false;\n        preSets.saveToCache = false;\n        preSets.emergencyCache = false;\n      }\n      // Get message received by current user.\n      const received = yield _this21.getRecentMessages(params, preSets, lfReceivedUnread, lfReceivedRead, undefined, site.getId());\n      result.messages = received;\n      const hasReceived = received.length > 0;\n      // Get message sent by current user.\n      params.useridto = userId;\n      params.useridfrom = site.getUserId();\n      const sent = yield _this21.getRecentMessages(params, preSets, lfSentUnread, lfSentRead, undefined, siteId);\n      result.messages = result.messages.concat(sent);\n      const hasSent = sent.length > 0;\n      if (result.messages.length > AddonMessagesProvider.LIMIT_MESSAGES) {\n        // Sort messages and get the more recent ones.\n        result.canLoadMore = true;\n        result.messages = _this21.sortMessages(result['messages']);\n        result.messages = result.messages.slice(-AddonMessagesProvider.LIMIT_MESSAGES);\n      } else {\n        result.canLoadMore = result.messages.length == AddonMessagesProvider.LIMIT_MESSAGES && (!hasReceived || !hasSent);\n      }\n      if (excludePending) {\n        // No need to get offline messages, return the ones we have.\n        return result;\n      }\n      // Get offline messages.\n      const offlineMessages = yield AddonMessagesOffline.getMessages(userId, site.getId());\n      result.messages = result.messages.concat(offlineMessages);\n      return result;\n    })();\n  }\n  /**\n   * Get the discussions of the current user. This function is used in Moodle sites older than 3.6.\n   * If the site is 3.6 or higher, please use getConversations.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with an object where the keys are the user ID of the other user.\n   */\n  getDiscussions(siteId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const discussions = {};\n      /**\n       * Convenience function to treat a recent message, adding it to discussions list if needed.\n       */\n      const treatRecentMessage = (message, userId, userFullname) => {\n        if (discussions[userId] === undefined) {\n          discussions[userId] = {\n            fullname: userFullname,\n            profileimageurl: ''\n          };\n          if ((!('timeread' in message) || !message.timeread) && !message.pending && message.useridfrom != currentUserId) {\n            discussions[userId].unread = true;\n          }\n        }\n        const messageId = 'id' in message ? message.id : 0;\n        // Extract the most recent message. Pending messages are considered more recent than messages already sent.\n        const discMessage = discussions[userId].message;\n        if (discMessage === undefined || !discMessage.pending && message.pending || discMessage.pending == message.pending && (discMessage.timecreated < message.timecreated || discMessage.timecreated == message.timecreated && discMessage.id < messageId)) {\n          discussions[userId].message = {\n            id: messageId,\n            user: userId,\n            message: message.text || '',\n            timecreated: message.timecreated,\n            pending: !!message.pending\n          };\n        }\n      };\n      const site = yield CoreSites.getSite(siteId);\n      const currentUserId = site.getUserId();\n      const params = {\n        useridto: currentUserId,\n        useridfrom: 0,\n        limitnum: AddonMessagesProvider.LIMIT_MESSAGES\n      };\n      const preSets = {\n        cacheKey: _this22.getCacheKeyForDiscussions()\n      };\n      const received = yield _this22.getRecentMessages(params, preSets, undefined, undefined, undefined, site.getId());\n      // Extract the discussions by filtering same senders.\n      received.forEach(message => {\n        treatRecentMessage(message, message.useridfrom, message.userfromfullname);\n      });\n      // Now get the last messages sent by the current user.\n      params.useridfrom = params.useridto;\n      params.useridto = 0;\n      const sent = yield _this22.getRecentMessages(params, preSets);\n      // Extract the discussions by filtering same senders.\n      sent.forEach(message => {\n        treatRecentMessage(message, message.useridto, message.usertofullname);\n      });\n      const offlineMessages = yield AddonMessagesOffline.getAllMessages(site.getId());\n      offlineMessages.forEach(message => {\n        treatRecentMessage(message, 'touserid' in message ? message.touserid : 0, '');\n      });\n      const discussionsWithUserImg = yield _this22.getDiscussionsUserImg(discussions, site.getId());\n      _this22.storeUsersFromDiscussions(discussionsWithUserImg);\n      return discussionsWithUserImg;\n    })();\n  }\n  /**\n   * Get user images for all the discussions that don't have one already.\n   *\n   * @param discussions List of discussions.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise always resolved. Resolve param is the formatted discussions.\n   */\n  getDiscussionsUserImg(discussions, siteId) {\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      for (const userId in discussions) {\n        if (!discussions[userId].profileimageurl && discussions[userId].message) {\n          // We don't have the user image. Try to retrieve it.\n          promises.push(CoreUser.getProfile(discussions[userId].message.user, 0, true, siteId).then(user => {\n            discussions[userId].profileimageurl = user.profileimageurl;\n            return;\n          }).catch(() => {\n            // Error getting profile, resolve promise without adding any extra data.\n          }));\n        }\n      }\n      yield Promise.all(promises);\n      return discussions;\n    })();\n  }\n  /**\n   * Get conversation member info by user id, works even if no conversation betwen the users exists.\n   *\n   * @param otherUserId The other user ID.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Promise resolved with the member info.\n   * @since 3.6\n   */\n  getMemberInfo(otherUserId, siteId, userId) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const preSets = {\n        cacheKey: _this23.getCacheKeyForMemberInfo(userId, otherUserId),\n        updateFrequency: CoreSite.FREQUENCY_OFTEN\n      };\n      const params = {\n        referenceuserid: userId,\n        userids: [otherUserId],\n        includecontactrequests: true,\n        includeprivacyinfo: true\n      };\n      const members = yield site.read('core_message_get_member_info', params, preSets);\n      if (!members || members.length < 1) {\n        // Should never happen.\n        throw new CoreError('Error fetching member info.');\n      }\n      return members[0];\n    })();\n  }\n  /**\n   * Get the cache key for the get message preferences call.\n   *\n   * @returns Cache key.\n   */\n  getMessagePreferencesCacheKey() {\n    return ROOT_CACHE_KEY + 'messagePreferences';\n  }\n  /**\n   * Get message preferences.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the message preferences.\n   */\n  getMessagePreferences(siteId) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      _this24.logger.debug('Get message preferences');\n      const site = yield CoreSites.getSite(siteId);\n      const preSets = {\n        cacheKey: _this24.getMessagePreferencesCacheKey(),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      const data = yield site.read('core_message_get_user_message_preferences', {}, preSets);\n      if (data.preferences) {\n        data.preferences.blocknoncontacts = data.blocknoncontacts;\n        return data.preferences;\n      }\n      throw new CoreError('Error getting message preferences');\n    })();\n  }\n  /**\n   * Get messages according to the params.\n   *\n   * @param params Parameters to pass to the WS.\n   * @param preSets Set of presets for the WS.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the data.\n   */\n  getMessages(params, preSets, siteId) {\n    return _asyncToGenerator(function* () {\n      params.type = 'conversations';\n      params.newestfirst = true;\n      const site = yield CoreSites.getSite(siteId);\n      const response = yield site.read('core_message_get_messages', params, preSets);\n      response.messages.forEach(message => {\n        message.read = !!params.read;\n        // Convert times to milliseconds.\n        message.timecreated = message.timecreated ? message.timecreated * 1000 : 0;\n        message.timeread = message.timeread ? message.timeread * 1000 : 0;\n      });\n      return response;\n    })();\n  }\n  /**\n   * Get the most recent messages.\n   *\n   * @param params Parameters to pass to the WS.\n   * @param preSets Set of presets for the WS.\n   * @param limitFromUnread Number of read messages already fetched, so fetch will be done from this number.\n   * @param limitFromRead Number of unread messages already fetched, so fetch will be done from this number.\n   * @param notUsed // Deprecated 3.9.5\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the data.\n   */\n  getRecentMessages(params, preSets, limitFromUnread = 0, limitFromRead = 0, notUsed = false,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  siteId) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      limitFromUnread = limitFromUnread || 0;\n      limitFromRead = limitFromRead || 0;\n      params.read = false;\n      params.limitfrom = limitFromUnread;\n      const response = yield _this25.getMessages(params, preSets, siteId);\n      let messages = response.messages;\n      if (!messages) {\n        throw new CoreError('Error fetching recent messages');\n      }\n      if (messages.length >= (params.limitnum || 0)) {\n        return messages;\n      }\n      // We need to fetch more messages.\n      params.limitnum = (params.limitnum || 0) - messages.length;\n      params.read = true;\n      params.limitfrom = limitFromRead;\n      try {\n        const response = yield _this25.getMessages(params, preSets, siteId);\n        if (response.messages) {\n          messages = messages.concat(response.messages);\n        }\n        return messages;\n      } catch (_unused3) {\n        return messages;\n      }\n    })();\n  }\n  /**\n   * Get a self conversation.\n   *\n   * @param messageOffset Offset for messages list.\n   * @param messageLimit Limit of messages. Defaults to 1 (last message).\n   *                     We recommend getConversationMessages to get them.\n   * @param newestFirst Whether to order messages by newest first.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID to get the self conversation for. If not defined, current user in the site.\n   * @returns Promise resolved with the response.\n   * @since 3.7\n   */\n  getSelfConversation(messageOffset = 0, messageLimit = 1, newestFirst = true, siteId, userId) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const preSets = {\n        cacheKey: _this26.getCacheKeyForSelfConversation(userId)\n      };\n      const params = {\n        userid: userId,\n        messageoffset: messageOffset,\n        messagelimit: messageLimit,\n        newestmessagesfirst: !!newestFirst\n      };\n      const conversation = yield site.read('core_message_get_self_conversation', params, preSets);\n      return _this26.formatConversation(conversation, userId);\n    })();\n  }\n  /**\n   * Get unread conversation counts by type.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved with the unread favourite, individual and group conversation counts.\n   */\n  getUnreadConversationCounts(siteId) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      let counts;\n      if (_this27.isGroupMessagingEnabled()) {\n        // @since 3.6\n        const preSets = {\n          cacheKey: _this27.getCacheKeyForUnreadConversationCounts()\n        };\n        const result = yield site.read('core_message_get_unread_conversation_counts', {}, preSets);\n        counts = {\n          favourites: result.favourites,\n          individual: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL],\n          group: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP],\n          self: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_SELF] || 0\n        };\n      } else {\n        const params = {\n          useridto: site.getUserId()\n        };\n        const preSets = {\n          cacheKey: _this27.getCacheKeyForMessageCount(site.getUserId()),\n          typeExpected: 'number'\n        };\n        const count = yield site.read('core_message_get_unread_conversations_count', params, preSets);\n        counts = {\n          favourites: 0,\n          individual: count,\n          group: 0,\n          self: 0\n        };\n      }\n      // Notify the new counts so all views are updated.\n      CoreEvents.trigger(AddonMessagesProvider.UNREAD_CONVERSATION_COUNTS_EVENT, counts, site.id);\n      return counts;\n    })();\n  }\n  /**\n   * Get the latest unread received messages.\n   *\n   * @param notUsed Not user anymore.\n   * @param forceCache True if it should return cached data. Has priority over ignoreCache.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the message unread count.\n   */\n  getUnreadReceivedMessages(notUsed = true,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  forceCache = false, ignoreCache = false, siteId) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        read: false,\n        limitfrom: 0,\n        limitnum: AddonMessagesProvider.LIMIT_MESSAGES,\n        useridto: site.getUserId(),\n        useridfrom: 0\n      };\n      const preSets = {};\n      if (forceCache) {\n        preSets.omitExpires = true;\n      } else if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      return _this28.getMessages(params, preSets, siteId);\n    })();\n  }\n  /**\n   * Invalidate all contacts cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateAllContactsCache(siteId) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield _this29.invalidateContactsCache(siteId);\n      yield _this29.invalidateBlockedContactsCache(siteId);\n    })();\n  }\n  /**\n   * Invalidate blocked contacts cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateBlockedContactsCache(siteId) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const userId = site.getUserId();\n      yield site.invalidateWsCacheForKey(_this30.getCacheKeyForBlockedContacts(userId));\n    })();\n  }\n  /**\n   * Invalidate contacts cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateContactsCache(siteId) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this31.getCacheKeyForContacts());\n    })();\n  }\n  /**\n   * Invalidate user contacts cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateUserContacts(siteId) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this32.getCacheKeyForUserContacts());\n    })();\n  }\n  /**\n   * Invalidate contact requests cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateContactRequestsCache(siteId) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.invalidateWsCacheForKey(_this33.getCacheKeyForContactRequests());\n    })();\n  }\n  /**\n   * Invalidate contact requests count cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateContactRequestsCountCache(siteId) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this34.getCacheKeyForContactRequestsCount());\n    })();\n  }\n  /**\n   * Invalidate conversation.\n   *\n   * @param conversationId Conversation ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  invalidateConversation(conversationId, siteId, userId) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this35.getCacheKeyForConversation(userId, conversationId));\n    })();\n  }\n  /**\n   * Invalidate conversation between users.\n   *\n   * @param otherUserId Other user ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  invalidateConversationBetweenUsers(otherUserId, siteId, userId) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this36.getCacheKeyForConversationBetweenUsers(userId, otherUserId));\n    })();\n  }\n  /**\n   * Invalidate conversation members cache.\n   *\n   * @param conversationId Conversation ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  invalidateConversationMembers(conversationId, siteId, userId) {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this37.getCacheKeyForConversationMembers(userId, conversationId));\n    })();\n  }\n  /**\n   * Invalidate conversation messages cache.\n   *\n   * @param conversationId Conversation ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  invalidateConversationMessages(conversationId, siteId, userId) {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this38.getCacheKeyForConversationMessages(userId, conversationId));\n    })();\n  }\n  /**\n   * Invalidate conversations cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  invalidateConversations(siteId, userId) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKeyStartingWith(_this39.getCommonCacheKeyForUserConversations(userId));\n    })();\n  }\n  /**\n   * Invalidate conversation counts cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateConversationCounts(siteId) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this40.getCacheKeyForConversationCounts());\n    })();\n  }\n  /**\n   * Invalidate discussion cache.\n   *\n   * @param userId The user ID with whom the current user is having the discussion.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateDiscussionCache(userId, siteId) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this41.getCacheKeyForDiscussion(userId));\n    })();\n  }\n  /**\n   * Invalidate discussions cache.\n   *\n   * Note that {@link this.getDiscussions} uses the contacts, so we need to invalidate contacts too.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateDiscussionsCache(siteId) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const promises = [];\n      promises.push(site.invalidateWsCacheForKey(_this42.getCacheKeyForDiscussions()));\n      promises.push(_this42.invalidateContactsCache(site.getId()));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidate member info cache.\n   *\n   * @param otherUserId The other user ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  invalidateMemberInfo(otherUserId, siteId, userId) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this43.getCacheKeyForMemberInfo(userId, otherUserId));\n    })();\n  }\n  /**\n   * Invalidate get message preferences.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data is invalidated.\n   */\n  invalidateMessagePreferences(siteId) {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this44.getMessagePreferencesCacheKey());\n    })();\n  }\n  /**\n   * Invalidate all cache entries with member info.\n   *\n   * @param userId Id of the user to invalidate.\n   * @param site Site object.\n   * @returns Promise resolved when done.\n   */\n  invalidateAllMemberInfo(userId, site) {\n    var _this45 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreUtils.allPromises([_this45.invalidateMemberInfo(userId, site.id), _this45.invalidateUserContacts(site.id), _this45.invalidateBlockedContactsCache(site.id), _this45.invalidateContactRequestsCache(site.id), _this45.invalidateConversations(site.id), _this45.getConversationBetweenUsers(userId, undefined, undefined, undefined, undefined, undefined, undefined, undefined, site.id, undefined, true).then(conversation => CoreUtils.allPromises([_this45.invalidateConversation(conversation.id), _this45.invalidateConversationMembers(conversation.id, site.id)])).catch(() => {\n        // The conversation does not exist or we can't fetch it now, ignore it.\n      })]);\n    })();\n  }\n  /**\n   * Invalidate a self conversation.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  invalidateSelfConversation(siteId, userId) {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this46.getCacheKeyForSelfConversation(userId));\n    })();\n  }\n  /**\n   * Invalidate unread conversation counts cache.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  invalidateUnreadConversationCounts(siteId) {\n    var _this47 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      if (_this47.isGroupMessagingEnabled()) {\n        // @since 3.6\n        return site.invalidateWsCacheForKey(_this47.getCacheKeyForUnreadConversationCounts());\n      } else {\n        return site.invalidateWsCacheForKey(_this47.getCacheKeyForMessageCount(site.getUserId()));\n      }\n    })();\n  }\n  /**\n   * Checks if the a user is blocked by the current user.\n   *\n   * @param userId The user ID to check against.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved with boolean, rejected when we do not know.\n   */\n  isBlocked(userId, siteId) {\n    var _this48 = this;\n    return _asyncToGenerator(function* () {\n      if (_this48.isGroupMessagingEnabled()) {\n        const member = yield _this48.getMemberInfo(userId, siteId);\n        return member.isblocked;\n      }\n      const blockedContacts = yield _this48.getBlockedContacts(siteId);\n      if (!blockedContacts.users || blockedContacts.users.length < 1) {\n        return false;\n      }\n      return blockedContacts.users.some(user => userId == user.id);\n    })();\n  }\n  /**\n   * Checks if the a user is a contact of the current user.\n   *\n   * @param userId The user ID to check against.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved with boolean, rejected when we do not know.\n   */\n  isContact(userId, siteId) {\n    var _this49 = this;\n    return _asyncToGenerator(function* () {\n      if (_this49.isGroupMessagingEnabled()) {\n        const member = yield _this49.getMemberInfo(userId, siteId);\n        return member.iscontact;\n      }\n      const contacts = yield _this49.getContacts(siteId);\n      return ['online', 'offline'].some(type => {\n        if (contacts[type] && contacts[type].length > 0) {\n          return contacts[type].some(user => userId == user.id);\n        }\n        return false;\n      });\n    })();\n  }\n  /**\n   * Returns whether or not group messaging is supported.\n   *\n   * @returns If related WS is available on current site.\n   * @since 3.6\n   */\n  isGroupMessagingEnabled() {\n    return CoreSites.wsAvailableInCurrentSite('core_message_get_conversations');\n  }\n  /**\n   * Returns whether or not group messaging is supported in a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether related WS is available on a certain site.\n   * @since 3.6\n   */\n  isGroupMessagingEnabledInSite(siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const site = yield CoreSites.getSite(siteId);\n        return site.wsAvailable('core_message_get_conversations');\n      } catch (_unused4) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Returns whether or not messaging is enabled for a certain site.\n   *\n   * This could call a WS so do not abuse this method.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when enabled, otherwise rejected.\n   */\n  isMessagingEnabledForSite(siteId) {\n    var _this50 = this;\n    return _asyncToGenerator(function* () {\n      const enabled = yield _this50.isPluginEnabled(siteId);\n      if (!enabled) {\n        throw new CoreError('Messaging not enabled for the site');\n      }\n    })();\n  }\n  /**\n   * Returns whether or not a site supports muting or unmuting a conversation.\n   *\n   * @param site The site to check, undefined for current site.\n   * @returns If related WS is available on current site.\n   * @since 3.7\n   */\n  isMuteConversationEnabled(site) {\n    var _site;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site = site) !== null && _site !== void 0 && _site.wsAvailable('core_message_mute_conversations'));\n  }\n  /**\n   * Returns whether or not a site supports muting or unmuting a conversation.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether related WS is available on a certain site.\n   * @since 3.7\n   */\n  isMuteConversationEnabledInSite(siteId) {\n    var _this51 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const site = yield CoreSites.getSite(siteId);\n        return _this51.isMuteConversationEnabled(site);\n      } catch (_unused5) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Returns whether or not the plugin is enabled in a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if enabled, rejected or resolved with false otherwise.\n   */\n  isPluginEnabled(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.canUseAdvancedFeature('messaging');\n    })();\n  }\n  /**\n   * Returns whether or not self conversation is supported in a certain site.\n   *\n   * @param site Site. If not defined, current site.\n   * @returns If related WS is available on the site.\n   * @since 3.7\n   */\n  isSelfConversationEnabled(site) {\n    var _site2;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site2 = site) !== null && _site2 !== void 0 && _site2.wsAvailable('core_message_get_self_conversation'));\n  }\n  /**\n   * Returns whether or not self conversation is supported in a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether related WS is available on a certain site.\n   * @since 3.7\n   */\n  isSelfConversationEnabledInSite(siteId) {\n    var _this52 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const site = yield CoreSites.getSite(siteId);\n        return _this52.isSelfConversationEnabled(site);\n      } catch (_unused6) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Mark message as read.\n   *\n   * @param messageId ID of message to mark as read\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean marking success or not.\n   */\n  markMessageRead(messageId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        messageid: messageId,\n        timeread: CoreTimeUtils.timestamp()\n      };\n      return site.write('core_message_mark_message_read', params);\n    })();\n  }\n  /**\n   * Mark all messages of a conversation as read.\n   *\n   * @param conversationId Conversation ID.\n   * @returns Promise resolved if success.\n   * @since 3.6\n   */\n  markAllConversationMessagesRead(conversationId) {\n    return _asyncToGenerator(function* () {\n      var _CoreSites$getCurrent3;\n      const params = {\n        userid: CoreSites.getCurrentSiteUserId(),\n        conversationid: conversationId\n      };\n      const preSets = {\n        responseExpected: false\n      };\n      yield (_CoreSites$getCurrent3 = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent3 === void 0 ? void 0 : _CoreSites$getCurrent3.write('core_message_mark_all_conversation_messages_as_read', params, preSets);\n    })();\n  }\n  /**\n   * Mark all messages of a discussion as read.\n   *\n   * @param userIdFrom User Id for the sender.\n   * @returns Promise resolved with boolean marking success or not.\n   * @deprecatedonmoodle since 3.6\n   */\n  markAllMessagesRead(userIdFrom) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        useridto: CoreSites.getCurrentSiteUserId(),\n        useridfrom: userIdFrom\n      };\n      const preSets = {\n        typeExpected: 'boolean'\n      };\n      const site = CoreSites.getCurrentSite();\n      if (!site) {\n        return false;\n      }\n      return site.write('core_message_mark_all_messages_as_read', params, preSets);\n    })();\n  }\n  /**\n   * Mute or unmute a conversation.\n   *\n   * @param conversationId Conversation ID.\n   * @param set Whether to mute or unmute.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  muteConversation(conversationId, set, siteId, userId) {\n    var _this53 = this;\n    return _asyncToGenerator(function* () {\n      yield _this53.muteConversations([conversationId], set, siteId, userId);\n    })();\n  }\n  /**\n   * Mute or unmute some conversations.\n   *\n   * @param conversations Conversation IDs.\n   * @param set Whether to mute or unmute.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  muteConversations(conversations, set, siteId, userId) {\n    var _this54 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const params = {\n        userid: userId,\n        conversationids: conversations\n      };\n      const wsName = set ? 'core_message_mute_conversations' : 'core_message_unmute_conversations';\n      yield site.write(wsName, params);\n      // Invalidate the conversations data.\n      const promises = conversations.map(conversationId => _this54.invalidateConversation(conversationId, site.getId(), userId));\n      try {\n        yield Promise.all(promises);\n      } catch (_unused7) {\n        // Ignore errors.\n      }\n    })();\n  }\n  /**\n   * Refresh the number of contact requests sent to the current user.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved with the number of contact requests.\n   * @since 3.6\n   */\n  refreshContactRequestsCount(siteId) {\n    var _this55 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield _this55.invalidateContactRequestsCountCache(siteId);\n      return _this55.getContactRequestsCount(siteId);\n    })();\n  }\n  /**\n   * Refresh unread conversation counts and trigger event.\n   *\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved with the unread favourite, individual and group conversation counts.\n   */\n  refreshUnreadConversationCounts(siteId) {\n    var _this56 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield _this56.invalidateUnreadConversationCounts(siteId);\n      return _this56.getUnreadConversationCounts(siteId);\n    })();\n  }\n  /**\n   * Remove a contact.\n   *\n   * @param userId User ID of the person to remove.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved when done.\n   */\n  removeContact(userId, siteId) {\n    var _this57 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userids: [userId]\n      };\n      const preSets = {\n        responseExpected: false\n      };\n      yield site.write('core_message_delete_contacts', params, preSets);\n      return CoreUtils.allPromises([_this57.invalidateUserContacts(site.id), _this57.invalidateAllMemberInfo(userId, site), _this57.invalidateContactsCache(site.id)]).then(() => {\n        const data = {\n          userId,\n          contactRemoved: true\n        };\n        CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n        return;\n      });\n    })();\n  }\n  /**\n   * Search for contacts.\n   *\n   * By default this only returns the first 100 contacts, but note that the WS can return thousands\n   * of results which would take a while to process. The limit here is just a convenience to\n   * prevent viewed to crash because too many DOM elements are created.\n   *\n   * @param query The query string.\n   * @param limit The number of results to return, 0 for none.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the contacts.\n   */\n  searchContacts(query, limit = 100, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        searchtext: query,\n        onlymycourses: false\n      };\n      const preSets = {\n        getFromCache: false\n      };\n      let contacts = yield site.read('core_message_search_contacts', params, preSets);\n      if (limit && contacts.length > limit) {\n        contacts = contacts.splice(0, limit);\n      }\n      CoreUser.storeUsers(contacts);\n      return contacts;\n    })();\n  }\n  /**\n   * Search for all the messges with a specific text.\n   *\n   * @param query The query string.\n   * @param userId The user ID. If not defined, current user.\n   * @param limitFrom Position of the first result to get. Defaults to 0.\n   * @param limitNum Number of results to get. Defaults to AddonMessagesProvider.LIMIT_SEARCH.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the results.\n   */\n  searchMessages(query, userId, limitFrom = 0, limitNum = AddonMessagesProvider.LIMIT_SEARCH, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userid: userId || site.getUserId(),\n        search: query,\n        limitfrom: limitFrom,\n        limitnum: limitNum <= 0 ? 0 : limitNum + 1\n      };\n      const preSets = {\n        getFromCache: false\n      };\n      const result = yield site.read('core_message_data_for_messagearea_search_messages', params, preSets);\n      if (!result.contacts || !result.contacts.length) {\n        return {\n          messages: [],\n          canLoadMore: false\n        };\n      }\n      const users = result.contacts.map(contact => ({\n        id: contact.userid,\n        fullname: contact.fullname,\n        profileimageurl: contact.profileimageurl\n      }));\n      CoreUser.storeUsers(users, site.id);\n      if (limitNum <= 0) {\n        return {\n          messages: result.contacts,\n          canLoadMore: false\n        };\n      }\n      return {\n        messages: result.contacts.slice(0, limitNum),\n        canLoadMore: result.contacts.length > limitNum\n      };\n    })();\n  }\n  /**\n   * Search for users.\n   *\n   * @param query Text to search for.\n   * @param limitFrom Position of the first found user to fetch.\n   * @param limitNum Number of found users to fetch. Defaults to AddonMessagesProvider.LIMIT_SEARCH.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved with two lists of found users: contacts and non-contacts.\n   * @since 3.6\n   */\n  searchUsers(query, limitFrom = 0, limitNum = AddonMessagesProvider.LIMIT_SEARCH, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        userid: site.getUserId(),\n        search: query,\n        limitfrom: limitFrom,\n        limitnum: limitNum <= 0 ? 0 : limitNum + 1\n      };\n      const preSets = {\n        getFromCache: false\n      };\n      const result = yield site.read('core_message_message_search_users', params, preSets);\n      const contacts = result.contacts || [];\n      const nonContacts = result.noncontacts || [];\n      CoreUser.storeUsers(contacts, site.id);\n      CoreUser.storeUsers(nonContacts, site.id);\n      if (limitNum <= 0) {\n        return {\n          contacts,\n          nonContacts,\n          canLoadMoreContacts: false,\n          canLoadMoreNonContacts: false\n        };\n      }\n      return {\n        contacts: contacts.slice(0, limitNum),\n        nonContacts: nonContacts.slice(0, limitNum),\n        canLoadMoreContacts: contacts.length > limitNum,\n        canLoadMoreNonContacts: nonContacts.length > limitNum\n      };\n    })();\n  }\n  /**\n   * Send a message to someone.\n   *\n   * @param toUserId User ID to send the message to.\n   * @param message The message to send\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with:\n   *         - sent (Boolean) True if message was sent to server, false if stored in device.\n   *         - message (Object) If sent=false, contains the stored message.\n   */\n  sendMessage(toUserId, message, siteId) {\n    var _this58 = this;\n    return _asyncToGenerator(function* () {\n      // Convenience function to store a message to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          const entry = yield AddonMessagesOffline.saveMessage(toUserId, message, siteId);\n          return {\n            sent: false,\n            message: {\n              msgid: -1,\n              text: entry.smallmessage,\n              timecreated: entry.timecreated,\n              conversationid: 0,\n              useridfrom: entry.useridfrom,\n              candeletemessagesforallusers: true\n            }\n          };\n        });\n        return function storeOffline() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the message.\n        return storeOffline();\n      }\n      // Check if this conversation already has offline messages.\n      // If so, store this message since they need to be sent in order.\n      let hasStoredMessages = false;\n      try {\n        hasStoredMessages = yield AddonMessagesOffline.hasMessages(toUserId, siteId);\n      } catch (_unused8) {\n        // Error, it's safer to assume it has messages.\n        hasStoredMessages = true;\n      }\n      if (hasStoredMessages) {\n        return storeOffline();\n      }\n      try {\n        // Online and no messages stored. Send it to server.\n        const result = yield _this58.sendMessageOnline(toUserId, message);\n        return {\n          sent: true,\n          message: result\n        };\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, the user cannot send the message so don't store it.\n          throw error;\n        }\n        // Error sending message, store it to retry later.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Send a message to someone. It will fail if offline or cannot connect.\n   *\n   * @param toUserId User ID to send the message to.\n   * @param message The message to send\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success, rejected if failure.\n   */\n  sendMessageOnline(toUserId, message, siteId) {\n    var _this59 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const messages = [{\n        touserid: toUserId,\n        text: message,\n        textformat: 1\n      }];\n      const response = yield _this59.sendMessagesOnline(messages, siteId);\n      if (response && response[0] && response[0].msgid === -1) {\n        // There was an error, and it should be translated already.\n        throw new CoreWSError({\n          message: response[0].errormessage,\n          errorcode: 'sendmessageerror'\n        });\n      }\n      try {\n        yield _this59.invalidateDiscussionCache(toUserId, siteId);\n      } catch (_unused9) {\n        // Ignore errors.\n      }\n      return response[0];\n    })();\n  }\n  /**\n   * Send some messages. It will fail if offline or cannot connect.\n   * IMPORTANT: Sending several messages at once for the same discussions can cause problems with display order,\n   * since messages with same timecreated aren't ordered by ID.\n   *\n   * @param messages Messages to send. Each message must contain touserid, text and textformat.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success, rejected if failure. Promise resolved doesn't mean that messages\n   *         have been sent, the resolve param can contain errors for messages not sent.\n   */\n  sendMessagesOnline(messages, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const data = {\n        messages\n      };\n      return site.write('core_message_send_instant_messages', data);\n    })();\n  }\n  /**\n   * Send a message to a conversation.\n   *\n   * @param conversation Conversation.\n   * @param message The message to send.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with:\n   *         - sent (boolean) True if message was sent to server, false if stored in device.\n   *         - message (any) If sent=false, contains the stored message.\n   * @since 3.6\n   */\n  sendMessageToConversation(conversation, message, siteId) {\n    var _this60 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      siteId = site.getId();\n      // Convenience function to store a message to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* () {\n          const entry = yield AddonMessagesOffline.saveConversationMessage(conversation, message, siteId);\n          return {\n            sent: false,\n            message: {\n              id: -1,\n              useridfrom: site.getUserId(),\n              text: entry.text,\n              timecreated: entry.timecreated\n            }\n          };\n        });\n        return function storeOffline() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the message.\n        return storeOffline();\n      }\n      // Check if this conversation already has offline messages.\n      // If so, store this message since they need to be sent in order.\n      let hasStoredMessages = false;\n      try {\n        hasStoredMessages = yield AddonMessagesOffline.hasConversationMessages(conversation.id, siteId);\n      } catch (_unused10) {\n        // Error, it's safer to assume it has messages.\n        hasStoredMessages = true;\n      }\n      if (hasStoredMessages) {\n        return storeOffline();\n      }\n      try {\n        // Online and no messages stored. Send it to server.\n        const result = yield _this60.sendMessageToConversationOnline(conversation.id, message, siteId);\n        return {\n          sent: true,\n          message: result\n        };\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, the user cannot send the message so don't store it.\n          throw error;\n        }\n        // Error sending message, store it to retry later.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Send a message to a conversation. It will fail if offline or cannot connect.\n   *\n   * @param conversationId Conversation ID.\n   * @param message The message to send\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success, rejected if failure.\n   * @since 3.6\n   */\n  sendMessageToConversationOnline(conversationId, message, siteId) {\n    var _this61 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const messages = [{\n        text: message,\n        textformat: 1\n      }];\n      const response = yield _this61.sendMessagesToConversationOnline(conversationId, messages, siteId);\n      try {\n        yield _this61.invalidateConversationMessages(conversationId, siteId);\n      } catch (_unused11) {\n        // Ignore errors.\n      }\n      return response[0];\n    })();\n  }\n  /**\n   * Send some messages to a conversation. It will fail if offline or cannot connect.\n   *\n   * @param conversationId Conversation ID.\n   * @param messages Messages to send. Each message must contain text and, optionally, textformat.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success, rejected if failure.\n   * @since 3.6\n   */\n  sendMessagesToConversationOnline(conversationId, messages, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        conversationid: conversationId,\n        messages: messages.map(message => ({\n          text: message.text,\n          textformat: message.textformat !== undefined ? message.textformat : 1\n        }))\n      };\n      return site.write('core_message_send_messages_to_conversation', params);\n    })();\n  }\n  /**\n   * Set or unset a conversation as favourite.\n   *\n   * @param conversationId Conversation ID.\n   * @param set Whether to set or unset it as favourite.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  setFavouriteConversation(conversationId, set, siteId, userId) {\n    return this.setFavouriteConversations([conversationId], set, siteId, userId);\n  }\n  /**\n   * Set or unset some conversations as favourites.\n   *\n   * @param conversations Conversation IDs.\n   * @param set Whether to set or unset them as favourites.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param userId User ID. If not defined, current user in the site.\n   * @returns Resolved when done.\n   */\n  setFavouriteConversations(conversations, set, siteId, userId) {\n    var _this62 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const params = {\n        userid: userId,\n        conversations: conversations\n      };\n      const wsName = set ? 'core_message_set_favourite_conversations' : 'core_message_unset_favourite_conversations';\n      yield site.write(wsName, params);\n      // Invalidate the conversations data.\n      const promises = conversations.map(conversationId => _this62.invalidateConversation(conversationId, site.getId(), userId));\n      try {\n        yield Promise.all(promises);\n      } catch (_unused12) {\n        // Ignore errors.\n      }\n    })();\n  }\n  /**\n   * Helper method to sort conversations by last message time.\n   *\n   * @param conversations Array of conversations.\n   * @returns Conversations sorted with most recent last.\n   */\n  sortConversations(conversations) {\n    return conversations.sort((a, b) => {\n      const timeA = Number(a.lastmessagedate);\n      const timeB = Number(b.lastmessagedate);\n      if (timeA == timeB && a.id) {\n        // Same time, sort by ID.\n        return a.id <= b.id ? 1 : -1;\n      }\n      return timeA <= timeB ? 1 : -1;\n    });\n  }\n  sortMessages(messages) {\n    return messages.sort((a, b) => {\n      // Pending messages last.\n      if (a.pending && !b.pending) {\n        return 1;\n      } else if (!a.pending && b.pending) {\n        return -1;\n      }\n      const timecreatedA = a.timecreated;\n      const timecreatedB = b.timecreated;\n      if (timecreatedA == timecreatedB && 'id' in a) {\n        const bId = 'id' in b ? b.id : 0;\n        // Same time, sort by ID.\n        return a.id >= bId ? 1 : -1;\n      }\n      return timecreatedA >= timecreatedB ? 1 : -1;\n    });\n  }\n  /**\n   * Store user data from contacts in local DB.\n   *\n   * @param contactTypes List of contacts grouped in types.\n   */\n  storeUsersFromAllContacts(contactTypes) {\n    for (const x in contactTypes) {\n      CoreUser.storeUsers(contactTypes[x]);\n    }\n  }\n  /**\n   * Store user data from discussions in local DB.\n   *\n   * @param discussions List of discussions.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  storeUsersFromDiscussions(discussions, siteId) {\n    const users = [];\n    for (const userId in discussions) {\n      users.push({\n        id: parseInt(userId, 10),\n        fullname: discussions[userId].fullname,\n        profileimageurl: discussions[userId].profileimageurl\n      });\n    }\n    CoreUser.storeUsers(users, siteId);\n  }\n  /**\n   * Unblock a user.\n   *\n   * @param userId User ID of the person to unblock.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Resolved when done.\n   */\n  unblockContact(userId, siteId) {\n    var _this63 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      try {\n        if (site.wsAvailable('core_message_unblock_user')) {\n          // Since Moodle 3.6\n          const params = {\n            userid: site.getUserId(),\n            unblockeduserid: userId\n          };\n          yield site.write('core_message_unblock_user', params);\n        } else {\n          const params = {\n            userids: [userId]\n          };\n          const preSets = {\n            responseExpected: false\n          };\n          yield site.write('core_message_unblock_contacts', params, preSets);\n        }\n        yield _this63.invalidateAllMemberInfo(userId, site);\n      } finally {\n        const data = {\n          userId,\n          userUnblocked: true\n        };\n        CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n      }\n    })();\n  }\n}\n_class = AddonMessagesProvider;\n_class.NEW_MESSAGE_EVENT = 'addon_messages_new_message_event';\n_class.READ_CHANGED_EVENT = 'addon_messages_read_changed_event';\n_class.OPEN_CONVERSATION_EVENT = 'addon_messages_open_conversation_event';\n// Notify a conversation should be opened.\n_class.UPDATE_CONVERSATION_LIST_EVENT = 'addon_messages_update_conversation_list_event';\n_class.MEMBER_INFO_CHANGED_EVENT = 'addon_messages_member_changed_event';\n_class.UNREAD_CONVERSATION_COUNTS_EVENT = 'addon_messages_unread_conversation_counts_event';\n_class.CONTACT_REQUESTS_COUNT_EVENT = 'addon_messages_contact_requests_count_event';\n_class.POLL_INTERVAL = 10000;\n_class.PUSH_SIMULATION_COMPONENT = 'AddonMessagesPushSimulation';\n_class.MESSAGE_PRIVACY_COURSEMEMBER = 0;\n// Privacy setting for being messaged by anyone within courses user is member.\n_class.MESSAGE_PRIVACY_ONLYCONTACTS = 1;\n// Privacy setting for being messaged only by contacts.\n_class.MESSAGE_PRIVACY_SITE = 2;\n// Privacy setting for being messaged by anyone on the site.\n_class.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL = 1;\n// An individual conversation.\n_class.MESSAGE_CONVERSATION_TYPE_GROUP = 2;\n// A group conversation.\n_class.MESSAGE_CONVERSATION_TYPE_SELF = 3;\n// A self conversation.\n_class.LIMIT_CONTACTS = 50;\n_class.LIMIT_MESSAGES = 50;\n_class.LIMIT_INITIAL_USER_SEARCH = 3;\n_class.LIMIT_SEARCH = 50;\n_class.NOTIFICATION_PREFERENCES_KEY = 'message_provider_moodle_instantmessage';\n_class.fac = function AddonMessagesProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.prov = /*@__PURE__*/i0.defineInjectable({\n  token: _class,\n  factory: _class.fac,\n  providedIn: 'root'\n});\nexport const AddonMessages = makeSingleton(AddonMessagesProvider);","map":{"version":3,"names":["CoreLogger","CoreSites","CoreNetwork","CoreUser","AddonMessagesOffline","CoreUtils","CoreTimeUtils","CoreEvents","CoreSite","makeSingleton","CoreError","AddonMessagesSyncProvider","CoreWSError","ROOT_CACHE_KEY","AddonMessagesProvider","constructor","logger","getInstance","addContact","userId","siteId","_this","_asyncToGenerator","site","getSite","params","userids","write","invalidateAllContactsCache","getId","blockContact","_this2","wsAvailable","userid","getUserId","blockeduserid","invalidateAllMemberInfo","data","userBlocked","trigger","MEMBER_INFO_CHANGED_EVENT","id","confirmContactRequest","_this3","requesteduserid","allPromises","invalidateContactsCache","invalidateUserContacts","refreshContactRequestsCount","finally","contactRequestConfirmed","createContactRequest","_this4","_result$warnings","result","warnings","length","contactRequestCreated","declineContactRequest","_this5","contactRequestDeclined","deleteConversation","conversationId","_this6","deleteConversations","conversationIds","conversationids","Promise","all","map","_ref","deleteConversationMessages","_unused","_x","apply","arguments","deleteMessage","message","deleteForAll","deleteMessageForAllOnline","deleteMessageOnline","read","touserid","smallmessage","timecreated","deleteConversationMessage","conversationid","text","_this7","_CoreSites$getCurrent","getCurrentSiteUserId","messageid","undefined","getCurrentSite","invalidateDiscussionCache","_this8","_CoreSites$getCurrent2","formatConversation","conversation","numMessages","messages","lastMessage","lastmessage","lastmessagedate","sentfromcurrentuser","useridfrom","type","MESSAGE_CONVERSATION_TYPE_GROUP","isIndividual","MESSAGE_CONVERSATION_TYPE_INDIVIDUAL","otherUser","members","find","member","name","fullname","imageurl","profileimageurl","showonlinestatus","isonline","isblocked","getCacheKeyForBlockedContacts","getCacheKeyForContacts","getCacheKeyForUserContacts","getCacheKeyForContactRequests","getCacheKeyForContactRequestsCount","getCacheKeyForDiscussion","getCacheKeyForMessageCount","getCacheKeyForUnreadConversationCounts","getCacheKeyForDiscussions","getCacheKeyForConversation","getCacheKeyForConversationBetweenUsers","otherUserId","getCacheKeyForConversationMembers","getCacheKeyForConversationMessages","getCacheKeyForConversations","favourites","getCommonCacheKeyForUserConversations","getCacheKeyForConversationCounts","getCacheKeyForMemberInfo","getCacheKeyForSelfConversation","getRootCacheKeyForConversations","getAllContacts","_this9","getCurrentSiteId","contacts","getContacts","blocked","getBlockedContacts","users","storeUsersFromAllContacts","_unused2","_this10","preSets","cacheKey","updateFrequency","FREQUENCY_OFTEN","_this11","validContacts","online","offline","strangers","typeName","forEach","contact","push","getUserContacts","limitFrom","limitNum","LIMIT_CONTACTS","_this12","limitfrom","limitnum","canLoadMore","storeUsers","slice","getContactRequests","_this13","requests","getContactRequestsCount","_this14","typeExpected","count","CONTACT_REQUESTS_COUNT_EVENT","getConversation","includeContactRequests","includePrivacyInfo","messageOffset","messageLimit","memberOffset","memberLimit","newestFirst","_this15","includecontactrequests","includeprivacyinfo","messageoffset","messagelimit","memberoffset","memberlimit","newestmessagesfirst","getConversationBetweenUsers","preferCache","_this16","omitExpires","otheruserid","getConversationMembers","limitTo","_this17","_limitTo","LIMIT_MESSAGES","FREQUENCY_SOMETIMES","getConversationMessages","options","_this18","_options$limitTo","_options$newestFirst","timeFrom","currentuserid","convid","newest","timefrom","getFromCache","saveToCache","emergencyCache","forceCache","ignoreCache","excludePending","offlineMessages","concat","getConversations","_this19","isVersionGreaterEqualThan","mergeself","response","error","conversations","getConversationCounts","_this20","counts","individual","types","group","self","MESSAGE_CONVERSATION_TYPE_SELF","getDiscussion","lfReceivedUnread","lfReceivedRead","lfSentUnread","lfSentRead","notUsed","_this21","useridto","received","getRecentMessages","hasReceived","sent","hasSent","sortMessages","getMessages","getDiscussions","_this22","discussions","treatRecentMessage","userFullname","timeread","pending","currentUserId","unread","messageId","discMessage","user","userfromfullname","usertofullname","getAllMessages","discussionsWithUserImg","getDiscussionsUserImg","storeUsersFromDiscussions","promises","getProfile","then","catch","getMemberInfo","_this23","referenceuserid","getMessagePreferencesCacheKey","getMessagePreferences","_this24","debug","preferences","blocknoncontacts","newestfirst","limitFromUnread","limitFromRead","_this25","_unused3","getSelfConversation","_this26","getUnreadConversationCounts","_this27","isGroupMessagingEnabled","UNREAD_CONVERSATION_COUNTS_EVENT","getUnreadReceivedMessages","_this28","_this29","invalidateBlockedContactsCache","_this30","invalidateWsCacheForKey","_this31","_this32","invalidateContactRequestsCache","_this33","invalidateContactRequestsCountCache","_this34","invalidateConversation","_this35","invalidateConversationBetweenUsers","_this36","invalidateConversationMembers","_this37","invalidateConversationMessages","_this38","invalidateConversations","_this39","invalidateWsCacheForKeyStartingWith","invalidateConversationCounts","_this40","_this41","invalidateDiscussionsCache","_this42","invalidateMemberInfo","_this43","invalidateMessagePreferences","_this44","_this45","invalidateSelfConversation","_this46","invalidateUnreadConversationCounts","_this47","isBlocked","_this48","blockedContacts","some","isContact","_this49","iscontact","wsAvailableInCurrentSite","isGroupMessagingEnabledInSite","_unused4","isMessagingEnabledForSite","_this50","enabled","isPluginEnabled","isMuteConversationEnabled","_site","isMuteConversationEnabledInSite","_this51","_unused5","canUseAdvancedFeature","isSelfConversationEnabled","_site2","isSelfConversationEnabledInSite","_this52","_unused6","markMessageRead","timestamp","markAllConversationMessagesRead","_CoreSites$getCurrent3","responseExpected","markAllMessagesRead","userIdFrom","muteConversation","set","_this53","muteConversations","_this54","wsName","_unused7","_this55","refreshUnreadConversationCounts","_this56","removeContact","_this57","contactRemoved","searchContacts","query","limit","searchtext","onlymycourses","splice","searchMessages","LIMIT_SEARCH","search","searchUsers","nonContacts","noncontacts","canLoadMoreContacts","canLoadMoreNonContacts","sendMessage","toUserId","_this58","storeOffline","_ref2","entry","saveMessage","msgid","candeletemessagesforallusers","isOnline","hasStoredMessages","hasMessages","_unused8","sendMessageOnline","isWebServiceError","_this59","textformat","sendMessagesOnline","errormessage","errorcode","_unused9","sendMessageToConversation","_this60","_ref3","saveConversationMessage","hasConversationMessages","_unused10","sendMessageToConversationOnline","_this61","sendMessagesToConversationOnline","_unused11","setFavouriteConversation","setFavouriteConversations","_this62","_unused12","sortConversations","sort","a","b","timeA","Number","timeB","timecreatedA","timecreatedB","bId","contactTypes","x","parseInt","unblockContact","_this63","unblockeduserid","userUnblocked","_class","NEW_MESSAGE_EVENT","READ_CHANGED_EVENT","OPEN_CONVERSATION_EVENT","UPDATE_CONVERSATION_LIST_EVENT","POLL_INTERVAL","PUSH_SIMULATION_COMPONENT","MESSAGE_PRIVACY_COURSEMEMBER","MESSAGE_PRIVACY_ONLYCONTACTS","MESSAGE_PRIVACY_SITE","LIMIT_INITIAL_USER_SEARCH","NOTIFICATION_PREFERENCES_KEY","factory","fac","providedIn","AddonMessages"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/messages/services/messages.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUser, CoreUserBasicData } from '@features/user/services/user';\nimport {\n    AddonMessagesOffline,\n    AddonMessagesOfflineAnyMessagesFormatted,\n    AddonMessagesOfflineConversationMessagesDBRecordFormatted,\n    AddonMessagesOfflineMessagesDBRecordFormatted,\n} from './messages-offline';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { AddonMessagesSyncEvents, AddonMessagesSyncProvider } from './messages-sync';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { AddonNotificationsPreferencesNotificationProcessorState } from '@addons/notifications/services/notifications';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaMessages:';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonMessagesProvider.NEW_MESSAGE_EVENT]: AddonMessagesNewMessagedEventData;\n        [AddonMessagesProvider.READ_CHANGED_EVENT]: AddonMessagesReadChangedEventData;\n        [AddonMessagesProvider.OPEN_CONVERSATION_EVENT]: AddonMessagesOpenConversationEventData;\n        [AddonMessagesProvider.UPDATE_CONVERSATION_LIST_EVENT]: AddonMessagesUpdateConversationListEventData;\n        [AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT]: AddonMessagesMemberInfoChangedEventData;\n        [AddonMessagesProvider.UNREAD_CONVERSATION_COUNTS_EVENT]: AddonMessagesUnreadConversationCountsEventData;\n        [AddonMessagesProvider.CONTACT_REQUESTS_COUNT_EVENT]: AddonMessagesContactRequestCountEventData;\n        [AddonMessagesSyncProvider.AUTO_SYNCED]: AddonMessagesSyncEvents;\n    }\n\n}\n\n/**\n * Service to handle messages.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonMessagesProvider {\n\n    static readonly NEW_MESSAGE_EVENT = 'addon_messages_new_message_event';\n    static readonly READ_CHANGED_EVENT = 'addon_messages_read_changed_event';\n    static readonly OPEN_CONVERSATION_EVENT = 'addon_messages_open_conversation_event'; // Notify a conversation should be opened.\n    static readonly UPDATE_CONVERSATION_LIST_EVENT = 'addon_messages_update_conversation_list_event';\n    static readonly MEMBER_INFO_CHANGED_EVENT = 'addon_messages_member_changed_event';\n    static readonly UNREAD_CONVERSATION_COUNTS_EVENT = 'addon_messages_unread_conversation_counts_event';\n    static readonly CONTACT_REQUESTS_COUNT_EVENT = 'addon_messages_contact_requests_count_event';\n    static readonly POLL_INTERVAL = 10000;\n    static readonly PUSH_SIMULATION_COMPONENT = 'AddonMessagesPushSimulation';\n\n    static readonly MESSAGE_PRIVACY_COURSEMEMBER = 0; // Privacy setting for being messaged by anyone within courses user is member.\n    static readonly MESSAGE_PRIVACY_ONLYCONTACTS = 1; // Privacy setting for being messaged only by contacts.\n    static readonly MESSAGE_PRIVACY_SITE = 2; // Privacy setting for being messaged by anyone on the site.\n    static readonly MESSAGE_CONVERSATION_TYPE_INDIVIDUAL = 1; // An individual conversation.\n    static readonly MESSAGE_CONVERSATION_TYPE_GROUP = 2; // A group conversation.\n    static readonly MESSAGE_CONVERSATION_TYPE_SELF = 3; // A self conversation.\n    static readonly LIMIT_CONTACTS = 50;\n    static readonly LIMIT_MESSAGES = 50;\n    static readonly LIMIT_INITIAL_USER_SEARCH = 3;\n    static readonly LIMIT_SEARCH = 50;\n\n    static readonly NOTIFICATION_PREFERENCES_KEY = 'message_provider_moodle_instantmessage';\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('AddonMessages');\n    }\n\n    /**\n     * Add a contact.\n     *\n     * @param userId User ID of the person to add.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved when done.\n     * @deprecatedonmoodle since 3.6\n     */\n    protected async addContact(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params = {\n            userids: [userId],\n        };\n\n        await site.write('core_message_create_contacts', params);\n\n        await this.invalidateAllContactsCache(site.getId());\n    }\n\n    /**\n     * Block a user.\n     *\n     * @param userId User ID of the person to block.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved when done.\n     */\n    async blockContact(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        try {\n            if (site.wsAvailable('core_message_block_user')) {\n                // Since Moodle 3.6\n                const params: AddonMessagesBlockUserWSParams = {\n                    userid: site.getUserId(),\n                    blockeduserid: userId,\n                };\n                await site.write('core_message_block_user', params);\n            } else {\n                const params: { userids: number[] } = {\n                    userids: [userId],\n                };\n                await site.write('core_message_block_contacts', params);\n            }\n\n            await this.invalidateAllMemberInfo(userId, site);\n        } finally {\n            const data: AddonMessagesMemberInfoChangedEventData = { userId, userBlocked: true };\n\n            CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n        }\n    }\n\n    /**\n     * Confirm a contact request from another user.\n     *\n     * @param userId ID of the user who made the contact request.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved when done.\n     * @since 3.6\n     */\n    async confirmContactRequest(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesConfirmContactRequestWSParams = {\n            userid: userId,\n            requesteduserid: site.getUserId(),\n        };\n\n        await site.write('core_message_confirm_contact_request', params);\n\n        await CoreUtils.allPromises([\n            this.invalidateAllMemberInfo(userId, site),\n            this.invalidateContactsCache(site.id),\n            this.invalidateUserContacts(site.id),\n            this.refreshContactRequestsCount(site.id),\n        ]).finally(() => {\n            const data: AddonMessagesMemberInfoChangedEventData = { userId, contactRequestConfirmed: true };\n            CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n        });\n    }\n\n    /**\n     * Send a contact request to another user.\n     *\n     * @param userId ID of the receiver of the contact request.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved when done.\n     * @since 3.6\n     */\n    async createContactRequest(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        // Use legacy function if not available.\n        if (!site.wsAvailable('core_message_create_contact_request')) {\n            await this.addContact(userId, site.getId());\n        } else {\n            const params: AddonMessagesCreateContactRequestWSParams = {\n                userid: site.getUserId(),\n                requesteduserid: userId,\n            };\n\n            const result = await site.write<AddonMessagesCreateContactRequestWSResponse>(\n                'core_message_create_contact_request',\n                params,\n            );\n\n            if (result.warnings?.length) {\n                throw new CoreWSError(result.warnings[0]);\n            }\n        }\n\n        await this.invalidateAllMemberInfo(userId, site).finally(() => {\n            const data: AddonMessagesMemberInfoChangedEventData = { userId, contactRequestCreated: true };\n            CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n        });\n    }\n\n    /**\n     * Decline a contact request from another user.\n     *\n     * @param userId ID of the user who made the contact request.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved when done.\n     * @since 3.6\n     */\n    async declineContactRequest(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesDeclineContactRequestWSParams = {\n            userid: userId,\n            requesteduserid: site.getUserId(),\n        };\n\n        await site.write('core_message_decline_contact_request', params);\n\n        await CoreUtils.allPromises([\n            this.invalidateAllMemberInfo(userId, site),\n            this.refreshContactRequestsCount(site.id),\n        ]).finally(() => {\n            const data: AddonMessagesMemberInfoChangedEventData = { userId, contactRequestDeclined: true };\n            CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n        });\n    }\n\n    /**\n     * Delete a conversation.\n     *\n     * @param conversationId Conversation to delete.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Promise resolved when the conversation has been deleted.\n     */\n    async deleteConversation(conversationId: number, siteId?: string, userId?: number): Promise<void> {\n        await this.deleteConversations([conversationId], siteId, userId);\n    }\n\n    /**\n     * Delete several conversations.\n     *\n     * @param conversationIds Conversations to delete.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Promise resolved when the conversations have been deleted.\n     */\n    async deleteConversations(conversationIds: number[], siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        const params: AddonMessagesDeleteConversationsByIdWSParams = {\n            userid: userId,\n            conversationids: conversationIds,\n        };\n\n        await site.write('core_message_delete_conversations_by_id', params);\n\n        await Promise.all(conversationIds.map(async (conversationId) => {\n            try {\n                return AddonMessagesOffline.deleteConversationMessages(conversationId, site.getId());\n            } catch {\n                // Ignore errors.\n            }\n        }));\n    }\n\n    /**\n     * Delete a message (online or offline).\n     *\n     * @param message Message to delete.\n     * @param deleteForAll Whether the message should be deleted for all users.\n     * @returns Promise resolved when the message has been deleted.\n     */\n    deleteMessage(message: AddonMessagesConversationMessageFormatted, deleteForAll?: boolean): Promise<void> {\n        if ('id' in message) {\n            // Message has ID, it means it has been sent to the server.\n            if (deleteForAll) {\n                return this.deleteMessageForAllOnline(message.id);\n            } else {\n                return this.deleteMessageOnline(message.id, !!('read' in message && message.read));\n            }\n        }\n\n        // It's an offline message.\n        if (!('conversationid' in message)) {\n            return AddonMessagesOffline.deleteMessage(message.touserid, message.smallmessage, message.timecreated);\n        }\n\n        return AddonMessagesOffline.deleteConversationMessage(message.conversationid, message.text, message.timecreated);\n    }\n\n    /**\n     * Delete a message from the server.\n     *\n     * @param id Message ID.\n     * @param read True if message is read, false otherwise.\n     * @param userId User we want to delete the message for. If not defined, use current user.\n     * @returns Promise resolved when the message has been deleted.\n     */\n    async deleteMessageOnline(id: number, read: boolean, userId?: number): Promise<void> {\n        userId = userId || CoreSites.getCurrentSiteUserId();\n\n        const params: AddonMessagesDeleteMessageWSParams = {\n            messageid: id,\n            userid: userId,\n        };\n\n        if (read !== undefined) {\n            params.read = read;\n        }\n\n        await CoreSites.getCurrentSite()?.write('core_message_delete_message', params);\n\n        await this.invalidateDiscussionCache(userId);\n    }\n\n    /**\n     * Delete a message for all users.\n     *\n     * @param id Message ID.\n     * @param userId User we want to delete the message for. If not defined, use current user.\n     * @returns Promise resolved when the message has been deleted.\n     */\n    async deleteMessageForAllOnline(id: number, userId?: number): Promise<void> {\n        userId = userId || CoreSites.getCurrentSiteUserId();\n\n        const params: AddonMessagesDeleteMessageForAllUsersWSParams = {\n            messageid: id,\n            userid: userId,\n        };\n\n        await CoreSites.getCurrentSite()?.write('core_message_delete_message_for_all_users', params);\n\n        await this.invalidateDiscussionCache(userId);\n    }\n\n    /**\n     * Format a conversation.\n     *\n     * @param conversation Conversation to format.\n     * @param userId User ID viewing the conversation.\n     * @returns Formatted conversation.\n     */\n    protected formatConversation(\n        conversation: AddonMessagesConversationFormatted,\n        userId: number,\n    ): AddonMessagesConversationFormatted {\n\n        const numMessages = conversation.messages.length;\n        const lastMessage = numMessages ? conversation.messages[numMessages - 1] : null;\n\n        conversation.lastmessage = lastMessage ? lastMessage.text : undefined;\n        conversation.lastmessagedate = lastMessage ? lastMessage.timecreated : undefined;\n        conversation.sentfromcurrentuser = lastMessage ? lastMessage.useridfrom == userId : undefined;\n\n        if (conversation.type != AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP) {\n            const isIndividual = conversation.type == AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL;\n\n            const otherUser = conversation.members.find((member) =>\n                (isIndividual && member.id != userId) || (!isIndividual && member.id == userId));\n\n            if (otherUser) {\n                conversation.name = conversation.name ? conversation.name : otherUser.fullname;\n                conversation.imageurl = conversation.imageurl ? conversation.imageurl : otherUser.profileimageurl;\n\n                conversation.otherUser = otherUser;\n                conversation.userid = otherUser.id;\n                conversation.showonlinestatus = otherUser.showonlinestatus;\n                conversation.isonline = otherUser.isonline;\n                conversation.isblocked = otherUser.isblocked;\n                conversation.otherUser = otherUser;\n            }\n        }\n\n        return conversation;\n    }\n\n    /**\n     * Get the cache key for blocked contacts.\n     *\n     * @param userId The user who's contacts we're looking for.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForBlockedContacts(userId: number): string {\n        return ROOT_CACHE_KEY + 'blockedContacts:' + userId;\n    }\n\n    /**\n     * Get the cache key for contacts.\n     *\n     * @returns Cache key.\n     */\n    protected getCacheKeyForContacts(): string {\n        return ROOT_CACHE_KEY + 'contacts';\n    }\n\n    /**\n     * Get the cache key for comfirmed contacts.\n     *\n     * @returns Cache key.\n     */\n    protected getCacheKeyForUserContacts(): string {\n        return ROOT_CACHE_KEY + 'userContacts';\n    }\n\n    /**\n     * Get the cache key for contact requests.\n     *\n     * @returns Cache key.\n     */\n    protected getCacheKeyForContactRequests(): string {\n        return ROOT_CACHE_KEY + 'contactRequests';\n    }\n\n    /**\n     * Get the cache key for contact requests count.\n     *\n     * @returns Cache key.\n     */\n    protected getCacheKeyForContactRequestsCount(): string {\n        return ROOT_CACHE_KEY + 'contactRequestsCount';\n    }\n\n    /**\n     * Get the cache key for a discussion.\n     *\n     * @param userId The other person with whom the current user is having the discussion.\n     * @returns Cache key.\n     */\n    getCacheKeyForDiscussion(userId: number): string {\n        return ROOT_CACHE_KEY + 'discussion:' + userId;\n    }\n\n    /**\n     * Get the cache key for the message count.\n     *\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForMessageCount(userId: number): string {\n        return ROOT_CACHE_KEY + 'count:' + userId;\n    }\n\n    /**\n     * Get the cache key for unread conversation counts.\n     *\n     * @returns Cache key.\n     */\n    protected getCacheKeyForUnreadConversationCounts(): string {\n        return ROOT_CACHE_KEY + 'unreadConversationCounts';\n    }\n\n    /**\n     * Get the cache key for the list of discussions.\n     *\n     * @returns Cache key.\n     */\n    protected getCacheKeyForDiscussions(): string {\n        return ROOT_CACHE_KEY + 'discussions';\n    }\n\n    /**\n     * Get cache key for get conversations.\n     *\n     * @param userId User ID.\n     * @param conversationId Conversation ID.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForConversation(userId: number, conversationId: number): string {\n        return ROOT_CACHE_KEY + 'conversation:' + userId + ':' + conversationId;\n    }\n\n    /**\n     * Get cache key for get conversations between users.\n     *\n     * @param userId User ID.\n     * @param otherUserId Other user ID.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForConversationBetweenUsers(userId: number, otherUserId: number): string {\n        return ROOT_CACHE_KEY + 'conversationBetweenUsers:' + userId + ':' + otherUserId;\n    }\n\n    /**\n     * Get cache key for get conversation members.\n     *\n     * @param userId User ID.\n     * @param conversationId Conversation ID.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForConversationMembers(userId: number, conversationId: number): string {\n        return ROOT_CACHE_KEY + 'conversationMembers:' + userId + ':' + conversationId;\n    }\n\n    /**\n     * Get cache key for get conversation messages.\n     *\n     * @param userId User ID.\n     * @param conversationId Conversation ID.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForConversationMessages(userId: number, conversationId: number): string {\n        return ROOT_CACHE_KEY + 'conversationMessages:' + userId + ':' + conversationId;\n    }\n\n    /**\n     * Get cache key for get conversations.\n     *\n     * @param userId User ID.\n     * @param type Filter by type.\n     * @param favourites Filter favourites.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForConversations(userId: number, type?: number, favourites?: boolean): string {\n        return this.getCommonCacheKeyForUserConversations(userId) + ':' + type + ':' + favourites;\n    }\n\n    /**\n     * Get cache key for conversation counts.\n     *\n     * @returns Cache key.\n     */\n    protected getCacheKeyForConversationCounts(): string {\n        return ROOT_CACHE_KEY + 'conversationCounts';\n    }\n\n    /**\n     * Get cache key for member info.\n     *\n     * @param userId User ID.\n     * @param otherUserId The other user ID.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForMemberInfo(userId: number, otherUserId: number): string {\n        return ROOT_CACHE_KEY + 'memberInfo:' + userId + ':' + otherUserId;\n    }\n\n    /**\n     * Get cache key for get self conversation.\n     *\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getCacheKeyForSelfConversation(userId: number): string {\n        return ROOT_CACHE_KEY + 'selfconversation:' + userId;\n    }\n\n    /**\n     * Get common cache key for get user conversations.\n     *\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getCommonCacheKeyForUserConversations(userId: number): string {\n        return this.getRootCacheKeyForConversations() + userId;\n    }\n\n    /**\n     * Get root cache key for get conversations.\n     *\n     * @returns Cache key.\n     */\n    protected getRootCacheKeyForConversations(): string {\n        return ROOT_CACHE_KEY + 'conversations:';\n    }\n\n    /**\n     * Get all the contacts of the current user.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the WS data.\n     * @deprecatedonmoodle since 3.6\n     */\n    async getAllContacts(siteId?: string): Promise<AddonMessagesGetContactsWSResponse> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const contacts = await this.getContacts(siteId);\n\n        try {\n            const blocked = await this.getBlockedContacts(siteId);\n            contacts.blocked = blocked.users;\n            this.storeUsersFromAllContacts(contacts);\n\n            return contacts;\n        } catch {\n            // The WS for blocked contacts might fail, but we still want the contacts.\n            contacts.blocked = [];\n            this.storeUsersFromAllContacts(contacts);\n\n            return contacts;\n        }\n    }\n\n    /**\n     * Get all the users blocked by the current user.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the WS data.\n     */\n    async getBlockedContacts(siteId?: string): Promise<AddonMessagesGetBlockedUsersWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const userId = site.getUserId();\n\n        const params: AddonMessagesGetBlockedUsersWSParams = {\n            userid: userId,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForBlockedContacts(userId),\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        };\n\n        return site.read('core_message_get_blocked_users', params, preSets);\n    }\n\n    /**\n     * Get the contacts of the current user.\n     *\n     * This excludes the blocked users.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the WS data.\n     * @deprecatedonmoodle since 3.6\n     */\n    async getContacts(siteId?: string): Promise<AddonMessagesGetContactsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForContacts(),\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        };\n\n        const contacts = await site.read<AddonMessagesGetContactsWSResponse>('core_message_get_contacts', undefined, preSets);\n\n        // Filter contacts with negative ID, they are notifications.\n        const validContacts: AddonMessagesGetContactsWSResponse = {\n            online: [],\n            offline: [],\n            strangers: [],\n        };\n\n        for (const typeName in contacts) {\n            if (!validContacts[typeName]) {\n                validContacts[typeName] = [];\n            }\n\n            contacts[typeName].forEach((contact: AddonMessagesGetContactsContact) => {\n                if (contact.id > 0) {\n                    validContacts[typeName].push(contact);\n                }\n            });\n        }\n\n        return validContacts;\n    }\n\n    /**\n     * Get the list of user contacts.\n     *\n     * @param limitFrom Position of the first contact to fetch.\n     * @param limitNum Number of contacts to fetch. Default is AddonMessagesProvider.LIMIT_CONTACTS.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the list of user contacts.\n     * @since 3.6\n     */\n    async getUserContacts(\n        limitFrom: number = 0,\n        limitNum: number = AddonMessagesProvider.LIMIT_CONTACTS,\n        siteId?: string,\n    ): Promise<{contacts: AddonMessagesConversationMember[]; canLoadMore: boolean}> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesGetUserContactsWSParams = {\n            userid: site.getUserId(),\n            limitfrom: limitFrom,\n            limitnum: limitNum <= 0 ? 0 : limitNum + 1,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForUserContacts(),\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        };\n\n        const contacts = await site.read<AddonMessagesGetUserContactsWSResponse>('core_message_get_user_contacts', params, preSets);\n\n        if (!contacts || !contacts.length) {\n            return { contacts: [], canLoadMore: false };\n        }\n\n        CoreUser.storeUsers(contacts, site.id);\n        if (limitNum <= 0) {\n            return { contacts, canLoadMore: false };\n        }\n\n        return {\n            contacts: contacts.slice(0, limitNum),\n            canLoadMore: contacts.length > limitNum,\n        };\n    }\n\n    /**\n     * Get the contact request sent to the current user.\n     *\n     * @param limitFrom Position of the first contact request to fetch.\n     * @param limitNum Number of contact requests to fetch. Default is AddonMessagesProvider.LIMIT_CONTACTS.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the list of contact requests.\n     * @since 3.6\n     */\n    async getContactRequests(\n        limitFrom: number = 0,\n        limitNum: number = AddonMessagesProvider.LIMIT_CONTACTS,\n        siteId?: string,\n    ): Promise<{requests: AddonMessagesConversationMember[]; canLoadMore: boolean}> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesGetContactRequestsWSParams = {\n            userid: site.getUserId(),\n            limitfrom: limitFrom,\n            limitnum: limitNum <= 0 ? 0 : limitNum + 1,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForContactRequests(),\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        };\n\n        const requests = await site.read<AddonMessagesGetContactRequestsWSResponse>(\n            'core_message_get_contact_requests',\n            params,\n            preSets,\n        );\n\n        if (!requests || !requests.length) {\n            return { requests: [], canLoadMore: false };\n        }\n\n        CoreUser.storeUsers(requests, site.id);\n        if (limitNum <= 0) {\n            return { requests, canLoadMore: false };\n        }\n\n        return {\n            requests: requests.slice(0, limitNum),\n            canLoadMore: requests.length > limitNum,\n        };\n    }\n\n    /**\n     * Get the number of contact requests sent to the current user.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved with the number of contact requests.\n     * @since 3.6\n     */\n    async getContactRequestsCount(siteId?: string): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesGetReceivedContactRequestsCountWSParams = {\n            userid: site.getUserId(),\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForContactRequestsCount(),\n            typeExpected: 'number',\n        };\n\n        const data: AddonMessagesContactRequestCountEventData = {\n            count: await site.read('core_message_get_received_contact_requests_count', params, preSets),\n        };\n\n        // Notify the new count so all badges are updated.\n        CoreEvents.trigger(AddonMessagesProvider.CONTACT_REQUESTS_COUNT_EVENT, data , site.id);\n\n        return data.count;\n\n    }\n\n    /**\n     * Get a conversation by the conversation ID.\n     *\n     * @param conversationId Conversation ID to fetch.\n     * @param includeContactRequests Include contact requests.\n     * @param includePrivacyInfo Include privacy info.\n     * @param messageOffset Offset for messages list.\n     * @param messageLimit Limit of messages. Defaults to 1 (last message).\n     *                     We recommend getConversationMessages to get them.\n     * @param memberOffset Offset for members list.\n     * @param memberLimit Limit of members. Defaults to 2 (to be able to know the other user in individual ones).\n     *                    We recommend getConversationMembers to get them.\n     * @param newestFirst Whether to order messages by newest first.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Promise resolved with the response.\n     * @since 3.6\n     */\n    async getConversation(\n        conversationId: number,\n        includeContactRequests: boolean = false,\n        includePrivacyInfo: boolean = false,\n        messageOffset: number = 0,\n        messageLimit: number = 1,\n        memberOffset: number = 0,\n        memberLimit: number = 2,\n        newestFirst: boolean = true,\n        siteId?: string,\n        userId?: number,\n    ): Promise<AddonMessagesConversationFormatted> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForConversation(userId, conversationId),\n        };\n\n        const params: AddonMessagesGetConversationWSParams = {\n            userid: userId,\n            conversationid: conversationId,\n            includecontactrequests: includeContactRequests,\n            includeprivacyinfo: includePrivacyInfo,\n            messageoffset: messageOffset,\n            messagelimit: messageLimit,\n            memberoffset: memberOffset,\n            memberlimit: memberLimit,\n            newestmessagesfirst: newestFirst,\n        };\n\n        const conversation = await site.read<AddonMessagesGetConversationWSResponse>(\n            'core_message_get_conversation',\n            params,\n            preSets,\n        );\n\n        return this.formatConversation(conversation, userId);\n    }\n\n    /**\n     * Get a conversation between two users.\n     *\n     * @param otherUserId The other user ID.\n     * @param includeContactRequests Include contact requests.\n     * @param includePrivacyInfo Include privacy info.\n     * @param messageOffset Offset for messages list.\n     * @param messageLimit Limit of messages. Defaults to 1 (last message).\n     *                     We recommend getConversationMessages to get them.\n     * @param memberOffset Offset for members list.\n     * @param memberLimit Limit of members. Defaults to 2 (to be able to know the other user in individual ones).\n     *                    We recommend getConversationMembers to get them.\n     * @param newestFirst Whether to order messages by newest first.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n     * @returns Promise resolved with the response.\n     * @since 3.6\n     */\n    async getConversationBetweenUsers(\n        otherUserId: number,\n        includeContactRequests?: boolean,\n        includePrivacyInfo?: boolean,\n        messageOffset: number = 0,\n        messageLimit: number = 1,\n        memberOffset: number = 0,\n        memberLimit: number = 2,\n        newestFirst: boolean = true,\n        siteId?: string,\n        userId?: number,\n        preferCache?: boolean,\n    ): Promise<AddonMessagesConversationFormatted> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForConversationBetweenUsers(userId, otherUserId),\n            omitExpires: !!preferCache,\n        };\n\n        const params: AddonMessagesGetConversationBetweenUsersWSParams = {\n            userid: userId,\n            otheruserid: otherUserId,\n            includecontactrequests: !!includeContactRequests,\n            includeprivacyinfo: !!includePrivacyInfo,\n            messageoffset: messageOffset,\n            messagelimit: messageLimit,\n            memberoffset: memberOffset,\n            memberlimit: memberLimit,\n            newestmessagesfirst: !!newestFirst,\n        };\n\n        const conversation: AddonMessagesConversation =\n            await site.read('core_message_get_conversation_between_users', params, preSets);\n\n        return this.formatConversation(conversation, userId);\n    }\n\n    /**\n     * Get a conversation members.\n     *\n     * @param conversationId Conversation ID to fetch.\n     * @param limitFrom Offset for members list.\n     * @param limitTo Limit of members.\n     * @param includeContactRequests Include contact requests.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in.\n     * @returns Conversation members.\n     * @since 3.6\n     */\n    async getConversationMembers(\n        conversationId: number,\n        limitFrom: number = 0,\n        limitTo?: number,\n        includeContactRequests?: boolean,\n        siteId?: string,\n        userId?: number,\n    ): Promise<{members: AddonMessagesConversationMember[]; canLoadMore: boolean}> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n        limitTo = limitTo ?? AddonMessagesProvider.LIMIT_MESSAGES;\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForConversationMembers(userId, conversationId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n\n        const params: AddonMessagesGetConversationMembersWSParams = {\n            userid: userId,\n            conversationid: conversationId,\n            limitfrom: limitFrom,\n            limitnum: limitTo < 1 ? limitTo : limitTo + 1,\n            includecontactrequests: !!includeContactRequests,\n            includeprivacyinfo: true,\n        };\n\n        const members: AddonMessagesConversationMember[] =\n            await site.read('core_message_get_conversation_members', params, preSets);\n        if (limitTo < 1) {\n            return {\n                canLoadMore: false,\n                members: members,\n            };\n        }\n\n        return {\n            canLoadMore: members.length > limitTo,\n            members: members.slice(0, limitTo),\n        };\n    }\n\n    /**\n     * Get a conversation by the conversation ID.\n     *\n     * @param conversationId Conversation ID to fetch.\n     * @param options Options.\n     * @returns Promise resolved with the response.\n     * @since 3.6\n     */\n    async getConversationMessages(\n        conversationId: number,\n        options: AddonMessagesGetConversationMessagesOptions = {},\n    ): Promise<AddonMessagesGetConversationMessagesResult> {\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        options.userId = options.userId || site.getUserId();\n        options.limitFrom = options.limitFrom || 0;\n        options.limitTo = options.limitTo ?? AddonMessagesProvider.LIMIT_MESSAGES;\n        options.timeFrom = options.timeFrom || 0;\n        options.newestFirst = options.newestFirst ?? true;\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForConversationMessages(options.userId, conversationId),\n        };\n        const params: AddonMessagesGetConversationMessagesWSParams = {\n            currentuserid: options.userId,\n            convid: conversationId,\n            limitfrom: options.limitFrom,\n            limitnum: options.limitTo < 1 ? options.limitTo : options.limitTo + 1, // If there's a limit, get 1 more than requested.\n            newest: !!options.newestFirst,\n            timefrom: options.timeFrom,\n        };\n\n        if (options.limitFrom > 0) {\n            // Do not use cache when retrieving older messages.\n            // This is to prevent storing too much data and to prevent inconsistencies between \"pages\" loaded.\n            preSets.getFromCache = false;\n            preSets.saveToCache = false;\n            preSets.emergencyCache = false;\n        } else if (options.forceCache) {\n            preSets.omitExpires = true;\n        } else if (options.ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        const result: AddonMessagesGetConversationMessagesResult =\n            await site.read('core_message_get_conversation_messages', params, preSets);\n\n        if (options.limitTo < 1) {\n            result.canLoadMore = false;\n        } else {\n            result.canLoadMore = result.messages.length > options.limitTo;\n            result.messages = result.messages.slice(0, options.limitTo);\n        }\n\n        result.messages.forEach((message) => {\n            // Convert time to milliseconds.\n            message.timecreated = message.timecreated ? message.timecreated * 1000 : 0;\n        });\n\n        if (options.excludePending) {\n            // No need to get offline messages, return the ones we have.\n            return result;\n        }\n\n        // Get offline messages.\n        const offlineMessages =\n            await AddonMessagesOffline.getConversationMessages(conversationId, options.userId, site.getId());\n\n        result.messages = result.messages.concat(offlineMessages);\n\n        return result;\n    }\n\n    /**\n     * Get the discussions of a certain user. This function is used in Moodle sites higher than 3.6.\n     * If the site is older than 3.6, please use getDiscussions.\n     *\n     * @param type Filter by type.\n     * @param favourites Whether to restrict the results to contain NO favourite conversations (false), ONLY favourite\n     *                   conversation (true), or ignore any restriction altogether (undefined or null).\n     * @param limitFrom The offset to start at.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @param forceCache True if it should return cached data. Has priority over ignoreCache.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved with the conversations.\n     * @since 3.6\n     */\n    async getConversations(\n        type?: number,\n        favourites?: boolean,\n        limitFrom: number = 0,\n        siteId?: string,\n        userId?: number,\n        forceCache?: boolean,\n        ignoreCache?: boolean,\n    ): Promise<{conversations: AddonMessagesConversationFormatted[]; canLoadMore: boolean}> {\n\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForConversations(userId, type, favourites),\n        };\n\n        const params: AddonMessagesGetConversationsWSParams = {\n            userid: userId,\n            limitfrom: limitFrom,\n            limitnum: AddonMessagesProvider.LIMIT_MESSAGES + 1,\n        };\n\n        if (forceCache) {\n            preSets.omitExpires = true;\n        } else if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n        if (type !== undefined && type != null) {\n            params.type = type;\n        }\n        if (favourites !== undefined && favourites != null) {\n            params.favourites = !!favourites;\n        }\n        if (site.isVersionGreaterEqualThan('3.7') && type != AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP) {\n            // Add self conversation to the list.\n            params.mergeself = true;\n        }\n\n        let response: AddonMessagesGetConversationsResult;\n        try {\n            response = await site.read('core_message_get_conversations', params, preSets);\n        } catch (error) {\n            if (params.mergeself) {\n                // Try again without the new param. Maybe the user is offline and he has a previous request cached.\n                delete params.mergeself;\n\n                return site.read('core_message_get_conversations', params, preSets);\n            }\n\n            throw error;\n        }\n\n        // Format the conversations, adding some calculated fields.\n        const conversations = response.conversations\n            .slice(0, AddonMessagesProvider.LIMIT_MESSAGES)\n            .map((conversation) => this.formatConversation(conversation, userId!));\n\n        return {\n            conversations,\n            canLoadMore: response.conversations.length > AddonMessagesProvider.LIMIT_MESSAGES,\n        };\n    }\n\n    /**\n     * Get conversation counts by type.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with favourite,\n     *         individual, group and self conversation counts.\n     * @since 3.6\n     */\n    async getConversationCounts(siteId?: string): Promise<{favourites: number; individual: number; group: number; self: number}> {\n        const site = await CoreSites.getSite(siteId);\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForConversationCounts(),\n        };\n\n        const result = await site.read<AddonMessagesGetConversationCountsWSResponse>(\n            'core_message_get_conversation_counts',\n            { },\n            preSets,\n        );\n\n        const counts = {\n            favourites: result.favourites,\n            individual: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL],\n            group: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP],\n            self: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_SELF] || 0,\n        };\n\n        return counts;\n    }\n\n    /**\n     * Return the current user's discussion with another user.\n     *\n     * @param userId The ID of the other user.\n     * @param excludePending True to exclude messages pending to be sent.\n     * @param lfReceivedUnread Number of unread received messages already fetched, so fetch will be done from this.\n     * @param lfReceivedRead Number of read received messages already fetched, so fetch will be done from this.\n     * @param lfSentUnread Number of unread sent messages already fetched, so fetch will be done from this.\n     * @param lfSentRead Number of read sent messages already fetched, so fetch will be done from this.\n     * @param notUsed Deprecated since 3.9.5\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with messages and a boolean telling if can load more messages.\n     */\n    async getDiscussion(\n        userId: number,\n        excludePending: boolean,\n        lfReceivedUnread: number = 0,\n        lfReceivedRead: number = 0,\n        lfSentUnread: number = 0,\n        lfSentRead: number = 0,\n        notUsed: boolean = false, // eslint-disable-line @typescript-eslint/no-unused-vars\n        siteId?: string,\n    ): Promise<AddonMessagesGetDiscussionMessages> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const result: AddonMessagesGetDiscussionMessages = {\n            messages: [],\n            canLoadMore: false,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForDiscussion(userId),\n        };\n        const params: AddonMessagesGetMessagesWSParams = {\n            useridto: site.getUserId(),\n            useridfrom: userId,\n            limitnum: AddonMessagesProvider.LIMIT_MESSAGES,\n        };\n\n        if (lfReceivedUnread > 0 || lfReceivedRead > 0 || lfSentUnread > 0 || lfSentRead > 0) {\n            // Do not use cache when retrieving older messages.\n            // This is to prevent storing too much data and to prevent inconsistencies between \"pages\" loaded.\n            preSets.getFromCache = false;\n            preSets.saveToCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        // Get message received by current user.\n        const received = await this.getRecentMessages(params, preSets, lfReceivedUnread, lfReceivedRead, undefined, site.getId());\n        result.messages = received;\n        const hasReceived = received.length > 0;\n\n        // Get message sent by current user.\n        params.useridto = userId;\n        params.useridfrom = site.getUserId();\n        const sent = await this.getRecentMessages(params, preSets, lfSentUnread, lfSentRead, undefined, siteId);\n        result.messages = result.messages.concat(sent);\n        const hasSent = sent.length > 0;\n\n        if (result.messages.length > AddonMessagesProvider.LIMIT_MESSAGES) {\n            // Sort messages and get the more recent ones.\n            result.canLoadMore = true;\n            result.messages = this.sortMessages(result['messages']);\n            result.messages = result.messages.slice(-AddonMessagesProvider.LIMIT_MESSAGES);\n        } else {\n            result.canLoadMore = result.messages.length == AddonMessagesProvider.LIMIT_MESSAGES && (!hasReceived || !hasSent);\n        }\n\n        if (excludePending) {\n            // No need to get offline messages, return the ones we have.\n            return result;\n        }\n\n        // Get offline messages.\n        const offlineMessages = await AddonMessagesOffline.getMessages(userId, site.getId());\n\n        result.messages = result.messages.concat(offlineMessages);\n\n        return result;\n    }\n\n    /**\n     * Get the discussions of the current user. This function is used in Moodle sites older than 3.6.\n     * If the site is 3.6 or higher, please use getConversations.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with an object where the keys are the user ID of the other user.\n     */\n    async getDiscussions(siteId?: string): Promise<{[userId: number]: AddonMessagesDiscussion}> {\n        const discussions: { [userId: number]: AddonMessagesDiscussion } = {};\n\n        /**\n         * Convenience function to treat a recent message, adding it to discussions list if needed.\n         */\n        const treatRecentMessage = (\n            message: AddonMessagesGetMessagesMessage |\n            AddonMessagesOfflineConversationMessagesDBRecordFormatted |\n            AddonMessagesOfflineMessagesDBRecordFormatted,\n            userId: number,\n            userFullname: string,\n        ): void => {\n            if (discussions[userId] === undefined) {\n                discussions[userId] = {\n                    fullname: userFullname,\n                    profileimageurl: '',\n                };\n\n                if ((!('timeread' in message) || !message.timeread) && !message.pending && message.useridfrom != currentUserId) {\n                    discussions[userId].unread = true;\n                }\n            }\n\n            const messageId = ('id' in message) ? message.id : 0;\n\n            // Extract the most recent message. Pending messages are considered more recent than messages already sent.\n            const discMessage = discussions[userId].message;\n            if (discMessage === undefined || (!discMessage.pending && message.pending) ||\n                (discMessage.pending == message.pending && (discMessage.timecreated < message.timecreated ||\n                    (discMessage.timecreated == message.timecreated && discMessage.id < messageId)))) {\n\n                discussions[userId].message = {\n                    id: messageId,\n                    user: userId,\n                    message: message.text || '',\n                    timecreated: message.timecreated,\n                    pending: !!message.pending,\n                };\n            }\n        };\n\n        const site = await CoreSites.getSite(siteId);\n\n        const currentUserId = site.getUserId();\n        const params: AddonMessagesGetMessagesWSParams = {\n            useridto: currentUserId,\n            useridfrom: 0,\n            limitnum: AddonMessagesProvider.LIMIT_MESSAGES,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForDiscussions(),\n        };\n\n        const received = await this.getRecentMessages(params, preSets, undefined, undefined, undefined, site.getId());\n        // Extract the discussions by filtering same senders.\n        received.forEach((message) => {\n            treatRecentMessage(message, message.useridfrom, message.userfromfullname);\n        });\n\n        // Now get the last messages sent by the current user.\n        params.useridfrom = params.useridto;\n        params.useridto = 0;\n\n        const sent = await this.getRecentMessages(params, preSets);\n        // Extract the discussions by filtering same senders.\n        sent.forEach((message) => {\n            treatRecentMessage(message, message.useridto, message.usertofullname);\n        });\n\n        const offlineMessages = await AddonMessagesOffline.getAllMessages(site.getId());\n\n        offlineMessages.forEach((message) => {\n            treatRecentMessage(message, 'touserid' in message ? message.touserid : 0, '');\n        });\n\n        const discussionsWithUserImg = await this.getDiscussionsUserImg(discussions, site.getId());\n        this.storeUsersFromDiscussions(discussionsWithUserImg);\n\n        return discussionsWithUserImg;\n    }\n\n    /**\n     * Get user images for all the discussions that don't have one already.\n     *\n     * @param discussions List of discussions.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise always resolved. Resolve param is the formatted discussions.\n     */\n    protected async getDiscussionsUserImg(\n        discussions: { [userId: number]: AddonMessagesDiscussion },\n        siteId?: string,\n    ): Promise<{[userId: number]: AddonMessagesDiscussion}> {\n        const promises: Promise<void>[] = [];\n\n        for (const userId in discussions) {\n            if (!discussions[userId].profileimageurl && discussions[userId].message) {\n                // We don't have the user image. Try to retrieve it.\n                promises.push(CoreUser.getProfile(discussions[userId].message!.user, 0, true, siteId).then((user) => {\n                    discussions[userId].profileimageurl = user.profileimageurl;\n\n                    return;\n                }).catch(() => {\n                    // Error getting profile, resolve promise without adding any extra data.\n                }));\n            }\n        }\n\n        await Promise.all(promises);\n\n        return discussions;\n    }\n\n    /**\n     * Get conversation member info by user id, works even if no conversation betwen the users exists.\n     *\n     * @param otherUserId The other user ID.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Promise resolved with the member info.\n     * @since 3.6\n     */\n    async getMemberInfo(otherUserId: number, siteId?: string, userId?: number): Promise<AddonMessagesConversationMember> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForMemberInfo(userId, otherUserId),\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        };\n        const params: AddonMessagesGetMemberInfoWSParams = {\n            referenceuserid: userId,\n            userids: [otherUserId],\n            includecontactrequests: true,\n            includeprivacyinfo: true,\n        };\n        const members: AddonMessagesConversationMember[] = await site.read('core_message_get_member_info', params, preSets);\n        if (!members || members.length < 1) {\n            // Should never happen.\n            throw new CoreError('Error fetching member info.');\n        }\n\n        return members[0];\n    }\n\n    /**\n     * Get the cache key for the get message preferences call.\n     *\n     * @returns Cache key.\n     */\n    protected getMessagePreferencesCacheKey(): string {\n        return ROOT_CACHE_KEY + 'messagePreferences';\n    }\n\n    /**\n     * Get message preferences.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the message preferences.\n     */\n    async getMessagePreferences(siteId?: string): Promise<AddonMessagesMessagePreferences> {\n        this.logger.debug('Get message preferences');\n\n        const site = await CoreSites.getSite(siteId);\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getMessagePreferencesCacheKey(),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n\n        const data = await site.read<AddonMessagesGetUserMessagePreferencesWSResponse>(\n            'core_message_get_user_message_preferences',\n            {},\n            preSets,\n        );\n\n        if (data.preferences) {\n            data.preferences.blocknoncontacts = data.blocknoncontacts;\n\n            return data.preferences;\n        }\n\n        throw new CoreError('Error getting message preferences');\n    }\n\n    /**\n     * Get messages according to the params.\n     *\n     * @param params Parameters to pass to the WS.\n     * @param preSets Set of presets for the WS.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the data.\n     */\n    protected async getMessages(\n        params: AddonMessagesGetMessagesWSParams,\n        preSets: CoreSiteWSPreSets,\n        siteId?: string,\n    ): Promise<AddonMessagesGetMessagesResult> {\n\n        params.type = 'conversations';\n        params.newestfirst = true;\n\n        const site = await CoreSites.getSite(siteId);\n        const response: AddonMessagesGetMessagesResult = await site.read('core_message_get_messages', params, preSets);\n\n        response.messages.forEach((message) => {\n            message.read = !!params.read;\n            // Convert times to milliseconds.\n            message.timecreated = message.timecreated ? message.timecreated * 1000 : 0;\n            message.timeread = message.timeread ? message.timeread * 1000 : 0;\n        });\n\n        return response;\n    }\n\n    /**\n     * Get the most recent messages.\n     *\n     * @param params Parameters to pass to the WS.\n     * @param preSets Set of presets for the WS.\n     * @param limitFromUnread Number of read messages already fetched, so fetch will be done from this number.\n     * @param limitFromRead Number of unread messages already fetched, so fetch will be done from this number.\n     * @param notUsed // Deprecated 3.9.5\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the data.\n     */\n    async getRecentMessages(\n        params: AddonMessagesGetMessagesWSParams,\n        preSets: CoreSiteWSPreSets,\n        limitFromUnread: number = 0,\n        limitFromRead: number = 0,\n        notUsed: boolean = false, // eslint-disable-line @typescript-eslint/no-unused-vars\n        siteId?: string,\n    ): Promise<AddonMessagesGetMessagesMessage[]> {\n        limitFromUnread = limitFromUnread || 0;\n        limitFromRead = limitFromRead || 0;\n\n        params.read = false;\n        params.limitfrom = limitFromUnread;\n\n        const response = await this.getMessages(params, preSets, siteId);\n        let messages = response.messages;\n\n        if (!messages) {\n            throw new CoreError('Error fetching recent messages');\n        }\n\n        if (messages.length >= (params.limitnum || 0)) {\n            return messages;\n        }\n\n        // We need to fetch more messages.\n        params.limitnum = (params.limitnum || 0) - messages.length;\n        params.read = true;\n        params.limitfrom = limitFromRead;\n\n        try {\n            const response = await this.getMessages(params, preSets, siteId);\n            if (response.messages) {\n                messages = messages.concat(response.messages);\n            }\n\n            return messages;\n        } catch {\n            return messages;\n        }\n    }\n\n    /**\n     * Get a self conversation.\n     *\n     * @param messageOffset Offset for messages list.\n     * @param messageLimit Limit of messages. Defaults to 1 (last message).\n     *                     We recommend getConversationMessages to get them.\n     * @param newestFirst Whether to order messages by newest first.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID to get the self conversation for. If not defined, current user in the site.\n     * @returns Promise resolved with the response.\n     * @since 3.7\n     */\n    async getSelfConversation(\n        messageOffset: number = 0,\n        messageLimit: number = 1,\n        newestFirst: boolean = true,\n        siteId?: string,\n        userId?: number,\n    ): Promise<AddonMessagesConversationFormatted> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCacheKeyForSelfConversation(userId),\n        };\n\n        const params: AddonMessagesGetSelfConversationWSParams = {\n            userid: userId,\n            messageoffset: messageOffset,\n            messagelimit: messageLimit,\n            newestmessagesfirst: !!newestFirst,\n        };\n        const conversation = await site.read<AddonMessagesConversation>('core_message_get_self_conversation', params, preSets);\n\n        return this.formatConversation(conversation, userId);\n    }\n\n    /**\n     * Get unread conversation counts by type.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved with the unread favourite, individual and group conversation counts.\n     */\n    async getUnreadConversationCounts(\n        siteId?: string,\n    ): Promise<{favourites: number; individual: number; group: number; self: number; orMore?: boolean}> {\n        const site = await CoreSites.getSite(siteId);\n\n        let counts: AddonMessagesUnreadConversationCountsEventData;\n\n        if (this.isGroupMessagingEnabled()) {\n            // @since 3.6\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getCacheKeyForUnreadConversationCounts(),\n            };\n\n            const result: AddonMessagesGetConversationCountsWSResponse =\n                await site.read('core_message_get_unread_conversation_counts', {}, preSets);\n\n            counts = {\n                favourites: result.favourites,\n                individual: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL],\n                group: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP],\n                self: result.types[AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_SELF] || 0,\n            };\n\n        } else {\n            const params: AddonMessageGetUnreadConversationsCountWSParams = {\n                useridto: site.getUserId(),\n            };\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getCacheKeyForMessageCount(site.getUserId()),\n                typeExpected: 'number',\n            };\n\n            const count = await site.read<number>('core_message_get_unread_conversations_count', params, preSets);\n\n            counts = { favourites: 0, individual: count, group: 0, self: 0 };\n        }\n\n        // Notify the new counts so all views are updated.\n        CoreEvents.trigger(AddonMessagesProvider.UNREAD_CONVERSATION_COUNTS_EVENT, counts, site.id);\n\n        return counts;\n    }\n\n    /**\n     * Get the latest unread received messages.\n     *\n     * @param notUsed Not user anymore.\n     * @param forceCache True if it should return cached data. Has priority over ignoreCache.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the message unread count.\n     */\n    async getUnreadReceivedMessages(\n        notUsed: boolean = true, // eslint-disable-line @typescript-eslint/no-unused-vars\n        forceCache: boolean = false,\n        ignoreCache: boolean = false,\n        siteId?: string,\n    ): Promise<AddonMessagesGetMessagesResult> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesGetMessagesWSParams = {\n            read: false,\n            limitfrom: 0,\n            limitnum: AddonMessagesProvider.LIMIT_MESSAGES,\n            useridto: site.getUserId(),\n            useridfrom: 0,\n        };\n        const preSets: CoreSiteWSPreSets = {};\n        if (forceCache) {\n            preSets.omitExpires = true;\n        } else if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        return this.getMessages(params, preSets, siteId);\n    }\n\n    /**\n     * Invalidate all contacts cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateAllContactsCache(siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await this.invalidateContactsCache(siteId);\n\n        await this.invalidateBlockedContactsCache(siteId);\n    }\n\n    /**\n     * Invalidate blocked contacts cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateBlockedContactsCache(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const userId = site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForBlockedContacts(userId));\n    }\n\n    /**\n     * Invalidate contacts cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateContactsCache(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForContacts());\n    }\n\n    /**\n     * Invalidate user contacts cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateUserContacts(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForUserContacts());\n    }\n\n    /**\n     * Invalidate contact requests cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateContactRequestsCache(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.invalidateWsCacheForKey(this.getCacheKeyForContactRequests());\n    }\n\n    /**\n     * Invalidate contact requests count cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateContactRequestsCountCache(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForContactRequestsCount());\n    }\n\n    /**\n     * Invalidate conversation.\n     *\n     * @param conversationId Conversation ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async invalidateConversation(conversationId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForConversation(userId, conversationId));\n    }\n\n    /**\n     * Invalidate conversation between users.\n     *\n     * @param otherUserId Other user ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async invalidateConversationBetweenUsers(otherUserId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForConversationBetweenUsers(userId, otherUserId));\n    }\n\n    /**\n     * Invalidate conversation members cache.\n     *\n     * @param conversationId Conversation ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async invalidateConversationMembers(conversationId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForConversationMembers(userId, conversationId));\n    }\n\n    /**\n     * Invalidate conversation messages cache.\n     *\n     * @param conversationId Conversation ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async invalidateConversationMessages(conversationId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForConversationMessages(userId, conversationId));\n    }\n\n    /**\n     * Invalidate conversations cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async invalidateConversations(siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getCommonCacheKeyForUserConversations(userId));\n    }\n\n    /**\n     * Invalidate conversation counts cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateConversationCounts(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForConversationCounts());\n    }\n\n    /**\n     * Invalidate discussion cache.\n     *\n     * @param userId The user ID with whom the current user is having the discussion.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateDiscussionCache(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForDiscussion(userId));\n    }\n\n    /**\n     * Invalidate discussions cache.\n     *\n     * Note that {@link this.getDiscussions} uses the contacts, so we need to invalidate contacts too.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateDiscussionsCache(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const promises: Promise<void>[] = [];\n        promises.push(site.invalidateWsCacheForKey(this.getCacheKeyForDiscussions()));\n        promises.push(this.invalidateContactsCache(site.getId()));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidate member info cache.\n     *\n     * @param otherUserId The other user ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async invalidateMemberInfo(otherUserId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForMemberInfo(userId, otherUserId));\n    }\n\n    /**\n     * Invalidate get message preferences.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data is invalidated.\n     */\n    async invalidateMessagePreferences(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getMessagePreferencesCacheKey());\n    }\n\n    /**\n     * Invalidate all cache entries with member info.\n     *\n     * @param userId Id of the user to invalidate.\n     * @param site Site object.\n     * @returns Promise resolved when done.\n     */\n    protected async invalidateAllMemberInfo(userId: number, site: CoreSite): Promise<void> {\n        await CoreUtils.allPromises([\n            this.invalidateMemberInfo(userId, site.id),\n            this.invalidateUserContacts(site.id),\n            this.invalidateBlockedContactsCache(site.id),\n            this.invalidateContactRequestsCache(site.id),\n            this.invalidateConversations(site.id),\n            this.getConversationBetweenUsers(\n                userId,\n                undefined,\n                undefined,\n                undefined,\n                undefined,\n                undefined,\n                undefined,\n                undefined,\n                site.id,\n                undefined,\n                true,\n            ).then((conversation) => CoreUtils.allPromises([\n                this.invalidateConversation(conversation.id),\n                this.invalidateConversationMembers(conversation.id, site.id),\n            ])).catch(() => {\n                // The conversation does not exist or we can't fetch it now, ignore it.\n            }),\n        ]);\n    }\n\n    /**\n     * Invalidate a self conversation.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async invalidateSelfConversation(siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getCacheKeyForSelfConversation(userId));\n    }\n\n    /**\n     * Invalidate unread conversation counts cache.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async invalidateUnreadConversationCounts(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        if (this.isGroupMessagingEnabled()) {\n            // @since 3.6\n            return site.invalidateWsCacheForKey(this.getCacheKeyForUnreadConversationCounts());\n\n        } else {\n            return site.invalidateWsCacheForKey(this.getCacheKeyForMessageCount(site.getUserId()));\n        }\n    }\n\n    /**\n     * Checks if the a user is blocked by the current user.\n     *\n     * @param userId The user ID to check against.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved with boolean, rejected when we do not know.\n     */\n    async isBlocked(userId: number, siteId?: string): Promise<boolean> {\n        if (this.isGroupMessagingEnabled()) {\n            const member = await this.getMemberInfo(userId, siteId);\n\n            return member.isblocked;\n        }\n\n        const blockedContacts = await this.getBlockedContacts(siteId);\n        if (!blockedContacts.users || blockedContacts.users.length < 1) {\n            return false;\n        }\n\n        return blockedContacts.users.some((user) => userId == user.id);\n    }\n\n    /**\n     * Checks if the a user is a contact of the current user.\n     *\n     * @param userId The user ID to check against.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved with boolean, rejected when we do not know.\n     */\n    async isContact(userId: number, siteId?: string): Promise<boolean> {\n        if (this.isGroupMessagingEnabled()) {\n            const member = await this.getMemberInfo(userId, siteId);\n\n            return member.iscontact;\n        }\n\n        const contacts = await this.getContacts(siteId);\n\n        return ['online', 'offline'].some((type) => {\n            if (contacts[type] && contacts[type].length > 0) {\n                return contacts[type].some((user: AddonMessagesGetContactsContact) => userId == user.id);\n            }\n\n            return false;\n        });\n    }\n\n    /**\n     * Returns whether or not group messaging is supported.\n     *\n     * @returns If related WS is available on current site.\n     * @since 3.6\n     */\n    isGroupMessagingEnabled(): boolean {\n        return CoreSites.wsAvailableInCurrentSite('core_message_get_conversations');\n    }\n\n    /**\n     * Returns whether or not group messaging is supported in a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether related WS is available on a certain site.\n     * @since 3.6\n     */\n    async isGroupMessagingEnabledInSite(siteId?: string): Promise<boolean> {\n        try {\n            const site = await CoreSites.getSite(siteId);\n\n            return site.wsAvailable('core_message_get_conversations');\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Returns whether or not messaging is enabled for a certain site.\n     *\n     * This could call a WS so do not abuse this method.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when enabled, otherwise rejected.\n     */\n    async isMessagingEnabledForSite(siteId?: string): Promise<void> {\n        const enabled = await this.isPluginEnabled(siteId);\n\n        if (!enabled) {\n            throw new CoreError('Messaging not enabled for the site');\n        }\n    }\n\n    /**\n     * Returns whether or not a site supports muting or unmuting a conversation.\n     *\n     * @param site The site to check, undefined for current site.\n     * @returns If related WS is available on current site.\n     * @since 3.7\n     */\n    isMuteConversationEnabled(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site?.wsAvailable('core_message_mute_conversations');\n    }\n\n    /**\n     * Returns whether or not a site supports muting or unmuting a conversation.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether related WS is available on a certain site.\n     * @since 3.7\n     */\n    async isMuteConversationEnabledInSite(siteId?: string): Promise<boolean> {\n        try {\n            const site = await CoreSites.getSite(siteId);\n\n            return this.isMuteConversationEnabled(site);\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Returns whether or not the plugin is enabled in a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if enabled, rejected or resolved with false otherwise.\n     */\n    async isPluginEnabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.canUseAdvancedFeature('messaging');\n    }\n\n    /**\n     * Returns whether or not self conversation is supported in a certain site.\n     *\n     * @param site Site. If not defined, current site.\n     * @returns If related WS is available on the site.\n     * @since 3.7\n     */\n    isSelfConversationEnabled(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site?.wsAvailable('core_message_get_self_conversation');\n    }\n\n    /**\n     * Returns whether or not self conversation is supported in a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether related WS is available on a certain site.\n     * @since 3.7\n     */\n    async isSelfConversationEnabledInSite(siteId?: string): Promise<boolean> {\n        try {\n            const site = await CoreSites.getSite(siteId);\n\n            return this.isSelfConversationEnabled(site);\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Mark message as read.\n     *\n     * @param messageId ID of message to mark as read\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean marking success or not.\n     */\n    async markMessageRead(messageId: number, siteId?: string): Promise<AddonMessagesMarkMessageReadResult> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesMarkMessageReadWSParams = {\n            messageid: messageId,\n            timeread: CoreTimeUtils.timestamp(),\n        };\n\n        return site.write('core_message_mark_message_read', params);\n    }\n\n    /**\n     * Mark all messages of a conversation as read.\n     *\n     * @param conversationId Conversation ID.\n     * @returns Promise resolved if success.\n     * @since 3.6\n     */\n    async markAllConversationMessagesRead(conversationId: number): Promise<void> {\n        const params: AddonMessagesMarkAllConversationMessagesAsReadWSParams = {\n            userid: CoreSites.getCurrentSiteUserId(),\n            conversationid: conversationId,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            responseExpected: false,\n        };\n\n        await CoreSites.getCurrentSite()?.write('core_message_mark_all_conversation_messages_as_read', params, preSets);\n    }\n\n    /**\n     * Mark all messages of a discussion as read.\n     *\n     * @param userIdFrom User Id for the sender.\n     * @returns Promise resolved with boolean marking success or not.\n     * @deprecatedonmoodle since 3.6\n     */\n    async markAllMessagesRead(userIdFrom?: number): Promise<boolean> {\n        const params: AddonMessagesMarkAllMessagesAsReadWSParams = {\n            useridto: CoreSites.getCurrentSiteUserId(),\n            useridfrom: userIdFrom,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            typeExpected: 'boolean',\n        };\n\n        const site = CoreSites.getCurrentSite();\n\n        if (!site) {\n            return false;\n        }\n\n        return site.write('core_message_mark_all_messages_as_read', params, preSets);\n    }\n\n    /**\n     * Mute or unmute a conversation.\n     *\n     * @param conversationId Conversation ID.\n     * @param set Whether to mute or unmute.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async muteConversation(conversationId: number, set: boolean, siteId?: string, userId?: number): Promise<void> {\n        await this.muteConversations([conversationId], set, siteId, userId);\n    }\n\n    /**\n     * Mute or unmute some conversations.\n     *\n     * @param conversations Conversation IDs.\n     * @param set Whether to mute or unmute.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async muteConversations(conversations: number[], set: boolean, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n        const params: AddonMessagesMuteConversationsWSParams = {\n            userid: userId,\n            conversationids: conversations,\n        };\n\n        const wsName = set ? 'core_message_mute_conversations' : 'core_message_unmute_conversations';\n        await site.write(wsName, params);\n\n        // Invalidate the conversations data.\n        const promises = conversations.map((conversationId) => this.invalidateConversation(conversationId, site.getId(), userId));\n\n        try {\n            await Promise.all(promises);\n        } catch {\n            // Ignore errors.\n        }\n    }\n\n    /**\n     * Refresh the number of contact requests sent to the current user.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved with the number of contact requests.\n     * @since 3.6\n     */\n    async refreshContactRequestsCount(siteId?: string): Promise<number> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await this.invalidateContactRequestsCountCache(siteId);\n\n        return this.getContactRequestsCount(siteId);\n    }\n\n    /**\n     * Refresh unread conversation counts and trigger event.\n     *\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved with the unread favourite, individual and group conversation counts.\n     */\n    async refreshUnreadConversationCounts(\n        siteId?: string,\n    ): Promise<{favourites: number; individual: number; group: number; orMore?: boolean}> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await this.invalidateUnreadConversationCounts(siteId);\n\n        return this.getUnreadConversationCounts(siteId);\n    }\n\n    /**\n     * Remove a contact.\n     *\n     * @param userId User ID of the person to remove.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved when done.\n     */\n    async removeContact(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesDeleteContactsWSParams = {\n            userids: [userId],\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            responseExpected: false,\n        };\n\n        await site.write('core_message_delete_contacts', params, preSets);\n\n        return CoreUtils.allPromises([\n            this.invalidateUserContacts(site.id),\n            this.invalidateAllMemberInfo(userId, site),\n            this.invalidateContactsCache(site.id),\n        ]).then(() => {\n            const data: AddonMessagesMemberInfoChangedEventData = { userId, contactRemoved: true };\n            CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n\n            return;\n        });\n    }\n\n    /**\n     * Search for contacts.\n     *\n     * By default this only returns the first 100 contacts, but note that the WS can return thousands\n     * of results which would take a while to process. The limit here is just a convenience to\n     * prevent viewed to crash because too many DOM elements are created.\n     *\n     * @param query The query string.\n     * @param limit The number of results to return, 0 for none.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the contacts.\n     */\n    async searchContacts(query: string, limit: number = 100, siteId?: string): Promise<AddonMessagesSearchContactsContact[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesSearchContactsWSParams = {\n            searchtext: query,\n            onlymycourses: false,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            getFromCache: false,\n        };\n\n        let contacts: AddonMessagesSearchContactsContact[] = await site.read('core_message_search_contacts', params, preSets);\n\n        if (limit && contacts.length > limit) {\n            contacts = contacts.splice(0, limit);\n        }\n\n        CoreUser.storeUsers(contacts);\n\n        return contacts;\n    }\n\n    /**\n     * Search for all the messges with a specific text.\n     *\n     * @param query The query string.\n     * @param userId The user ID. If not defined, current user.\n     * @param limitFrom Position of the first result to get. Defaults to 0.\n     * @param limitNum Number of results to get. Defaults to AddonMessagesProvider.LIMIT_SEARCH.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the results.\n     */\n    async searchMessages(\n        query: string,\n        userId?: number,\n        limitFrom: number = 0,\n        limitNum: number = AddonMessagesProvider.LIMIT_SEARCH,\n        siteId?: string,\n    ): Promise<{messages: AddonMessagesMessageAreaContact[]; canLoadMore: boolean}> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesDataForMessageareaSearchMessagesWSParams = {\n            userid: userId || site.getUserId(),\n            search: query,\n            limitfrom: limitFrom,\n            limitnum: limitNum <= 0 ? 0 : limitNum + 1,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            getFromCache: false,\n        };\n\n        const result: AddonMessagesDataForMessageareaSearchMessagesWSResponse =\n            await site.read('core_message_data_for_messagearea_search_messages', params, preSets);\n        if (!result.contacts || !result.contacts.length) {\n            return { messages: [], canLoadMore: false };\n        }\n\n        const users: CoreUserBasicData[] = result.contacts.map((contact) => ({\n            id: contact.userid,\n            fullname: contact.fullname,\n            profileimageurl: contact.profileimageurl,\n        }));\n\n        CoreUser.storeUsers(users, site.id);\n\n        if (limitNum <= 0) {\n            return { messages: result.contacts, canLoadMore: false };\n        }\n\n        return {\n            messages: result.contacts.slice(0, limitNum),\n            canLoadMore: result.contacts.length > limitNum,\n        };\n    }\n\n    /**\n     * Search for users.\n     *\n     * @param query Text to search for.\n     * @param limitFrom Position of the first found user to fetch.\n     * @param limitNum Number of found users to fetch. Defaults to AddonMessagesProvider.LIMIT_SEARCH.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved with two lists of found users: contacts and non-contacts.\n     * @since 3.6\n     */\n    async searchUsers(\n        query: string,\n        limitFrom: number = 0,\n        limitNum: number = AddonMessagesProvider.LIMIT_SEARCH,\n        siteId?: string,\n    ): Promise<{\n            contacts: AddonMessagesConversationMember[];\n            nonContacts: AddonMessagesConversationMember[];\n            canLoadMoreContacts: boolean;\n            canLoadMoreNonContacts: boolean;\n        }> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonMessagesMessageSearchUsersWSParams = {\n            userid: site.getUserId(),\n            search: query,\n            limitfrom: limitFrom,\n            limitnum: limitNum <= 0 ? 0 : limitNum + 1,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            getFromCache: false,\n        };\n\n        const result: AddonMessagesSearchUsersWSResponse = await site.read('core_message_message_search_users', params, preSets);\n        const contacts = result.contacts || [];\n        const nonContacts = result.noncontacts || [];\n\n        CoreUser.storeUsers(contacts, site.id);\n        CoreUser.storeUsers(nonContacts, site.id);\n\n        if (limitNum <= 0) {\n            return { contacts, nonContacts, canLoadMoreContacts: false, canLoadMoreNonContacts: false };\n        }\n\n        return {\n            contacts: contacts.slice(0, limitNum),\n            nonContacts: nonContacts.slice(0, limitNum),\n            canLoadMoreContacts: contacts.length > limitNum,\n            canLoadMoreNonContacts: nonContacts.length > limitNum,\n        };\n    }\n\n    /**\n     * Send a message to someone.\n     *\n     * @param toUserId User ID to send the message to.\n     * @param message The message to send\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with:\n     *         - sent (Boolean) True if message was sent to server, false if stored in device.\n     *         - message (Object) If sent=false, contains the stored message.\n     */\n    async sendMessage(\n        toUserId: number,\n        message: string,\n        siteId?: string,\n    ): Promise<AddonMessagesSendMessageResults> {\n\n        // Convenience function to store a message to be synchronized later.\n        const storeOffline = async (): Promise<AddonMessagesSendMessageResults> => {\n            const entry = await AddonMessagesOffline.saveMessage(toUserId, message, siteId);\n\n            return {\n                sent: false,\n                message: {\n                    msgid: -1,\n                    text: entry.smallmessage,\n                    timecreated: entry.timecreated,\n                    conversationid: 0,\n                    useridfrom: entry.useridfrom,\n                    candeletemessagesforallusers: true,\n                },\n            };\n        };\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the message.\n            return storeOffline();\n        }\n\n        // Check if this conversation already has offline messages.\n        // If so, store this message since they need to be sent in order.\n        let hasStoredMessages = false;\n        try {\n            hasStoredMessages = await AddonMessagesOffline.hasMessages(toUserId, siteId);\n        } catch {\n            // Error, it's safer to assume it has messages.\n            hasStoredMessages = true;\n        }\n\n        if (hasStoredMessages) {\n            return storeOffline();\n        }\n\n        try {\n            // Online and no messages stored. Send it to server.\n            const result = await this.sendMessageOnline(toUserId, message);\n\n            return {\n                sent: true,\n                message: result,\n            };\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // It's a WebService error, the user cannot send the message so don't store it.\n                throw error;\n            }\n\n            // Error sending message, store it to retry later.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Send a message to someone. It will fail if offline or cannot connect.\n     *\n     * @param toUserId User ID to send the message to.\n     * @param message The message to send\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected if failure.\n     */\n    async sendMessageOnline(toUserId: number, message: string, siteId?: string): Promise<AddonMessagesSendInstantMessagesMessage> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const messages = [\n            {\n                touserid: toUserId,\n                text: message,\n                textformat: 1,\n            },\n        ];\n\n        const response = await this.sendMessagesOnline(messages, siteId);\n\n        if (response && response[0] && response[0].msgid === -1) {\n            // There was an error, and it should be translated already.\n            throw new CoreWSError({ message: response[0].errormessage, errorcode: 'sendmessageerror' });\n        }\n\n        try {\n            await this.invalidateDiscussionCache(toUserId, siteId);\n        } catch {\n            // Ignore errors.\n        }\n\n        return response[0];\n    }\n\n    /**\n     * Send some messages. It will fail if offline or cannot connect.\n     * IMPORTANT: Sending several messages at once for the same discussions can cause problems with display order,\n     * since messages with same timecreated aren't ordered by ID.\n     *\n     * @param messages Messages to send. Each message must contain touserid, text and textformat.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected if failure. Promise resolved doesn't mean that messages\n     *         have been sent, the resolve param can contain errors for messages not sent.\n     */\n    async sendMessagesOnline(\n        messages: AddonMessagesMessageData[],\n        siteId?: string,\n    ): Promise<AddonMessagesSendInstantMessagesMessage[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const data: AddonMessagesSendInstantMessagesWSParams = {\n            messages,\n        };\n\n        return site.write('core_message_send_instant_messages', data);\n    }\n\n    /**\n     * Send a message to a conversation.\n     *\n     * @param conversation Conversation.\n     * @param message The message to send.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with:\n     *         - sent (boolean) True if message was sent to server, false if stored in device.\n     *         - message (any) If sent=false, contains the stored message.\n     * @since 3.6\n     */\n    async sendMessageToConversation(\n        conversation: AddonMessagesConversation,\n        message: string,\n        siteId?: string,\n    ): Promise<AddonMessagesSendMessageResults> {\n\n        const site = await CoreSites.getSite(siteId);\n        siteId = site.getId();\n\n        // Convenience function to store a message to be synchronized later.\n        const storeOffline = async(): Promise<AddonMessagesSendMessageResults> => {\n            const entry = await AddonMessagesOffline.saveConversationMessage(conversation, message, siteId);\n\n            return {\n                sent: false,\n                message: {\n                    id: -1,\n                    useridfrom: site.getUserId(),\n                    text: entry.text,\n                    timecreated: entry.timecreated,\n                },\n            };\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the message.\n            return storeOffline();\n        }\n\n        // Check if this conversation already has offline messages.\n        // If so, store this message since they need to be sent in order.\n        let hasStoredMessages = false;\n        try {\n            hasStoredMessages = await AddonMessagesOffline.hasConversationMessages(conversation.id, siteId);\n        } catch {\n            // Error, it's safer to assume it has messages.\n            hasStoredMessages = true;\n        }\n\n        if (hasStoredMessages) {\n            return storeOffline();\n        }\n\n        try {\n            // Online and no messages stored. Send it to server.\n            const result = await this.sendMessageToConversationOnline(conversation.id, message, siteId);\n\n            return {\n                sent: true,\n                message: result,\n            };\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // It's a WebService error, the user cannot send the message so don't store it.\n                throw error;\n            }\n\n            // Error sending message, store it to retry later.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Send a message to a conversation. It will fail if offline or cannot connect.\n     *\n     * @param conversationId Conversation ID.\n     * @param message The message to send\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected if failure.\n     * @since 3.6\n     */\n    async sendMessageToConversationOnline(\n        conversationId: number,\n        message: string,\n        siteId?: string,\n    ): Promise<AddonMessagesSendMessagesToConversationMessage> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const messages = [\n            {\n                text: message,\n                textformat: 1,\n            },\n        ];\n\n        const response = await this.sendMessagesToConversationOnline(conversationId, messages, siteId);\n\n        try {\n            await this.invalidateConversationMessages(conversationId, siteId);\n        } catch {\n            // Ignore errors.\n        }\n\n        return response[0];\n    }\n\n    /**\n     * Send some messages to a conversation. It will fail if offline or cannot connect.\n     *\n     * @param conversationId Conversation ID.\n     * @param messages Messages to send. Each message must contain text and, optionally, textformat.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected if failure.\n     * @since 3.6\n     */\n    async sendMessagesToConversationOnline(\n        conversationId: number,\n        messages: CoreMessageSendMessagesToConversationMessageData[],\n        siteId?: string,\n    ): Promise<AddonMessagesSendMessagesToConversationMessage[]> {\n\n        const site = await CoreSites.getSite(siteId);\n        const params: CoreMessageSendMessagesToConversationWSParams = {\n            conversationid: conversationId,\n            messages: messages.map((message) => ({\n                text: message.text,\n                textformat: message.textformat !== undefined ? message.textformat : 1,\n            })),\n        };\n\n        return site.write('core_message_send_messages_to_conversation', params);\n    }\n\n    /**\n     * Set or unset a conversation as favourite.\n     *\n     * @param conversationId Conversation ID.\n     * @param set Whether to set or unset it as favourite.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    setFavouriteConversation(conversationId: number, set: boolean, siteId?: string, userId?: number): Promise<void> {\n        return this.setFavouriteConversations([conversationId], set, siteId, userId);\n    }\n\n    /**\n     * Set or unset some conversations as favourites.\n     *\n     * @param conversations Conversation IDs.\n     * @param set Whether to set or unset them as favourites.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param userId User ID. If not defined, current user in the site.\n     * @returns Resolved when done.\n     */\n    async setFavouriteConversations(conversations: number[], set: boolean, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        const params: AddonMessagesSetFavouriteConversationsWSParams = {\n            userid: userId,\n            conversations: conversations,\n        };\n        const wsName = set ? 'core_message_set_favourite_conversations' : 'core_message_unset_favourite_conversations';\n\n        await site.write(wsName, params);\n\n        // Invalidate the conversations data.\n        const promises = conversations.map((conversationId) => this.invalidateConversation(conversationId, site.getId(), userId));\n\n        try {\n            await Promise.all(promises);\n        } catch {\n            // Ignore errors.\n        }\n    }\n\n    /**\n     * Helper method to sort conversations by last message time.\n     *\n     * @param conversations Array of conversations.\n     * @returns Conversations sorted with most recent last.\n     */\n    sortConversations(conversations: AddonMessagesConversationFormatted[]): AddonMessagesConversationFormatted[] {\n        return conversations.sort((a, b) => {\n            const timeA = Number(a.lastmessagedate);\n            const timeB = Number(b.lastmessagedate);\n\n            if (timeA == timeB && a.id) {\n                // Same time, sort by ID.\n                return a.id <= b.id ? 1 : -1;\n            }\n\n            return timeA <= timeB ? 1 : -1;\n        });\n    }\n\n    /**\n     * Helper method to sort messages by time.\n     *\n     * @param messages Array of messages containing the key 'timecreated'.\n     * @returns Messages sorted with most recent last.\n     */\n    sortMessages(messages: AddonMessagesConversationMessageFormatted[]): AddonMessagesConversationMessageFormatted[];\n    sortMessages(\n        messages: (AddonMessagesGetMessagesMessage | AddonMessagesOfflineMessagesDBRecordFormatted)[],\n    ): (AddonMessagesGetMessagesMessage | AddonMessagesOfflineMessagesDBRecordFormatted)[];\n    sortMessages(messages: AddonMessagesOfflineAnyMessagesFormatted[]): AddonMessagesOfflineAnyMessagesFormatted[];\n    sortMessages(\n        messages: (AddonMessagesGetMessagesMessage | AddonMessagesOfflineMessagesDBRecordFormatted)[] |\n        AddonMessagesOfflineAnyMessagesFormatted[] |\n        AddonMessagesConversationMessageFormatted[],\n    ): (AddonMessagesGetMessagesMessage | AddonMessagesOfflineMessagesDBRecordFormatted)[] |\n        AddonMessagesOfflineAnyMessagesFormatted[] |\n        AddonMessagesConversationMessageFormatted[] {\n        return messages.sort((a, b) => {\n            // Pending messages last.\n            if (a.pending && !b.pending) {\n                return 1;\n            } else if (!a.pending && b.pending) {\n                return -1;\n            }\n\n            const timecreatedA = a.timecreated;\n            const timecreatedB = b.timecreated;\n            if (timecreatedA == timecreatedB && 'id' in a) {\n                const bId = 'id' in b ? b.id : 0;\n\n                // Same time, sort by ID.\n                return a.id >= bId ? 1 : -1;\n            }\n\n            return timecreatedA >= timecreatedB ? 1 : -1;\n        });\n    }\n\n    /**\n     * Store user data from contacts in local DB.\n     *\n     * @param contactTypes List of contacts grouped in types.\n     */\n    protected storeUsersFromAllContacts(contactTypes: AddonMessagesGetContactsWSResponse): void {\n        for (const x in contactTypes) {\n            CoreUser.storeUsers(contactTypes[x]);\n        }\n    }\n\n    /**\n     * Store user data from discussions in local DB.\n     *\n     * @param discussions List of discussions.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    protected storeUsersFromDiscussions(discussions: { [userId: number]: AddonMessagesDiscussion }, siteId?: string): void {\n        const users: CoreUserBasicData[] = [];\n\n        for (const userId in discussions) {\n            users.push({\n                id: parseInt(userId, 10),\n                fullname: discussions[userId].fullname,\n                profileimageurl: discussions[userId].profileimageurl,\n            });\n        }\n        CoreUser.storeUsers(users, siteId);\n    }\n\n    /**\n     * Unblock a user.\n     *\n     * @param userId User ID of the person to unblock.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Resolved when done.\n     */\n    async unblockContact(userId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        try {\n            if (site.wsAvailable('core_message_unblock_user')) {\n                // Since Moodle 3.6\n                const params: AddonMessagesUnblockUserWSParams = {\n                    userid: site.getUserId(),\n                    unblockeduserid: userId,\n                };\n                await site.write('core_message_unblock_user', params);\n            } else {\n                const params: { userids: number[] } = {\n                    userids: [userId],\n                };\n                const preSets: CoreSiteWSPreSets = {\n                    responseExpected: false,\n                };\n                await site.write('core_message_unblock_contacts', params, preSets);\n            }\n\n            await this.invalidateAllMemberInfo(userId, site);\n        } finally {\n            const data: AddonMessagesMemberInfoChangedEventData = { userId, userUnblocked: true };\n\n            CoreEvents.trigger(AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT, data, site.id);\n        }\n    }\n\n}\n\nexport const AddonMessages = makeSingleton(AddonMessagesProvider);\n\n/**\n * Options to pass to getConversationMessages.\n */\nexport type AddonMessagesGetConversationMessagesOptions = {\n    excludePending?: boolean; // True to exclude messages pending to be sent.\n    limitFrom?: number; // Offset for messages list. Defaults to 0.\n    limitTo?: number; // Limit of messages.\n    newestFirst?: boolean; // Whether to order messages by newest first.\n    timeFrom?: number; // The timestamp from which the messages were created (in seconds). Defaults to 0.\n    siteId?: string; // Site ID. If not defined, use current site.\n    userId?: number; // User ID. If not defined, current user in the site.\n    forceCache?: boolean; // True if it should return cached data. Has priority over ignoreCache.\n    ignoreCache?: boolean; // True if it should ignore cached data (it will always fail in offline or server down).\n};\n\n/**\n * Data returned by core_message_get_self_conversation WS.\n */\nexport type AddonMessagesConversation = {\n    id: number; // The conversation id.\n    name?: string; // The conversation name, if set.\n    subname?: string; // A subtitle for the conversation name, if set.\n    imageurl?: string; // A link to the conversation picture, if set.\n    type: number; // The type of the conversation (1=individual,2=group,3=self).\n    membercount: number; // Total number of conversation members.\n    ismuted: boolean; // If the user muted this conversation.\n    isfavourite: boolean; // If the user marked this conversation as a favourite.\n    isread: boolean; // If the user has read all messages in the conversation.\n    unreadcount?: number; // The number of unread messages in this conversation.\n    members: AddonMessagesConversationMember[];\n    messages: AddonMessagesConversationMessage[];\n    candeletemessagesforallusers: boolean; // @since 3.7. If the user can delete messages in the conversation for all users.\n};\n\n/**\n * Params of core_message_get_conversation WS.\n */\ntype AddonMessagesGetConversationWSParams = {\n    userid: number; // The id of the user who we are viewing conversations for.\n    conversationid: number; // The id of the conversation to fetch.\n    includecontactrequests: boolean; // Include contact requests in the members.\n    includeprivacyinfo: boolean; // Include privacy info in the members.\n    memberlimit?: number; // Limit for number of members.\n    memberoffset?: number; // Offset for member list.\n    messagelimit?: number; // Limit for number of messages.\n    messageoffset?: number; // Offset for messages list.\n    newestmessagesfirst?: boolean; // Order messages by newest first.\n};\n\n/**\n * Data returned by core_message_get_conversation WS.\n */\ntype AddonMessagesGetConversationWSResponse = AddonMessagesConversation;\n\n/**\n * Params of core_message_get_self_conversation WS.\n */\ntype AddonMessagesGetSelfConversationWSParams = {\n    userid: number; // The id of the user who we are viewing self-conversations for.\n    messagelimit?: number; // Limit for number of messages.\n    messageoffset?: number; // Offset for messages list.\n    newestmessagesfirst?: boolean; // Order messages by newest first.\n};\n\n/**\n * Conversation with some calculated data.\n */\nexport type AddonMessagesConversationFormatted = AddonMessagesConversation & {\n    lastmessage?: string; // Calculated in the app. Last message.\n    lastmessagedate?: number; // Calculated in the app. Date the last message was sent.\n    sentfromcurrentuser?: boolean; // Calculated in the app. Whether last message was sent by the current user.\n    name?: string; // Calculated in the app. If private conversation, name of the other user.\n    userid?: number; // Calculated in the app. URL. If private conversation, ID of the other user.\n    showonlinestatus?: boolean; // Calculated in the app. If private conversation, whether to show online status of the other user.\n    isonline?: boolean; // Calculated in the app. If private conversation, whether the other user is online.\n    isblocked?: boolean; // Calculated in the app. If private conversation, whether the other user is blocked.\n    otherUser?: AddonMessagesConversationMember; // Calculated in the app. Other user in the conversation.\n};\n\n/**\n * Params of core_message_get_conversation_between_users WS.\n */\ntype AddonMessagesGetConversationBetweenUsersWSParams = {\n    userid: number; // The id of the user who we are viewing conversations for.\n    otheruserid: number; // The other user id.\n    includecontactrequests: boolean; // Include contact requests in the members.\n    includeprivacyinfo: boolean; // Include privacy info in the members.\n    memberlimit?: number; // Limit for number of members.\n    memberoffset?: number; // Offset for member list.\n    messagelimit?: number; // Limit for number of messages.\n    messageoffset?: number; // Offset for messages list.\n    newestmessagesfirst?: boolean; // Order messages by newest first.\n};\n\n/**\n * Params of core_message_get_member_info WS.\n */\ntype AddonMessagesGetMemberInfoWSParams = {\n    referenceuserid: number; // Id of the user.\n    userids: number[];\n    includecontactrequests?: boolean; // Include contact requests in response.\n    includeprivacyinfo?: boolean; // Include privacy info in response.\n};\n\n/**\n * Params of core_message_get_conversation_members WS.\n */\ntype AddonMessagesGetConversationMembersWSParams = {\n    userid: number; // The id of the user we are performing this action on behalf of.\n    conversationid: number; // The id of the conversation.\n    includecontactrequests?: boolean; // Do we want to include contact requests?.\n    includeprivacyinfo?: boolean; // Do we want to include privacy info?.\n    limitfrom?: number; // Limit from.\n    limitnum?: number; // Limit number.\n};\n\n/**\n * Conversation member returned by core_message_get_member_info and core_message_get_conversation_members WS.\n */\nexport type AddonMessagesConversationMember = {\n    id: number; // The user id.\n    fullname: string; // The user's name.\n    profileurl: string; // The link to the user's profile page.\n    profileimageurl: string; // User picture URL.\n    profileimageurlsmall: string; // Small user picture URL.\n    isonline: boolean; // The user's online status.\n    showonlinestatus: boolean; // Show the user's online status?.\n    isblocked: boolean; // If the user has been blocked.\n    iscontact: boolean; // Is the user a contact?.\n    isdeleted: boolean; // Is the user deleted?.\n    canmessageevenifblocked: boolean; // @since 3.8. If the user can still message even if they get blocked.\n    canmessage: boolean; // If the user can be messaged.\n    requirescontact: boolean; // If the user requires to be contacts.\n    contactrequests?: { // The contact requests.\n        id: number; // The id of the contact request.\n        userid: number; // The id of the user who created the contact request.\n        requesteduserid: number; // The id of the user confirming the request.\n        timecreated: number; // The timecreated timestamp for the contact request.\n    }[];\n    conversations?: { // Conversations between users.\n        id: number; // Conversations id.\n        type: number; // Conversation type: private or public.\n        name: string; // Multilang compatible conversation name2.\n        timecreated: number; // The timecreated timestamp for the conversation.\n    }[];\n};\n\n/**\n * Conversation message.\n */\nexport type AddonMessagesConversationMessage = {\n    id: number; // The id of the message.\n    useridfrom: number; // The id of the user who sent the message.\n    text: string; // The text of the message.\n    timecreated: number; // The timecreated timestamp for the message.\n};\n\n/**\n * Conversation message with some calculated data.\n */\nexport type AddonMessagesConversationMessageFormatted =\n    (AddonMessagesConversationMessage\n    | AddonMessagesGetMessagesMessage\n    | AddonMessagesOfflineMessagesDBRecordFormatted\n    | AddonMessagesOfflineConversationMessagesDBRecordFormatted) & {\n        pending?: boolean; // Calculated in the app. Whether the message is pending to be sent.\n        sending?: boolean; // Calculated in the app. Whether the message is being sent right now.\n        hash?: string; // Calculated in the app. A hash to identify the message.\n        showDate?: boolean; // Calculated in the app. Whether to show the date before the message.\n        showUserData?: boolean; // Calculated in the app. Whether to show the user data in the message.\n        showTail?: boolean; // Calculated in the app. Whether to show a \"tail\" in the message.\n    };\n\n/**\n * Data returned by core_message_get_user_message_preferences WS.\n */\nexport type AddonMessagesGetUserMessagePreferencesWSResponse = {\n    preferences: AddonMessagesMessagePreferences;\n    blocknoncontacts: number; // Privacy messaging setting to define who can message you.\n    entertosend: boolean; // User preference for using enter to send messages.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Message preferences.\n */\nexport type AddonMessagesMessagePreferences = {\n    userid: number; // User id.\n    disableall: number; // Whether all the preferences are disabled.\n    processors: { // Config form values.\n        displayname: string; // Display name.\n        name: string; // Processor name.\n        hassettings: boolean; // Whether has settings.\n        contextid: number; // Context id.\n        userconfigured: number; // Whether is configured by the user.\n    }[];\n    components: { // Available components.\n        displayname: string; // Display name.\n        notifications: AddonMessagesMessagePreferencesNotification[]; // List of notificaitons for the component.\n    }[];\n} & AddonMessagesMessagePreferencesCalculatedData;\n\n/**\n * Notification processor in message preferences.\n */\nexport type AddonMessagesMessagePreferencesNotification = {\n    displayname: string; // Display name.\n    preferencekey: string; // Preference key.\n    processors: AddonMessagesMessagePreferencesNotificationProcessor[]; // Processors values for this notification.\n};\n\n/**\n * Notification processor in message preferences.\n */\nexport type AddonMessagesMessagePreferencesNotificationProcessor = {\n    displayname: string; // Display name.\n    name: string; // Processor name.\n    locked: boolean; // Is locked by admin?.\n    lockedmessage?: string; // @since 3.6. Text to display if locked.\n    userconfigured: number; // Is configured?.\n    enabled?: boolean; // @since 4.0. Processor enabled.\n    loggedin: AddonNotificationsPreferencesNotificationProcessorState; // @deprecatedonmoodle since 4.0.\n    loggedoff: AddonNotificationsPreferencesNotificationProcessorState; // @deprecatedonmoodle since 4.0.\n};\n\n/**\n * Message discussion (before 3.6).\n *\n * @deprecatedonmoodle since 3.6.\n */\nexport type AddonMessagesDiscussion = {\n    fullname: string; // Full name of the other user in the discussion.\n    profileimageurl?: string; // Profile image of the other user in the discussion.\n    message?: { // Last message.\n        id: number; // Message ID.\n        user: number; // User ID that sent the message.\n        message: string; // Text of the message.\n        timecreated: number; // Time the message was sent.\n        pending?: boolean; // Whether the message is pending to be sent.\n    };\n    unread?: boolean; // Whether the discussion has unread messages.\n};\n\n/**\n * Contact for message area.\n */\nexport type AddonMessagesMessageAreaContact = {\n    userid: number; // The user's id.\n    fullname: string; // The user's name.\n    profileimageurl: string; // User picture URL.\n    profileimageurlsmall: string; // Small user picture URL.\n    ismessaging: boolean; // If we are messaging the user.\n    sentfromcurrentuser: boolean; // Was the last message sent from the current user?.\n    lastmessage: string; // The user's last message.\n    lastmessagedate: number; // @since 3.6. Timestamp for last message.\n    messageid: number; // The unique search message id.\n    showonlinestatus: boolean; // Show the user's online status?.\n    isonline: boolean; // The user's online status.\n    isread: boolean; // If the user has read the message.\n    isblocked: boolean; // If the user has been blocked.\n    unreadcount: number; // The number of unread messages in this conversation.\n    conversationid: number; // @since 3.6. The id of the conversation.\n} & AddonMessagesMessageAreaContactCalculatedData;\n\n/**\n * Params of core_message_get_blocked_users WS.\n */\ntype AddonMessagesGetBlockedUsersWSParams = {\n    userid: number; // The user whose blocked users we want to retrieve.\n};\n\n/**\n * Result of WS core_message_get_blocked_users.\n */\nexport type AddonMessagesGetBlockedUsersWSResponse = {\n    users: AddonMessagesBlockedUser[]; // List of blocked users.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * User data returned by core_message_get_blocked_users.\n */\nexport type AddonMessagesBlockedUser = {\n    id: number; // User ID.\n    fullname: string; // User full name.\n    profileimageurl?: string; // User picture URL.\n};\n\n/**\n * Result of WS core_message_get_contacts.\n */\nexport type AddonMessagesGetContactsWSResponse = {\n    online: AddonMessagesGetContactsContact[]; // List of online contacts.\n    offline: AddonMessagesGetContactsContact[]; // List of offline contacts.\n    strangers: AddonMessagesGetContactsContact[]; // List of users that are not in the user's contact list but have sent a message.\n} & AddonMessagesGetContactsCalculatedData;\n\n/**\n * User data returned by core_message_get_contacts.\n */\nexport type AddonMessagesGetContactsContact = {\n    id: number; // User ID.\n    fullname: string; // User full name.\n    profileimageurl?: string; // User picture URL.\n    profileimageurlsmall?: string; // Small user picture URL.\n    unread: number; // Unread message count.\n};\n\n/**\n * Params of core_message_search_contacts WS.\n */\ntype AddonMessagesSearchContactsWSParams = {\n    searchtext: string; // String the user's fullname has to match to be found.\n    onlymycourses?: boolean; // Limit search to the user's courses.\n};\n\n/**\n * User data returned by core_message_search_contacts.\n */\nexport type AddonMessagesSearchContactsContact = {\n    id: number; // User ID.\n    fullname: string; // User full name.\n    profileimageurl?: string; // User picture URL.\n    profileimageurlsmall?: string; // Small user picture URL.\n};\n\n/**\n * Params of core_message_get_conversation_messages WS.\n */\ntype AddonMessagesGetConversationMessagesWSParams = {\n    currentuserid: number; // The current user's id.\n    convid: number; // The conversation id.\n    limitfrom?: number; // Limit from.\n    limitnum?: number; // Limit number.\n    newest?: boolean; // Newest first?.\n    timefrom?: number; // The timestamp from which the messages were created.\n};\n\n/**\n * Data returned by core_message_get_conversation_messages WS.\n */\ntype AddonMessagesGetConversationMessagesWSResponse = {\n    id: number; // The conversation id.\n    members: AddonMessagesConversationMember[];\n    messages: AddonMessagesConversationMessage[];\n};\n\n/**\n * Result formatted of WS core_message_get_conversation_messages.\n */\nexport type AddonMessagesGetConversationMessagesResult = Omit<AddonMessagesGetConversationMessagesWSResponse, 'messages'> & {\n    messages: (AddonMessagesConversationMessage | AddonMessagesOfflineConversationMessagesDBRecordFormatted)[];\n} & AddonMessagesGetConversationMessagesCalculatedData;\n\n/**\n * Params of core_message_get_conversations WS.\n */\ntype AddonMessagesGetConversationsWSParams = {\n    userid: number; // The id of the user who we are viewing conversations for.\n    limitfrom?: number; // The offset to start at.\n    limitnum?: number; // Limit number of conversations to this.\n    type?: number; // Filter by type.\n    favourites?: boolean; // Whether to restrict the results to contain NO favourite conversations (false), ONLY favourite\n    // conversation(true), or ignore any restriction altogether(null).\n    mergeself?: boolean; // Whether to include self-conversations (true) or ONLY private conversations (false) when private\n    // conversations are requested.\n\n};\n\n/**\n * Result of WS core_message_get_conversations.\n */\nexport type AddonMessagesGetConversationsResult = {\n    conversations: AddonMessagesConversation[];\n};\n\n/**\n * Params of core_message_get_messages WS.\n */\nexport type AddonMessagesGetMessagesWSParams = {\n    useridto: number; // The user id who received the message, 0 for any user.\n    useridfrom?: number; // The user id who send the message, 0 for any user. -10 or -20 for no-reply or support user.\n    type?: string; // Type of message to return, expected values are: notifications, conversations and both.\n    read?: boolean; // True for getting read messages, false for unread.\n    newestfirst?: boolean; // True for ordering by newest first, false for oldest first.\n    limitfrom?: number; // Limit from.\n    limitnum?: number; // Limit number.\n};\n\n/**\n * Result of WS core_message_get_messages.\n */\nexport type AddonMessagesGetMessagesResult = {\n    messages: AddonMessagesGetMessagesMessage[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Message data returned by core_message_get_messages.\n */\nexport type AddonMessagesGetMessagesMessage = {\n    id: number; // Message id.\n    useridfrom: number; // User from id.\n    useridto: number; // User to id.\n    subject: string; // The message subject.\n    text: string; // The message text formated.\n    fullmessage: string; // The message.\n    fullmessageformat: number; // Fullmessage format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    fullmessagehtml: string; // The message in html.\n    smallmessage: string; // The shorten message.\n    notification: number; // Is a notification?.\n    contexturl: string; // Context URL.\n    contexturlname: string; // Context URL link name.\n    timecreated: number; // Time created.\n    timeread: number; // Time read.\n    usertofullname: string; // User to full name.\n    userfromfullname: string; // User from full name.\n    component?: string; // @since 3.7. The component that generated the notification.\n    eventtype?: string; // @since 3.7. The type of notification.\n    customdata?: string; // @since 3.7. Custom data to be passed to the message processor.\n} & AddonMessagesGetMessagesMessageCalculatedData;\n\n/**\n * Response object on get discussion.\n */\nexport type AddonMessagesGetDiscussionMessages = {\n    messages: (AddonMessagesGetMessagesMessage | AddonMessagesOfflineMessagesDBRecordFormatted)[];\n    canLoadMore: boolean;\n};\n\n/**\n * Params of core_message_data_for_messagearea_search_messages WS.\n */\ntype AddonMessagesDataForMessageareaSearchMessagesWSParams = {\n    userid: number; // The id of the user who is performing the search.\n    search: string; // The string being searched.\n    limitfrom?: number; // Limit from.\n    limitnum?: number; // Limit number.\n};\n\n/**\n * Result of WS core_message_data_for_messagearea_search_messages.\n */\nexport type AddonMessagesDataForMessageareaSearchMessagesWSResponse = {\n    contacts: AddonMessagesMessageAreaContact[];\n};\n\n/**\n * Params of core_message_message_search_users WS.\n */\ntype AddonMessagesMessageSearchUsersWSParams = {\n    userid: number; // The id of the user who is performing the search.\n    search: string; // The string being searched.\n    limitfrom?: number; // Limit from.\n    limitnum?: number; // Limit number.\n};\n\n/**\n * Result of WS core_message_message_search_users.\n */\nexport type AddonMessagesSearchUsersWSResponse = {\n    contacts: AddonMessagesConversationMember[];\n    noncontacts: AddonMessagesConversationMember[];\n};\n\n/**\n * Params of core_message_mark_message_read WS.\n */\ntype AddonMessagesMarkMessageReadWSParams = {\n    messageid: number; // Id of the message in the messages table.\n    timeread?: number; // Timestamp for when the message should be marked read.\n};\n\n/**\n * Result of WS core_message_mark_message_read.\n */\nexport type AddonMessagesMarkMessageReadResult = {\n    messageid: number; // The id of the message in the messages table.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result of WS core_message_send_instant_messages.\n */\nexport type AddonMessagesSendInstantMessagesMessage = {\n    msgid: number; // Test this to know if it succeeds: i of the created message if it succeeded, -1 when failed.\n    clientmsgid?: string; // Your own id for the message.\n    errormessage?: string; // Error message - if it failed.\n    text?: string; // @since 3.6. The text of the message.\n    timecreated?: number; // @since 3.6. The timecreated timestamp for the message.\n    conversationid?: number; // @since 3.6. The conversation id for this message.\n    useridfrom?: number; // @since 3.6. The user id who sent the message.\n    candeletemessagesforallusers: boolean; // @since 3.7. If the user can delete messages in the conversation for all users.\n};\n\nexport type CoreMessageSendMessagesToConversationMessageData ={\n    text: string; // The text of the message.\n    textformat?: number; // Text format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n};\n\n/**\n * Params of core_message_send_messages_to_conversation WS.\n */\ntype CoreMessageSendMessagesToConversationWSParams = {\n    conversationid: number; // Id of the conversation.\n    messages: CoreMessageSendMessagesToConversationMessageData[];\n};\n\n/**\n * Result of WS core_message_send_messages_to_conversation.\n */\nexport type AddonMessagesSendMessagesToConversationMessage = {\n    id: number; // The id of the message.\n    useridfrom: number; // The id of the user who sent the message.\n    text: string; // The text of the message.\n    timecreated: number; // The timecreated timestamp for the message.\n};\n\n/**\n * Result for Send Messages functions trying online or storing in offline.\n */\nexport type AddonMessagesSendMessageResults = {\n    sent: boolean;\n    message: AddonMessagesSendMessagesToConversationMessage | AddonMessagesSendInstantMessagesMessage;\n};\n\n/**\n * Calculated data for core_message_get_contacts.\n */\nexport type AddonMessagesGetContactsCalculatedData = {\n    blocked?: AddonMessagesBlockedUser[]; // Calculated in the app. List of blocked users.\n};\n\n/**\n * Calculated data for core_message_get_conversation_messages.\n */\nexport type AddonMessagesGetConversationMessagesCalculatedData = {\n    canLoadMore?: boolean; // Calculated in the app. Whether more messages can be loaded.\n};\n\n/**\n * Calculated data for message preferences.\n */\nexport type AddonMessagesMessagePreferencesCalculatedData = {\n    blocknoncontacts?: number; // Calculated in the app. Based on the result of core_message_get_user_message_preferences.\n};\n\n/**\n * Calculated data for messages returned by core_message_get_messages.\n */\nexport type AddonMessagesGetMessagesMessageCalculatedData = {\n    pending?: boolean; // Calculated in the app. Whether the message is pending to be sent.\n    read?: boolean; // Calculated in the app. Whether the message has been read.\n};\n\n/**\n * Calculated data for contact for message area.\n */\nexport type AddonMessagesMessageAreaContactCalculatedData = {\n    id?: number; // Calculated in the app. User ID.\n};\n\n/**\n * Params of core_message_block_user WS.\n */\ntype AddonMessagesBlockUserWSParams = {\n    userid: number; // The id of the user who is blocking.\n    blockeduserid: number; // The id of the user being blocked.\n};\n\n/**\n * Params of core_message_unblock_user WS.\n */\ntype AddonMessagesUnblockUserWSParams = {\n    userid: number; // The id of the user who is unblocking.\n    unblockeduserid: number; // The id of the user being unblocked.\n};\n\n/**\n * Params of core_message_confirm_contact_request WS.\n */\ntype AddonMessagesConfirmContactRequestWSParams = {\n    userid: number; // The id of the user making the request.\n    requesteduserid: number; // The id of the user being requested.\n};\n\n/**\n * Params of core_message_create_contact_request WS.\n */\ntype AddonMessagesCreateContactRequestWSParams = AddonMessagesConfirmContactRequestWSParams;\n\n/**\n * Data returned by core_message_create_contact_request WS.\n */\nexport type AddonMessagesCreateContactRequestWSResponse = {\n    request?: {\n        id: number; // Message id.\n        userid: number; // User from id.\n        requesteduserid: number; // User to id.\n        timecreated: number; // Time created.\n    }; // Request record.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_message_decline_contact_request WS.\n */\ntype AddonMessagesDeclineContactRequestWSParams = AddonMessagesConfirmContactRequestWSParams;\n\n/**\n * Params of core_message_delete_conversations_by_id WS.\n */\ntype AddonMessagesDeleteConversationsByIdWSParams = {\n    userid: number; // The user id of who we want to delete the conversation for.\n    conversationids: number[]; // List of conversation IDs.\n};\n\n/**\n * Params of core_message_delete_message WS.\n */\ntype AddonMessagesDeleteMessageWSParams = {\n    messageid: number; // The message id.\n    userid: number; // The user id of who we want to delete the message for.\n    read?: boolean; // If is a message read.\n};\n\n/**\n * Params of core_message_delete_message_for_all_users WS.\n */\ntype AddonMessagesDeleteMessageForAllUsersWSParams = {\n    messageid: number; // The message id.\n    userid: number; // The user id of who we want to delete the message for all users.\n};\n\n/**\n * Params of core_message_get_user_contacts WS.\n */\ntype AddonMessagesGetUserContactsWSParams = {\n    userid: number; // The id of the user who we retrieving the contacts for.\n    limitfrom?: number; // Limit from.\n    limitnum?: number; // Limit number.\n};\n\n/**\n * Data returned by core_message_get_user_contacts WS.\n */\nexport type AddonMessagesGetUserContactsWSResponse = {\n    id: number; // The user id.\n    fullname: string; // The user's name.\n    profileurl: string; // The link to the user's profile page.\n    profileimageurl: string; // User picture URL.\n    profileimageurlsmall: string; // Small user picture URL.\n    isonline: boolean; // The user's online status.\n    showonlinestatus: boolean; // Show the user's online status?.\n    isblocked: boolean; // If the user has been blocked.\n    iscontact: boolean; // Is the user a contact?.\n    isdeleted: boolean; // Is the user deleted?.\n    canmessageevenifblocked: boolean; // If the user can still message even if they get blocked.\n    canmessage: boolean; // If the user can be messaged.\n    requirescontact: boolean; // If the user requires to be contacts.\n    contactrequests?: { // The contact requests.\n        id: number; // The id of the contact request.\n        userid: number; // The id of the user who created the contact request.\n        requesteduserid: number; // The id of the user confirming the request.\n        timecreated: number; // The timecreated timestamp for the contact request.\n    }[];\n    conversations?: { // Conversations between users.\n        id: number; // Conversations id.\n        type: number; // Conversation type: private or public.\n        name: string; // Multilang compatible conversation name2.\n        timecreated: number; // The timecreated timestamp for the conversation.\n    }[];\n}[];\n\n/**\n * Params of core_message_get_contact_requests WS.\n */\ntype AddonMessagesGetContactRequestsWSParams = {\n    userid: number; // The id of the user we want the requests for.\n    limitfrom?: number; // Limit from.\n    limitnum?: number; // Limit number.\n};\n\n/**\n * Data returned by core_message_get_contact_requests WS.\n */\nexport type AddonMessagesGetContactRequestsWSResponse = {\n    id: number; // The user id.\n    fullname: string; // The user's name.\n    profileurl: string; // The link to the user's profile page.\n    profileimageurl: string; // User picture URL.\n    profileimageurlsmall: string; // Small user picture URL.\n    isonline: boolean; // The user's online status.\n    showonlinestatus: boolean; // Show the user's online status?.\n    isblocked: boolean; // If the user has been blocked.\n    iscontact: boolean; // Is the user a contact?.\n    isdeleted: boolean; // Is the user deleted?.\n    canmessageevenifblocked: boolean; // If the user can still message even if they get blocked.\n    canmessage: boolean; // If the user can be messaged.\n    requirescontact: boolean; // If the user requires to be contacts.\n    contactrequests?: { // The contact requests.\n        id: number; // The id of the contact request.\n        userid: number; // The id of the user who created the contact request.\n        requesteduserid: number; // The id of the user confirming the request.\n        timecreated: number; // The timecreated timestamp for the contact request.\n    }[];\n    conversations?: { // Conversations between users.\n        id: number; // Conversations id.\n        type: number; // Conversation type: private or public.\n        name: string; // Multilang compatible conversation name2.\n        timecreated: number; // The timecreated timestamp for the conversation.\n    }[];\n}[];\n\n/**\n * Params of core_message_get_received_contact_requests_count WS.\n */\ntype AddonMessagesGetReceivedContactRequestsCountWSParams = {\n    userid: number; // The id of the user we want to return the number of received contact requests for.\n};\n\n/**\n * Params of core_message_mark_all_conversation_messages_as_read WS.\n */\ntype AddonMessagesMarkAllConversationMessagesAsReadWSParams = {\n    userid: number; // The user id who who we are marking the messages as read for.\n    conversationid: number; // The conversation id who who we are marking the messages as read for.\n};\n\n/**\n * Params of core_message_mark_all_messages_as_read WS. Deprecated on Moodle 3.6\n */\ntype AddonMessagesMarkAllMessagesAsReadWSParams = {\n    useridto: number; // The user id who received the message, 0 for any user.\n    useridfrom?: number; // The user id who send the message, 0 for any user. -10 or -20 for no-reply or support user.\n};\n\n/**\n * Params of core_message_mute_conversations and core_message_unmute_conversations WS.\n */\ntype AddonMessagesMuteConversationsWSParams = {\n    userid: number; // The id of the user who is blocking.\n    conversationids: number[];\n};\n\n/**\n * Params of core_message_delete_contacts WS.\n */\ntype AddonMessagesDeleteContactsWSParams = {\n    userids: number[]; // List of user IDs.\n    userid?: number; // The id of the user we are deleting the contacts for, 0 for the current user.\n\n};\n\n/**\n * One message data.\n */\nexport type AddonMessagesMessageData = {\n    touserid: number; // Id of the user to send the private message.\n    text: string; // The text of the message.\n    textformat?: number; // Text format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    clientmsgid?: string; // Your own client id for the message. If this id is provided, the fail message id will be returned.\n};\n\n/**\n * Params of core_message_send_instant_messages WS.\n */\ntype AddonMessagesSendInstantMessagesWSParams = {\n    messages: AddonMessagesMessageData[];\n};\n\n/**\n * Data returned by core_message_get_conversation_counts and core_message_get_unread_conversation_counts WS.\n */\nexport type AddonMessagesGetConversationCountsWSResponse = {\n    favourites: number; // Total number of favourite conversations.\n    types: {\n        1: number; // Total number of individual conversations.\n        2: number; // Total number of group conversations.\n        3: number; // Total number of self conversations.\n    };\n};\n\n/**\n * Params of core_message_set_favourite_conversations and core_message_unset_favourite_conversations WS.\n */\ntype AddonMessagesSetFavouriteConversationsWSParams = {\n    userid?: number; // Id of the user, 0 for current user.\n    conversations: number[];\n};\n\n/**\n * Params of core_message_get_unread_conversations_count WS.\n */\ntype AddonMessageGetUnreadConversationsCountWSParams = {\n    useridto: number; // The user id who received the message, 0 for any user.\n};\n\n/**\n * Data sent by UNREAD_CONVERSATION_COUNTS_EVENT event.\n */\nexport type AddonMessagesUnreadConversationCountsEventData = {\n    favourites: number;\n    individual: number;\n    group: number;\n    self: number;\n    orMore?: boolean;\n};\n\n/**\n * Data sent by CONTACT_REQUESTS_COUNT_EVENT event.\n */\nexport type AddonMessagesContactRequestCountEventData = {\n    count: number;\n};\n\n/**\n * Data sent by MEMBER_INFO_CHANGED_EVENT event.\n */\nexport type AddonMessagesMemberInfoChangedEventData = {\n    userId: number;\n    userBlocked?: boolean;\n    userUnblocked?: boolean;\n    contactRequestConfirmed?: boolean;\n    contactRequestCreated?: boolean;\n    contactRequestDeclined?: boolean;\n    contactRemoved?: boolean;\n};\n\n/**\n * Data sent by READ_CHANGED_EVENT event.\n */\nexport type AddonMessagesReadChangedEventData = {\n    userId?: number;\n    conversationId?: number;\n};\n\n/**\n * Data sent by NEW_MESSAGE_EVENT event.\n */\nexport type AddonMessagesNewMessagedEventData = {\n    conversationId?: number;\n    userId?: number;\n    message?: string; // If undefined it means the conversation has no messages, e.g. last message was deleted.\n    timecreated: number;\n    userFrom?: AddonMessagesConversationMember;\n    isfavourite: boolean;\n    type?: number;\n};\n\n/**\n * Data sent by UPDATE_CONVERSATION_LIST_EVENT event.\n */\nexport type AddonMessagesUpdateConversationListEventData = {\n    conversationId: number;\n    action: string;\n    value?: boolean;\n};\n\n/**\n * Data sent by OPEN_CONVERSATION_EVENT event.\n */\nexport type AddonMessagesOpenConversationEventData = {\n    userId?: number;\n    conversationId?: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}