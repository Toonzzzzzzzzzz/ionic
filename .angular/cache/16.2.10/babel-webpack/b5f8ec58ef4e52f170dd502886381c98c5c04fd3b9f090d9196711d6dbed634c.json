{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreError } from '@classes/errors/error';\n/**\n * Blocked sync error.\n */\nexport class CoreSyncBlockedError extends CoreError {}\n/**\n * Base class to create sync providers. It provides some common functions.\n */\nexport class CoreSyncBaseProvider {\n  constructor(component) {\n    /**\n     * Component of the sync provider.\n     */\n    this.component = 'core';\n    /**\n     * Translatable component name string.\n     */\n    this.componentTranslatableString = 'generic component';\n    /**\n     * Sync provider's interval.\n     */\n    this.syncInterval = 300000;\n    // Store sync promises.\n    this.syncPromises = {};\n    this.logger = CoreLogger.getInstance(component);\n    this.component = component;\n  }\n  /**\n   * Add an offline data deleted warning to a list of warnings.\n   *\n   * @param warnings List of warnings.\n   * @param name Instance name.\n   * @param error Specific error message.\n   */\n  addOfflineDataDeletedWarning(warnings, name, error) {\n    const warning = this.getOfflineDataDeletedWarning(name, error);\n    if (warnings.indexOf(warning) == -1) {\n      warnings.push(warning);\n    }\n  }\n  /**\n   * Add an ongoing sync to the syncPromises list. On finish the promise will be removed.\n   *\n   * @param id Unique sync identifier per component.\n   * @param promise The promise of the sync to add.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns The sync promise.\n   */\n  addOngoingSync(id, promise, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!siteId) {\n        throw new CoreError('CoreSyncBaseProvider: Site ID not supplied');\n      }\n      const uniqueId = _this.getUniqueSyncId(id);\n      if (!_this.syncPromises[siteId]) {\n        _this.syncPromises[siteId] = {};\n      }\n      _this.syncPromises[siteId][uniqueId] = promise;\n      // Promise will be deleted when finish.\n      try {\n        return yield promise;\n      } finally {\n        delete _this.syncPromises[siteId][uniqueId];\n      }\n    })();\n  }\n  /**\n   * Add an offline data deleted warning to a list of warnings.\n   *\n   * @param name Instance name.\n   * @param error Specific error message.\n   * @returns Warning message.\n   */\n  getOfflineDataDeletedWarning(name, error) {\n    return Translate.instant('core.warningofflinedatadeleted', {\n      component: this.componentTranslate,\n      name: name,\n      error: CoreTextUtils.getErrorMessageFromError(error)\n    });\n  }\n  /**\n   * If there's an ongoing sync for a certain identifier return it.\n   *\n   * @param id Unique sync identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise of the current sync or undefined if there isn't any.\n   */\n  getOngoingSync(id, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const uniqueId = this.getUniqueSyncId(id);\n    if (this.syncPromises[siteId] && this.syncPromises[siteId][uniqueId] !== undefined) {\n      return this.syncPromises[siteId][uniqueId];\n    }\n  }\n  /**\n   * Get the synchronization time in a human readable format.\n   *\n   * @param id Unique sync identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the readable time.\n   */\n  getReadableSyncTime(id, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const time = yield _this2.getSyncTime(id, siteId);\n      return _this2.getReadableTimeFromTimestamp(time);\n    })();\n  }\n  /**\n   * Given a timestamp return it in a human readable format.\n   *\n   * @param timestamp Timestamp\n   * @returns Human readable time.\n   */\n  getReadableTimeFromTimestamp(timestamp) {\n    if (!timestamp) {\n      return Translate.instant('core.never');\n    } else {\n      return CoreTimeUtils.userDate(timestamp);\n    }\n  }\n  /**\n   * Get the synchronization time. Returns 0 if no time stored.\n   *\n   * @param id Unique sync identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the time.\n   */\n  getSyncTime(id, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const entry = yield CoreSync.getSyncRecord(_this3.component, id, siteId);\n        return entry.time;\n      } catch (_unused) {\n        return 0;\n      }\n    })();\n  }\n  /**\n   * Get the synchronization warnings of an instance.\n   *\n   * @param id Unique sync identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the warnings.\n   */\n  getSyncWarnings(id, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const entry = yield CoreSync.getSyncRecord(_this4.component, id, siteId);\n        return CoreTextUtils.parseJSON(entry.warnings, []);\n      } catch (_unused2) {\n        return [];\n      }\n    })();\n  }\n  /**\n   * Create a unique identifier from component and id.\n   *\n   * @param id Unique sync identifier per component.\n   * @returns Unique identifier from component and id.\n   */\n  getUniqueSyncId(id) {\n    return this.component + '#' + id;\n  }\n  /**\n   * Check if a there's an ongoing syncronization for the given id.\n   *\n   * @param id Unique sync identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Whether it's synchronizing.\n   */\n  isSyncing(id, siteId) {\n    return !!this.getOngoingSync(id, siteId);\n  }\n  /**\n   * Check if a sync is needed: if a certain time has passed since the last time.\n   *\n   * @param id Unique sync identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether sync is needed.\n   */\n  isSyncNeeded(id, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const time = yield _this5.getSyncTime(id, siteId);\n      return Date.now() - _this5.syncInterval >= time;\n    })();\n  }\n  /**\n   * Set the synchronization time.\n   *\n   * @param id Unique sync identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @param time Time to set. If not defined, current time.\n   * @returns Promise resolved when the time is set.\n   */\n  setSyncTime(id, siteId, time) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      time = time !== undefined ? time : Date.now();\n      yield CoreSync.insertOrUpdateSyncRecord(_this6.component, id, {\n        time: time\n      }, siteId);\n    })();\n  }\n  /**\n   * Set the synchronization warnings.\n   *\n   * @param id Unique sync identifier per component.\n   * @param warnings Warnings to set.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  setSyncWarnings(id, warnings, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const warningsText = JSON.stringify(warnings || []);\n      yield CoreSync.insertOrUpdateSyncRecord(_this7.component, id, {\n        warnings: warningsText\n      }, siteId);\n    })();\n  }\n  /**\n   * Execute a sync function on selected sites.\n   *\n   * @param syncFunctionLog Log message to explain the sync function purpose.\n   * @param syncFunction Sync function to execute.\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @returns Resolved with siteIds selected. Rejected if offline.\n   */\n  syncOnSites(syncFunctionLog, syncFunction, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreNetwork.isOnline()) {\n        const message = `Cannot sync '${syncFunctionLog}' because device is offline.`;\n        _this8.logger.debug(message);\n        throw new CoreError(message);\n      }\n      let siteIds = [];\n      if (!siteId) {\n        // No site ID defined, sync all sites.\n        _this8.logger.debug(`Try to sync '${syncFunctionLog}' in all sites.`);\n        siteIds = yield CoreSites.getLoggedInSitesIds();\n      } else {\n        _this8.logger.debug(`Try to sync '${syncFunctionLog}' in site '${siteId}'.`);\n        siteIds = [siteId];\n      }\n      // Execute function for every site.\n      yield Promise.all(siteIds.map(siteId => syncFunction(siteId)));\n    })();\n  }\n  /**\n   * If there's an ongoing sync for a certain identifier, wait for it to end.\n   * If there's no sync ongoing the promise will be resolved right away.\n   *\n   * @param id Unique sync identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when there's no sync going on for the identifier.\n   */\n  waitForSync(id, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const promise = _this9.getOngoingSync(id, siteId);\n      if (!promise) {\n        return;\n      }\n      try {\n        return yield promise;\n      } catch (_unused3) {\n        return;\n      }\n    })();\n  }\n  /**\n   * Get component name translated.\n   *\n   * @returns Component name translated.\n   */\n  get componentTranslate() {\n    if (!this.componentTranslateInternal) {\n      this.componentTranslateInternal = Translate.instant(this.componentTranslatableString);\n    }\n    return this.componentTranslateInternal;\n  }\n}","map":{"version":3,"names":["CoreNetwork","CoreSites","CoreSync","CoreTextUtils","CoreTimeUtils","Translate","CoreLogger","CoreError","CoreSyncBlockedError","CoreSyncBaseProvider","constructor","component","componentTranslatableString","syncInterval","syncPromises","logger","getInstance","addOfflineDataDeletedWarning","warnings","name","error","warning","getOfflineDataDeletedWarning","indexOf","push","addOngoingSync","id","promise","siteId","_this","_asyncToGenerator","getCurrentSiteId","uniqueId","getUniqueSyncId","instant","componentTranslate","getErrorMessageFromError","getOngoingSync","undefined","getReadableSyncTime","_this2","time","getSyncTime","getReadableTimeFromTimestamp","timestamp","userDate","_this3","entry","getSyncRecord","_unused","getSyncWarnings","_this4","parseJSON","_unused2","isSyncing","isSyncNeeded","_this5","Date","now","setSyncTime","_this6","insertOrUpdateSyncRecord","setSyncWarnings","_this7","warningsText","JSON","stringify","syncOnSites","syncFunctionLog","syncFunction","_this8","isOnline","message","debug","siteIds","getLoggedInSitesIds","Promise","all","map","waitForSync","_this9","_unused3","componentTranslateInternal"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/base-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreAnyError, CoreError } from '@classes/errors/error';\n\n/**\n * Blocked sync error.\n */\nexport class CoreSyncBlockedError extends CoreError {}\n\n/**\n * Base class to create sync providers. It provides some common functions.\n */\nexport class CoreSyncBaseProvider<T = void> {\n\n    /**\n     * Logger instance.\n     */\n    protected logger: CoreLogger;\n\n    /**\n     * Component of the sync provider.\n     */\n    component = 'core';\n\n    /**\n     * Translatable component name string.\n     */\n    protected componentTranslatableString = 'generic component';\n\n    /**\n     * Translated name of the component.\n     */\n    protected componentTranslateInternal?: string;\n\n    /**\n     * Sync provider's interval.\n     */\n    syncInterval = 300000;\n\n    // Store sync promises.\n    protected syncPromises: { [siteId: string]: { [uniqueId: string]: Promise<T> } } = {};\n\n    constructor(component: string) {\n        this.logger = CoreLogger.getInstance(component);\n        this.component = component;\n    }\n\n    /**\n     * Add an offline data deleted warning to a list of warnings.\n     *\n     * @param warnings List of warnings.\n     * @param name Instance name.\n     * @param error Specific error message.\n     */\n    protected addOfflineDataDeletedWarning(warnings: string[], name: string, error: CoreAnyError): void {\n        const warning = this.getOfflineDataDeletedWarning(name, error);\n\n        if (warnings.indexOf(warning) == -1) {\n            warnings.push(warning);\n        }\n    }\n\n    /**\n     * Add an ongoing sync to the syncPromises list. On finish the promise will be removed.\n     *\n     * @param id Unique sync identifier per component.\n     * @param promise The promise of the sync to add.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns The sync promise.\n     */\n    async addOngoingSync(id: string | number, promise: Promise<T>, siteId?: string): Promise<T> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!siteId) {\n            throw new CoreError('CoreSyncBaseProvider: Site ID not supplied');\n        }\n\n        const uniqueId = this.getUniqueSyncId(id);\n        if (!this.syncPromises[siteId]) {\n            this.syncPromises[siteId] = {};\n        }\n\n        this.syncPromises[siteId][uniqueId] = promise;\n\n        // Promise will be deleted when finish.\n        try {\n            return await promise;\n        } finally {\n            delete this.syncPromises[siteId][uniqueId];\n        }\n    }\n\n    /**\n     * Add an offline data deleted warning to a list of warnings.\n     *\n     * @param name Instance name.\n     * @param error Specific error message.\n     * @returns Warning message.\n     */\n    protected getOfflineDataDeletedWarning(name: string, error: CoreAnyError): string {\n        return Translate.instant('core.warningofflinedatadeleted', {\n            component: this.componentTranslate,\n            name: name,\n            error: CoreTextUtils.getErrorMessageFromError(error),\n        });\n    }\n\n    /**\n     * If there's an ongoing sync for a certain identifier return it.\n     *\n     * @param id Unique sync identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise of the current sync or undefined if there isn't any.\n     */\n    getOngoingSync(id: string | number, siteId?: string): Promise<T> | undefined {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n        const uniqueId = this.getUniqueSyncId(id);\n\n        if (this.syncPromises[siteId] && this.syncPromises[siteId][uniqueId] !== undefined) {\n            return this.syncPromises[siteId][uniqueId];\n        }\n    }\n\n    /**\n     * Get the synchronization time in a human readable format.\n     *\n     * @param id Unique sync identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the readable time.\n     */\n    async getReadableSyncTime(id: string | number, siteId?: string): Promise<string> {\n        const time = await this.getSyncTime(id, siteId);\n\n        return this.getReadableTimeFromTimestamp(time);\n    }\n\n    /**\n     * Given a timestamp return it in a human readable format.\n     *\n     * @param timestamp Timestamp\n     * @returns Human readable time.\n     */\n    getReadableTimeFromTimestamp(timestamp: number): string {\n        if (!timestamp) {\n            return Translate.instant('core.never');\n        } else {\n            return CoreTimeUtils.userDate(timestamp);\n        }\n    }\n\n    /**\n     * Get the synchronization time. Returns 0 if no time stored.\n     *\n     * @param id Unique sync identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the time.\n     */\n    async getSyncTime(id: string | number, siteId?: string): Promise<number> {\n        try {\n            const entry = await CoreSync.getSyncRecord(this.component, id, siteId);\n\n            return entry.time;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Get the synchronization warnings of an instance.\n     *\n     * @param id Unique sync identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the warnings.\n     */\n    async getSyncWarnings(id: string | number, siteId?: string): Promise<string[]> {\n        try {\n            const entry = await CoreSync.getSyncRecord(this.component, id, siteId);\n\n            return <string[]> CoreTextUtils.parseJSON(entry.warnings, []);\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Create a unique identifier from component and id.\n     *\n     * @param id Unique sync identifier per component.\n     * @returns Unique identifier from component and id.\n     */\n    protected getUniqueSyncId(id: string | number): string {\n        return this.component + '#' + id;\n    }\n\n    /**\n     * Check if a there's an ongoing syncronization for the given id.\n     *\n     * @param id Unique sync identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Whether it's synchronizing.\n     */\n    isSyncing(id: string | number, siteId?: string): boolean {\n        return !!this.getOngoingSync(id, siteId);\n    }\n\n    /**\n     * Check if a sync is needed: if a certain time has passed since the last time.\n     *\n     * @param id Unique sync identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether sync is needed.\n     */\n    async isSyncNeeded(id: string | number, siteId?: string): Promise<boolean> {\n        const time = await this.getSyncTime(id, siteId);\n\n        return Date.now() - this.syncInterval >= time;\n    }\n\n    /**\n     * Set the synchronization time.\n     *\n     * @param id Unique sync identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @param time Time to set. If not defined, current time.\n     * @returns Promise resolved when the time is set.\n     */\n    async setSyncTime(id: string | number, siteId?: string, time?: number): Promise<void> {\n        time = time !== undefined ? time : Date.now();\n\n        await CoreSync.insertOrUpdateSyncRecord(this.component, id, { time: time }, siteId);\n    }\n\n    /**\n     * Set the synchronization warnings.\n     *\n     * @param id Unique sync identifier per component.\n     * @param warnings Warnings to set.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async setSyncWarnings(id: string | number, warnings: string[], siteId?: string): Promise<void> {\n        const warningsText = JSON.stringify(warnings || []);\n\n        await CoreSync.insertOrUpdateSyncRecord(this.component, id, { warnings: warningsText }, siteId);\n    }\n\n    /**\n     * Execute a sync function on selected sites.\n     *\n     * @param syncFunctionLog Log message to explain the sync function purpose.\n     * @param syncFunction Sync function to execute.\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @returns Resolved with siteIds selected. Rejected if offline.\n     */\n    async syncOnSites(syncFunctionLog: string, syncFunction: (siteId: string) => void, siteId?: string): Promise<void> {\n        if (!CoreNetwork.isOnline()) {\n            const message = `Cannot sync '${syncFunctionLog}' because device is offline.`;\n            this.logger.debug(message);\n\n            throw new CoreError(message);\n        }\n\n        let siteIds: string[] = [];\n\n        if (!siteId) {\n            // No site ID defined, sync all sites.\n            this.logger.debug(`Try to sync '${syncFunctionLog}' in all sites.`);\n            siteIds = await CoreSites.getLoggedInSitesIds();\n        } else {\n            this.logger.debug(`Try to sync '${syncFunctionLog}' in site '${siteId}'.`);\n            siteIds = [siteId];\n        }\n\n        // Execute function for every site.\n        await Promise.all(siteIds.map((siteId) => syncFunction(siteId)));\n    }\n\n    /**\n     * If there's an ongoing sync for a certain identifier, wait for it to end.\n     * If there's no sync ongoing the promise will be resolved right away.\n     *\n     * @param id Unique sync identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when there's no sync going on for the identifier.\n     */\n    async waitForSync(id: string | number, siteId?: string): Promise<T | undefined> {\n        const promise = this.getOngoingSync(id, siteId);\n\n        if (!promise) {\n            return;\n        }\n\n        try {\n            return await promise;\n        } catch {\n            return;\n        }\n    }\n\n    /**\n     * Get component name translated.\n     *\n     * @returns Component name translated.\n     */\n    protected get componentTranslate(): string {\n        if (!this.componentTranslateInternal) {\n            this.componentTranslateInternal = <string> Translate.instant(this.componentTranslatableString);\n        }\n\n        return this.componentTranslateInternal;\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}