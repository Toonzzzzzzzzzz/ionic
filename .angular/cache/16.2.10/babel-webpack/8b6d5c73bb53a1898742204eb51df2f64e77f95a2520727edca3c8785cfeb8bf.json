{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreConstants } from '@/core/constants';\nimport { isSafeNumber } from '@/core/utils/types';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreQuestionHelper } from '@features/question/services/question-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { AddonModQuizAccessRuleDelegate } from '../access-rules-delegate';\nimport { AddonModQuiz, AddonModQuizProvider } from '../quiz';\nimport { AddonModQuizHelper } from '../quiz-helper';\nimport { AddonModQuizSync } from '../quiz-sync';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to prefetch quizzes.\n */\nexport class AddonModQuizPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n  constructor() {\n    super(...arguments);\n    this.name = 'AddonModQuiz';\n    this.modName = 'quiz';\n    this.component = AddonModQuizProvider.COMPONENT;\n    this.updatesNames = /^configuration$|^.*files$|^grades$|^gradeitems$|^questions$|^attempts$/;\n  }\n  /**\n   * Download the module.\n   *\n   * @param module The module object returned by WS.\n   * @param courseId Course ID.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @param canStart If true, start a new attempt if needed.\n   * @returns Promise resolved when all content is downloaded.\n   */\n  download(module, courseId, dirPath, single, canStart = true) {\n    // Same implementation for download and prefetch.\n    return this.prefetch(module, courseId, single, dirPath, canStart);\n  }\n  /**\n   * Get list of files. If not defined, we'll assume they're in module.contents.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @returns Promise resolved with the list of files.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getFiles(module, courseId, single) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const quiz = yield AddonModQuiz.getQuiz(courseId, module.id);\n        const files = _this.getIntroFilesFromInstance(module, quiz);\n        const attempts = yield AddonModQuiz.getUserAttempts(quiz.id, {\n          cmId: module.id,\n          readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */\n        });\n\n        const attemptFiles = yield _this.getAttemptsFeedbackFiles(quiz, attempts);\n        return files.concat(attemptFiles);\n      } catch (_unused) {\n        // Quiz not found, return empty list.\n        return [];\n      }\n    })();\n  }\n  /**\n   * Get the list of downloadable files on feedback attemptss.\n   *\n   * @param quiz Quiz.\n   * @param attempts Quiz user attempts.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns List of Files.\n   */\n  getAttemptsFeedbackFiles(quiz, attempts, siteId) {\n    return _asyncToGenerator(function* () {\n      let files = [];\n      yield Promise.all(attempts.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (attempt) {\n          var _feedback$feedbackinl;\n          if (!AddonModQuiz.isAttemptFinished(attempt.state)) {\n            // Attempt not finished, no feedback files.\n            return;\n          }\n          const attemptGrade = AddonModQuiz.rescaleGrade(attempt.sumgrades, quiz, false);\n          const attemptGradeNumber = attemptGrade !== undefined && Number(attemptGrade);\n          if (!isSafeNumber(attemptGradeNumber)) {\n            return;\n          }\n          const feedback = yield AddonModQuiz.getFeedbackForGrade(quiz.id, attemptGradeNumber, {\n            cmId: quiz.coursemodule,\n            readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n            siteId\n          });\n          if ((_feedback$feedbackinl = feedback.feedbackinlinefiles) !== null && _feedback$feedbackinl !== void 0 && _feedback$feedbackinl.length) {\n            files = files.concat(feedback.feedbackinlinefiles);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return files;\n    })();\n  }\n  /**\n   * Gather some preflight data for an attempt. This function will start a new attempt if needed.\n   *\n   * @param quiz Quiz.\n   * @param accessInfo Quiz access info returned by AddonModQuizProvider.getQuizAccessInformation.\n   * @param attempt Attempt to continue. Don't pass any value if the user needs to start a new attempt.\n   * @param askPreflight Whether it should ask for preflight data if needed.\n   * @param title Lang key of the title to set to preflight modal (e.g. 'addon.mod_quiz.startattempt').\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the preflight data.\n   */\n  getPreflightData(quiz, accessInfo, attempt, askPreflight, title, siteId) {\n    return _asyncToGenerator(function* () {\n      const preflightData = {};\n      if (askPreflight) {\n        // We can ask preflight, check if it's needed and get the data.\n        yield AddonModQuizHelper.getAndCheckPreflightData(quiz, accessInfo, preflightData, attempt, false, true, title, siteId);\n      } else {\n        // Get some fixed preflight data from access rules (data that doesn't require user interaction).\n        const rules = (accessInfo === null || accessInfo === void 0 ? void 0 : accessInfo.activerulenames) || [];\n        yield AddonModQuizAccessRuleDelegate.getFixedPreflightData(rules, quiz, preflightData, attempt, true, siteId);\n        if (!attempt) {\n          // We need to create a new attempt.\n          yield AddonModQuiz.startAttempt(quiz.id, preflightData, false, siteId);\n        }\n      }\n      return preflightData;\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId The course ID the module belongs to.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId) {\n    return AddonModQuiz.invalidateContent(moduleId, courseId);\n  }\n  /**\n   * Invalidate WS calls needed to determine module status.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when invalidated.\n   */\n  invalidateModule(module, courseId) {\n    return _asyncToGenerator(function* () {\n      // Invalidate the calls required to check if a quiz is downloadable.\n      yield Promise.all([AddonModQuiz.invalidateQuizData(courseId), AddonModQuiz.invalidateUserAttemptsForUser(module.instance)]);\n    })();\n  }\n  /**\n   * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Whether the module can be downloaded. The promise should never be rejected.\n   */\n  isDownloadable(module, courseId) {\n    return _asyncToGenerator(function* () {\n      var _CoreSites$getCurrent, _quiz$attempts;\n      if ((_CoreSites$getCurrent = CoreSites.getCurrentSite()) !== null && _CoreSites$getCurrent !== void 0 && _CoreSites$getCurrent.isOfflineDisabled()) {\n        // Don't allow downloading the quiz if offline is disabled to prevent wasting a lot of data when opening it.\n        return false;\n      }\n      const siteId = CoreSites.getCurrentSiteId();\n      const quiz = yield AddonModQuiz.getQuiz(courseId, module.id, {\n        siteId\n      });\n      if (!AddonModQuiz.isQuizOffline(quiz) || quiz.hasquestions === 0) {\n        return false;\n      }\n      // Not downloadable if we reached max attempts or the quiz has an unfinished attempt.\n      const attempts = yield AddonModQuiz.getUserAttempts(quiz.id, {\n        cmId: module.id,\n        siteId\n      });\n      const isLastFinished = !attempts.length || AddonModQuiz.isAttemptFinished(attempts[attempts.length - 1].state);\n      return quiz.attempts === 0 || ((_quiz$attempts = quiz.attempts) !== null && _quiz$attempts !== void 0 ? _quiz$attempts : 0) > attempts.length || !isLastFinished;\n    })();\n  }\n  /**\n   * Whether or not the handler is enabled on a site level.\n   *\n   * @returns A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  /**\n   * Prefetch a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @param canStart If true, start a new attempt if needed.\n   * @returns Promise resolved when done.\n   */\n  prefetch(module, courseId, single, dirPath, canStart = true) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (module.attemptFinished) {\n        // Delete the value so it does not block anything if true.\n        delete module.attemptFinished;\n        // Quiz got synced recently and an attempt has finished. Do not prefetch.\n        return;\n      }\n      return _this2.prefetchPackage(module, courseId, siteId => _this2.prefetchQuiz(module, courseId, !!single, canStart, siteId));\n    })();\n  }\n  /**\n   * Prefetch a quiz.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @param canStart If true, start a new attempt if needed.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  prefetchQuiz(module, courseId, single, canStart, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const commonOptions = {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      const modOptions = _objectSpread({\n        cmId: module.id\n      }, commonOptions);\n      // Get quiz.\n      const quiz = yield AddonModQuiz.getQuiz(courseId, module.id, commonOptions);\n      const introFiles = _this3.getIntroFilesFromInstance(module, quiz);\n      // Prefetch some quiz data.\n      // eslint-disable-next-line prefer-const\n      let [quizAccessInfo, attempts, attemptAccessInfo] = yield Promise.all([AddonModQuiz.getQuizAccessInformation(quiz.id, modOptions), AddonModQuiz.getUserAttempts(quiz.id, modOptions), AddonModQuiz.getAttemptAccessInformation(quiz.id, 0, modOptions), AddonModQuiz.getQuizRequiredQtypes(quiz.id, modOptions), CoreFilepool.addFilesToQueue(siteId, introFiles, AddonModQuizProvider.COMPONENT, module.id)]);\n      // Check if we need to start a new attempt.\n      let attempt = attempts[attempts.length - 1];\n      let preflightData = {};\n      let startAttempt = false;\n      if (canStart || attempt) {\n        if (canStart && (!attempt || AddonModQuiz.isAttemptFinished(attempt.state))) {\n          // Check if the user can attempt the quiz.\n          if (attemptAccessInfo.preventnewattemptreasons.length) {\n            throw new CoreError(CoreTextUtils.buildMessage(attemptAccessInfo.preventnewattemptreasons));\n          }\n          startAttempt = true;\n          attempt = undefined;\n        }\n        // Get the preflight data. This function will also start a new attempt if needed.\n        preflightData = yield _this3.getPreflightData(quiz, quizAccessInfo, attempt, single, 'core.download', siteId);\n      }\n      const promises = [];\n      if (startAttempt) {\n        // Re-fetch user attempts since we created a new one.\n        promises.push(AddonModQuiz.getUserAttempts(quiz.id, modOptions).then( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (atts) {\n            attempts = atts;\n            const attemptFiles = yield _this3.getAttemptsFeedbackFiles(quiz, attempts, siteId);\n            return CoreFilepool.addFilesToQueue(siteId, attemptFiles, AddonModQuizProvider.COMPONENT, module.id);\n          });\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }()));\n        // Update the download time to prevent detecting the new attempt as an update.\n        promises.push(CoreUtils.ignoreErrors(CoreFilepool.updatePackageDownloadTime(siteId, AddonModQuizProvider.COMPONENT, module.id)));\n      } else {\n        // Use the already fetched attempts.\n        promises.push(_this3.getAttemptsFeedbackFiles(quiz, attempts, siteId).then(attemptFiles => CoreFilepool.addFilesToQueue(siteId, attemptFiles, AddonModQuizProvider.COMPONENT, module.id)));\n      }\n      // Fetch attempt related data.\n      promises.push(AddonModQuiz.getCombinedReviewOptions(quiz.id, modOptions));\n      promises.push(AddonModQuiz.getUserBestGrade(quiz.id, modOptions));\n      promises.push(_this3.prefetchGradeAndFeedback(quiz, modOptions, siteId));\n      promises.push(AddonModQuiz.getAttemptAccessInformation(quiz.id, 0, modOptions)); // Last attempt.\n      // Get course data, needed to determine upload max size if it's configured to be course limit.\n      promises.push(CoreUtils.ignoreErrors(CoreCourses.getCourseByField('id', courseId, siteId)));\n      yield Promise.all(promises);\n      // We have quiz data, now we'll get specific data for each attempt.\n      yield Promise.all(attempts.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (attempt) {\n          yield _this3.prefetchAttempt(quiz, attempt, preflightData, siteId);\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      if (!canStart) {\n        // Nothing else to do.\n        return;\n      }\n      // If there's nothing to send, mark the quiz as synchronized.\n      const hasData = yield AddonModQuizSync.hasDataToSync(quiz.id, siteId);\n      if (!hasData) {\n        AddonModQuizSync.setSyncTime(quiz.id, siteId);\n      }\n    })();\n  }\n  /**\n   * Prefetch all WS data for an attempt.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param preflightData Preflight required data (like password).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the prefetch is finished. Data returned is not reliable.\n   */\n  prefetchAttempt(quiz, attempt, preflightData, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const pages = AddonModQuiz.getPagesFromLayout(attempt.layout);\n      const isSequential = AddonModQuiz.isNavigationSequential(quiz);\n      let promises = [];\n      const modOptions = {\n        cmId: quiz.coursemodule,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      if (AddonModQuiz.isAttemptFinished(attempt.state)) {\n        // Attempt is finished, get feedback and review data.\n        const attemptGrade = AddonModQuiz.rescaleGrade(attempt.sumgrades, quiz, false);\n        const attemptGradeNumber = attemptGrade !== undefined && Number(attemptGrade);\n        if (isSafeNumber(attemptGradeNumber)) {\n          promises.push(AddonModQuiz.getFeedbackForGrade(quiz.id, attemptGradeNumber, modOptions));\n        }\n        // Get the review for each page.\n        pages.forEach(page => {\n          promises.push(CoreUtils.ignoreErrors(AddonModQuiz.getAttemptReview(attempt.id, _objectSpread({\n            page\n          }, modOptions))));\n        });\n        // Get the review for all questions in same page.\n        promises.push(_this4.prefetchAttemptReviewFiles(quiz, attempt, modOptions, siteId));\n      } else {\n        // Attempt not finished, get data needed to continue the attempt.\n        promises.push(AddonModQuiz.getAttemptAccessInformation(quiz.id, attempt.id, modOptions));\n        promises.push(AddonModQuiz.getAttemptSummary(attempt.id, preflightData, modOptions));\n        if (attempt.state == AddonModQuizProvider.ATTEMPT_IN_PROGRESS) {\n          // Get data for each page.\n          promises = promises.concat(pages.map( /*#__PURE__*/function () {\n            var _ref4 = _asyncToGenerator(function* (page) {\n              if (isSequential && typeof attempt.currentpage === 'number' && page < attempt.currentpage) {\n                // Sequential quiz, cannot get pages before the current one.\n                return;\n              }\n              const data = yield AddonModQuiz.getAttemptData(attempt.id, page, preflightData, modOptions);\n              // Download the files inside the questions.\n              yield Promise.all(data.questions.map( /*#__PURE__*/function () {\n                var _ref5 = _asyncToGenerator(function* (question) {\n                  yield CoreQuestionHelper.prefetchQuestionFiles(question, _this4.component, quiz.coursemodule, siteId, attempt.uniqueid);\n                });\n                return function (_x5) {\n                  return _ref5.apply(this, arguments);\n                };\n              }()));\n            });\n            return function (_x4) {\n              return _ref4.apply(this, arguments);\n            };\n          }()));\n        }\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Prefetch attempt review and its files.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param modOptions Other options.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  prefetchAttemptReviewFiles(quiz, attempt, modOptions, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      // Get the review for all questions in same page.\n      const data = yield CoreUtils.ignoreErrors(AddonModQuiz.getAttemptReview(attempt.id, _objectSpread({\n        page: -1\n      }, modOptions)));\n      if (!data) {\n        return;\n      }\n      // Download the files inside the questions.\n      yield Promise.all(data.questions.map(question => {\n        CoreQuestionHelper.prefetchQuestionFiles(question, _this5.component, quiz.coursemodule, siteId, attempt.uniqueid);\n      }));\n    })();\n  }\n  /**\n   * Prefetch quiz grade and its feedback.\n   *\n   * @param quiz Quiz.\n   * @param modOptions Other options.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  prefetchGradeAndFeedback(quiz, modOptions, siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const gradebookData = yield AddonModQuiz.getGradeFromGradebook(quiz.course, quiz.coursemodule, true, siteId);\n        if (gradebookData && gradebookData.graderaw !== undefined) {\n          yield AddonModQuiz.getFeedbackForGrade(quiz.id, gradebookData.graderaw, modOptions);\n        }\n      } catch (_unused2) {\n        // Ignore errors.\n      }\n    })();\n  }\n  /**\n   * Prefetches some data for a quiz and its last attempt.\n   * This function will NOT start a new attempt, it only reads data for the quiz and the last attempt.\n   *\n   * @param quiz Quiz.\n   * @param askPreflight Whether it should ask for preflight data if needed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  prefetchQuizAndLastAttempt(quiz, askPreflight, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const modOptions = {\n        cmId: quiz.coursemodule,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      // Get quiz data.\n      const [quizAccessInfo, attempts] = yield Promise.all([AddonModQuiz.getQuizAccessInformation(quiz.id, modOptions), AddonModQuiz.getUserAttempts(quiz.id, modOptions), AddonModQuiz.getQuizRequiredQtypes(quiz.id, modOptions), AddonModQuiz.getCombinedReviewOptions(quiz.id, modOptions), AddonModQuiz.getUserBestGrade(quiz.id, modOptions), _this6.prefetchGradeAndFeedback(quiz, modOptions, siteId), AddonModQuiz.getAttemptAccessInformation(quiz.id, 0, modOptions) // Last attempt.\n      ]);\n\n      const lastAttempt = attempts[attempts.length - 1];\n      let preflightData = {};\n      if (lastAttempt) {\n        // Get the preflight data.\n        preflightData = yield _this6.getPreflightData(quiz, quizAccessInfo, lastAttempt, askPreflight, 'core.download', siteId);\n        // Get data for last attempt.\n        yield _this6.prefetchAttempt(quiz, lastAttempt, preflightData, siteId);\n      }\n      // Prefetch finished, set the right status.\n      yield _this6.setStatusAfterPrefetch(quiz, {\n        cmId: quiz.coursemodule,\n        attempts,\n        readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n        siteId\n      });\n    })();\n  }\n  /**\n   * Set the right status to a quiz after prefetching.\n   * If the last attempt is finished or there isn't one, set it as not downloaded to show download icon.\n   *\n   * @param quiz Quiz.\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  setStatusAfterPrefetch(quiz, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      let attempts = options.attempts;\n      if (!attempts) {\n        // Get the attempts.\n        attempts = yield AddonModQuiz.getUserAttempts(quiz.id, options);\n      }\n      // Check the current status of the quiz.\n      const status = yield CoreFilepool.getPackageStatus(options.siteId, _this7.component, quiz.coursemodule);\n      if (status === CoreConstants.NOT_DOWNLOADED) {\n        return;\n      }\n      // Quiz was downloaded, set the new status.\n      // If no attempts or last is finished we'll mark it as not downloaded to show download icon.\n      const lastAttempt = attempts[attempts.length - 1];\n      const isLastFinished = !lastAttempt || AddonModQuiz.isAttemptFinished(lastAttempt.state);\n      const newStatus = isLastFinished ? CoreConstants.NOT_DOWNLOADED : CoreConstants.DOWNLOADED;\n      yield CoreFilepool.storePackageStatus(options.siteId, newStatus, _this7.component, quiz.coursemodule);\n    })();\n  }\n  /**\n   * Sync a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  sync(module, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const quiz = yield AddonModQuiz.getQuiz(courseId, module.id, {\n        siteId\n      });\n      try {\n        const result = yield AddonModQuizSync.syncQuiz(quiz, false, siteId);\n        module.attemptFinished = result.attemptFinished || false;\n        return result;\n      } catch (_unused3) {\n        // Ignore errors.\n        module.attemptFinished = false;\n      }\n    })();\n  }\n}\n_class = AddonModQuizPrefetchHandlerService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵAddonModQuizPrefetchHandlerService_BaseFactory;\n  return function AddonModQuizPrefetchHandlerService_Factory(t) {\n    return (ɵAddonModQuizPrefetchHandlerService_BaseFactory || (ɵAddonModQuizPrefetchHandlerService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModQuizPrefetchHandler = makeSingleton(AddonModQuizPrefetchHandlerService);","map":{"version":3,"names":["CoreConstants","isSafeNumber","CoreError","CoreCourseActivityPrefetchHandlerBase","CoreCourses","CoreQuestionHelper","CoreFilepool","CoreSites","CoreTextUtils","CoreUtils","makeSingleton","AddonModQuizAccessRuleDelegate","AddonModQuiz","AddonModQuizProvider","AddonModQuizHelper","AddonModQuizSync","AddonModQuizPrefetchHandlerService","constructor","name","modName","component","COMPONENT","updatesNames","download","module","courseId","dirPath","single","canStart","prefetch","getFiles","_this","_asyncToGenerator","quiz","getQuiz","id","files","getIntroFilesFromInstance","attempts","getUserAttempts","cmId","readingStrategy","attemptFiles","getAttemptsFeedbackFiles","concat","_unused","siteId","Promise","all","map","_ref","attempt","_feedback$feedbackinl","isAttemptFinished","state","attemptGrade","rescaleGrade","sumgrades","attemptGradeNumber","undefined","Number","feedback","getFeedbackForGrade","coursemodule","feedbackinlinefiles","length","_x","apply","arguments","getPreflightData","accessInfo","askPreflight","title","preflightData","getAndCheckPreflightData","rules","activerulenames","getFixedPreflightData","startAttempt","invalidateContent","moduleId","invalidateModule","invalidateQuizData","invalidateUserAttemptsForUser","instance","isDownloadable","_CoreSites$getCurrent","_quiz$attempts","getCurrentSite","isOfflineDisabled","getCurrentSiteId","isQuizOffline","hasquestions","isLastFinished","isEnabled","_this2","attemptFinished","prefetchPackage","prefetchQuiz","_this3","commonOptions","modOptions","_objectSpread","introFiles","quizAccessInfo","attemptAccessInfo","getQuizAccessInformation","getAttemptAccessInformation","getQuizRequiredQtypes","addFilesToQueue","preventnewattemptreasons","buildMessage","promises","push","then","_ref2","atts","_x2","ignoreErrors","updatePackageDownloadTime","getCombinedReviewOptions","getUserBestGrade","prefetchGradeAndFeedback","getCourseByField","_ref3","prefetchAttempt","_x3","hasData","hasDataToSync","setSyncTime","_this4","pages","getPagesFromLayout","layout","isSequential","isNavigationSequential","forEach","page","getAttemptReview","prefetchAttemptReviewFiles","getAttemptSummary","ATTEMPT_IN_PROGRESS","_ref4","currentpage","data","getAttemptData","questions","_ref5","question","prefetchQuestionFiles","uniqueid","_x5","_x4","_this5","gradebookData","getGradeFromGradebook","course","graderaw","_unused2","prefetchQuizAndLastAttempt","_this6","lastAttempt","setStatusAfterPrefetch","options","_this7","status","getPackageStatus","NOT_DOWNLOADED","newStatus","DOWNLOADED","storePackageStatus","sync","result","syncQuiz","_unused3","t","factory","ɵfac","providedIn","AddonModQuizPrefetchHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/quiz/services/handlers/prefetch.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreConstants } from '@/core/constants';\nimport { isSafeNumber } from '@/core/utils/types';\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourseAnyModuleData, CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreQuestionHelper } from '@features/question/services/question-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { AddonModQuizAccessRuleDelegate } from '../access-rules-delegate';\nimport {\n    AddonModQuiz,\n    AddonModQuizAttemptWSData,\n    AddonModQuizGetQuizAccessInformationWSResponse,\n    AddonModQuizProvider,\n    AddonModQuizQuizWSData,\n} from '../quiz';\nimport { AddonModQuizHelper } from '../quiz-helper';\nimport { AddonModQuizSync, AddonModQuizSyncResult } from '../quiz-sync';\n\n/**\n * Handler to prefetch quizzes.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModQuizPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n\n    name = 'AddonModQuiz';\n    modName = 'quiz';\n    component = AddonModQuizProvider.COMPONENT;\n    updatesNames = /^configuration$|^.*files$|^grades$|^gradeitems$|^questions$|^attempts$/;\n\n    /**\n     * Download the module.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param canStart If true, start a new attempt if needed.\n     * @returns Promise resolved when all content is downloaded.\n     */\n    download(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        dirPath?: string,\n        single?: boolean,\n        canStart: boolean = true,\n    ): Promise<void> {\n        // Same implementation for download and prefetch.\n        return this.prefetch(module, courseId, single, dirPath, canStart);\n    }\n\n    /**\n     * Get list of files. If not defined, we'll assume they're in module.contents.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @returns Promise resolved with the list of files.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getFiles(module: CoreCourseAnyModuleData, courseId: number, single?: boolean): Promise<CoreWSFile[]> {\n        try {\n            const quiz = await AddonModQuiz.getQuiz(courseId, module.id);\n\n            const files = this.getIntroFilesFromInstance(module, quiz);\n\n            const attempts = await AddonModQuiz.getUserAttempts(quiz.id, {\n                cmId: module.id,\n                readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            });\n\n            const attemptFiles = await this.getAttemptsFeedbackFiles(quiz, attempts);\n\n            return files.concat(attemptFiles);\n        } catch {\n            // Quiz not found, return empty list.\n            return [];\n        }\n    }\n\n    /**\n     * Get the list of downloadable files on feedback attemptss.\n     *\n     * @param quiz Quiz.\n     * @param attempts Quiz user attempts.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns List of Files.\n     */\n    protected async getAttemptsFeedbackFiles(\n        quiz: AddonModQuizQuizWSData,\n        attempts: AddonModQuizAttemptWSData[],\n        siteId?: string,\n    ): Promise<CoreWSFile[]> {\n        let files: CoreWSFile[] = [];\n\n        await Promise.all(attempts.map(async (attempt) => {\n            if (!AddonModQuiz.isAttemptFinished(attempt.state)) {\n                // Attempt not finished, no feedback files.\n                return;\n            }\n\n            const attemptGrade = AddonModQuiz.rescaleGrade(attempt.sumgrades, quiz, false);\n            const attemptGradeNumber = attemptGrade !== undefined && Number(attemptGrade);\n            if (!isSafeNumber(attemptGradeNumber)) {\n                return;\n            }\n\n            const feedback = await AddonModQuiz.getFeedbackForGrade(quiz.id, attemptGradeNumber, {\n                cmId: quiz.coursemodule,\n                readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n                siteId,\n            });\n\n            if (feedback.feedbackinlinefiles?.length) {\n                files = files.concat(feedback.feedbackinlinefiles);\n            }\n        }));\n\n        return files;\n    }\n\n    /**\n     * Gather some preflight data for an attempt. This function will start a new attempt if needed.\n     *\n     * @param quiz Quiz.\n     * @param accessInfo Quiz access info returned by AddonModQuizProvider.getQuizAccessInformation.\n     * @param attempt Attempt to continue. Don't pass any value if the user needs to start a new attempt.\n     * @param askPreflight Whether it should ask for preflight data if needed.\n     * @param title Lang key of the title to set to preflight modal (e.g. 'addon.mod_quiz.startattempt').\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the preflight data.\n     */\n    async getPreflightData(\n        quiz: AddonModQuizQuizWSData,\n        accessInfo: AddonModQuizGetQuizAccessInformationWSResponse,\n        attempt?: AddonModQuizAttemptWSData,\n        askPreflight?: boolean,\n        title?: string,\n        siteId?: string,\n    ): Promise<Record<string, string>> {\n        const preflightData: Record<string, string> = {};\n\n        if (askPreflight) {\n            // We can ask preflight, check if it's needed and get the data.\n            await AddonModQuizHelper.getAndCheckPreflightData(\n                quiz,\n                accessInfo,\n                preflightData,\n                attempt,\n                false,\n                true,\n                title,\n                siteId,\n            );\n        } else {\n            // Get some fixed preflight data from access rules (data that doesn't require user interaction).\n            const rules = accessInfo?.activerulenames || [];\n\n            await AddonModQuizAccessRuleDelegate.getFixedPreflightData(rules, quiz, preflightData, attempt, true, siteId);\n\n            if (!attempt) {\n                // We need to create a new attempt.\n                await AddonModQuiz.startAttempt(quiz.id, preflightData, false, siteId);\n            }\n        }\n\n        return preflightData;\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId The course ID the module belongs to.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        return AddonModQuiz.invalidateContent(moduleId, courseId);\n    }\n\n    /**\n     * Invalidate WS calls needed to determine module status.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when invalidated.\n     */\n    async invalidateModule(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        // Invalidate the calls required to check if a quiz is downloadable.\n        await Promise.all([\n            AddonModQuiz.invalidateQuizData(courseId),\n            AddonModQuiz.invalidateUserAttemptsForUser(module.instance),\n        ]);\n    }\n\n    /**\n     * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Whether the module can be downloaded. The promise should never be rejected.\n     */\n    async isDownloadable(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        if (CoreSites.getCurrentSite()?.isOfflineDisabled()) {\n            // Don't allow downloading the quiz if offline is disabled to prevent wasting a lot of data when opening it.\n            return false;\n        }\n\n        const siteId = CoreSites.getCurrentSiteId();\n\n        const quiz = await AddonModQuiz.getQuiz(courseId, module.id, { siteId });\n\n        if (!AddonModQuiz.isQuizOffline(quiz) || quiz.hasquestions === 0) {\n            return false;\n        }\n\n        // Not downloadable if we reached max attempts or the quiz has an unfinished attempt.\n        const attempts = await AddonModQuiz.getUserAttempts(quiz.id, {\n            cmId: module.id,\n            siteId,\n        });\n\n        const isLastFinished = !attempts.length || AddonModQuiz.isAttemptFinished(attempts[attempts.length - 1].state);\n\n        return quiz.attempts === 0 || (quiz.attempts ?? 0) > attempts.length || !isLastFinished;\n    }\n\n    /**\n     * Whether or not the handler is enabled on a site level.\n     *\n     * @returns A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * Prefetch a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @param canStart If true, start a new attempt if needed.\n     * @returns Promise resolved when done.\n     */\n    async prefetch(\n        module: SyncedModule,\n        courseId: number,\n        single?: boolean,\n        dirPath?: string,\n        canStart: boolean = true,\n    ): Promise<void> {\n        if (module.attemptFinished) {\n            // Delete the value so it does not block anything if true.\n            delete module.attemptFinished;\n\n            // Quiz got synced recently and an attempt has finished. Do not prefetch.\n            return;\n        }\n\n        return this.prefetchPackage(module, courseId, (siteId) => this.prefetchQuiz(module, courseId, !!single, canStart, siteId));\n    }\n\n    /**\n     * Prefetch a quiz.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param canStart If true, start a new attempt if needed.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchQuiz(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        single: boolean,\n        canStart: boolean,\n        siteId: string,\n    ): Promise<void> {\n        const commonOptions = {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n        const modOptions = {\n            cmId: module.id,\n            ...commonOptions, // Include all common options.\n        };\n\n        // Get quiz.\n        const quiz = await AddonModQuiz.getQuiz(courseId, module.id, commonOptions);\n\n        const introFiles = this.getIntroFilesFromInstance(module, quiz);\n\n        // Prefetch some quiz data.\n        // eslint-disable-next-line prefer-const\n        let [quizAccessInfo, attempts, attemptAccessInfo] = await Promise.all([\n            AddonModQuiz.getQuizAccessInformation(quiz.id, modOptions),\n            AddonModQuiz.getUserAttempts(quiz.id, modOptions),\n            AddonModQuiz.getAttemptAccessInformation(quiz.id, 0, modOptions),\n            AddonModQuiz.getQuizRequiredQtypes(quiz.id, modOptions),\n            CoreFilepool.addFilesToQueue(siteId, introFiles, AddonModQuizProvider.COMPONENT, module.id),\n        ]);\n\n        // Check if we need to start a new attempt.\n        let attempt: AddonModQuizAttemptWSData | undefined = attempts[attempts.length - 1];\n        let preflightData: Record<string, string> = {};\n        let startAttempt = false;\n\n        if (canStart || attempt) {\n            if (canStart && (!attempt || AddonModQuiz.isAttemptFinished(attempt.state))) {\n                // Check if the user can attempt the quiz.\n                if (attemptAccessInfo.preventnewattemptreasons.length) {\n                    throw new CoreError(CoreTextUtils.buildMessage(attemptAccessInfo.preventnewattemptreasons));\n                }\n\n                startAttempt = true;\n                attempt = undefined;\n            }\n\n            // Get the preflight data. This function will also start a new attempt if needed.\n            preflightData = await this.getPreflightData(quiz, quizAccessInfo, attempt, single, 'core.download', siteId);\n        }\n\n        const promises: Promise<unknown>[] = [];\n\n        if (startAttempt) {\n            // Re-fetch user attempts since we created a new one.\n            promises.push(AddonModQuiz.getUserAttempts(quiz.id, modOptions).then(async (atts) => {\n                attempts = atts;\n\n                const attemptFiles = await this.getAttemptsFeedbackFiles(quiz, attempts, siteId);\n\n                return CoreFilepool.addFilesToQueue(siteId, attemptFiles, AddonModQuizProvider.COMPONENT, module.id);\n            }));\n\n            // Update the download time to prevent detecting the new attempt as an update.\n            promises.push(CoreUtils.ignoreErrors(\n                CoreFilepool.updatePackageDownloadTime(siteId, AddonModQuizProvider.COMPONENT, module.id),\n            ));\n        } else {\n            // Use the already fetched attempts.\n            promises.push(this.getAttemptsFeedbackFiles(quiz, attempts, siteId).then((attemptFiles) =>\n                CoreFilepool.addFilesToQueue(siteId, attemptFiles, AddonModQuizProvider.COMPONENT, module.id)));\n        }\n\n        // Fetch attempt related data.\n        promises.push(AddonModQuiz.getCombinedReviewOptions(quiz.id, modOptions));\n        promises.push(AddonModQuiz.getUserBestGrade(quiz.id, modOptions));\n        promises.push(this.prefetchGradeAndFeedback(quiz, modOptions, siteId));\n        promises.push(AddonModQuiz.getAttemptAccessInformation(quiz.id, 0, modOptions)); // Last attempt.\n\n        // Get course data, needed to determine upload max size if it's configured to be course limit.\n        promises.push(CoreUtils.ignoreErrors(CoreCourses.getCourseByField('id', courseId, siteId)));\n\n        await Promise.all(promises);\n\n        // We have quiz data, now we'll get specific data for each attempt.\n        await Promise.all(attempts.map(async (attempt) => {\n            await this.prefetchAttempt(quiz, attempt, preflightData, siteId);\n        }));\n\n        if (!canStart) {\n            // Nothing else to do.\n            return;\n        }\n\n        // If there's nothing to send, mark the quiz as synchronized.\n        const hasData = await AddonModQuizSync.hasDataToSync(quiz.id, siteId);\n\n        if (!hasData) {\n            AddonModQuizSync.setSyncTime(quiz.id, siteId);\n        }\n    }\n\n    /**\n     * Prefetch all WS data for an attempt.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param preflightData Preflight required data (like password).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the prefetch is finished. Data returned is not reliable.\n     */\n    async prefetchAttempt(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData,\n        preflightData: Record<string, string>,\n        siteId?: string,\n    ): Promise<void> {\n        const pages = AddonModQuiz.getPagesFromLayout(attempt.layout);\n        const isSequential = AddonModQuiz.isNavigationSequential(quiz);\n        let promises: Promise<unknown>[] = [];\n\n        const modOptions: CoreCourseCommonModWSOptions = {\n            cmId: quiz.coursemodule,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        if (AddonModQuiz.isAttemptFinished(attempt.state)) {\n            // Attempt is finished, get feedback and review data.\n            const attemptGrade = AddonModQuiz.rescaleGrade(attempt.sumgrades, quiz, false);\n            const attemptGradeNumber = attemptGrade !== undefined && Number(attemptGrade);\n            if (isSafeNumber(attemptGradeNumber)) {\n                promises.push(AddonModQuiz.getFeedbackForGrade(quiz.id, attemptGradeNumber, modOptions));\n            }\n\n            // Get the review for each page.\n            pages.forEach((page) => {\n                promises.push(CoreUtils.ignoreErrors(AddonModQuiz.getAttemptReview(attempt.id, {\n                    page,\n                    ...modOptions, // Include all options.\n                })));\n            });\n\n            // Get the review for all questions in same page.\n            promises.push(this.prefetchAttemptReviewFiles(quiz, attempt, modOptions, siteId));\n        } else {\n\n            // Attempt not finished, get data needed to continue the attempt.\n            promises.push(AddonModQuiz.getAttemptAccessInformation(quiz.id, attempt.id, modOptions));\n            promises.push(AddonModQuiz.getAttemptSummary(attempt.id, preflightData, modOptions));\n\n            if (attempt.state == AddonModQuizProvider.ATTEMPT_IN_PROGRESS) {\n                // Get data for each page.\n                promises = promises.concat(pages.map(async (page) => {\n                    if (isSequential && typeof attempt.currentpage === 'number' && page < attempt.currentpage) {\n                        // Sequential quiz, cannot get pages before the current one.\n                        return;\n                    }\n\n                    const data = await AddonModQuiz.getAttemptData(attempt.id, page, preflightData, modOptions);\n\n                    // Download the files inside the questions.\n                    await Promise.all(data.questions.map(async (question) => {\n                        await CoreQuestionHelper.prefetchQuestionFiles(\n                            question,\n                            this.component,\n                            quiz.coursemodule,\n                            siteId,\n                            attempt.uniqueid,\n                        );\n                    }));\n\n                }));\n            }\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Prefetch attempt review and its files.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param modOptions Other options.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchAttemptReviewFiles(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData,\n        modOptions: CoreCourseCommonModWSOptions,\n        siteId?: string,\n    ): Promise<void> {\n        // Get the review for all questions in same page.\n        const data = await CoreUtils.ignoreErrors(AddonModQuiz.getAttemptReview(attempt.id, {\n            page: -1,\n            ...modOptions, // Include all options.\n        }));\n\n        if (!data) {\n            return;\n        }\n        // Download the files inside the questions.\n        await Promise.all(data.questions.map((question) => {\n            CoreQuestionHelper.prefetchQuestionFiles(\n                question,\n                this.component,\n                quiz.coursemodule,\n                siteId,\n                attempt.uniqueid,\n            );\n        }));\n    }\n\n    /**\n     * Prefetch quiz grade and its feedback.\n     *\n     * @param quiz Quiz.\n     * @param modOptions Other options.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchGradeAndFeedback(\n        quiz: AddonModQuizQuizWSData,\n        modOptions: CoreCourseCommonModWSOptions,\n        siteId?: string,\n    ): Promise<void> {\n        try {\n            const gradebookData = await AddonModQuiz.getGradeFromGradebook(quiz.course, quiz.coursemodule, true, siteId);\n\n            if (gradebookData && gradebookData.graderaw !== undefined) {\n                await AddonModQuiz.getFeedbackForGrade(quiz.id, gradebookData.graderaw, modOptions);\n            }\n        } catch {\n            // Ignore errors.\n        }\n    }\n\n    /**\n     * Prefetches some data for a quiz and its last attempt.\n     * This function will NOT start a new attempt, it only reads data for the quiz and the last attempt.\n     *\n     * @param quiz Quiz.\n     * @param askPreflight Whether it should ask for preflight data if needed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async prefetchQuizAndLastAttempt(quiz: AddonModQuizQuizWSData, askPreflight?: boolean, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const modOptions = {\n            cmId: quiz.coursemodule,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        // Get quiz data.\n        const [quizAccessInfo, attempts] = await Promise.all([\n            AddonModQuiz.getQuizAccessInformation(quiz.id, modOptions),\n            AddonModQuiz.getUserAttempts(quiz.id, modOptions),\n            AddonModQuiz.getQuizRequiredQtypes(quiz.id, modOptions),\n            AddonModQuiz.getCombinedReviewOptions(quiz.id, modOptions),\n            AddonModQuiz.getUserBestGrade(quiz.id, modOptions),\n            this.prefetchGradeAndFeedback(quiz, modOptions, siteId),\n            AddonModQuiz.getAttemptAccessInformation(quiz.id, 0, modOptions), // Last attempt.\n        ]);\n\n        const lastAttempt = attempts[attempts.length - 1];\n        let preflightData: Record<string, string> = {};\n        if (lastAttempt) {\n            // Get the preflight data.\n            preflightData = await this.getPreflightData(quiz, quizAccessInfo, lastAttempt, askPreflight, 'core.download', siteId);\n\n            // Get data for last attempt.\n            await this.prefetchAttempt(quiz, lastAttempt, preflightData, siteId);\n        }\n\n        // Prefetch finished, set the right status.\n        await this.setStatusAfterPrefetch(quiz, {\n            cmId: quiz.coursemodule,\n            attempts,\n            readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n            siteId,\n        });\n    }\n\n    /**\n     * Set the right status to a quiz after prefetching.\n     * If the last attempt is finished or there isn't one, set it as not downloaded to show download icon.\n     *\n     * @param quiz Quiz.\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    async setStatusAfterPrefetch(\n        quiz: AddonModQuizQuizWSData,\n        options: AddonModQuizSetStatusAfterPrefetchOptions = {},\n    ): Promise<void> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        let attempts = options.attempts;\n\n        if (!attempts) {\n            // Get the attempts.\n            attempts = await AddonModQuiz.getUserAttempts(quiz.id, options);\n        }\n\n        // Check the current status of the quiz.\n        const status = await CoreFilepool.getPackageStatus(options.siteId, this.component, quiz.coursemodule);\n\n        if (status === CoreConstants.NOT_DOWNLOADED) {\n            return;\n        }\n\n        // Quiz was downloaded, set the new status.\n        // If no attempts or last is finished we'll mark it as not downloaded to show download icon.\n        const lastAttempt = attempts[attempts.length - 1];\n        const isLastFinished = !lastAttempt || AddonModQuiz.isAttemptFinished(lastAttempt.state);\n        const newStatus = isLastFinished ? CoreConstants.NOT_DOWNLOADED : CoreConstants.DOWNLOADED;\n\n        await CoreFilepool.storePackageStatus(options.siteId, newStatus, this.component, quiz.coursemodule);\n    }\n\n    /**\n     * Sync a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async sync(module: SyncedModule, courseId: number, siteId?: string): Promise<AddonModQuizSyncResult | undefined> {\n        const quiz = await AddonModQuiz.getQuiz(courseId, module.id, { siteId });\n\n        try {\n            const result = await AddonModQuizSync.syncQuiz(quiz, false, siteId);\n\n            module.attemptFinished = result.attemptFinished || false;\n\n            return result;\n        } catch {\n            // Ignore errors.\n            module.attemptFinished = false;\n        }\n    }\n\n}\n\nexport const AddonModQuizPrefetchHandler = makeSingleton(AddonModQuizPrefetchHandlerService);\n\n/**\n * Options to pass to setStatusAfterPrefetch.\n */\nexport type AddonModQuizSetStatusAfterPrefetchOptions = CoreCourseCommonModWSOptions & {\n    attempts?: AddonModQuizAttemptWSData[]; // List of attempts. If not provided, they will be calculated.\n};\n\n/**\n * Module data with some calculated data.\n */\ntype SyncedModule = CoreCourseAnyModuleData & {\n    attemptFinished?: boolean;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}