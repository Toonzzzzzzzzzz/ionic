{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { Md5 } from 'ts-md5/dist/md5';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreApp } from '@services/app';\nimport { CoreFile } from '@services/file';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreSites } from '@services/sites';\nimport { CoreEvents } from '@singletons/events';\nimport { makeSingleton } from '@singletons';\nimport { APP_SCHEMA, SHARED_FILES_TABLE_NAME } from './database/sharedfiles';\nimport { CorePath } from '@singletons/path';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to share files with the app.\n */\nexport class CoreSharedFilesProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('CoreSharedFilesProvider');\n    this.appDB = new Promise(resolve => this.resolveAppDB = resolve);\n  }\n  /**\n   * Initialize database.\n   *\n   * @returns Promise resolved when done.\n   */\n  initializeDatabase() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield CoreApp.createTablesFromSchema(APP_SCHEMA);\n      } catch (e) {\n        // Ignore errors.\n      }\n      _this.resolveAppDB(CoreApp.getDB());\n    })();\n  }\n  /**\n   * Checks if there is a new file received in iOS. If more than one file is found, treat only the first one.\n   * The file returned is marked as \"treated\" and will be deleted in the next execution.\n   *\n   * @returns Promise resolved with a new file to be treated. If no new files found, resolved with undefined.\n   */\n  checkIOSNewFiles() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.logger.debug('Search for new files on iOS');\n      const entries = yield CoreUtils.ignoreErrors(CoreFile.getDirectoryContents('Inbox'));\n      if (!entries || !entries.length) {\n        return;\n      }\n      let fileToReturn;\n      for (let i = 0; i < entries.length; i++) {\n        if (entries[i].isDirectory) {\n          continue;\n        }\n        const fileEntry = entries[i];\n        const fileId = _this2.getFileId(fileEntry);\n        try {\n          // Check if file was already treated.\n          yield _this2.isFileTreated(fileId);\n          // File already treated, delete it. No need to block the execution for this.\n          _this2.deleteInboxFile(fileEntry);\n        } catch (_unused) {\n          // File not treated before.\n          _this2.logger.debug(`Found new file ${fileEntry.name} shared with the app.`);\n          fileToReturn = fileEntry;\n          break;\n        }\n      }\n      if (!fileToReturn) {\n        return;\n      }\n      // Mark it as \"treated\".\n      const fileId = _this2.getFileId(fileToReturn);\n      yield _this2.markAsTreated(fileId);\n      _this2.logger.debug(`File marked as \"treated\": ${fileToReturn.name}`);\n      return fileToReturn;\n    })();\n  }\n  /**\n   * Deletes a file in the Inbox folder (shared with the app).\n   *\n   * @param entry FileEntry.\n   * @returns Promise resolved when done, rejected otherwise.\n   */\n  deleteInboxFile(entry) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.logger.debug('Delete inbox file: ' + entry.name);\n      yield CoreUtils.ignoreErrors(CoreFile.removeFileByFileEntry(entry));\n      try {\n        yield _this3.unmarkAsTreated(_this3.getFileId(entry));\n        _this3.logger.debug(`\"Treated\" mark removed from file: ${entry.name}`);\n      } catch (error) {\n        _this3.logger.debug(`Error deleting \"treated\" mark from file: ${entry.name}`, error);\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Get the ID of a file for managing \"treated\" files.\n   *\n   * @param entry FileEntry.\n   * @returns File ID.\n   */\n  getFileId(entry) {\n    return Md5.hashAsciiStr(entry.name);\n  }\n  /**\n   * Get the shared files stored in a site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @param path Path to search inside the site shared folder.\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @returns Promise resolved with the files.\n   */\n  getSiteSharedFiles(siteId, path, mimetypes) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let pathToGet = _this4.getSiteSharedFilesDirPath(siteId);\n      if (path) {\n        pathToGet = CorePath.concatenatePaths(pathToGet, path);\n      }\n      try {\n        let entries = yield CoreFile.getDirectoryContents(pathToGet);\n        if (mimetypes) {\n          // Get only files with the right mimetype and the ones we cannot determine the mimetype.\n          entries = entries.filter(entry => {\n            const extension = CoreMimetypeUtils.getFileExtension(entry.name);\n            const mimetype = CoreMimetypeUtils.getMimeType(extension);\n            return !mimetype || mimetypes.indexOf(mimetype) > -1;\n          });\n        }\n        return entries;\n      } catch (_unused2) {\n        // Directory not found, return empty list.\n        return [];\n      }\n    })();\n  }\n  /**\n   * Get the path to a site's shared files folder.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Path.\n   */\n  getSiteSharedFilesDirPath(siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    return CoreFile.getSiteFolder(siteId) + '/' + CoreSharedFilesProvider.SHARED_FILES_FOLDER;\n  }\n  /**\n   * Check if a file has been treated already.\n   *\n   * @param fileId File ID.\n   * @returns Resolved if treated, rejected otherwise.\n   */\n  isFileTreated(fileId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield _this5.appDB;\n      return db.getRecord(SHARED_FILES_TABLE_NAME, {\n        id: fileId\n      });\n    })();\n  }\n  /**\n   * Mark a file as treated.\n   *\n   * @param fileId File ID.\n   * @returns Promise resolved when marked.\n   */\n  markAsTreated(fileId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // Check if it's already marked.\n        yield _this6.isFileTreated(fileId);\n      } catch (err) {\n        // Doesn't exist, insert it.\n        const db = yield _this6.appDB;\n        yield db.insertRecord(SHARED_FILES_TABLE_NAME, {\n          id: fileId\n        });\n      }\n    })();\n  }\n  /**\n   * Store a file in a site's shared folder.\n   *\n   * @param entry File entry.\n   * @param newName Name of the new file. If not defined, use original file's name.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  storeFileInSite(entry, newName, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!entry || !siteId) {\n        return;\n      }\n      newName = newName || entry.name;\n      const sharedFilesFolder = _this7.getSiteSharedFilesDirPath(siteId);\n      const newPath = CorePath.concatenatePaths(sharedFilesFolder, newName);\n      // Create dir if it doesn't exist already.\n      yield CoreFile.createDir(sharedFilesFolder);\n      const newFile = yield CoreFile.moveExternalFile(entry.toURL(), newPath);\n      CoreEvents.trigger(CoreEvents.FILE_SHARED, {\n        siteId,\n        name: newName\n      });\n      return newFile;\n    })();\n  }\n  /**\n   * Unmark a file as treated.\n   *\n   * @param fileId File ID.\n   * @returns Resolved when unmarked.\n   */\n  unmarkAsTreated(fileId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield _this8.appDB;\n      yield db.deleteRecords(SHARED_FILES_TABLE_NAME, {\n        id: fileId\n      });\n    })();\n  }\n}\n_class = CoreSharedFilesProvider;\n_class.SHARED_FILES_FOLDER = 'sharedfiles';\n_class.ɵfac = function CoreSharedFilesProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreSharedFiles = makeSingleton(CoreSharedFilesProvider);","map":{"version":3,"names":["Md5","CoreLogger","CoreApp","CoreFile","CoreUtils","CoreMimetypeUtils","CoreSites","CoreEvents","makeSingleton","APP_SCHEMA","SHARED_FILES_TABLE_NAME","CorePath","CoreSharedFilesProvider","constructor","logger","getInstance","appDB","Promise","resolve","resolveAppDB","initializeDatabase","_this","_asyncToGenerator","createTablesFromSchema","e","getDB","checkIOSNewFiles","_this2","debug","entries","ignoreErrors","getDirectoryContents","length","fileToReturn","i","isDirectory","fileEntry","fileId","getFileId","isFileTreated","deleteInboxFile","_unused","name","markAsTreated","entry","_this3","removeFileByFileEntry","unmarkAsTreated","error","hashAsciiStr","getSiteSharedFiles","siteId","path","mimetypes","_this4","pathToGet","getSiteSharedFilesDirPath","concatenatePaths","filter","extension","getFileExtension","mimetype","getMimeType","indexOf","_unused2","getCurrentSiteId","getSiteFolder","SHARED_FILES_FOLDER","_this5","db","getRecord","id","_this6","err","insertRecord","storeFileInSite","newName","_this7","sharedFilesFolder","newPath","createDir","newFile","moveExternalFile","toURL","trigger","FILE_SHARED","_this8","deleteRecords","_class","factory","ɵfac","providedIn","CoreSharedFiles"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/sharedfiles/services/sharedfiles.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { FileEntry, DirectoryEntry } from '@awesome-cordova-plugins/file/ngx';\nimport { Md5 } from 'ts-md5/dist/md5';\n\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreApp } from '@services/app';\nimport { CoreFile } from '@services/file';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreSites } from '@services/sites';\nimport { CoreEvents } from '@singletons/events';\nimport { makeSingleton } from '@singletons';\nimport { APP_SCHEMA, CoreSharedFilesDBRecord, SHARED_FILES_TABLE_NAME } from './database/sharedfiles';\nimport { CorePath } from '@singletons/path';\n\n/**\n * Service to share files with the app.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreSharedFilesProvider {\n\n    static readonly SHARED_FILES_FOLDER = 'sharedfiles';\n\n    protected logger: CoreLogger;\n    // Variables for DB.\n    protected appDB: Promise<SQLiteDB>;\n    protected resolveAppDB!: (appDB: SQLiteDB) => void;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreSharedFilesProvider');\n        this.appDB = new Promise(resolve => this.resolveAppDB = resolve);\n    }\n\n    /**\n     * Initialize database.\n     *\n     * @returns Promise resolved when done.\n     */\n    async initializeDatabase(): Promise<void> {\n        try {\n            await CoreApp.createTablesFromSchema(APP_SCHEMA);\n        } catch (e) {\n            // Ignore errors.\n        }\n\n        this.resolveAppDB(CoreApp.getDB());\n    }\n\n    /**\n     * Checks if there is a new file received in iOS. If more than one file is found, treat only the first one.\n     * The file returned is marked as \"treated\" and will be deleted in the next execution.\n     *\n     * @returns Promise resolved with a new file to be treated. If no new files found, resolved with undefined.\n     */\n    async checkIOSNewFiles(): Promise<FileEntry | undefined> {\n        this.logger.debug('Search for new files on iOS');\n\n        const entries = await CoreUtils.ignoreErrors(CoreFile.getDirectoryContents('Inbox'));\n\n        if (!entries || !entries.length) {\n            return;\n        }\n\n        let fileToReturn: FileEntry | undefined;\n\n        for (let i = 0; i < entries.length; i++) {\n            if (entries[i].isDirectory) {\n                continue;\n            }\n\n            const fileEntry = <FileEntry> entries[i];\n            const fileId = this.getFileId(fileEntry);\n\n            try {\n                // Check if file was already treated.\n                await this.isFileTreated(fileId);\n\n                // File already treated, delete it. No need to block the execution for this.\n                this.deleteInboxFile(fileEntry);\n            } catch {\n                // File not treated before.\n                this.logger.debug(`Found new file ${fileEntry.name} shared with the app.`);\n                fileToReturn = fileEntry;\n                break;\n            }\n        }\n\n        if (!fileToReturn) {\n            return;\n        }\n\n        // Mark it as \"treated\".\n        const fileId = this.getFileId(fileToReturn);\n\n        await this.markAsTreated(fileId);\n\n        this.logger.debug(`File marked as \"treated\": ${fileToReturn.name}`);\n\n        return fileToReturn;\n    }\n\n    /**\n     * Deletes a file in the Inbox folder (shared with the app).\n     *\n     * @param entry FileEntry.\n     * @returns Promise resolved when done, rejected otherwise.\n     */\n    async deleteInboxFile(entry: FileEntry): Promise<void> {\n        this.logger.debug('Delete inbox file: ' + entry.name);\n\n        await CoreUtils.ignoreErrors(CoreFile.removeFileByFileEntry(entry));\n\n        try {\n            await this.unmarkAsTreated(this.getFileId(entry));\n\n            this.logger.debug(`\"Treated\" mark removed from file: ${entry.name}`);\n        } catch (error) {\n            this.logger.debug(`Error deleting \"treated\" mark from file: ${entry.name}`, error);\n\n            throw error;\n        }\n    }\n\n    /**\n     * Get the ID of a file for managing \"treated\" files.\n     *\n     * @param entry FileEntry.\n     * @returns File ID.\n     */\n    protected getFileId(entry: FileEntry): string {\n        return <string> Md5.hashAsciiStr(entry.name);\n    }\n\n    /**\n     * Get the shared files stored in a site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @param path Path to search inside the site shared folder.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns Promise resolved with the files.\n     */\n    async getSiteSharedFiles(siteId?: string, path?: string, mimetypes?: string[]): Promise<(FileEntry | DirectoryEntry)[]> {\n        let pathToGet = this.getSiteSharedFilesDirPath(siteId);\n        if (path) {\n            pathToGet = CorePath.concatenatePaths(pathToGet, path);\n        }\n\n        try {\n            let entries = await CoreFile.getDirectoryContents(pathToGet);\n\n            if (mimetypes) {\n                // Get only files with the right mimetype and the ones we cannot determine the mimetype.\n                entries = entries.filter((entry) => {\n                    const extension = CoreMimetypeUtils.getFileExtension(entry.name);\n                    const mimetype = CoreMimetypeUtils.getMimeType(extension);\n\n                    return !mimetype || mimetypes.indexOf(mimetype) > -1;\n                });\n            }\n\n            return entries;\n        } catch {\n            // Directory not found, return empty list.\n            return [];\n        }\n    }\n\n    /**\n     * Get the path to a site's shared files folder.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Path.\n     */\n    getSiteSharedFilesDirPath(siteId?: string): string {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        return CoreFile.getSiteFolder(siteId) + '/' + CoreSharedFilesProvider.SHARED_FILES_FOLDER;\n    }\n\n    /**\n     * Check if a file has been treated already.\n     *\n     * @param fileId File ID.\n     * @returns Resolved if treated, rejected otherwise.\n     */\n    protected async isFileTreated(fileId: string): Promise<CoreSharedFilesDBRecord> {\n        const db = await this.appDB;\n\n        return db.getRecord(SHARED_FILES_TABLE_NAME, { id: fileId });\n    }\n\n    /**\n     * Mark a file as treated.\n     *\n     * @param fileId File ID.\n     * @returns Promise resolved when marked.\n     */\n    protected async markAsTreated(fileId: string): Promise<void> {\n        try {\n            // Check if it's already marked.\n            await this.isFileTreated(fileId);\n        } catch (err) {\n            // Doesn't exist, insert it.\n            const db = await this.appDB;\n\n            await db.insertRecord(SHARED_FILES_TABLE_NAME, { id: fileId });\n        }\n    }\n\n    /**\n     * Store a file in a site's shared folder.\n     *\n     * @param entry File entry.\n     * @param newName Name of the new file. If not defined, use original file's name.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async storeFileInSite(entry: FileEntry, newName?: string, siteId?: string): Promise<FileEntry | undefined> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!entry || !siteId) {\n            return;\n        }\n\n        newName = newName || entry.name;\n\n        const sharedFilesFolder = this.getSiteSharedFilesDirPath(siteId);\n        const newPath = CorePath.concatenatePaths(sharedFilesFolder, newName);\n\n        // Create dir if it doesn't exist already.\n        await CoreFile.createDir(sharedFilesFolder);\n\n        const newFile = await CoreFile.moveExternalFile(entry.toURL(), newPath);\n\n        CoreEvents.trigger(CoreEvents.FILE_SHARED, { siteId, name: newName });\n\n        return newFile;\n    }\n\n    /**\n     * Unmark a file as treated.\n     *\n     * @param fileId File ID.\n     * @returns Resolved when unmarked.\n     */\n    protected async unmarkAsTreated(fileId: string): Promise<void> {\n        const db = await this.appDB;\n\n        await db.deleteRecords(SHARED_FILES_TABLE_NAME, { id: fileId });\n    }\n\n}\n\nexport const CoreSharedFiles = makeSingleton(CoreSharedFilesProvider);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}