{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModDataFieldsDelegate } from './data-fields-delegate';\nimport { AddonModDataOffline } from './data-offline';\nimport { AddonModDataSyncProvider } from './data-sync';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModData:';\nexport var AddonModDataAction;\n(function (AddonModDataAction) {\n  AddonModDataAction[\"ADD\"] = \"add\";\n  AddonModDataAction[\"EDIT\"] = \"edit\";\n  AddonModDataAction[\"DELETE\"] = \"delete\";\n  AddonModDataAction[\"APPROVE\"] = \"approve\";\n  AddonModDataAction[\"DISAPPROVE\"] = \"disapprove\";\n  AddonModDataAction[\"USER\"] = \"user\";\n  AddonModDataAction[\"USERPICTURE\"] = \"userpicture\";\n  AddonModDataAction[\"MORE\"] = \"more\";\n  AddonModDataAction[\"MOREURL\"] = \"moreurl\";\n  AddonModDataAction[\"COMMENTS\"] = \"comments\";\n  AddonModDataAction[\"TIMEADDED\"] = \"timeadded\";\n  AddonModDataAction[\"TIMEMODIFIED\"] = \"timemodified\";\n  AddonModDataAction[\"TAGS\"] = \"tags\";\n  AddonModDataAction[\"APPROVALSTATUS\"] = \"approvalstatus\";\n  AddonModDataAction[\"DELCHECK\"] = \"delcheck\";\n  AddonModDataAction[\"EXPORT\"] = \"export\";\n  AddonModDataAction[\"ACTIONSMENU\"] = \"actionsmenu\";\n})(AddonModDataAction || (AddonModDataAction = {}));\nexport var AddonModDataTemplateType;\n(function (AddonModDataTemplateType) {\n  AddonModDataTemplateType[\"LIST_HEADER\"] = \"listtemplateheader\";\n  AddonModDataTemplateType[\"LIST\"] = \"listtemplate\";\n  AddonModDataTemplateType[\"LIST_FOOTER\"] = \"listtemplatefooter\";\n  AddonModDataTemplateType[\"ADD\"] = \"addtemplate\";\n  AddonModDataTemplateType[\"SEARCH\"] = \"asearchtemplate\";\n  AddonModDataTemplateType[\"SINGLE\"] = \"singletemplate\";\n})(AddonModDataTemplateType || (AddonModDataTemplateType = {}));\nexport var AddonModDataTemplateMode;\n(function (AddonModDataTemplateMode) {\n  AddonModDataTemplateMode[\"LIST\"] = \"list\";\n  AddonModDataTemplateMode[\"EDIT\"] = \"edit\";\n  AddonModDataTemplateMode[\"SHOW\"] = \"show\";\n  AddonModDataTemplateMode[\"SEARCH\"] = \"search\";\n})(AddonModDataTemplateMode || (AddonModDataTemplateMode = {}));\n/**\n * Service that provides some features for databases.\n */\nexport class AddonModDataProvider {\n  /**\n   * Adds a new entry to a database.\n   *\n   * @param dataId Data instance ID.\n   * @param entryId EntryId or provisional entry ID when offline.\n   * @param courseId Course ID.\n   * @param contents The fields data to be created.\n   * @param groupId Group id, 0 means that the function will determine the user group.\n   * @param fields The fields that define the contents.\n   * @param siteId Site ID. If not defined, current site.\n   * @param forceOffline Force editing entry in offline.\n   * @returns Promise resolved when the action is done.\n   */\n  addEntry(dataId, entryId, courseId, contents, groupId = 0, fields, siteId, forceOffline = false) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a data to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          const entry = yield AddonModDataOffline.saveEntry(dataId, entryId, AddonModDataAction.ADD, courseId, groupId, contents, undefined, siteId);\n          return {\n            // Return provissional entry Id.\n            newentryid: entry.entryid,\n            sent: false\n          };\n        });\n        return function storeOffline() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      // Checks to store offline.\n      if (!CoreNetwork.isOnline() || forceOffline) {\n        const notifications = _this.checkFields(fields, contents);\n        if (notifications.length > 0) {\n          return {\n            fieldnotifications: notifications\n          };\n        }\n      }\n      // Remove unnecessary not synced actions.\n      yield _this.deleteEntryOfflineAction(dataId, entryId, AddonModDataAction.ADD, siteId);\n      // App is offline, store the action.\n      if (!CoreNetwork.isOnline() || forceOffline) {\n        return storeOffline();\n      }\n      try {\n        const result = yield _this.addEntryOnline(dataId, contents, groupId, siteId);\n        result.sent = true;\n        return result;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that responses cannot be submitted.\n          throw error;\n        }\n        // Couldn't connect to server, store in offline.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Adds a new entry to a database. It does not cache calls. It will fail if offline or cannot connect.\n   *\n   * @param dataId Database ID.\n   * @param data The fields data to be created.\n   * @param groupId Group id, 0 means that the function will determine the user group.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the action is done.\n   */\n  addEntryOnline(dataId, data, groupId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        databaseid: dataId,\n        data\n      };\n      if (groupId !== undefined) {\n        params.groupid = groupId;\n      }\n      return site.write('mod_data_add_entry', params);\n    })();\n  }\n  /**\n   * Approves or unapproves an entry.\n   *\n   * @param dataId Database ID.\n   * @param entryId Entry ID.\n   * @param approve Whether to approve (true) or unapprove the entry.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the action is done.\n   */\n  approveEntry(dataId, entryId, approve, courseId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a data to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          const action = approve ? AddonModDataAction.APPROVE : AddonModDataAction.DISAPPROVE;\n          yield AddonModDataOffline.saveEntry(dataId, entryId, action, courseId, undefined, undefined, undefined, siteId);\n          return {\n            sent: false\n          };\n        });\n        return function storeOffline() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      // Get if the opposite action is not synced.\n      const oppositeAction = approve ? AddonModDataAction.DISAPPROVE : AddonModDataAction.APPROVE;\n      const found = yield _this2.deleteEntryOfflineAction(dataId, entryId, oppositeAction, siteId);\n      if (found) {\n        // Offline action has been found and deleted. Stop here.\n        return;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        yield _this2.approveEntryOnline(entryId, approve, siteId);\n        return {\n          sent: true\n        };\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that responses cannot be submitted.\n          throw error;\n        }\n        // Couldn't connect to server, store in offline.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Approves or unapproves an entry. It does not cache calls. It will fail if offline or cannot connect.\n   *\n   * @param entryId Entry ID.\n   * @param approve Whether to approve (true) or unapprove the entry.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the action is done.\n   */\n  approveEntryOnline(entryId, approve, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        entryid: entryId,\n        approve\n      };\n      yield site.write('mod_data_approve_entry', params);\n    })();\n  }\n  /**\n   * Convenience function to check fields requeriments here named \"notifications\".\n   *\n   * @param fields The fields that define the contents.\n   * @param contents The contents data of the fields.\n   * @returns Array of notifications if any or false.\n   */\n  checkFields(fields, contents) {\n    const notifications = [];\n    const contentsIndexed = CoreUtils.arrayToObjectMultiple(contents, 'fieldid');\n    // App is offline, check required fields.\n    fields.forEach(field => {\n      const notification = AddonModDataFieldsDelegate.getFieldsNotifications(field, contentsIndexed[field.id]);\n      if (notification) {\n        notifications.push({\n          fieldname: field.name,\n          notification\n        });\n      }\n    });\n    return notifications;\n  }\n  /**\n   * Deletes an entry.\n   *\n   * @param dataId Database ID.\n   * @param entryId Entry ID.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the action is done.\n   */\n  deleteEntry(dataId, entryId, courseId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a data to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* () {\n          yield AddonModDataOffline.saveEntry(dataId, entryId, AddonModDataAction.DELETE, courseId, undefined, undefined, undefined, siteId);\n        });\n        return function storeOffline() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      // Check if the opposite action is not synced and just delete it.\n      const addedOffline = yield _this3.deleteEntryOfflineAction(dataId, entryId, AddonModDataAction.ADD, siteId);\n      if (addedOffline) {\n        // Offline add action found and deleted. Stop here.\n        return;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        yield _this3.deleteEntryOnline(entryId, siteId);\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that responses cannot be submitted.\n          throw error;\n        }\n        // Couldn't connect to server, store in offline.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Deletes an entry. It does not cache calls. It will fail if offline or cannot connect.\n   *\n   * @param entryId Entry ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the action is done.\n   */\n  deleteEntryOnline(entryId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        entryid: entryId\n      };\n      yield site.write('mod_data_delete_entry', params);\n    })();\n  }\n  /**\n   * Delete entry offline action.\n   *\n   * @param dataId Database ID.\n   * @param entryId Entry ID.\n   * @param action Action name to delete.\n   * @param siteId Site ID.\n   * @returns Resolved with true if the action has been found and deleted.\n   */\n  deleteEntryOfflineAction(dataId, entryId, action, siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        // Get other not not synced actions.\n        yield AddonModDataOffline.getEntry(dataId, entryId, action, siteId);\n        yield AddonModDataOffline.deleteEntry(dataId, entryId, action, siteId);\n        return true;\n      } catch (_unused) {\n        // Not found.\n        return false;\n      }\n    })();\n  }\n  /**\n   * Updates an existing entry.\n   *\n   * @param dataId Database ID.\n   * @param entryId Entry ID.\n   * @param courseId Course ID.\n   * @param contents The contents data to be updated.\n   * @param fields The fields that define the contents.\n   * @param siteId Site ID. If not defined, current site.\n   * @param forceOffline Force editing entry in offline.\n   * @returns Promise resolved when the action is done.\n   */\n  editEntry(dataId, entryId, courseId, contents, fields, siteId, forceOffline = false) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a data to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* () {\n          yield AddonModDataOffline.saveEntry(dataId, entryId, AddonModDataAction.EDIT, courseId, undefined, contents, undefined, siteId);\n          return {\n            updated: true,\n            sent: false\n          };\n        });\n        return function storeOffline() {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline() || forceOffline) {\n        const notifications = _this4.checkFields(fields, contents);\n        if (notifications.length > 0) {\n          return {\n            fieldnotifications: notifications\n          };\n        }\n      }\n      // Remove unnecessary not synced actions.\n      yield _this4.deleteEntryOfflineAction(dataId, entryId, AddonModDataAction.EDIT, siteId);\n      if (!CoreNetwork.isOnline() || forceOffline) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        const result = yield _this4.editEntryOnline(entryId, contents, siteId);\n        result.sent = true;\n        return result;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that responses cannot be submitted.\n          throw error;\n        }\n        // Couldn't connect to server, store in offline.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Updates an existing entry. It does not cache calls. It will fail if offline or cannot connect.\n   *\n   * @param entryId Entry ID.\n   * @param data The fields data to be updated.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the action is done.\n   */\n  editEntryOnline(entryId, data, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        entryid: entryId,\n        data\n      };\n      return site.write('mod_data_update_entry', params);\n    })();\n  }\n  /**\n   * Performs the whole fetch of the entries in the database.\n   *\n   * @param dataId Data ID.\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  fetchAllEntries(dataId, options = {}) {\n    options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n    options = Object.assign({\n      page: 0,\n      perPage: AddonModDataProvider.PER_PAGE\n    }, options);\n    return this.fetchEntriesRecursive(dataId, [], options);\n  }\n  /**\n   * Recursive call on fetch all entries.\n   *\n   * @param dataId Data ID.\n   * @param entries Entries already fetch (just to concatenate them).\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  fetchEntriesRecursive(dataId, entries, options) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this5.getEntries(dataId, options);\n      entries = entries.concat(result.entries);\n      const canLoadMore = options.perPage > 0 && (options.page + 1) * options.perPage < result.totalcount;\n      if (canLoadMore) {\n        options.page++;\n        return _this5.fetchEntriesRecursive(dataId, entries, options);\n      }\n      return entries;\n    })();\n  }\n  /**\n   * Get cache key for data data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getDatabaseDataCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'data:' + courseId;\n  }\n  /**\n   * Get prefix cache key for all database activity data WS calls.\n   *\n   * @param dataId Data ID.\n   * @returns Cache key.\n   */\n  getDatabaseDataPrefixCacheKey(dataId) {\n    return ROOT_CACHE_KEY + dataId;\n  }\n  /**\n   * Get a database data. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the data is retrieved.\n   */\n  getDatabaseByKey(courseId, key, value, options = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this6.getDatabaseDataCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModDataProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_data_get_databases_by_courses', params, preSets);\n      const currentData = response.databases.find(data => data[key] == value);\n      if (currentData) {\n        return currentData;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get a data by course module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the data is retrieved.\n   */\n  getDatabase(courseId, cmId, options = {}) {\n    return this.getDatabaseByKey(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a data by ID.\n   *\n   * @param courseId Course ID.\n   * @param id Data ID.\n   * @param options Other options.\n   * @returns Promise resolved when the data is retrieved.\n   */\n  getDatabaseById(courseId, id, options = {}) {\n    return this.getDatabaseByKey(courseId, 'id', id, options);\n  }\n  /**\n   * Get prefix cache key for all database access information data WS calls.\n   *\n   * @param dataId Data ID.\n   * @returns Cache key.\n   */\n  getDatabaseAccessInformationDataPrefixCacheKey(dataId) {\n    return this.getDatabaseDataPrefixCacheKey(dataId) + ':access:';\n  }\n  /**\n   * Get cache key for database access information data WS calls.\n   *\n   * @param dataId Data ID.\n   * @param groupId Group ID.\n   * @returns Cache key.\n   */\n  getDatabaseAccessInformationDataCacheKey(dataId, groupId = 0) {\n    return this.getDatabaseAccessInformationDataPrefixCacheKey(dataId) + groupId;\n  }\n  /**\n   * Get access information for a given database.\n   *\n   * @param dataId Data ID.\n   * @param options Other options.\n   * @returns Promise resolved when the database is retrieved.\n   */\n  getDatabaseAccessInformation(dataId, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      options.groupId = options.groupId || 0;\n      const params = {\n        databaseid: dataId,\n        groupid: options.groupId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this7.getDatabaseAccessInformationDataCacheKey(dataId, options.groupId),\n        component: AddonModDataProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_data_get_data_access_information', params, preSets);\n    })();\n  }\n  /**\n   * Get entries for a specific database and group.\n   *\n   * @param dataId Data ID.\n   * @param options Other options.\n   * @returns Promise resolved when the database is retrieved.\n   */\n  getEntries(dataId, options = {}) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      options = Object.assign({\n        groupId: 0,\n        sort: 0,\n        order: 'DESC',\n        page: 0,\n        perPage: AddonModDataProvider.PER_PAGE\n      }, options);\n      const site = yield CoreSites.getSite(options.siteId);\n      // Always use sort and order params to improve cache usage (entries are identified by params).\n      const params = {\n        databaseid: dataId,\n        returncontents: true,\n        page: options.page,\n        perpage: options.perPage,\n        groupid: options.groupId,\n        sort: options.sort,\n        order: options.order\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this8.getEntriesCacheKey(dataId, options.groupId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModDataProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_data_get_entries', params, preSets);\n      const entriesFormatted = response.entries.map(entry => _this8.formatEntryContents(entry));\n      return Object.assign(response, {\n        entries: entriesFormatted\n      });\n    })();\n  }\n  /**\n   * Get cache key for database entries data WS calls.\n   *\n   * @param dataId Data ID.\n   * @param groupId Group ID.\n   * @returns Cache key.\n   */\n  getEntriesCacheKey(dataId, groupId = 0) {\n    return this.getEntriesPrefixCacheKey(dataId) + groupId;\n  }\n  /**\n   * Get prefix cache key for database all entries data WS calls.\n   *\n   * @param dataId Data ID.\n   * @returns Cache key.\n   */\n  getEntriesPrefixCacheKey(dataId) {\n    return this.getDatabaseDataPrefixCacheKey(dataId) + ':entries:';\n  }\n  /**\n   * Get an entry of the database activity.\n   *\n   * @param dataId Data ID for caching purposes.\n   * @param entryId Entry ID.\n   * @param options Other options.\n   * @returns Promise resolved when the entry is retrieved.\n   */\n  getEntry(dataId, entryId, options = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        entryid: entryId,\n        returncontents: true\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this9.getEntryCacheKey(dataId, entryId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModDataProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_data_get_entry', params, preSets);\n      return Object.assign(response, {\n        entry: _this9.formatEntryContents(response.entry)\n      });\n    })();\n  }\n  /**\n   * Formats the contents of an entry.\n   *\n   * @param entry Original WS entry.\n   * @returns Entry with contents formatted.\n   */\n  formatEntryContents(entry) {\n    return Object.assign(entry, {\n      contents: CoreUtils.arrayToObject(entry.contents, 'fieldid')\n    });\n  }\n  /**\n   * Get cache key for database entry data WS calls.\n   *\n   * @param dataId Data ID for caching purposes.\n   * @param entryId Entry ID.\n   * @returns Cache key.\n   */\n  getEntryCacheKey(dataId, entryId) {\n    return this.getDatabaseDataPrefixCacheKey(dataId) + ':entry:' + entryId;\n  }\n  /**\n   * Get the list of configured fields for the given database.\n   *\n   * @param dataId Data ID.\n   * @param options Other options.\n   * @returns Promise resolved when the fields are retrieved.\n   */\n  getFields(dataId, options = {}) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        databaseid: dataId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this10.getFieldsCacheKey(dataId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModDataProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_data_get_fields', params, preSets);\n      if (response.fields) {\n        return response.fields;\n      }\n      throw new CoreError('No fields were returned.');\n    })();\n  }\n  /**\n   * Get cache key for database fields data WS calls.\n   *\n   * @param dataId Data ID.\n   * @returns Cache key.\n   */\n  getFieldsCacheKey(dataId) {\n    return this.getDatabaseDataPrefixCacheKey(dataId) + ':fields';\n  }\n  /**\n   * Invalidate the prefetched content.\n   * To invalidate files, use AddonModDataProvider#invalidateFiles.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID of the module.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const promises = [];\n      promises.push(_this11.getDatabase(courseId, moduleId).then( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (database) {\n          const ps = [];\n          // Do not invalidate module data before getting module info, we need it!\n          ps.push(_this11.invalidateDatabaseData(courseId, siteId));\n          ps.push(_this11.invalidateDatabaseWSData(database.id, siteId));\n          ps.push(_this11.invalidateFieldsData(database.id, siteId));\n          yield Promise.all(ps);\n          return;\n        });\n        return function (_x) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n      promises.push(_this11.invalidateFiles(moduleId, siteId));\n      yield CoreUtils.allPromises(promises);\n    })();\n  }\n  /**\n   * Invalidates database access information data.\n   *\n   * @param dataId Data ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateDatabaseAccessInformationData(dataId, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this12.getDatabaseAccessInformationDataPrefixCacheKey(dataId));\n    })();\n  }\n  /**\n   * Invalidates database entries data.\n   *\n   * @param dataId Data ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateEntriesData(dataId, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this13.getEntriesPrefixCacheKey(dataId));\n    })();\n  }\n  /**\n   * Invalidates database fields data.\n   *\n   * @param dataId Data ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateFieldsData(dataId, siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this14.getFieldsCacheKey(dataId));\n    })();\n  }\n  /**\n   * Invalidate the prefetched files.\n   *\n   * @param moduleId The module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the files are invalidated.\n   */\n  invalidateFiles(moduleId, siteId) {\n    return _asyncToGenerator(function* () {\n      yield CoreFilepool.invalidateFilesByComponent(siteId, AddonModDataProvider.COMPONENT, moduleId);\n    })();\n  }\n  /**\n   * Invalidates database data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateDatabaseData(courseId, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this15.getDatabaseDataCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidates database data except files and module info.\n   *\n   * @param databaseId Data ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateDatabaseWSData(databaseId, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this16.getDatabaseDataPrefixCacheKey(databaseId));\n    })();\n  }\n  /**\n   * Invalidates database entry data.\n   *\n   * @param dataId Data ID for caching purposes.\n   * @param entryId Entry ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateEntryData(dataId, entryId, siteId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this17.getEntryCacheKey(dataId, entryId));\n    })();\n  }\n  /**\n   * Report the database as being viewed.\n   *\n   * @param id Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(id, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        databaseid: id\n      };\n      yield CoreCourseLogHelper.log('mod_data_view_database', params, AddonModDataProvider.COMPONENT, id, siteId);\n    })();\n  }\n  /**\n   * Performs search over a database.\n   *\n   * @param dataId The data instance id.\n   * @param options Other options.\n   * @returns Promise resolved when the action is done.\n   */\n  searchEntries(dataId, options = {}) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      options.groupId = options.groupId || 0;\n      options.sort = options.sort || 0;\n      options.order = options.order || 'DESC';\n      options.page = options.page || 0;\n      options.perPage = options.perPage || AddonModDataProvider.PER_PAGE;\n      options.readingStrategy = options.readingStrategy || 3 /* CoreSitesReadingStrategy.PREFER_NETWORK */;\n      const params = {\n        databaseid: dataId,\n        groupid: options.groupId,\n        returncontents: true,\n        page: options.page,\n        perpage: options.perPage\n      };\n      const preSets = _objectSpread({\n        component: AddonModDataProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      if (options.sort !== undefined) {\n        params.sort = options.sort;\n      }\n      if (options.order !== undefined) {\n        params.order = options.order;\n      }\n      if (options.search !== undefined) {\n        params.search = options.search;\n      }\n      if (options.advSearch !== undefined) {\n        params.advsearch = options.advSearch;\n      }\n      const response = yield site.read('mod_data_search_entries', params, preSets);\n      const entriesFormatted = response.entries.map(entry => _this18.formatEntryContents(entry));\n      return Object.assign(response, {\n        entries: entriesFormatted\n      });\n    })();\n  }\n}\n_class = AddonModDataProvider;\n_class.COMPONENT = 'mmaModData';\n_class.PER_PAGE = 25;\n_class.ENTRY_CHANGED = 'addon_mod_data_entry_changed';\n_class.ɵfac = function AddonModDataProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModData = makeSingleton(AddonModDataProvider);","map":{"version":3,"names":["CoreError","CoreSite","CoreCourseLogHelper","CoreNetwork","CoreFilepool","CoreSites","CoreSitesReadingStrategy","CoreUtils","makeSingleton","Translate","AddonModDataFieldsDelegate","AddonModDataOffline","AddonModDataSyncProvider","ROOT_CACHE_KEY","AddonModDataAction","AddonModDataTemplateType","AddonModDataTemplateMode","AddonModDataProvider","addEntry","dataId","entryId","courseId","contents","groupId","fields","siteId","forceOffline","_this","_asyncToGenerator","getCurrentSiteId","storeOffline","_ref","entry","saveEntry","ADD","undefined","newentryid","entryid","sent","apply","arguments","isOnline","notifications","checkFields","length","fieldnotifications","deleteEntryOfflineAction","result","addEntryOnline","error","isWebServiceError","data","site","getSite","params","databaseid","groupid","write","approveEntry","approve","_this2","_ref2","action","APPROVE","DISAPPROVE","oppositeAction","found","approveEntryOnline","contentsIndexed","arrayToObjectMultiple","forEach","field","notification","getFieldsNotifications","id","push","fieldname","name","deleteEntry","_this3","_ref3","DELETE","addedOffline","deleteEntryOnline","getEntry","_unused","editEntry","_this4","_ref4","EDIT","updated","editEntryOnline","fetchAllEntries","options","Object","assign","page","perPage","PER_PAGE","fetchEntriesRecursive","entries","_this5","getEntries","concat","canLoadMore","totalcount","getDatabaseDataCacheKey","getDatabaseDataPrefixCacheKey","getDatabaseByKey","key","value","_this6","courseids","preSets","_objectSpread","cacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","response","read","currentData","databases","find","instant","getDatabase","cmId","getDatabaseById","getDatabaseAccessInformationDataPrefixCacheKey","getDatabaseAccessInformationDataCacheKey","getDatabaseAccessInformation","_this7","componentId","_this8","sort","order","returncontents","perpage","getEntriesCacheKey","FREQUENCY_SOMETIMES","entriesFormatted","map","formatEntryContents","getEntriesPrefixCacheKey","_this9","getEntryCacheKey","arrayToObject","getFields","_this10","getFieldsCacheKey","invalidateContent","moduleId","_this11","promises","then","_ref5","database","ps","invalidateDatabaseData","invalidateDatabaseWSData","invalidateFieldsData","Promise","all","_x","invalidateFiles","allPromises","invalidateDatabaseAccessInformationData","_this12","invalidateWsCacheForKeyStartingWith","invalidateEntriesData","_this13","_this14","invalidateWsCacheForKey","invalidateFilesByComponent","_this15","databaseId","_this16","invalidateEntryData","_this17","logView","log","searchEntries","_this18","search","advSearch","advsearch","_class","ENTRY_CHANGED","factory","ɵfac","providedIn","AddonModData"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/data/services/data.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreRatingInfo } from '@features/rating/services/rating';\nimport { CoreTagItem } from '@features/tag/services/tag';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFileEntry } from '@services/file-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModDataFieldsDelegate } from './data-fields-delegate';\nimport { AddonModDataOffline } from './data-offline';\nimport { AddonModDataAutoSyncData, AddonModDataSyncProvider } from './data-sync';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaModData:';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonModDataSyncProvider.AUTO_SYNCED]: AddonModDataAutoSyncData;\n        [AddonModDataProvider.ENTRY_CHANGED]: AddonModDataEntryChangedEventData;\n    }\n}\n\nexport enum AddonModDataAction {\n    ADD = 'add',\n    EDIT = 'edit',\n    DELETE = 'delete',\n    APPROVE = 'approve',\n    DISAPPROVE = 'disapprove',\n    USER = 'user',\n    USERPICTURE = 'userpicture',\n    MORE = 'more',\n    MOREURL = 'moreurl',\n    COMMENTS = 'comments',\n    TIMEADDED = 'timeadded',\n    TIMEMODIFIED = 'timemodified',\n    TAGS = 'tags',\n    APPROVALSTATUS = 'approvalstatus',\n    DELCHECK = 'delcheck', // Unused.\n    EXPORT = 'export', // Unused.\n    ACTIONSMENU = 'actionsmenu',\n}\n\nexport enum AddonModDataTemplateType {\n    LIST_HEADER = 'listtemplateheader',\n    LIST = 'listtemplate',\n    LIST_FOOTER = 'listtemplatefooter',\n    ADD = 'addtemplate',\n    SEARCH = 'asearchtemplate',\n    SINGLE = 'singletemplate',\n}\n\nexport enum AddonModDataTemplateMode {\n    LIST = 'list',\n    EDIT = 'edit',\n    SHOW = 'show',\n    SEARCH = 'search',\n}\n\n/**\n * Service that provides some features for databases.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModDataProvider {\n\n    static readonly COMPONENT = 'mmaModData';\n    static readonly PER_PAGE = 25;\n    static readonly ENTRY_CHANGED = 'addon_mod_data_entry_changed';\n\n    /**\n     * Adds a new entry to a database.\n     *\n     * @param dataId Data instance ID.\n     * @param entryId EntryId or provisional entry ID when offline.\n     * @param courseId Course ID.\n     * @param contents The fields data to be created.\n     * @param groupId Group id, 0 means that the function will determine the user group.\n     * @param fields The fields that define the contents.\n     * @param siteId Site ID. If not defined, current site.\n     * @param forceOffline Force editing entry in offline.\n     * @returns Promise resolved when the action is done.\n     */\n    async addEntry(\n        dataId: number,\n        entryId: number,\n        courseId: number,\n        contents: AddonModDataEntryWSField[],\n        groupId: number = 0,\n        fields: AddonModDataField[],\n        siteId?: string,\n        forceOffline: boolean = false,\n    ): Promise<AddonModDataAddEntryResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a data to be synchronized later.\n        const storeOffline = async (): Promise<AddonModDataAddEntryResult> => {\n            const entry = await AddonModDataOffline.saveEntry(\n                dataId,\n                entryId,\n                AddonModDataAction.ADD,\n                courseId,\n                groupId,\n                contents,\n                undefined,\n                siteId,\n            );\n\n            return {\n                // Return provissional entry Id.\n                newentryid: entry.entryid,\n                sent: false,\n            };\n        };\n\n        // Checks to store offline.\n        if (!CoreNetwork.isOnline() || forceOffline) {\n            const notifications = this.checkFields(fields, contents);\n            if (notifications.length > 0) {\n                return { fieldnotifications: notifications };\n            }\n        }\n\n        // Remove unnecessary not synced actions.\n        await this.deleteEntryOfflineAction(dataId, entryId, AddonModDataAction.ADD, siteId);\n\n        // App is offline, store the action.\n        if (!CoreNetwork.isOnline() || forceOffline) {\n            return storeOffline();\n        }\n\n        try {\n            const result: AddonModDataAddEntryResult = await this.addEntryOnline(dataId, contents, groupId, siteId);\n            result.sent = true;\n\n            return result;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that responses cannot be submitted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store in offline.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Adds a new entry to a database. It does not cache calls. It will fail if offline or cannot connect.\n     *\n     * @param dataId Database ID.\n     * @param data The fields data to be created.\n     * @param groupId Group id, 0 means that the function will determine the user group.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the action is done.\n     */\n    async addEntryOnline(\n        dataId: number,\n        data: AddonModDataEntryWSField[],\n        groupId?: number,\n        siteId?: string,\n    ): Promise<AddonModDataAddEntryWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonModDataAddEntryWSParams = {\n            databaseid: dataId,\n            data,\n        };\n\n        if (groupId !== undefined) {\n            params.groupid = groupId;\n        }\n\n        return site.write<AddonModDataAddEntryWSResponse>('mod_data_add_entry', params);\n    }\n\n    /**\n     * Approves or unapproves an entry.\n     *\n     * @param dataId Database ID.\n     * @param entryId Entry ID.\n     * @param approve Whether to approve (true) or unapprove the entry.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the action is done.\n     */\n    async approveEntry(\n        dataId: number,\n        entryId: number,\n        approve: boolean,\n        courseId: number,\n        siteId?: string,\n    ): Promise<AddonModDataApproveEntryResult | undefined> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a data to be synchronized later.\n        const storeOffline = async (): Promise<AddonModDataApproveEntryResult> => {\n            const action = approve ? AddonModDataAction.APPROVE : AddonModDataAction.DISAPPROVE;\n\n            await AddonModDataOffline.saveEntry(dataId, entryId, action, courseId, undefined, undefined, undefined, siteId);\n\n            return {\n                sent: false,\n            };\n        };\n\n        // Get if the opposite action is not synced.\n        const oppositeAction = approve ? AddonModDataAction.DISAPPROVE : AddonModDataAction.APPROVE;\n\n        const found = await this.deleteEntryOfflineAction(dataId, entryId, oppositeAction, siteId);\n        if (found) {\n            // Offline action has been found and deleted. Stop here.\n            return;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            await this.approveEntryOnline(entryId, approve, siteId);\n\n            return {\n                sent: true,\n            };\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that responses cannot be submitted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store in offline.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Approves or unapproves an entry. It does not cache calls. It will fail if offline or cannot connect.\n     *\n     * @param entryId Entry ID.\n     * @param approve Whether to approve (true) or unapprove the entry.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the action is done.\n     */\n    async approveEntryOnline(entryId: number, approve: boolean, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonModDataApproveEntryWSParams = {\n            entryid: entryId,\n            approve,\n        };\n\n        await site.write('mod_data_approve_entry', params);\n    }\n\n    /**\n     * Convenience function to check fields requeriments here named \"notifications\".\n     *\n     * @param fields The fields that define the contents.\n     * @param contents The contents data of the fields.\n     * @returns Array of notifications if any or false.\n     */\n    protected checkFields(fields: AddonModDataField[], contents: AddonModDataSubfieldData[]): AddonModDataFieldNotification[] {\n        const notifications: AddonModDataFieldNotification[] = [];\n        const contentsIndexed = CoreUtils.arrayToObjectMultiple(contents, 'fieldid');\n\n        // App is offline, check required fields.\n        fields.forEach((field) => {\n            const notification = AddonModDataFieldsDelegate.getFieldsNotifications(field, contentsIndexed[field.id]);\n\n            if (notification) {\n                notifications.push({\n                    fieldname: field.name,\n                    notification,\n                });\n            }\n        });\n\n        return notifications;\n    }\n\n    /**\n     * Deletes an entry.\n     *\n     * @param dataId Database ID.\n     * @param entryId Entry ID.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the action is done.\n     */\n    async deleteEntry(dataId: number, entryId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a data to be synchronized later.\n        const storeOffline = async (): Promise<void> => {\n            await AddonModDataOffline.saveEntry(\n                dataId,\n                entryId,\n                AddonModDataAction.DELETE,\n                courseId,\n                undefined,\n                undefined,\n                undefined,\n                siteId,\n            );\n        };\n\n        // Check if the opposite action is not synced and just delete it.\n        const addedOffline = await this.deleteEntryOfflineAction(dataId, entryId, AddonModDataAction.ADD, siteId);\n        if (addedOffline) {\n            // Offline add action found and deleted. Stop here.\n            return;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            await this.deleteEntryOnline(entryId, siteId);\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that responses cannot be submitted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store in offline.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Deletes an entry. It does not cache calls. It will fail if offline or cannot connect.\n     *\n     * @param entryId Entry ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the action is done.\n     */\n    async deleteEntryOnline(entryId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonModDataDeleteEntryWSParams = {\n            entryid: entryId,\n        };\n\n        await site.write('mod_data_delete_entry', params);\n    }\n\n    /**\n     * Delete entry offline action.\n     *\n     * @param dataId Database ID.\n     * @param entryId Entry ID.\n     * @param action Action name to delete.\n     * @param siteId Site ID.\n     * @returns Resolved with true if the action has been found and deleted.\n     */\n    protected async deleteEntryOfflineAction(\n        dataId: number,\n        entryId: number,\n        action: AddonModDataAction,\n        siteId: string,\n    ): Promise<boolean> {\n        try {\n            // Get other not not synced actions.\n            await AddonModDataOffline.getEntry(dataId, entryId, action, siteId);\n            await AddonModDataOffline.deleteEntry(dataId, entryId, action, siteId);\n\n            return true;\n        } catch {\n            // Not found.\n            return false;\n        }\n    }\n\n    /**\n     * Updates an existing entry.\n     *\n     * @param dataId Database ID.\n     * @param entryId Entry ID.\n     * @param courseId Course ID.\n     * @param contents The contents data to be updated.\n     * @param fields The fields that define the contents.\n     * @param siteId Site ID. If not defined, current site.\n     * @param forceOffline Force editing entry in offline.\n     * @returns Promise resolved when the action is done.\n     */\n    async editEntry(\n        dataId: number,\n        entryId: number,\n        courseId: number,\n        contents: AddonModDataEntryWSField[],\n        fields: AddonModDataField[],\n        siteId?: string,\n        forceOffline: boolean = false,\n    ): Promise<AddonModDataEditEntryResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a data to be synchronized later.\n        const storeOffline = async (): Promise<AddonModDataEditEntryResult> => {\n            await AddonModDataOffline.saveEntry(\n                dataId,\n                entryId,\n                AddonModDataAction.EDIT,\n                courseId,\n                undefined,\n                contents,\n                undefined,\n                siteId,\n            );\n\n            return {\n                updated: true,\n                sent: false,\n            };\n        };\n\n        if (!CoreNetwork.isOnline() || forceOffline) {\n            const notifications = this.checkFields(fields, contents);\n            if (notifications.length > 0) {\n                return { fieldnotifications: notifications };\n            }\n        }\n\n        // Remove unnecessary not synced actions.\n        await this.deleteEntryOfflineAction(dataId, entryId, AddonModDataAction.EDIT, siteId);\n\n        if (!CoreNetwork.isOnline() || forceOffline) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            const result: AddonModDataEditEntryResult = await this.editEntryOnline(entryId, contents, siteId);\n            result.sent = true;\n\n            return result;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that responses cannot be submitted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store in offline.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Updates an existing entry. It does not cache calls. It will fail if offline or cannot connect.\n     *\n     * @param entryId Entry ID.\n     * @param data The fields data to be updated.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the action is done.\n     */\n    async editEntryOnline(\n        entryId: number,\n        data: AddonModDataEntryWSField[],\n        siteId?: string,\n    ): Promise<AddonModDataUpdateEntryWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonModDataUpdateEntryWSParams = {\n            entryid: entryId,\n            data,\n        };\n\n        return site.write<AddonModDataUpdateEntryWSResponse>('mod_data_update_entry', params);\n    }\n\n    /**\n     * Performs the whole fetch of the entries in the database.\n     *\n     * @param dataId Data ID.\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    fetchAllEntries(dataId: number, options: AddonModDataGetEntriesOptions = {}): Promise<AddonModDataEntry[]> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n        options = Object.assign({\n            page: 0,\n            perPage: AddonModDataProvider.PER_PAGE,\n        }, options);\n\n        return this.fetchEntriesRecursive(dataId, [], options);\n    }\n\n    /**\n     * Recursive call on fetch all entries.\n     *\n     * @param dataId Data ID.\n     * @param entries Entries already fetch (just to concatenate them).\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    protected async fetchEntriesRecursive(\n        dataId: number,\n        entries: AddonModDataEntry[],\n        options: AddonModDataGetEntriesOptions,\n    ): Promise<AddonModDataEntry[]> {\n        const result = await this.getEntries(dataId, options);\n        entries = entries.concat(result.entries);\n\n        const canLoadMore = options.perPage! > 0 && ((options.page! + 1) * options.perPage!) < result.totalcount;\n        if (canLoadMore) {\n            options.page!++;\n\n            return this.fetchEntriesRecursive(dataId, entries, options);\n        }\n\n        return entries;\n    }\n\n    /**\n     * Get cache key for data data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getDatabaseDataCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'data:' + courseId;\n    }\n\n    /**\n     * Get prefix cache key for all database activity data WS calls.\n     *\n     * @param dataId Data ID.\n     * @returns Cache key.\n     */\n    protected getDatabaseDataPrefixCacheKey(dataId: number): string {\n        return ROOT_CACHE_KEY + dataId;\n    }\n\n    /**\n     * Get a database data. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the data is retrieved.\n     */\n    protected async getDatabaseByKey(\n        courseId: number,\n        key: string,\n        value: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModDataData> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModDataGetDatabasesByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getDatabaseDataCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModDataProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n        const response =\n            await site.read<AddonModDataGetDatabasesByCoursesWSResponse>('mod_data_get_databases_by_courses', params, preSets);\n\n        const currentData = response.databases.find((data) => data[key] == value);\n        if (currentData) {\n            return currentData;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get a data by course module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the data is retrieved.\n     */\n    getDatabase(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModDataData> {\n        return this.getDatabaseByKey(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a data by ID.\n     *\n     * @param courseId Course ID.\n     * @param id Data ID.\n     * @param options Other options.\n     * @returns Promise resolved when the data is retrieved.\n     */\n    getDatabaseById(courseId: number, id: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModDataData> {\n        return this.getDatabaseByKey(courseId, 'id', id, options);\n    }\n\n    /**\n     * Get prefix cache key for all database access information data WS calls.\n     *\n     * @param dataId Data ID.\n     * @returns Cache key.\n     */\n    protected getDatabaseAccessInformationDataPrefixCacheKey(dataId: number): string {\n        return this.getDatabaseDataPrefixCacheKey(dataId) + ':access:';\n    }\n\n    /**\n     * Get cache key for database access information data WS calls.\n     *\n     * @param dataId Data ID.\n     * @param groupId Group ID.\n     * @returns Cache key.\n     */\n    protected getDatabaseAccessInformationDataCacheKey(dataId: number, groupId: number = 0): string {\n        return this.getDatabaseAccessInformationDataPrefixCacheKey(dataId) + groupId;\n    }\n\n    /**\n     * Get access information for a given database.\n     *\n     * @param dataId Data ID.\n     * @param options Other options.\n     * @returns Promise resolved when the database is retrieved.\n     */\n    async getDatabaseAccessInformation(\n        dataId: number,\n        options: AddonModDataAccessInfoOptions = {},\n    ): Promise<AddonModDataGetDataAccessInformationWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        options.groupId = options.groupId || 0;\n\n        const params: AddonModDataGetDataAccessInformationWSParams = {\n            databaseid: dataId,\n            groupid: options.groupId,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getDatabaseAccessInformationDataCacheKey(dataId, options.groupId),\n            component: AddonModDataProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read<AddonModDataGetDataAccessInformationWSResponse>('mod_data_get_data_access_information', params, preSets);\n    }\n\n    /**\n     * Get entries for a specific database and group.\n     *\n     * @param dataId Data ID.\n     * @param options Other options.\n     * @returns Promise resolved when the database is retrieved.\n     */\n    async getEntries(dataId: number, options: AddonModDataGetEntriesOptions = {}): Promise<AddonModDataEntries> {\n        options = Object.assign({\n            groupId: 0,\n            sort: 0,\n            order: 'DESC',\n            page: 0,\n            perPage: AddonModDataProvider.PER_PAGE,\n        }, options);\n\n        const site = await CoreSites.getSite(options.siteId);\n        // Always use sort and order params to improve cache usage (entries are identified by params).\n        const params: AddonModDataGetEntriesWSParams = {\n            databaseid: dataId,\n            returncontents: true,\n            page: options.page,\n            perpage: options.perPage,\n            groupid: options.groupId,\n            sort: options.sort,\n            order: options.order,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEntriesCacheKey(dataId, options.groupId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModDataProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModDataGetEntriesWSResponse>('mod_data_get_entries', params, preSets);\n\n        const entriesFormatted = response.entries.map((entry) => this.formatEntryContents(entry));\n\n        return Object.assign(response, {\n            entries: entriesFormatted,\n        });\n    }\n\n    /**\n     * Get cache key for database entries data WS calls.\n     *\n     * @param dataId Data ID.\n     * @param groupId Group ID.\n     * @returns Cache key.\n     */\n    protected getEntriesCacheKey(dataId: number, groupId: number = 0): string {\n        return this.getEntriesPrefixCacheKey(dataId) + groupId;\n    }\n\n    /**\n     * Get prefix cache key for database all entries data WS calls.\n     *\n     * @param dataId Data ID.\n     * @returns Cache key.\n     */\n    protected getEntriesPrefixCacheKey(dataId: number): string {\n        return this.getDatabaseDataPrefixCacheKey(dataId) + ':entries:';\n    }\n\n    /**\n     * Get an entry of the database activity.\n     *\n     * @param dataId Data ID for caching purposes.\n     * @param entryId Entry ID.\n     * @param options Other options.\n     * @returns Promise resolved when the entry is retrieved.\n     */\n    async getEntry(\n        dataId: number,\n        entryId: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModDataGetEntryFormatted> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModDataGetEntryWSParams = {\n            entryid: entryId,\n            returncontents: true,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEntryCacheKey(dataId, entryId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModDataProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModDataGetEntryWSResponse>('mod_data_get_entry', params, preSets);\n\n        return Object.assign(response, {\n            entry: this.formatEntryContents(response.entry),\n        });\n    }\n\n    /**\n     * Formats the contents of an entry.\n     *\n     * @param entry Original WS entry.\n     * @returns Entry with contents formatted.\n     */\n    protected formatEntryContents(entry: AddonModDataEntryWS): AddonModDataEntry {\n        return Object.assign(entry, {\n            contents: CoreUtils.arrayToObject(entry.contents, 'fieldid'),\n        });\n    }\n\n    /**\n     * Get cache key for database entry data WS calls.\n     *\n     * @param dataId Data ID for caching purposes.\n     * @param entryId Entry ID.\n     * @returns Cache key.\n     */\n    protected getEntryCacheKey(dataId: number, entryId: number): string {\n        return this.getDatabaseDataPrefixCacheKey(dataId) + ':entry:' + entryId;\n    }\n\n    /**\n     * Get the list of configured fields for the given database.\n     *\n     * @param dataId Data ID.\n     * @param options Other options.\n     * @returns Promise resolved when the fields are retrieved.\n     */\n    async getFields(dataId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModDataField[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModDataGetFieldsWSParams = {\n            databaseid: dataId,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getFieldsCacheKey(dataId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModDataProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModDataGetFieldsWSResponse>('mod_data_get_fields', params, preSets);\n        if (response.fields) {\n            return response.fields;\n        }\n\n        throw new CoreError('No fields were returned.');\n    }\n\n    /**\n     * Get cache key for database fields data WS calls.\n     *\n     * @param dataId Data ID.\n     * @returns Cache key.\n     */\n    protected getFieldsCacheKey(dataId: number): string {\n        return this.getDatabaseDataPrefixCacheKey(dataId) + ':fields';\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     * To invalidate files, use AddonModDataProvider#invalidateFiles.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID of the module.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const promises: Promise<void>[] = [];\n\n        promises.push(this.getDatabase(courseId, moduleId).then(async (database) => {\n            const ps: Promise<void>[] = [];\n\n            // Do not invalidate module data before getting module info, we need it!\n            ps.push(this.invalidateDatabaseData(courseId, siteId));\n            ps.push(this.invalidateDatabaseWSData(database.id, siteId));\n            ps.push(this.invalidateFieldsData(database.id, siteId));\n\n            await Promise.all(ps);\n\n            return;\n        }));\n\n        promises.push(this.invalidateFiles(moduleId, siteId));\n\n        await CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Invalidates database access information data.\n     *\n     * @param dataId Data ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateDatabaseAccessInformationData(dataId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getDatabaseAccessInformationDataPrefixCacheKey(dataId));\n    }\n\n    /**\n     * Invalidates database entries data.\n     *\n     * @param dataId Data ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateEntriesData(dataId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getEntriesPrefixCacheKey(dataId));\n    }\n\n    /**\n     * Invalidates database fields data.\n     *\n     * @param dataId Data ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateFieldsData(dataId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getFieldsCacheKey(dataId));\n    }\n\n    /**\n     * Invalidate the prefetched files.\n     *\n     * @param moduleId The module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the files are invalidated.\n     */\n    async invalidateFiles(moduleId: number, siteId?: string): Promise<void> {\n        await CoreFilepool.invalidateFilesByComponent(siteId, AddonModDataProvider.COMPONENT, moduleId);\n    }\n\n    /**\n     * Invalidates database data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateDatabaseData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getDatabaseDataCacheKey(courseId));\n    }\n\n    /**\n     * Invalidates database data except files and module info.\n     *\n     * @param databaseId Data ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateDatabaseWSData(databaseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getDatabaseDataPrefixCacheKey(databaseId));\n    }\n\n    /**\n     * Invalidates database entry data.\n     *\n     * @param dataId Data ID for caching purposes.\n     * @param entryId Entry ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateEntryData(dataId: number, entryId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getEntryCacheKey(dataId, entryId));\n    }\n\n    /**\n     * Report the database as being viewed.\n     *\n     * @param id Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logView(id: number, siteId?: string): Promise<void> {\n        const params: AddonModDataViewDatabaseWSParams = {\n            databaseid: id,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_data_view_database',\n            params,\n            AddonModDataProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Performs search over a database.\n     *\n     * @param dataId The data instance id.\n     * @param options Other options.\n     * @returns Promise resolved when the action is done.\n     */\n    async searchEntries(dataId: number, options: AddonModDataSearchEntriesOptions = {}): Promise<AddonModDataEntries> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        options.groupId = options.groupId || 0;\n        options.sort = options.sort || 0;\n        options.order = options.order || 'DESC';\n        options.page = options.page || 0;\n        options.perPage = options.perPage || AddonModDataProvider.PER_PAGE;\n        options.readingStrategy = options.readingStrategy || CoreSitesReadingStrategy.PREFER_NETWORK;\n\n        const params: AddonModDataSearchEntriesWSParams = {\n            databaseid: dataId,\n            groupid: options.groupId,\n            returncontents: true,\n            page: options.page,\n            perpage: options.perPage,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            component: AddonModDataProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n        if (options.sort !== undefined) {\n            params.sort = options.sort;\n        }\n        if (options.order !== undefined) {\n            params.order = options.order;\n        }\n        if (options.search !== undefined) {\n            params.search = options.search;\n        }\n        if (options.advSearch !== undefined) {\n            params.advsearch = options.advSearch;\n        }\n        const response = await site.read<AddonModDataSearchEntriesWSResponse>('mod_data_search_entries', params, preSets);\n\n        const entriesFormatted = response.entries.map((entry) => this.formatEntryContents(entry));\n\n        return Object.assign(response, {\n            entries: entriesFormatted,\n        });\n    }\n\n}\nexport const AddonModData = makeSingleton(AddonModDataProvider);\n\n/**\n * Params of mod_data_view_database WS.\n */\ntype AddonModDataViewDatabaseWSParams = {\n    databaseid: number; // Data instance id.\n};\n\n/**\n * Params of mod_data_search_entries WS.\n */\ntype AddonModDataSearchEntriesWSParams = {\n    databaseid: number; // Data instance id.\n    groupid?: number; // Group id, 0 means that the function will determine the user group.\n    returncontents?: boolean; // Whether to return contents or not.\n    search?: string; // Search string (empty when using advanced).\n    advsearch?: AddonModDataSearchEntriesAdvancedField[];\n    sort?: number; // Sort the records by this field id, reserved ids are:\n    // 0: timeadded\n    // -1: firstname\n    // -2: lastname\n    // -3: approved\n    // -4: timemodified.\n    // Empty for using the default database setting.\n    order?: string; // The direction of the sorting: 'ASC' or 'DESC'. Empty for using the default database setting.\n    page?: number; // The page of records to return.\n    perpage?: number; // The number of records to return per page.\n};\n\n/**\n * Data returned by mod_data_search_entries WS.\n */\nexport type AddonModDataSearchEntriesWSResponse = {\n    entries: AddonModDataEntryWS[];\n    totalcount: number; // Total count of records returned by the search.\n    maxcount?: number; // Total count of records that the user could see in the database (if all the search criterias were removed).\n    listviewcontents?: string; // The list view contents as is rendered in the site.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Options to pass to get access info.\n */\nexport type AddonModDataAccessInfoOptions = CoreCourseCommonModWSOptions & {\n    groupId?: number; // Group Id.\n};\n\n/**\n * Options to pass to get entries.\n */\nexport type AddonModDataGetEntriesOptions = CoreCourseCommonModWSOptions & {\n    groupId?: number; // Group Id.\n    sort?: number; // Sort the records by this field id, defaults to 0. Reserved ids are:\n    // 0: timeadded\n    // -1: firstname\n    // -2: lastname\n    // -3: approved\n    // -4: timemodified\n    order?: string; // The direction of the sorting: 'ASC' or 'DESC'. Defaults to 'DESC'.\n    page?: number; // Page of records to return. Defaults to 0.\n    perPage?: number; // Records per page to return. Defaults to AddonModDataProvider.PER_PAGE.\n};\n\n/**\n * Options to pass to search entries.\n */\nexport type AddonModDataSearchEntriesOptions = AddonModDataGetEntriesOptions & {\n    search?: string; // Search text. It will be used if advSearch is not defined.\n    advSearch?: AddonModDataSearchEntriesAdvancedField[];\n};\n\n/**\n * Database entry (online or offline).\n */\nexport type AddonModDataEntry = Omit<AddonModDataEntryWS, 'contents'> & {\n    contents: AddonModDataEntryFields; // The record contents.\n    tags?: CoreTagItem[]; // Tags.\n    // Calculated data.\n    deleted?: boolean; // Entry is deleted offline.\n    hasOffline?: boolean; // Entry has offline actions.\n};\n\n/**\n * Database entry data from WS.\n */\nexport type AddonModDataEntryWS = {\n    id: number; // Record id.\n    userid: number; // The id of the user who created the record.\n    groupid: number; // The group id this record belongs to (0 for no groups).\n    dataid: number; // The database id this record belongs to.\n    timecreated: number; // Time the record was created.\n    timemodified: number; // Last time the record was modified.\n    approved: boolean; // Whether the entry has been approved (if the database is configured in that way).\n    canmanageentry: boolean; // Whether the current user can manage this entry.\n    fullname?: string; // The user who created the entry fullname.\n    contents?: AddonModDataEntryField[];\n    tags?: CoreTagItem[]; // Tags.\n};\n\n/**\n * Entry field content.\n */\nexport type AddonModDataEntryField = {\n    id: number; // Content id.\n    fieldid: number; // The field type of the content.\n    recordid: number; // The record this content belongs to.\n    content: string; // Contents.\n    content1: string | null; // Contents.\n    content2: string | null; // Contents.\n    content3: string | null; // Contents.\n    content4: string | null; // Contents.\n    files: CoreFileEntry[];\n};\n\n/**\n * Entry contents indexed by field id.\n */\nexport type AddonModDataEntryFields = {\n    [fieldid: number]: AddonModDataEntryField;\n};\n\n/**\n * List of entries returned by web service and helper functions.\n */\nexport type AddonModDataEntries = {\n    entries: AddonModDataEntry[]; // Online entries.\n    totalcount: number; // Total count of online entries or found entries.\n    maxcount?: number; // Total count of online entries. Only returned when searching.\n    offlineEntries?: AddonModDataEntry[]; // Offline entries.\n    hasOfflineActions?: boolean; // Whether the database has offline data.\n    hasOfflineRatings?: boolean; // Whether the database has offline ratings.\n};\n\n/**\n * Subfield form data.\n */\nexport type AddonModDataSubfieldData = {\n    fieldid: number;\n    subfield?: string;\n    value?: unknown; // Value encoded in JSON.\n    files?: CoreFileEntry[];\n};\n\n/**\n * Params of mod_data_get_data_access_information WS.\n */\ntype AddonModDataGetDataAccessInformationWSParams = {\n    databaseid: number; // Database instance id.\n    groupid?: number; // Group id, 0 means that the function will determine the user group.\n};\n\n/**\n * Data returned by mod_data_get_data_access_information WS.\n */\nexport type AddonModDataGetDataAccessInformationWSResponse = {\n    groupid: number; // User current group id (calculated).\n    canaddentry: boolean; // Whether the user can add entries or not.\n    canmanageentries: boolean; // Whether the user can manage entries or not.\n    canapprove: boolean; // Whether the user can approve entries or not.\n    timeavailable: boolean; // Whether the database is available or not by time restrictions.\n    inreadonlyperiod: boolean; // Whether the database is in read mode only.\n    numentries: number; // The number of entries the current user added.\n    entrieslefttoadd: number; // The number of entries left to complete the activity.\n    entrieslefttoview: number; // The number of entries left to view other users entries.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_data_get_databases_by_courses WS.\n */\ntype AddonModDataGetDatabasesByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_data_get_databases_by_courses WS.\n */\ntype AddonModDataGetDatabasesByCoursesWSResponse = {\n    databases: AddonModDataData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Database data returned by mod_assign_get_assignments.\n */\nexport type AddonModDataData = {\n    id: number; // Database id.\n    course: number; // Course id.\n    name: string; // Database name.\n    intro: string; // The Database intro.\n    introformat?: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    comments: boolean; // Comments enabled.\n    timeavailablefrom: number; // Timeavailablefrom field.\n    timeavailableto: number; // Timeavailableto field.\n    timeviewfrom: number; // Timeviewfrom field.\n    timeviewto: number; // Timeviewto field.\n    requiredentries: number; // Requiredentries field.\n    requiredentriestoview: number; // Requiredentriestoview field.\n    maxentries: number; // Maxentries field.\n    rssarticles: number; // Rssarticles field.\n    singletemplate: string; // Singletemplate field.\n    listtemplate: string; // Listtemplate field.\n    listtemplateheader: string; // Listtemplateheader field.\n    listtemplatefooter: string; // Listtemplatefooter field.\n    addtemplate: string; // Addtemplate field.\n    rsstemplate: string; // Rsstemplate field.\n    rsstitletemplate: string; // Rsstitletemplate field.\n    csstemplate: string; // Csstemplate field.\n    jstemplate: string; // Jstemplate field.\n    asearchtemplate: string; // Asearchtemplate field.\n    approval: boolean; // Approval field.\n    manageapproved: boolean; // Manageapproved field.\n    scale?: number; // Scale field.\n    assessed?: number; // Assessed field.\n    assesstimestart?: number; // Assesstimestart field.\n    assesstimefinish?: number; // Assesstimefinish field.\n    defaultsort: number; // Defaultsort field.\n    defaultsortdir: number; // Defaultsortdir field.\n    editany?: boolean; // Editany field (not used any more).\n    notification?: number; // Notification field (not used any more).\n    timemodified?: number; // Time modified.\n    coursemodule: number; // Coursemodule.\n    introfiles?: CoreWSExternalFile[];\n};\n\n/**\n * Params of mod_data_add_entry WS.\n */\ntype AddonModDataAddEntryWSParams = {\n    databaseid: number; // Data instance id.\n    groupid?: number; // Group id, 0 means that the function will determine the user group.\n    data: AddonModDataEntryWSField[]; // The fields data to be created.\n};\n\n/**\n * Data returned by mod_data_add_entry WS.\n */\nexport type AddonModDataAddEntryWSResponse = {\n    newentryid: number; // True new created entry id. 0 if the entry was not created.\n    generalnotifications: string[];\n    fieldnotifications: AddonModDataFieldNotification[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_data_approve_entry WS.\n */\ntype AddonModDataApproveEntryWSParams = {\n    entryid: number; // Record entry id.\n    approve?: boolean; // Whether to approve (true) or unapprove the entry.\n};\n\n/**\n * Params of mod_data_delete_entry WS.\n */\ntype AddonModDataDeleteEntryWSParams = {\n    entryid: number; // Record entry id.\n};\n\n/**\n * Params of mod_data_update_entry WS.\n */\ntype AddonModDataUpdateEntryWSParams = {\n    entryid: number; // The entry record id.\n    data: AddonModDataEntryWSField[]; // The fields data to be updated.\n};\n\n/**\n * Data returned by mod_data_update_entry WS.\n */\nexport type AddonModDataUpdateEntryWSResponse = {\n    updated: boolean; // True if the entry was successfully updated, false other wise.\n    generalnotifications: string[];\n    fieldnotifications: AddonModDataFieldNotification[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n// The fields data to be created or updated.\nexport type AddonModDataEntryWSField = {\n    fieldid: number; // The field id. AddonModDataSubfieldData\n    subfield?: string; // The subfield name (if required).\n    value: string; // The contents for the field always JSON encoded.\n};\n\n/**\n * Params of mod_data_get_entries WS.\n */\ntype AddonModDataGetEntriesWSParams = {\n    databaseid: number; // Data instance id.\n    groupid?: number; // Group id, 0 means that the function will determine the user group.\n    returncontents?: boolean; // Whether to return contents or not. This will return each entry raw contents and the complete list\n    // view(using the template).\n    sort?: number; // Sort the records by this field id, reserved ids are:\n    // 0: timeadded\n    // -1: firstname\n    // -2: lastname\n    // -3: approved\n    // -4: timemodified.\n    // Empty for using the default database setting.\n    order?: string; // The direction of the sorting: 'ASC' or 'DESC'. Empty for using the default database setting.\n    page?: number; // The page of records to return.\n    perpage?: number; // The number of records to return per page.\n};\n\n/**\n * Data returned by mod_data_get_entries WS.\n */\nexport type AddonModDataGetEntriesWSResponse = {\n    entries: AddonModDataEntryWS[];\n    totalcount: number; // Total count of records.\n    totalfilesize: number; // Total size (bytes) of the files included in the records.\n    listviewcontents?: string; // The list view contents as is rendered in the site.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_data_get_entry WS.\n */\ntype AddonModDataGetEntryWSParams = {\n    entryid: number; // Record entry id.\n    returncontents?: boolean; // Whether to return contents or not.\n};\n\n/**\n * Data returned by mod_data_get_entry WS.\n */\ntype AddonModDataGetEntryWSResponse = {\n    entry: AddonModDataEntryWS;\n    entryviewcontents?: string; // The entry as is rendered in the site.\n    ratinginfo?: CoreRatingInfo; // Rating information.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data returned by mod_data_get_entry WS.\n */\nexport type AddonModDataGetEntryFormatted = {\n    entry: AddonModDataEntry;\n    entryviewcontents?: string; // The entry as is rendered in the site.\n    ratinginfo?: CoreRatingInfo; // Rating information.\n    warnings?: CoreWSExternalWarning[];\n};\n\nexport type AddonModDataFieldNotification = {\n    fieldname: string; // The field name.\n    notification: string; // The notification for the field.\n};\n\n/**\n * Params of mod_data_get_fields WS.\n */\ntype AddonModDataGetFieldsWSParams = {\n    databaseid: number; // Database instance id.\n};\n\n/**\n * Data returned by mod_data_get_fields WS.\n */\ntype AddonModDataGetFieldsWSResponse = {\n    fields: AddonModDataField[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Field data returned by mod_data_get_fields WS.\n */\nexport type AddonModDataField = {\n    id: number; // Field id.\n    dataid: number; // The field type of the content.\n    type: string; // The field type.\n    name: string; // The field name.\n    description: string; // The field description.\n    required: boolean; // Whether is a field required or not.\n    param1: string; // Field parameters.\n    param2: string; // Field parameters.\n    param3: string; // Field parameters.\n    param4: string; // Field parameters.\n    param5: string; // Field parameters.\n    param6: string; // Field parameters.\n    param7: string; // Field parameters.\n    param8: string; // Field parameters.\n    param9: string; // Field parameters.\n    param10: string; // Field parameters.\n};\n\nexport type AddonModDataEntryChangedEventData = {\n    dataId: number;\n    entryId?: number;\n    deleted?: boolean;\n};\n\n/**\n * Advanced search field.\n */\nexport type AddonModDataSearchEntriesAdvancedField = {\n    name: string; // Field key for search. Use fn or ln for first or last name.\n    value: string; // JSON encoded value for search.\n};\n\n/**\n * Advanced search field.\n */\nexport type AddonModDataSearchEntriesAdvancedFieldFormatted = {\n    name: string; // Field key for search. Use fn or ln for first or last name.\n    value: unknown; // JSON encoded value for search.\n};\n\nexport type AddonModDataAddEntryResult = Partial<AddonModDataAddEntryWSResponse> & {\n    sent?: boolean; // True if sent, false if stored offline.\n};\n\nexport type AddonModDataApproveEntryResult = {\n    sent?: boolean; // True if sent, false if stored offline.\n};\n\nexport type AddonModDataEditEntryResult = Partial<AddonModDataUpdateEntryWSResponse> & {\n    sent?: boolean; // True if sent, false if stored offline.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}