{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { RETAKES_FINISHED_SYNC_TABLE_NAME } from './database/lesson';\nimport { AddonModLessonPrefetchHandler } from './handlers/prefetch';\nimport { AddonModLesson, AddonModLessonProvider } from './lesson';\nimport { AddonModLessonOffline } from './lesson-offline';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync lesson.\n */\nexport class AddonModLessonSyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModLessonSyncProvider');\n    this.componentTranslatableString = 'lesson';\n  }\n  /**\n   * Unmark a retake as finished in a synchronization.\n   *\n   * @param lessonId Lesson ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteRetakeFinishedInSync(lessonId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // Ignore errors, maybe there is none.\n      yield CoreUtils.ignoreErrors(site.getDb().deleteRecords(RETAKES_FINISHED_SYNC_TABLE_NAME, {\n        lessonid: lessonId\n      }));\n    })();\n  }\n  /**\n   * Get a retake finished in a synchronization for a certain lesson (if any).\n   *\n   * @param lessonId Lesson ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the retake entry (undefined if no retake).\n   */\n  getRetakeFinishedInSync(lessonId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return CoreUtils.ignoreErrors(site.getDb().getRecord(RETAKES_FINISHED_SYNC_TABLE_NAME, {\n        lessonid: lessonId\n      }));\n    })();\n  }\n  /**\n   * Check if a lesson has data to synchronize.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Retake number.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it has data to sync.\n   */\n  hasDataToSync(lessonId, retake, siteId) {\n    return _asyncToGenerator(function* () {\n      const [hasAttempts, hasFinished] = yield Promise.all([CoreUtils.ignoreErrors(AddonModLessonOffline.hasRetakeAttempts(lessonId, retake, siteId)), CoreUtils.ignoreErrors(AddonModLessonOffline.hasFinishedRetake(lessonId, siteId))]);\n      return !!(hasAttempts || hasFinished);\n    })();\n  }\n  /**\n   * Mark a retake as finished in a synchronization.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake The retake number.\n   * @param pageId The page ID to start reviewing from.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  setRetakeFinishedInSync(lessonId, retake, pageId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().insertRecord(RETAKES_FINISHED_SYNC_TABLE_NAME, {\n        lessonid: lessonId,\n        retake: Number(retake),\n        pageid: Number(pageId),\n        timefinished: CoreTimeUtils.timestamp()\n      });\n    })();\n  }\n  /**\n   * Try to synchronize all the lessons in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllLessons(siteId, force = false) {\n    return this.syncOnSites('all lessons', siteId => this.syncAllLessonsFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all lessons on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllLessonsFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Get all the lessons that have something to be synchronized.\n      const lessons = yield AddonModLessonOffline.getAllLessonsWithData(siteId);\n      // Sync all lessons that need it.\n      yield Promise.all(lessons.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (lesson) {\n          const result = force ? yield _this.syncLesson(lesson.id, false, false, siteId) : yield _this.syncLessonIfNeeded(lesson.id, false, siteId);\n          if (result !== null && result !== void 0 && result.updated) {\n            // Sync successful, send event.\n            CoreEvents.trigger(AddonModLessonSyncProvider.AUTO_SYNCED, {\n              lessonId: lesson.id,\n              warnings: result.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Sync a lesson only if a certain time has passed since the last time.\n   *\n   * @param lessonId Lesson ID.\n   * @param askPassword Whether we should ask for password if needed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the lesson is synced or if it doesn't need to be synced.\n   */\n  syncLessonIfNeeded(lessonId, askPassword = false, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const needed = yield _this2.isSyncNeeded(lessonId, siteId);\n      if (needed) {\n        return _this2.syncLesson(lessonId, askPassword, false, siteId);\n      }\n    })();\n  }\n  /**\n   * Try to synchronize a lesson.\n   *\n   * @param lessonId Lesson ID.\n   * @param askPassword True if we should ask for password if needed, false otherwise.\n   * @param ignoreBlock True to ignore the sync block setting.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success.\n   */\n  syncLesson(lessonId, askPassword = false, ignoreBlock = false, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      let syncPromise = _this3.getOngoingSync(lessonId, siteId);\n      if (syncPromise) {\n        // There's already a sync ongoing for this lesson, return the promise.\n        return syncPromise;\n      }\n      // Verify that lesson isn't blocked.\n      if (!ignoreBlock && CoreSync.isBlocked(AddonModLessonProvider.COMPONENT, lessonId, siteId)) {\n        _this3.logger.debug('Cannot sync lesson ' + lessonId + ' because it is blocked.');\n        throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', {\n          $a: _this3.componentTranslate\n        }));\n      }\n      _this3.logger.debug('Try to sync lesson ' + lessonId + ' in site ' + siteId);\n      syncPromise = _this3.performSyncLesson(lessonId, askPassword, ignoreBlock, siteId);\n      return _this3.addOngoingSync(lessonId, syncPromise, siteId);\n    })();\n  }\n  /**\n   * Try to synchronize a lesson.\n   *\n   * @param lessonId Lesson ID.\n   * @param askPassword True if we should ask for password if needed, false otherwise.\n   * @param ignoreBlock True to ignore the sync block setting.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success.\n   */\n  performSyncLesson(lessonId, askPassword = false, ignoreBlock = false, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModLessonProvider.COMPONENT, lessonId, siteId));\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Try to synchronize the page attempts first.\n      const passwordData = yield _this4.syncAttempts(lessonId, result, askPassword, siteId);\n      // Now sync the retake.\n      yield _this4.syncRetake(lessonId, result, passwordData, askPassword, ignoreBlock, siteId);\n      if (result.updated && result.courseId) {\n        try {\n          // Data has been sent to server, update data.\n          const module = yield CoreCourse.getModuleBasicInfoByInstance(lessonId, 'lesson', {\n            siteId\n          });\n          yield _this4.prefetchAfterUpdate(AddonModLessonPrefetchHandler.instance, module, result.courseId, undefined, siteId);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n      }\n      // Sync finished, set sync time.\n      yield CoreUtils.ignoreErrors(_this4.setSyncTime(lessonId, siteId));\n      // All done, return the result.\n      return result;\n    })();\n  }\n  /**\n   * Sync all page attempts.\n   *\n   * @param lessonId Lesson ID.\n   * @param result Sync result where to store the result.\n   * @param askPassword True if we should ask for password if needed, false otherwise.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Password result if any.\n   */\n  syncAttempts(lessonId, result, askPassword = false, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      let attempts = yield AddonModLessonOffline.getLessonAttempts(lessonId, siteId);\n      if (!attempts.length) {\n        return;\n      } else if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      result.courseId = attempts[0].courseid;\n      const attemptsLength = attempts.length;\n      // Get the info, access info and the lesson password if needed.\n      const lesson = yield AddonModLesson.getLessonById(result.courseId, lessonId, {\n        siteId\n      });\n      const passwordData = yield AddonModLessonPrefetchHandler.getLessonPassword(lessonId, {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        askPassword,\n        siteId\n      });\n      const promises = [];\n      passwordData.lesson = passwordData.lesson || lesson;\n      // Filter the attempts, get only the ones that belong to the current retake.\n      attempts = attempts.filter(attempt => {\n        if (attempt.retake == passwordData.accessInfo.attemptscount) {\n          return true;\n        }\n        // Attempt doesn't belong to current retake, delete.\n        promises.push(CoreUtils.ignoreErrors(AddonModLessonOffline.deleteAttempt(lesson.id, attempt.retake, attempt.pageid, attempt.timemodified, siteId)));\n        return false;\n      });\n      if (attempts.length != attemptsLength) {\n        // Some attempts won't be sent, add a warning.\n        _this5.addOfflineDataDeletedWarning(result.warnings, lesson.name, Translate.instant('addon.mod_lesson.warningretakefinished'));\n      }\n      yield Promise.all(promises);\n      if (!attempts.length) {\n        return passwordData;\n      }\n      // Send the attempts in the same order they were answered.\n      attempts.sort((a, b) => a.timemodified - b.timemodified);\n      const promisesData = attempts.map(attempt => ({\n        function: () => {\n          var _passwordData$passwor;\n          return _this5.sendAttempt(lesson, (_passwordData$passwor = passwordData.password) !== null && _passwordData$passwor !== void 0 ? _passwordData$passwor : '', attempt, result, siteId);\n        },\n        blocking: true\n      }));\n      yield CoreUtils.executeOrderedPromises(promisesData);\n      return passwordData;\n    })();\n  }\n  /**\n   * Send an attempt to the site and delete it afterwards.\n   *\n   * @param lesson Lesson.\n   * @param password Password (if any).\n   * @param attempt Attempt to send.\n   * @param result Result where to store the data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  sendAttempt(lesson, password, attempt, result, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const retake = attempt.retake;\n      const pageId = attempt.pageid;\n      const timemodified = attempt.timemodified;\n      try {\n        // Send the page data.\n        yield AddonModLesson.processPageOnline(lesson.id, attempt.pageid, attempt.data || {}, {\n          password,\n          siteId\n        });\n        result.updated = true;\n        yield AddonModLessonOffline.deleteAttempt(lesson.id, retake, pageId, timemodified, siteId);\n      } catch (error) {\n        if (!error || !CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server.\n          throw error;\n        }\n        // The WebService has thrown an error, this means that the attempt cannot be submitted. Delete it.\n        result.updated = true;\n        yield AddonModLessonOffline.deleteAttempt(lesson.id, retake, pageId, timemodified, siteId);\n        // Attempt deleted, add a warning.\n        _this6.addOfflineDataDeletedWarning(result.warnings, lesson.name, error);\n      }\n    })();\n  }\n  /**\n   * Sync retake.\n   *\n   * @param lessonId Lesson ID.\n   * @param result Sync result where to store the result.\n   * @param passwordData Password data. If not provided it will be calculated.\n   * @param askPassword True if we should ask for password if needed, false otherwise.\n   * @param ignoreBlock True to ignore the sync block setting.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  syncRetake(lessonId, result, passwordData, askPassword = false, ignoreBlock = false, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      var _passwordData;\n      // Attempts sent or there was none. If there is a finished retake, send it.\n      const retake = yield CoreUtils.ignoreErrors(AddonModLessonOffline.getRetake(lessonId, siteId));\n      if (!retake) {\n        // No retake to sync.\n        return;\n      }\n      if (!retake.finished) {\n        // The retake isn't marked as finished, nothing to send. Delete the retake.\n        yield AddonModLessonOffline.deleteRetake(lessonId, siteId);\n        return;\n      } else if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      result.courseId = retake.courseid || result.courseId;\n      if (!((_passwordData = passwordData) !== null && _passwordData !== void 0 && _passwordData.lesson)) {\n        // Retrieve the needed data.\n        const lesson = yield AddonModLesson.getLessonById(result.courseId, lessonId, {\n          siteId\n        });\n        passwordData = yield AddonModLessonPrefetchHandler.getLessonPassword(lessonId, {\n          readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n          askPassword,\n          siteId\n        });\n        passwordData.lesson = passwordData.lesson || lesson;\n      }\n      if (retake.retake != passwordData.accessInfo.attemptscount) {\n        // The retake changed, add a warning if it isn't there already.\n        if (!result.warnings.length) {\n          _this7.addOfflineDataDeletedWarning(result.warnings, passwordData.lesson.name, Translate.instant('addon.mod_lesson.warningretakefinished'));\n        }\n        yield AddonModLessonOffline.deleteRetake(lessonId, siteId);\n      }\n      try {\n        var _response$data;\n        // All good, finish the retake.\n        const response = yield AddonModLesson.finishRetakeOnline(lessonId, {\n          password: passwordData.password,\n          siteId\n        });\n        result.updated = true;\n        // Mark the retake as finished in a sync if it can be reviewed.\n        if (!ignoreBlock && (_response$data = response.data) !== null && _response$data !== void 0 && _response$data.reviewlesson) {\n          const params = CoreUrlUtils.extractUrlParams(response.data.reviewlesson.value);\n          if (params.pageid) {\n            // The retake can be reviewed, mark it as finished. Don't block the user for this.\n            _this7.setRetakeFinishedInSync(lessonId, retake.retake, Number(params.pageid), siteId);\n          }\n        }\n        yield AddonModLessonOffline.deleteRetake(lessonId, siteId);\n      } catch (error) {\n        if (!error || !CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server.\n          throw error;\n        }\n        // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.\n        result.updated = true;\n        yield AddonModLessonOffline.deleteRetake(lessonId, siteId);\n        // Retake deleted, add a warning.\n        _this7.addOfflineDataDeletedWarning(result.warnings, passwordData.lesson.name, error);\n      }\n    })();\n  }\n}\n_class = AddonModLessonSyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_lesson_autom_synced';\n_class.ɵfac = function AddonModLessonSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModLessonSync = makeSingleton(AddonModLessonSyncProvider);","map":{"version":3,"names":["CoreSyncBlockedError","CoreNetworkError","CoreCourseActivitySyncBaseProvider","CoreCourse","CoreCourseLogHelper","CoreNetwork","CoreSites","CoreSync","CoreTimeUtils","CoreUrlUtils","CoreUtils","makeSingleton","Translate","CoreEvents","RETAKES_FINISHED_SYNC_TABLE_NAME","AddonModLessonPrefetchHandler","AddonModLesson","AddonModLessonProvider","AddonModLessonOffline","AddonModLessonSyncProvider","constructor","componentTranslatableString","deleteRetakeFinishedInSync","lessonId","siteId","_asyncToGenerator","site","getSite","ignoreErrors","getDb","deleteRecords","lessonid","getRetakeFinishedInSync","getRecord","hasDataToSync","retake","hasAttempts","hasFinished","Promise","all","hasRetakeAttempts","hasFinishedRetake","setRetakeFinishedInSync","pageId","insertRecord","Number","pageid","timefinished","timestamp","syncAllLessons","force","syncOnSites","syncAllLessonsFunc","_this","lessons","getAllLessonsWithData","map","_ref","lesson","result","syncLesson","id","syncLessonIfNeeded","updated","trigger","AUTO_SYNCED","warnings","_x","apply","arguments","askPassword","_this2","needed","isSyncNeeded","ignoreBlock","_this3","getCurrentSiteId","syncPromise","getOngoingSync","isBlocked","COMPONENT","logger","debug","instant","$a","componentTranslate","performSyncLesson","addOngoingSync","_this4","syncActivity","passwordData","syncAttempts","syncRetake","courseId","module","getModuleBasicInfoByInstance","prefetchAfterUpdate","instance","undefined","_unused","setSyncTime","_this5","attempts","getLessonAttempts","length","isOnline","courseid","attemptsLength","getLessonById","getLessonPassword","readingStrategy","promises","filter","attempt","accessInfo","attemptscount","push","deleteAttempt","timemodified","addOfflineDataDeletedWarning","name","sort","a","b","promisesData","function","_passwordData$passwor","sendAttempt","password","blocking","executeOrderedPromises","_this6","processPageOnline","data","error","isWebServiceError","_this7","_passwordData","getRetake","finished","deleteRetake","_response$data","response","finishRetakeOnline","reviewlesson","params","extractUrlParams","value","_class","factory","ɵfac","providedIn","AddonModLessonSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/lesson/services/lesson-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModLessonRetakeFinishedInSyncDBRecord, RETAKES_FINISHED_SYNC_TABLE_NAME } from './database/lesson';\nimport { AddonModLessonGetPasswordResult, AddonModLessonPrefetchHandler } from './handlers/prefetch';\nimport { AddonModLesson, AddonModLessonLessonWSData, AddonModLessonProvider } from './lesson';\nimport { AddonModLessonOffline, AddonModLessonPageAttemptRecord } from './lesson-offline';\n\n/**\n * Service to sync lesson.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModLessonSyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModLessonSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_lesson_autom_synced';\n\n    protected componentTranslatableString = 'lesson';\n\n    constructor() {\n        super('AddonModLessonSyncProvider');\n    }\n\n    /**\n     * Unmark a retake as finished in a synchronization.\n     *\n     * @param lessonId Lesson ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteRetakeFinishedInSync(lessonId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        // Ignore errors, maybe there is none.\n        await CoreUtils.ignoreErrors(site.getDb().deleteRecords(RETAKES_FINISHED_SYNC_TABLE_NAME, { lessonid: lessonId }));\n    }\n\n    /**\n     * Get a retake finished in a synchronization for a certain lesson (if any).\n     *\n     * @param lessonId Lesson ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the retake entry (undefined if no retake).\n     */\n    async getRetakeFinishedInSync(\n        lessonId: number,\n        siteId?: string,\n    ): Promise<AddonModLessonRetakeFinishedInSyncDBRecord | undefined> {\n        const site = await CoreSites.getSite(siteId);\n\n        return CoreUtils.ignoreErrors(site.getDb().getRecord(RETAKES_FINISHED_SYNC_TABLE_NAME, { lessonid: lessonId }));\n    }\n\n    /**\n     * Check if a lesson has data to synchronize.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Retake number.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it has data to sync.\n     */\n    async hasDataToSync(lessonId: number, retake: number, siteId?: string): Promise<boolean> {\n\n        const [hasAttempts, hasFinished] = await Promise.all([\n            CoreUtils.ignoreErrors(AddonModLessonOffline.hasRetakeAttempts(lessonId, retake, siteId)),\n            CoreUtils.ignoreErrors(AddonModLessonOffline.hasFinishedRetake(lessonId, siteId)),\n        ]);\n\n        return !!(hasAttempts || hasFinished);\n    }\n\n    /**\n     * Mark a retake as finished in a synchronization.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake The retake number.\n     * @param pageId The page ID to start reviewing from.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async setRetakeFinishedInSync(lessonId: number, retake: number, pageId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().insertRecord(RETAKES_FINISHED_SYNC_TABLE_NAME, <AddonModLessonRetakeFinishedInSyncDBRecord> {\n            lessonid: lessonId,\n            retake: Number(retake),\n            pageid: Number(pageId),\n            timefinished: CoreTimeUtils.timestamp(),\n        });\n    }\n\n    /**\n     * Try to synchronize all the lessons in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllLessons(siteId?: string, force = false): Promise<void> {\n        return this.syncOnSites('all lessons', (siteId) => this.syncAllLessonsFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all lessons on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllLessonsFunc(force: boolean, siteId: string): Promise<void> {\n        // Get all the lessons that have something to be synchronized.\n        const lessons = await AddonModLessonOffline.getAllLessonsWithData(siteId);\n\n        // Sync all lessons that need it.\n        await Promise.all(lessons.map(async (lesson) => {\n            const result = force ?\n                await this.syncLesson(lesson.id, false, false, siteId) :\n                await this.syncLessonIfNeeded(lesson.id, false, siteId);\n\n            if (result?.updated) {\n                // Sync successful, send event.\n                CoreEvents.trigger(AddonModLessonSyncProvider.AUTO_SYNCED, {\n                    lessonId: lesson.id,\n                    warnings: result.warnings,\n                }, siteId);\n            }\n        }));\n    }\n\n    /**\n     * Sync a lesson only if a certain time has passed since the last time.\n     *\n     * @param lessonId Lesson ID.\n     * @param askPassword Whether we should ask for password if needed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the lesson is synced or if it doesn't need to be synced.\n     */\n    async syncLessonIfNeeded(\n        lessonId: number,\n        askPassword = false,\n        siteId?: string,\n    ): Promise<AddonModLessonSyncResult | undefined> {\n        const needed = await this.isSyncNeeded(lessonId, siteId);\n\n        if (needed) {\n            return this.syncLesson(lessonId, askPassword, false, siteId);\n        }\n    }\n\n    /**\n     * Try to synchronize a lesson.\n     *\n     * @param lessonId Lesson ID.\n     * @param askPassword True if we should ask for password if needed, false otherwise.\n     * @param ignoreBlock True to ignore the sync block setting.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success.\n     */\n    async syncLesson(\n        lessonId: number,\n        askPassword = false,\n        ignoreBlock = false,\n        siteId?: string,\n    ): Promise<AddonModLessonSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        let syncPromise = this.getOngoingSync(lessonId, siteId);\n        if (syncPromise) {\n            // There's already a sync ongoing for this lesson, return the promise.\n            return syncPromise;\n        }\n\n        // Verify that lesson isn't blocked.\n        if (!ignoreBlock && CoreSync.isBlocked(AddonModLessonProvider.COMPONENT, lessonId, siteId)) {\n            this.logger.debug('Cannot sync lesson ' + lessonId + ' because it is blocked.');\n\n            throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));\n        }\n\n        this.logger.debug('Try to sync lesson ' + lessonId + ' in site ' + siteId);\n\n        syncPromise = this.performSyncLesson(lessonId, askPassword, ignoreBlock, siteId);\n\n        return this.addOngoingSync(lessonId, syncPromise, siteId);\n    }\n\n    /**\n     * Try to synchronize a lesson.\n     *\n     * @param lessonId Lesson ID.\n     * @param askPassword True if we should ask for password if needed, false otherwise.\n     * @param ignoreBlock True to ignore the sync block setting.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success.\n     */\n    protected async performSyncLesson(\n        lessonId: number,\n        askPassword = false,\n        ignoreBlock = false,\n        siteId?: string,\n    ): Promise<AddonModLessonSyncResult> {\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(\n            CoreCourseLogHelper.syncActivity(AddonModLessonProvider.COMPONENT, lessonId, siteId),\n        );\n\n        const result: AddonModLessonSyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Try to synchronize the page attempts first.\n        const passwordData = await this.syncAttempts(lessonId, result, askPassword, siteId);\n\n        // Now sync the retake.\n        await this.syncRetake(lessonId, result, passwordData, askPassword, ignoreBlock, siteId);\n\n        if (result.updated && result.courseId) {\n            try {\n                // Data has been sent to server, update data.\n                const module = await CoreCourse.getModuleBasicInfoByInstance(lessonId, 'lesson', { siteId });\n                await this.prefetchAfterUpdate(AddonModLessonPrefetchHandler.instance, module, result.courseId, undefined, siteId);\n            } catch {\n                // Ignore errors.\n            }\n        }\n\n        // Sync finished, set sync time.\n        await CoreUtils.ignoreErrors(this.setSyncTime(lessonId, siteId));\n\n        // All done, return the result.\n        return result;\n    }\n\n    /**\n     * Sync all page attempts.\n     *\n     * @param lessonId Lesson ID.\n     * @param result Sync result where to store the result.\n     * @param askPassword True if we should ask for password if needed, false otherwise.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Password result if any.\n     */\n    protected async syncAttempts(\n        lessonId: number,\n        result: AddonModLessonSyncResult,\n        askPassword = false,\n        siteId?: string,\n    ): Promise<AddonModLessonGetPasswordResult | undefined> {\n        let attempts = await AddonModLessonOffline.getLessonAttempts(lessonId, siteId);\n\n        if (!attempts.length) {\n            return;\n        } else if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        result.courseId = attempts[0].courseid;\n        const attemptsLength = attempts.length;\n\n        // Get the info, access info and the lesson password if needed.\n        const lesson = await AddonModLesson.getLessonById(result.courseId, lessonId, { siteId });\n\n        const passwordData = await AddonModLessonPrefetchHandler.getLessonPassword(lessonId, {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            askPassword,\n            siteId,\n        });\n\n        const promises: Promise<void>[] = [];\n        passwordData.lesson = passwordData.lesson || lesson;\n\n        // Filter the attempts, get only the ones that belong to the current retake.\n        attempts = attempts.filter((attempt) => {\n            if (attempt.retake == passwordData.accessInfo.attemptscount) {\n                return true;\n            }\n\n            // Attempt doesn't belong to current retake, delete.\n            promises.push(CoreUtils.ignoreErrors(AddonModLessonOffline.deleteAttempt(\n                lesson.id,\n                attempt.retake,\n                attempt.pageid,\n                attempt.timemodified,\n                siteId,\n            )));\n\n            return false;\n        });\n\n        if (attempts.length != attemptsLength) {\n            // Some attempts won't be sent, add a warning.\n            this.addOfflineDataDeletedWarning(\n                result.warnings,\n                lesson.name,\n                Translate.instant('addon.mod_lesson.warningretakefinished'),\n            );\n\n        }\n\n        await Promise.all(promises);\n\n        if (!attempts.length) {\n            return passwordData;\n        }\n\n        // Send the attempts in the same order they were answered.\n        attempts.sort((a, b) => a.timemodified - b.timemodified);\n\n        const promisesData = attempts.map((attempt) => ({\n            function: () => this.sendAttempt(lesson, passwordData.password ?? '', attempt, result, siteId),\n            blocking: true,\n        }));\n\n        await CoreUtils.executeOrderedPromises(promisesData);\n\n        return passwordData;\n    }\n\n    /**\n     * Send an attempt to the site and delete it afterwards.\n     *\n     * @param lesson Lesson.\n     * @param password Password (if any).\n     * @param attempt Attempt to send.\n     * @param result Result where to store the data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    protected async sendAttempt(\n        lesson: AddonModLessonLessonWSData,\n        password: string,\n        attempt: AddonModLessonPageAttemptRecord,\n        result: AddonModLessonSyncResult,\n        siteId?: string,\n    ): Promise<void> {\n        const retake = attempt.retake;\n        const pageId = attempt.pageid;\n        const timemodified = attempt.timemodified;\n\n        try {\n            // Send the page data.\n            await AddonModLesson.processPageOnline(lesson.id, attempt.pageid, attempt.data || {}, {\n                password,\n                siteId,\n            });\n\n            result.updated = true;\n\n            await AddonModLessonOffline.deleteAttempt(lesson.id, retake, pageId, timemodified, siteId);\n        } catch (error) {\n            if (!error || !CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server.\n                throw error;\n            }\n\n            // The WebService has thrown an error, this means that the attempt cannot be submitted. Delete it.\n            result.updated = true;\n\n            await AddonModLessonOffline.deleteAttempt(lesson.id, retake, pageId, timemodified, siteId);\n\n            // Attempt deleted, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, lesson.name, error);\n        }\n    }\n\n    /**\n     * Sync retake.\n     *\n     * @param lessonId Lesson ID.\n     * @param result Sync result where to store the result.\n     * @param passwordData Password data. If not provided it will be calculated.\n     * @param askPassword True if we should ask for password if needed, false otherwise.\n     * @param ignoreBlock True to ignore the sync block setting.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    protected async syncRetake(\n        lessonId: number,\n        result: AddonModLessonSyncResult,\n        passwordData?: AddonModLessonGetPasswordResult,\n        askPassword = false,\n        ignoreBlock = false,\n        siteId?: string,\n    ): Promise<void> {\n        // Attempts sent or there was none. If there is a finished retake, send it.\n        const retake = await CoreUtils.ignoreErrors(AddonModLessonOffline.getRetake(lessonId, siteId));\n\n        if (!retake) {\n            // No retake to sync.\n            return;\n        }\n\n        if (!retake.finished) {\n            // The retake isn't marked as finished, nothing to send. Delete the retake.\n            await AddonModLessonOffline.deleteRetake(lessonId, siteId);\n\n            return;\n        } else if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        result.courseId = retake.courseid || result.courseId;\n\n        if (!passwordData?.lesson) {\n            // Retrieve the needed data.\n            const lesson = await AddonModLesson.getLessonById(result.courseId!, lessonId, { siteId });\n            passwordData = await AddonModLessonPrefetchHandler.getLessonPassword(lessonId, {\n                readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n                askPassword,\n                siteId,\n            });\n\n            passwordData.lesson = passwordData.lesson || lesson;\n        }\n\n        if (retake.retake != passwordData.accessInfo.attemptscount) {\n            // The retake changed, add a warning if it isn't there already.\n            if (!result.warnings.length) {\n                this.addOfflineDataDeletedWarning(\n                    result.warnings,\n                    passwordData.lesson.name,\n                    Translate.instant('addon.mod_lesson.warningretakefinished'),\n                );\n            }\n\n            await AddonModLessonOffline.deleteRetake(lessonId, siteId);\n        }\n\n        try {\n            // All good, finish the retake.\n            const response = await AddonModLesson.finishRetakeOnline(lessonId, {\n                password: passwordData.password,\n                siteId,\n            });\n\n            result.updated = true;\n\n            // Mark the retake as finished in a sync if it can be reviewed.\n            if (!ignoreBlock && response.data?.reviewlesson) {\n                const params = CoreUrlUtils.extractUrlParams(<string> response.data.reviewlesson.value);\n                if (params.pageid) {\n                    // The retake can be reviewed, mark it as finished. Don't block the user for this.\n                    this.setRetakeFinishedInSync(lessonId, retake.retake, Number(params.pageid), siteId);\n                }\n            }\n\n            await AddonModLessonOffline.deleteRetake(lessonId, siteId);\n        } catch (error) {\n            if (!error || !CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server.\n                throw error;\n            }\n\n            // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.\n            result.updated = true;\n\n            await AddonModLessonOffline.deleteRetake(lessonId, siteId);\n\n            // Retake deleted, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, passwordData.lesson.name, error);\n        }\n    }\n\n}\n\nexport const AddonModLessonSync = makeSingleton(AddonModLessonSyncProvider);\n\n/**\n * Data returned by a lesson sync.\n */\nexport type AddonModLessonSyncResult = CoreSyncResult & {\n    courseId?: number; // Course the lesson belongs to (if known).\n};\n\n/**\n * Data passed to AUTO_SYNCED event.\n */\nexport type AddonModLessonAutoSyncData = {\n    lessonId: number;\n    warnings: string[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}