{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreApp } from '@services/app';\nimport { CoreNetwork } from '@services/network';\nimport { CoreConfig } from '@services/config';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { APP_SCHEMA, CRON_TABLE_NAME } from '@services/database/cron';\nimport { asyncInstance } from '../utils/async-instance';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport * as i0 from \"@angular/core\";\n/*\n * Service to handle cron processes. The registered processes will be executed every certain time.\n*/\nexport class CoreCronDelegateService {\n  // Max time a process can block the queue. Defaults to 2 minutes.\n  constructor() {\n    this.handlers = {};\n    this.queuePromise = Promise.resolve();\n    this.table = asyncInstance();\n    this.logger = CoreLogger.getInstance('CoreCronDelegate');\n  }\n  /**\n   * Initialize database.\n   */\n  initializeDatabase() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield CoreApp.createTablesFromSchema(APP_SCHEMA);\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      const table = new CoreDatabaseTableProxy({\n        cachingStrategy: CoreDatabaseCachingStrategy.Eager\n      }, CoreApp.getDB(), CRON_TABLE_NAME);\n      yield table.initialize();\n      _this.table.setInstance(table);\n    })();\n  }\n  /**\n   * Try to execute a handler. It will schedule the next execution once done.\n   * If the handler cannot be executed or it fails, it will be re-executed after mmCoreCronMinInterval.\n   *\n   * @param name Name of the handler.\n   * @param force Wether the execution is forced (manual sync).\n   * @param siteId Site ID. If not defined, all sites.\n   * @returns Promise resolved if handler is executed successfully, rejected otherwise.\n   */\n  checkAndExecuteHandler(name, force, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.handlers[name] || !_this2.handlers[name].execute) {\n        // Invalid handler.\n        _this2.logger.debug(`Cannot execute cron job because is invalid: ${name}`);\n        throw new CoreError(Translate.instant('core.errorsomethingwrong') + '<br>' + Translate.instant('core.errorsitesupport'));\n      }\n      const usesNetwork = _this2.handlerUsesNetwork(name);\n      const isSync = !force && _this2.isHandlerSync(name);\n      if (usesNetwork && !CoreNetwork.isOnline()) {\n        // Offline, stop executing.\n        _this2.logger.debug(`Cron job failed because your device is not connected to the internet: ${name}`);\n        _this2.stopHandler(name);\n        throw new CoreError(Translate.instant('core.settings.cannotsyncoffline'));\n      }\n      if (isSync) {\n        // Check network connection.\n        const syncOnlyOnWifi = yield CoreConfig.get(CoreConstants.SETTINGS_SYNC_ONLY_ON_WIFI, false);\n        if (syncOnlyOnWifi && !CoreNetwork.isWifi()) {\n          // Cannot execute in this network connection, retry soon.\n          _this2.logger.debug(`Cron job failed because your device has a limited internet connection: ${name}`);\n          _this2.scheduleNextExecution(name, CoreCronDelegateService.MIN_INTERVAL);\n          throw new CoreError(Translate.instant('core.settings.cannotsyncwithoutwifi'));\n        }\n      }\n      // Add the execution to the queue.\n      _this2.queuePromise = CoreUtils.ignoreErrors(_this2.queuePromise).then( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          yield _this2.executeHandler(name, force, siteId);\n          _this2.logger.debug(`Cron job '${name}' was successfully executed.`);\n          yield CoreUtils.ignoreErrors(_this2.setHandlerLastExecutionTime(name, Date.now()));\n          _this2.scheduleNextExecution(name);\n          return;\n        } catch (error) {\n          // Handler call failed. Retry soon.\n          _this2.logger.error(`Cron job '${name}' failed.`, error);\n          _this2.scheduleNextExecution(name, CoreCronDelegateService.MIN_INTERVAL);\n          throw error;\n        }\n      }));\n      return _this2.queuePromise;\n    })();\n  }\n  /**\n   * Run a handler, cancelling the execution if it takes more than MAX_TIME_PROCESS.\n   *\n   * @param name Name of the handler.\n   * @param force Wether the execution is forced (manual sync).\n   * @param siteId Site ID. If not defined, all sites.\n   * @returns Promise resolved when the handler finishes or reaches max time, rejected if it fails.\n   */\n  executeHandler(name, force, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.logger.debug('Executing handler: ' + name);\n      try {\n        var _this3$handlers$name$, _this3$handlers$name;\n        // Wrap the call in Promise.resolve to make sure it's a promise.\n        const promise = Promise.resolve((_this3$handlers$name$ = (_this3$handlers$name = _this3.handlers[name]).execute) === null || _this3$handlers$name$ === void 0 ? void 0 : _this3$handlers$name$.call(_this3$handlers$name, siteId, force));\n        yield CoreUtils.timeoutPromise(promise, CoreCronDelegateService.MAX_TIME_PROCESS);\n      } catch (error) {\n        if (error.timeout) {\n          // The handler took too long. Resolve because we don't want to retry soon.\n          _this3.logger.debug(`Resolving execution of handler '${name}' because it took too long.`);\n          return;\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Force execution of synchronization cron tasks without waiting for the scheduled time.\n   * Please notice that some tasks may not be executed depending on the network connection and sync settings.\n   *\n   * @param siteId Site ID. If not defined, all sites.\n   * @returns Promise resolved if all handlers are executed successfully, rejected otherwise.\n   */\n  forceSyncExecution(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      for (const name in _this4.handlers) {\n        if (_this4.isHandlerManualSync(name)) {\n          // Now force the execution of the handler.\n          promises.push(_this4.forceCronHandlerExecution(name, siteId));\n        }\n      }\n      yield CoreUtils.allPromises(promises);\n    })();\n  }\n  /**\n   * Force execution of a cron tasks without waiting for the scheduled time.\n   * Please notice that some tasks may not be executed depending on the network connection and sync settings.\n   *\n   * @param name Name of the handler.\n   * @param siteId Site ID. If not defined, all sites.\n   * @returns Promise resolved if handler has been executed successfully, rejected otherwise.\n   */\n  forceCronHandlerExecution(name, siteId) {\n    const handler = this.handlers[name];\n    // Mark the handler as running (it might be running already).\n    handler.running = true;\n    // Cancel pending timeout.\n    clearTimeout(handler.timeout);\n    delete handler.timeout;\n    // Now force the execution of the handler.\n    return this.checkAndExecuteHandler(name, true, siteId);\n  }\n  /**\n   * Get a handler's interval.\n   *\n   * @param name Handler's name.\n   * @returns Handler's interval.\n   */\n  getHandlerInterval(name) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var _this5$handlers$name$, _this5$handlers$name;\n      if (_this5.handlers[name] === undefined) {\n        // Invalid, return default.\n        return CoreCronDelegateService.DEFAULT_INTERVAL;\n      }\n      // Don't allow intervals lower than the minimum.\n      const handlerInterval = yield (_this5$handlers$name$ = (_this5$handlers$name = _this5.handlers[name]).getInterval) === null || _this5$handlers$name$ === void 0 ? void 0 : _this5$handlers$name$.call(_this5$handlers$name);\n      if (!handlerInterval) {\n        return CoreCronDelegateService.DEFAULT_INTERVAL;\n      }\n      const minInterval = CoreCronDelegateService.MIN_INTERVAL;\n      return Math.max(minInterval, handlerInterval);\n    })();\n  }\n  /**\n   * Get a handler's last execution ID.\n   *\n   * @param name Handler's name.\n   * @returns Handler's last execution ID.\n   */\n  getHandlerLastExecutionId(name) {\n    return 'last_execution_' + name;\n  }\n  /**\n   * Get a handler's last execution time. If not defined, return 0.\n   *\n   * @param name Handler's name.\n   * @returns Promise resolved with the handler's last execution time.\n   */\n  getHandlerLastExecutionTime(name) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const id = _this6.getHandlerLastExecutionId(name);\n      try {\n        const entry = yield _this6.table.getOneByPrimaryKey({\n          id\n        });\n        const time = Number(entry.value);\n        return isNaN(time) ? 0 : time;\n      } catch (_unused2) {\n        return 0; // Not set, return 0.\n      }\n    })();\n  }\n  /**\n   * Check if a handler uses network. Defaults to true.\n   *\n   * @param name Handler's name.\n   * @returns True if handler uses network or not defined, false otherwise.\n   */\n  handlerUsesNetwork(name) {\n    var _this$handlers$name$u, _this$handlers$name, _this$handlers$name$u2;\n    return (_this$handlers$name$u = (_this$handlers$name = this.handlers[name]) === null || _this$handlers$name === void 0 || (_this$handlers$name$u2 = _this$handlers$name.usesNetwork) === null || _this$handlers$name$u2 === void 0 ? void 0 : _this$handlers$name$u2.call(_this$handlers$name)) !== null && _this$handlers$name$u !== void 0 ? _this$handlers$name$u : true;\n  }\n  /**\n   * Check if there is any manual sync handler registered.\n   *\n   * @returns Whether it has at least 1 manual sync handler.\n   */\n  hasManualSyncHandlers() {\n    for (const name in this.handlers) {\n      if (this.isHandlerManualSync(name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Check if there is any sync handler registered.\n   *\n   * @returns Whether it has at least 1 sync handler.\n   */\n  hasSyncHandlers() {\n    for (const name in this.handlers) {\n      if (this.isHandlerSync(name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Check if a handler can be manually synced. Defaults will use isSync instead.\n   *\n   * @param name Handler's name.\n   * @returns True if handler is a sync process and can be manually executed or not defined, false otherwise.\n   */\n  isHandlerManualSync(name) {\n    var _this$handlers$name$c, _this$handlers$name2, _this$handlers$name2$;\n    return (_this$handlers$name$c = (_this$handlers$name2 = this.handlers[name]) === null || _this$handlers$name2 === void 0 || (_this$handlers$name2$ = _this$handlers$name2.canManualSync) === null || _this$handlers$name2$ === void 0 ? void 0 : _this$handlers$name2$.call(_this$handlers$name2)) !== null && _this$handlers$name$c !== void 0 ? _this$handlers$name$c : this.isHandlerSync(name);\n  }\n  /**\n   * Check if a handler is a sync process. Defaults to true.\n   *\n   * @param name Handler's name.\n   * @returns True if handler is a sync process or not defined, false otherwise.\n   */\n  isHandlerSync(name) {\n    var _this$handlers$name$i, _this$handlers$name3, _this$handlers$name3$;\n    return (_this$handlers$name$i = (_this$handlers$name3 = this.handlers[name]) === null || _this$handlers$name3 === void 0 || (_this$handlers$name3$ = _this$handlers$name3.isSync) === null || _this$handlers$name3$ === void 0 ? void 0 : _this$handlers$name3$.call(_this$handlers$name3)) !== null && _this$handlers$name$i !== void 0 ? _this$handlers$name$i : true;\n  }\n  /**\n   * Register a handler to be executed every certain time.\n   *\n   * @param handler The handler to register.\n   */\n  register(handler) {\n    if (!handler || !handler.name) {\n      // Invalid handler.\n      return;\n    }\n    if (this.handlers[handler.name] !== undefined) {\n      this.logger.debug(`The cron handler '${handler.name}' is already registered.`);\n      return;\n    }\n    this.logger.debug(`Register handler '${handler.name}' in cron.`);\n    handler.running = false;\n    this.handlers[handler.name] = handler;\n    // Start the handler.\n    this.startHandler(handler.name);\n  }\n  /**\n   * Schedule a next execution for a handler.\n   *\n   * @param name Name of the handler.\n   * @param timeToNextExecution Time (in milliseconds). If not supplied it will be calculated.\n   * @returns Promise resolved when done.\n   */\n  scheduleNextExecution(name, timeToNextExecution) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this7.handlers[name]) {\n        // Invalid handler.\n        return;\n      }\n      if (_this7.handlers[name].timeout) {\n        // There's already a pending timeout.\n        return;\n      }\n      if (!timeToNextExecution) {\n        // Get last execution time to check when do we need to execute it.\n        const lastExecution = yield _this7.getHandlerLastExecutionTime(name);\n        const interval = yield _this7.getHandlerInterval(name);\n        timeToNextExecution = lastExecution + interval - Date.now();\n      }\n      _this7.logger.debug(`Scheduling next execution of handler '${name}' in '${timeToNextExecution}' ms`);\n      if (timeToNextExecution < 0) {\n        timeToNextExecution = 0; // Big negative numbers aren't executed immediately.\n      }\n\n      _this7.handlers[name].timeout = window.setTimeout(() => {\n        delete _this7.handlers[name].timeout;\n        CoreUtils.ignoreErrors(_this7.checkAndExecuteHandler(name));\n      }, timeToNextExecution);\n    })();\n  }\n  /**\n   * Set a handler's last execution time.\n   *\n   * @param name Handler's name.\n   * @param time Time to set.\n   * @returns Promise resolved when the execution time is saved.\n   */\n  setHandlerLastExecutionTime(name, time) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const id = _this8.getHandlerLastExecutionId(name);\n      const entry = {\n        id,\n        value: time\n      };\n      yield _this8.table.insert(entry);\n    })();\n  }\n  /**\n   * Start running a handler periodically.\n   *\n   * @param name Name of the handler.\n   */\n  startHandler(name) {\n    if (!this.handlers[name]) {\n      // Invalid handler.\n      this.logger.debug(`Cannot start handler '${name}', is invalid.`);\n      return;\n    }\n    if (this.handlers[name].running) {\n      this.logger.debug(`Handler '${name}', is already running.`);\n      return;\n    }\n    this.handlers[name].running = true;\n    this.scheduleNextExecution(name);\n  }\n  /**\n   * Start running periodically the handlers that use network.\n   */\n  startNetworkHandlers() {\n    for (const name in this.handlers) {\n      if (this.handlerUsesNetwork(name)) {\n        this.startHandler(name);\n      }\n    }\n  }\n  /**\n   * Stop running a handler periodically.\n   *\n   * @param name Name of the handler.\n   */\n  stopHandler(name) {\n    if (!this.handlers[name]) {\n      // Invalid handler.\n      this.logger.debug(`Cannot stop handler '${name}', is invalid.`);\n      return;\n    }\n    if (!this.handlers[name].running) {\n      this.logger.debug(`Cannot stop handler '${name}', it's not running.`);\n      return;\n    }\n    this.handlers[name].running = false;\n    clearTimeout(this.handlers[name].timeout);\n    delete this.handlers[name].timeout;\n  }\n}\n_class = CoreCronDelegateService;\n// Constants.\n_class.DEFAULT_INTERVAL = 3600000;\n// Default interval is 1 hour.\n_class.MIN_INTERVAL = 300000;\n// Minimum interval is 5 minutes.\n_class.MAX_TIME_PROCESS = 120000;\n_class.ɵfac = function CoreCronDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCronDelegate = makeSingleton(CoreCronDelegateService);","map":{"version":3,"names":["CoreApp","CoreNetwork","CoreConfig","CoreUtils","CoreConstants","CoreError","makeSingleton","Translate","CoreLogger","APP_SCHEMA","CRON_TABLE_NAME","asyncInstance","CoreDatabaseCachingStrategy","CoreDatabaseTableProxy","CoreCronDelegateService","constructor","handlers","queuePromise","Promise","resolve","table","logger","getInstance","initializeDatabase","_this","_asyncToGenerator","createTablesFromSchema","_unused","cachingStrategy","Eager","getDB","initialize","setInstance","checkAndExecuteHandler","name","force","siteId","_this2","execute","debug","instant","usesNetwork","handlerUsesNetwork","isSync","isHandlerSync","isOnline","stopHandler","syncOnlyOnWifi","get","SETTINGS_SYNC_ONLY_ON_WIFI","isWifi","scheduleNextExecution","MIN_INTERVAL","ignoreErrors","then","executeHandler","setHandlerLastExecutionTime","Date","now","error","_this3","_this3$handlers$name$","_this3$handlers$name","promise","call","timeoutPromise","MAX_TIME_PROCESS","timeout","forceSyncExecution","_this4","promises","isHandlerManualSync","push","forceCronHandlerExecution","allPromises","handler","running","clearTimeout","getHandlerInterval","_this5","_this5$handlers$name$","_this5$handlers$name","undefined","DEFAULT_INTERVAL","handlerInterval","getInterval","minInterval","Math","max","getHandlerLastExecutionId","getHandlerLastExecutionTime","_this6","id","entry","getOneByPrimaryKey","time","Number","value","isNaN","_unused2","_this$handlers$name$u","_this$handlers$name","_this$handlers$name$u2","hasManualSyncHandlers","hasSyncHandlers","_this$handlers$name$c","_this$handlers$name2","_this$handlers$name2$","canManualSync","_this$handlers$name$i","_this$handlers$name3","_this$handlers$name3$","register","startHandler","timeToNextExecution","_this7","lastExecution","interval","window","setTimeout","_this8","insert","startNetworkHandlers","_class","factory","ɵfac","providedIn","CoreCronDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/cron.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreApp } from '@services/app';\nimport { CoreNetwork } from '@services/network';\nimport { CoreConfig } from '@services/config';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\n\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { APP_SCHEMA, CRON_TABLE_NAME, CronDBEntry } from '@services/database/cron';\nimport { asyncInstance } from '../utils/async-instance';\nimport { CoreDatabaseTable } from '@classes/database/database-table';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\n\n/*\n * Service to handle cron processes. The registered processes will be executed every certain time.\n*/\n@Injectable({ providedIn: 'root' })\nexport class CoreCronDelegateService {\n\n    // Constants.\n    static readonly DEFAULT_INTERVAL = 3600000; // Default interval is 1 hour.\n    static readonly MIN_INTERVAL = 300000; // Minimum interval is 5 minutes.\n    static readonly MAX_TIME_PROCESS = 120000; // Max time a process can block the queue. Defaults to 2 minutes.\n\n    protected logger: CoreLogger;\n    protected handlers: { [s: string]: CoreCronHandler } = {};\n    protected queuePromise: Promise<void> = Promise.resolve();\n    protected table = asyncInstance<CoreDatabaseTable<CronDBEntry>>();\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreCronDelegate');\n    }\n\n    /**\n     * Initialize database.\n     */\n    async initializeDatabase(): Promise<void> {\n        try {\n            await CoreApp.createTablesFromSchema(APP_SCHEMA);\n        } catch {\n            // Ignore errors.\n        }\n\n        const table = new CoreDatabaseTableProxy<CronDBEntry>(\n            { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            CoreApp.getDB(),\n            CRON_TABLE_NAME,\n        );\n\n        await table.initialize();\n\n        this.table.setInstance(table);\n    }\n\n    /**\n     * Try to execute a handler. It will schedule the next execution once done.\n     * If the handler cannot be executed or it fails, it will be re-executed after mmCoreCronMinInterval.\n     *\n     * @param name Name of the handler.\n     * @param force Wether the execution is forced (manual sync).\n     * @param siteId Site ID. If not defined, all sites.\n     * @returns Promise resolved if handler is executed successfully, rejected otherwise.\n     */\n    protected async checkAndExecuteHandler(name: string, force?: boolean, siteId?: string): Promise<void> {\n        if (!this.handlers[name] || !this.handlers[name].execute) {\n            // Invalid handler.\n            this.logger.debug(`Cannot execute cron job because is invalid: ${name}`);\n\n            throw new CoreError(\n                Translate.instant('core.errorsomethingwrong') + '<br>' + Translate.instant('core.errorsitesupport'),\n            );\n        }\n\n        const usesNetwork = this.handlerUsesNetwork(name);\n        const isSync = !force && this.isHandlerSync(name);\n\n        if (usesNetwork && !CoreNetwork.isOnline()) {\n            // Offline, stop executing.\n            this.logger.debug(`Cron job failed because your device is not connected to the internet: ${name}`);\n            this.stopHandler(name);\n\n            throw new CoreError(Translate.instant('core.settings.cannotsyncoffline'));\n        }\n\n        if (isSync) {\n            // Check network connection.\n            const syncOnlyOnWifi = await CoreConfig.get(CoreConstants.SETTINGS_SYNC_ONLY_ON_WIFI, false);\n\n            if (syncOnlyOnWifi && !CoreNetwork.isWifi()) {\n                // Cannot execute in this network connection, retry soon.\n                this.logger.debug(`Cron job failed because your device has a limited internet connection: ${name}`);\n                this.scheduleNextExecution(name, CoreCronDelegateService.MIN_INTERVAL);\n\n                throw new CoreError(Translate.instant('core.settings.cannotsyncwithoutwifi'));\n            }\n        }\n\n        // Add the execution to the queue.\n        this.queuePromise = CoreUtils.ignoreErrors(this.queuePromise).then(async () => {\n            try {\n                await this.executeHandler(name, force, siteId);\n\n                this.logger.debug(`Cron job '${name}' was successfully executed.`);\n\n                await CoreUtils.ignoreErrors(this.setHandlerLastExecutionTime(name, Date.now()));\n\n                this.scheduleNextExecution(name);\n\n                return;\n            } catch (error) {\n                // Handler call failed. Retry soon.\n                this.logger.error(`Cron job '${name}' failed.`, error);\n                this.scheduleNextExecution(name, CoreCronDelegateService.MIN_INTERVAL);\n\n                throw error;\n            }\n        });\n\n        return this.queuePromise;\n    }\n\n    /**\n     * Run a handler, cancelling the execution if it takes more than MAX_TIME_PROCESS.\n     *\n     * @param name Name of the handler.\n     * @param force Wether the execution is forced (manual sync).\n     * @param siteId Site ID. If not defined, all sites.\n     * @returns Promise resolved when the handler finishes or reaches max time, rejected if it fails.\n     */\n    protected async executeHandler(name: string, force?: boolean, siteId?: string): Promise<void> {\n        this.logger.debug('Executing handler: ' + name);\n\n        try {\n            // Wrap the call in Promise.resolve to make sure it's a promise.\n            const promise = Promise.resolve(this.handlers[name].execute?.(siteId, force));\n\n            await CoreUtils.timeoutPromise(promise, CoreCronDelegateService.MAX_TIME_PROCESS);\n        } catch (error) {\n            if (error.timeout) {\n                // The handler took too long. Resolve because we don't want to retry soon.\n                this.logger.debug(`Resolving execution of handler '${name}' because it took too long.`);\n\n                return;\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Force execution of synchronization cron tasks without waiting for the scheduled time.\n     * Please notice that some tasks may not be executed depending on the network connection and sync settings.\n     *\n     * @param siteId Site ID. If not defined, all sites.\n     * @returns Promise resolved if all handlers are executed successfully, rejected otherwise.\n     */\n    async forceSyncExecution(siteId?: string): Promise<void> {\n        const promises: Promise<void>[] = [];\n\n        for (const name in this.handlers) {\n            if (this.isHandlerManualSync(name)) {\n                // Now force the execution of the handler.\n                promises.push(this.forceCronHandlerExecution(name, siteId));\n            }\n        }\n\n        await CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Force execution of a cron tasks without waiting for the scheduled time.\n     * Please notice that some tasks may not be executed depending on the network connection and sync settings.\n     *\n     * @param name Name of the handler.\n     * @param siteId Site ID. If not defined, all sites.\n     * @returns Promise resolved if handler has been executed successfully, rejected otherwise.\n     */\n    forceCronHandlerExecution(name: string, siteId?: string): Promise<void> {\n        const handler = this.handlers[name];\n\n        // Mark the handler as running (it might be running already).\n        handler.running = true;\n\n        // Cancel pending timeout.\n        clearTimeout(handler.timeout);\n        delete handler.timeout;\n\n        // Now force the execution of the handler.\n        return this.checkAndExecuteHandler(name, true, siteId);\n    }\n\n    /**\n     * Get a handler's interval.\n     *\n     * @param name Handler's name.\n     * @returns Handler's interval.\n     */\n    protected async getHandlerInterval(name: string): Promise<number> {\n        if (this.handlers[name] === undefined) {\n            // Invalid, return default.\n            return CoreCronDelegateService.DEFAULT_INTERVAL;\n        }\n\n        // Don't allow intervals lower than the minimum.\n        const handlerInterval = await this.handlers[name].getInterval?.();\n\n        if (!handlerInterval) {\n            return CoreCronDelegateService.DEFAULT_INTERVAL;\n        }\n\n        const minInterval = CoreCronDelegateService.MIN_INTERVAL;\n\n        return Math.max(minInterval, handlerInterval);\n    }\n\n    /**\n     * Get a handler's last execution ID.\n     *\n     * @param name Handler's name.\n     * @returns Handler's last execution ID.\n     */\n    protected getHandlerLastExecutionId(name: string): string {\n        return 'last_execution_' + name;\n    }\n\n    /**\n     * Get a handler's last execution time. If not defined, return 0.\n     *\n     * @param name Handler's name.\n     * @returns Promise resolved with the handler's last execution time.\n     */\n    protected async getHandlerLastExecutionTime(name: string): Promise<number> {\n        const id = this.getHandlerLastExecutionId(name);\n\n        try {\n            const entry = await this.table.getOneByPrimaryKey({ id });\n\n            const time = Number(entry.value);\n\n            return isNaN(time) ? 0 : time;\n        } catch {\n            return 0; // Not set, return 0.\n        }\n    }\n\n    /**\n     * Check if a handler uses network. Defaults to true.\n     *\n     * @param name Handler's name.\n     * @returns True if handler uses network or not defined, false otherwise.\n     */\n    protected handlerUsesNetwork(name: string): boolean {\n        return this.handlers[name]?.usesNetwork?.() ?? true;\n    }\n\n    /**\n     * Check if there is any manual sync handler registered.\n     *\n     * @returns Whether it has at least 1 manual sync handler.\n     */\n    hasManualSyncHandlers(): boolean {\n        for (const name in this.handlers) {\n            if (this.isHandlerManualSync(name)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if there is any sync handler registered.\n     *\n     * @returns Whether it has at least 1 sync handler.\n     */\n    hasSyncHandlers(): boolean {\n        for (const name in this.handlers) {\n            if (this.isHandlerSync(name)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if a handler can be manually synced. Defaults will use isSync instead.\n     *\n     * @param name Handler's name.\n     * @returns True if handler is a sync process and can be manually executed or not defined, false otherwise.\n     */\n    protected isHandlerManualSync(name: string): boolean {\n        return this.handlers[name]?.canManualSync?.() ?? this.isHandlerSync(name);\n    }\n\n    /**\n     * Check if a handler is a sync process. Defaults to true.\n     *\n     * @param name Handler's name.\n     * @returns True if handler is a sync process or not defined, false otherwise.\n     */\n    protected isHandlerSync(name: string): boolean {\n        return this.handlers[name]?.isSync?.() ?? true;\n    }\n\n    /**\n     * Register a handler to be executed every certain time.\n     *\n     * @param handler The handler to register.\n     */\n    register(handler: CoreCronHandler): void {\n        if (!handler || !handler.name) {\n            // Invalid handler.\n            return;\n        }\n        if (this.handlers[handler.name] !== undefined) {\n            this.logger.debug(`The cron handler '${handler.name}' is already registered.`);\n\n            return;\n        }\n\n        this.logger.debug(`Register handler '${handler.name}' in cron.`);\n\n        handler.running = false;\n        this.handlers[handler.name] = handler;\n\n        // Start the handler.\n        this.startHandler(handler.name);\n    }\n\n    /**\n     * Schedule a next execution for a handler.\n     *\n     * @param name Name of the handler.\n     * @param timeToNextExecution Time (in milliseconds). If not supplied it will be calculated.\n     * @returns Promise resolved when done.\n     */\n    protected async scheduleNextExecution(name: string, timeToNextExecution?: number): Promise<void> {\n        if (!this.handlers[name]) {\n            // Invalid handler.\n            return;\n        }\n        if (this.handlers[name].timeout) {\n            // There's already a pending timeout.\n            return;\n        }\n\n        if (!timeToNextExecution) {\n            // Get last execution time to check when do we need to execute it.\n            const lastExecution = await this.getHandlerLastExecutionTime(name);\n            const interval = await this.getHandlerInterval(name);\n\n            timeToNextExecution = lastExecution + interval - Date.now();\n        }\n\n        this.logger.debug(`Scheduling next execution of handler '${name}' in '${timeToNextExecution}' ms`);\n        if (timeToNextExecution < 0) {\n            timeToNextExecution = 0; // Big negative numbers aren't executed immediately.\n        }\n\n        this.handlers[name].timeout = window.setTimeout(() => {\n            delete this.handlers[name].timeout;\n            CoreUtils.ignoreErrors(this.checkAndExecuteHandler(name));\n        }, timeToNextExecution);\n    }\n\n    /**\n     * Set a handler's last execution time.\n     *\n     * @param name Handler's name.\n     * @param time Time to set.\n     * @returns Promise resolved when the execution time is saved.\n     */\n    protected async setHandlerLastExecutionTime(name: string, time: number): Promise<void> {\n        const id = this.getHandlerLastExecutionId(name);\n        const entry = {\n            id,\n            value: time,\n        };\n\n        await this.table.insert(entry);\n    }\n\n    /**\n     * Start running a handler periodically.\n     *\n     * @param name Name of the handler.\n     */\n    protected startHandler(name: string): void {\n        if (!this.handlers[name]) {\n            // Invalid handler.\n            this.logger.debug(`Cannot start handler '${name}', is invalid.`);\n\n            return;\n        }\n\n        if (this.handlers[name].running) {\n            this.logger.debug(`Handler '${name}', is already running.`);\n\n            return;\n        }\n\n        this.handlers[name].running = true;\n\n        this.scheduleNextExecution(name);\n    }\n\n    /**\n     * Start running periodically the handlers that use network.\n     */\n    startNetworkHandlers(): void {\n        for (const name in this.handlers) {\n            if (this.handlerUsesNetwork(name)) {\n                this.startHandler(name);\n            }\n        }\n    }\n\n    /**\n     * Stop running a handler periodically.\n     *\n     * @param name Name of the handler.\n     */\n    protected stopHandler(name: string): void {\n        if (!this.handlers[name]) {\n            // Invalid handler.\n            this.logger.debug(`Cannot stop handler '${name}', is invalid.`);\n\n            return;\n        }\n\n        if (!this.handlers[name].running) {\n            this.logger.debug(`Cannot stop handler '${name}', it's not running.`);\n\n            return;\n        }\n\n        this.handlers[name].running = false;\n        clearTimeout(this.handlers[name].timeout);\n        delete this.handlers[name].timeout;\n    }\n\n}\n\nexport const CoreCronDelegate = makeSingleton(CoreCronDelegateService);\n\n/**\n * Interface that all cron handlers must implement.\n */\nexport interface CoreCronHandler {\n    /**\n     * A name to identify the handler.\n     */\n    name: string;\n\n    /**\n     * Whether the handler is running. Used internally by the provider, there's no need to set it.\n     */\n    running?: boolean;\n\n    /**\n     * Timeout ID for the handler scheduling. Used internally by the provider, there's no need to set it.\n     */\n    timeout?: number;\n\n    /**\n     * Returns handler's interval in milliseconds. Defaults to CoreCronDelegateService.DEFAULT_INTERVAL.\n     *\n     * @returns Interval time (in milliseconds).\n     */\n    getInterval?(): number | Promise<number>;\n\n    /**\n     * Check whether the process uses network or not. True if not defined.\n     *\n     * @returns Whether the process uses network or not\n     */\n    usesNetwork?(): boolean;\n\n    /**\n     * Check whether it's a synchronization process or not. True if not defined.\n     *\n     * @returns Whether it's a synchronization process or not.\n     */\n    isSync?(): boolean;\n\n    /**\n     * Check whether the sync can be executed manually. Call isSync if not defined.\n     *\n     * @returns Whether the sync can be executed manually.\n     */\n    canManualSync?(): boolean;\n\n    /**\n     * Execute the process.\n     *\n     * @param siteId ID of the site affected. If not defined, all sites.\n     * @param force Determines if it's a forced execution.\n     * @returns Promise resolved when done. If the promise is rejected, this function will be called again often,\n     *         it shouldn't be abused.\n     */\n    execute?(siteId?: string, force?: boolean): Promise<void>;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}