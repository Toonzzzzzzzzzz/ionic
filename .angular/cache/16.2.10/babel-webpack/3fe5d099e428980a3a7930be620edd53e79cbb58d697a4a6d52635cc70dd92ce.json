{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile, CoreFileProvider } from '@services/file';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate, Camera, ActionSheetController } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreFileUploader, CoreFileUploaderProvider } from './fileuploader';\nimport { CoreFileUploaderDelegate } from './fileuploader-delegate';\nimport { CAPTURE_ERROR_NO_MEDIA_FILES } from '@classes/errors/captureerror';\nimport { CoreSites } from '@services/sites';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { Chooser } from '@features/native/plugins';\nimport * as i0 from \"@angular/core\";\n/**\n * Helper service to upload files.\n */\nexport class CoreFileUploaderHelperProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('CoreFileUploaderHelperProvider');\n  }\n  /**\n   * Choose any type of file and upload it.\n   *\n   * @param maxSize Max size of the upload. -1 for no max size.\n   * @param upload True if the file should be uploaded, false to return the picked file.\n   * @param allowOffline True to allow uploading in offline.\n   * @returns Promise resolved when done.\n   */\n  chooseAndUploadFile(maxSize, upload, allowOffline, mimetypes) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const modal = yield CoreDomUtils.showModalLoading();\n      const result = yield Chooser.getFileMetadata(mimetypes ? mimetypes.join(',') : undefined);\n      modal.dismiss();\n      if (!result) {\n        // User canceled.\n        throw new CoreCanceledError();\n      }\n      if (result.name == 'File') {\n        // In some Android 4.4 devices the file name cannot be retrieved. Try to use the one from the URI.\n        result.name = _this.getChosenFileNameFromPath(result) || result.name;\n      }\n      // Verify that the mimetype is supported.\n      const error = CoreFileUploader.isInvalidMimetype(mimetypes, result.name, result.mediaType);\n      if (error) {\n        throw new CoreError(error);\n      }\n      const options = CoreFileUploader.getFileUploadOptions(result.uri, result.name, result.mediaType, true);\n      if (upload) {\n        return _this.uploadFile(result.uri, maxSize || -1, true, options);\n      } else {\n        return _this.copyToTmpFolder(result.uri, false, maxSize, undefined, options);\n      }\n    })();\n  }\n  /**\n   * Show a confirmation modal to the user if the size of the file is bigger than the allowed threshold.\n   *\n   * @param size File size.\n   * @param alwaysConfirm True to show a confirm even if the size isn't high.\n   * @param allowOffline True to allow uploading in offline.\n   * @param wifiThreshold Threshold for WiFi connection. Default: CoreFileUploaderProvider.WIFI_SIZE_WARNING.\n   * @param limitedThreshold Threshold for limited connection. Default: CoreFileUploaderProvider.LIMITED_SIZE_WARNING.\n   * @returns Promise resolved when the user confirms or if there's no need to show a modal.\n   */\n  confirmUploadFile(size, alwaysConfirm, allowOffline, wifiThreshold, limitedThreshold) {\n    return _asyncToGenerator(function* () {\n      if (size == 0) {\n        return;\n      }\n      if (!allowOffline && !CoreNetwork.isOnline()) {\n        throw new CoreError(Translate.instant('core.fileuploader.errormustbeonlinetoupload'));\n      }\n      wifiThreshold = wifiThreshold === undefined ? CoreFileUploaderProvider.WIFI_SIZE_WARNING : wifiThreshold;\n      limitedThreshold = limitedThreshold === undefined ? CoreFileUploaderProvider.LIMITED_SIZE_WARNING : limitedThreshold;\n      if (size < 0) {\n        return CoreDomUtils.showConfirm(Translate.instant('core.fileuploader.confirmuploadunknownsize'));\n      } else if (size >= wifiThreshold || CoreNetwork.isNetworkAccessLimited() && size >= limitedThreshold) {\n        const readableSize = CoreTextUtils.bytesToSize(size, 2);\n        return CoreDomUtils.showConfirm(Translate.instant('core.fileuploader.confirmuploadfile', {\n          size: readableSize\n        }));\n      } else if (alwaysConfirm) {\n        return CoreDomUtils.showConfirm(Translate.instant('core.areyousure'));\n      }\n    })();\n  }\n  /**\n   * Create a temporary copy of a file and upload it.\n   *\n   * @param file File to copy and upload.\n   * @param upload True if the file should be uploaded, false to return the copy of the file.\n   * @param name Name to use when uploading the file. If not defined, use the file's name.\n   * @returns Promise resolved when the file is uploaded.\n   */\n  copyAndUploadFile(file, upload, name) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      name = name || file.name;\n      const modal = yield CoreDomUtils.showModalLoading('core.fileuploader.readingfile', true);\n      let fileEntry;\n      try {\n        // Get unique name for the copy.\n        const newName = yield CoreFile.getUniqueNameInFolder(CoreFileProvider.TMPFOLDER, name);\n        const filePath = CorePath.concatenatePaths(CoreFileProvider.TMPFOLDER, newName);\n        // Write the data into the file.\n        fileEntry = yield CoreFile.writeFileDataInFile(file, filePath, progress => _this2.showProgressModal(modal, 'core.fileuploader.readingfileperc', progress));\n      } catch (error) {\n        _this2.logger.error('Error reading file to upload.', error);\n        modal.dismiss();\n        throw error;\n      }\n      modal.dismiss();\n      if (upload) {\n        // Pass true to delete the copy after the upload.\n        return _this2.uploadGenericFile(fileEntry.toURL(), name, file.type, true);\n      } else {\n        return fileEntry;\n      }\n    })();\n  }\n  /**\n   * Copy or move a file to the app temporary folder.\n   *\n   * @param path Path of the file.\n   * @param shouldDelete True if original file should be deleted (move), false otherwise (copy).\n   * @param maxSize Max size of the file. If not defined or -1, no max size.\n   * @param defaultExt Defaut extension to use if the file doesn't have any.\n   * @returns Promise resolved with the copied file.\n   */\n  copyToTmpFolder(path, shouldDelete, maxSize, defaultExt, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const fileName = (options === null || options === void 0 ? void 0 : options.fileName) || CoreFile.getFileAndDirectoryFromPath(path).name;\n      // Check that size isn't too large.\n      if (maxSize !== undefined && maxSize != -1) {\n        const fileEntry = yield CoreFile.getExternalFile(path);\n        const fileData = yield CoreFile.getFileObjectFromFileEntry(fileEntry);\n        if (fileData.size > maxSize) {\n          throw _this3.createMaxBytesError(maxSize, fileEntry.name);\n        }\n      }\n      // File isn't too large.\n      // Get a unique name in the folder to prevent overriding another file.\n      const newName = yield CoreFile.getUniqueNameInFolder(CoreFileProvider.TMPFOLDER, fileName, defaultExt);\n      // Now move or copy the file.\n      const destPath = CorePath.concatenatePaths(CoreFileProvider.TMPFOLDER, newName);\n      if (shouldDelete) {\n        return CoreFile.moveExternalFile(path, destPath);\n      } else {\n        return CoreFile.copyExternalFile(path, destPath);\n      }\n    })();\n  }\n  /**\n   * Function called when trying to upload a file bigger than max size. Creates an error instance.\n   *\n   * @param maxSize Max size (bytes).\n   * @param fileName Name of the file.\n   * @returns Message.\n   */\n  createMaxBytesError(maxSize, fileName) {\n    return new CoreError(Translate.instant('core.fileuploader.maxbytesfile', {\n      $a: {\n        file: fileName,\n        size: CoreTextUtils.bytesToSize(maxSize, 2)\n      }\n    }));\n  }\n  /**\n   * Function called when the file picker is closed.\n   */\n  filePickerClosed() {\n    if (this.filePickerDeferred) {\n      this.filePickerDeferred.reject(new CoreCanceledError());\n      this.filePickerDeferred = undefined;\n    }\n  }\n  /**\n   * Function to call once a file is uploaded using the file picker.\n   *\n   * @param result Result of the upload process.\n   */\n  fileUploaded(result) {\n    var _this$actionSheet;\n    if (this.filePickerDeferred) {\n      this.filePickerDeferred.resolve(result);\n      this.filePickerDeferred = undefined;\n    }\n    // Close the action sheet if it's opened.\n    (_this$actionSheet = this.actionSheet) === null || _this$actionSheet === void 0 || _this$actionSheet.dismiss();\n  }\n  /**\n   * Given the result of choosing a file, try to get its file name from the path.\n   *\n   * @param result Chosen file data.\n   * @returns File name, undefined if cannot get it.\n   */\n  getChosenFileNameFromPath(result) {\n    const nameAndDir = CoreFile.getFileAndDirectoryFromPath(result.uri);\n    if (!nameAndDir.name) {\n      return;\n    }\n    let extension = CoreMimetypeUtils.getFileExtension(nameAndDir.name);\n    if (!extension) {\n      // The URI doesn't have an extension, add it now.\n      extension = CoreMimetypeUtils.getExtension(result.mediaType);\n      if (extension) {\n        nameAndDir.name += '.' + extension;\n      }\n    }\n    return decodeURIComponent(nameAndDir.name);\n  }\n  /**\n   * Open the \"file picker\" to select and upload a file.\n   *\n   * @param maxSize Max size of the file to upload. If not defined or -1, no max size.\n   * @param title File picker title.\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @returns Promise resolved when a file is uploaded, rejected if file picker is closed without a file uploaded.\n   *         The resolve value is the response of the upload request.\n   */\n  selectAndUploadFile(maxSize, title, mimetypes) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this4.selectFileWithPicker(maxSize, false, title, mimetypes, true);\n    })();\n  }\n  /**\n   * Open the \"file picker\" to select a file without uploading it.\n   *\n   * @param maxSize Max size of the file. If not defined or -1, no max size.\n   * @param allowOffline True to allow selecting in offline, false to require connection.\n   * @param title File picker title.\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @returns Promise resolved when a file is selected, rejected if file picker is closed without selecting a file.\n   *         The resolve value is the FileEntry of a copy of the picked file, so it can be deleted afterwards.\n   */\n  selectFile(maxSize, allowOffline, title, mimetypes) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this5.selectFileWithPicker(maxSize, allowOffline, title, mimetypes, false);\n    })();\n  }\n  /**\n   * Open the \"file picker\" to select a file and maybe uploading it.\n   *\n   * @param maxSize Max size of the file. If not defined or -1, no max size.\n   * @param allowOffline True to allow selecting in offline, false to require connection.\n   * @param title File picker title.\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @param upload Whether the file should be uploaded.\n   * @returns Promise resolved when a file is selected/uploaded, rejected if file picker is closed.\n   */\n  selectFileWithPicker(maxSize, allowOffline, title, mimetypes, upload) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // Create the cancel button and get the handlers to upload the file.\n      const buttons = [{\n        text: Translate.instant('core.cancel'),\n        role: 'cancel',\n        handler: () => {\n          // User cancelled the action sheet.\n          _this6.filePickerClosed();\n        }\n      }];\n      const handlers = CoreFileUploaderDelegate.getHandlers(mimetypes);\n      _this6.filePickerDeferred = new CorePromisedValue();\n      // Create a button for each handler.\n      handlers.forEach(handler => {\n        buttons.push({\n          text: Translate.instant(handler.title),\n          icon: handler.icon,\n          cssClass: handler.class,\n          handler: function () {\n            var _ref = _asyncToGenerator(function* () {\n              if (!handler.action) {\n                // Nothing to do.\n                return false;\n              }\n              if (!allowOffline && !CoreNetwork.isOnline()) {\n                // Not allowed, show error.\n                CoreDomUtils.showErrorModal('core.fileuploader.errormustbeonlinetoupload', true);\n                return false;\n              }\n              try {\n                const data = yield handler.action(maxSize, upload, allowOffline, handler.mimetypes);\n                let result;\n                if (data.treated) {\n                  // The handler already treated the file. Return the result.\n                  result = data.result;\n                } else if (data.fileEntry) {\n                  // The handler provided us a fileEntry, use it.\n                  result = yield _this6.uploadFileEntry(data.fileEntry, !!data.delete, maxSize, upload, allowOffline);\n                } else if (data.path) {\n                  let fileEntry;\n                  try {\n                    // The handler provided a path. First treat it like it's a relative path.\n                    fileEntry = yield CoreFile.getFile(data.path);\n                  } catch (error) {\n                    // File not found, it's probably an absolute path.\n                    fileEntry = yield CoreFile.getExternalFile(data.path);\n                  }\n                  // File found, treat it.\n                  result = yield _this6.uploadFileEntry(fileEntry, !!data.delete, maxSize, upload, allowOffline);\n                }\n                if (!result) {\n                  // Nothing received, fail.\n                  throw new CoreError('No file received');\n                }\n                _this6.fileUploaded(result);\n                return true;\n              } catch (error) {\n                CoreDomUtils.showErrorModalDefault(error, Translate.instant('core.fileuploader.errorreadingfile'));\n                return false;\n              }\n            });\n            return function handler() {\n              return _ref.apply(this, arguments);\n            };\n          }()\n        });\n      });\n      _this6.actionSheet = yield ActionSheetController.create({\n        header: title ? title : Translate.instant('core.fileuploader.' + (upload ? 'uploadafile' : 'selectafile')),\n        buttons: buttons\n      });\n      yield _this6.actionSheet.present();\n      // Call afterRender for each button.\n      setTimeout(() => {\n        handlers.forEach(handler => {\n          if (handler.afterRender) {\n            handler.afterRender(maxSize, upload, allowOffline, handler.mimetypes);\n          }\n        });\n      }, 500);\n      return _this6.filePickerDeferred;\n    })();\n  }\n  /**\n   * Convenience function to upload a file on a certain site, showing a confirm if needed.\n   *\n   * @param fileEntry FileEntry of the file to upload.\n   * @param deleteAfterUpload Whether the file should be deleted after upload.\n   * @param siteId Id of the site to upload the file to. If not defined, use current site.\n   * @returns Promise resolved when the file is uploaded.\n   */\n  showConfirmAndUploadInSite(fileEntry, deleteAfterUpload, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const file = yield CoreFile.getFileObjectFromFileEntry(fileEntry);\n        yield _this7.confirmUploadFile(file.size);\n        yield _this7.uploadGenericFile(fileEntry.toURL(), file.name, file.type, deleteAfterUpload, siteId);\n        CoreDomUtils.showToast('core.fileuploader.fileuploaded', true, undefined, 'core-toast-success');\n      } catch (error) {\n        CoreDomUtils.showErrorModalDefault(error, 'core.fileuploader.errorreadingfile', true);\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Treat a capture audio/video error.\n   *\n   * @param error Error returned by the Cordova plugin.\n   * @param defaultMessage Key of the default message to show.\n   */\n  treatCaptureError(error, defaultMessage) {\n    // Cancelled or error. If cancelled, error is an object with code = CAPTURE_EROR_NO_MEDIA_FILES.\n    if (error) {\n      if (error.code !== CAPTURE_ERROR_NO_MEDIA_FILES) {\n        // Error, not cancelled.\n        this.logger.error('Error while recording audio/video', error);\n        const message = this.isNoAppError(error) ? Translate.instant('core.fileuploader.errornoapp') : error.message || Translate.instant(defaultMessage);\n        throw new CoreError(message);\n      } else {\n        throw new CoreCanceledError();\n      }\n    }\n    throw new CoreError('Error capturing media');\n  }\n  /**\n   * Check if a capture error is because there is no app to capture.\n   *\n   * @param error Error.\n   * @returns Whether it's because there is no app.\n   */\n  isNoAppError(error) {\n    return error && error.code == 20;\n  }\n  /**\n   * Treat a capture image or browse album error.\n   *\n   * @param error Error returned by the Cordova plugin.\n   * @param defaultMessage Key of the default message to show.\n   * @returns Rejected promise. If it doesn't have an error message it means it was cancelled.\n   */\n  treatImageError(error, defaultMessage) {\n    // Cancelled or error.\n    if (!error || typeof error == 'number') {\n      return new CoreError(defaultMessage);\n    }\n    if (typeof error == 'string') {\n      if (error.toLowerCase().indexOf('no image selected') > -1) {\n        // User cancelled.\n        return new CoreCanceledError();\n      }\n      return new CoreError(error);\n    } else if ('code' in error && error.code === CAPTURE_ERROR_NO_MEDIA_FILES) {\n      throw new CoreCanceledError();\n    } else {\n      throw error;\n    }\n  }\n  /**\n   * Convenient helper for the user to record and upload a video.\n   *\n   * @param isAudio True if uploading an audio, false if it's a video.\n   * @param maxSize Max size of the upload. -1 for no max size.\n   * @param upload True if the file should be uploaded, false to return the picked file.\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @returns Promise resolved when done.\n   */\n  uploadAudioOrVideo(isAudio, maxSize, upload, mimetypes) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      _this8.logger.debug('Trying to record a ' + (isAudio ? 'audio' : 'video') + ' file');\n      let media;\n      try {\n        const medias = isAudio ? yield CoreFileUploader.captureAudio() : yield CoreFileUploader.captureVideo({\n          limit: 1\n        });\n        media = medias[0]; // We used limit 1, we only want 1 media.\n      } catch (error) {\n        const defaultError = isAudio ? 'core.fileuploader.errorcapturingaudio' : 'core.fileuploader.errorcapturingvideo';\n        throw _this8.treatCaptureError(error, defaultError); // Throw the right error.\n      }\n\n      let path = media.fullPath;\n      const error = CoreFileUploader.isInvalidMimetype(mimetypes, media.fullPath);\n      if (error) {\n        throw new Error(error);\n      }\n      // Make sure the path has the protocol. In iOS it doesn't.\n      if (CorePlatform.isMobile() && path.indexOf('file://') == -1) {\n        path = 'file://' + path;\n      }\n      const options = CoreFileUploader.getMediaUploadOptions(media);\n      if (upload) {\n        return _this8.uploadFile(path, maxSize || -1, true, options);\n      } else {\n        // Copy or move the file to our temporary folder.\n        return _this8.copyToTmpFolder(path, true, maxSize, undefined, options);\n      }\n    })();\n  }\n  /**\n   * Uploads a file of any type.\n   * This function will not check the size of the file, please check it before calling this function.\n   *\n   * @param uri File URI.\n   * @param name File name.\n   * @param type File type.\n   * @param deleteAfterUpload Whether the file should be deleted after upload.\n   * @param siteId Id of the site to upload the file to. If not defined, use current site.\n   * @returns Promise resolved when the file is uploaded.\n   */\n  uploadGenericFile(uri, name, type, deleteAfterUpload, siteId) {\n    const options = CoreFileUploader.getFileUploadOptions(uri, name, type, deleteAfterUpload);\n    return this.uploadFile(uri, -1, false, options, siteId);\n  }\n  /**\n   * Convenient helper for the user to upload an image, either from the album or taking it with the camera.\n   *\n   * @param fromAlbum True if the image should be selected from album, false if it should be taken with camera.\n   * @param maxSize Max size of the upload. -1 for no max size.\n   * @param upload True if the file should be uploaded, false to return the picked file.\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @returns Promise resolved when done.\n   */\n  uploadImage(fromAlbum, maxSize, upload, mimetypes) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      _this9.logger.debug('Trying to capture an image with camera');\n      const options = {\n        quality: 50,\n        destinationType: Camera.DestinationType.FILE_URI,\n        correctOrientation: true\n      };\n      if (fromAlbum) {\n        const imageSupported = !mimetypes || CoreUtils.indexOfRegexp(mimetypes, /^image\\//) > -1;\n        const videoSupported = !mimetypes || CoreUtils.indexOfRegexp(mimetypes, /^video\\//) > -1;\n        options.sourceType = Camera.PictureSourceType.PHOTOLIBRARY;\n        options.popoverOptions = {\n          x: 10,\n          y: 10,\n          width: CorePlatform.width() - 200,\n          height: CorePlatform.height() - 200,\n          arrowDir: Camera.PopoverArrowDirection.ARROW_ANY\n        };\n        // Determine the mediaType based on the mimetypes.\n        if (imageSupported && !videoSupported) {\n          options.mediaType = Camera.MediaType.PICTURE;\n        } else if (!imageSupported && videoSupported) {\n          options.mediaType = Camera.MediaType.VIDEO;\n        } else if (CorePlatform.isIOS()) {\n          // Only get all media in iOS because in Android using this option allows uploading any kind of file.\n          options.mediaType = Camera.MediaType.ALLMEDIA;\n        }\n      } else if (mimetypes) {\n        if (mimetypes.indexOf('image/jpeg') > -1) {\n          options.encodingType = Camera.EncodingType.JPEG;\n        } else if (mimetypes.indexOf('image/png') > -1) {\n          options.encodingType = Camera.EncodingType.PNG;\n        }\n      }\n      let path;\n      try {\n        path = yield CoreFileUploader.getPicture(options);\n      } catch (error) {\n        const defaultError = fromAlbum ? 'core.fileuploader.errorgettingimagealbum' : 'core.fileuploader.errorcapturingimage';\n        throw _this9.treatImageError(error, Translate.instant(defaultError));\n      }\n      const error = CoreFileUploader.isInvalidMimetype(mimetypes, path); // Verify that the mimetype is supported.\n      if (error) {\n        throw new CoreError(error);\n      }\n      const uploadOptions = CoreFileUploader.getCameraUploadOptions(path, fromAlbum);\n      if (upload) {\n        return _this9.uploadFile(path, maxSize || -1, true, uploadOptions);\n      } else {\n        // Copy or move the file to our temporary folder.\n        return _this9.copyToTmpFolder(path, !fromAlbum, maxSize, 'jpg', uploadOptions);\n      }\n    })();\n  }\n  /**\n   * Upload a file given the file entry.\n   *\n   * @param fileEntry The file entry.\n   * @param deleteAfter True if the file should be deleted once treated.\n   * @param maxSize Max size of the file. If not defined or -1, no max size.\n   * @param upload True if the file should be uploaded, false to return the picked file.\n   * @param allowOffline True to allow selecting in offline, false to require connection.\n   * @param name Name to use when uploading the file. If not defined, use the file's name.\n   * @returns Promise resolved when done.\n   */\n  uploadFileEntry(fileEntry, deleteAfter, maxSize, upload, allowOffline, name) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const file = yield CoreFile.getFileObjectFromFileEntry(fileEntry);\n      const result = yield _this10.uploadFileObject(file, maxSize, upload, allowOffline, name);\n      if (deleteAfter) {\n        // We have uploaded and deleted a copy of the file. Now delete the original one.\n        CoreFile.removeFileByFileEntry(fileEntry);\n      }\n      return result;\n    })();\n  }\n  /**\n   * Upload a file given the file object.\n   *\n   * @param file The file object.\n   * @param maxSize Max size of the file. If not defined or -1, no max size.\n   * @param upload True if the file should be uploaded, false to return the picked file.\n   * @param allowOffline True to allow selecting in offline, false to require connection.\n   * @param name Name to use when uploading the file. If not defined, use the file's name.\n   * @returns Promise resolved when done.\n   */\n  uploadFileObject(file, maxSize, upload, allowOffline, name) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (maxSize === 0) {\n        var _CoreSites$getCurrent;\n        const siteInfo = (_CoreSites$getCurrent = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent === void 0 ? void 0 : _CoreSites$getCurrent.getInfo();\n        if (siteInfo && siteInfo.usermaxuploadfilesize) {\n          maxSize = siteInfo.usermaxuploadfilesize;\n        }\n      }\n      if (maxSize !== undefined && maxSize != -1 && file.size > maxSize) {\n        throw _this11.createMaxBytesError(maxSize, file.name);\n      }\n      if (upload) {\n        yield _this11.confirmUploadFile(file.size, false, allowOffline);\n      }\n      // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.\n      return _this11.copyAndUploadFile(file, upload, name);\n    })();\n  }\n  /**\n   * Convenience function to upload a file, allowing to retry if it fails.\n   *\n   * @param path Absolute path of the file to upload.\n   * @param maxSize Max size of the upload. -1 for no max size.\n   * @param checkSize True to check size.\n   * @param options Options.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if the file is uploaded, rejected otherwise.\n   */\n  uploadFile(path, maxSize, checkSize, options, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const errorStr = Translate.instant('core.error');\n      const retryStr = Translate.instant('core.retry');\n      const uploadingStr = Translate.instant('core.fileuploader.uploading');\n      const errorUploading = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (error) {\n          // Allow the user to retry.\n          try {\n            yield CoreDomUtils.showConfirm(error, errorStr, retryStr);\n          } catch (error) {\n            // User cancelled. Delete the file if needed.\n            if (options.deleteAfterUpload) {\n              CoreFile.removeExternalFile(path);\n            }\n            throw new CoreCanceledError();\n          }\n          // Try again.\n          return _this12.uploadFile(path, maxSize, checkSize, options, siteId);\n        });\n        return function errorUploading(_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        return errorUploading(Translate.instant('core.fileuploader.errormustbeonlinetoupload'));\n      }\n      let file;\n      let size = 0;\n      if (checkSize) {\n        try {\n          // Check that file size is the right one.\n          const fileEntry = yield CoreFile.getExternalFile(path);\n          file = yield CoreFile.getFileObjectFromFileEntry(fileEntry);\n          size = file.size;\n        } catch (_unused) {\n          // Ignore failures.\n        }\n      }\n      if (maxSize != -1 && size > maxSize && file) {\n        throw _this12.createMaxBytesError(maxSize, file.name);\n      }\n      if (size > 0) {\n        yield _this12.confirmUploadFile(size);\n      }\n      // File isn't too large and user confirmed, let's upload.\n      const modal = yield CoreDomUtils.showModalLoading(uploadingStr);\n      try {\n        return yield CoreFileUploader.uploadFile(path, options, progress => {\n          _this12.showProgressModal(modal, 'core.fileuploader.uploadingperc', progress);\n        }, siteId);\n      } catch (error) {\n        _this12.logger.error('Error uploading file.', error);\n        modal.dismiss();\n        return errorUploading(error);\n      } finally {\n        modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Show a progress modal.\n   *\n   * @param modal The modal where to show the progress.\n   * @param stringKey The key of the string to display.\n   * @param progress The progress event.\n   */\n  showProgressModal(modal, stringKey, progress) {\n    if (!progress || !progress.lengthComputable || progress.loaded === undefined || !progress.total) {\n      return;\n    }\n    // Calculate the progress percentage.\n    const perc = Math.min(progress.loaded / progress.total * 100, 100);\n    if (isNaN(perc) || perc < 0) {\n      return;\n    }\n    modal.updateText(Translate.instant(stringKey, {\n      $a: perc.toFixed(1)\n    }));\n  }\n}\n_class = CoreFileUploaderHelperProvider;\n_class.ɵfac = function CoreFileUploaderHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFileUploaderHelper = makeSingleton(CoreFileUploaderHelperProvider);","map":{"version":3,"names":["CoreNetwork","CoreFile","CoreFileProvider","CoreDomUtils","CoreMimetypeUtils","CoreTextUtils","CoreUtils","makeSingleton","Translate","Camera","ActionSheetController","CoreLogger","CoreCanceledError","CoreError","CoreFileUploader","CoreFileUploaderProvider","CoreFileUploaderDelegate","CAPTURE_ERROR_NO_MEDIA_FILES","CoreSites","CorePath","CorePromisedValue","CorePlatform","Chooser","CoreFileUploaderHelperProvider","constructor","logger","getInstance","chooseAndUploadFile","maxSize","upload","allowOffline","mimetypes","_this","_asyncToGenerator","modal","showModalLoading","result","getFileMetadata","join","undefined","dismiss","name","getChosenFileNameFromPath","error","isInvalidMimetype","mediaType","options","getFileUploadOptions","uri","uploadFile","copyToTmpFolder","confirmUploadFile","size","alwaysConfirm","wifiThreshold","limitedThreshold","isOnline","instant","WIFI_SIZE_WARNING","LIMITED_SIZE_WARNING","showConfirm","isNetworkAccessLimited","readableSize","bytesToSize","copyAndUploadFile","file","_this2","fileEntry","newName","getUniqueNameInFolder","TMPFOLDER","filePath","concatenatePaths","writeFileDataInFile","progress","showProgressModal","uploadGenericFile","toURL","type","path","shouldDelete","defaultExt","_this3","fileName","getFileAndDirectoryFromPath","getExternalFile","fileData","getFileObjectFromFileEntry","createMaxBytesError","destPath","moveExternalFile","copyExternalFile","$a","filePickerClosed","filePickerDeferred","reject","fileUploaded","_this$actionSheet","resolve","actionSheet","nameAndDir","extension","getFileExtension","getExtension","decodeURIComponent","selectAndUploadFile","title","_this4","selectFileWithPicker","selectFile","_this5","_this6","buttons","text","role","handler","handlers","getHandlers","forEach","push","icon","cssClass","class","_ref","action","showErrorModal","data","treated","uploadFileEntry","delete","getFile","showErrorModalDefault","apply","arguments","create","header","present","setTimeout","afterRender","showConfirmAndUploadInSite","deleteAfterUpload","siteId","_this7","showToast","treatCaptureError","defaultMessage","code","message","isNoAppError","treatImageError","toLowerCase","indexOf","uploadAudioOrVideo","isAudio","_this8","debug","media","medias","captureAudio","captureVideo","limit","defaultError","fullPath","Error","isMobile","getMediaUploadOptions","uploadImage","fromAlbum","_this9","quality","destinationType","DestinationType","FILE_URI","correctOrientation","imageSupported","indexOfRegexp","videoSupported","sourceType","PictureSourceType","PHOTOLIBRARY","popoverOptions","x","y","width","height","arrowDir","PopoverArrowDirection","ARROW_ANY","MediaType","PICTURE","VIDEO","isIOS","ALLMEDIA","encodingType","EncodingType","JPEG","PNG","getPicture","uploadOptions","getCameraUploadOptions","deleteAfter","_this10","uploadFileObject","removeFileByFileEntry","_this11","_CoreSites$getCurrent","siteInfo","getCurrentSite","getInfo","usermaxuploadfilesize","checkSize","_this12","errorStr","retryStr","uploadingStr","errorUploading","_ref2","removeExternalFile","_x","_unused","stringKey","lengthComputable","loaded","total","perc","Math","min","isNaN","updateText","toFixed","factory","ɵfac","providedIn","CoreFileUploaderHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/fileuploader/services/fileuploader-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { ActionSheetButton } from '@ionic/core';\nimport { CameraOptions } from '@awesome-cordova-plugins/camera/ngx';\nimport { ChooserResult } from 'cordova-plugin-chooser';\nimport { FileEntry, IFile } from '@awesome-cordova-plugins/file/ngx';\nimport { MediaFile } from '@awesome-cordova-plugins/media-capture/ngx';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile, CoreFileProvider, CoreFileProgressEvent } from '@services/file';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate, Camera, ActionSheetController } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreError } from '@classes/errors/error';\nimport {\n    CoreFileUploader,\n    CoreFileUploaderProvider,\n    CoreFileUploaderOptions,\n    CoreFileUploaderAudioRecording,\n} from './fileuploader';\nimport { CoreFileUploaderDelegate } from './fileuploader-delegate';\nimport { CAPTURE_ERROR_NO_MEDIA_FILES, CoreCaptureError } from '@classes/errors/captureerror';\nimport { CoreIonLoadingElement } from '@classes/ion-loading';\nimport { CoreWSUploadFileResult } from '@services/ws';\nimport { CoreSites } from '@services/sites';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { Chooser } from '@features/native/plugins';\n\n/**\n * Helper service to upload files.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFileUploaderHelperProvider {\n\n    protected logger: CoreLogger;\n    protected filePickerDeferred?: CorePromisedValue<CoreWSUploadFileResult | FileEntry>;\n    protected actionSheet?: HTMLIonActionSheetElement;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreFileUploaderHelperProvider');\n    }\n\n    /**\n     * Choose any type of file and upload it.\n     *\n     * @param maxSize Max size of the upload. -1 for no max size.\n     * @param upload True if the file should be uploaded, false to return the picked file.\n     * @param allowOffline True to allow uploading in offline.\n     * @returns Promise resolved when done.\n     */\n    async chooseAndUploadFile(\n        maxSize?: number,\n        upload?: boolean,\n        allowOffline?: boolean,\n        mimetypes?: string[],\n    ): Promise<CoreWSUploadFileResult | FileEntry> {\n\n        const modal = await CoreDomUtils.showModalLoading();\n\n        const result = await Chooser.getFileMetadata(mimetypes ? mimetypes.join(',') : undefined);\n\n        modal.dismiss();\n\n        if (!result) {\n            // User canceled.\n            throw new CoreCanceledError();\n        }\n\n        if (result.name == 'File') {\n            // In some Android 4.4 devices the file name cannot be retrieved. Try to use the one from the URI.\n            result.name = this.getChosenFileNameFromPath(result) || result.name;\n        }\n\n        // Verify that the mimetype is supported.\n        const error = CoreFileUploader.isInvalidMimetype(mimetypes, result.name, result.mediaType);\n\n        if (error) {\n            throw new CoreError(error);\n        }\n\n        const options = CoreFileUploader.getFileUploadOptions(result.uri, result.name, result.mediaType, true);\n\n        if (upload) {\n            return this.uploadFile(result.uri, maxSize || -1, true, options);\n        } else {\n            return this.copyToTmpFolder(result.uri, false, maxSize, undefined, options);\n        }\n    }\n\n    /**\n     * Show a confirmation modal to the user if the size of the file is bigger than the allowed threshold.\n     *\n     * @param size File size.\n     * @param alwaysConfirm True to show a confirm even if the size isn't high.\n     * @param allowOffline True to allow uploading in offline.\n     * @param wifiThreshold Threshold for WiFi connection. Default: CoreFileUploaderProvider.WIFI_SIZE_WARNING.\n     * @param limitedThreshold Threshold for limited connection. Default: CoreFileUploaderProvider.LIMITED_SIZE_WARNING.\n     * @returns Promise resolved when the user confirms or if there's no need to show a modal.\n     */\n    async confirmUploadFile(\n        size: number,\n        alwaysConfirm?: boolean,\n        allowOffline?: boolean,\n        wifiThreshold?: number,\n        limitedThreshold?: number,\n    ): Promise<void> {\n        if (size == 0) {\n            return;\n        }\n\n        if (!allowOffline && !CoreNetwork.isOnline()) {\n            throw new CoreError(Translate.instant('core.fileuploader.errormustbeonlinetoupload'));\n        }\n\n        wifiThreshold = wifiThreshold === undefined ? CoreFileUploaderProvider.WIFI_SIZE_WARNING : wifiThreshold;\n        limitedThreshold = limitedThreshold === undefined ?\n            CoreFileUploaderProvider.LIMITED_SIZE_WARNING : limitedThreshold;\n\n        if (size < 0) {\n            return CoreDomUtils.showConfirm(Translate.instant('core.fileuploader.confirmuploadunknownsize'));\n        } else if (size >= wifiThreshold || (CoreNetwork.isNetworkAccessLimited() && size >= limitedThreshold)) {\n            const readableSize = CoreTextUtils.bytesToSize(size, 2);\n\n            return CoreDomUtils.showConfirm(\n                Translate.instant('core.fileuploader.confirmuploadfile', { size: readableSize }),\n            );\n        } else if (alwaysConfirm) {\n            return CoreDomUtils.showConfirm(Translate.instant('core.areyousure'));\n        }\n    }\n\n    /**\n     * Create a temporary copy of a file and upload it.\n     *\n     * @param file File to copy and upload.\n     * @param upload True if the file should be uploaded, false to return the copy of the file.\n     * @param name Name to use when uploading the file. If not defined, use the file's name.\n     * @returns Promise resolved when the file is uploaded.\n     */\n    async copyAndUploadFile(file: IFile | File, upload?: boolean, name?: string): Promise<CoreWSUploadFileResult | FileEntry> {\n        name = name || file.name;\n\n        const modal = await CoreDomUtils.showModalLoading('core.fileuploader.readingfile', true);\n        let fileEntry: FileEntry | undefined;\n\n        try {\n            // Get unique name for the copy.\n            const newName = await CoreFile.getUniqueNameInFolder(CoreFileProvider.TMPFOLDER, name);\n\n            const filePath = CorePath.concatenatePaths(CoreFileProvider.TMPFOLDER, newName);\n\n            // Write the data into the file.\n            fileEntry = await CoreFile.writeFileDataInFile(\n                file,\n                filePath,\n                (progress: CoreFileProgressEvent) => this.showProgressModal(modal, 'core.fileuploader.readingfileperc', progress),\n            );\n        } catch (error) {\n            this.logger.error('Error reading file to upload.', error);\n            modal.dismiss();\n\n            throw error;\n        }\n\n        modal.dismiss();\n\n        if (upload) {\n            // Pass true to delete the copy after the upload.\n            return this.uploadGenericFile(fileEntry.toURL(), name, file.type, true);\n        } else {\n            return fileEntry;\n        }\n    }\n\n    /**\n     * Copy or move a file to the app temporary folder.\n     *\n     * @param path Path of the file.\n     * @param shouldDelete True if original file should be deleted (move), false otherwise (copy).\n     * @param maxSize Max size of the file. If not defined or -1, no max size.\n     * @param defaultExt Defaut extension to use if the file doesn't have any.\n     * @returns Promise resolved with the copied file.\n     */\n    protected async copyToTmpFolder(\n        path: string,\n        shouldDelete: boolean,\n        maxSize?: number,\n        defaultExt?: string,\n        options?: CoreFileUploaderOptions,\n    ): Promise<FileEntry> {\n\n        const fileName = options?.fileName || CoreFile.getFileAndDirectoryFromPath(path).name;\n\n        // Check that size isn't too large.\n        if (maxSize !== undefined && maxSize != -1) {\n            const fileEntry = await CoreFile.getExternalFile(path);\n\n            const fileData = await CoreFile.getFileObjectFromFileEntry(fileEntry);\n\n            if (fileData.size > maxSize) {\n                throw this.createMaxBytesError(maxSize, fileEntry.name);\n            }\n        }\n\n        // File isn't too large.\n        // Get a unique name in the folder to prevent overriding another file.\n        const newName = await CoreFile.getUniqueNameInFolder(CoreFileProvider.TMPFOLDER, fileName, defaultExt);\n\n        // Now move or copy the file.\n        const destPath = CorePath.concatenatePaths(CoreFileProvider.TMPFOLDER, newName);\n        if (shouldDelete) {\n            return CoreFile.moveExternalFile(path, destPath);\n        } else {\n            return CoreFile.copyExternalFile(path, destPath);\n        }\n    }\n\n    /**\n     * Function called when trying to upload a file bigger than max size. Creates an error instance.\n     *\n     * @param maxSize Max size (bytes).\n     * @param fileName Name of the file.\n     * @returns Message.\n     */\n    protected createMaxBytesError(maxSize: number, fileName: string): CoreError {\n        return new CoreError(Translate.instant('core.fileuploader.maxbytesfile', {\n            $a: {\n                file: fileName,\n                size: CoreTextUtils.bytesToSize(maxSize, 2),\n            },\n        }));\n    }\n\n    /**\n     * Function called when the file picker is closed.\n     */\n    filePickerClosed(): void {\n        if (this.filePickerDeferred) {\n            this.filePickerDeferred.reject(new CoreCanceledError());\n            this.filePickerDeferred = undefined;\n        }\n    }\n\n    /**\n     * Function to call once a file is uploaded using the file picker.\n     *\n     * @param result Result of the upload process.\n     */\n    fileUploaded(result: CoreWSUploadFileResult | FileEntry): void {\n        if (this.filePickerDeferred) {\n            this.filePickerDeferred.resolve(result);\n            this.filePickerDeferred = undefined;\n        }\n        // Close the action sheet if it's opened.\n        this.actionSheet?.dismiss();\n    }\n\n    /**\n     * Given the result of choosing a file, try to get its file name from the path.\n     *\n     * @param result Chosen file data.\n     * @returns File name, undefined if cannot get it.\n     */\n    protected getChosenFileNameFromPath(result: ChooserResult): string | undefined {\n        const nameAndDir = CoreFile.getFileAndDirectoryFromPath(result.uri);\n\n        if (!nameAndDir.name) {\n            return;\n        }\n\n        let extension = CoreMimetypeUtils.getFileExtension(nameAndDir.name);\n\n        if (!extension) {\n            // The URI doesn't have an extension, add it now.\n            extension = CoreMimetypeUtils.getExtension(result.mediaType);\n\n            if (extension) {\n                nameAndDir.name += '.' + extension;\n            }\n        }\n\n        return decodeURIComponent(nameAndDir.name);\n    }\n\n    /**\n     * Open the \"file picker\" to select and upload a file.\n     *\n     * @param maxSize Max size of the file to upload. If not defined or -1, no max size.\n     * @param title File picker title.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns Promise resolved when a file is uploaded, rejected if file picker is closed without a file uploaded.\n     *         The resolve value is the response of the upload request.\n     */\n    async selectAndUploadFile(maxSize?: number, title?: string, mimetypes?: string[]): Promise<CoreWSUploadFileResult> {\n        return <CoreWSUploadFileResult> await this.selectFileWithPicker(maxSize, false, title, mimetypes, true);\n    }\n\n    /**\n     * Open the \"file picker\" to select a file without uploading it.\n     *\n     * @param maxSize Max size of the file. If not defined or -1, no max size.\n     * @param allowOffline True to allow selecting in offline, false to require connection.\n     * @param title File picker title.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns Promise resolved when a file is selected, rejected if file picker is closed without selecting a file.\n     *         The resolve value is the FileEntry of a copy of the picked file, so it can be deleted afterwards.\n     */\n    async selectFile(maxSize?: number, allowOffline?: boolean, title?: string, mimetypes?: string[]): Promise<FileEntry> {\n        return <FileEntry> await this.selectFileWithPicker(maxSize, allowOffline, title, mimetypes, false);\n    }\n\n    /**\n     * Open the \"file picker\" to select a file and maybe uploading it.\n     *\n     * @param maxSize Max size of the file. If not defined or -1, no max size.\n     * @param allowOffline True to allow selecting in offline, false to require connection.\n     * @param title File picker title.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @param upload Whether the file should be uploaded.\n     * @returns Promise resolved when a file is selected/uploaded, rejected if file picker is closed.\n     */\n    protected async selectFileWithPicker(\n        maxSize?: number,\n        allowOffline?: boolean,\n        title?: string,\n        mimetypes?: string[],\n        upload?: boolean,\n    ): Promise<CoreWSUploadFileResult | FileEntry> {\n        // Create the cancel button and get the handlers to upload the file.\n        const buttons: ActionSheetButton[] = [{\n            text: Translate.instant('core.cancel'),\n            role: 'cancel',\n            handler: (): void => {\n                // User cancelled the action sheet.\n                this.filePickerClosed();\n            },\n        }];\n        const handlers = CoreFileUploaderDelegate.getHandlers(mimetypes);\n\n        this.filePickerDeferred = new CorePromisedValue();\n\n        // Create a button for each handler.\n        handlers.forEach((handler) => {\n            buttons.push({\n                text: Translate.instant(handler.title),\n                icon: handler.icon,\n                cssClass: handler.class,\n                handler: async (): Promise<boolean> => {\n                    if (!handler.action) {\n                        // Nothing to do.\n                        return false;\n                    }\n\n                    if (!allowOffline && !CoreNetwork.isOnline()) {\n                        // Not allowed, show error.\n                        CoreDomUtils.showErrorModal('core.fileuploader.errormustbeonlinetoupload', true);\n\n                        return false;\n                    }\n\n                    try {\n                        const data = await handler.action(maxSize, upload, allowOffline, handler.mimetypes);\n\n                        let result: CoreWSUploadFileResult | FileEntry | undefined;\n\n                        if (data.treated) {\n                            // The handler already treated the file. Return the result.\n                            result = data.result;\n                        } else if (data.fileEntry) {\n                            // The handler provided us a fileEntry, use it.\n                            result = await this.uploadFileEntry(data.fileEntry, !!data.delete, maxSize, upload, allowOffline);\n                        } else if (data.path) {\n                            let fileEntry: FileEntry;\n\n                            try {\n                                // The handler provided a path. First treat it like it's a relative path.\n                                fileEntry = await CoreFile.getFile(data.path);\n                            } catch (error) {\n                                // File not found, it's probably an absolute path.\n                                fileEntry = await CoreFile.getExternalFile(data.path);\n                            }\n\n                            // File found, treat it.\n                            result = await this.uploadFileEntry(fileEntry, !!data.delete, maxSize, upload, allowOffline);\n                        }\n\n                        if (!result) {\n                            // Nothing received, fail.\n                            throw new CoreError('No file received');\n                        }\n\n                        this.fileUploaded(result);\n\n                        return true;\n                    } catch (error) {\n                        CoreDomUtils.showErrorModalDefault(\n                            error,\n                            Translate.instant('core.fileuploader.errorreadingfile'),\n                        );\n\n                        return false;\n                    }\n                },\n            });\n        });\n\n        this.actionSheet = await ActionSheetController.create({\n            header: title ? title : Translate.instant('core.fileuploader.' + (upload ? 'uploadafile' : 'selectafile')),\n            buttons: buttons,\n        });\n        await this.actionSheet.present();\n\n        // Call afterRender for each button.\n        setTimeout(() => {\n            handlers.forEach((handler) => {\n                if (handler.afterRender) {\n                    handler.afterRender(maxSize, upload, allowOffline, handler.mimetypes);\n                }\n            });\n        }, 500);\n\n        return this.filePickerDeferred;\n    }\n\n    /**\n     * Convenience function to upload a file on a certain site, showing a confirm if needed.\n     *\n     * @param fileEntry FileEntry of the file to upload.\n     * @param deleteAfterUpload Whether the file should be deleted after upload.\n     * @param siteId Id of the site to upload the file to. If not defined, use current site.\n     * @returns Promise resolved when the file is uploaded.\n     */\n    async showConfirmAndUploadInSite(fileEntry: FileEntry, deleteAfterUpload?: boolean, siteId?: string): Promise<void> {\n        try {\n            const file = await CoreFile.getFileObjectFromFileEntry(fileEntry);\n\n            await this.confirmUploadFile(file.size);\n\n            await this.uploadGenericFile(fileEntry.toURL(), file.name, file.type, deleteAfterUpload, siteId);\n\n            CoreDomUtils.showToast('core.fileuploader.fileuploaded', true, undefined, 'core-toast-success');\n        } catch (error) {\n            CoreDomUtils.showErrorModalDefault(error, 'core.fileuploader.errorreadingfile', true);\n\n            throw error;\n        }\n    }\n\n    /**\n     * Treat a capture audio/video error.\n     *\n     * @param error Error returned by the Cordova plugin.\n     * @param defaultMessage Key of the default message to show.\n     */\n    protected treatCaptureError(error: CoreCaptureError, defaultMessage: string): void {\n        // Cancelled or error. If cancelled, error is an object with code = CAPTURE_EROR_NO_MEDIA_FILES.\n        if (error) {\n            if (error.code !== CAPTURE_ERROR_NO_MEDIA_FILES) {\n                // Error, not cancelled.\n                this.logger.error('Error while recording audio/video', error);\n\n                const message = this.isNoAppError(error) ? Translate.instant('core.fileuploader.errornoapp') :\n                    (error.message || Translate.instant(defaultMessage));\n\n                throw new CoreError(message);\n            } else {\n                throw new CoreCanceledError();\n            }\n        }\n\n        throw new CoreError('Error capturing media');\n    }\n\n    /**\n     * Check if a capture error is because there is no app to capture.\n     *\n     * @param error Error.\n     * @returns Whether it's because there is no app.\n     */\n    protected isNoAppError(error: CoreCaptureError): boolean {\n        return error && error.code == 20;\n    }\n\n    /**\n     * Treat a capture image or browse album error.\n     *\n     * @param error Error returned by the Cordova plugin.\n     * @param defaultMessage Key of the default message to show.\n     * @returns Rejected promise. If it doesn't have an error message it means it was cancelled.\n     */\n    protected treatImageError(error: number | string | CoreError | CoreCaptureError, defaultMessage: string): CoreError {\n        // Cancelled or error.\n        if (!error || typeof error == 'number') {\n            return new CoreError(defaultMessage);\n        }\n\n        if (typeof error == 'string') {\n            if (error.toLowerCase().indexOf('no image selected') > -1) {\n                // User cancelled.\n                return new CoreCanceledError();\n            }\n\n            return new CoreError(error);\n        } else if ('code' in error && error.code === CAPTURE_ERROR_NO_MEDIA_FILES) {\n            throw new CoreCanceledError();\n        } else {\n            throw error;\n        }\n\n    }\n\n    /**\n     * Convenient helper for the user to record and upload a video.\n     *\n     * @param isAudio True if uploading an audio, false if it's a video.\n     * @param maxSize Max size of the upload. -1 for no max size.\n     * @param upload True if the file should be uploaded, false to return the picked file.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns Promise resolved when done.\n     */\n    async uploadAudioOrVideo(\n        isAudio: boolean,\n        maxSize?: number,\n        upload?: boolean,\n        mimetypes?: string[],\n    ): Promise<CoreWSUploadFileResult | FileEntry> {\n        this.logger.debug('Trying to record a ' + (isAudio ? 'audio' : 'video') + ' file');\n\n        let media: MediaFile | CoreFileUploaderAudioRecording;\n\n        try {\n            const medias = isAudio\n                ? await CoreFileUploader.captureAudio()\n                : await CoreFileUploader.captureVideo({ limit: 1 });\n\n            media = medias[0]; // We used limit 1, we only want 1 media.\n        } catch (error) {\n            const defaultError = isAudio ? 'core.fileuploader.errorcapturingaudio' : 'core.fileuploader.errorcapturingvideo';\n\n            throw this.treatCaptureError(error, defaultError); // Throw the right error.\n        }\n\n        let path = media.fullPath;\n        const error = CoreFileUploader.isInvalidMimetype(mimetypes, media.fullPath);\n\n        if (error) {\n            throw new Error(error);\n        }\n\n        // Make sure the path has the protocol. In iOS it doesn't.\n        if (CorePlatform.isMobile() && path.indexOf('file://') == -1) {\n            path = 'file://' + path;\n        }\n\n        const options = CoreFileUploader.getMediaUploadOptions(media);\n\n        if (upload) {\n            return this.uploadFile(path, maxSize || -1, true, options);\n        } else {\n            // Copy or move the file to our temporary folder.\n            return this.copyToTmpFolder(path, true, maxSize, undefined, options);\n        }\n    }\n\n    /**\n     * Uploads a file of any type.\n     * This function will not check the size of the file, please check it before calling this function.\n     *\n     * @param uri File URI.\n     * @param name File name.\n     * @param type File type.\n     * @param deleteAfterUpload Whether the file should be deleted after upload.\n     * @param siteId Id of the site to upload the file to. If not defined, use current site.\n     * @returns Promise resolved when the file is uploaded.\n     */\n    uploadGenericFile(\n        uri: string,\n        name: string,\n        type: string,\n        deleteAfterUpload?: boolean,\n        siteId?: string,\n    ): Promise<CoreWSUploadFileResult> {\n        const options = CoreFileUploader.getFileUploadOptions(uri, name, type, deleteAfterUpload);\n\n        return this.uploadFile(uri, -1, false, options, siteId);\n    }\n\n    /**\n     * Convenient helper for the user to upload an image, either from the album or taking it with the camera.\n     *\n     * @param fromAlbum True if the image should be selected from album, false if it should be taken with camera.\n     * @param maxSize Max size of the upload. -1 for no max size.\n     * @param upload True if the file should be uploaded, false to return the picked file.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns Promise resolved when done.\n     */\n    async uploadImage(\n        fromAlbum: boolean,\n        maxSize?: number,\n        upload?: boolean,\n        mimetypes?: string[],\n    ): Promise<CoreWSUploadFileResult | FileEntry> {\n        this.logger.debug('Trying to capture an image with camera');\n\n        const options: CameraOptions = {\n            quality: 50,\n            destinationType: Camera.DestinationType.FILE_URI,\n            correctOrientation: true,\n        };\n\n        if (fromAlbum) {\n            const imageSupported = !mimetypes || CoreUtils.indexOfRegexp(mimetypes, /^image\\//) > -1;\n            const videoSupported = !mimetypes || CoreUtils.indexOfRegexp(mimetypes, /^video\\//) > -1;\n\n            options.sourceType = Camera.PictureSourceType.PHOTOLIBRARY;\n            options.popoverOptions = {\n                x: 10,\n                y: 10,\n                width: CorePlatform.width() - 200,\n                height: CorePlatform.height() - 200,\n                arrowDir: Camera.PopoverArrowDirection.ARROW_ANY,\n            };\n\n            // Determine the mediaType based on the mimetypes.\n            if (imageSupported && !videoSupported) {\n                options.mediaType = Camera.MediaType.PICTURE;\n            } else if (!imageSupported && videoSupported) {\n                options.mediaType = Camera.MediaType.VIDEO;\n            } else if (CorePlatform.isIOS()) {\n                // Only get all media in iOS because in Android using this option allows uploading any kind of file.\n                options.mediaType = Camera.MediaType.ALLMEDIA;\n            }\n        } else if (mimetypes) {\n            if (mimetypes.indexOf('image/jpeg') > -1) {\n                options.encodingType = Camera.EncodingType.JPEG;\n            } else if (mimetypes.indexOf('image/png') > -1) {\n                options.encodingType = Camera.EncodingType.PNG;\n            }\n        }\n\n        let path: string | undefined;\n\n        try {\n            path = await CoreFileUploader.getPicture(options);\n        } catch (error) {\n            const defaultError = fromAlbum ? 'core.fileuploader.errorgettingimagealbum' : 'core.fileuploader.errorcapturingimage';\n\n            throw this.treatImageError(error, Translate.instant(defaultError));\n        }\n\n        const error = CoreFileUploader.isInvalidMimetype(mimetypes, path); // Verify that the mimetype is supported.\n        if (error) {\n            throw new CoreError(error);\n        }\n\n        const uploadOptions = CoreFileUploader.getCameraUploadOptions(path, fromAlbum);\n\n        if (upload) {\n            return this.uploadFile(path, maxSize || -1, true, uploadOptions);\n        } else {\n            // Copy or move the file to our temporary folder.\n            return this.copyToTmpFolder(path, !fromAlbum, maxSize, 'jpg', uploadOptions);\n        }\n    }\n\n    /**\n     * Upload a file given the file entry.\n     *\n     * @param fileEntry The file entry.\n     * @param deleteAfter True if the file should be deleted once treated.\n     * @param maxSize Max size of the file. If not defined or -1, no max size.\n     * @param upload True if the file should be uploaded, false to return the picked file.\n     * @param allowOffline True to allow selecting in offline, false to require connection.\n     * @param name Name to use when uploading the file. If not defined, use the file's name.\n     * @returns Promise resolved when done.\n     */\n    async uploadFileEntry(\n        fileEntry: FileEntry,\n        deleteAfter: boolean,\n        maxSize?: number,\n        upload?: boolean,\n        allowOffline?: boolean,\n        name?: string,\n    ): Promise<CoreWSUploadFileResult | FileEntry> {\n        const file = await CoreFile.getFileObjectFromFileEntry(fileEntry);\n\n        const result = await this.uploadFileObject(file, maxSize, upload, allowOffline, name);\n\n        if (deleteAfter) {\n            // We have uploaded and deleted a copy of the file. Now delete the original one.\n            CoreFile.removeFileByFileEntry(fileEntry);\n        }\n\n        return result;\n    }\n\n    /**\n     * Upload a file given the file object.\n     *\n     * @param file The file object.\n     * @param maxSize Max size of the file. If not defined or -1, no max size.\n     * @param upload True if the file should be uploaded, false to return the picked file.\n     * @param allowOffline True to allow selecting in offline, false to require connection.\n     * @param name Name to use when uploading the file. If not defined, use the file's name.\n     * @returns Promise resolved when done.\n     */\n    async uploadFileObject(\n        file: IFile | File,\n        maxSize?: number,\n        upload?: boolean,\n        allowOffline?: boolean,\n        name?: string,\n    ): Promise<CoreWSUploadFileResult | FileEntry> {\n        if (maxSize === 0) {\n            const siteInfo = CoreSites.getCurrentSite()?.getInfo();\n\n            if (siteInfo && siteInfo.usermaxuploadfilesize) {\n                maxSize = siteInfo.usermaxuploadfilesize;\n            }\n        }\n\n        if (maxSize !== undefined && maxSize != -1 && file.size > maxSize) {\n            throw this.createMaxBytesError(maxSize, file.name);\n        }\n\n        if (upload) {\n            await this.confirmUploadFile(file.size, false, allowOffline);\n        }\n\n        // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.\n        return this.copyAndUploadFile(file, upload, name);\n    }\n\n    /**\n     * Convenience function to upload a file, allowing to retry if it fails.\n     *\n     * @param path Absolute path of the file to upload.\n     * @param maxSize Max size of the upload. -1 for no max size.\n     * @param checkSize True to check size.\n     * @param options Options.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if the file is uploaded, rejected otherwise.\n     */\n    async uploadFile(\n        path: string,\n        maxSize: number,\n        checkSize: boolean,\n        options: CoreFileUploaderOptions,\n        siteId?: string,\n    ): Promise<CoreWSUploadFileResult> {\n        const errorStr = Translate.instant('core.error');\n        const retryStr = Translate.instant('core.retry');\n        const uploadingStr = Translate.instant('core.fileuploader.uploading');\n        const errorUploading = async (error): Promise<CoreWSUploadFileResult> => {\n            // Allow the user to retry.\n            try {\n                await CoreDomUtils.showConfirm(error, errorStr, retryStr);\n            } catch (error) {\n                // User cancelled. Delete the file if needed.\n                if (options.deleteAfterUpload) {\n                    CoreFile.removeExternalFile(path);\n                }\n\n                throw new CoreCanceledError();\n            }\n\n            // Try again.\n            return this.uploadFile(path, maxSize, checkSize, options, siteId);\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            return errorUploading(Translate.instant('core.fileuploader.errormustbeonlinetoupload'));\n        }\n\n        let file: IFile | undefined;\n        let size = 0;\n\n        if (checkSize) {\n            try {\n                // Check that file size is the right one.\n                const fileEntry = await CoreFile.getExternalFile(path);\n\n                file = await CoreFile.getFileObjectFromFileEntry(fileEntry);\n\n                size = file.size;\n            } catch {\n                // Ignore failures.\n            }\n        }\n\n        if (maxSize != -1 && size > maxSize && file) {\n            throw this.createMaxBytesError(maxSize, file.name);\n        }\n\n        if (size > 0) {\n            await this.confirmUploadFile(size);\n        }\n\n        // File isn't too large and user confirmed, let's upload.\n        const modal = await CoreDomUtils.showModalLoading(uploadingStr);\n\n        try {\n            return await CoreFileUploader.uploadFile(\n                path,\n                options,\n                (progress: ProgressEvent) => {\n                    this.showProgressModal(modal, 'core.fileuploader.uploadingperc', progress);\n                },\n                siteId,\n            );\n        } catch (error) {\n            this.logger.error('Error uploading file.', error);\n\n            modal.dismiss();\n\n            return errorUploading(error);\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Show a progress modal.\n     *\n     * @param modal The modal where to show the progress.\n     * @param stringKey The key of the string to display.\n     * @param progress The progress event.\n     */\n    protected showProgressModal(\n        modal: CoreIonLoadingElement,\n        stringKey: string,\n        progress: ProgressEvent | CoreFileProgressEvent,\n    ): void {\n        if (!progress || !progress.lengthComputable || progress.loaded === undefined || !progress.total) {\n            return;\n        }\n\n        // Calculate the progress percentage.\n        const perc = Math.min((progress.loaded / progress.total) * 100, 100);\n\n        if (isNaN(perc) || perc < 0) {\n            return;\n        }\n\n        modal.updateText(Translate.instant(stringKey, { $a: perc.toFixed(1) }));\n    }\n\n}\n\nexport const CoreFileUploaderHelper = makeSingleton(CoreFileUploaderHelperProvider);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}