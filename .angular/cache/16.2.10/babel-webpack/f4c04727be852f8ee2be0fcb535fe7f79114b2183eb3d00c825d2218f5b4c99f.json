{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreCourseModulePrefetchDelegate } from '@features/course/services/module-prefetch-delegate';\nimport { CoreQuestion } from '@features/question/services/question';\nimport { CoreQuestionDelegate } from '@features/question/services/question-delegate';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModQuizPrefetchHandler } from './handlers/prefetch';\nimport { AddonModQuiz, AddonModQuizProvider } from './quiz';\nimport { AddonModQuizOffline } from './quiz-offline';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync quizzes.\n */\nexport class AddonModQuizSyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModQuizSyncProvider');\n    this.componentTranslatableString = 'quiz';\n  }\n  /**\n   * Finish a sync process: remove offline data if needed, prefetch quiz data, set sync time and return the result.\n   *\n   * @param siteId Site ID.\n   * @param quiz Quiz.\n   * @param courseId Course ID.\n   * @param warnings List of warnings generated by the sync.\n   * @param options Other options.\n   * @returns Promise resolved on success.\n   */\n  finishSync(siteId, quiz, courseId, warnings, options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      options = options || {};\n      // Invalidate the data for the quiz and attempt.\n      yield CoreUtils.ignoreErrors(AddonModQuiz.invalidateAllQuizData(quiz.id, courseId, options.attemptId, siteId));\n      if (options.removeAttempt && options.attemptId) {\n        const promises = [];\n        promises.push(AddonModQuizOffline.removeAttemptAndAnswers(options.attemptId, siteId));\n        if (options.onlineQuestions) {\n          for (const slot in options.onlineQuestions) {\n            promises.push(CoreQuestionDelegate.deleteOfflineData(options.onlineQuestions[slot], AddonModQuizProvider.COMPONENT, quiz.coursemodule, siteId));\n          }\n        }\n        yield Promise.all(promises);\n      }\n      if (options.updated) {\n        try {\n          // Data has been sent. Update prefetched data.\n          const module = yield CoreCourse.getModuleBasicInfoByInstance(quiz.id, 'quiz', {\n            siteId\n          });\n          yield _this.prefetchAfterUpdateQuiz(module, quiz, courseId, siteId);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n      }\n      yield CoreUtils.ignoreErrors(_this.setSyncTime(quiz.id, siteId));\n      // Check if online attempt was finished because of the sync.\n      let attemptFinished = false;\n      if (options.onlineAttempt && !AddonModQuiz.isAttemptFinished(options.onlineAttempt.state)) {\n        // Attempt wasn't finished at start. Check if it's finished now.\n        const attempts = yield AddonModQuiz.getUserAttempts(quiz.id, {\n          cmId: quiz.coursemodule,\n          siteId\n        });\n        const attempt = attempts.find(attempt => {\n          var _options;\n          return attempt.id == ((_options = options) === null || _options === void 0 || (_options = _options.onlineAttempt) === null || _options === void 0 ? void 0 : _options.id);\n        });\n        attemptFinished = attempt ? AddonModQuiz.isAttemptFinished(attempt.state) : false;\n      }\n      return {\n        warnings,\n        attemptFinished,\n        updated: !!options.updated || !!options.removeAttempt\n      };\n    })();\n  }\n  /**\n   * Check if a quiz has data to synchronize.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it has data to sync.\n   */\n  hasDataToSync(quizId, siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const attempts = yield AddonModQuizOffline.getQuizAttempts(quizId, siteId);\n        return !!attempts.length;\n      } catch (_unused2) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Conveniece function to prefetch data after an update.\n   *\n   * @param module Module.\n   * @param quiz Quiz.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  prefetchAfterUpdateQuiz(module, quiz, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      var _result$updates;\n      let shouldDownload = false;\n      // Get the module updates to check if the data was updated or not.\n      const result = yield CoreCourseModulePrefetchDelegate.getModuleUpdates(module, courseId, true, siteId);\n      if (result !== null && result !== void 0 && (_result$updates = result.updates) !== null && _result$updates !== void 0 && _result$updates.length) {\n        const regex = /^.*files$/;\n        // Only prefetch if files haven't changed.\n        shouldDownload = !result.updates.find(entry => entry.name.match(regex));\n        if (shouldDownload) {\n          yield AddonModQuizPrefetchHandler.download(module, courseId, undefined, false, false);\n        }\n      }\n      // Prefetch finished or not needed, set the right status.\n      yield AddonModQuizPrefetchHandler.setStatusAfterPrefetch(quiz, {\n        cmId: module.id,\n        readingStrategy: shouldDownload ? 1 /* CoreSitesReadingStrategy.PREFER_CACHE */ : undefined,\n        siteId\n      });\n    })();\n  }\n  /**\n   * Try to synchronize all the quizzes in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllQuizzes(siteId, force) {\n    return this.syncOnSites('all quizzes', siteId => this.syncAllQuizzesFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all quizzes on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllQuizzesFunc(force, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // Get all offline attempts.\n      const attempts = yield AddonModQuizOffline.getAllAttempts(siteId);\n      const quizIds = {}; // To prevent duplicates.\n      // Sync all quizzes that haven't been synced for a while and that aren't attempted right now.\n      yield Promise.all(attempts.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (attempt) {\n          var _data$warnings;\n          if (quizIds[attempt.quizid]) {\n            // Quiz already treated.\n            return;\n          }\n          quizIds[attempt.quizid] = true;\n          if (CoreSync.isBlocked(AddonModQuizProvider.COMPONENT, attempt.quizid, siteId)) {\n            return;\n          }\n          // Quiz not blocked, try to synchronize it.\n          const quiz = yield AddonModQuiz.getQuizById(attempt.courseid, attempt.quizid, {\n            siteId\n          });\n          const data = yield force ? _this2.syncQuiz(quiz, false, siteId) : _this2.syncQuizIfNeeded(quiz, false, siteId);\n          if (data !== null && data !== void 0 && (_data$warnings = data.warnings) !== null && _data$warnings !== void 0 && _data$warnings.length) {\n            // Store the warnings to show them when the user opens the quiz.\n            yield _this2.setSyncWarnings(quiz.id, data.warnings, siteId);\n          }\n          if (data) {\n            // Sync successful. Send event.\n            CoreEvents.trigger(AddonModQuizSyncProvider.AUTO_SYNCED, {\n              quizId: quiz.id,\n              attemptFinished: data.attemptFinished,\n              warnings: data.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Sync a quiz only if a certain time has passed since the last time.\n   *\n   * @param quiz Quiz.\n   * @param askPreflight Whether we should ask for preflight data if needed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the quiz is synced or if it doesn't need to be synced.\n   */\n  syncQuizIfNeeded(quiz, askPreflight, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const needed = yield _this3.isSyncNeeded(quiz.id, siteId);\n      if (needed) {\n        return _this3.syncQuiz(quiz, askPreflight, siteId);\n      }\n    })();\n  }\n  /**\n   * Try to synchronize a quiz.\n   * The promise returned will be resolved with an array with warnings if the synchronization is successful.\n   *\n   * @param quiz Quiz.\n   * @param askPreflight Whether we should ask for preflight data if needed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success.\n   */\n  syncQuiz(quiz, askPreflight, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const currentSyncPromise = this.getOngoingSync(quiz.id, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for this quiz, return the promise.\n      return currentSyncPromise;\n    }\n    // Verify that quiz isn't blocked.\n    if (CoreSync.isBlocked(AddonModQuizProvider.COMPONENT, quiz.id, siteId)) {\n      this.logger.debug('Cannot sync quiz ' + quiz.id + ' because it is blocked.');\n      throw new CoreError(Translate.instant('core.errorsyncblocked', {\n        $a: this.componentTranslate\n      }));\n    }\n    return this.addOngoingSync(quiz.id, this.performSyncQuiz(quiz, askPreflight, siteId), siteId);\n  }\n  /**\n   * Perform the quiz sync.\n   *\n   * @param quiz Quiz.\n   * @param askPreflight Whether we should ask for preflight data if needed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success.\n   */\n  performSyncQuiz(quiz, askPreflight, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const warnings = [];\n      const courseId = quiz.course;\n      const modOptions = {\n        cmId: quiz.coursemodule,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      _this4.logger.debug('Try to sync quiz ' + quiz.id + ' in site ' + siteId);\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModQuizProvider.COMPONENT, quiz.id, siteId));\n      // Get all the offline attempts for the quiz. It should always be 0 or 1 attempt\n      const offlineAttempts = yield AddonModQuizOffline.getQuizAttempts(quiz.id, siteId);\n      const offlineAttempt = offlineAttempts.pop();\n      if (!offlineAttempt) {\n        // Nothing to sync, finish.\n        return _this4.finishSync(siteId, quiz, courseId, warnings);\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreError(Translate.instant('core.cannotconnect'));\n      }\n      // Now get the list of online attempts to make sure this attempt exists and isn't finished.\n      const onlineAttempts = yield AddonModQuiz.getUserAttempts(quiz.id, modOptions);\n      const lastAttemptId = onlineAttempts.length ? onlineAttempts[onlineAttempts.length - 1].id : undefined;\n      const onlineAttempt = onlineAttempts.find(attempt => attempt.id == offlineAttempt.id);\n      if (!onlineAttempt || AddonModQuiz.isAttemptFinished(onlineAttempt.state)) {\n        // Attempt not found or it's finished in online. Discard it.\n        warnings.push(Translate.instant('addon.mod_quiz.warningattemptfinished'));\n        return _this4.finishSync(siteId, quiz, courseId, warnings, {\n          attemptId: offlineAttempt.id,\n          offlineAttempt,\n          onlineAttempt,\n          removeAttempt: true\n        });\n      }\n      // Get the data stored in offline.\n      const answersList = yield AddonModQuizOffline.getAttemptAnswers(offlineAttempt.id, siteId);\n      if (!answersList.length) {\n        // No answers stored, finish.\n        return _this4.finishSync(siteId, quiz, courseId, warnings, {\n          attemptId: lastAttemptId,\n          offlineAttempt,\n          onlineAttempt,\n          removeAttempt: true\n        });\n      }\n      const offlineAnswers = CoreQuestion.convertAnswersArrayToObject(answersList);\n      const offlineQuestions = AddonModQuizOffline.classifyAnswersInQuestions(offlineAnswers);\n      // We're going to need preflightData, get it.\n      const info = yield AddonModQuiz.getQuizAccessInformation(quiz.id, modOptions);\n      const preflightData = yield AddonModQuizPrefetchHandler.getPreflightData(quiz, info, onlineAttempt, askPreflight, 'core.settings.synchronization', siteId);\n      // Now get the online questions data.\n      const onlineQuestions = yield AddonModQuiz.getAllQuestionsData(quiz, onlineAttempt, preflightData, {\n        pages: AddonModQuiz.getPagesFromLayoutAndQuestions(onlineAttempt.layout || '', offlineQuestions),\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      });\n      // Validate questions, discarding the offline answers that can't be synchronized.\n      const discardedData = yield _this4.validateQuestions(onlineAttempt.id, onlineQuestions, offlineQuestions, siteId);\n      // Let questions prepare the data to send.\n      yield Promise.all(Object.keys(offlineQuestions).map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (slotString) {\n          const slot = Number(slotString);\n          const onlineQuestion = onlineQuestions[slot];\n          yield CoreQuestionDelegate.prepareSyncData(onlineQuestion, offlineQuestions[slot].answers, AddonModQuizProvider.COMPONENT, quiz.coursemodule, siteId);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      // Get the answers to send.\n      const answers = AddonModQuizOffline.extractAnswersFromQuestions(offlineQuestions);\n      const finish = !!offlineAttempt.finished && !discardedData;\n      if (discardedData) {\n        if (offlineAttempt.finished) {\n          warnings.push(Translate.instant('addon.mod_quiz.warningdatadiscardedfromfinished'));\n        } else {\n          warnings.push(Translate.instant('addon.mod_quiz.warningdatadiscarded'));\n        }\n      }\n      // Send the answers.\n      yield AddonModQuiz.processAttempt(quiz, onlineAttempt, answers, preflightData, finish, false, false, siteId);\n      if (!finish) {\n        // Answers sent, now set the current page.\n        yield CoreUtils.ignoreErrors(AddonModQuiz.logViewAttempt(onlineAttempt.id, offlineAttempt.currentpage, preflightData, false, siteId));\n      }\n      // Data sent. Finish the sync.\n      return _this4.finishSync(siteId, quiz, courseId, warnings, {\n        attemptId: lastAttemptId,\n        offlineAttempt,\n        onlineAttempt,\n        removeAttempt: true,\n        updated: true,\n        onlineQuestions\n      });\n    })();\n  }\n  /**\n   * Validate questions, discarding the offline answers that can't be synchronized.\n   *\n   * @param attemptId Attempt ID.\n   * @param onlineQuestions Online questions\n   * @param offlineQuestions Offline questions.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if some offline data was discarded, false otherwise.\n   */\n  validateQuestions(attemptId, onlineQuestions, offlineQuestions, siteId) {\n    return _asyncToGenerator(function* () {\n      let discardedData = false;\n      yield Promise.all(Object.keys(offlineQuestions).map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (slotString) {\n          const slot = Number(slotString);\n          const offlineQuestion = offlineQuestions[slot];\n          const onlineQuestion = onlineQuestions[slot];\n          const offlineSequenceCheck = offlineQuestion.answers[':sequencecheck'];\n          if (onlineQuestion) {\n            // We found the online data for the question, validate that the sequence check is ok.\n            if (!CoreQuestionDelegate.validateSequenceCheck(onlineQuestion, offlineSequenceCheck)) {\n              // Sequence check is not valid, remove the offline data.\n              yield AddonModQuizOffline.removeQuestionAndAnswers(attemptId, slot, siteId);\n              discardedData = true;\n              delete offlineQuestions[slot];\n            } else {\n              // Sequence check is valid. Use the online one to prevent synchronization errors.\n              offlineQuestion.answers[':sequencecheck'] = String(onlineQuestion.sequencecheck);\n            }\n          } else {\n            // Online question not found, it can happen for 2 reasons:\n            // 1- It's a sequential quiz and the question is in a page already passed.\n            // 2- Quiz layout has changed (shouldn't happen since it's blocked if there are attempts).\n            yield AddonModQuizOffline.removeQuestionAndAnswers(attemptId, slot, siteId);\n            discardedData = true;\n            delete offlineQuestions[slot];\n          }\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return discardedData;\n    })();\n  }\n}\n_class = AddonModQuizSyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_quiz_autom_synced';\n_class.ɵfac = function AddonModQuizSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModQuizSync = makeSingleton(AddonModQuizSyncProvider);","map":{"version":3,"names":["CoreError","CoreCourseActivitySyncBaseProvider","CoreCourse","CoreCourseLogHelper","CoreCourseModulePrefetchDelegate","CoreQuestion","CoreQuestionDelegate","CoreNetwork","CoreSites","CoreSync","CoreUtils","makeSingleton","Translate","CoreEvents","AddonModQuizPrefetchHandler","AddonModQuiz","AddonModQuizProvider","AddonModQuizOffline","AddonModQuizSyncProvider","constructor","componentTranslatableString","finishSync","siteId","quiz","courseId","warnings","options","_this","_asyncToGenerator","ignoreErrors","invalidateAllQuizData","id","attemptId","removeAttempt","promises","push","removeAttemptAndAnswers","onlineQuestions","slot","deleteOfflineData","COMPONENT","coursemodule","Promise","all","updated","module","getModuleBasicInfoByInstance","prefetchAfterUpdateQuiz","_unused","setSyncTime","attemptFinished","onlineAttempt","isAttemptFinished","state","attempts","getUserAttempts","cmId","attempt","find","_options","hasDataToSync","quizId","getQuizAttempts","length","_unused2","_result$updates","shouldDownload","result","getModuleUpdates","updates","regex","entry","name","match","download","undefined","setStatusAfterPrefetch","readingStrategy","syncAllQuizzes","force","syncOnSites","syncAllQuizzesFunc","_this2","getAllAttempts","quizIds","map","_ref","_data$warnings","quizid","isBlocked","getQuizById","courseid","data","syncQuiz","syncQuizIfNeeded","setSyncWarnings","trigger","AUTO_SYNCED","_x","apply","arguments","askPreflight","_this3","needed","isSyncNeeded","getCurrentSiteId","currentSyncPromise","getOngoingSync","logger","debug","instant","$a","componentTranslate","addOngoingSync","performSyncQuiz","_this4","course","modOptions","syncActivity","offlineAttempts","offlineAttempt","pop","isOnline","onlineAttempts","lastAttemptId","answersList","getAttemptAnswers","offlineAnswers","convertAnswersArrayToObject","offlineQuestions","classifyAnswersInQuestions","info","getQuizAccessInformation","preflightData","getPreflightData","getAllQuestionsData","pages","getPagesFromLayoutAndQuestions","layout","discardedData","validateQuestions","Object","keys","_ref2","slotString","Number","onlineQuestion","prepareSyncData","answers","_x2","extractAnswersFromQuestions","finish","finished","processAttempt","logViewAttempt","currentpage","_ref3","offlineQuestion","offlineSequenceCheck","validateSequenceCheck","removeQuestionAndAnswers","String","sequencecheck","_x3","_class","factory","ɵfac","providedIn","AddonModQuizSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/quiz/services/quiz-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse, CoreCourseModuleBasicInfo } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreCourseModulePrefetchDelegate } from '@features/course/services/module-prefetch-delegate';\nimport { CoreQuestion, CoreQuestionQuestionParsed } from '@features/question/services/question';\nimport { CoreQuestionDelegate } from '@features/question/services/question-delegate';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModQuizAttemptDBRecord } from './database/quiz';\nimport { AddonModQuizPrefetchHandler } from './handlers/prefetch';\nimport { AddonModQuiz, AddonModQuizAttemptWSData, AddonModQuizProvider, AddonModQuizQuizWSData } from './quiz';\nimport { AddonModQuizOffline, AddonModQuizQuestionsWithAnswers } from './quiz-offline';\n\n/**\n * Service to sync quizzes.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModQuizSyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModQuizSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_quiz_autom_synced';\n\n    protected componentTranslatableString = 'quiz';\n\n    constructor() {\n        super('AddonModQuizSyncProvider');\n    }\n\n    /**\n     * Finish a sync process: remove offline data if needed, prefetch quiz data, set sync time and return the result.\n     *\n     * @param siteId Site ID.\n     * @param quiz Quiz.\n     * @param courseId Course ID.\n     * @param warnings List of warnings generated by the sync.\n     * @param options Other options.\n     * @returns Promise resolved on success.\n     */\n    protected async finishSync(\n        siteId: string,\n        quiz: AddonModQuizQuizWSData,\n        courseId: number,\n        warnings: string[],\n        options?: FinishSyncOptions,\n    ): Promise<AddonModQuizSyncResult> {\n        options = options || {};\n\n        // Invalidate the data for the quiz and attempt.\n        await CoreUtils.ignoreErrors(\n            AddonModQuiz.invalidateAllQuizData(quiz.id, courseId, options.attemptId, siteId),\n        );\n\n        if (options.removeAttempt && options.attemptId) {\n            const promises: Promise<unknown>[] = [];\n\n            promises.push(AddonModQuizOffline.removeAttemptAndAnswers(options.attemptId, siteId));\n\n            if (options.onlineQuestions) {\n                for (const slot in options.onlineQuestions) {\n                    promises.push(CoreQuestionDelegate.deleteOfflineData(\n                        options.onlineQuestions[slot],\n                        AddonModQuizProvider.COMPONENT,\n                        quiz.coursemodule,\n                        siteId,\n                    ));\n                }\n            }\n\n            await Promise.all(promises);\n        }\n\n        if (options.updated) {\n            try {\n                // Data has been sent. Update prefetched data.\n                const module = await CoreCourse.getModuleBasicInfoByInstance(quiz.id, 'quiz', { siteId });\n\n                await this.prefetchAfterUpdateQuiz(module, quiz, courseId, siteId);\n            } catch {\n                // Ignore errors.\n            }\n        }\n\n        await CoreUtils.ignoreErrors(this.setSyncTime(quiz.id, siteId));\n\n        // Check if online attempt was finished because of the sync.\n        let attemptFinished = false;\n        if (options.onlineAttempt && !AddonModQuiz.isAttemptFinished(options.onlineAttempt.state)) {\n            // Attempt wasn't finished at start. Check if it's finished now.\n            const attempts = await AddonModQuiz.getUserAttempts(quiz.id, { cmId: quiz.coursemodule, siteId });\n\n            const attempt = attempts.find(attempt => attempt.id == options?.onlineAttempt?.id);\n\n            attemptFinished = attempt ? AddonModQuiz.isAttemptFinished(attempt.state) : false;\n        }\n\n        return { warnings, attemptFinished, updated: !!options.updated || !!options.removeAttempt };\n    }\n\n    /**\n     * Check if a quiz has data to synchronize.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it has data to sync.\n     */\n    async hasDataToSync(quizId: number, siteId?: string): Promise<boolean> {\n        try {\n            const attempts = await AddonModQuizOffline.getQuizAttempts(quizId, siteId);\n\n            return !!attempts.length;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Conveniece function to prefetch data after an update.\n     *\n     * @param module Module.\n     * @param quiz Quiz.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchAfterUpdateQuiz(\n        module: CoreCourseModuleBasicInfo,\n        quiz: AddonModQuizQuizWSData,\n        courseId: number,\n        siteId?: string,\n    ): Promise<void> {\n        let shouldDownload = false;\n\n        // Get the module updates to check if the data was updated or not.\n        const result = await CoreCourseModulePrefetchDelegate.getModuleUpdates(module, courseId, true, siteId);\n\n        if (result?.updates?.length) {\n            const regex = /^.*files$/;\n\n            // Only prefetch if files haven't changed.\n            shouldDownload = !result.updates.find((entry) => entry.name.match(regex));\n\n            if (shouldDownload) {\n                await AddonModQuizPrefetchHandler.download(module, courseId, undefined, false, false);\n            }\n        }\n\n        // Prefetch finished or not needed, set the right status.\n        await AddonModQuizPrefetchHandler.setStatusAfterPrefetch(quiz, {\n            cmId: module.id,\n            readingStrategy: shouldDownload ? CoreSitesReadingStrategy.PREFER_CACHE : undefined,\n            siteId,\n        });\n    }\n\n    /**\n     * Try to synchronize all the quizzes in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllQuizzes(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all quizzes', (siteId) => this.syncAllQuizzesFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all quizzes on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllQuizzesFunc(force: boolean, siteId: string): Promise<void> {\n        // Get all offline attempts.\n        const attempts = await AddonModQuizOffline.getAllAttempts(siteId);\n\n        const quizIds: Record<number, boolean> = {}; // To prevent duplicates.\n\n        // Sync all quizzes that haven't been synced for a while and that aren't attempted right now.\n        await Promise.all(attempts.map(async (attempt) => {\n            if (quizIds[attempt.quizid]) {\n                // Quiz already treated.\n                return;\n            }\n            quizIds[attempt.quizid] = true;\n\n            if (CoreSync.isBlocked(AddonModQuizProvider.COMPONENT, attempt.quizid, siteId)) {\n                return;\n            }\n\n            // Quiz not blocked, try to synchronize it.\n            const quiz = await AddonModQuiz.getQuizById(attempt.courseid, attempt.quizid, { siteId });\n\n            const data = await (force ? this.syncQuiz(quiz, false, siteId) : this.syncQuizIfNeeded(quiz, false, siteId));\n\n            if (data?.warnings?.length) {\n                // Store the warnings to show them when the user opens the quiz.\n                await this.setSyncWarnings(quiz.id, data.warnings, siteId);\n            }\n\n            if (data) {\n                // Sync successful. Send event.\n                CoreEvents.trigger(AddonModQuizSyncProvider.AUTO_SYNCED, {\n                    quizId: quiz.id,\n                    attemptFinished: data.attemptFinished,\n                    warnings: data.warnings,\n                }, siteId);\n            }\n        }));\n    }\n\n    /**\n     * Sync a quiz only if a certain time has passed since the last time.\n     *\n     * @param quiz Quiz.\n     * @param askPreflight Whether we should ask for preflight data if needed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the quiz is synced or if it doesn't need to be synced.\n     */\n    async syncQuizIfNeeded(\n        quiz: AddonModQuizQuizWSData,\n        askPreflight?: boolean,\n        siteId?: string,\n    ): Promise<AddonModQuizSyncResult | undefined> {\n        const needed = await this.isSyncNeeded(quiz.id, siteId);\n\n        if (needed) {\n            return this.syncQuiz(quiz, askPreflight, siteId);\n        }\n    }\n\n    /**\n     * Try to synchronize a quiz.\n     * The promise returned will be resolved with an array with warnings if the synchronization is successful.\n     *\n     * @param quiz Quiz.\n     * @param askPreflight Whether we should ask for preflight data if needed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success.\n     */\n    syncQuiz(quiz: AddonModQuizQuizWSData, askPreflight?: boolean, siteId?: string): Promise<AddonModQuizSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(quiz.id, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this quiz, return the promise.\n            return currentSyncPromise;\n        }\n\n        // Verify that quiz isn't blocked.\n        if (CoreSync.isBlocked(AddonModQuizProvider.COMPONENT, quiz.id, siteId)) {\n            this.logger.debug('Cannot sync quiz ' + quiz.id + ' because it is blocked.');\n\n            throw new CoreError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));\n        }\n\n        return this.addOngoingSync(quiz.id, this.performSyncQuiz(quiz, askPreflight, siteId), siteId);\n    }\n\n    /**\n     * Perform the quiz sync.\n     *\n     * @param quiz Quiz.\n     * @param askPreflight Whether we should ask for preflight data if needed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success.\n     */\n    async performSyncQuiz(quiz: AddonModQuizQuizWSData, askPreflight?: boolean, siteId?: string): Promise<AddonModQuizSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const warnings: string[] = [];\n        const courseId = quiz.course;\n        const modOptions = {\n            cmId: quiz.coursemodule,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        this.logger.debug('Try to sync quiz ' + quiz.id + ' in site ' + siteId);\n\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(\n            CoreCourseLogHelper.syncActivity(AddonModQuizProvider.COMPONENT, quiz.id, siteId),\n        );\n\n        // Get all the offline attempts for the quiz. It should always be 0 or 1 attempt\n        const offlineAttempts = await AddonModQuizOffline.getQuizAttempts(quiz.id, siteId);\n        const offlineAttempt = offlineAttempts.pop();\n\n        if (!offlineAttempt) {\n            // Nothing to sync, finish.\n            return this.finishSync(siteId, quiz, courseId, warnings);\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreError(Translate.instant('core.cannotconnect'));\n        }\n\n        // Now get the list of online attempts to make sure this attempt exists and isn't finished.\n        const onlineAttempts = await AddonModQuiz.getUserAttempts(quiz.id, modOptions);\n\n        const lastAttemptId = onlineAttempts.length ? onlineAttempts[onlineAttempts.length - 1].id : undefined;\n        const onlineAttempt = onlineAttempts.find((attempt) => attempt.id == offlineAttempt.id);\n\n        if (!onlineAttempt || AddonModQuiz.isAttemptFinished(onlineAttempt.state)) {\n            // Attempt not found or it's finished in online. Discard it.\n            warnings.push(Translate.instant('addon.mod_quiz.warningattemptfinished'));\n\n            return this.finishSync(siteId, quiz, courseId, warnings, {\n                attemptId: offlineAttempt.id,\n                offlineAttempt,\n                onlineAttempt,\n                removeAttempt: true,\n            });\n        }\n\n        // Get the data stored in offline.\n        const answersList = await AddonModQuizOffline.getAttemptAnswers(offlineAttempt.id, siteId);\n\n        if (!answersList.length) {\n            // No answers stored, finish.\n            return this.finishSync(siteId, quiz, courseId, warnings, {\n                attemptId: lastAttemptId,\n                offlineAttempt,\n                onlineAttempt,\n                removeAttempt: true,\n            });\n        }\n\n        const offlineAnswers = CoreQuestion.convertAnswersArrayToObject(answersList);\n        const offlineQuestions = AddonModQuizOffline.classifyAnswersInQuestions(offlineAnswers);\n\n        // We're going to need preflightData, get it.\n        const info = await AddonModQuiz.getQuizAccessInformation(quiz.id, modOptions);\n\n        const preflightData = await AddonModQuizPrefetchHandler.getPreflightData(\n            quiz,\n            info,\n            onlineAttempt,\n            askPreflight,\n            'core.settings.synchronization',\n            siteId,\n        );\n\n        // Now get the online questions data.\n        const onlineQuestions = await AddonModQuiz.getAllQuestionsData(quiz, onlineAttempt, preflightData, {\n            pages: AddonModQuiz.getPagesFromLayoutAndQuestions(onlineAttempt.layout || '', offlineQuestions),\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        });\n\n        // Validate questions, discarding the offline answers that can't be synchronized.\n        const discardedData = await this.validateQuestions(onlineAttempt.id, onlineQuestions, offlineQuestions, siteId);\n\n        // Let questions prepare the data to send.\n        await Promise.all(Object.keys(offlineQuestions).map(async (slotString) => {\n            const slot = Number(slotString);\n            const onlineQuestion = onlineQuestions[slot];\n\n            await CoreQuestionDelegate.prepareSyncData(\n                onlineQuestion,\n                offlineQuestions[slot].answers,\n                AddonModQuizProvider.COMPONENT,\n                quiz.coursemodule,\n                siteId,\n            );\n        }));\n\n        // Get the answers to send.\n        const answers = AddonModQuizOffline.extractAnswersFromQuestions(offlineQuestions);\n        const finish = !!offlineAttempt.finished && !discardedData;\n\n        if (discardedData) {\n            if (offlineAttempt.finished) {\n                warnings.push(Translate.instant('addon.mod_quiz.warningdatadiscardedfromfinished'));\n            } else {\n                warnings.push(Translate.instant('addon.mod_quiz.warningdatadiscarded'));\n            }\n        }\n\n        // Send the answers.\n        await AddonModQuiz.processAttempt(quiz, onlineAttempt, answers, preflightData, finish, false, false, siteId);\n\n        if (!finish) {\n            // Answers sent, now set the current page.\n            await CoreUtils.ignoreErrors(AddonModQuiz.logViewAttempt(\n                onlineAttempt.id,\n                offlineAttempt.currentpage,\n                preflightData,\n                false,\n                siteId,\n            ));\n        }\n\n        // Data sent. Finish the sync.\n        return this.finishSync(siteId, quiz, courseId, warnings, {\n            attemptId: lastAttemptId,\n            offlineAttempt,\n            onlineAttempt,\n            removeAttempt: true,\n            updated: true,\n            onlineQuestions,\n        });\n    }\n\n    /**\n     * Validate questions, discarding the offline answers that can't be synchronized.\n     *\n     * @param attemptId Attempt ID.\n     * @param onlineQuestions Online questions\n     * @param offlineQuestions Offline questions.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if some offline data was discarded, false otherwise.\n     */\n    async validateQuestions(\n        attemptId: number,\n        onlineQuestions: Record<number, CoreQuestionQuestionParsed>,\n        offlineQuestions: AddonModQuizQuestionsWithAnswers,\n        siteId?: string,\n    ): Promise<boolean> {\n        let discardedData = false;\n\n        await Promise.all(Object.keys(offlineQuestions).map(async (slotString) => {\n            const slot = Number(slotString);\n            const offlineQuestion = offlineQuestions[slot];\n            const onlineQuestion = onlineQuestions[slot];\n            const offlineSequenceCheck = <string> offlineQuestion.answers[':sequencecheck'];\n\n            if (onlineQuestion) {\n                // We found the online data for the question, validate that the sequence check is ok.\n                if (!CoreQuestionDelegate.validateSequenceCheck(onlineQuestion, offlineSequenceCheck)) {\n                    // Sequence check is not valid, remove the offline data.\n                    await AddonModQuizOffline.removeQuestionAndAnswers(attemptId, slot, siteId);\n\n                    discardedData = true;\n                    delete offlineQuestions[slot];\n                } else {\n                    // Sequence check is valid. Use the online one to prevent synchronization errors.\n                    offlineQuestion.answers[':sequencecheck'] = String(onlineQuestion.sequencecheck);\n                }\n            } else {\n                // Online question not found, it can happen for 2 reasons:\n                // 1- It's a sequential quiz and the question is in a page already passed.\n                // 2- Quiz layout has changed (shouldn't happen since it's blocked if there are attempts).\n                await AddonModQuizOffline.removeQuestionAndAnswers(attemptId, slot, siteId);\n\n                discardedData = true;\n                delete offlineQuestions[slot];\n            }\n        }));\n\n        return discardedData;\n    }\n\n}\n\nexport const AddonModQuizSync = makeSingleton(AddonModQuizSyncProvider);\n\n/**\n * Data returned by a quiz sync.\n */\nexport type AddonModQuizSyncResult = CoreSyncResult & {\n    attemptFinished: boolean; // Whether an attempt was finished in the site due to the sync.\n};\n\n/**\n * Options to pass to finish sync.\n */\ntype FinishSyncOptions = {\n    attemptId?: number; // Last attempt ID.\n    offlineAttempt?: AddonModQuizAttemptDBRecord; // Offline attempt synchronized, if any.\n    onlineAttempt?: AddonModQuizAttemptWSData; // Online data for the offline attempt.\n    removeAttempt?: boolean; // Whether the offline data should be removed.\n    updated?: boolean; // Whether the offline data should be removed.\n    onlineQuestions?: Record<number, CoreQuestionQuestionParsed>; // Online questions indexed by slot.\n};\n\n/**\n * Data passed to AUTO_SYNCED event.\n */\nexport type AddonModQuizAutoSyncData = {\n    quizId: number;\n    attemptFinished: boolean;\n    warnings: string[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}