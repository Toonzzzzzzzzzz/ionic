{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { asyncInstance } from '@/core/utils/async-instance';\nimport { CoreApp } from '@services/app';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport { makeSingleton } from '@singletons';\nimport { APP_SCHEMA, TABLE_NAME } from './database/storage';\nimport { CoreSites } from './sites';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to store data using key-value pairs.\n *\n * The data can be scoped to a single site using CoreStorage.forSite(site), and it will be automatically cleared\n * when the site is deleted.\n *\n * For tabular data, use CoreAppProvider.getDB() or CoreSite.getDb().\n */\nexport class CoreStorageService {\n  constructor(lazyTableConstructor) {\n    this.table = asyncInstance(lazyTableConstructor);\n  }\n  /**\n   * Initialize database.\n   */\n  initializeDatabase() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield CoreApp.createTablesFromSchema(APP_SCHEMA);\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      yield _this.initializeTable(CoreApp.getDB());\n    })();\n  }\n  /**\n   * Initialize table.\n   *\n   * @param database Database.\n   */\n  initializeTable(database) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const table = yield getStorageTable(database);\n      _this2.table.setInstance(table);\n    })();\n  }\n  get(key, defaultValue = null) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const {\n          value\n        } = yield _this3.table.getOneByPrimaryKey({\n          key\n        });\n        return JSON.parse(value);\n      } catch (error) {\n        return defaultValue;\n      }\n    })();\n  }\n  getFromDB(key, defaultValue = null) {\n    return _asyncToGenerator(function* () {\n      try {\n        const db = CoreApp.getDB();\n        const {\n          value\n        } = yield db.getRecord(TABLE_NAME, {\n          key\n        });\n        return JSON.parse(value);\n      } catch (error) {\n        return defaultValue;\n      }\n    })();\n  }\n  /**\n   * Set value.\n   *\n   * @param key Data key.\n   * @param value Data value.\n   */\n  set(key, value) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4.table.insert({\n        key,\n        value: JSON.stringify(value)\n      });\n    })();\n  }\n  /**\n   * Check if value exists.\n   *\n   * @param key Data key.\n   * @returns Whether key exists or not.\n   */\n  has(key) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5.table.hasAny({\n        key\n      });\n    })();\n  }\n  /**\n   * Remove value.\n   *\n   * @param key Data key.\n   */\n  remove(key) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.table.deleteByPrimaryKey({\n        key\n      });\n    })();\n  }\n  /**\n   * Get the core_storage table of the current site.\n   *\n   * @returns CoreStorageService instance with the core_storage table.\n   */\n  forCurrentSite() {\n    return asyncInstance( /*#__PURE__*/_asyncToGenerator(function* () {\n      const siteId = yield CoreSites.getStoredCurrentSiteId();\n      const site = yield CoreSites.getSite(siteId);\n      if (!(siteId in SERVICE_INSTANCES)) {\n        SERVICE_INSTANCES[siteId] = asyncInstance( /*#__PURE__*/_asyncToGenerator(function* () {\n          const instance = new CoreStorageService();\n          yield instance.initializeTable(site.getDb());\n          return instance;\n        }));\n      }\n      return yield SERVICE_INSTANCES[siteId].getInstance();\n    }));\n  }\n  /**\n   * Get the core_storage table for the provided site.\n   *\n   * @param site Site from which we will obtain the storage.\n   * @returns CoreStorageService instance with the core_storage table.\n   */\n  forSite(site) {\n    const siteId = site.getId();\n    return asyncInstance( /*#__PURE__*/_asyncToGenerator(function* () {\n      if (!(siteId in SERVICE_INSTANCES)) {\n        const instance = new CoreStorageService();\n        yield instance.initializeTable(site.getDb());\n        SERVICE_INSTANCES[siteId] = asyncInstance(() => instance);\n      }\n      return yield SERVICE_INSTANCES[siteId].getInstance();\n    }));\n  }\n}\n_class = CoreStorageService;\n_class.ɵfac = function CoreStorageService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(null, 8));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreStorage = makeSingleton(CoreStorageService);\nconst SERVICE_INSTANCES = {};\nconst TABLE_INSTANCES = new WeakMap();\n/**\n * Helper function to get a storage table for the given database.\n *\n * @param database Database.\n * @returns Storage table.\n */\nfunction getStorageTable(database) {\n  const existingTable = TABLE_INSTANCES.get(database);\n  if (existingTable) {\n    return existingTable;\n  }\n  const table = new Promise((resolve, reject) => {\n    const tableProxy = new CoreDatabaseTableProxy({\n      cachingStrategy: CoreDatabaseCachingStrategy.Eager\n    }, database, TABLE_NAME, ['key']);\n    tableProxy.initialize().then(() => resolve(tableProxy)).catch(reject);\n  });\n  TABLE_INSTANCES.set(database, table);\n  return table;\n}","map":{"version":3,"names":["asyncInstance","CoreApp","CoreDatabaseCachingStrategy","CoreDatabaseTableProxy","makeSingleton","APP_SCHEMA","TABLE_NAME","CoreSites","CoreStorageService","constructor","lazyTableConstructor","table","initializeDatabase","_this","_asyncToGenerator","createTablesFromSchema","_unused","initializeTable","getDB","database","_this2","getStorageTable","setInstance","get","key","defaultValue","_this3","value","getOneByPrimaryKey","JSON","parse","error","getFromDB","db","getRecord","set","_this4","insert","stringify","has","_this5","hasAny","remove","_this6","deleteByPrimaryKey","forCurrentSite","siteId","getStoredCurrentSiteId","site","getSite","SERVICE_INSTANCES","instance","getDb","getInstance","forSite","getId","i0","ɵɵinject","factory","ɵfac","providedIn","CoreStorage","TABLE_INSTANCES","WeakMap","existingTable","Promise","resolve","reject","tableProxy","cachingStrategy","Eager","initialize","then","catch"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/storage.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Inject, Injectable, Optional } from '@angular/core';\n\nimport { AsyncInstance, asyncInstance } from '@/core/utils/async-instance';\nimport { CoreApp } from '@services/app';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport { CoreDatabaseTable } from '@classes/database/database-table';\nimport { makeSingleton } from '@singletons';\nimport { SQLiteDB } from '@classes/sqlitedb';\n\nimport { APP_SCHEMA, CoreStorageRecord, TABLE_NAME } from './database/storage';\nimport { CoreSites } from './sites';\nimport { CoreSite } from '@classes/sites/site';\n\n/**\n * Service to store data using key-value pairs.\n *\n * The data can be scoped to a single site using CoreStorage.forSite(site), and it will be automatically cleared\n * when the site is deleted.\n *\n * For tabular data, use CoreAppProvider.getDB() or CoreSite.getDb().\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreStorageService {\n\n    table: AsyncInstance<CoreStorageTable>;\n\n    constructor(@Optional() @Inject(null) lazyTableConstructor?: () => Promise<CoreStorageTable>) {\n        this.table = asyncInstance(lazyTableConstructor);\n    }\n\n    /**\n     * Initialize database.\n     */\n    async initializeDatabase(): Promise<void> {\n        try {\n            await CoreApp.createTablesFromSchema(APP_SCHEMA);\n        } catch {\n            // Ignore errors.\n        }\n\n        await this.initializeTable(CoreApp.getDB());\n    }\n\n    /**\n     * Initialize table.\n     *\n     * @param database Database.\n     */\n    async initializeTable(database: SQLiteDB): Promise<void> {\n        const table = await getStorageTable(database);\n\n        this.table.setInstance(table);\n    }\n\n    /**\n     * Get value.\n     *\n     * @param key Data key.\n     * @param defaultValue Value to return if the key wasn't found.\n     * @returns Data value.\n     */\n    async get<T=unknown>(key: string): Promise<T | null>;\n    async get<T>(key: string, defaultValue: T): Promise<T>;\n    async get<T=unknown>(key: string, defaultValue: T | null = null): Promise<T | null> {\n        try {\n            const { value } = await this.table.getOneByPrimaryKey({ key });\n\n            return JSON.parse(value);\n        } catch (error) {\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Get value directly from the database, without using any optimizations..\n     *\n     * @param key Data key.\n     * @param defaultValue Value to return if the key wasn't found.\n     * @returns Data value.\n     */\n    async getFromDB<T=unknown>(key: string): Promise<T | null>;\n    async getFromDB<T>(key: string, defaultValue: T): Promise<T>;\n    async getFromDB<T=unknown>(key: string, defaultValue: T | null = null): Promise<T | null> {\n        try {\n            const db = CoreApp.getDB();\n            const { value } = await db.getRecord<CoreStorageRecord>(TABLE_NAME, { key });\n\n            return JSON.parse(value);\n        } catch (error) {\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Set value.\n     *\n     * @param key Data key.\n     * @param value Data value.\n     */\n    async set(key: string, value: unknown): Promise<void> {\n        await this.table.insert({ key, value: JSON.stringify(value) });\n    }\n\n    /**\n     * Check if value exists.\n     *\n     * @param key Data key.\n     * @returns Whether key exists or not.\n     */\n    async has(key: string): Promise<boolean> {\n        return this.table.hasAny({ key });\n    }\n\n    /**\n     * Remove value.\n     *\n     * @param key Data key.\n     */\n    async remove(key: string): Promise<void> {\n        await this.table.deleteByPrimaryKey({ key });\n    }\n\n    /**\n     * Get the core_storage table of the current site.\n     *\n     * @returns CoreStorageService instance with the core_storage table.\n     */\n    forCurrentSite(): AsyncInstance<Omit<CoreStorageService, 'forSite' | 'forCurrentSite'>> {\n        return asyncInstance(async () => {\n            const siteId = await CoreSites.getStoredCurrentSiteId();\n            const site = await CoreSites.getSite(siteId);\n\n            if (!(siteId in SERVICE_INSTANCES)) {\n                SERVICE_INSTANCES[siteId] = asyncInstance(async () => {\n                    const instance = new CoreStorageService();\n                    await instance.initializeTable(site.getDb());\n\n                    return instance;\n                });\n            }\n\n            return await SERVICE_INSTANCES[siteId].getInstance();\n        });\n    }\n\n    /**\n     * Get the core_storage table for the provided site.\n     *\n     * @param site Site from which we will obtain the storage.\n     * @returns CoreStorageService instance with the core_storage table.\n     */\n    forSite(site: CoreSite): AsyncInstance<Omit<CoreStorageService, 'forSite' | 'forCurrentSite'>> {\n        const siteId = site.getId();\n\n        return asyncInstance(async () => {\n            if (!(siteId in SERVICE_INSTANCES)) {\n                const instance = new CoreStorageService();\n                await instance.initializeTable(site.getDb());\n\n                SERVICE_INSTANCES[siteId] = asyncInstance(() => instance);\n            }\n\n            return await SERVICE_INSTANCES[siteId].getInstance();\n        });\n    }\n\n}\n\nexport const CoreStorage = makeSingleton(CoreStorageService);\n\nconst SERVICE_INSTANCES: Record<string, AsyncInstance<CoreStorageService>> = {};\nconst TABLE_INSTANCES: WeakMap<SQLiteDB, Promise<CoreStorageTable>> = new WeakMap();\n\n/**\n * Helper function to get a storage table for the given database.\n *\n * @param database Database.\n * @returns Storage table.\n */\nfunction getStorageTable(database: SQLiteDB): Promise<CoreStorageTable> {\n    const existingTable = TABLE_INSTANCES.get(database);\n\n    if (existingTable) {\n        return existingTable;\n    }\n\n    const table = new Promise<CoreStorageTable>((resolve, reject) => {\n        const tableProxy = new CoreDatabaseTableProxy<CoreStorageRecord, 'key'>(\n            { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            database,\n            TABLE_NAME,\n            ['key'],\n        );\n\n        tableProxy.initialize()\n            .then(() => resolve(tableProxy))\n            .catch(reject);\n    });\n\n    TABLE_INSTANCES.set(database, table);\n\n    return table;\n}\n\n/**\n * Storage table.\n */\ntype CoreStorageTable = CoreDatabaseTable<CoreStorageRecord, 'key'>;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}