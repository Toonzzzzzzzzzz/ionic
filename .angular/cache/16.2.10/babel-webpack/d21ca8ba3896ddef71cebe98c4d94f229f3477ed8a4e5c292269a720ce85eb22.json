{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ViewContainerRef } from '@angular/core';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreContextMenuComponent } from '../context-menu/context-menu';\nimport { CoreDirectivesRegistry } from '@singletons/directives-registry';\nimport { CoreDom } from '@singletons/dom';\nimport * as i0 from \"@angular/core\";\nconst _c0 = [\"contextMenuContainer\"];\nconst _c1 = [\"*\"];\nconst BUTTON_HIDDEN_CLASS = 'core-navbar-button-hidden';\n/**\n * Component to add buttons to the app's header without having to place them inside the header itself. This is meant for\n * pages that are loaded inside a sub ion-nav, so they don't have a header.\n *\n * If this component indicates a position (start/end), the buttons will only be added if the header has some buttons in that\n * position. If no start/end is specified, then the buttons will be added to the first <ion-buttons> found in the header.\n *\n * If this component has a \"prepend\" attribute, the buttons will be added before other existing buttons in the header.\n *\n * You can use the [hidden] input to hide all the inner buttons if a certain condition is met.\n *\n * IMPORTANT: Do not use *ngIf in the buttons inside this component, it can cause problems. Please use [hidden] instead.\n *\n * Example usage:\n *\n * <core-navbar-buttons slot=\"end\">\n *     <ion-button [hidden]=\"!buttonShown\" [attr.aria-label]=\"Do something\" (click)=\"action()\">\n *         <ion-icon name=\"funnel\" slot=\"icon-only\" aria-hidden=\"true\"></ion-icon>\n *     </ion-button>\n * </core-navbar-buttons>\n */\nexport class CoreNavBarButtonsComponent {\n  // If the hidden input is true, hide all buttons.\n  // eslint-disable-next-line @angular-eslint/no-input-rename\n  set hidden(value) {\n    if (typeof value === 'string' && value === '') {\n      value = true;\n    }\n    this.allButtonsHidden = value;\n    this.showHideAllElements();\n  }\n  constructor(element) {\n    this.allButtonsHidden = false;\n    this.forceHidden = false;\n    this.element = element.nativeElement;\n    this.logger = CoreLogger.getInstance('CoreNavBarButtonsComponent');\n    CoreDirectivesRegistry.register(this.element, this);\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnInit() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const header = yield _this.searchHeader();\n        if (header) {\n          // Search the right buttons container (start, end or any).\n          let selector = 'ion-buttons';\n          let slot = _this.element.getAttribute('slot');\n          // Take the slot from the parent if it has.\n          if (!slot && _this.element.parentElement) {\n            slot = _this.element.parentElement.getAttribute('slot');\n          }\n          if (slot) {\n            selector += '[slot=\"' + slot + '\"]';\n          }\n          const buttonsContainer = header.querySelector(selector);\n          if (buttonsContainer) {\n            _this.mergeContextMenus(buttonsContainer);\n            const prepend = _this.element.hasAttribute('prepend');\n            _this.movedChildren = CoreDomUtils.moveChildren(_this.element, buttonsContainer, prepend);\n            _this.showHideAllElements();\n            // Make sure that context-menu is always at the end of buttons if any.\n            const contextMenu = buttonsContainer.querySelector('core-context-menu');\n            const userMenu = buttonsContainer.querySelector('core-user-menu-button');\n            if (userMenu) {\n              var _contextMenu$parentEl;\n              contextMenu === null || contextMenu === void 0 || (_contextMenu$parentEl = contextMenu.parentElement) === null || _contextMenu$parentEl === void 0 || _contextMenu$parentEl.insertBefore(contextMenu, userMenu);\n            } else {\n              var _contextMenu$parentEl2;\n              contextMenu === null || contextMenu === void 0 || (_contextMenu$parentEl2 = contextMenu.parentElement) === null || _contextMenu$parentEl2 === void 0 || _contextMenu$parentEl2.appendChild(contextMenu);\n            }\n          } else {\n            _this.logger.warn('The header was found, but it didn\\'t have the right ion-buttons.', selector);\n          }\n        }\n      } catch (error) {\n        // Header not found.\n        _this.logger.error(error);\n      }\n    })();\n  }\n  /**\n   * Force or unforce hiding all buttons. If this is true, it will override the \"hidden\" input.\n   *\n   * @param value The value to set.\n   */\n  forceHide(value) {\n    this.forceHidden = value;\n    this.showHideAllElements();\n  }\n  /**\n   * If both button containers have a context menu, merge them into a single one.\n   *\n   * @param buttonsContainer The container where the buttons will be moved.\n   */\n  mergeContextMenus(buttonsContainer) {\n    // Check if both button containers have a context menu.\n    const secondaryContextMenu = this.element.querySelector('core-context-menu');\n    if (!secondaryContextMenu) {\n      return;\n    }\n    const mainContextMenu = buttonsContainer.querySelector('core-context-menu');\n    const secondaryContextMenuInstance = CoreDirectivesRegistry.resolve(secondaryContextMenu, CoreContextMenuComponent);\n    let mainContextMenuInstance;\n    if (mainContextMenu) {\n      // Both containers have a context menu. Merge them to prevent having 2 menus at the same time.\n      mainContextMenuInstance = CoreDirectivesRegistry.resolve(mainContextMenu, CoreContextMenuComponent);\n    } else {\n      // There is a context-menu in these buttons, but there is no main context menu in the header.\n      // Create one main context menu dynamically.\n      // @todo: Find a better way to handle header buttons. This isn't working as expected in some cases because the menu\n      // is destroyed when the page is destroyed, so click listeners stop working.\n      mainContextMenuInstance = this.createMainContextMenu();\n    }\n    // Check that both context menus belong to the same core-tab. We shouldn't merge menus from different tabs.\n    if (mainContextMenuInstance && secondaryContextMenuInstance) {\n      var _secondaryContextMenu;\n      this.mergedContextMenu = secondaryContextMenuInstance;\n      this.mergedContextMenu.mergeContextMenus(mainContextMenuInstance);\n      // Remove the empty context menu from the DOM.\n      (_secondaryContextMenu = secondaryContextMenu.parentElement) === null || _secondaryContextMenu === void 0 || _secondaryContextMenu.removeChild(secondaryContextMenu);\n    }\n  }\n  /**\n   * Create a new and empty context menu to be used as a \"parent\".\n   *\n   * @returns Created component.\n   */\n  createMainContextMenu() {\n    const componentRef = this.container.createComponent(CoreContextMenuComponent);\n    this.createdMainContextMenuElement = componentRef.location.nativeElement;\n    return componentRef.instance;\n  }\n  /**\n   * Search the ion-header where the buttons should be added.\n   *\n   * @returns Promise resolved with the header element.\n   */\n  searchHeader() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreDom.waitToBeInDOM(_this2.element);\n      let parentPage = _this2.element;\n      while (parentPage && parentPage.parentElement) {\n        var _parentPage, _content$parentElemen;\n        const content = parentPage.closest('ion-content');\n        if (content) {\n          // Sometimes ion-page class is not yet added by the ViewController, wait for content to render.\n          yield content.componentOnReady();\n        }\n        parentPage = parentPage.parentElement.closest('.ion-page, .ion-page-hidden, .ion-page-invisible');\n        // Check if the page has a header. If it doesn't, search the next parent page.\n        let header = (_parentPage = parentPage) === null || _parentPage === void 0 ? void 0 : _parentPage.querySelector(':scope > ion-header');\n        if (header && getComputedStyle(header).display !== 'none') {\n          return header;\n        }\n        // Find using content if any.\n        header = content === null || content === void 0 || (_content$parentElemen = content.parentElement) === null || _content$parentElemen === void 0 ? void 0 : _content$parentElemen.querySelector(':scope > ion-header');\n        if (header && getComputedStyle(header).display !== 'none') {\n          return header;\n        }\n      }\n      // Header not found, reject.\n      throw Error('Header not found.');\n    })();\n  }\n  /**\n   * Show or hide all the elements.\n   */\n  showHideAllElements() {\n    var _this$movedChildren;\n    // Show or hide all moved children.\n    (_this$movedChildren = this.movedChildren) === null || _this$movedChildren === void 0 || _this$movedChildren.forEach(child => {\n      this.showHideElement(child);\n    });\n    // Show or hide all the context menu items that were merged to another context menu.\n    if (this.mergedContextMenu) {\n      if (this.forceHidden || this.allButtonsHidden) {\n        this.mergedContextMenu.removeMergedItems();\n      } else {\n        this.mergedContextMenu.restoreMergedItems();\n      }\n    }\n  }\n  /**\n   * Show or hide an element.\n   *\n   * @param element Element to show or hide.\n   */\n  showHideElement(element) {\n    // Check if it's an HTML Element and it's not a created context menu. Never hide created context menus.\n    if (element instanceof Element && element !== this.createdMainContextMenuElement) {\n      element.classList.toggle(BUTTON_HIDDEN_CLASS, !!this.forceHidden || !!this.allButtonsHidden);\n    }\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnDestroy() {\n    var _this$movedChildren2, _this$mergedContextMe;\n    // This component was destroyed, remove all the buttons that were moved.\n    // The buttons can be moved outside of the current page, that's why we need to manually destroy them.\n    // There's no need to destroy context menu items that were merged because they weren't moved from their DOM position.\n    (_this$movedChildren2 = this.movedChildren) === null || _this$movedChildren2 === void 0 || _this$movedChildren2.forEach(child => {\n      if (child.parentElement && child !== this.createdMainContextMenuElement) {\n        child.parentElement.removeChild(child);\n      }\n    });\n    (_this$mergedContextMe = this.mergedContextMenu) === null || _this$mergedContextMe === void 0 || _this$mergedContextMe.removeMergedItems();\n  }\n}\n_class = CoreNavBarButtonsComponent;\n_class.ɵfac = function CoreNavBarButtonsComponent_Factory(t) {\n  return new (t || _class)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n_class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: _class,\n  selectors: [[\"core-navbar-buttons\"]],\n  viewQuery: function CoreNavBarButtonsComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5, ViewContainerRef);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n    }\n  },\n  inputs: {\n    hidden: \"hidden\"\n  },\n  ngContentSelectors: _c1,\n  decls: 4,\n  vars: 0,\n  consts: [[\"contextMenuContainer\", \"\"]],\n  template: function CoreNavBarButtonsComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵprojection(0);\n      i0.ɵɵelementStart(1, \"template\", null, 0);\n      i0.ɵɵtext(3, \"-\");\n      i0.ɵɵelementEnd();\n    }\n  },\n  styles: [\"[_nghost-%COMP%] {\\n  display: none !important;\\n}\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9jb3JlL2NvbXBvbmVudHMvbmF2YmFyLWJ1dHRvbnMvbmF2YmFyLWJ1dHRvbnMuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNJLHdCQUFBO0FBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyI6aG9zdCB7XG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ== */\"]\n});","map":{"version":3,"names":["ViewContainerRef","CoreLogger","CoreDomUtils","CoreContextMenuComponent","CoreDirectivesRegistry","CoreDom","BUTTON_HIDDEN_CLASS","CoreNavBarButtonsComponent","hidden","value","allButtonsHidden","showHideAllElements","constructor","element","forceHidden","nativeElement","logger","getInstance","register","ngOnInit","_this","_asyncToGenerator","header","searchHeader","selector","slot","getAttribute","parentElement","buttonsContainer","querySelector","mergeContextMenus","prepend","hasAttribute","movedChildren","moveChildren","contextMenu","userMenu","_contextMenu$parentEl","insertBefore","_contextMenu$parentEl2","appendChild","warn","error","forceHide","secondaryContextMenu","mainContextMenu","secondaryContextMenuInstance","resolve","mainContextMenuInstance","createMainContextMenu","_secondaryContextMenu","mergedContextMenu","removeChild","componentRef","container","createComponent","createdMainContextMenuElement","location","instance","_this2","waitToBeInDOM","parentPage","_parentPage","_content$parentElemen","content","closest","componentOnReady","getComputedStyle","display","Error","_this$movedChildren","forEach","child","showHideElement","removeMergedItems","restoreMergedItems","Element","classList","toggle","ngOnDestroy","_this$movedChildren2","_this$mergedContextMe","i0","ɵɵdirectiveInject","ElementRef","selectors","viewQuery","CoreNavBarButtonsComponent_Query","rf","ctx","ɵɵprojection","ɵɵelementStart","ɵɵtext","ɵɵelementEnd"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/components/navbar-buttons/navbar-buttons.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n    Component,\n    Input,\n    OnInit,\n    OnDestroy,\n    ElementRef,\n    ViewContainerRef,\n    ViewChild,\n} from '@angular/core';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreContextMenuComponent } from '../context-menu/context-menu';\nimport { CoreDirectivesRegistry } from '@singletons/directives-registry';\nimport { CoreDom } from '@singletons/dom';\n\nconst BUTTON_HIDDEN_CLASS = 'core-navbar-button-hidden';\n\n/**\n * Component to add buttons to the app's header without having to place them inside the header itself. This is meant for\n * pages that are loaded inside a sub ion-nav, so they don't have a header.\n *\n * If this component indicates a position (start/end), the buttons will only be added if the header has some buttons in that\n * position. If no start/end is specified, then the buttons will be added to the first <ion-buttons> found in the header.\n *\n * If this component has a \"prepend\" attribute, the buttons will be added before other existing buttons in the header.\n *\n * You can use the [hidden] input to hide all the inner buttons if a certain condition is met.\n *\n * IMPORTANT: Do not use *ngIf in the buttons inside this component, it can cause problems. Please use [hidden] instead.\n *\n * Example usage:\n *\n * <core-navbar-buttons slot=\"end\">\n *     <ion-button [hidden]=\"!buttonShown\" [attr.aria-label]=\"Do something\" (click)=\"action()\">\n *         <ion-icon name=\"funnel\" slot=\"icon-only\" aria-hidden=\"true\"></ion-icon>\n *     </ion-button>\n * </core-navbar-buttons>\n */\n@Component({\n    selector: 'core-navbar-buttons',\n    template: '<ng-content></ng-content><template #contextMenuContainer>-</template>',\n    styleUrls: ['navbar-buttons.scss'],\n})\nexport class CoreNavBarButtonsComponent implements OnInit, OnDestroy {\n\n    @ViewChild('contextMenuContainer', { read: ViewContainerRef }) container!: ViewContainerRef;\n\n    // If the hidden input is true, hide all buttons.\n    // eslint-disable-next-line @angular-eslint/no-input-rename\n    @Input('hidden') set hidden(value: boolean) {\n        if (typeof value === 'string' && value === '') {\n            value = true;\n        }\n        this.allButtonsHidden = value;\n        this.showHideAllElements();\n    }\n\n    protected element: HTMLElement;\n    protected allButtonsHidden = false;\n    protected forceHidden = false;\n    protected logger: CoreLogger;\n    protected movedChildren?: Node[];\n    protected mergedContextMenu?: CoreContextMenuComponent;\n    protected createdMainContextMenuElement?: HTMLElement;\n\n    constructor(element: ElementRef) {\n        this.element = element.nativeElement;\n        this.logger = CoreLogger.getInstance('CoreNavBarButtonsComponent');\n\n        CoreDirectivesRegistry.register(this.element, this);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async ngOnInit(): Promise<void> {\n        try {\n            const header = await this.searchHeader();\n            if (header) {\n                // Search the right buttons container (start, end or any).\n                let selector = 'ion-buttons';\n\n                let slot = this.element.getAttribute('slot');\n                // Take the slot from the parent if it has.\n                if (!slot && this.element.parentElement) {\n                    slot = this.element.parentElement.getAttribute('slot');\n                }\n                if (slot) {\n                    selector += '[slot=\"' + slot + '\"]';\n                }\n\n                const buttonsContainer = header.querySelector<HTMLIonButtonsElement>(selector);\n                if (buttonsContainer) {\n                    this.mergeContextMenus(buttonsContainer);\n\n                    const prepend = this.element.hasAttribute('prepend');\n\n                    this.movedChildren = CoreDomUtils.moveChildren(this.element, buttonsContainer, prepend);\n                    this.showHideAllElements();\n\n                    // Make sure that context-menu is always at the end of buttons if any.\n                    const contextMenu = buttonsContainer.querySelector('core-context-menu');\n                    const userMenu = buttonsContainer.querySelector('core-user-menu-button');\n\n                    if (userMenu) {\n                        contextMenu?.parentElement?.insertBefore(contextMenu, userMenu);\n                    } else {\n                        contextMenu?.parentElement?.appendChild(contextMenu);\n                    }\n                } else {\n                    this.logger.warn('The header was found, but it didn\\'t have the right ion-buttons.', selector);\n                }\n            }\n        } catch (error) {\n            // Header not found.\n            this.logger.error(error);\n        }\n    }\n\n    /**\n     * Force or unforce hiding all buttons. If this is true, it will override the \"hidden\" input.\n     *\n     * @param value The value to set.\n     */\n    forceHide(value: boolean): void {\n        this.forceHidden = value;\n\n        this.showHideAllElements();\n    }\n\n    /**\n     * If both button containers have a context menu, merge them into a single one.\n     *\n     * @param buttonsContainer The container where the buttons will be moved.\n     */\n    protected mergeContextMenus(buttonsContainer: HTMLIonButtonsElement): void {\n        // Check if both button containers have a context menu.\n        const secondaryContextMenu = this.element.querySelector('core-context-menu');\n        if (!secondaryContextMenu) {\n            return;\n        }\n\n        const mainContextMenu = buttonsContainer.querySelector('core-context-menu');\n        const secondaryContextMenuInstance = CoreDirectivesRegistry.resolve(secondaryContextMenu, CoreContextMenuComponent);\n        let mainContextMenuInstance: CoreContextMenuComponent | null;\n        if (mainContextMenu) {\n            // Both containers have a context menu. Merge them to prevent having 2 menus at the same time.\n            mainContextMenuInstance = CoreDirectivesRegistry.resolve(mainContextMenu, CoreContextMenuComponent);\n        } else {\n            // There is a context-menu in these buttons, but there is no main context menu in the header.\n            // Create one main context menu dynamically.\n            // @todo: Find a better way to handle header buttons. This isn't working as expected in some cases because the menu\n            // is destroyed when the page is destroyed, so click listeners stop working.\n            mainContextMenuInstance = this.createMainContextMenu();\n        }\n\n        // Check that both context menus belong to the same core-tab. We shouldn't merge menus from different tabs.\n        if (mainContextMenuInstance && secondaryContextMenuInstance) {\n            this.mergedContextMenu = secondaryContextMenuInstance;\n\n            this.mergedContextMenu.mergeContextMenus(mainContextMenuInstance);\n\n            // Remove the empty context menu from the DOM.\n            secondaryContextMenu.parentElement?.removeChild(secondaryContextMenu);\n        }\n    }\n\n    /**\n     * Create a new and empty context menu to be used as a \"parent\".\n     *\n     * @returns Created component.\n     */\n    protected createMainContextMenu(): CoreContextMenuComponent {\n        const componentRef = this.container.createComponent(CoreContextMenuComponent);\n\n        this.createdMainContextMenuElement = componentRef.location.nativeElement;\n\n        return componentRef.instance;\n    }\n\n    /**\n     * Search the ion-header where the buttons should be added.\n     *\n     * @returns Promise resolved with the header element.\n     */\n    protected async searchHeader(): Promise<HTMLIonHeaderElement> {\n        await CoreDom.waitToBeInDOM(this.element);\n        let parentPage: HTMLElement | null = this.element;\n\n        while (parentPage && parentPage.parentElement) {\n            const content = parentPage.closest<HTMLIonContentElement>('ion-content');\n            if (content) {\n                // Sometimes ion-page class is not yet added by the ViewController, wait for content to render.\n                await content.componentOnReady();\n            }\n\n            parentPage = parentPage.parentElement.closest('.ion-page, .ion-page-hidden, .ion-page-invisible');\n\n            // Check if the page has a header. If it doesn't, search the next parent page.\n            let header  = parentPage?.querySelector<HTMLIonHeaderElement>(':scope > ion-header');\n\n            if (header && getComputedStyle(header).display !== 'none') {\n                return header;\n            }\n\n            // Find using content if any.\n            header = content?.parentElement?.querySelector<HTMLIonHeaderElement>(':scope > ion-header');\n\n            if (header && getComputedStyle(header).display !== 'none') {\n                return header;\n            }\n        }\n\n        // Header not found, reject.\n        throw Error('Header not found.');\n    }\n\n    /**\n     * Show or hide all the elements.\n     */\n    protected showHideAllElements(): void {\n        // Show or hide all moved children.\n        this.movedChildren?.forEach((child: Node) => {\n            this.showHideElement(child);\n        });\n\n        // Show or hide all the context menu items that were merged to another context menu.\n        if (this.mergedContextMenu) {\n            if (this.forceHidden || this.allButtonsHidden) {\n                this.mergedContextMenu.removeMergedItems();\n            } else {\n                this.mergedContextMenu.restoreMergedItems();\n            }\n        }\n    }\n\n    /**\n     * Show or hide an element.\n     *\n     * @param element Element to show or hide.\n     */\n    protected showHideElement(element: Node): void {\n        // Check if it's an HTML Element and it's not a created context menu. Never hide created context menus.\n        if (element instanceof Element && element !== this.createdMainContextMenuElement) {\n            element.classList.toggle(BUTTON_HIDDEN_CLASS, !!this.forceHidden || !!this.allButtonsHidden);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngOnDestroy(): void {\n        // This component was destroyed, remove all the buttons that were moved.\n        // The buttons can be moved outside of the current page, that's why we need to manually destroy them.\n        // There's no need to destroy context menu items that were merged because they weren't moved from their DOM position.\n        this.movedChildren?.forEach((child) => {\n            if (child.parentElement && child !== this.createdMainContextMenuElement) {\n                child.parentElement.removeChild(child);\n            }\n        });\n\n        this.mergedContextMenu?.removeMergedItems();\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}