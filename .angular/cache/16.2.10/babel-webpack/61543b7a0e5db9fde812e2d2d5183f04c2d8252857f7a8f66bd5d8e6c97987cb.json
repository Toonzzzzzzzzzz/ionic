{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreGroups } from '@services/groups';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { AddonModWorkshop, AddonModWorkshopPhase } from '../workshop';\nimport { AddonModWorkshopHelper } from '../workshop-helper';\nimport { AddonModWorkshopSync } from '../workshop-sync';\nimport { AddonModWorkshopPrefetchHandlerService } from '@addons/mod/workshop/services/handlers/prefetch';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to prefetch workshops.\n */\nexport class AddonModWorkshopPrefetchHandlerLazyService extends AddonModWorkshopPrefetchHandlerService {\n  /**\n   * @inheritdoc\n   */\n  getFiles(module, courseId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const info = yield _this.getWorkshopInfoHelper(module, courseId, {\n        omitFail: true\n      });\n      return info.files;\n    })();\n  }\n  /**\n   * Helper function to get all workshop info just once.\n   *\n   * @param module Module to get the files.\n   * @param courseId Course ID the module belongs to.\n   * @param options Other options.\n   * @returns Promise resolved with the info fetched.\n   */\n  getWorkshopInfoHelper(module, courseId, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _options$siteId;\n      let groups = [];\n      let files = [];\n      let workshop;\n      let access;\n      const modOptions = _objectSpread({\n        cmId: module.id\n      }, options);\n      const site = yield CoreSites.getSite(options.siteId);\n      options.siteId = (_options$siteId = options.siteId) !== null && _options$siteId !== void 0 ? _options$siteId : site.getId();\n      const userId = site.getUserId();\n      try {\n        workshop = yield AddonModWorkshop.getWorkshop(courseId, module.id, options);\n      } catch (error) {\n        if (options.omitFail) {\n          // Any error, return the info we have.\n          return {\n            groups: [],\n            files: []\n          };\n        }\n        throw error;\n      }\n      try {\n        files = _this2.getIntroFilesFromInstance(module, workshop);\n        files = files.concat(workshop.instructauthorsfiles || []).concat(workshop.instructreviewersfiles || []);\n        access = yield AddonModWorkshop.getWorkshopAccessInformation(workshop.id, modOptions);\n        if (access.canviewallsubmissions) {\n          const groupInfo = yield CoreGroups.getActivityGroupInfo(module.id, false, undefined, options.siteId);\n          if (!groupInfo.groups || groupInfo.groups.length == 0) {\n            groupInfo.groups = [{\n              id: 0,\n              name: ''\n            }];\n          }\n          groups = groupInfo.groups;\n        }\n        const phases = yield AddonModWorkshop.getUserPlanPhases(workshop.id, modOptions);\n        // Get submission phase info.\n        const submissionPhase = phases[AddonModWorkshopPhase.PHASE_SUBMISSION];\n        const canSubmit = AddonModWorkshopHelper.canSubmit(workshop, access, submissionPhase.tasks);\n        const canAssess = AddonModWorkshopHelper.canAssess(workshop, access);\n        const promises = [];\n        if (canSubmit) {\n          promises.push(AddonModWorkshopHelper.getUserSubmission(workshop.id, {\n            userId,\n            cmId: module.id\n          }).then(submission => {\n            if (submission) {\n              files = files.concat(submission.contentfiles || []).concat(submission.attachmentfiles || []);\n            }\n            return;\n          }));\n        }\n        if (access.canviewallsubmissions && workshop.phase >= AddonModWorkshopPhase.PHASE_SUBMISSION) {\n          promises.push(AddonModWorkshop.getSubmissions(workshop.id, modOptions).then( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (submissions) {\n              yield Promise.all(submissions.map( /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator(function* (submission) {\n                  files = files.concat(submission.contentfiles || []).concat(submission.attachmentfiles || []);\n                  const assessments = yield AddonModWorkshop.getSubmissionAssessments(workshop.id, submission.id, {\n                    cmId: module.id\n                  });\n                  assessments.forEach(assessment => {\n                    files = files.concat(assessment.feedbackattachmentfiles).concat(assessment.feedbackcontentfiles);\n                  });\n                  if (workshop.phase >= AddonModWorkshopPhase.PHASE_ASSESSMENT && canAssess) {\n                    yield Promise.all(assessments.map(assessment => AddonModWorkshopHelper.getReviewerAssessmentById(workshop.id, assessment.id)));\n                  }\n                });\n                return function (_x2) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()));\n              return;\n            });\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }()));\n        }\n        // Get assessment files.\n        if (workshop.phase >= AddonModWorkshopPhase.PHASE_ASSESSMENT && canAssess) {\n          promises.push(AddonModWorkshopHelper.getReviewerAssessments(workshop.id, modOptions).then(assessments => {\n            assessments.forEach(assessment => {\n              files = files.concat(assessment.feedbackattachmentfiles).concat(assessment.feedbackcontentfiles);\n            });\n            return;\n          }));\n        }\n        yield Promise.all(promises);\n        return {\n          workshop,\n          groups,\n          files: files.filter(file => file !== undefined)\n        };\n      } catch (error) {\n        if (options.omitFail) {\n          // Any error, return the info we have.\n          return {\n            workshop,\n            groups,\n            files: files.filter(file => file !== undefined)\n          };\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateContent(moduleId, courseId) {\n    return _asyncToGenerator(function* () {\n      yield AddonModWorkshop.invalidateContent(moduleId, courseId);\n    })();\n  }\n  /**\n   * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Whether the module can be downloaded. The promise should never be rejected.\n   */\n  isDownloadable(module, courseId) {\n    return _asyncToGenerator(function* () {\n      const workshop = yield AddonModWorkshop.getWorkshop(courseId, module.id, {\n        readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */\n      });\n\n      const accessData = yield AddonModWorkshop.getWorkshopAccessInformation(workshop.id, {\n        cmId: module.id\n      });\n      // Check if workshop is setup by phase.\n      return accessData.canswitchphase || workshop.phase > AddonModWorkshopPhase.PHASE_SETUP;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  prefetch(module, courseId) {\n    return this.prefetchPackage(module, courseId, siteId => this.prefetchWorkshop(module, courseId, siteId));\n  }\n  /**\n   * Retrieves all the grades reports for all the groups and then returns only unique grades.\n   *\n   * @param workshopId Workshop ID.\n   * @param groups Array of groups in the activity.\n   * @param cmId Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns All unique entries.\n   */\n  getAllGradesReport(workshopId, groups, cmId, siteId) {\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      groups.forEach(group => {\n        promises.push(AddonModWorkshop.fetchAllGradeReports(workshopId, {\n          groupId: group.id,\n          cmId,\n          siteId\n        }));\n      });\n      const grades = yield Promise.all(promises);\n      const uniqueGrades = {};\n      grades.forEach(groupGrades => {\n        groupGrades.forEach(grade => {\n          if (grade.submissionid) {\n            uniqueGrades[grade.submissionid] = grade;\n          }\n        });\n      });\n      return CoreUtils.objectToArray(uniqueGrades);\n    })();\n  }\n  /**\n   * Prefetch a workshop.\n   *\n   * @param module The module object returned by WS.\n   * @param courseId Course ID the module belongs to.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  prefetchWorkshop(module, courseId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const userIds = [];\n      const commonOptions = {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      const modOptions = _objectSpread({\n        cmId: module.id\n      }, commonOptions);\n      const site = yield CoreSites.getSite(siteId);\n      const currentUserId = site.getUserId();\n      // Prefetch the workshop data.\n      const info = yield _this3.getWorkshopInfoHelper(module, courseId, commonOptions);\n      if (!info.workshop) {\n        // It would throw an exception so it would not happen.\n        return;\n      }\n      const workshop = info.workshop;\n      const promises = [];\n      const assessmentIds = [];\n      promises.push(CoreFilepool.addFilesToQueue(siteId, info.files, _this3.component, module.id));\n      promises.push(AddonModWorkshop.getWorkshopAccessInformation(workshop.id, modOptions).then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (access) {\n          const phases = yield AddonModWorkshop.getUserPlanPhases(workshop.id, modOptions);\n          // Get submission phase info.\n          const submissionPhase = phases[AddonModWorkshopPhase.PHASE_SUBMISSION];\n          const canSubmit = AddonModWorkshopHelper.canSubmit(workshop, access, submissionPhase.tasks);\n          const canAssess = AddonModWorkshopHelper.canAssess(workshop, access);\n          const promises2 = [];\n          if (canSubmit) {\n            promises2.push(AddonModWorkshop.getSubmissions(workshop.id, modOptions));\n            // Add userId to the profiles to prefetch.\n            userIds.push(currentUserId);\n          }\n          let reportPromise = Promise.resolve();\n          if (access.canviewallsubmissions && workshop.phase >= AddonModWorkshopPhase.PHASE_SUBMISSION) {\n            // eslint-disable-next-line promise/no-nesting\n            reportPromise = _this3.getAllGradesReport(workshop.id, info.groups, module.id, siteId).then(grades => {\n              grades.forEach(grade => {\n                userIds.push(grade.userid);\n                grade.submissiongradeoverby && userIds.push(grade.submissiongradeoverby);\n                grade.reviewedby && grade.reviewedby.forEach(assessment => {\n                  userIds.push(assessment.userid);\n                  assessmentIds[assessment.assessmentid] = assessment.assessmentid;\n                });\n                grade.reviewerof && grade.reviewerof.forEach(assessment => {\n                  userIds.push(assessment.userid);\n                  assessmentIds[assessment.assessmentid] = assessment.assessmentid;\n                });\n              });\n              return;\n            });\n          }\n          if (workshop.phase >= AddonModWorkshopPhase.PHASE_ASSESSMENT && canAssess) {\n            // Wait the report promise to finish to override assessments array if needed.\n            reportPromise = reportPromise.finally( /*#__PURE__*/_asyncToGenerator(function* () {\n              const revAssessments = yield AddonModWorkshopHelper.getReviewerAssessments(workshop.id, {\n                userId: currentUserId,\n                cmId: module.id,\n                siteId\n              });\n              let files = []; // Files in each submission.\n              revAssessments.forEach(assessment => {\n                var _assessment$submissio, _assessment$submissio2, _assessment$submissio3;\n                if (((_assessment$submissio = assessment.submission) === null || _assessment$submissio === void 0 ? void 0 : _assessment$submissio.authorid) == currentUserId) {\n                  promises.push(AddonModWorkshop.getAssessment(workshop.id, assessment.id, modOptions));\n                }\n                userIds.push(assessment.reviewerid);\n                userIds.push(assessment.gradinggradeoverby);\n                assessmentIds[assessment.id] = assessment.id;\n                files = files.concat(((_assessment$submissio2 = assessment.submission) === null || _assessment$submissio2 === void 0 ? void 0 : _assessment$submissio2.attachmentfiles) || []).concat(((_assessment$submissio3 = assessment.submission) === null || _assessment$submissio3 === void 0 ? void 0 : _assessment$submissio3.contentfiles) || []);\n              });\n              yield CoreFilepool.addFilesToQueue(siteId, files, _this3.component, module.id);\n            }));\n          }\n          reportPromise = reportPromise.finally(() => {\n            if (assessmentIds.length > 0) {\n              return Promise.all(assessmentIds.map(assessmentId => AddonModWorkshop.getAssessmentForm(workshop.id, assessmentId, modOptions)));\n            }\n          });\n          promises2.push(reportPromise);\n          if (workshop.phase == AddonModWorkshopPhase.PHASE_CLOSED) {\n            promises2.push(AddonModWorkshop.getGrades(workshop.id, modOptions));\n            if (access.canviewpublishedsubmissions) {\n              promises2.push(AddonModWorkshop.getSubmissions(workshop.id, modOptions));\n            }\n          }\n          yield Promise.all(promises2);\n          return;\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      // Add Basic Info to manage links.\n      promises.push(CoreCourse.getModuleBasicInfoByInstance(workshop.id, 'workshop', {\n        siteId\n      }));\n      promises.push(CoreCourse.getModuleBasicGradeInfo(module.id, siteId));\n      // Get course data, needed to determine upload max size if it's configured to be course limit.\n      promises.push(CoreUtils.ignoreErrors(CoreCourses.getCourseByField('id', courseId, siteId)));\n      yield Promise.all(promises);\n      // Prefetch user profiles.\n      yield CoreUser.prefetchProfiles(userIds, courseId, siteId);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  sync(module, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      return AddonModWorkshopSync.syncWorkshop(module.instance, siteId);\n    })();\n  }\n}\n_class = AddonModWorkshopPrefetchHandlerLazyService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵAddonModWorkshopPrefetchHandlerLazyService_BaseFactory;\n  return function AddonModWorkshopPrefetchHandlerLazyService_Factory(t) {\n    return (ɵAddonModWorkshopPrefetchHandlerLazyService_BaseFactory || (ɵAddonModWorkshopPrefetchHandlerLazyService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModWorkshopPrefetchHandler = makeSingleton(AddonModWorkshopPrefetchHandlerLazyService);","map":{"version":3,"names":["CoreCourse","CoreCourses","CoreUser","CoreFilepool","CoreGroups","CoreSites","CoreSitesReadingStrategy","CoreUtils","makeSingleton","AddonModWorkshop","AddonModWorkshopPhase","AddonModWorkshopHelper","AddonModWorkshopSync","AddonModWorkshopPrefetchHandlerService","AddonModWorkshopPrefetchHandlerLazyService","getFiles","module","courseId","_this","_asyncToGenerator","info","getWorkshopInfoHelper","omitFail","files","options","_this2","_options$siteId","groups","workshop","access","modOptions","_objectSpread","cmId","id","site","getSite","siteId","getId","userId","getUserId","getWorkshop","error","getIntroFilesFromInstance","concat","instructauthorsfiles","instructreviewersfiles","getWorkshopAccessInformation","canviewallsubmissions","groupInfo","getActivityGroupInfo","undefined","length","name","phases","getUserPlanPhases","submissionPhase","PHASE_SUBMISSION","canSubmit","tasks","canAssess","promises","push","getUserSubmission","then","submission","contentfiles","attachmentfiles","phase","getSubmissions","_ref","submissions","Promise","all","map","_ref2","assessments","getSubmissionAssessments","forEach","assessment","feedbackattachmentfiles","feedbackcontentfiles","PHASE_ASSESSMENT","getReviewerAssessmentById","_x2","apply","arguments","_x","getReviewerAssessments","filter","file","invalidateContent","moduleId","isDownloadable","readingStrategy","accessData","canswitchphase","PHASE_SETUP","prefetch","prefetchPackage","prefetchWorkshop","getAllGradesReport","workshopId","group","fetchAllGradeReports","groupId","grades","uniqueGrades","groupGrades","grade","submissionid","objectToArray","_this3","userIds","commonOptions","currentUserId","assessmentIds","addFilesToQueue","component","_ref3","promises2","reportPromise","resolve","userid","submissiongradeoverby","reviewedby","assessmentid","reviewerof","finally","revAssessments","_assessment$submissio","_assessment$submissio2","_assessment$submissio3","authorid","getAssessment","reviewerid","gradinggradeoverby","assessmentId","getAssessmentForm","PHASE_CLOSED","getGrades","canviewpublishedsubmissions","_x3","getModuleBasicInfoByInstance","getModuleBasicGradeInfo","ignoreErrors","getCourseByField","prefetchProfiles","sync","syncWorkshop","instance","t","factory","ɵfac","providedIn","AddonModWorkshopPrefetchHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/workshop/services/handlers/prefetch-lazy.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { AddonModDataSyncResult } from '@addons/mod/data/services/data-sync';\nimport { Injectable } from '@angular/core';\nimport { CoreCourse, CoreCourseAnyModuleData } from '@features/course/services/course';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreGroup, CoreGroups } from '@services/groups';\nimport { CoreSites, CoreSitesReadingStrategy, CoreSitesCommonWSOptions } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile, CoreWSFile } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport {\n    AddonModWorkshop,\n    AddonModWorkshopPhase,\n    AddonModWorkshopGradesData,\n    AddonModWorkshopData,\n    AddonModWorkshopGetWorkshopAccessInformationWSResponse,\n} from '../workshop';\nimport { AddonModWorkshopHelper } from '../workshop-helper';\nimport { AddonModWorkshopSync } from '../workshop-sync';\nimport { AddonModWorkshopPrefetchHandlerService } from '@addons/mod/workshop/services/handlers/prefetch';\n\n/**\n * Handler to prefetch workshops.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModWorkshopPrefetchHandlerLazyService extends AddonModWorkshopPrefetchHandlerService {\n\n    /**\n     * @inheritdoc\n     */\n    async getFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<CoreWSFile[]> {\n        const info = await this.getWorkshopInfoHelper(module, courseId, { omitFail: true });\n\n        return info.files;\n    }\n\n    /**\n     * Helper function to get all workshop info just once.\n     *\n     * @param module Module to get the files.\n     * @param courseId Course ID the module belongs to.\n     * @param options Other options.\n     * @returns Promise resolved with the info fetched.\n     */\n    protected async getWorkshopInfoHelper(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        options: AddonModWorkshopGetInfoOptions = {},\n    ): Promise<{ workshop?: AddonModWorkshopData; groups: CoreGroup[]; files: CoreWSFile[]}> {\n        let groups: CoreGroup[] = [];\n        let files: CoreWSFile[] = [];\n        let workshop: AddonModWorkshopData;\n        let access: AddonModWorkshopGetWorkshopAccessInformationWSResponse | undefined;\n\n        const modOptions = {\n            cmId: module.id,\n            ...options, // Include all options.\n        };\n\n        const site = await CoreSites.getSite(options.siteId);\n        options.siteId = options.siteId ?? site.getId();\n        const userId = site.getUserId();\n\n        try {\n            workshop = await AddonModWorkshop.getWorkshop(courseId, module.id, options);\n        }  catch (error) {\n            if (options.omitFail) {\n                // Any error, return the info we have.\n                return {\n                    groups: [],\n                    files: [],\n                };\n            }\n\n            throw error;\n        }\n\n        try {\n            files = this.getIntroFilesFromInstance(module, workshop);\n            files = files.concat(workshop.instructauthorsfiles || []).concat(workshop.instructreviewersfiles || []);\n\n            access = await AddonModWorkshop.getWorkshopAccessInformation(workshop.id, modOptions);\n            if (access.canviewallsubmissions) {\n                const groupInfo = await CoreGroups.getActivityGroupInfo(module.id, false, undefined, options.siteId);\n                if (!groupInfo.groups || groupInfo.groups.length == 0) {\n                    groupInfo.groups = [{ id: 0, name: '' }];\n                }\n                groups = groupInfo.groups;\n            }\n\n            const phases = await AddonModWorkshop.getUserPlanPhases(workshop.id, modOptions);\n\n            // Get submission phase info.\n            const submissionPhase = phases[AddonModWorkshopPhase.PHASE_SUBMISSION];\n            const canSubmit = AddonModWorkshopHelper.canSubmit(workshop, access, submissionPhase.tasks);\n            const canAssess = AddonModWorkshopHelper.canAssess(workshop, access);\n\n            const promises: Promise<void>[] = [];\n\n            if (canSubmit) {\n                promises.push(AddonModWorkshopHelper.getUserSubmission(workshop.id, {\n                    userId,\n                    cmId: module.id,\n                }).then((submission) => {\n                    if (submission) {\n                        files = files.concat(submission.contentfiles || []).concat(submission.attachmentfiles || []);\n                    }\n\n                    return;\n                }));\n            }\n\n            if (access.canviewallsubmissions && workshop.phase >= AddonModWorkshopPhase.PHASE_SUBMISSION) {\n                promises.push(AddonModWorkshop.getSubmissions(workshop.id, modOptions).then(async (submissions) => {\n\n                    await Promise.all(submissions.map(async (submission) => {\n                        files = files.concat(submission.contentfiles || []).concat(submission.attachmentfiles || []);\n\n                        const assessments = await AddonModWorkshop.getSubmissionAssessments(workshop.id, submission.id, {\n                            cmId: module.id,\n                        });\n\n                        assessments.forEach((assessment) => {\n                            files = files.concat(assessment.feedbackattachmentfiles)\n                                .concat(assessment.feedbackcontentfiles);\n                        });\n\n                        if (workshop.phase >= AddonModWorkshopPhase.PHASE_ASSESSMENT && canAssess) {\n                            await Promise.all(assessments.map((assessment) =>\n                                AddonModWorkshopHelper.getReviewerAssessmentById(workshop.id, assessment.id)));\n                        }\n                    }));\n\n                    return;\n                }));\n            }\n\n            // Get assessment files.\n            if (workshop.phase >= AddonModWorkshopPhase.PHASE_ASSESSMENT && canAssess) {\n                promises.push(AddonModWorkshopHelper.getReviewerAssessments(workshop.id, modOptions).then((assessments) => {\n                    assessments.forEach((assessment) => {\n                        files = files.concat(<CoreWSExternalFile[]>assessment.feedbackattachmentfiles)\n                            .concat(assessment.feedbackcontentfiles);\n                    });\n\n                    return;\n                }));\n            }\n\n            await Promise.all(promises);\n\n            return {\n                workshop,\n                groups,\n                files: files.filter((file) => file !== undefined),\n            };\n        } catch (error) {\n            if (options.omitFail) {\n                // Any error, return the info we have.\n                return {\n                    workshop,\n                    groups,\n                    files: files.filter((file) => file !== undefined),\n                };\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        await AddonModWorkshop.invalidateContent(moduleId, courseId);\n    }\n\n    /**\n     * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Whether the module can be downloaded. The promise should never be rejected.\n     */\n    async isDownloadable(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        const workshop = await AddonModWorkshop.getWorkshop(courseId, module.id, {\n            readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n        });\n\n        const accessData = await AddonModWorkshop.getWorkshopAccessInformation(workshop.id, { cmId: module.id });\n\n        // Check if workshop is setup by phase.\n        return accessData.canswitchphase || workshop.phase > AddonModWorkshopPhase.PHASE_SETUP;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    prefetch(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        return this.prefetchPackage(module, courseId, (siteId) => this.prefetchWorkshop(module, courseId, siteId));\n    }\n\n    /**\n     * Retrieves all the grades reports for all the groups and then returns only unique grades.\n     *\n     * @param workshopId Workshop ID.\n     * @param groups Array of groups in the activity.\n     * @param cmId Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns All unique entries.\n     */\n    protected async getAllGradesReport(\n        workshopId: number,\n        groups: CoreGroup[],\n        cmId: number,\n        siteId: string,\n    ): Promise<AddonModWorkshopGradesData[]> {\n        const promises: Promise<AddonModWorkshopGradesData[]>[] = [];\n\n        groups.forEach((group) => {\n            promises.push(AddonModWorkshop.fetchAllGradeReports(workshopId, { groupId: group.id, cmId, siteId }));\n        });\n\n        const grades = await Promise.all(promises);\n        const uniqueGrades: Record<number, AddonModWorkshopGradesData> = {};\n\n        grades.forEach((groupGrades) => {\n            groupGrades.forEach((grade) => {\n                if (grade.submissionid) {\n                    uniqueGrades[grade.submissionid] = grade;\n                }\n            });\n        });\n\n        return CoreUtils.objectToArray(uniqueGrades);\n    }\n\n    /**\n     * Prefetch a workshop.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID the module belongs to.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchWorkshop(module: CoreCourseAnyModuleData, courseId: number, siteId: string): Promise<void> {\n        const userIds: number[] = [];\n        const commonOptions = {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n        const modOptions = {\n            cmId: module.id,\n            ...commonOptions, // Include all common options.\n        };\n\n        const site = await CoreSites.getSite(siteId);\n        const currentUserId = site.getUserId();\n\n        // Prefetch the workshop data.\n        const info = await this.getWorkshopInfoHelper(module, courseId, commonOptions);\n        if (!info.workshop) {\n            // It would throw an exception so it would not happen.\n            return;\n        }\n\n        const workshop = info.workshop;\n        const promises: Promise<unknown>[] = [];\n        const assessmentIds: number[] = [];\n\n        promises.push(CoreFilepool.addFilesToQueue(siteId, info.files, this.component, module.id));\n\n        promises.push(AddonModWorkshop.getWorkshopAccessInformation(workshop.id, modOptions).then(async (access) => {\n            const phases = await AddonModWorkshop.getUserPlanPhases(workshop.id, modOptions);\n\n            // Get submission phase info.\n            const submissionPhase = phases[AddonModWorkshopPhase.PHASE_SUBMISSION];\n            const canSubmit = AddonModWorkshopHelper.canSubmit(workshop, access, submissionPhase.tasks);\n            const canAssess = AddonModWorkshopHelper.canAssess(workshop, access);\n            const promises2: Promise<unknown>[] = [];\n\n            if (canSubmit) {\n                promises2.push(AddonModWorkshop.getSubmissions(workshop.id, modOptions));\n                // Add userId to the profiles to prefetch.\n                userIds.push(currentUserId);\n            }\n\n            let reportPromise: Promise<unknown> = Promise.resolve();\n            if (access.canviewallsubmissions && workshop.phase >= AddonModWorkshopPhase.PHASE_SUBMISSION) {\n                // eslint-disable-next-line promise/no-nesting\n                reportPromise = this.getAllGradesReport(workshop.id, info.groups, module.id, siteId).then((grades) => {\n                    grades.forEach((grade) => {\n                        userIds.push(grade.userid);\n                        grade.submissiongradeoverby && userIds.push(grade.submissiongradeoverby);\n\n                        grade.reviewedby && grade.reviewedby.forEach((assessment) => {\n                            userIds.push(assessment.userid);\n                            assessmentIds[assessment.assessmentid] = assessment.assessmentid;\n                        });\n\n                        grade.reviewerof && grade.reviewerof.forEach((assessment) => {\n                            userIds.push(assessment.userid);\n                            assessmentIds[assessment.assessmentid] = assessment.assessmentid;\n                        });\n                    });\n\n                    return;\n                });\n            }\n\n            if (workshop.phase >= AddonModWorkshopPhase.PHASE_ASSESSMENT && canAssess) {\n                // Wait the report promise to finish to override assessments array if needed.\n                reportPromise = reportPromise.finally(async () => {\n                    const revAssessments = await AddonModWorkshopHelper.getReviewerAssessments(workshop.id, {\n                        userId: currentUserId,\n                        cmId: module.id,\n                        siteId,\n                    });\n\n                    let files: CoreWSExternalFile[] = []; // Files in each submission.\n\n                    revAssessments.forEach((assessment) => {\n                        if (assessment.submission?.authorid == currentUserId) {\n                            promises.push(AddonModWorkshop.getAssessment(\n                                workshop.id,\n                                assessment.id,\n                                modOptions,\n                            ));\n                        }\n                        userIds.push(assessment.reviewerid);\n                        userIds.push(assessment.gradinggradeoverby);\n                        assessmentIds[assessment.id] = assessment.id;\n\n                        files = files.concat(assessment.submission?.attachmentfiles || [])\n                            .concat(assessment.submission?.contentfiles || []);\n                    });\n\n                    await CoreFilepool.addFilesToQueue(siteId, files, this.component, module.id);\n                });\n            }\n\n            reportPromise = reportPromise.finally(() => {\n                if (assessmentIds.length > 0) {\n                    return Promise.all(assessmentIds.map((assessmentId) =>\n                        AddonModWorkshop.getAssessmentForm(workshop.id, assessmentId, modOptions)));\n                }\n            });\n            promises2.push(reportPromise);\n\n            if (workshop.phase == AddonModWorkshopPhase.PHASE_CLOSED) {\n                promises2.push(AddonModWorkshop.getGrades(workshop.id, modOptions));\n                if (access.canviewpublishedsubmissions) {\n                    promises2.push(AddonModWorkshop.getSubmissions(workshop.id, modOptions));\n                }\n            }\n\n            await Promise.all(promises2);\n\n            return;\n        }));\n\n        // Add Basic Info to manage links.\n        promises.push(CoreCourse.getModuleBasicInfoByInstance(workshop.id, 'workshop', { siteId }));\n        promises.push(CoreCourse.getModuleBasicGradeInfo(module.id, siteId));\n\n        // Get course data, needed to determine upload max size if it's configured to be course limit.\n        promises.push(CoreUtils.ignoreErrors(CoreCourses.getCourseByField('id', courseId, siteId)));\n\n        await Promise.all(promises);\n\n        // Prefetch user profiles.\n        await CoreUser.prefetchProfiles(userIds, courseId, siteId);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async sync(module: CoreCourseAnyModuleData, courseId: number, siteId?: string): Promise<AddonModDataSyncResult> {\n        return AddonModWorkshopSync.syncWorkshop(module.instance, siteId);\n    }\n\n}\nexport const AddonModWorkshopPrefetchHandler = makeSingleton(AddonModWorkshopPrefetchHandlerLazyService);\n\n/**\n * Options to pass to getWorkshopInfoHelper.\n */\nexport type AddonModWorkshopGetInfoOptions = CoreSitesCommonWSOptions & {\n    omitFail?: boolean; // True to always return even if fails.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}