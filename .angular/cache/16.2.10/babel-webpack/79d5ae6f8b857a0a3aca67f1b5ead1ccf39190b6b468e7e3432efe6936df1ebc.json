{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreDom } from '@singletons/dom';\nimport { CoreLogger } from '@singletons/logger';\n/**\n * Class to make a question of ddimageortext type work.\n */\nexport class AddonQtypeDdImageOrTextQuestion {\n  /**\n   * Create the this.\n   *\n   * @param container The container HTMLElement of the question.\n   * @param question The question.\n   * @param readOnly Whether it's read only.\n   * @param drops The drop zones received in the init object of the question.\n   */\n  constructor(container, question, readOnly, drops) {\n    this.container = container;\n    this.question = question;\n    this.readOnly = readOnly;\n    this.drops = drops;\n    this.toLoad = 0;\n    this.afterImageLoadDone = false;\n    this.proportion = 1;\n    this.logger = CoreLogger.getInstance('AddonQtypeDdImageOrTextQuestion');\n    this.initializer();\n  }\n  /**\n   * Calculate image proportion to make easy conversions.\n   */\n  calculateImgProportion() {\n    const bgImg = this.doc.bgImg();\n    if (!bgImg) {\n      return;\n    }\n    // Render the position related to the current image dimensions.\n    this.proportion = 1;\n    if (bgImg.width != bgImg.naturalWidth) {\n      this.proportion = bgImg.width / bgImg.naturalWidth;\n    }\n  }\n  /**\n   * Convert the X and Y position of the BG IMG to a position relative to the window.\n   *\n   * @param bgImgXY X and Y of the BG IMG relative position.\n   * @returns Position relative to the window.\n   */\n  convertToWindowXY(bgImgXY) {\n    const bgImg = this.doc.bgImg();\n    if (!bgImg) {\n      return bgImgXY;\n    }\n    const ddArea = this.container.querySelector('.ddarea');\n    if (!ddArea) {\n      return bgImgXY;\n    }\n    const position = CoreDom.getRelativeElementPosition(bgImg, ddArea);\n    // Render the position related to the current image dimensions.\n    bgImgXY[0] *= this.proportion;\n    bgImgXY[1] *= this.proportion;\n    return [bgImgXY[0] + position.x + 1, bgImgXY[1] + position.y + 1];\n  }\n  /**\n   * Create and initialize all draggable elements and drop zones.\n   */\n  createAllDragAndDrops() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _this$doc$dragItemsAr, _this$container$query;\n      // Initialize drop zones.\n      _this.initDrops();\n      // Initialize drag items area.\n      (_this$doc$dragItemsAr = _this.doc.dragItemsArea) === null || _this$doc$dragItemsAr === void 0 || _this$doc$dragItemsAr.classList.add('clearfix');\n      _this.makeDragAreaClickable();\n      const dragItemHomes = _this.doc.dragItemHomes();\n      let i = 0;\n      // Create the draggable items.\n      for (let x = 0; x < dragItemHomes.length; x++) {\n        var _this$doc$getClassnam, _this$doc$getClassnam2, _this$doc$getClassnam3;\n        const dragItemHome = dragItemHomes[x];\n        const dragItemNo = (_this$doc$getClassnam = _this.doc.getClassnameNumericSuffix(dragItemHome, 'dragitemhomes')) !== null && _this$doc$getClassnam !== void 0 ? _this$doc$getClassnam : -1;\n        const choice = (_this$doc$getClassnam2 = _this.doc.getClassnameNumericSuffix(dragItemHome, 'choice')) !== null && _this$doc$getClassnam2 !== void 0 ? _this$doc$getClassnam2 : -1;\n        const group = (_this$doc$getClassnam3 = _this.doc.getClassnameNumericSuffix(dragItemHome, 'group')) !== null && _this$doc$getClassnam3 !== void 0 ? _this$doc$getClassnam3 : -1;\n        // Images need to be inside a div element to admit padding with width and height.\n        if (dragItemHome.tagName == 'IMG') {\n          var _dragItemHome$parentN;\n          const wrap = document.createElement('div');\n          wrap.className = dragItemHome.className;\n          dragItemHome.className = '';\n          // Insert wrapper before the image in the DOM tree.\n          (_dragItemHome$parentN = dragItemHome.parentNode) === null || _dragItemHome$parentN === void 0 || _dragItemHome$parentN.insertBefore(wrap, dragItemHome);\n          // Move the image into wrapper.\n          wrap.appendChild(dragItemHome);\n        }\n        // Create a new drag item for this home.\n        const dragNode = _this.doc.cloneNewDragItem(i, dragItemNo);\n        i++;\n        // Make the item draggable.\n        _this.draggableForQuestion(dragNode, group, choice);\n        // If the draggable item needs to be created more than once, create the rest of copies.\n        if (dragNode !== null && dragNode !== void 0 && dragNode.classList.contains('infinite')) {\n          const groupSize = _this.doc.dropZoneGroup(group).length;\n          let dragsToCreate = groupSize - 1;\n          while (dragsToCreate > 0) {\n            const newDragNode = _this.doc.cloneNewDragItem(i, dragItemNo);\n            i++;\n            _this.draggableForQuestion(newDragNode, group, choice);\n            dragsToCreate--;\n          }\n        }\n      }\n      yield CoreDom.waitToBeVisible((_this$container$query = _this.container.querySelector('.ddarea')) !== null && _this$container$query !== void 0 ? _this$container$query : _this.container);\n      // All drag items have been created, position them.\n      _this.repositionDragsForQuestion();\n      if (!_this.readOnly) {\n        const dropZones = _this.doc.dropZones();\n        dropZones.forEach(dropZone => {\n          dropZone.setAttribute('tabIndex', '0');\n        });\n      }\n    })();\n  }\n  /**\n   * Deselect all drags.\n   */\n  deselectDrags() {\n    const drags = this.doc.dragItems();\n    drags.forEach(drag => {\n      drag.classList.remove('beingdragged');\n    });\n    this.selected = null;\n  }\n  /**\n   * Function to call when the instance is no longer needed.\n   */\n  destroy() {\n    var _this$resizeListener;\n    this.stopPolling();\n    (_this$resizeListener = this.resizeListener) === null || _this$resizeListener === void 0 || _this$resizeListener.off();\n  }\n  /**\n   * Make an element draggable.\n   *\n   * @param drag Element to make draggable.\n   * @param group Group the element belongs to.\n   * @param choice Choice the element belongs to.\n   */\n  draggableForQuestion(drag, group, choice) {\n    if (!drag) {\n      return;\n    }\n    // Set attributes.\n    drag.setAttribute('group', String(group));\n    drag.setAttribute('choice', String(choice));\n    if (!this.readOnly) {\n      // Listen to click events.\n      drag.addEventListener('click', e => {\n        e.preventDefault();\n        e.stopPropagation();\n        if (drag.classList.contains('beingdragged')) {\n          this.deselectDrags();\n        } else {\n          this.selectDrag(drag);\n        }\n      });\n    }\n  }\n  /**\n   * Function called when a drop zone is clicked.\n   *\n   * @param dropNode Drop element.\n   */\n  dropClick(dropNode) {\n    const drag = this.selected;\n    if (!drag) {\n      // No selected item, nothing to do.\n      return;\n    }\n    // Deselect the drag and place it in the position of this drop zone if it belongs to the same group.\n    this.deselectDrags();\n    if (Number(dropNode.getAttribute('group')) === Number(drag.getAttribute('group'))) {\n      this.placeDragInDrop(drag, dropNode);\n    }\n  }\n  /**\n   * Get all the draggable elements for a choice and a drop zone.\n   *\n   * @param choice Choice number.\n   * @param drop Drop zone.\n   * @returns Draggable elements.\n   */\n  getChoicesForDrop(choice, drop) {\n    if (!this.doc.topNode) {\n      return [];\n    }\n    return Array.from(this.doc.topNode.querySelectorAll('div.dragitemgroup' + drop.getAttribute('group') + ` .choice${choice}.drag`));\n  }\n  /**\n   * Get an unplaced draggable element that belongs to a certain choice and drop zone.\n   *\n   * @param choice Choice number.\n   * @param drop Drop zone.\n   * @returns Unplaced draggable element.\n   */\n  getUnplacedChoiceForDrop(choice, drop) {\n    const dragItems = this.getChoicesForDrop(choice, drop);\n    const foundItem = dragItems.find(dragItem => !dragItem.classList.contains('placed') && !dragItem.classList.contains('beingdragged'));\n    return foundItem || null;\n  }\n  /**\n   * Initialize drop zones.\n   */\n  initDrops() {\n    var _this$doc$topNode;\n    const dropAreas = (_this$doc$topNode = this.doc.topNode) === null || _this$doc$topNode === void 0 ? void 0 : _this$doc$topNode.querySelector('div.dropzones');\n    if (!dropAreas) {\n      return;\n    }\n    const groupNodes = {};\n    // Create all group nodes and add them to the drop area.\n    for (let groupNo = 1; groupNo <= 8; groupNo++) {\n      const groupNode = document.createElement('div');\n      groupNode.className = `dropzonegroup${groupNo}`;\n      dropAreas.appendChild(groupNode);\n      groupNodes[groupNo] = groupNode;\n    }\n    // Create the drops specified by the init object.\n    for (const dropNo in this.drops) {\n      const drop = this.drops[dropNo];\n      const nodeClass = `dropzone group${drop.group} place${dropNo}`;\n      const title = drop.text.replace('\"', '\"');\n      const dropNode = document.createElement('div');\n      dropNode.setAttribute('title', title);\n      dropNode.className = nodeClass;\n      groupNodes[drop.group].appendChild(dropNode);\n      dropNode.style.opacity = '0.5';\n      dropNode.setAttribute('xy', drop.xy);\n      dropNode.setAttribute('aria-label', drop.text);\n      dropNode.setAttribute('place', dropNo);\n      dropNode.setAttribute('inputid', drop.fieldname.replace(':', '_'));\n      dropNode.setAttribute('group', drop.group);\n      dropNode.addEventListener('click', e => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.dropClick(dropNode);\n      });\n    }\n  }\n  /**\n   * Initialize the question.\n   */\n  initializer() {\n    this.doc = new AddonQtypeDdImageOrTextQuestionDocStructure(this.container, this.question.slot);\n    if (this.readOnly) {\n      var _this$doc$topNode2;\n      (_this$doc$topNode2 = this.doc.topNode) === null || _this$doc$topNode2 === void 0 || _this$doc$topNode2.classList.add('readonly');\n    }\n    // Wait the DOM to be rendered.\n    setTimeout(() => {\n      const bgImg = this.doc.bgImg();\n      if (!bgImg) {\n        this.logger.error('Background image not found');\n        return;\n      }\n      // Wait for background image to be loaded.\n      // On iOS, complete is mistakenly true, check also naturalWidth for compatibility.\n      if (!bgImg.complete || !bgImg.naturalWidth) {\n        this.toLoad++;\n        bgImg.addEventListener('load', () => {\n          this.toLoad--;\n        });\n      }\n      const itemHomes = this.doc.dragItemHomes();\n      itemHomes.forEach(item => {\n        if (item.tagName != 'IMG') {\n          return;\n        }\n        // Wait for drag images to be loaded.\n        // On iOS, complete is mistakenly true, check also naturalWidth for compatibility.\n        const itemImg = item;\n        if (!itemImg.complete || !itemImg.naturalWidth) {\n          this.toLoad++;\n          itemImg.addEventListener('load', () => {\n            this.toLoad--;\n          });\n        }\n      });\n      this.pollForImageLoad();\n    });\n    this.resizeListener = CoreDom.onWindowResize(() => {\n      this.repositionDragsForQuestion();\n    });\n  }\n  /**\n   * Make the drag items area clickable.\n   */\n  makeDragAreaClickable() {\n    if (this.readOnly) {\n      return;\n    }\n    const home = this.doc.dragItemsArea;\n    home === null || home === void 0 || home.addEventListener('click', e => {\n      const drag = this.selected;\n      if (!drag) {\n        // No element selected, nothing to do.\n        return false;\n      }\n      // An element was selected. Deselect it and move it back to the area if needed.\n      this.deselectDrags();\n      this.removeDragFromDrop(drag);\n      e.preventDefault();\n      e.stopPropagation();\n    });\n  }\n  /**\n   * Place a draggable element into a certain drop zone.\n   *\n   * @param drag Draggable element.\n   * @param drop Drop zone element.\n   */\n  placeDragInDrop(drag, drop) {\n    var _this$doc$topNode3;\n    // Search the input related to the drop zone.\n    const targetInputId = drop.getAttribute('inputid') || '';\n    const inputNode = (_this$doc$topNode3 = this.doc.topNode) === null || _this$doc$topNode3 === void 0 ? void 0 : _this$doc$topNode3.querySelector(`input#${targetInputId}`);\n    // Check if the draggable item is already assigned to an input and if it's the same as the one of the drop zone.\n    const originInputId = drag.getAttribute('inputid');\n    if (originInputId && originInputId != targetInputId) {\n      var _this$doc$topNode4;\n      // Remove it from the previous place.\n      const originInputNode = (_this$doc$topNode4 = this.doc.topNode) === null || _this$doc$topNode4 === void 0 ? void 0 : _this$doc$topNode4.querySelector(`input#${originInputId}`);\n      originInputNode === null || originInputNode === void 0 || originInputNode.setAttribute('value', '0');\n    }\n    // Now position the draggable and set it to the input.\n    const ddArea = this.container.querySelector('.ddarea');\n    if (!ddArea) {\n      return;\n    }\n    const position = CoreDom.getRelativeElementPosition(drop, ddArea);\n    const choice = drag.getAttribute('choice');\n    drag.style.left = position.x + 'px';\n    drag.style.top = position.y + 'px';\n    drag.classList.add('placed');\n    if (choice) {\n      inputNode === null || inputNode === void 0 || inputNode.setAttribute('value', choice);\n    }\n    drag.setAttribute('inputid', targetInputId);\n  }\n  /**\n   * Wait for images to be loaded.\n   */\n  pollForImageLoad() {\n    if (this.afterImageLoadDone) {\n      // Already done, stop.\n      return;\n    }\n    if (this.toLoad <= 0) {\n      // All images loaded.\n      this.createAllDragAndDrops();\n      this.afterImageLoadDone = true;\n      this.question.loaded = true;\n    }\n    // Try again after a while.\n    setTimeout(() => {\n      this.pollForImageLoad();\n    }, 1000);\n  }\n  /**\n   * Remove a draggable element from the drop zone where it is.\n   *\n   * @param drag Draggable element to remove.\n   */\n  removeDragFromDrop(drag) {\n    // Check if the draggable element is assigned to an input. If so, empty the input's value.\n    const inputId = drag.getAttribute('inputid');\n    if (inputId) {\n      var _this$doc$topNode5;\n      (_this$doc$topNode5 = this.doc.topNode) === null || _this$doc$topNode5 === void 0 || (_this$doc$topNode5 = _this$doc$topNode5.querySelector(`input#${inputId}`)) === null || _this$doc$topNode5 === void 0 || _this$doc$topNode5.setAttribute('value', '0');\n    }\n    // Move the element to its original position.\n    const dragItemHome = this.doc.dragItemHome(Number(drag.getAttribute('dragitemno')));\n    const ddArea = this.container.querySelector('.ddarea');\n    if (!dragItemHome || !ddArea) {\n      return;\n    }\n    const position = CoreDom.getRelativeElementPosition(dragItemHome, ddArea);\n    drag.style.left = position.x + 'px';\n    drag.style.top = position.y + 'px';\n    drag.classList.remove('placed');\n    drag.setAttribute('inputid', '');\n  }\n  /**\n   * Reposition all the draggable elements and drop zones.\n   */\n  repositionDragsForQuestion() {\n    const dragItems = this.doc.dragItems();\n    // Mark all draggable items as \"unplaced\", they will be placed again later.\n    dragItems.forEach(dragItem => {\n      dragItem.classList.remove('placed');\n      dragItem.setAttribute('inputid', '');\n    });\n    // Calculate the proportion to apply to images.\n    this.calculateImgProportion();\n    // Apply the proportion to all images in drag item homes.\n    const dragItemHomes = this.doc.dragItemHomes();\n    for (let x = 0; x < dragItemHomes.length; x++) {\n      const dragItemHome = dragItemHomes[x];\n      const dragItemHomeImg = dragItemHome.querySelector('img');\n      if (!dragItemHomeImg || dragItemHomeImg.naturalWidth <= 0) {\n        continue;\n      }\n      const widthHeight = [Math.round(dragItemHomeImg.naturalWidth * this.proportion), Math.round(dragItemHomeImg.naturalHeight * this.proportion)];\n      dragItemHomeImg.style.width = widthHeight[0] + 'px';\n      dragItemHomeImg.style.height = widthHeight[1] + 'px';\n      // Apply the proportion to all the images cloned from this home.\n      const dragItemNo = this.doc.getClassnameNumericSuffix(dragItemHome, 'dragitemhomes');\n      const groupNo = this.doc.getClassnameNumericSuffix(dragItemHome, 'group');\n      const dragsImg = this.doc.topNode ? Array.from(this.doc.topNode.querySelectorAll(`.drag.group${groupNo}.dragitems${dragItemNo} img`)) : [];\n      dragsImg.forEach(dragImg => {\n        dragImg.style.width = widthHeight[0] + 'px';\n        dragImg.style.height = widthHeight[1] + 'px';\n      });\n    }\n    // Update the padding of all draggable elements.\n    this.updatePaddingSizesAll();\n    const dropZones = this.doc.dropZones();\n    for (let x = 0; x < dropZones.length; x++) {\n      var _dropZone$getAttribut, _this$doc$topNode6;\n      // Re-position the drop zone based on the proportion.\n      const dropZone = dropZones[x];\n      const dropZoneXY = (_dropZone$getAttribut = dropZone.getAttribute('xy')) === null || _dropZone$getAttribut === void 0 ? void 0 : _dropZone$getAttribut.split(',').map(i => Number(i));\n      const relativeXY = this.convertToWindowXY(dropZoneXY || []);\n      dropZone.style.left = relativeXY[0] + 'px';\n      dropZone.style.top = relativeXY[1] + 'px';\n      // Re-place items got from the inputs.\n      const inputCss = 'input#' + dropZone.getAttribute('inputid');\n      const input = (_this$doc$topNode6 = this.doc.topNode) === null || _this$doc$topNode6 === void 0 ? void 0 : _this$doc$topNode6.querySelector(inputCss);\n      const choice = input ? Number(input.value) : -1;\n      if (choice > 0) {\n        const dragItem = this.getUnplacedChoiceForDrop(choice, dropZone);\n        if (dragItem !== null) {\n          this.placeDragInDrop(dragItem, dropZone);\n        }\n      }\n    }\n    // Re-place draggable items not placed drop zones (they will be placed in the original position).\n    for (let x = 0; x < dragItems.length; x++) {\n      const dragItem = dragItems[x];\n      if (!dragItem.classList.contains('placed') && !dragItem.classList.contains('beingdragged')) {\n        this.removeDragFromDrop(dragItem);\n      }\n    }\n  }\n  /**\n   * Mark a draggable element as selected.\n   *\n   * @param drag Element to select.\n   */\n  selectDrag(drag) {\n    // Deselect previous ones.\n    this.deselectDrags();\n    this.selected = drag;\n    drag.classList.add('beingdragged');\n  }\n  /**\n   * Stop waiting for images to be loaded.\n   */\n  stopPolling() {\n    this.afterImageLoadDone = true;\n  }\n  /**\n   * Update the padding of all items in a group to make them all have the same width and height.\n   *\n   * @param groupNo The group number.\n   */\n  updatePaddingSizeForGroup(groupNo) {\n    // Get all the items for this group.\n    const groupItems = this.doc.topNode ? Array.from(this.doc.topNode.querySelectorAll(`.draghome.group${groupNo}`)) : [];\n    if (groupItems.length == 0) {\n      return;\n    }\n    // Get the max width and height of the items.\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (let x = 0; x < groupItems.length; x++) {\n      // Check if the item has an img.\n      const item = groupItems[x];\n      const img = item.querySelector('img');\n      if (img) {\n        maxWidth = Math.max(maxWidth, Math.round(this.proportion * img.naturalWidth));\n        maxHeight = Math.max(maxHeight, Math.round(this.proportion * img.naturalHeight));\n      } else {\n        // Remove the padding to calculate the size.\n        const originalPadding = item.style.padding;\n        item.style.padding = '';\n        // Text is not affected by the proportion.\n        maxWidth = Math.max(maxWidth, Math.round(item.clientWidth));\n        maxHeight = Math.max(maxHeight, Math.round(item.clientHeight));\n        // Restore the padding.\n        item.style.padding = originalPadding;\n      }\n    }\n    if (maxWidth <= 0 || maxHeight <= 0) {\n      return;\n    }\n    // Add a variable padding to the image or text.\n    maxWidth = Math.round(maxWidth + this.proportion * 8);\n    maxHeight = Math.round(maxHeight + this.proportion * 8);\n    for (let x = 0; x < groupItems.length; x++) {\n      // Check if the item has an img and calculate its width and height.\n      const item = groupItems[x];\n      const img = item.querySelector('img');\n      let width;\n      let height;\n      if (img) {\n        width = Math.round(img.naturalWidth * this.proportion);\n        height = Math.round(img.naturalHeight * this.proportion);\n      } else {\n        // Remove the padding to calculate the size.\n        const originalPadding = item.style.padding;\n        item.style.padding = '';\n        // Text is not affected by the proportion.\n        width = Math.round(item.clientWidth);\n        height = Math.round(item.clientHeight);\n        // Restore the padding.\n        item.style.padding = originalPadding;\n      }\n      // Now set the right padding to make this item have the max height and width.\n      const marginTopBottom = Math.round((maxHeight - height) / 2);\n      const marginLeftRight = Math.round((maxWidth - width) / 2);\n      // Correction for the roundings.\n      const widthCorrection = maxWidth - (width + marginLeftRight * 2);\n      const heightCorrection = maxHeight - (height + marginTopBottom * 2);\n      item.style.padding = marginTopBottom + 'px ' + marginLeftRight + 'px ' + (marginTopBottom + heightCorrection) + 'px ' + (marginLeftRight + widthCorrection) + 'px';\n      const dragItemNo = this.doc.getClassnameNumericSuffix(item, 'dragitemhomes');\n      const drags = this.doc.topNode ? Array.from(this.doc.topNode.querySelectorAll(`.drag.group${groupNo}.dragitems${dragItemNo}`)) : [];\n      drags.forEach(drag => {\n        drag.style.padding = marginTopBottom + 'px ' + marginLeftRight + 'px ' + (marginTopBottom + heightCorrection) + 'px ' + (marginLeftRight + widthCorrection) + 'px';\n      });\n    }\n    // It adds the border of 1px to the width.\n    const zoneGroups = this.doc.dropZoneGroup(groupNo);\n    zoneGroups.forEach(zone => {\n      zone.style.width = maxWidth + 2 + 'px ';\n      zone.style.height = maxHeight + 2 + 'px ';\n    });\n  }\n  /**\n   * Update the padding of all items in all groups.\n   */\n  updatePaddingSizesAll() {\n    for (let groupNo = 1; groupNo <= 8; groupNo++) {\n      this.updatePaddingSizeForGroup(groupNo);\n    }\n  }\n}\n/**\n * Encapsulates operations on dd area.\n */\nexport class AddonQtypeDdImageOrTextQuestionDocStructure {\n  constructor(container, slot) {\n    var _this$topNode;\n    this.container = container;\n    this.slot = slot;\n    this.logger = CoreLogger.getInstance('AddonQtypeDdImageOrTextQuestionDocStructure');\n    this.topNode = this.container.querySelector('.addon-qtype-ddimageortext-container');\n    this.dragItemsArea = ((_this$topNode = this.topNode) === null || _this$topNode === void 0 ? void 0 : _this$topNode.querySelector('div.draghomes')) || null;\n    if (!this.topNode) {\n      this.logger.error('ddimageortext container not found');\n      return;\n    }\n    if (this.dragItemsArea) {\n      // On 3.9+ dragitems were removed.\n      const dragItems = this.topNode.querySelector('div.dragitems');\n      if (dragItems) {\n        // Remove empty div.dragitems.\n        dragItems.remove();\n      }\n      // 3.6+ site, transform HTML so it has the same structure as in Moodle 3.5.\n      const ddArea = this.topNode.querySelector('div.ddarea');\n      if (ddArea) {\n        // Move div.dropzones to div.ddarea.\n        const dropZones = this.topNode.querySelector('div.dropzones');\n        if (dropZones) {\n          ddArea.appendChild(dropZones);\n        }\n        // Move div.draghomes to div.ddarea and rename the class to .dragitems.\n        ddArea === null || ddArea === void 0 || ddArea.appendChild(this.dragItemsArea);\n      }\n      this.dragItemsArea.classList.remove('draghomes');\n      this.dragItemsArea.classList.add('dragitems');\n      // Add .dragitemhomesNNN class to drag items.\n      Array.from(this.dragItemsArea.querySelectorAll('.draghome')).forEach((draghome, index) => {\n        draghome.classList.add(`dragitemhomes${index}`);\n      });\n    } else {\n      this.dragItemsArea = this.topNode.querySelector('div.dragitems');\n    }\n  }\n  querySelector(element, selector) {\n    if (!element) {\n      return null;\n    }\n    return element.querySelector(selector);\n  }\n  querySelectorAll(element, selector) {\n    if (!element) {\n      return [];\n    }\n    return Array.from(element.querySelectorAll(selector));\n  }\n  dragItems() {\n    return this.querySelectorAll(this.dragItemsArea, '.drag');\n  }\n  dropZones() {\n    return this.querySelectorAll(this.topNode, 'div.dropzones div.dropzone');\n  }\n  dropZoneGroup(groupNo) {\n    return this.querySelectorAll(this.topNode, `div.dropzones div.group${groupNo}`);\n  }\n  dragItemsClonedFrom(dragItemNo) {\n    return this.querySelectorAll(this.dragItemsArea, `.dragitems${dragItemNo}`);\n  }\n  dragItem(dragInstanceNo) {\n    return this.querySelector(this.dragItemsArea, `.draginstance${dragInstanceNo}`);\n  }\n  dragItemsInGroup(groupNo) {\n    return this.querySelectorAll(this.dragItemsArea, `.drag.group${groupNo}`);\n  }\n  dragItemHomes() {\n    return this.querySelectorAll(this.dragItemsArea, '.draghome');\n  }\n  bgImg() {\n    return this.querySelector(this.topNode, '.dropbackground');\n  }\n  dragItemHome(dragItemNo) {\n    return this.querySelector(this.dragItemsArea, `.dragitemhomes${dragItemNo}`);\n  }\n  getClassnameNumericSuffix(node, prefix) {\n    if (node.classList && node.classList.length) {\n      const patt1 = new RegExp(`^${prefix}([0-9])+$`);\n      const classFound = Array.from(node.classList).find(className => patt1.test(className));\n      if (classFound) {\n        const patt2 = new RegExp('([0-9])+$');\n        const match = patt2.exec(classFound);\n        return Number(match === null || match === void 0 ? void 0 : match[0]);\n      }\n    }\n    this.logger.warn(`Prefix \"${prefix}\" not found in class names.`);\n  }\n  cloneNewDragItem(dragInstanceNo, dragItemNo) {\n    var _dragHome$parentEleme;\n    const dragHome = this.dragItemHome(dragItemNo);\n    if (dragHome === null) {\n      return null;\n    }\n    const dragHomeImg = dragHome.querySelector('img');\n    let divDrag = undefined;\n    // Images need to be inside a div element to admit padding with width and height.\n    if (dragHomeImg) {\n      // Clone the image.\n      const drag = dragHomeImg.cloneNode(true);\n      // Create a div and put the image in it.\n      divDrag = document.createElement('div');\n      divDrag.appendChild(drag);\n      divDrag.className = dragHome.className;\n      drag.className = '';\n    } else {\n      // The drag item doesn't have an image, just clone it.\n      divDrag = dragHome.cloneNode(true);\n    }\n    // Set the right classes and styles.\n    divDrag.classList.remove(`dragitemhomes${dragItemNo}`);\n    divDrag.classList.remove('draghome');\n    divDrag.classList.add(`dragitems${dragItemNo}`);\n    divDrag.classList.add(`draginstance${dragInstanceNo}`);\n    divDrag.classList.add('drag');\n    divDrag.style.visibility = 'inherit';\n    divDrag.style.position = 'absolute';\n    divDrag.setAttribute('draginstanceno', String(dragInstanceNo));\n    divDrag.setAttribute('dragitemno', String(dragItemNo));\n    divDrag.setAttribute('tabindex', '0');\n    // Insert the new drag after the dragHome.\n    (_dragHome$parentEleme = dragHome.parentElement) === null || _dragHome$parentEleme === void 0 || _dragHome$parentEleme.insertBefore(divDrag, dragHome.nextSibling);\n    return divDrag;\n  }\n}","map":{"version":3,"names":["CoreDom","CoreLogger","AddonQtypeDdImageOrTextQuestion","constructor","container","question","readOnly","drops","toLoad","afterImageLoadDone","proportion","logger","getInstance","initializer","calculateImgProportion","bgImg","doc","width","naturalWidth","convertToWindowXY","bgImgXY","ddArea","querySelector","position","getRelativeElementPosition","x","y","createAllDragAndDrops","_this","_asyncToGenerator","_this$doc$dragItemsAr","_this$container$query","initDrops","dragItemsArea","classList","add","makeDragAreaClickable","dragItemHomes","i","length","_this$doc$getClassnam","_this$doc$getClassnam2","_this$doc$getClassnam3","dragItemHome","dragItemNo","getClassnameNumericSuffix","choice","group","tagName","_dragItemHome$parentN","wrap","document","createElement","className","parentNode","insertBefore","appendChild","dragNode","cloneNewDragItem","draggableForQuestion","contains","groupSize","dropZoneGroup","dragsToCreate","newDragNode","waitToBeVisible","repositionDragsForQuestion","dropZones","forEach","dropZone","setAttribute","deselectDrags","drags","dragItems","drag","remove","selected","destroy","_this$resizeListener","stopPolling","resizeListener","off","String","addEventListener","e","preventDefault","stopPropagation","selectDrag","dropClick","dropNode","Number","getAttribute","placeDragInDrop","getChoicesForDrop","drop","topNode","Array","from","querySelectorAll","getUnplacedChoiceForDrop","foundItem","find","dragItem","_this$doc$topNode","dropAreas","groupNodes","groupNo","groupNode","dropNo","nodeClass","title","text","replace","style","opacity","xy","fieldname","AddonQtypeDdImageOrTextQuestionDocStructure","slot","_this$doc$topNode2","setTimeout","error","complete","itemHomes","item","itemImg","pollForImageLoad","onWindowResize","home","removeDragFromDrop","_this$doc$topNode3","targetInputId","inputNode","originInputId","_this$doc$topNode4","originInputNode","left","top","loaded","inputId","_this$doc$topNode5","dragItemHomeImg","widthHeight","Math","round","naturalHeight","height","dragsImg","dragImg","updatePaddingSizesAll","_dropZone$getAttribut","_this$doc$topNode6","dropZoneXY","split","map","relativeXY","inputCss","input","value","updatePaddingSizeForGroup","groupItems","maxWidth","maxHeight","img","max","originalPadding","padding","clientWidth","clientHeight","marginTopBottom","marginLeftRight","widthCorrection","heightCorrection","zoneGroups","zone","_this$topNode","draghome","index","element","selector","dragItemsClonedFrom","dragInstanceNo","dragItemsInGroup","node","prefix","patt1","RegExp","classFound","test","patt2","match","exec","warn","_dragHome$parentEleme","dragHome","dragHomeImg","divDrag","undefined","cloneNode","visibility","parentElement","nextSibling"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/qtype/ddimageortext/classes/ddimageortext.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreDom } from '@singletons/dom';\nimport { CoreEventObserver } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { AddonModQuizDdImageOrTextQuestionData } from '../component/ddimageortext';\n\n/**\n * Class to make a question of ddimageortext type work.\n */\nexport class AddonQtypeDdImageOrTextQuestion {\n\n    protected logger: CoreLogger;\n    protected toLoad = 0;\n    protected doc!: AddonQtypeDdImageOrTextQuestionDocStructure;\n    protected afterImageLoadDone = false;\n    protected proportion = 1;\n    protected selected?: HTMLElement | null; // Selected element (being \"dragged\").\n    protected resizeListener?: CoreEventObserver;\n\n    /**\n     * Create the this.\n     *\n     * @param container The container HTMLElement of the question.\n     * @param question The question.\n     * @param readOnly Whether it's read only.\n     * @param drops The drop zones received in the init object of the question.\n     */\n    constructor(\n        protected container: HTMLElement,\n        protected question: AddonModQuizDdImageOrTextQuestionData,\n        protected readOnly: boolean,\n        protected drops?: unknown[],\n    ) {\n        this.logger = CoreLogger.getInstance('AddonQtypeDdImageOrTextQuestion');\n\n        this.initializer();\n    }\n\n    /**\n     * Calculate image proportion to make easy conversions.\n     */\n    calculateImgProportion(): void {\n        const bgImg = this.doc.bgImg();\n        if (!bgImg) {\n            return;\n        }\n\n        // Render the position related to the current image dimensions.\n        this.proportion = 1;\n        if (bgImg.width != bgImg.naturalWidth) {\n            this.proportion = bgImg.width / bgImg.naturalWidth;\n        }\n    }\n\n    /**\n     * Convert the X and Y position of the BG IMG to a position relative to the window.\n     *\n     * @param bgImgXY X and Y of the BG IMG relative position.\n     * @returns Position relative to the window.\n     */\n    convertToWindowXY(bgImgXY: number[]): number[] {\n        const bgImg = this.doc.bgImg();\n        if (!bgImg) {\n            return bgImgXY;\n        }\n\n        const ddArea = this.container.querySelector<HTMLElement>('.ddarea');\n        if (!ddArea) {\n            return bgImgXY;\n        }\n\n        const position = CoreDom.getRelativeElementPosition(bgImg, ddArea);\n\n        // Render the position related to the current image dimensions.\n        bgImgXY[0] *= this.proportion;\n        bgImgXY[1] *= this.proportion;\n\n        return [bgImgXY[0] + position.x + 1, bgImgXY[1] + position.y + 1];\n    }\n\n    /**\n     * Create and initialize all draggable elements and drop zones.\n     */\n    async createAllDragAndDrops(): Promise<void> {\n        // Initialize drop zones.\n        this.initDrops();\n\n        // Initialize drag items area.\n        this.doc.dragItemsArea?.classList.add('clearfix');\n        this.makeDragAreaClickable();\n\n        const dragItemHomes = this.doc.dragItemHomes();\n        let i = 0;\n\n        // Create the draggable items.\n        for (let x = 0; x < dragItemHomes.length; x++) {\n\n            const dragItemHome = dragItemHomes[x];\n            const dragItemNo = this.doc.getClassnameNumericSuffix(dragItemHome, 'dragitemhomes') ?? -1;\n            const choice = this.doc.getClassnameNumericSuffix(dragItemHome, 'choice') ?? -1;\n            const group = this.doc.getClassnameNumericSuffix(dragItemHome, 'group') ?? -1;\n\n            // Images need to be inside a div element to admit padding with width and height.\n            if (dragItemHome.tagName == 'IMG') {\n                const wrap = document.createElement('div');\n                wrap.className = dragItemHome.className;\n                dragItemHome.className = '';\n\n                // Insert wrapper before the image in the DOM tree.\n                dragItemHome.parentNode?.insertBefore(wrap, dragItemHome);\n                // Move the image into wrapper.\n                wrap.appendChild(dragItemHome);\n            }\n\n            // Create a new drag item for this home.\n            const dragNode = this.doc.cloneNewDragItem(i, dragItemNo);\n            i++;\n\n            // Make the item draggable.\n            this.draggableForQuestion(dragNode, group, choice);\n\n            // If the draggable item needs to be created more than once, create the rest of copies.\n            if (dragNode?.classList.contains('infinite')) {\n                const groupSize = this.doc.dropZoneGroup(group).length;\n                let dragsToCreate = groupSize - 1;\n\n                while (dragsToCreate > 0) {\n                    const newDragNode = this.doc.cloneNewDragItem(i, dragItemNo);\n                    i++;\n                    this.draggableForQuestion(newDragNode, group, choice);\n\n                    dragsToCreate--;\n                }\n            }\n        }\n\n        await CoreDom.waitToBeVisible(\n            this.container.querySelector<HTMLElement>('.ddarea') ??\n            this.container,\n        );\n\n        // All drag items have been created, position them.\n        this.repositionDragsForQuestion();\n\n        if (!this.readOnly) {\n            const dropZones = this.doc.dropZones();\n            dropZones.forEach((dropZone) => {\n                dropZone.setAttribute('tabIndex', '0');\n            });\n        }\n    }\n\n    /**\n     * Deselect all drags.\n     */\n    deselectDrags(): void {\n        const drags = this.doc.dragItems();\n\n        drags.forEach((drag) => {\n            drag.classList.remove('beingdragged');\n        });\n\n        this.selected = null;\n    }\n\n    /**\n     * Function to call when the instance is no longer needed.\n     */\n    destroy(): void {\n        this.stopPolling();\n\n        this.resizeListener?.off();\n    }\n\n    /**\n     * Make an element draggable.\n     *\n     * @param drag Element to make draggable.\n     * @param group Group the element belongs to.\n     * @param choice Choice the element belongs to.\n     */\n    draggableForQuestion(drag: HTMLElement | null, group: number, choice: number): void {\n        if (!drag) {\n            return;\n        }\n\n        // Set attributes.\n        drag.setAttribute('group', String(group));\n        drag.setAttribute('choice', String(choice));\n\n        if (!this.readOnly) {\n            // Listen to click events.\n            drag.addEventListener('click', (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n\n                if (drag.classList.contains('beingdragged')) {\n                    this.deselectDrags();\n                } else {\n                    this.selectDrag(drag);\n                }\n            });\n        }\n    }\n\n    /**\n     * Function called when a drop zone is clicked.\n     *\n     * @param dropNode Drop element.\n     */\n    dropClick(dropNode: HTMLElement): void {\n        const drag = this.selected;\n        if (!drag) {\n            // No selected item, nothing to do.\n            return;\n        }\n\n        // Deselect the drag and place it in the position of this drop zone if it belongs to the same group.\n        this.deselectDrags();\n\n        if (Number(dropNode.getAttribute('group')) === Number(drag.getAttribute('group'))) {\n            this.placeDragInDrop(drag, dropNode);\n        }\n    }\n\n    /**\n     * Get all the draggable elements for a choice and a drop zone.\n     *\n     * @param choice Choice number.\n     * @param drop Drop zone.\n     * @returns Draggable elements.\n     */\n    getChoicesForDrop(choice: number, drop: HTMLElement): HTMLElement[] {\n        if (!this.doc.topNode) {\n            return [];\n        }\n\n        return Array.from(\n            this.doc.topNode.querySelectorAll('div.dragitemgroup' + drop.getAttribute('group') + ` .choice${choice}.drag`),\n        );\n    }\n\n    /**\n     * Get an unplaced draggable element that belongs to a certain choice and drop zone.\n     *\n     * @param choice Choice number.\n     * @param drop Drop zone.\n     * @returns Unplaced draggable element.\n     */\n    getUnplacedChoiceForDrop(choice: number, drop: HTMLElement): HTMLElement | null {\n        const dragItems = this.getChoicesForDrop(choice, drop);\n\n        const foundItem = dragItems.find((dragItem) =>\n            !dragItem.classList.contains('placed') && !dragItem.classList.contains('beingdragged'));\n\n        return foundItem || null;\n    }\n\n    /**\n     * Initialize drop zones.\n     */\n    initDrops(): void {\n        const dropAreas = this.doc.topNode?.querySelector('div.dropzones');\n        if (!dropAreas) {\n            return;\n        }\n\n        const groupNodes: Record<number, HTMLElement> = {};\n\n        // Create all group nodes and add them to the drop area.\n        for (let groupNo = 1; groupNo <= 8; groupNo++) {\n            const groupNode = document.createElement('div');\n            groupNode.className = `dropzonegroup${groupNo}`;\n\n            dropAreas.appendChild(groupNode);\n            groupNodes[groupNo] = groupNode;\n        }\n\n        // Create the drops specified by the init object.\n        for (const dropNo in this.drops) {\n            const drop = this.drops[dropNo];\n            const nodeClass = `dropzone group${drop.group} place${dropNo}`;\n            const title = drop.text.replace('\"', '\"');\n            const dropNode = document.createElement('div');\n\n            dropNode.setAttribute('title', title);\n            dropNode.className = nodeClass;\n\n            groupNodes[drop.group].appendChild(dropNode);\n            dropNode.style.opacity = '0.5';\n            dropNode.setAttribute('xy', drop.xy);\n            dropNode.setAttribute('aria-label', drop.text);\n            dropNode.setAttribute('place', dropNo);\n            dropNode.setAttribute('inputid', drop.fieldname.replace(':', '_'));\n            dropNode.setAttribute('group', drop.group);\n\n            dropNode.addEventListener('click', (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n\n                this.dropClick(dropNode);\n            });\n        }\n    }\n\n    /**\n     * Initialize the question.\n     */\n    initializer(): void {\n        this.doc = new AddonQtypeDdImageOrTextQuestionDocStructure(this.container, this.question.slot);\n\n        if (this.readOnly) {\n            this.doc.topNode?.classList.add('readonly');\n        }\n\n        // Wait the DOM to be rendered.\n        setTimeout(() => {\n            const bgImg = this.doc.bgImg();\n            if (!bgImg) {\n                this.logger.error('Background image not found');\n\n                return;\n            }\n\n            // Wait for background image to be loaded.\n            // On iOS, complete is mistakenly true, check also naturalWidth for compatibility.\n            if (!bgImg.complete || !bgImg.naturalWidth) {\n                this.toLoad++;\n                bgImg.addEventListener('load', () => {\n                    this.toLoad--;\n                });\n            }\n\n            const itemHomes = this.doc.dragItemHomes();\n            itemHomes.forEach((item) => {\n                if (item.tagName != 'IMG') {\n                    return;\n                }\n                // Wait for drag images to be loaded.\n                // On iOS, complete is mistakenly true, check also naturalWidth for compatibility.\n                const itemImg = <HTMLImageElement> item;\n\n                if (!itemImg.complete || !itemImg.naturalWidth) {\n                    this.toLoad++;\n                    itemImg.addEventListener('load', () => {\n                        this.toLoad--;\n                    });\n                }\n            });\n\n            this.pollForImageLoad();\n        });\n\n        this.resizeListener = CoreDom.onWindowResize(() => {\n            this.repositionDragsForQuestion();\n        });\n    }\n\n    /**\n     * Make the drag items area clickable.\n     */\n    makeDragAreaClickable(): void {\n        if (this.readOnly) {\n            return;\n        }\n\n        const home = this.doc.dragItemsArea;\n        home?.addEventListener('click', (e) => {\n            const drag = this.selected;\n            if (!drag) {\n                // No element selected, nothing to do.\n                return false;\n            }\n\n            // An element was selected. Deselect it and move it back to the area if needed.\n            this.deselectDrags();\n            this.removeDragFromDrop(drag);\n\n            e.preventDefault();\n            e.stopPropagation();\n        });\n    }\n\n    /**\n     * Place a draggable element into a certain drop zone.\n     *\n     * @param drag Draggable element.\n     * @param drop Drop zone element.\n     */\n    placeDragInDrop(drag: HTMLElement, drop: HTMLElement): void {\n        // Search the input related to the drop zone.\n        const targetInputId = drop.getAttribute('inputid') || '';\n        const inputNode = this.doc.topNode?.querySelector<HTMLInputElement>(`input#${targetInputId}`);\n\n        // Check if the draggable item is already assigned to an input and if it's the same as the one of the drop zone.\n        const originInputId = drag.getAttribute('inputid');\n        if (originInputId && originInputId != targetInputId) {\n            // Remove it from the previous place.\n            const originInputNode = this.doc.topNode?.querySelector<HTMLInputElement>(`input#${originInputId}`);\n            originInputNode?.setAttribute('value', '0');\n        }\n\n        // Now position the draggable and set it to the input.\n        const ddArea = this.container.querySelector<HTMLElement>('.ddarea');\n        if (!ddArea) {\n            return;\n        }\n\n        const position = CoreDom.getRelativeElementPosition(drop, ddArea);\n        const choice = drag.getAttribute('choice');\n        drag.style.left = position.x + 'px';\n        drag.style.top = position.y + 'px';\n        drag.classList.add('placed');\n\n        if (choice) {\n            inputNode?.setAttribute('value', choice);\n        }\n\n        drag.setAttribute('inputid', targetInputId);\n    }\n\n    /**\n     * Wait for images to be loaded.\n     */\n    pollForImageLoad(): void {\n        if (this.afterImageLoadDone) {\n            // Already done, stop.\n            return;\n        }\n\n        if (this.toLoad <= 0) {\n            // All images loaded.\n            this.createAllDragAndDrops();\n            this.afterImageLoadDone = true;\n            this.question.loaded = true;\n        }\n\n        // Try again after a while.\n        setTimeout(() => {\n            this.pollForImageLoad();\n        }, 1000);\n    }\n\n    /**\n     * Remove a draggable element from the drop zone where it is.\n     *\n     * @param drag Draggable element to remove.\n     */\n    removeDragFromDrop(drag: HTMLElement): void {\n        // Check if the draggable element is assigned to an input. If so, empty the input's value.\n        const inputId = drag.getAttribute('inputid');\n        if (inputId) {\n            this.doc.topNode?.querySelector<HTMLInputElement>(`input#${inputId}`)?.setAttribute('value', '0');\n        }\n\n        // Move the element to its original position.\n        const dragItemHome = this.doc.dragItemHome(Number(drag.getAttribute('dragitemno')));\n        const ddArea = this.container.querySelector<HTMLElement>('.ddarea');\n        if (!dragItemHome || !ddArea) {\n            return;\n        }\n\n        const position = CoreDom.getRelativeElementPosition(dragItemHome, ddArea);\n        drag.style.left = position.x + 'px';\n        drag.style.top = position.y + 'px';\n        drag.classList.remove('placed');\n\n        drag.setAttribute('inputid', '');\n    }\n\n    /**\n     * Reposition all the draggable elements and drop zones.\n     */\n    repositionDragsForQuestion(): void {\n        const dragItems = this.doc.dragItems();\n\n        // Mark all draggable items as \"unplaced\", they will be placed again later.\n        dragItems.forEach((dragItem) => {\n            dragItem.classList.remove('placed');\n            dragItem.setAttribute('inputid', '');\n        });\n\n        // Calculate the proportion to apply to images.\n        this.calculateImgProportion();\n\n        // Apply the proportion to all images in drag item homes.\n        const dragItemHomes = this.doc.dragItemHomes();\n        for (let x = 0; x < dragItemHomes.length; x++) {\n            const dragItemHome = dragItemHomes[x];\n            const dragItemHomeImg = dragItemHome.querySelector('img');\n\n            if (!dragItemHomeImg || dragItemHomeImg.naturalWidth <= 0) {\n                continue;\n            }\n\n            const widthHeight = [Math.round(dragItemHomeImg.naturalWidth * this.proportion),\n                Math.round(dragItemHomeImg.naturalHeight * this.proportion)];\n\n            dragItemHomeImg.style.width = widthHeight[0] + 'px';\n            dragItemHomeImg.style.height = widthHeight[1] + 'px';\n\n            // Apply the proportion to all the images cloned from this home.\n            const dragItemNo = this.doc.getClassnameNumericSuffix(dragItemHome, 'dragitemhomes');\n            const groupNo = this.doc.getClassnameNumericSuffix(dragItemHome, 'group');\n            const dragsImg = this.doc.topNode ?\n                Array.from(this.doc.topNode.querySelectorAll<HTMLElement>(`.drag.group${groupNo}.dragitems${dragItemNo} img`)) : [];\n\n            dragsImg.forEach((dragImg) => {\n                dragImg.style.width = widthHeight[0] + 'px';\n                dragImg.style.height = widthHeight[1] + 'px';\n            });\n        }\n\n        // Update the padding of all draggable elements.\n        this.updatePaddingSizesAll();\n\n        const dropZones = this.doc.dropZones();\n        for (let x = 0; x < dropZones.length; x++) {\n            // Re-position the drop zone based on the proportion.\n            const dropZone = dropZones[x];\n            const dropZoneXY = dropZone.getAttribute('xy')?.split(',').map((i) => Number(i));\n            const relativeXY = this.convertToWindowXY(dropZoneXY || []);\n\n            dropZone.style.left = relativeXY[0] + 'px';\n            dropZone.style.top = relativeXY[1] + 'px';\n\n            // Re-place items got from the inputs.\n            const inputCss = 'input#' + dropZone.getAttribute('inputid');\n            const input = this.doc.topNode?.querySelector<HTMLInputElement>(inputCss);\n            const choice = input ? Number(input.value) : -1;\n\n            if (choice > 0) {\n                const dragItem = this.getUnplacedChoiceForDrop(choice, dropZone);\n\n                if (dragItem !== null) {\n                    this.placeDragInDrop(dragItem, dropZone);\n                }\n            }\n        }\n\n        // Re-place draggable items not placed drop zones (they will be placed in the original position).\n        for (let x = 0; x < dragItems.length; x++) {\n            const dragItem = dragItems[x];\n            if (!dragItem.classList.contains('placed') && !dragItem.classList.contains('beingdragged')) {\n                this.removeDragFromDrop(dragItem);\n            }\n        }\n    }\n\n    /**\n     * Mark a draggable element as selected.\n     *\n     * @param drag Element to select.\n     */\n    selectDrag(drag: HTMLElement): void {\n        // Deselect previous ones.\n        this.deselectDrags();\n\n        this.selected = drag;\n        drag.classList.add('beingdragged');\n    }\n\n    /**\n     * Stop waiting for images to be loaded.\n     */\n    stopPolling(): void {\n        this.afterImageLoadDone = true;\n    }\n\n    /**\n     * Update the padding of all items in a group to make them all have the same width and height.\n     *\n     * @param groupNo The group number.\n     */\n    updatePaddingSizeForGroup(groupNo: number): void {\n\n        // Get all the items for this group.\n        const groupItems = this.doc.topNode ?\n            Array.from(this.doc.topNode.querySelectorAll<HTMLElement>(`.draghome.group${groupNo}`)) : [];\n\n        if (groupItems.length == 0) {\n            return;\n        }\n\n        // Get the max width and height of the items.\n        let maxWidth = 0;\n        let maxHeight = 0;\n\n        for (let x = 0; x < groupItems.length; x++) {\n            // Check if the item has an img.\n            const item = groupItems[x];\n            const img = item.querySelector('img');\n\n            if (img) {\n                maxWidth = Math.max(maxWidth, Math.round(this.proportion * img.naturalWidth));\n                maxHeight = Math.max(maxHeight, Math.round(this.proportion * img.naturalHeight));\n            } else {\n                // Remove the padding to calculate the size.\n                const originalPadding = item.style.padding;\n                item.style.padding = '';\n\n                // Text is not affected by the proportion.\n                maxWidth = Math.max(maxWidth, Math.round(item.clientWidth));\n                maxHeight = Math.max(maxHeight, Math.round(item.clientHeight));\n\n                // Restore the padding.\n                item.style.padding = originalPadding;\n            }\n        }\n\n        if (maxWidth <= 0 || maxHeight <= 0) {\n            return;\n        }\n\n        // Add a variable padding to the image or text.\n        maxWidth = Math.round(maxWidth + this.proportion * 8);\n        maxHeight = Math.round(maxHeight + this.proportion * 8);\n\n        for (let x = 0; x < groupItems.length; x++) {\n            // Check if the item has an img and calculate its width and height.\n            const item = groupItems[x];\n            const img = item.querySelector('img');\n            let width: number | undefined;\n            let height: number | undefined;\n\n            if (img) {\n                width = Math.round(img.naturalWidth * this.proportion);\n                height = Math.round(img.naturalHeight * this.proportion);\n            } else {\n                // Remove the padding to calculate the size.\n                const originalPadding = item.style.padding;\n                item.style.padding = '';\n\n                // Text is not affected by the proportion.\n                width = Math.round(item.clientWidth);\n                height = Math.round(item.clientHeight);\n\n                // Restore the padding.\n                item.style.padding = originalPadding;\n            }\n\n            // Now set the right padding to make this item have the max height and width.\n            const marginTopBottom = Math.round((maxHeight - height) / 2);\n            const marginLeftRight = Math.round((maxWidth - width) / 2);\n\n            // Correction for the roundings.\n            const widthCorrection = maxWidth - (width + marginLeftRight * 2);\n            const heightCorrection = maxHeight - (height + marginTopBottom * 2);\n\n            item.style.padding = marginTopBottom + 'px ' + marginLeftRight + 'px ' +\n                (marginTopBottom + heightCorrection) + 'px ' + (marginLeftRight + widthCorrection) + 'px';\n\n            const dragItemNo = this.doc.getClassnameNumericSuffix(item, 'dragitemhomes');\n            const drags = this.doc.topNode ?\n                Array.from(this.doc.topNode.querySelectorAll<HTMLElement>(`.drag.group${groupNo}.dragitems${dragItemNo}`)) : [];\n\n            drags.forEach((drag) => {\n                drag.style.padding = marginTopBottom + 'px ' + marginLeftRight + 'px ' +\n                        (marginTopBottom + heightCorrection) + 'px ' + (marginLeftRight + widthCorrection) + 'px';\n            });\n        }\n\n        // It adds the border of 1px to the width.\n        const zoneGroups = this.doc.dropZoneGroup(groupNo);\n        zoneGroups.forEach((zone) => {\n            zone.style.width = maxWidth + 2 + 'px ';\n            zone.style.height = maxHeight + 2 + 'px ';\n        });\n    }\n\n    /**\n     * Update the padding of all items in all groups.\n     */\n    updatePaddingSizesAll(): void {\n        for (let groupNo = 1; groupNo <= 8; groupNo++) {\n            this.updatePaddingSizeForGroup(groupNo);\n        }\n    }\n\n}\n\n/**\n * Encapsulates operations on dd area.\n */\nexport class AddonQtypeDdImageOrTextQuestionDocStructure {\n\n    topNode: HTMLElement | null;\n    dragItemsArea: HTMLElement | null;\n\n    protected logger: CoreLogger;\n\n    constructor(\n        protected container: HTMLElement,\n        protected slot: number,\n    ) {\n        this.logger = CoreLogger.getInstance('AddonQtypeDdImageOrTextQuestionDocStructure');\n        this.topNode = this.container.querySelector<HTMLElement>('.addon-qtype-ddimageortext-container');\n        this.dragItemsArea = this.topNode?.querySelector<HTMLElement>('div.draghomes') || null;\n\n        if (!this.topNode) {\n            this.logger.error('ddimageortext container not found');\n\n            return;\n        }\n\n        if (this.dragItemsArea) {\n            // On 3.9+ dragitems were removed.\n            const dragItems = this.topNode.querySelector('div.dragitems');\n\n            if (dragItems) {\n                // Remove empty div.dragitems.\n                dragItems.remove();\n            }\n\n            // 3.6+ site, transform HTML so it has the same structure as in Moodle 3.5.\n            const ddArea = this.topNode.querySelector('div.ddarea');\n            if (ddArea) {\n                // Move div.dropzones to div.ddarea.\n                const dropZones = this.topNode.querySelector('div.dropzones');\n                if (dropZones) {\n                    ddArea.appendChild(dropZones);\n                }\n\n                // Move div.draghomes to div.ddarea and rename the class to .dragitems.\n                ddArea?.appendChild(this.dragItemsArea);\n            }\n\n            this.dragItemsArea.classList.remove('draghomes');\n            this.dragItemsArea.classList.add('dragitems');\n\n            // Add .dragitemhomesNNN class to drag items.\n            Array.from(this.dragItemsArea.querySelectorAll('.draghome')).forEach((draghome, index) => {\n                draghome.classList.add(`dragitemhomes${index}`);\n            });\n        } else {\n            this.dragItemsArea = this.topNode.querySelector<HTMLElement>('div.dragitems');\n        }\n    }\n\n    querySelector<T = HTMLElement>(element: HTMLElement | null, selector: string): T | null {\n        if (!element) {\n            return null;\n        }\n\n        return <T | null> element.querySelector(selector);\n    }\n\n    querySelectorAll(element: HTMLElement | null, selector: string): HTMLElement[] {\n        if (!element) {\n            return [];\n        }\n\n        return Array.from(element.querySelectorAll(selector));\n    }\n\n    dragItems(): HTMLElement[] {\n        return this.querySelectorAll(this.dragItemsArea, '.drag');\n    }\n\n    dropZones(): HTMLElement[] {\n        return this.querySelectorAll(this.topNode, 'div.dropzones div.dropzone');\n    }\n\n    dropZoneGroup(groupNo: number): HTMLElement[] {\n        return this.querySelectorAll(this.topNode, `div.dropzones div.group${groupNo}`);\n    }\n\n    dragItemsClonedFrom(dragItemNo: number): HTMLElement[] {\n        return this.querySelectorAll(this.dragItemsArea, `.dragitems${dragItemNo}`);\n    }\n\n    dragItem(dragInstanceNo: number): HTMLElement | null {\n        return this.querySelector(this.dragItemsArea, `.draginstance${dragInstanceNo}`);\n    }\n\n    dragItemsInGroup(groupNo: number): HTMLElement[] {\n        return this.querySelectorAll(this.dragItemsArea, `.drag.group${groupNo}`);\n    }\n\n    dragItemHomes(): HTMLElement[] {\n        return this.querySelectorAll(this.dragItemsArea, '.draghome');\n    }\n\n    bgImg(): HTMLImageElement | null {\n        return this.querySelector(this.topNode, '.dropbackground');\n    }\n\n    dragItemHome(dragItemNo: number): HTMLElement | null {\n        return this.querySelector(this.dragItemsArea, `.dragitemhomes${dragItemNo}`);\n    }\n\n    getClassnameNumericSuffix(node: HTMLElement, prefix: string): number | undefined {\n        if (node.classList && node.classList.length) {\n            const patt1 = new RegExp(`^${prefix}([0-9])+$`);\n\n            const classFound = Array.from(node.classList)\n                .find((className) => patt1.test(className));\n\n            if (classFound) {\n                const patt2 = new RegExp('([0-9])+$');\n                const match = patt2.exec(classFound);\n\n                return Number(match?.[0]);\n            }\n        }\n\n        this.logger.warn(`Prefix \"${prefix}\" not found in class names.`);\n    }\n\n    cloneNewDragItem(dragInstanceNo: number, dragItemNo: number): HTMLElement | null {\n        const dragHome = this.dragItemHome(dragItemNo);\n        if (dragHome === null) {\n            return null;\n        }\n\n        const dragHomeImg = dragHome.querySelector('img');\n        let divDrag: HTMLElement | undefined = undefined;\n\n        // Images need to be inside a div element to admit padding with width and height.\n        if (dragHomeImg) {\n            // Clone the image.\n            const drag = <HTMLElement> dragHomeImg.cloneNode(true);\n\n            // Create a div and put the image in it.\n            divDrag = document.createElement('div');\n            divDrag.appendChild(drag);\n            divDrag.className = dragHome.className;\n            drag.className = '';\n        } else {\n            // The drag item doesn't have an image, just clone it.\n            divDrag = <HTMLElement> dragHome.cloneNode(true);\n        }\n\n        // Set the right classes and styles.\n        divDrag.classList.remove(`dragitemhomes${dragItemNo}`);\n        divDrag.classList.remove('draghome');\n        divDrag.classList.add(`dragitems${dragItemNo}`);\n        divDrag.classList.add(`draginstance${dragInstanceNo}`);\n        divDrag.classList.add('drag');\n\n        divDrag.style.visibility = 'inherit';\n        divDrag.style.position = 'absolute';\n        divDrag.setAttribute('draginstanceno', String(dragInstanceNo));\n        divDrag.setAttribute('dragitemno', String(dragItemNo));\n        divDrag.setAttribute('tabindex', '0');\n\n        // Insert the new drag after the dragHome.\n        dragHome.parentElement?.insertBefore(divDrag, dragHome.nextSibling);\n\n        return divDrag;\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}