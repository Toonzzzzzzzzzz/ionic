{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { Subject } from 'rxjs';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle push notifications actions to perform when clicked and received.\n */\nexport class CorePushNotificationsDelegateService {\n  constructor() {\n    this.observables = {};\n    this.clickHandlers = {};\n    this.counterHandlers = {};\n    this.logger = CoreLogger.getInstance('CorePushNotificationsDelegate');\n    this.observables['receive'] = new Subject();\n  }\n  /**\n   * Function called when a push notification is clicked. Sends notification to handlers.\n   *\n   * @param notification Notification clicked.\n   * @returns Promise resolved when done.\n   */\n  clicked(notification) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _handlers$;\n      if (!notification) {\n        return;\n      }\n      let handlers = [];\n      const promises = Object.values(_this.clickHandlers).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (handler) {\n          // Check if the handler is disabled for the site.\n          const disabled = yield _this.isFeatureDisabled(handler, notification.site);\n          if (disabled) {\n            return;\n          }\n          // Check if the handler handles the notification.\n          const handles = yield handler.handles(notification);\n          if (handles) {\n            handlers.push(handler);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      yield CoreUtils.ignoreErrors(CoreUtils.allPromises(promises));\n      // Sort by priority.\n      handlers = handlers.sort((a, b) => (a.priority || 0) <= (b.priority || 0) ? 1 : -1);\n      // Execute the first one.\n      (_handlers$ = handlers[0]) === null || _handlers$ === void 0 || _handlers$.handleClick(notification);\n    })();\n  }\n  /**\n   * Check if a handler's feature is disabled for a certain site.\n   *\n   * @param handler Handler to check.\n   * @param siteId The site ID to check.\n   * @returns Promise resolved with boolean: whether the handler feature is disabled.\n   */\n  isFeatureDisabled(handler, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!siteId) {\n        // Notification doesn't belong to a site. Assume all handlers are enabled.\n        return false;\n      } else if (handler.featureName) {\n        // Check if the feature is disabled.\n        return CoreSites.isFeatureDisabled(handler.featureName, siteId);\n      } else {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Function called when a push notification is received in foreground (cannot tell when it's received in background).\n   * Sends notification to all handlers.\n   *\n   * @param notification Notification received.\n   */\n  received(notification) {\n    this.observables['receive'].next(notification);\n  }\n  /**\n   * Register a push notifications observable for a certain event. Right now, only receive is supported.\n   * let observer = pushNotificationsDelegate.on('receive').subscribe((notification) => {\n   * ...\n   * observer.unsuscribe();\n   *\n   * @param eventName Only receive is permitted.\n   * @returns Observer to subscribe.\n   */\n  on(eventName) {\n    if (this.observables[eventName] === undefined) {\n      const eventNames = Object.keys(this.observables).join(', ');\n      this.logger.warn(`'${eventName}' event name is not allowed. Use one of the following: '${eventNames}'.`);\n      return new Subject();\n    }\n    return this.observables[eventName];\n  }\n  /**\n   * Register a click handler.\n   *\n   * @param handler The handler to register.\n   * @returns True if registered successfully, false otherwise.\n   */\n  registerClickHandler(handler) {\n    if (this.clickHandlers[handler.name] !== undefined) {\n      this.logger.log(`Addon '${handler.name}' already registered`);\n      return false;\n    }\n    this.logger.log(`Registered addon '${handler.name}'`);\n    this.clickHandlers[handler.name] = handler;\n    handler.priority = handler.priority || 0;\n    return true;\n  }\n  /**\n   * Register a push notifications handler for update badge counter.\n   *\n   * @param name Handler's name.\n   */\n  registerCounterHandler(name) {\n    if (this.counterHandlers[name] === undefined) {\n      this.logger.debug(`Registered handler '${name}' as badge counter handler.`);\n      this.counterHandlers[name] = name;\n    } else {\n      this.logger.log(`Handler '${name}' as badge counter handler already registered.`);\n    }\n  }\n  /**\n   * Check if a counter handler is present.\n   *\n   * @param name Handler's name.\n   * @returns If handler name is present.\n   */\n  isCounterHandlerRegistered(name) {\n    return this.counterHandlers[name] !== undefined;\n  }\n  /**\n   * Get all counter badge handlers.\n   *\n   * @returns with all the handler names.\n   */\n  getCounterHandlers() {\n    return this.counterHandlers;\n  }\n}\n_class = CorePushNotificationsDelegateService;\n_class.ɵfac = function CorePushNotificationsDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CorePushNotificationsDelegate = makeSingleton(CorePushNotificationsDelegateService);","map":{"version":3,"names":["Subject","CoreSites","CoreUtils","makeSingleton","CoreLogger","CorePushNotificationsDelegateService","constructor","observables","clickHandlers","counterHandlers","logger","getInstance","clicked","notification","_this","_asyncToGenerator","_handlers$","handlers","promises","Object","values","map","_ref","handler","disabled","isFeatureDisabled","site","handles","push","_x","apply","arguments","ignoreErrors","allPromises","sort","a","b","priority","handleClick","siteId","featureName","received","next","on","eventName","undefined","eventNames","keys","join","warn","registerClickHandler","name","log","registerCounterHandler","debug","isCounterHandlerRegistered","getCounterHandlers","factory","ɵfac","providedIn","CorePushNotificationsDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/pushnotifications/services/push-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CorePushNotificationsNotificationBasicData } from './pushnotifications';\n\n/**\n * Interface that all click handlers must implement.\n */\nexport interface CorePushNotificationsClickHandler {\n    /**\n     * A name to identify the handler.\n     */\n    name: string;\n\n    /**\n     * Handler's priority. The highest priority is treated first.\n     */\n    priority?: number;\n\n    /**\n     * Name of the feature this handler is related to.\n     * It will be used to check if the feature is disabled (@see CoreSite.isFeatureDisabled).\n     */\n    featureName?: string;\n\n    /**\n     * Check if a notification click is handled by this handler.\n     *\n     * @param notification The notification to check.\n     * @returns Whether the notification click is handled by this handler.\n     */\n    handles(notification: CorePushNotificationsNotificationBasicData): Promise<boolean>;\n\n    /**\n     * Handle the notification click.\n     *\n     * @param notification The notification to check.\n     * @returns Promise resolved when done.\n     */\n    handleClick(notification: CorePushNotificationsNotificationBasicData): Promise<void>;\n}\n\n/**\n * Service to handle push notifications actions to perform when clicked and received.\n */\n@Injectable({ providedIn: 'root' })\nexport class CorePushNotificationsDelegateService {\n\n    protected logger: CoreLogger;\n    protected observables: { [s: string]: Subject<unknown> } = {};\n    protected clickHandlers: { [s: string]: CorePushNotificationsClickHandler } = {};\n    protected counterHandlers: Record<string, string> = {};\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CorePushNotificationsDelegate');\n        this.observables['receive'] = new Subject<CorePushNotificationsNotificationBasicData>();\n    }\n\n    /**\n     * Function called when a push notification is clicked. Sends notification to handlers.\n     *\n     * @param notification Notification clicked.\n     * @returns Promise resolved when done.\n     */\n    async clicked(notification: CorePushNotificationsNotificationBasicData): Promise<void> {\n        if (!notification) {\n            return;\n        }\n\n        let handlers: CorePushNotificationsClickHandler[] = [];\n\n        const promises = Object.values(this.clickHandlers).map(async (handler) => {\n            // Check if the handler is disabled for the site.\n            const disabled = await this.isFeatureDisabled(handler, notification.site);\n\n            if (disabled) {\n                return;\n            }\n\n            // Check if the handler handles the notification.\n            const handles = await handler.handles(notification);\n            if (handles) {\n                handlers.push(handler);\n            }\n        });\n\n        await CoreUtils.ignoreErrors(CoreUtils.allPromises(promises));\n\n        // Sort by priority.\n        handlers = handlers.sort((a, b) => (a.priority || 0) <= (b.priority || 0) ? 1 : -1);\n\n        // Execute the first one.\n        handlers[0]?.handleClick(notification);\n    }\n\n    /**\n     * Check if a handler's feature is disabled for a certain site.\n     *\n     * @param handler Handler to check.\n     * @param siteId The site ID to check.\n     * @returns Promise resolved with boolean: whether the handler feature is disabled.\n     */\n    protected async isFeatureDisabled(handler: CorePushNotificationsClickHandler, siteId?: string): Promise<boolean> {\n        if (!siteId) {\n            // Notification doesn't belong to a site. Assume all handlers are enabled.\n            return false;\n        } else if (handler.featureName) {\n            // Check if the feature is disabled.\n            return CoreSites.isFeatureDisabled(handler.featureName, siteId);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Function called when a push notification is received in foreground (cannot tell when it's received in background).\n     * Sends notification to all handlers.\n     *\n     * @param notification Notification received.\n     */\n    received(notification: CorePushNotificationsNotificationBasicData): void {\n        this.observables['receive'].next(notification);\n    }\n\n    /**\n     * Register a push notifications observable for a certain event. Right now, only receive is supported.\n     * let observer = pushNotificationsDelegate.on('receive').subscribe((notification) => {\n     * ...\n     * observer.unsuscribe();\n     *\n     * @param eventName Only receive is permitted.\n     * @returns Observer to subscribe.\n     */\n    on<T = CorePushNotificationsNotificationBasicData>(eventName: string): Subject<T> {\n        if (this.observables[eventName] === undefined) {\n            const eventNames = Object.keys(this.observables).join(', ');\n            this.logger.warn(`'${eventName}' event name is not allowed. Use one of the following: '${eventNames}'.`);\n\n            return new Subject<T>();\n        }\n\n        return <Subject<T>> this.observables[eventName];\n    }\n\n    /**\n     * Register a click handler.\n     *\n     * @param handler The handler to register.\n     * @returns True if registered successfully, false otherwise.\n     */\n    registerClickHandler(handler: CorePushNotificationsClickHandler): boolean {\n        if (this.clickHandlers[handler.name] !== undefined) {\n            this.logger.log(`Addon '${handler.name}' already registered`);\n\n            return false;\n        }\n\n        this.logger.log(`Registered addon '${handler.name}'`);\n        this.clickHandlers[handler.name] = handler;\n        handler.priority = handler.priority || 0;\n\n        return true;\n    }\n\n    /**\n     * Register a push notifications handler for update badge counter.\n     *\n     * @param name Handler's name.\n     */\n    registerCounterHandler(name: string): void {\n        if (this.counterHandlers[name] === undefined) {\n            this.logger.debug(`Registered handler '${name}' as badge counter handler.`);\n            this.counterHandlers[name] = name;\n        } else {\n            this.logger.log(`Handler '${name}' as badge counter handler already registered.`);\n        }\n    }\n\n    /**\n     * Check if a counter handler is present.\n     *\n     * @param name Handler's name.\n     * @returns If handler name is present.\n     */\n    isCounterHandlerRegistered(name: string): boolean {\n        return this.counterHandlers[name] !== undefined;\n    }\n\n    /**\n     * Get all counter badge handlers.\n     *\n     * @returns with all the handler names.\n     */\n    getCounterHandlers(): Record<string, string> {\n        return this.counterHandlers;\n    }\n\n}\n\nexport const CorePushNotificationsDelegate = makeSingleton(CorePushNotificationsDelegateService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}