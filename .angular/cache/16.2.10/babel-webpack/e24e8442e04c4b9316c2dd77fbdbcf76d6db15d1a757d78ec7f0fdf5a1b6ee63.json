{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreFilterHelper } from '@features/filter/services/filter-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreCourse } from '../services/course';\nimport { CoreCourseModulePrefetchHandlerBase } from './module-prefetch-handler';\n/**\n * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. It is useful to minimize the amount of\n * functions that handlers need to implement. It also provides some helper features like preventing a module to be\n * downloaded twice at the same time.\n *\n * If your handler inherits from this service, you just need to override the functions that you want to change.\n *\n * This class should be used for RESOURCES whose main purpose is downloading files present in module.contents.\n */\nexport class CoreCourseResourcePrefetchHandlerBase extends CoreCourseModulePrefetchHandlerBase {\n  /**\n   * Download the module.\n   *\n   * @param module The module object returned by WS.\n   * @param courseId Course ID.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @returns Promise resolved when all content is downloaded.\n   */\n  download(module, courseId, dirPath) {\n    return this.downloadOrPrefetch(module, courseId, false, dirPath);\n  }\n  /**\n   * Download or prefetch the content.\n   *\n   * @param module The module object returned by WS.\n   * @param courseId Course ID.\n   * @param prefetch True to prefetch, false to download right away.\n   * @param dirPath Path of the directory where to store all the content files. This is to keep the files\n   *                relative paths and make the package work in an iframe. Undefined to download the files\n   *                in the filepool root folder.\n   * @returns Promise resolved when all content is downloaded.\n   */\n  downloadOrPrefetch(module, courseId, prefetch, dirPath) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreNetwork.isOnline()) {\n        // Cannot download in offline.\n        throw new CoreNetworkError();\n      }\n      const siteId = CoreSites.getCurrentSiteId();\n      if (_this.isDownloading(module.id, siteId)) {\n        // There's already a download ongoing for this module, return the promise.\n        return _this.getOngoingDownload(module.id, siteId);\n      }\n      // Get module info to be able to handle links.\n      const prefetchPromise = _this.performDownloadOrPrefetch(siteId, module, courseId, !!prefetch, dirPath);\n      return _this.addOngoingDownload(module.id, prefetchPromise, siteId);\n    })();\n  }\n  /**\n   * Download or prefetch the content.\n   *\n   * @param siteId Site Id.\n   * @param module The module object returned by WS.\n   * @param courseId Course ID.\n   * @param prefetch True to prefetch, false to download right away.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @returns Promise resolved when all content is downloaded.\n   */\n  performDownloadOrPrefetch(siteId, module, courseId, prefetch, dirPath) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // Get module info to be able to handle links.\n      yield CoreCourse.getModuleBasicInfo(module.id, {\n        siteId\n      });\n      // Load module contents (ignore cache so we always have the latest data).\n      yield _this2.loadContents(module, courseId, true);\n      // Get the intro files.\n      const introFiles = yield _this2.getIntroFiles(module, courseId, true);\n      const contentFiles = _this2.getContentDownloadableFiles(module);\n      const promises = [];\n      if (dirPath) {\n        // Download intro files in filepool root folder.\n        promises.push(CoreFilepool.downloadOrPrefetchFiles(siteId, introFiles, prefetch, false, _this2.component, module.id));\n        // Download content files inside dirPath.\n        promises.push(CoreFilepool.downloadOrPrefetchPackage(siteId, contentFiles, prefetch, _this2.component, module.id, undefined, dirPath));\n      } else {\n        // No dirPath, download everything in filepool root folder.\n        promises.push(CoreFilepool.downloadOrPrefetchPackage(siteId, introFiles.concat(contentFiles), prefetch, _this2.component, module.id));\n      }\n      promises.push(CoreFilterHelper.getFilters('module', module.id, {\n        courseId\n      }));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Get list of files. If not defined, we'll assume they're in module.contents.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @returns Promise resolved with the list of files.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getFiles(module, courseId, single) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Load module contents if needed.\n      yield _this3.loadContents(module, courseId);\n      const files = yield _this3.getIntroFiles(module, courseId);\n      return files.concat(_this3.getContentDownloadableFiles(module));\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId The course ID the module belongs to.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  invalidateContent(moduleId, courseId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const siteId = CoreSites.getCurrentSiteId();\n      yield Promise.all([CoreCourse.invalidateModule(moduleId), CoreFilepool.invalidateFilesByComponent(siteId, _this4.component, moduleId)]);\n    })();\n  }\n  /**\n   * Load module contents into module.contents if they aren't loaded already.\n   *\n   * @param module Module to load the contents.\n   * @param courseId The course ID. Recommended to speed up the process and minimize data usage.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved when loaded.\n   */\n  loadContents(module, courseId, ignoreCache) {\n    return CoreCourse.loadModuleContents(module, courseId, undefined, false, ignoreCache);\n  }\n  /**\n   * Prefetch a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @returns Promise resolved when done.\n   */\n  prefetch(module, courseId, single, dirPath) {\n    return this.downloadOrPrefetch(module, courseId, true, dirPath);\n  }\n}","map":{"version":3,"names":["CoreNetworkError","CoreFilterHelper","CoreNetwork","CoreFilepool","CoreSites","CoreCourse","CoreCourseModulePrefetchHandlerBase","CoreCourseResourcePrefetchHandlerBase","download","module","courseId","dirPath","downloadOrPrefetch","prefetch","_this","_asyncToGenerator","isOnline","siteId","getCurrentSiteId","isDownloading","id","getOngoingDownload","prefetchPromise","performDownloadOrPrefetch","addOngoingDownload","_this2","getModuleBasicInfo","loadContents","introFiles","getIntroFiles","contentFiles","getContentDownloadableFiles","promises","push","downloadOrPrefetchFiles","component","downloadOrPrefetchPackage","undefined","concat","getFilters","Promise","all","getFiles","single","_this3","files","invalidateContent","moduleId","_this4","invalidateModule","invalidateFilesByComponent","ignoreCache","loadModuleContents"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/classes/resource-prefetch-handler.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreFilterHelper } from '@features/filter/services/filter-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreWSFile } from '@services/ws';\nimport { CoreCourse, CoreCourseAnyModuleData } from '../services/course';\nimport { CoreCourseModuleData } from '../services/course-helper';\nimport { CoreCourseModulePrefetchHandlerBase } from './module-prefetch-handler';\n\n/**\n * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. It is useful to minimize the amount of\n * functions that handlers need to implement. It also provides some helper features like preventing a module to be\n * downloaded twice at the same time.\n *\n * If your handler inherits from this service, you just need to override the functions that you want to change.\n *\n * This class should be used for RESOURCES whose main purpose is downloading files present in module.contents.\n */\nexport class CoreCourseResourcePrefetchHandlerBase extends CoreCourseModulePrefetchHandlerBase {\n\n    /**\n     * Download the module.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when all content is downloaded.\n     */\n    download(module: CoreCourseModuleData, courseId: number, dirPath?: string): Promise<void> {\n        return this.downloadOrPrefetch(module, courseId, false, dirPath);\n    }\n\n    /**\n     * Download or prefetch the content.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID.\n     * @param prefetch True to prefetch, false to download right away.\n     * @param dirPath Path of the directory where to store all the content files. This is to keep the files\n     *                relative paths and make the package work in an iframe. Undefined to download the files\n     *                in the filepool root folder.\n     * @returns Promise resolved when all content is downloaded.\n     */\n    async downloadOrPrefetch(module: CoreCourseModuleData, courseId: number, prefetch?: boolean, dirPath?: string): Promise<void> {\n        if (!CoreNetwork.isOnline()) {\n            // Cannot download in offline.\n            throw new CoreNetworkError();\n        }\n\n        const siteId = CoreSites.getCurrentSiteId();\n\n        if (this.isDownloading(module.id, siteId)) {\n            // There's already a download ongoing for this module, return the promise.\n            return this.getOngoingDownload(module.id, siteId);\n        }\n\n        // Get module info to be able to handle links.\n        const prefetchPromise = this.performDownloadOrPrefetch(siteId, module, courseId, !!prefetch, dirPath);\n\n        return this.addOngoingDownload(module.id, prefetchPromise, siteId);\n    }\n\n    /**\n     * Download or prefetch the content.\n     *\n     * @param siteId Site Id.\n     * @param module The module object returned by WS.\n     * @param courseId Course ID.\n     * @param prefetch True to prefetch, false to download right away.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when all content is downloaded.\n     */\n    protected async performDownloadOrPrefetch(\n        siteId: string,\n        module: CoreCourseModuleData,\n        courseId: number,\n        prefetch: boolean,\n        dirPath?: string,\n    ): Promise<void> {\n        // Get module info to be able to handle links.\n        await CoreCourse.getModuleBasicInfo(module.id, { siteId });\n\n        // Load module contents (ignore cache so we always have the latest data).\n        await this.loadContents(module, courseId, true);\n\n        // Get the intro files.\n        const introFiles = await this.getIntroFiles(module, courseId, true);\n\n        const contentFiles = this.getContentDownloadableFiles(module);\n        const promises: Promise<unknown>[] = [];\n\n        if (dirPath) {\n            // Download intro files in filepool root folder.\n            promises.push(\n                CoreFilepool.downloadOrPrefetchFiles(siteId, introFiles, prefetch, false, this.component, module.id),\n            );\n\n            // Download content files inside dirPath.\n            promises.push(CoreFilepool.downloadOrPrefetchPackage(\n                siteId,\n                contentFiles,\n                prefetch,\n                this.component,\n                module.id,\n                undefined,\n                dirPath,\n            ));\n        } else {\n            // No dirPath, download everything in filepool root folder.\n            promises.push(CoreFilepool.downloadOrPrefetchPackage(\n                siteId,\n                introFiles.concat(contentFiles),\n                prefetch,\n                this.component,\n                module.id,\n            ));\n        }\n\n        promises.push(CoreFilterHelper.getFilters('module', module.id, { courseId }));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Get list of files. If not defined, we'll assume they're in module.contents.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @returns Promise resolved with the list of files.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getFiles(module: CoreCourseModuleData, courseId: number, single?: boolean): Promise<CoreWSFile[]> {\n        // Load module contents if needed.\n        await this.loadContents(module, courseId);\n\n        const files = await this.getIntroFiles(module, courseId);\n\n        return files.concat(this.getContentDownloadableFiles(module));\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId The course ID the module belongs to.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        await Promise.all([\n            CoreCourse.invalidateModule(moduleId),\n            CoreFilepool.invalidateFilesByComponent(siteId, this.component, moduleId),\n        ]);\n    }\n\n    /**\n     * Load module contents into module.contents if they aren't loaded already.\n     *\n     * @param module Module to load the contents.\n     * @param courseId The course ID. Recommended to speed up the process and minimize data usage.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved when loaded.\n     */\n    loadContents(module: CoreCourseAnyModuleData, courseId: number, ignoreCache?: boolean): Promise<void> {\n        return CoreCourse.loadModuleContents(module, courseId, undefined, false, ignoreCache);\n    }\n\n    /**\n     * Prefetch a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when done.\n     */\n    prefetch(module: CoreCourseModuleData, courseId: number, single?: boolean, dirPath?: string): Promise<void> {\n        return this.downloadOrPrefetch(module, courseId, true, dirPath);\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}