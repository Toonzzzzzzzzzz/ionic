{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { makeSingleton } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport { ASSESSMENTS_TABLE, EVALUATE_ASSESSMENTS_TABLE, EVALUATE_SUBMISSIONS_TABLE, SUBMISSIONS_TABLE } from './database/workshop';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline workshop.\n */\nexport class AddonModWorkshopOfflineProvider {\n  /**\n   * Get all the workshops ids that have something to be synced.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with workshops id that have something to be synced.\n   */\n  getAllWorkshops(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const promiseResults = yield Promise.all([_this.getAllSubmissions(siteId), _this.getAllAssessments(siteId), _this.getAllEvaluateSubmissions(siteId), _this.getAllEvaluateAssessments(siteId)]);\n      const workshopIds = {};\n      // Get workshops from any offline object all should have workshopid.\n      promiseResults.forEach(offlineObjects => {\n        offlineObjects.forEach(offlineObject => {\n          workshopIds[offlineObject.workshopid] = offlineObject.workshopid;\n        });\n      });\n      return Object.values(workshopIds);\n    })();\n  }\n  /**\n   * Check if there is an offline data to be synced.\n   *\n   * @param workshopId Workshop ID to remove.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has offline data, false otherwise.\n   */\n  hasWorkshopOfflineData(workshopId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const results = yield Promise.all([_this2.getSubmissions(workshopId, siteId), _this2.getAssessments(workshopId, siteId), _this2.getEvaluateSubmissions(workshopId, siteId), _this2.getEvaluateAssessments(workshopId, siteId)]);\n        return results.some(result => result && result.length);\n      } catch (_unused) {\n        // No offline data found.\n        return false;\n      }\n    })();\n  }\n  /**\n   * Delete workshop submission action.\n   *\n   * @param workshopId Workshop ID.\n   * @param action Action to be done.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteSubmissionAction(workshopId, action, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId,\n        action: action\n      };\n      yield site.getDb().deleteRecords(SUBMISSIONS_TABLE, conditions);\n    })();\n  }\n  /**\n   * Delete all workshop submission actions.\n   *\n   * @param workshopId Workshop ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteAllSubmissionActions(workshopId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId\n      };\n      yield site.getDb().deleteRecords(SUBMISSIONS_TABLE, conditions);\n    })();\n  }\n  /**\n   * Get the all the submissions to be synced.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the objects to be synced.\n   */\n  getAllSubmissions(siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const records = yield site.getDb().getRecords(SUBMISSIONS_TABLE);\n      return records.map(record => _this3.parseSubmissionRecord(record));\n    })();\n  }\n  /**\n   * Get the submissions of a workshop to be synced.\n   *\n   * @param workshopId ID of the workshop.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getSubmissions(workshopId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId\n      };\n      const records = yield site.getDb().getRecords(SUBMISSIONS_TABLE, conditions);\n      return records.map(record => _this4.parseSubmissionRecord(record));\n    })();\n  }\n  /**\n   * Get an specific action of a submission of a workshop to be synced.\n   *\n   * @param workshopId ID of the workshop.\n   * @param action Action to be done.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getSubmissionAction(workshopId, action, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId,\n        action: action\n      };\n      const record = yield site.getDb().getRecord(SUBMISSIONS_TABLE, conditions);\n      return _this5.parseSubmissionRecord(record);\n    })();\n  }\n  /**\n   * Offline version for adding a submission action to a workshop.\n   *\n   * @param workshopId Workshop ID.\n   * @param courseId Course ID the workshop belongs to.\n   * @param title The submission title.\n   * @param content The submission text content.\n   * @param attachmentsId Stored attachments.\n   * @param submissionId Submission Id, if action is add, the time the submission was created.\n   *                     If set to 0, current time is used.\n   * @param action Action to be done. ['add', 'update', 'delete']\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when submission action is successfully saved.\n   */\n  saveSubmission(workshopId, courseId, title, content, attachmentsId, submissionId = 0, action, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const timemodified = CoreTimeUtils.timestamp();\n      const submission = {\n        workshopid: workshopId,\n        courseid: courseId,\n        title: title,\n        content: content,\n        attachmentsid: JSON.stringify(attachmentsId),\n        action: action,\n        submissionid: submissionId,\n        timemodified: timemodified\n      };\n      yield site.getDb().insertRecord(SUBMISSIONS_TABLE, submission);\n    })();\n  }\n  /**\n   * Parse \"attachments\" column of a submission record.\n   *\n   * @param record Submission record, modified in place.\n   * @returns The offline submission parsed.\n   */\n  parseSubmissionRecord(record) {\n    return _objectSpread(_objectSpread({}, record), {}, {\n      attachmentsid: CoreTextUtils.parseJSON(record.attachmentsid)\n    });\n  }\n  /**\n   * Delete workshop assessment.\n   *\n   * @param workshopId Workshop ID.\n   * @param assessmentId Assessment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteAssessment(workshopId, assessmentId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId,\n        assessmentid: assessmentId\n      };\n      yield site.getDb().deleteRecords(ASSESSMENTS_TABLE, conditions);\n    })();\n  }\n  /**\n   * Get the all the assessments to be synced.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the objects to be synced.\n   */\n  getAllAssessments(siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const records = yield site.getDb().getRecords(ASSESSMENTS_TABLE);\n      return records.map(record => _this6.parseAssessmentRecord(record));\n    })();\n  }\n  /**\n   * Get the assessments of a workshop to be synced.\n   *\n   * @param workshopId ID of the workshop.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getAssessments(workshopId, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId\n      };\n      const records = yield site.getDb().getRecords(ASSESSMENTS_TABLE, conditions);\n      return records.map(record => _this7.parseAssessmentRecord(record));\n    })();\n  }\n  /**\n   * Get an specific assessment of a workshop to be synced.\n   *\n   * @param workshopId ID of the workshop.\n   * @param assessmentId Assessment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getAssessment(workshopId, assessmentId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId,\n        assessmentid: assessmentId\n      };\n      const record = yield site.getDb().getRecord(ASSESSMENTS_TABLE, conditions);\n      return _this8.parseAssessmentRecord(record);\n    })();\n  }\n  /**\n   * Offline version for adding an assessment to a workshop.\n   *\n   * @param workshopId Workshop ID.\n   * @param assessmentId Assessment ID.\n   * @param courseId Course ID the workshop belongs to.\n   * @param inputData Assessment data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when assessment is successfully saved.\n   */\n  saveAssessment(workshopId, assessmentId, courseId, inputData, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const assessment = {\n        workshopid: workshopId,\n        courseid: courseId,\n        inputdata: JSON.stringify(inputData),\n        assessmentid: assessmentId,\n        timemodified: CoreTimeUtils.timestamp()\n      };\n      yield site.getDb().insertRecord(ASSESSMENTS_TABLE, assessment);\n    })();\n  }\n  /**\n   * Parse \"inpudata\" column of an assessment record.\n   *\n   * @param record Assessnent record, modified in place.\n   * @returns The offline assessment parsed.\n   */\n  parseAssessmentRecord(record) {\n    return _objectSpread(_objectSpread({}, record), {}, {\n      inputdata: CoreTextUtils.parseJSON(record.inputdata)\n    });\n  }\n  /**\n   * Delete workshop evaluate submission.\n   *\n   * @param workshopId Workshop ID.\n   * @param submissionId Submission ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteEvaluateSubmission(workshopId, submissionId, siteId) {\n    return _asyncToGenerator(function* () {\n      const conditions = {\n        workshopid: workshopId,\n        submissionid: submissionId\n      };\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(EVALUATE_SUBMISSIONS_TABLE, conditions);\n    })();\n  }\n  /**\n   * Get the all the evaluate submissions to be synced.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the objects to be synced.\n   */\n  getAllEvaluateSubmissions(siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const records = yield site.getDb().getRecords(EVALUATE_SUBMISSIONS_TABLE);\n      return records.map(record => _this9.parseEvaluateSubmissionRecord(record));\n    })();\n  }\n  /**\n   * Get the evaluate submissions of a workshop to be synced.\n   *\n   * @param workshopId ID of the workshop.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getEvaluateSubmissions(workshopId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId\n      };\n      const records = yield site.getDb().getRecords(EVALUATE_SUBMISSIONS_TABLE, conditions);\n      return records.map(record => _this10.parseEvaluateSubmissionRecord(record));\n    })();\n  }\n  /**\n   * Get an specific evaluate submission of a workshop to be synced.\n   *\n   * @param workshopId ID of the workshop.\n   * @param submissionId Submission ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getEvaluateSubmission(workshopId, submissionId, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId,\n        submissionid: submissionId\n      };\n      const record = yield site.getDb().getRecord(EVALUATE_SUBMISSIONS_TABLE, conditions);\n      return _this11.parseEvaluateSubmissionRecord(record);\n    })();\n  }\n  /**\n   * Offline version for evaluation a submission to a workshop.\n   *\n   * @param workshopId Workshop ID.\n   * @param submissionId Submission ID.\n   * @param courseId Course ID the workshop belongs to.\n   * @param feedbackText The feedback for the author.\n   * @param published Whether to publish the submission for other users.\n   * @param gradeOver The new submission grade (empty for no overriding the grade).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when submission evaluation is successfully saved.\n   */\n  saveEvaluateSubmission(workshopId, submissionId, courseId, feedbackText = '', published, gradeOver, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const submission = {\n        workshopid: workshopId,\n        courseid: courseId,\n        submissionid: submissionId,\n        timemodified: CoreTimeUtils.timestamp(),\n        feedbacktext: feedbackText,\n        published: Number(published),\n        gradeover: JSON.stringify(gradeOver)\n      };\n      yield site.getDb().insertRecord(EVALUATE_SUBMISSIONS_TABLE, submission);\n    })();\n  }\n  /**\n   * Parse \"published\" and \"gradeover\" columns of an evaluate submission record.\n   *\n   * @param record Evaluate submission record, modified in place.\n   * @returns The offline evaluate submission parsed.\n   */\n  parseEvaluateSubmissionRecord(record) {\n    return _objectSpread(_objectSpread({}, record), {}, {\n      published: Boolean(record.published),\n      gradeover: CoreTextUtils.parseJSON(record.gradeover)\n    });\n  }\n  /**\n   * Delete workshop evaluate assessment.\n   *\n   * @param workshopId Workshop ID.\n   * @param assessmentId Assessment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteEvaluateAssessment(workshopId, assessmentId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId,\n        assessmentid: assessmentId\n      };\n      yield site.getDb().deleteRecords(EVALUATE_ASSESSMENTS_TABLE, conditions);\n    })();\n  }\n  /**\n   * Get the all the evaluate assessments to be synced.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the objects to be synced.\n   */\n  getAllEvaluateAssessments(siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const records = yield site.getDb().getRecords(EVALUATE_ASSESSMENTS_TABLE);\n      return records.map(record => _this12.parseEvaluateAssessmentRecord(record));\n    })();\n  }\n  /**\n   * Get the evaluate assessments of a workshop to be synced.\n   *\n   * @param workshopId ID of the workshop.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getEvaluateAssessments(workshopId, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId\n      };\n      const records = yield site.getDb().getRecords(EVALUATE_ASSESSMENTS_TABLE, conditions);\n      return records.map(record => _this13.parseEvaluateAssessmentRecord(record));\n    })();\n  }\n  /**\n   * Get an specific evaluate assessment of a workshop to be synced.\n   *\n   * @param workshopId ID of the workshop.\n   * @param assessmentId Assessment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getEvaluateAssessment(workshopId, assessmentId, siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        workshopid: workshopId,\n        assessmentid: assessmentId\n      };\n      const record = yield site.getDb().getRecord(EVALUATE_ASSESSMENTS_TABLE, conditions);\n      return _this14.parseEvaluateAssessmentRecord(record);\n    })();\n  }\n  /**\n   * Offline version for evaluating an assessment to a workshop.\n   *\n   * @param workshopId Workshop ID.\n   * @param assessmentId Assessment ID.\n   * @param courseId Course ID the workshop belongs to.\n   * @param feedbackText The feedback for the reviewer.\n   * @param weight The new weight for the assessment.\n   * @param gradingGradeOver The new grading grade (empty for no overriding the grade).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when assessment evaluation is successfully saved.\n   */\n  saveEvaluateAssessment(workshopId, assessmentId, courseId, feedbackText, weight = 0, gradingGradeOver, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const assessment = {\n        workshopid: workshopId,\n        courseid: courseId,\n        assessmentid: assessmentId,\n        timemodified: CoreTimeUtils.timestamp(),\n        feedbacktext: feedbackText || '',\n        weight: weight,\n        gradinggradeover: JSON.stringify(gradingGradeOver)\n      };\n      yield site.getDb().insertRecord(EVALUATE_ASSESSMENTS_TABLE, assessment);\n    })();\n  }\n  /**\n   * Parse \"gradinggradeover\" column of an evaluate assessment record.\n   *\n   * @param record Evaluate assessment record, modified in place.\n   * @returns The offline evaluate assessment parsed.\n   */\n  parseEvaluateAssessmentRecord(record) {\n    return _objectSpread(_objectSpread({}, record), {}, {\n      gradinggradeover: CoreTextUtils.parseJSON(record.gradinggradeover)\n    });\n  }\n  /**\n   * Get the path to the folder where to store files for offline attachments in a workshop.\n   *\n   * @param workshopId Workshop ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getWorkshopFolder(workshopId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const siteFolderPath = CoreFile.getSiteFolder(site.getId());\n      const workshopFolderPath = 'offlineworkshop/' + workshopId + '/';\n      return CorePath.concatenatePaths(siteFolderPath, workshopFolderPath);\n    })();\n  }\n  /**\n   * Get the path to the folder where to store files for offline submissions.\n   *\n   * @param workshopId Workshop ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getSubmissionFolder(workshopId, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const folderPath = yield _this15.getWorkshopFolder(workshopId, siteId);\n      return CorePath.concatenatePaths(folderPath, 'submission');\n    })();\n  }\n  /**\n   * Get the path to the folder where to store files for offline assessment.\n   *\n   * @param workshopId Workshop ID.\n   * @param assessmentId Assessment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getAssessmentFolder(workshopId, assessmentId, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      let folderPath = yield _this16.getWorkshopFolder(workshopId, siteId);\n      folderPath += 'assessment/';\n      return CorePath.concatenatePaths(folderPath, String(assessmentId));\n    })();\n  }\n}\n_class = AddonModWorkshopOfflineProvider;\n_class.ɵfac = function AddonModWorkshopOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModWorkshopOffline = makeSingleton(AddonModWorkshopOfflineProvider);","map":{"version":3,"names":["CoreFile","CoreSites","CoreTextUtils","CoreTimeUtils","makeSingleton","CorePath","ASSESSMENTS_TABLE","EVALUATE_ASSESSMENTS_TABLE","EVALUATE_SUBMISSIONS_TABLE","SUBMISSIONS_TABLE","AddonModWorkshopOfflineProvider","getAllWorkshops","siteId","_this","_asyncToGenerator","promiseResults","Promise","all","getAllSubmissions","getAllAssessments","getAllEvaluateSubmissions","getAllEvaluateAssessments","workshopIds","forEach","offlineObjects","offlineObject","workshopid","Object","values","hasWorkshopOfflineData","workshopId","_this2","results","getSubmissions","getAssessments","getEvaluateSubmissions","getEvaluateAssessments","some","result","length","_unused","deleteSubmissionAction","action","site","getSite","conditions","getDb","deleteRecords","deleteAllSubmissionActions","_this3","records","getRecords","map","record","parseSubmissionRecord","_this4","getSubmissionAction","_this5","getRecord","saveSubmission","courseId","title","content","attachmentsId","submissionId","timemodified","timestamp","submission","courseid","attachmentsid","JSON","stringify","submissionid","insertRecord","_objectSpread","parseJSON","deleteAssessment","assessmentId","assessmentid","_this6","parseAssessmentRecord","_this7","getAssessment","_this8","saveAssessment","inputData","assessment","inputdata","deleteEvaluateSubmission","_this9","parseEvaluateSubmissionRecord","_this10","getEvaluateSubmission","_this11","saveEvaluateSubmission","feedbackText","published","gradeOver","feedbacktext","Number","gradeover","Boolean","deleteEvaluateAssessment","_this12","parseEvaluateAssessmentRecord","_this13","getEvaluateAssessment","_this14","saveEvaluateAssessment","weight","gradingGradeOver","gradinggradeover","getWorkshopFolder","siteFolderPath","getSiteFolder","getId","workshopFolderPath","concatenatePaths","getSubmissionFolder","_this15","folderPath","getAssessmentFolder","_this16","String","factory","ɵfac","providedIn","AddonModWorkshopOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/workshop/services/workshop-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreFileUploaderStoreFilesResult } from '@features/fileuploader/services/fileuploader';\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { makeSingleton } from '@singletons';\nimport { CoreFormFields } from '@singletons/form';\nimport { CorePath } from '@singletons/path';\nimport {\n    AddonModWorkshopAssessmentDBRecord,\n    AddonModWorkshopEvaluateAssessmentDBRecord,\n    AddonModWorkshopEvaluateSubmissionDBRecord,\n    AddonModWorkshopSubmissionDBRecord,\n    ASSESSMENTS_TABLE,\n    EVALUATE_ASSESSMENTS_TABLE,\n    EVALUATE_SUBMISSIONS_TABLE,\n    SUBMISSIONS_TABLE,\n} from './database/workshop';\nimport { AddonModWorkshopAction } from './workshop';\n\n/**\n * Service to handle offline workshop.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModWorkshopOfflineProvider {\n\n    /**\n     * Get all the workshops ids that have something to be synced.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with workshops id that have something to be synced.\n     */\n    async getAllWorkshops(siteId?: string): Promise<number[]> {\n        const promiseResults = await Promise.all([\n            this.getAllSubmissions(siteId),\n            this.getAllAssessments(siteId),\n            this.getAllEvaluateSubmissions(siteId),\n            this.getAllEvaluateAssessments(siteId),\n        ]);\n\n        const workshopIds: Record<number, number> = {};\n\n        // Get workshops from any offline object all should have workshopid.\n        promiseResults.forEach((offlineObjects) => {\n            offlineObjects.forEach((offlineObject: AddonModWorkshopOfflineSubmission | AddonModWorkshopOfflineAssessment |\n            AddonModWorkshopOfflineEvaluateSubmission | AddonModWorkshopOfflineEvaluateAssessment) => {\n                workshopIds[offlineObject.workshopid] = offlineObject.workshopid;\n            });\n        });\n\n        return Object.values(workshopIds);\n    }\n\n    /**\n     * Check if there is an offline data to be synced.\n     *\n     * @param workshopId Workshop ID to remove.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has offline data, false otherwise.\n     */\n    async hasWorkshopOfflineData(workshopId: number, siteId?: string): Promise<boolean> {\n        try {\n            const results = await Promise.all([\n                this.getSubmissions(workshopId, siteId),\n                this.getAssessments(workshopId, siteId),\n                this.getEvaluateSubmissions(workshopId, siteId),\n                this.getEvaluateAssessments(workshopId, siteId),\n            ]);\n\n            return results.some((result) => result && result.length);\n        } catch {\n            // No offline data found.\n            return false;\n        }\n    }\n\n    /**\n     * Delete workshop submission action.\n     *\n     * @param workshopId Workshop ID.\n     * @param action Action to be done.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteSubmissionAction(\n        workshopId: number,\n        action: AddonModWorkshopAction,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopSubmissionDBRecord> = {\n            workshopid: workshopId,\n            action: action,\n        };\n\n        await site.getDb().deleteRecords(SUBMISSIONS_TABLE, conditions);\n    }\n\n    /**\n     * Delete all workshop submission actions.\n     *\n     * @param workshopId Workshop ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteAllSubmissionActions(workshopId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopSubmissionDBRecord> = {\n            workshopid: workshopId,\n        };\n\n        await site.getDb().deleteRecords(SUBMISSIONS_TABLE, conditions);\n    }\n\n    /**\n     * Get the all the submissions to be synced.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the objects to be synced.\n     */\n    async getAllSubmissions(siteId?: string): Promise<AddonModWorkshopOfflineSubmission[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const records = await site.getDb().getRecords<AddonModWorkshopSubmissionDBRecord>(SUBMISSIONS_TABLE);\n\n        return records.map((record) => this.parseSubmissionRecord(record));\n    }\n\n    /**\n     * Get the submissions of a workshop to be synced.\n     *\n     * @param workshopId ID of the workshop.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getSubmissions(workshopId: number, siteId?: string): Promise<AddonModWorkshopOfflineSubmission[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopSubmissionDBRecord> = {\n            workshopid: workshopId,\n        };\n\n        const records = await site.getDb().getRecords<AddonModWorkshopSubmissionDBRecord>(SUBMISSIONS_TABLE, conditions);\n\n        return records.map((record) => this.parseSubmissionRecord(record));\n    }\n\n    /**\n     * Get an specific action of a submission of a workshop to be synced.\n     *\n     * @param workshopId ID of the workshop.\n     * @param action Action to be done.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getSubmissionAction(\n        workshopId: number,\n        action: AddonModWorkshopAction,\n        siteId?: string,\n    ): Promise<AddonModWorkshopOfflineSubmission> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopSubmissionDBRecord> = {\n            workshopid: workshopId,\n            action: action,\n        };\n\n        const record = await site.getDb().getRecord<AddonModWorkshopSubmissionDBRecord>(SUBMISSIONS_TABLE, conditions);\n\n        return this.parseSubmissionRecord(record);\n    }\n\n    /**\n     * Offline version for adding a submission action to a workshop.\n     *\n     * @param workshopId Workshop ID.\n     * @param courseId Course ID the workshop belongs to.\n     * @param title The submission title.\n     * @param content The submission text content.\n     * @param attachmentsId Stored attachments.\n     * @param submissionId Submission Id, if action is add, the time the submission was created.\n     *                     If set to 0, current time is used.\n     * @param action Action to be done. ['add', 'update', 'delete']\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when submission action is successfully saved.\n     */\n    async saveSubmission(\n        workshopId: number,\n        courseId: number,\n        title: string,\n        content: string,\n        attachmentsId: CoreFileUploaderStoreFilesResult | undefined,\n        submissionId = 0,\n        action: AddonModWorkshopAction,\n        siteId?: string,\n    ): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const timemodified = CoreTimeUtils.timestamp();\n\n        const submission: AddonModWorkshopSubmissionDBRecord = {\n            workshopid: workshopId,\n            courseid: courseId,\n            title: title,\n            content: content,\n            attachmentsid: JSON.stringify(attachmentsId),\n            action: action,\n            submissionid: submissionId,\n            timemodified: timemodified,\n        };\n\n        await site.getDb().insertRecord(SUBMISSIONS_TABLE, submission);\n    }\n\n    /**\n     * Parse \"attachments\" column of a submission record.\n     *\n     * @param record Submission record, modified in place.\n     * @returns The offline submission parsed.\n     */\n    protected parseSubmissionRecord(record: AddonModWorkshopSubmissionDBRecord): AddonModWorkshopOfflineSubmission {\n        return {\n            ...record,\n            attachmentsid: CoreTextUtils.parseJSON(record.attachmentsid),\n        };\n    }\n\n    /**\n     * Delete workshop assessment.\n     *\n     * @param workshopId Workshop ID.\n     * @param assessmentId Assessment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteAssessment(workshopId: number, assessmentId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopAssessmentDBRecord> = {\n            workshopid: workshopId,\n            assessmentid: assessmentId,\n        };\n\n        await site.getDb().deleteRecords(ASSESSMENTS_TABLE, conditions);\n    }\n\n    /**\n     * Get the all the assessments to be synced.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the objects to be synced.\n     */\n    async getAllAssessments(siteId?: string): Promise<AddonModWorkshopOfflineAssessment[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const records = await site.getDb().getRecords<AddonModWorkshopAssessmentDBRecord>(ASSESSMENTS_TABLE);\n\n        return records.map((record) => this.parseAssessmentRecord(record));\n    }\n\n    /**\n     * Get the assessments of a workshop to be synced.\n     *\n     * @param workshopId ID of the workshop.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getAssessments(workshopId: number, siteId?: string): Promise<AddonModWorkshopOfflineAssessment[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopAssessmentDBRecord> = {\n            workshopid: workshopId,\n        };\n\n        const records = await site.getDb().getRecords<AddonModWorkshopAssessmentDBRecord>(ASSESSMENTS_TABLE, conditions);\n\n        return records.map((record) => this.parseAssessmentRecord(record));\n    }\n\n    /**\n     * Get an specific assessment of a workshop to be synced.\n     *\n     * @param workshopId ID of the workshop.\n     * @param assessmentId Assessment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getAssessment(workshopId: number, assessmentId: number, siteId?: string): Promise<AddonModWorkshopOfflineAssessment> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopAssessmentDBRecord> = {\n            workshopid: workshopId,\n            assessmentid: assessmentId,\n        };\n\n        const record = await site.getDb().getRecord<AddonModWorkshopAssessmentDBRecord>(ASSESSMENTS_TABLE, conditions);\n\n        return this.parseAssessmentRecord(record);\n    }\n\n    /**\n     * Offline version for adding an assessment to a workshop.\n     *\n     * @param workshopId Workshop ID.\n     * @param assessmentId Assessment ID.\n     * @param courseId Course ID the workshop belongs to.\n     * @param inputData Assessment data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when assessment is successfully saved.\n     */\n    async saveAssessment(\n        workshopId: number,\n        assessmentId: number,\n        courseId: number,\n        inputData: CoreFormFields,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const assessment: AddonModWorkshopAssessmentDBRecord = {\n            workshopid: workshopId,\n            courseid: courseId,\n            inputdata: JSON.stringify(inputData),\n            assessmentid: assessmentId,\n            timemodified: CoreTimeUtils.timestamp(),\n        };\n\n        await site.getDb().insertRecord(ASSESSMENTS_TABLE, assessment);\n    }\n\n    /**\n     * Parse \"inpudata\" column of an assessment record.\n     *\n     * @param record Assessnent record, modified in place.\n     * @returns The offline assessment parsed.\n     */\n    protected parseAssessmentRecord(record: AddonModWorkshopAssessmentDBRecord): AddonModWorkshopOfflineAssessment {\n        return {\n            ...record,\n            inputdata: CoreTextUtils.parseJSON(record.inputdata),\n        };\n    }\n\n    /**\n     * Delete workshop evaluate submission.\n     *\n     * @param workshopId Workshop ID.\n     * @param submissionId Submission ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteEvaluateSubmission(workshopId: number, submissionId: number, siteId?: string): Promise<void> {\n        const conditions: Partial<AddonModWorkshopEvaluateSubmissionDBRecord> = {\n            workshopid: workshopId,\n            submissionid: submissionId,\n        };\n\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(EVALUATE_SUBMISSIONS_TABLE, conditions);\n    }\n\n    /**\n     * Get the all the evaluate submissions to be synced.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the objects to be synced.\n     */\n    async getAllEvaluateSubmissions(siteId?: string): Promise<AddonModWorkshopOfflineEvaluateSubmission[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const records = await site.getDb().getRecords<AddonModWorkshopEvaluateSubmissionDBRecord>(EVALUATE_SUBMISSIONS_TABLE);\n\n        return records.map((record) => this.parseEvaluateSubmissionRecord(record));\n    }\n\n    /**\n     * Get the evaluate submissions of a workshop to be synced.\n     *\n     * @param workshopId ID of the workshop.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getEvaluateSubmissions(workshopId: number, siteId?: string): Promise<AddonModWorkshopOfflineEvaluateSubmission[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopEvaluateSubmissionDBRecord> = {\n            workshopid: workshopId,\n        };\n\n        const records =\n            await site.getDb().getRecords<AddonModWorkshopEvaluateSubmissionDBRecord>(EVALUATE_SUBMISSIONS_TABLE, conditions);\n\n        return records.map((record) => this.parseEvaluateSubmissionRecord(record));\n    }\n\n    /**\n     * Get an specific evaluate submission of a workshop to be synced.\n     *\n     * @param workshopId ID of the workshop.\n     * @param submissionId Submission ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getEvaluateSubmission(\n        workshopId: number,\n        submissionId: number,\n        siteId?: string,\n    ): Promise<AddonModWorkshopOfflineEvaluateSubmission> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopEvaluateSubmissionDBRecord> = {\n            workshopid: workshopId,\n            submissionid: submissionId,\n        };\n\n        const record =\n            await site.getDb().getRecord<AddonModWorkshopEvaluateSubmissionDBRecord>(EVALUATE_SUBMISSIONS_TABLE, conditions);\n\n        return this.parseEvaluateSubmissionRecord(record);\n    }\n\n    /**\n     * Offline version for evaluation a submission to a workshop.\n     *\n     * @param workshopId Workshop ID.\n     * @param submissionId Submission ID.\n     * @param courseId Course ID the workshop belongs to.\n     * @param feedbackText The feedback for the author.\n     * @param published Whether to publish the submission for other users.\n     * @param gradeOver The new submission grade (empty for no overriding the grade).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when submission evaluation is successfully saved.\n     */\n    async saveEvaluateSubmission(\n        workshopId: number,\n        submissionId: number,\n        courseId: number,\n        feedbackText = '',\n        published?: boolean,\n        gradeOver?: string,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const submission: AddonModWorkshopEvaluateSubmissionDBRecord = {\n            workshopid: workshopId,\n            courseid: courseId,\n            submissionid: submissionId,\n            timemodified: CoreTimeUtils.timestamp(),\n            feedbacktext: feedbackText,\n            published: Number(published),\n            gradeover: JSON.stringify(gradeOver),\n        };\n\n        await site.getDb().insertRecord(EVALUATE_SUBMISSIONS_TABLE, submission);\n    }\n\n    /**\n     * Parse \"published\" and \"gradeover\" columns of an evaluate submission record.\n     *\n     * @param record Evaluate submission record, modified in place.\n     * @returns The offline evaluate submission parsed.\n     */\n    protected parseEvaluateSubmissionRecord(\n        record: AddonModWorkshopEvaluateSubmissionDBRecord,\n    ): AddonModWorkshopOfflineEvaluateSubmission {\n        return {\n            ...record,\n            published: Boolean(record.published),\n            gradeover: CoreTextUtils.parseJSON(record.gradeover),\n        };\n    }\n\n    /**\n     * Delete workshop evaluate assessment.\n     *\n     * @param workshopId Workshop ID.\n     * @param assessmentId Assessment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteEvaluateAssessment(workshopId: number, assessmentId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopEvaluateAssessmentDBRecord> = {\n            workshopid: workshopId,\n            assessmentid: assessmentId,\n        };\n\n        await site.getDb().deleteRecords(EVALUATE_ASSESSMENTS_TABLE, conditions);\n    }\n\n    /**\n     * Get the all the evaluate assessments to be synced.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the objects to be synced.\n     */\n    async getAllEvaluateAssessments(siteId?: string): Promise<AddonModWorkshopOfflineEvaluateAssessment[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const records = await site.getDb().getRecords<AddonModWorkshopEvaluateAssessmentDBRecord>(EVALUATE_ASSESSMENTS_TABLE);\n\n        return records.map((record) => this.parseEvaluateAssessmentRecord(record));\n    }\n\n    /**\n     * Get the evaluate assessments of a workshop to be synced.\n     *\n     * @param workshopId ID of the workshop.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getEvaluateAssessments(workshopId: number, siteId?: string): Promise<AddonModWorkshopOfflineEvaluateAssessment[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopEvaluateAssessmentDBRecord> = {\n            workshopid: workshopId,\n        };\n\n        const records =\n            await site.getDb().getRecords<AddonModWorkshopEvaluateAssessmentDBRecord>(EVALUATE_ASSESSMENTS_TABLE, conditions);\n\n        return records.map((record) => this.parseEvaluateAssessmentRecord(record));\n    }\n\n    /**\n     * Get an specific evaluate assessment of a workshop to be synced.\n     *\n     * @param workshopId ID of the workshop.\n     * @param assessmentId Assessment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getEvaluateAssessment(\n        workshopId: number,\n        assessmentId: number,\n        siteId?: string,\n    ): Promise<AddonModWorkshopOfflineEvaluateAssessment> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModWorkshopEvaluateAssessmentDBRecord> = {\n            workshopid: workshopId,\n            assessmentid: assessmentId,\n        };\n\n        const record =\n            await site.getDb().getRecord<AddonModWorkshopEvaluateAssessmentDBRecord>(EVALUATE_ASSESSMENTS_TABLE, conditions);\n\n        return this.parseEvaluateAssessmentRecord(record);\n    }\n\n    /**\n     * Offline version for evaluating an assessment to a workshop.\n     *\n     * @param workshopId Workshop ID.\n     * @param assessmentId Assessment ID.\n     * @param courseId Course ID the workshop belongs to.\n     * @param feedbackText The feedback for the reviewer.\n     * @param weight The new weight for the assessment.\n     * @param gradingGradeOver The new grading grade (empty for no overriding the grade).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when assessment evaluation is successfully saved.\n     */\n    async saveEvaluateAssessment(\n        workshopId: number,\n        assessmentId: number,\n        courseId: number,\n        feedbackText?: string,\n        weight = 0,\n        gradingGradeOver?: string,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const assessment: AddonModWorkshopEvaluateAssessmentDBRecord = {\n            workshopid: workshopId,\n            courseid: courseId,\n            assessmentid: assessmentId,\n            timemodified: CoreTimeUtils.timestamp(),\n            feedbacktext: feedbackText || '',\n            weight: weight,\n            gradinggradeover: JSON.stringify(gradingGradeOver),\n        };\n\n        await site.getDb().insertRecord(EVALUATE_ASSESSMENTS_TABLE, assessment);\n    }\n\n    /**\n     * Parse \"gradinggradeover\" column of an evaluate assessment record.\n     *\n     * @param record Evaluate assessment record, modified in place.\n     * @returns The offline evaluate assessment parsed.\n     */\n    protected parseEvaluateAssessmentRecord(\n        record: AddonModWorkshopEvaluateAssessmentDBRecord,\n    ): AddonModWorkshopOfflineEvaluateAssessment {\n        return {\n            ...record,\n            gradinggradeover: CoreTextUtils.parseJSON(record.gradinggradeover),\n        };\n    }\n\n    /**\n     * Get the path to the folder where to store files for offline attachments in a workshop.\n     *\n     * @param workshopId Workshop ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    async getWorkshopFolder(workshopId: number, siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n\n        const siteFolderPath = CoreFile.getSiteFolder(site.getId());\n        const workshopFolderPath = 'offlineworkshop/' + workshopId + '/';\n\n        return CorePath.concatenatePaths(siteFolderPath, workshopFolderPath);\n    }\n\n    /**\n     * Get the path to the folder where to store files for offline submissions.\n     *\n     * @param workshopId Workshop ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    async getSubmissionFolder(workshopId: number, siteId?: string): Promise<string> {\n        const folderPath = await this.getWorkshopFolder(workshopId, siteId);\n\n        return CorePath.concatenatePaths(folderPath, 'submission');\n    }\n\n    /**\n     * Get the path to the folder where to store files for offline assessment.\n     *\n     * @param workshopId Workshop ID.\n     * @param assessmentId Assessment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    async getAssessmentFolder(workshopId: number, assessmentId: number, siteId?: string): Promise<string> {\n        let folderPath = await this.getWorkshopFolder(workshopId, siteId);\n\n        folderPath += 'assessment/';\n\n        return CorePath.concatenatePaths(folderPath, String(assessmentId));\n    }\n\n}\nexport const AddonModWorkshopOffline = makeSingleton(AddonModWorkshopOfflineProvider);\n\nexport type AddonModWorkshopOfflineSubmission = Omit<AddonModWorkshopSubmissionDBRecord, 'attachmentsid'> & {\n    attachmentsid?: CoreFileUploaderStoreFilesResult;\n};\n\nexport type AddonModWorkshopOfflineAssessment = Omit<AddonModWorkshopAssessmentDBRecord, 'inputdata'> & {\n    inputdata: CoreFormFields;\n};\n\nexport type AddonModWorkshopOfflineEvaluateSubmission =\n    Omit<AddonModWorkshopEvaluateSubmissionDBRecord, 'published' | 'gradeover'> & {\n        published: boolean;\n        gradeover: string;\n    };\n\nexport type AddonModWorkshopOfflineEvaluateAssessment =\n    Omit<AddonModWorkshopEvaluateAssessmentDBRecord, 'gradinggradeover'> & {\n        gradinggradeover: string;\n    };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}