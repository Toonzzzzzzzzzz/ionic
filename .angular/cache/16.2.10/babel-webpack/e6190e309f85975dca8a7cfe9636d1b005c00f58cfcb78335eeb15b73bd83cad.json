{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModFeedbackOffline } from './feedback-offline';\nimport { AddonModFeedbackSyncProvider } from './feedback-sync';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'AddonModFeedback:';\n/**\n * Service that provides some features for feedbacks.\n */\nexport class AddonModFeedbackProvider {\n  /**\n   * Check dependency of a question item.\n   *\n   * @param items All question items to check dependency.\n   * @param item Item to check.\n   * @returns Return true if dependency is acomplished and it can be shown. False, otherwise.\n   */\n  checkDependencyItem(items, item) {\n    const depend = items.find(itemFind => itemFind.id == item.dependitem);\n    // Item not found, looks like dependent item has been removed or is in the same or following pages.\n    if (!depend) {\n      return true;\n    }\n    switch (depend.typ) {\n      case 'label':\n        return false;\n      case 'multichoice':\n      case 'multichoicerated':\n        return this.compareDependItemMultichoice(depend, item.dependvalue);\n      default:\n        break;\n    }\n    return item.dependvalue == depend.rawValue;\n  }\n  /**\n   * Check dependency item of type Multichoice.\n   *\n   * @param item Item to check.\n   * @param dependValue Value to compare.\n   * @returns Return true if dependency is acomplished and it can be shown. False, otherwise.\n   */\n  compareDependItemMultichoice(item, dependValue) {\n    const parts = item.presentation.split(AddonModFeedbackProvider.MULTICHOICE_TYPE_SEP) || [];\n    const subtype = parts.length > 0 && parts[0] ? parts[0] : 'r';\n    const choicesStr = (parts[1] || '').split(AddonModFeedbackProvider.MULTICHOICE_ADJUST_SEP)[0] || '';\n    const choices = choicesStr.split(AddonModFeedbackProvider.LINE_SEP) || [];\n    let values;\n    if (subtype === 'c') {\n      if (item.rawValue === undefined) {\n        values = [''];\n      } else {\n        item.rawValue = '' + item.rawValue;\n        values = item.rawValue.split(AddonModFeedbackProvider.LINE_SEP);\n      }\n    } else {\n      values = [item.rawValue || ''];\n    }\n    for (let index = 0; index < choices.length; index++) {\n      for (const x in values) {\n        if (values[x] == index + 1) {\n          let value = choices[index];\n          if (item.typ == 'multichoicerated') {\n            value = value.split(AddonModFeedbackProvider.MULTICHOICERATED_VALUE_SEP)[1] || '';\n          }\n          if (value.trim() == dependValue) {\n            return true;\n          }\n          // We can finish checking if only searching on one value and we found it.\n          if (values.length == 1) {\n            return false;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Fill values of item questions.\n   *\n   * @param feedbackId Feedback ID.\n   * @param items Item to fill the value.\n   * @param options Other options.\n   * @returns Resolved with values when done.\n   */\n  fillValues(feedbackId, items, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const filledItems = items;\n      try {\n        const valuesArray = yield _this.getCurrentValues(feedbackId, options);\n        const values = {};\n        valuesArray.forEach(value => {\n          values[value.item] = value.value;\n        });\n        filledItems.forEach(itemData => {\n          if (itemData.hasvalue && values[itemData.id] !== undefined) {\n            itemData.rawValue = values[itemData.id];\n          }\n        });\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      // Merge with offline data.\n      const offlineResponses = yield CoreUtils.ignoreErrors(AddonModFeedbackOffline.getFeedbackResponses(feedbackId, options.siteId));\n      if (!offlineResponses) {\n        return items;\n      }\n      const offlineValues = {};\n      // Merge all values into one array.\n      const offlineValuesArray = offlineResponses.reduce((array, entry) => {\n        const responses = CoreUtils.objectToArrayOfObjects(entry.responses, 'id', 'value');\n        return array.concat(responses);\n      }, []).map(valueEntry => {\n        const parts = valueEntry.id.split('_');\n        const item = (parts[1] || '').replace(/\\[.*\\]/, ''); // Remove [0] and similar.\n        return _objectSpread(_objectSpread({}, valueEntry), {}, {\n          typ: parts[0],\n          item: Number(item)\n        });\n      });\n      offlineValuesArray.forEach(value => {\n        if (offlineValues[value.item] === undefined) {\n          offlineValues[value.item] = [];\n        }\n        offlineValues[value.item].push(value.value);\n      });\n      filledItems.forEach(item => {\n        if (!item.hasvalue || offlineValues[item.id] === undefined) {\n          return;\n        }\n        // Treat multichoice checkboxes.\n        if (item.typ === 'multichoice' && item.presentation.split(AddonModFeedbackProvider.MULTICHOICE_TYPE_SEP)[0] === 'c') {\n          offlineValues[item.id] = offlineValues[item.id].filter(value => Number(value) > 0);\n          item.rawValue = offlineValues[item.id].join(AddonModFeedbackProvider.LINE_SEP);\n        } else {\n          item.rawValue = offlineValues[item.id][0];\n        }\n      });\n      return filledItems;\n    })();\n  }\n  /**\n   * Returns all the feedback non respondents users.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @param previous Only for recurrent use. Object with the previous fetched info.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getAllNonRespondents(feedbackId, options = {}, previous) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      previous = previous || {\n        page: 0,\n        users: []\n      };\n      const response = yield _this2.getNonRespondents(feedbackId, _objectSpread({\n        page: previous.page\n      }, options));\n      if (previous.users.length < response.total) {\n        previous.users = previous.users.concat(response.users);\n      }\n      if (previous.users.length < response.total) {\n        // Can load more.\n        previous.page++;\n        return _this2.getAllNonRespondents(feedbackId, options, previous);\n      }\n      return _objectSpread(_objectSpread({}, previous), {}, {\n        total: response.total\n      });\n    })();\n  }\n  /**\n   * Returns all the feedback user responses.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @param previous Only for recurrent use. Object with the previous fetched info.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getAllResponsesAnalysis(feedbackId, options = {}, previous) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      previous = previous || {\n        page: 0,\n        attempts: [],\n        anonattempts: []\n      };\n      const responses = yield _this3.getResponsesAnalysis(feedbackId, _objectSpread({\n        page: previous.page\n      }, options));\n      if (previous.anonattempts.length < responses.totalanonattempts) {\n        previous.anonattempts = previous.anonattempts.concat(responses.anonattempts);\n      }\n      if (previous.attempts.length < responses.totalattempts) {\n        previous.attempts = previous.attempts.concat(responses.attempts);\n      }\n      if (previous.anonattempts.length < responses.totalanonattempts || previous.attempts.length < responses.totalattempts) {\n        // Can load more.\n        previous.page++;\n        return _this3.getAllResponsesAnalysis(feedbackId, options, previous);\n      }\n      return _objectSpread(_objectSpread({}, previous), {}, {\n        totalattempts: responses.totalattempts,\n        totalanonattempts: responses.totalanonattempts\n      });\n    })();\n  }\n  /**\n   * Get analysis information for a given feedback.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the feedback is retrieved.\n   */\n  getAnalysis(feedbackId, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this4.getAnalysisDataCacheKey(feedbackId, options.groupId),\n        component: AddonModFeedbackProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      if (options.groupId) {\n        params.groupid = options.groupId;\n      }\n      return site.read('mod_feedback_get_analysis', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for feedback analysis data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @param groupId Group ID.\n   * @returns Cache key.\n   */\n  getAnalysisDataCacheKey(feedbackId, groupId = 0) {\n    return this.getAnalysisDataPrefixCacheKey(feedbackId) + groupId;\n  }\n  /**\n   * Get prefix cache key for feedback analysis data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getAnalysisDataPrefixCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':analysis:';\n  }\n  /**\n   * Find an attempt in all responses analysis.\n   *\n   * @param feedbackId Feedback ID.\n   * @param attemptId Attempt ID to find.\n   * @param options Other options.\n   * @param previous Only for recurrent use. Object with the previous fetched info.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getAttempt(feedbackId, attemptId, options = {}, previous) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      previous = previous || {\n        page: 0,\n        attemptsLoaded: 0,\n        anonAttemptsLoaded: 0\n      };\n      const responses = yield _this5.getResponsesAnalysis(feedbackId, _objectSpread({\n        page: previous.page\n      }, options));\n      const attempt = responses.attempts.find(attempt => attemptId == attempt.id);\n      if (attempt) {\n        return attempt;\n      }\n      const anonAttempt = responses.anonattempts.find(attempt => attemptId == attempt.id);\n      if (anonAttempt) {\n        return anonAttempt;\n      }\n      if (previous.anonAttemptsLoaded < responses.totalanonattempts) {\n        previous.anonAttemptsLoaded += responses.anonattempts.length;\n      }\n      if (previous.attemptsLoaded < responses.totalattempts) {\n        previous.attemptsLoaded += responses.attempts.length;\n      }\n      if (previous.anonAttemptsLoaded < responses.totalanonattempts || previous.attemptsLoaded < responses.totalattempts) {\n        // Can load more. Check there.\n        previous.page++;\n        return _this5.getAttempt(feedbackId, attemptId, options, previous);\n      }\n      // Not found and all loaded. Reject.\n      throw new CoreError('Attempt not found.');\n    })();\n  }\n  /**\n   * Get prefix cache key for feedback completion data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getCompletedDataCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':completed:';\n  }\n  /**\n   * Returns the temporary completion timemodified for the current user.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getCurrentCompletedTimeModified(feedbackId, options = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this6.getCurrentCompletedTimeModifiedDataCacheKey(feedbackId),\n        component: AddonModFeedbackProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      try {\n        const response = yield site.read('mod_feedback_get_current_completed_tmp', params, preSets);\n        return response.feedback.timemodified;\n      } catch (_unused2) {\n        // Ignore errors.\n        return 0;\n      }\n    })();\n  }\n  /**\n   * Get prefix cache key for feedback current completed temp data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getCurrentCompletedTimeModifiedDataCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':completedtime:';\n  }\n  /**\n   * Returns the temporary responses or responses of the last submission for the current user.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getCurrentValues(feedbackId, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this7.getCurrentValuesDataCacheKey(feedbackId),\n        component: AddonModFeedbackProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_feedback_get_unfinished_responses', params, preSets);\n      if (response.responses.length) {\n        return response.responses;\n      }\n      // No unfinished responses, fetch responses of the last submission.\n      const finishedResponse = yield site.read('mod_feedback_get_finished_responses', params, preSets);\n      return finishedResponse.responses;\n    })();\n  }\n  /**\n   * Get cache key for get current values feedback data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getCurrentValuesDataCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':currentvalues';\n  }\n  /**\n   * Get access information for a given feedback.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the feedback is retrieved.\n   */\n  getFeedbackAccessInformation(feedbackId, options = {}) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this8.getFeedbackAccessInformationDataCacheKey(feedbackId),\n        component: AddonModFeedbackProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_feedback_get_feedback_access_information', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for feedback access information data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getFeedbackAccessInformationDataCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':access';\n  }\n  /**\n   * Get cache key for feedback data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getFeedbackCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'feedback:' + courseId;\n  }\n  /**\n   * Get prefix cache key for all feedback activity data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getFeedbackDataPrefixCacheKey(feedbackId) {\n    return ROOT_CACHE_KEY + feedbackId;\n  }\n  /**\n   * Get a feedback with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the feedback is retrieved.\n   */\n  getFeedbackDataByKey(courseId, key, value, options = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this9.getFeedbackCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModFeedbackProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_feedback_get_feedbacks_by_courses', params, preSets);\n      const currentFeedback = response.feedbacks.find(feedback => feedback[key] == value);\n      if (currentFeedback) {\n        return currentFeedback;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get a feedback by course module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the feedback is retrieved.\n   */\n  getFeedback(courseId, cmId, options = {}) {\n    return this.getFeedbackDataByKey(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a feedback by ID.\n   *\n   * @param courseId Course ID.\n   * @param id Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the feedback is retrieved.\n   */\n  getFeedbackById(courseId, id, options = {}) {\n    return this.getFeedbackDataByKey(courseId, 'id', id, options);\n  }\n  /**\n   * Returns the items (questions) in the given feedback.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getItems(feedbackId, options = {}) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this10.getItemsDataCacheKey(feedbackId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModFeedbackProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_feedback_get_items', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for get items feedback data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getItemsDataCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':items';\n  }\n  /**\n   * Retrieves a list of students who didn't submit the feedback.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getNonRespondents(feedbackId, options = {}) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      options.groupId = options.groupId || 0;\n      options.page = options.page || 0;\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId,\n        groupid: options.groupId,\n        page: options.page,\n        perpage: AddonModFeedbackProvider.PER_PAGE\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this11.getNonRespondentsDataCacheKey(feedbackId, options.groupId),\n        component: AddonModFeedbackProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_feedback_get_non_respondents', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for non respondents feedback data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @param groupId Group id, 0 means that the function will determine the user group.\n   * @returns Cache key.\n   */\n  getNonRespondentsDataCacheKey(feedbackId, groupId = 0) {\n    return this.getNonRespondentsDataPrefixCacheKey(feedbackId) + groupId;\n  }\n  /**\n   * Get prefix cache key for feedback non respondents data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getNonRespondentsDataPrefixCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':nonrespondents:';\n  }\n  /**\n   * Get a single feedback page items. This function is not cached, use AddonModFeedbackHelperProvider#getPageItems instead.\n   *\n   * @param feedbackId Feedback ID.\n   * @param page The page to get.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getPageItems(feedbackId, page, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        feedbackid: feedbackId,\n        page: page\n      };\n      return site.write('mod_feedback_get_page_items', params);\n    })();\n  }\n  /**\n   * Get a single feedback page items. If offline or server down it will use getItems to calculate dependencies.\n   *\n   * @param feedbackId Feedback ID.\n   * @param page The page to get.\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getPageItemsWithValues(feedbackId, page, options = {}) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      try {\n        const response = yield _this12.getPageItems(feedbackId, page, options.siteId);\n        response.items = yield _this12.fillValues(feedbackId, response.items, options);\n        return response;\n      } catch (_unused3) {\n        // If getPageItems fail we should calculate it using getItems.\n        const response = yield _this12.getItems(feedbackId, options);\n        const items = yield _this12.fillValues(feedbackId, response.items, options);\n        // Separate items by pages.\n        let currentPage = 0;\n        const previousPageItems = [];\n        const pageItems = items.filter(item => {\n          // Greater page, discard all entries.\n          if (currentPage > page) {\n            return false;\n          }\n          if (item.typ == 'pagebreak') {\n            currentPage++;\n            return false;\n          }\n          // Save items on previous page to check dependencies and discard entry.\n          if (currentPage < page) {\n            previousPageItems.push(item);\n            return false;\n          }\n          // Filter depending items.\n          if (item && item.dependitem > 0 && previousPageItems.length > 0) {\n            return _this12.checkDependencyItem(previousPageItems, item);\n          }\n          // Filter items with errors.\n          return item;\n        });\n        return {\n          items: pageItems,\n          hasprevpage: page > 0,\n          hasnextpage: currentPage > page,\n          warnings: response.warnings\n        };\n      }\n    })();\n  }\n  /**\n   * Convenience function to get the page we can jump.\n   *\n   * @param feedbackId Feedback ID.\n   * @param page Page where we want to jump.\n   * @param changePage If page change is forward (1) or backward (-1).\n   * @param options Other options.\n   * @returns Page number where to jump. Or false if completed or first page.\n   */\n  getPageJumpTo(feedbackId, page, changePage, options) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const response = yield _this13.getPageItemsWithValues(feedbackId, page, {\n        cmId: options.cmId,\n        readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n        siteId: options.siteId\n      });\n      // The page we are going has items.\n      if (response.items.length > 0) {\n        return page;\n      }\n      // Check we can jump futher.\n      if (changePage == 1 && response.hasnextpage || changePage == -1 && response.hasprevpage) {\n        return _this13.getPageJumpTo(feedbackId, page + changePage, changePage, options);\n      }\n      // Completed or first page.\n      return false;\n    })();\n  }\n  /**\n   * Returns the feedback user responses.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getResponsesAnalysis(feedbackId, options = {}) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      options.groupId = options.groupId || 0;\n      options.page = options.page || 0;\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId,\n        groupid: options.groupId,\n        page: options.page,\n        perpage: AddonModFeedbackProvider.PER_PAGE\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this14.getResponsesAnalysisDataCacheKey(feedbackId, options.groupId),\n        component: AddonModFeedbackProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_feedback_get_responses_analysis', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for responses analysis feedback data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @param groupId Group id, 0 means that the function will determine the user group.\n   * @returns Cache key.\n   */\n  getResponsesAnalysisDataCacheKey(feedbackId, groupId = 0) {\n    return this.getResponsesAnalysisDataPrefixCacheKey(feedbackId) + groupId;\n  }\n  /**\n   * Get prefix cache key for feedback responses analysis data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getResponsesAnalysisDataPrefixCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':responsesanalysis:';\n  }\n  /**\n   * Gets the resume page information.\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getResumePage(feedbackId, options = {}) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this15.getResumePageDataCacheKey(feedbackId),\n        component: AddonModFeedbackProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_feedback_launch_feedback', params, preSets);\n      // WS will return -1 for last page but the user need to start again.\n      return response.gopage > 0 ? response.gopage : 0;\n    })();\n  }\n  /**\n   * Get prefix cache key for resume feedback page data WS calls.\n   *\n   * @param feedbackId Feedback ID.\n   * @returns Cache key.\n   */\n  getResumePageDataCacheKey(feedbackId) {\n    return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':launch';\n  }\n  /**\n   * Invalidates feedback data except files and module info.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllFeedbackData(feedbackId, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this16.getFeedbackDataPrefixCacheKey(feedbackId));\n    })();\n  }\n  /**\n   * Invalidates feedback analysis data.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAnalysisData(feedbackId, siteId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.invalidateWsCacheForKeyStartingWith(_this17.getAnalysisDataPrefixCacheKey(feedbackId));\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   * To invalidate files, use AddonModFeedbackProvider#invalidateFiles.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID of the module.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const feedback = yield _this18.getFeedback(courseId, moduleId, {\n        siteId\n      });\n      yield Promise.all([_this18.invalidateFeedbackData(courseId, siteId), _this18.invalidateAllFeedbackData(feedback.id, siteId)]);\n    })();\n  }\n  /**\n   * Invalidates temporary completion record data.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCurrentValuesData(feedbackId, siteId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.invalidateWsCacheForKey(_this19.getCurrentValuesDataCacheKey(feedbackId));\n    })();\n  }\n  /**\n   * Invalidates feedback access information data.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateFeedbackAccessInformationData(feedbackId, siteId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.invalidateWsCacheForKey(_this20.getFeedbackAccessInformationDataCacheKey(feedbackId));\n    })();\n  }\n  /**\n   * Invalidates feedback data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateFeedbackData(courseId, siteId) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.invalidateWsCacheForKey(_this21.getFeedbackCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidate the prefetched files.\n   *\n   * @param moduleId The module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the files are invalidated.\n   */\n  invalidateFiles(moduleId, siteId) {\n    return _asyncToGenerator(function* () {\n      return CoreFilepool.invalidateFilesByComponent(siteId, AddonModFeedbackProvider.COMPONENT, moduleId);\n    })();\n  }\n  /**\n   * Invalidates feedback non respondents record data.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateNonRespondentsData(feedbackId, siteId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this22.getNonRespondentsDataPrefixCacheKey(feedbackId));\n    })();\n  }\n  /**\n   * Invalidates feedback user responses record data.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateResponsesAnalysisData(feedbackId, siteId) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this23.getResponsesAnalysisDataPrefixCacheKey(feedbackId));\n    })();\n  }\n  /**\n   * Invalidates launch feedback data.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateResumePageData(feedbackId, siteId) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this24.getResumePageDataCacheKey(feedbackId));\n    })();\n  }\n  /**\n   * Returns if feedback has been completed\n   *\n   * @param feedbackId Feedback ID.\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  isCompleted(feedbackId, options = {}) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        feedbackid: feedbackId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this25.getCompletedDataCacheKey(feedbackId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModFeedbackProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return CoreUtils.promiseWorks(site.read('mod_feedback_get_last_completed', params, preSets));\n    })();\n  }\n  /**\n   * Report the feedback as being viewed.\n   *\n   * @param id Module ID.\n   * @param formViewed True if form was viewed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(id, formViewed = false, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        feedbackid: id,\n        moduleviewed: formViewed\n      };\n      yield CoreCourseLogHelper.log('mod_feedback_view_feedback', params, AddonModFeedbackProvider.COMPONENT, id, siteId);\n    })();\n  }\n  /**\n   * Process a jump between pages.\n   *\n   * @param feedbackId Feedback ID.\n   * @param page The page being processed.\n   * @param responses The data to be processed the key is the field name (usually type[index]_id).\n   * @param options Other options.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  processPage(feedbackId, page, responses, options = {}) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a message to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          yield AddonModFeedbackOffline.saveResponses(feedbackId, page, responses, options.courseId, options.siteId);\n          // Simulate process_page response.\n          const response = {\n            jumpto: page,\n            completed: false,\n            offline: true\n          };\n          let changePage = 0;\n          if (options.goPrevious) {\n            if (page > 0) {\n              changePage = -1;\n            }\n          } else if (!options.formHasErrors) {\n            // We can only go next if it has no errors.\n            changePage = 1;\n          }\n          if (changePage === 0) {\n            return response;\n          }\n          const pageItems = yield _this26.getPageItemsWithValues(feedbackId, page, {\n            cmId: options.cmId,\n            readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n            siteId: options.siteId\n          });\n          // Check completion.\n          if (changePage == 1 && !pageItems.hasnextpage) {\n            response.completed = true;\n            return response;\n          }\n          const loadPage = yield _this26.getPageJumpTo(feedbackId, page + changePage, changePage, options);\n          if (loadPage === false) {\n            // Completed or first page.\n            if (changePage == -1) {\n              response.jumpto = 0;\n            } else {\n              response.completed = true;\n            }\n          } else {\n            response.jumpto = loadPage;\n          }\n          return response;\n        });\n        return function storeOffline() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      // If there's already a response to be sent to the server, discard it first.\n      yield AddonModFeedbackOffline.deleteFeedbackPageResponses(feedbackId, page, options.siteId);\n      try {\n        return yield _this26.processPageOnline(feedbackId, page, responses, !!options.goPrevious, options.siteId);\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that responses cannot be submitted.\n          throw error;\n        }\n        // Couldn't connect to server, store in offline.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Process a jump between pages.\n   *\n   * @param feedbackId Feedback ID.\n   * @param page The page being processed.\n   * @param responses The data to be processed the key is the field name (usually type[index]_id).\n   * @param goPrevious Whether we want to jump to previous page.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  processPageOnline(feedbackId, page, responses, goPrevious, siteId) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        feedbackid: feedbackId,\n        page: page,\n        responses: CoreUtils.objectToArrayOfObjects(responses, 'name', 'value'),\n        goprevious: goPrevious\n      };\n      const response = yield site.write('mod_feedback_process_page', params);\n      // Invalidate and update current values because they will change.\n      yield CoreUtils.ignoreErrors(_this27.invalidateCurrentValuesData(feedbackId, site.getId()));\n      yield CoreUtils.ignoreErrors(_this27.getCurrentValues(feedbackId, {\n        siteId: site.getId()\n      }));\n      return response;\n    })();\n  }\n}\n_class = AddonModFeedbackProvider;\n_class.COMPONENT = 'mmaModFeedback';\n_class.FORM_SUBMITTED = 'addon_mod_feedback_form_submitted';\n_class.LINE_SEP = '|';\n_class.MULTICHOICE_TYPE_SEP = '>>>>>';\n_class.MULTICHOICE_ADJUST_SEP = '<<<<<';\n_class.MULTICHOICE_HIDENOSELECT = 'h';\n_class.MULTICHOICERATED_VALUE_SEP = '####';\n_class.PER_PAGE = 20;\n_class.ɵfac = function AddonModFeedbackProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModFeedback = makeSingleton(AddonModFeedbackProvider);","map":{"version":3,"names":["CoreError","CoreSite","CoreCourseLogHelper","CoreNetwork","CoreFilepool","CoreSites","CoreSitesReadingStrategy","CoreUtils","makeSingleton","Translate","AddonModFeedbackOffline","AddonModFeedbackSyncProvider","ROOT_CACHE_KEY","AddonModFeedbackProvider","checkDependencyItem","items","item","depend","find","itemFind","id","dependitem","typ","compareDependItemMultichoice","dependvalue","rawValue","dependValue","parts","presentation","split","MULTICHOICE_TYPE_SEP","subtype","length","choicesStr","MULTICHOICE_ADJUST_SEP","choices","LINE_SEP","values","undefined","index","x","value","MULTICHOICERATED_VALUE_SEP","trim","fillValues","feedbackId","options","_this","_asyncToGenerator","filledItems","valuesArray","getCurrentValues","forEach","itemData","hasvalue","_unused","offlineResponses","ignoreErrors","getFeedbackResponses","siteId","offlineValues","offlineValuesArray","reduce","array","entry","responses","objectToArrayOfObjects","concat","map","valueEntry","replace","_objectSpread","Number","push","filter","join","getAllNonRespondents","previous","_this2","getCurrentSiteId","page","users","response","getNonRespondents","total","getAllResponsesAnalysis","_this3","attempts","anonattempts","getResponsesAnalysis","totalanonattempts","totalattempts","getAnalysis","_this4","site","getSite","params","feedbackid","preSets","cacheKey","getAnalysisDataCacheKey","groupId","component","COMPONENT","componentId","cmId","getReadingStrategyPreSets","readingStrategy","groupid","read","getAnalysisDataPrefixCacheKey","getFeedbackDataPrefixCacheKey","getAttempt","attemptId","_this5","attemptsLoaded","anonAttemptsLoaded","attempt","anonAttempt","getCompletedDataCacheKey","getCurrentCompletedTimeModified","_this6","getCurrentCompletedTimeModifiedDataCacheKey","feedback","timemodified","_unused2","_this7","getCurrentValuesDataCacheKey","finishedResponse","getFeedbackAccessInformation","_this8","getFeedbackAccessInformationDataCacheKey","getFeedbackCacheKey","courseId","getFeedbackDataByKey","key","_this9","courseids","updateFrequency","FREQUENCY_RARELY","currentFeedback","feedbacks","instant","getFeedback","getFeedbackById","getItems","_this10","getItemsDataCacheKey","FREQUENCY_SOMETIMES","_this11","perpage","PER_PAGE","getNonRespondentsDataCacheKey","getNonRespondentsDataPrefixCacheKey","getPageItems","write","getPageItemsWithValues","_this12","_unused3","currentPage","previousPageItems","pageItems","hasprevpage","hasnextpage","warnings","getPageJumpTo","changePage","_this13","_this14","getResponsesAnalysisDataCacheKey","getResponsesAnalysisDataPrefixCacheKey","getResumePage","_this15","getResumePageDataCacheKey","gopage","invalidateAllFeedbackData","_this16","invalidateWsCacheForKeyStartingWith","invalidateAnalysisData","_this17","invalidateContent","moduleId","_this18","Promise","all","invalidateFeedbackData","invalidateCurrentValuesData","_this19","invalidateWsCacheForKey","invalidateFeedbackAccessInformationData","_this20","_this21","invalidateFiles","invalidateFilesByComponent","invalidateNonRespondentsData","_this22","invalidateResponsesAnalysisData","_this23","invalidateResumePageData","_this24","isCompleted","_this25","promiseWorks","logView","formViewed","moduleviewed","log","processPage","_this26","storeOffline","_ref","saveResponses","jumpto","completed","offline","goPrevious","formHasErrors","loadPage","apply","arguments","isOnline","deleteFeedbackPageResponses","processPageOnline","error","isWebServiceError","_this27","goprevious","getId","_class","FORM_SUBMITTED","MULTICHOICE_HIDENOSELECT","factory","ɵfac","providedIn","AddonModFeedback"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/feedback/services/feedback.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile, CoreWSExternalWarning, CoreWSStoredFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModFeedbackOffline } from './feedback-offline';\nimport { AddonModFeedbackAutoSyncData, AddonModFeedbackSyncProvider } from './feedback-sync';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'AddonModFeedback:';\n\n/**\n * Service that provides some features for feedbacks.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModFeedbackProvider {\n\n    static readonly COMPONENT = 'mmaModFeedback';\n    static readonly FORM_SUBMITTED = 'addon_mod_feedback_form_submitted';\n    static readonly LINE_SEP = '|';\n    static readonly MULTICHOICE_TYPE_SEP = '>>>>>';\n    static readonly MULTICHOICE_ADJUST_SEP = '<<<<<';\n    static readonly MULTICHOICE_HIDENOSELECT = 'h';\n    static readonly MULTICHOICERATED_VALUE_SEP = '####';\n    static readonly PER_PAGE = 20;\n\n    /**\n     * Check dependency of a question item.\n     *\n     * @param items All question items to check dependency.\n     * @param item Item to check.\n     * @returns Return true if dependency is acomplished and it can be shown. False, otherwise.\n     */\n    protected checkDependencyItem(items: AddonModFeedbackItem[], item: AddonModFeedbackItem): boolean {\n        const depend = items.find((itemFind) => itemFind.id == item.dependitem);\n\n        // Item not found, looks like dependent item has been removed or is in the same or following pages.\n        if (!depend) {\n            return true;\n        }\n\n        switch (depend.typ) {\n            case 'label':\n                return false;\n            case 'multichoice':\n            case 'multichoicerated':\n                return this.compareDependItemMultichoice(depend, item.dependvalue);\n            default:\n                break;\n        }\n\n        return item.dependvalue == depend.rawValue;\n    }\n\n    /**\n     * Check dependency item of type Multichoice.\n     *\n     * @param item Item to check.\n     * @param dependValue Value to compare.\n     * @returns Return true if dependency is acomplished and it can be shown. False, otherwise.\n     */\n    protected compareDependItemMultichoice(item: AddonModFeedbackItem, dependValue: string): boolean {\n        const parts = item.presentation.split(AddonModFeedbackProvider.MULTICHOICE_TYPE_SEP) || [];\n        const subtype = parts.length > 0 && parts[0] ? parts[0] : 'r';\n\n        const choicesStr = (parts[1] || '').split(AddonModFeedbackProvider.MULTICHOICE_ADJUST_SEP)[0] || '';\n        const choices = choicesStr.split(AddonModFeedbackProvider.LINE_SEP) || [];\n        let values: AddonModFeedbackResponseValue[];\n\n        if (subtype === 'c') {\n            if (item.rawValue === undefined) {\n                values = [''];\n            } else {\n                item.rawValue = '' + item.rawValue;\n                values = item.rawValue.split(AddonModFeedbackProvider.LINE_SEP);\n            }\n        } else {\n            values = [item.rawValue || ''];\n        }\n\n        for (let index = 0; index < choices.length; index++) {\n            for (const x in values) {\n                if (values[x] == index + 1) {\n                    let value = choices[index];\n\n                    if (item.typ == 'multichoicerated') {\n                        value = value.split(AddonModFeedbackProvider.MULTICHOICERATED_VALUE_SEP)[1] || '';\n                    }\n\n                    if (value.trim() == dependValue) {\n                        return true;\n                    }\n\n                    // We can finish checking if only searching on one value and we found it.\n                    if (values.length == 1) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Fill values of item questions.\n     *\n     * @param feedbackId Feedback ID.\n     * @param items Item to fill the value.\n     * @param options Other options.\n     * @returns Resolved with values when done.\n     */\n    protected async fillValues(\n        feedbackId: number,\n        items: AddonModFeedbackWSItem[],\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModFeedbackItem[]> {\n        const filledItems = <AddonModFeedbackItem[]> items;\n\n        try {\n            const valuesArray = await this.getCurrentValues(feedbackId, options);\n\n            const values: Record<number, string> = {};\n\n            valuesArray.forEach((value) => {\n                values[value.item] = value.value;\n            });\n\n            filledItems.forEach((itemData) => {\n                if (itemData.hasvalue && values[itemData.id] !== undefined) {\n                    itemData.rawValue = values[itemData.id];\n                }\n            });\n        } catch {\n            // Ignore errors.\n        }\n\n        // Merge with offline data.\n        const offlineResponses = await CoreUtils.ignoreErrors(\n            AddonModFeedbackOffline.getFeedbackResponses(feedbackId, options.siteId),\n        );\n\n        if (!offlineResponses) {\n            return items;\n        }\n\n        const offlineValues: Record<number, AddonModFeedbackResponseValue[]> = {};\n\n        // Merge all values into one array.\n        const offlineValuesArray = offlineResponses.reduce((array, entry) => {\n            const responses = <OfflineResponsesArray> CoreUtils.objectToArrayOfObjects(entry.responses, 'id', 'value');\n\n            return array.concat(responses);\n        }, <OfflineResponsesArray> []).map((valueEntry) => {\n            const parts = valueEntry.id.split('_');\n            const item = (parts[1] || '').replace(/\\[.*\\]/, ''); // Remove [0] and similar.\n\n            return {\n                ...valueEntry,\n                typ: parts[0],\n                item: Number(item),\n            };\n        });\n\n        offlineValuesArray.forEach((value) => {\n            if (offlineValues[value.item] === undefined) {\n                offlineValues[value.item] = [];\n            }\n            offlineValues[value.item].push(value.value);\n        });\n\n        filledItems.forEach((item) => {\n            if (!item.hasvalue || offlineValues[item.id] === undefined) {\n                return;\n            }\n\n            // Treat multichoice checkboxes.\n            if (item.typ === 'multichoice' && item.presentation.split(AddonModFeedbackProvider.MULTICHOICE_TYPE_SEP)[0] === 'c') {\n\n                offlineValues[item.id] = offlineValues[item.id].filter((value) => Number(value) > 0);\n                item.rawValue = offlineValues[item.id].join(AddonModFeedbackProvider.LINE_SEP);\n            } else {\n                item.rawValue = offlineValues[item.id][0];\n            }\n        });\n\n        return filledItems;\n    }\n\n    /**\n     * Returns all the feedback non respondents users.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @param previous Only for recurrent use. Object with the previous fetched info.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getAllNonRespondents(\n        feedbackId: number,\n        options: AddonModFeedbackGroupOptions = {},\n        previous?: AddonModFeedbackPreviousNonRespondents,\n    ): Promise<AddonModFeedbackAllNonRespondent> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n        previous = previous || {\n            page: 0,\n            users: [],\n        };\n\n        const response = await this.getNonRespondents(feedbackId, {\n            page: previous.page,\n            ...options, // Include all options.\n        });\n\n        if (previous.users.length < response.total) {\n            previous.users = previous.users.concat(response.users);\n        }\n\n        if (previous.users.length < response.total) {\n            // Can load more.\n            previous.page++;\n\n            return this.getAllNonRespondents(feedbackId, options, previous);\n        }\n\n        return {\n            ...previous,\n            total: response.total,\n        };\n    }\n\n    /**\n     * Returns all the feedback user responses.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @param previous Only for recurrent use. Object with the previous fetched info.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getAllResponsesAnalysis(\n        feedbackId: number,\n        options: AddonModFeedbackGroupOptions = {},\n        previous?: AddonModFeedbackPreviousResponsesAnalysis,\n    ): Promise<AddonModFeedbackAllResponsesAnalysis> {\n\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n        previous = previous || {\n            page: 0,\n            attempts: [],\n            anonattempts: [],\n        };\n\n        const responses = await this.getResponsesAnalysis(feedbackId, {\n            page: previous.page,\n            ...options, // Include all options.\n        });\n\n        if (previous.anonattempts.length < responses.totalanonattempts) {\n            previous.anonattempts = previous.anonattempts.concat(responses.anonattempts);\n        }\n\n        if (previous.attempts.length < responses.totalattempts) {\n            previous.attempts = previous.attempts.concat(responses.attempts);\n        }\n\n        if (previous.anonattempts.length < responses.totalanonattempts || previous.attempts.length < responses.totalattempts) {\n            // Can load more.\n            previous.page++;\n\n            return this.getAllResponsesAnalysis(feedbackId, options, previous);\n        }\n\n        return {\n            ...previous,\n            totalattempts: responses.totalattempts,\n            totalanonattempts: responses.totalanonattempts,\n        };\n    }\n\n    /**\n     * Get analysis information for a given feedback.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the feedback is retrieved.\n     */\n    async getAnalysis(\n        feedbackId: number,\n        options: AddonModFeedbackGroupOptions = {},\n    ): Promise<AddonModFeedbackGetAnalysisWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetAnalysisWSParams = {\n            feedbackid: feedbackId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAnalysisDataCacheKey(feedbackId, options.groupId),\n            component: AddonModFeedbackProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        if (options.groupId) {\n            params.groupid = options.groupId;\n        }\n\n        return site.read('mod_feedback_get_analysis', params, preSets);\n    }\n\n    /**\n     * Get cache key for feedback analysis data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @param groupId Group ID.\n     * @returns Cache key.\n     */\n    protected getAnalysisDataCacheKey(feedbackId: number, groupId: number = 0): string {\n        return this.getAnalysisDataPrefixCacheKey(feedbackId) + groupId;\n    }\n\n    /**\n     * Get prefix cache key for feedback analysis data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getAnalysisDataPrefixCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':analysis:';\n    }\n\n    /**\n     * Find an attempt in all responses analysis.\n     *\n     * @param feedbackId Feedback ID.\n     * @param attemptId Attempt ID to find.\n     * @param options Other options.\n     * @param previous Only for recurrent use. Object with the previous fetched info.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getAttempt(\n        feedbackId: number,\n        attemptId: number,\n        options: AddonModFeedbackGroupOptions = {},\n        previous?: AddonModFeedbackGetAttemptPreviousData,\n    ): Promise<AddonModFeedbackWSAttempt | AddonModFeedbackWSAnonAttempt> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n        previous = previous || {\n            page: 0,\n            attemptsLoaded: 0,\n            anonAttemptsLoaded: 0,\n        };\n\n        const responses = await this.getResponsesAnalysis(feedbackId, {\n            page: previous.page,\n            ...options, // Include all options.\n        });\n\n        const attempt = responses.attempts.find((attempt) => attemptId == attempt.id);\n\n        if (attempt) {\n            return attempt;\n        }\n\n        const anonAttempt = responses.anonattempts.find((attempt) => attemptId == attempt.id);\n\n        if (anonAttempt) {\n            return anonAttempt;\n        }\n\n        if (previous.anonAttemptsLoaded < responses.totalanonattempts) {\n            previous.anonAttemptsLoaded += responses.anonattempts.length;\n        }\n        if (previous.attemptsLoaded < responses.totalattempts) {\n            previous.attemptsLoaded += responses.attempts.length;\n        }\n\n        if (previous.anonAttemptsLoaded < responses.totalanonattempts || previous.attemptsLoaded < responses.totalattempts) {\n            // Can load more. Check there.\n            previous.page++;\n\n            return this.getAttempt(feedbackId, attemptId, options, previous);\n        }\n\n        // Not found and all loaded. Reject.\n        throw new CoreError('Attempt not found.');\n    }\n\n    /**\n     * Get prefix cache key for feedback completion data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getCompletedDataCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':completed:';\n    }\n\n    /**\n     * Returns the temporary completion timemodified for the current user.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getCurrentCompletedTimeModified(feedbackId: number, options: CoreCourseCommonModWSOptions = {}): Promise<number> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetCurrentCompletedTmpWSParams = {\n            feedbackid: feedbackId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCurrentCompletedTimeModifiedDataCacheKey(feedbackId),\n            component: AddonModFeedbackProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        try {\n            const response = await site.read<AddonModFeedbackGetCurrentCompletedTmpWSResponse>(\n                'mod_feedback_get_current_completed_tmp',\n                params,\n                preSets,\n            );\n\n            return response.feedback.timemodified;\n        } catch {\n            // Ignore errors.\n            return 0;\n        }\n    }\n\n    /**\n     * Get prefix cache key for feedback current completed temp data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getCurrentCompletedTimeModifiedDataCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':completedtime:';\n    }\n\n    /**\n     * Returns the temporary responses or responses of the last submission for the current user.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getCurrentValues(\n        feedbackId: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModFeedbackWSResponse[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetUnfinishedResponsesWSParams = {\n            feedbackid: feedbackId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCurrentValuesDataCacheKey(feedbackId),\n            component: AddonModFeedbackProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModFeedbackGetUnfinishedResponsesWSResponse>(\n            'mod_feedback_get_unfinished_responses',\n            params,\n            preSets,\n        );\n\n        if (response.responses.length) {\n            return response.responses;\n        }\n\n        // No unfinished responses, fetch responses of the last submission.\n        const finishedResponse = await site.read<AddonModFeedbackGetFinishedResponsesWSResponse>(\n            'mod_feedback_get_finished_responses',\n            params,\n            preSets,\n        );\n\n        return finishedResponse.responses;\n    }\n\n    /**\n     * Get cache key for get current values feedback data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getCurrentValuesDataCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':currentvalues';\n    }\n\n    /**\n     * Get access information for a given feedback.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the feedback is retrieved.\n     */\n    async getFeedbackAccessInformation(\n        feedbackId: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModFeedbackGetFeedbackAccessInformationWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetFeedbackAccessInformationWSParams = {\n            feedbackid: feedbackId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getFeedbackAccessInformationDataCacheKey(feedbackId),\n            component: AddonModFeedbackProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_feedback_get_feedback_access_information', params, preSets);\n    }\n\n    /**\n     * Get cache key for feedback access information data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getFeedbackAccessInformationDataCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':access';\n    }\n\n    /**\n     * Get cache key for feedback data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getFeedbackCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'feedback:' + courseId;\n    }\n\n    /**\n     * Get prefix cache key for all feedback activity data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getFeedbackDataPrefixCacheKey(feedbackId: number): string {\n        return ROOT_CACHE_KEY + feedbackId;\n    }\n\n    /**\n     * Get a feedback with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the feedback is retrieved.\n     */\n    protected async getFeedbackDataByKey(\n        courseId: number,\n        key: string,\n        value: unknown,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModFeedbackWSFeedback> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetFeedbacksByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getFeedbackCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModFeedbackProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModFeedbackGetFeedbacksByCoursesWSResponse>(\n            'mod_feedback_get_feedbacks_by_courses',\n            params,\n            preSets,\n        );\n\n        const currentFeedback = response.feedbacks.find((feedback) => feedback[key] == value);\n        if (currentFeedback) {\n            return currentFeedback;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get a feedback by course module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the feedback is retrieved.\n     */\n    getFeedback(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModFeedbackWSFeedback> {\n        return this.getFeedbackDataByKey(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a feedback by ID.\n     *\n     * @param courseId Course ID.\n     * @param id Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the feedback is retrieved.\n     */\n    getFeedbackById(courseId: number, id: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModFeedbackWSFeedback> {\n        return this.getFeedbackDataByKey(courseId, 'id', id, options);\n    }\n\n    /**\n     * Returns the items (questions) in the given feedback.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getItems(feedbackId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModFeedbackGetItemsWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetItemsWSParams = {\n            feedbackid: feedbackId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getItemsDataCacheKey(feedbackId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModFeedbackProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_feedback_get_items', params, preSets);\n    }\n\n    /**\n     * Get cache key for get items feedback data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getItemsDataCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':items';\n    }\n\n    /**\n     * Retrieves a list of students who didn't submit the feedback.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getNonRespondents(\n        feedbackId: number,\n        options: AddonModFeedbackGroupPaginatedOptions = {},\n    ): Promise<AddonModFeedbackGetNonRespondentsWSResponse> {\n        options.groupId = options.groupId || 0;\n        options.page = options.page || 0;\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetNonRespondentsWSParams = {\n            feedbackid: feedbackId,\n            groupid: options.groupId,\n            page: options.page,\n            perpage: AddonModFeedbackProvider.PER_PAGE,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getNonRespondentsDataCacheKey(feedbackId, options.groupId),\n            component: AddonModFeedbackProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_feedback_get_non_respondents', params, preSets);\n    }\n\n    /**\n     * Get cache key for non respondents feedback data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @param groupId Group id, 0 means that the function will determine the user group.\n     * @returns Cache key.\n     */\n    protected getNonRespondentsDataCacheKey(feedbackId: number, groupId: number = 0): string {\n        return this.getNonRespondentsDataPrefixCacheKey(feedbackId) + groupId;\n    }\n\n    /**\n     * Get prefix cache key for feedback non respondents data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getNonRespondentsDataPrefixCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':nonrespondents:';\n    }\n\n    /**\n     * Get a single feedback page items. This function is not cached, use AddonModFeedbackHelperProvider#getPageItems instead.\n     *\n     * @param feedbackId Feedback ID.\n     * @param page The page to get.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getPageItems(feedbackId: number, page: number, siteId?: string): Promise<AddonModFeedbackGetPageItemsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModFeedbackGetPageItemsWSParams = {\n            feedbackid: feedbackId,\n            page: page,\n        };\n\n        return site.write('mod_feedback_get_page_items', params);\n    }\n\n    /**\n     * Get a single feedback page items. If offline or server down it will use getItems to calculate dependencies.\n     *\n     * @param feedbackId Feedback ID.\n     * @param page The page to get.\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getPageItemsWithValues(\n        feedbackId: number,\n        page: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModFeedbackPageItems> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        try {\n            const response: AddonModFeedbackPageItems = await this.getPageItems(feedbackId, page, options.siteId);\n\n            response.items = await this.fillValues(feedbackId, response.items, options);\n\n            return response;\n        } catch {\n            // If getPageItems fail we should calculate it using getItems.\n            const response = await this.getItems(feedbackId, options);\n\n            const items = await this.fillValues(feedbackId, response.items, options);\n\n            // Separate items by pages.\n            let currentPage = 0;\n            const previousPageItems: AddonModFeedbackItem[] = [];\n\n            const pageItems = items.filter((item) => {\n                // Greater page, discard all entries.\n                if (currentPage > page) {\n                    return false;\n                }\n\n                if (item.typ == 'pagebreak') {\n                    currentPage++;\n\n                    return false;\n                }\n\n                // Save items on previous page to check dependencies and discard entry.\n                if (currentPage < page) {\n                    previousPageItems.push(item);\n\n                    return false;\n                }\n\n                // Filter depending items.\n                if (item && item.dependitem > 0 && previousPageItems.length > 0) {\n                    return this.checkDependencyItem(previousPageItems, item);\n                }\n\n                // Filter items with errors.\n                return item;\n            });\n\n            return {\n                items: pageItems,\n                hasprevpage: page > 0,\n                hasnextpage: currentPage > page,\n                warnings: response.warnings,\n            };\n        }\n    }\n\n    /**\n     * Convenience function to get the page we can jump.\n     *\n     * @param feedbackId Feedback ID.\n     * @param page Page where we want to jump.\n     * @param changePage If page change is forward (1) or backward (-1).\n     * @param options Other options.\n     * @returns Page number where to jump. Or false if completed or first page.\n     */\n    protected async getPageJumpTo(\n        feedbackId: number,\n        page: number,\n        changePage: number,\n        options: { cmId?: number; siteId?: string },\n    ): Promise<number | false> {\n\n        const response = await this.getPageItemsWithValues(feedbackId, page, {\n            cmId: options.cmId,\n            readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n            siteId: options.siteId,\n        });\n\n        // The page we are going has items.\n        if (response.items.length > 0) {\n            return page;\n        }\n\n        // Check we can jump futher.\n        if ((changePage == 1 && response.hasnextpage) || (changePage == -1 && response.hasprevpage)) {\n            return this.getPageJumpTo(feedbackId, page + changePage, changePage, options);\n        }\n\n        // Completed or first page.\n        return false;\n    }\n\n    /**\n     * Returns the feedback user responses.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getResponsesAnalysis(\n        feedbackId: number,\n        options: AddonModFeedbackGroupPaginatedOptions = {},\n    ): Promise<AddonModFeedbackGetResponsesAnalysisWSResponse> {\n        options.groupId = options.groupId || 0;\n        options.page = options.page || 0;\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetResponsesAnalysisWSParams = {\n            feedbackid: feedbackId,\n            groupid: options.groupId,\n            page: options.page,\n            perpage: AddonModFeedbackProvider.PER_PAGE,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getResponsesAnalysisDataCacheKey(feedbackId, options.groupId),\n            component: AddonModFeedbackProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_feedback_get_responses_analysis', params, preSets);\n    }\n\n    /**\n     * Get cache key for responses analysis feedback data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @param groupId Group id, 0 means that the function will determine the user group.\n     * @returns Cache key.\n     */\n    protected getResponsesAnalysisDataCacheKey(feedbackId: number, groupId: number = 0): string {\n        return this.getResponsesAnalysisDataPrefixCacheKey(feedbackId) + groupId;\n    }\n\n    /**\n     * Get prefix cache key for feedback responses analysis data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getResponsesAnalysisDataPrefixCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':responsesanalysis:';\n    }\n\n    /**\n     * Gets the resume page information.\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getResumePage(feedbackId: number, options: CoreCourseCommonModWSOptions = {}): Promise<number> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackLaunchFeedbackWSParams = {\n            feedbackid: feedbackId,\n        };\n        const preSets = {\n            cacheKey: this.getResumePageDataCacheKey(feedbackId),\n            component: AddonModFeedbackProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModFeedbackLaunchFeedbackWSResponse>('mod_feedback_launch_feedback', params, preSets);\n\n        // WS will return -1 for last page but the user need to start again.\n        return response.gopage > 0 ? response.gopage : 0;\n    }\n\n    /**\n     * Get prefix cache key for resume feedback page data WS calls.\n     *\n     * @param feedbackId Feedback ID.\n     * @returns Cache key.\n     */\n    protected getResumePageDataCacheKey(feedbackId: number): string {\n        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':launch';\n    }\n\n    /**\n     * Invalidates feedback data except files and module info.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllFeedbackData(feedbackId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getFeedbackDataPrefixCacheKey(feedbackId));\n    }\n\n    /**\n     * Invalidates feedback analysis data.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAnalysisData(feedbackId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.invalidateWsCacheForKeyStartingWith(this.getAnalysisDataPrefixCacheKey(feedbackId));\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     * To invalidate files, use AddonModFeedbackProvider#invalidateFiles.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID of the module.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const feedback = await this.getFeedback(courseId, moduleId, { siteId });\n\n        await Promise.all([\n            this.invalidateFeedbackData(courseId, siteId),\n            this.invalidateAllFeedbackData(feedback.id, siteId),\n        ]);\n    }\n\n    /**\n     * Invalidates temporary completion record data.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCurrentValuesData(feedbackId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.invalidateWsCacheForKey(this.getCurrentValuesDataCacheKey(feedbackId));\n    }\n\n    /**\n     * Invalidates feedback access information data.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateFeedbackAccessInformationData(feedbackId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.invalidateWsCacheForKey(this.getFeedbackAccessInformationDataCacheKey(feedbackId));\n    }\n\n    /**\n     * Invalidates feedback data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateFeedbackData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.invalidateWsCacheForKey(this.getFeedbackCacheKey(courseId));\n    }\n\n    /**\n     * Invalidate the prefetched files.\n     *\n     * @param moduleId The module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the files are invalidated.\n     */\n    async invalidateFiles(moduleId: number, siteId?: string): Promise<void> {\n        return CoreFilepool.invalidateFilesByComponent(siteId, AddonModFeedbackProvider.COMPONENT, moduleId);\n    }\n\n    /**\n     * Invalidates feedback non respondents record data.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateNonRespondentsData(feedbackId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getNonRespondentsDataPrefixCacheKey(feedbackId));\n    }\n\n    /**\n     * Invalidates feedback user responses record data.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateResponsesAnalysisData(feedbackId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getResponsesAnalysisDataPrefixCacheKey(feedbackId));\n    }\n\n    /**\n     * Invalidates launch feedback data.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateResumePageData(feedbackId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getResumePageDataCacheKey(feedbackId));\n    }\n\n    /**\n     * Returns if feedback has been completed\n     *\n     * @param feedbackId Feedback ID.\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async isCompleted(feedbackId: number, options: CoreCourseCommonModWSOptions = {}): Promise<boolean> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModFeedbackGetLastCompletedWSParams = {\n            feedbackid: feedbackId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCompletedDataCacheKey(feedbackId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModFeedbackProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return CoreUtils.promiseWorks(site.read('mod_feedback_get_last_completed', params, preSets));\n    }\n\n    /**\n     * Report the feedback as being viewed.\n     *\n     * @param id Module ID.\n     * @param formViewed True if form was viewed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logView(id: number, formViewed: boolean = false, siteId?: string): Promise<void> {\n        const params: AddonModFeedbackViewFeedbackWSParams = {\n            feedbackid: id,\n            moduleviewed: formViewed,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_feedback_view_feedback',\n            params,\n            AddonModFeedbackProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Process a jump between pages.\n     *\n     * @param feedbackId Feedback ID.\n     * @param page The page being processed.\n     * @param responses The data to be processed the key is the field name (usually type[index]_id).\n     * @param options Other options.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async processPage(\n        feedbackId: number,\n        page: number,\n        responses: Record<string, AddonModFeedbackResponseValue>,\n        options: AddonModFeedbackProcessPageOptions = {},\n    ): Promise<AddonModFeedbackProcessPageResponse> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a message to be synchronized later.\n        const storeOffline = async (): Promise<AddonModFeedbackProcessPageResponse> => {\n            await AddonModFeedbackOffline.saveResponses(feedbackId, page, responses, options.courseId!, options.siteId);\n\n            // Simulate process_page response.\n            const response: AddonModFeedbackProcessPageResponse = {\n                jumpto: page,\n                completed: false,\n                offline: true,\n            };\n            let changePage = 0;\n\n            if (options.goPrevious) {\n                if (page > 0) {\n                    changePage = -1;\n                }\n            } else if (!options.formHasErrors) {\n                // We can only go next if it has no errors.\n                changePage = 1;\n            }\n\n            if (changePage === 0) {\n                return response;\n            }\n\n            const pageItems = await this.getPageItemsWithValues(feedbackId, page, {\n                cmId: options.cmId,\n                readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n                siteId: options.siteId,\n            });\n\n            // Check completion.\n            if (changePage == 1 && !pageItems.hasnextpage) {\n                response.completed = true;\n\n                return response;\n            }\n\n            const loadPage = await this.getPageJumpTo(feedbackId, page + changePage, changePage, options);\n\n            if (loadPage === false) {\n                // Completed or first page.\n                if (changePage == -1) {\n                    response.jumpto = 0;\n                } else {\n                    response.completed = true;\n                }\n            } else {\n                response.jumpto = loadPage;\n            }\n\n            return response;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        // If there's already a response to be sent to the server, discard it first.\n        await AddonModFeedbackOffline.deleteFeedbackPageResponses(feedbackId, page, options.siteId);\n\n        try {\n            return await this.processPageOnline(feedbackId, page, responses, !!options.goPrevious, options.siteId);\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that responses cannot be submitted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store in offline.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Process a jump between pages.\n     *\n     * @param feedbackId Feedback ID.\n     * @param page The page being processed.\n     * @param responses The data to be processed the key is the field name (usually type[index]_id).\n     * @param goPrevious Whether we want to jump to previous page.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async processPageOnline(\n        feedbackId: number,\n        page: number,\n        responses: Record<string, AddonModFeedbackResponseValue>,\n        goPrevious: boolean,\n        siteId?: string,\n    ): Promise<AddonModFeedbackProcessPageWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModFeedbackProcessPageWSParams = {\n            feedbackid: feedbackId,\n            page: page,\n            responses: CoreUtils.objectToArrayOfObjects(responses, 'name', 'value'),\n            goprevious: goPrevious,\n        };\n\n        const response = await site.write<AddonModFeedbackProcessPageWSResponse>('mod_feedback_process_page', params);\n\n        // Invalidate and update current values because they will change.\n        await CoreUtils.ignoreErrors(this.invalidateCurrentValuesData(feedbackId, site.getId()));\n\n        await CoreUtils.ignoreErrors(this.getCurrentValues(feedbackId, { siteId: site.getId() }));\n\n        return response;\n    }\n\n}\n\nexport const AddonModFeedback = makeSingleton(AddonModFeedbackProvider);\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonModFeedbackProvider.FORM_SUBMITTED]: AddonModFeedbackFormSubmittedData;\n        [AddonModFeedbackSyncProvider.AUTO_SYNCED]: AddonModFeedbackAutoSyncData;\n    }\n\n}\n\n/**\n * Data passed to FORM_SUBMITTED event.\n */\nexport type AddonModFeedbackFormSubmittedData = {\n    feedbackId: number;\n    tab: string;\n    offline: boolean;\n};\n\n/**\n * Params of mod_feedback_get_analysis WS.\n */\nexport type AddonModFeedbackGetAnalysisWSParams = {\n    feedbackid: number; // Feedback instance id.\n    groupid?: number; // Group id, 0 means that the function will determine the user group.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_analysis WS.\n */\nexport type AddonModFeedbackGetAnalysisWSResponse = {\n    completedcount: number; // Number of completed submissions.\n    itemscount: number; // Number of items (questions).\n    itemsdata: {\n        item: AddonModFeedbackWSItem;\n        data: string[];\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Item data returneds by feedback_item_exporter.\n */\nexport type AddonModFeedbackWSItem = {\n    id: number; // The record id.\n    feedback: number; // The feedback instance id this records belongs to.\n    template: number; // If it belogns to a template, the template id.\n    name: string; // The item name.\n    label: string; // The item label.\n    presentation: string; // The text describing the item or the available possible answers.\n    typ: string; // The type of the item.\n    hasvalue: number; // Whether it has a value or not.\n    position: number; // The position in the list of questions.\n    required: boolean; // Whether is a item (question) required or not.\n    dependitem: number; // The item id this item depend on.\n    dependvalue: string; // The depend value.\n    options: string; // Different additional settings for the item (question).\n    itemfiles: CoreWSStoredFile[]; // Itemfiles.\n    itemnumber: number; // The item position number.\n    otherdata: string; // Additional data that may be required by external functions.\n};\n\n/**\n * Item with some calculated data.\n */\nexport type AddonModFeedbackItem = AddonModFeedbackWSItem & {\n    rawValue?: AddonModFeedbackResponseValue;\n};\n\n/**\n * Params of mod_feedback_get_current_completed_tmp WS.\n */\nexport type AddonModFeedbackGetCurrentCompletedTmpWSParams = {\n    feedbackid: number; // Feedback instance id.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_current_completed_tmp WS.\n */\nexport type AddonModFeedbackGetCurrentCompletedTmpWSResponse = {\n    feedback: {\n        id: number; // The record id.\n        feedback: number; // The feedback instance id this records belongs to.\n        userid: number; // The user who completed the feedback (0 for anonymous).\n        guestid: string; // For guests, this is the session key.\n        timemodified: number; // The last time the feedback was completed.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        random_response: number; // The response number (used when shuffling anonymous responses).\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        anonymous_response: number; // Whether is an anonymous response.\n        courseid: number; // The course id where the feedback was completed.\n    };\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_feedback_get_unfinished_responses WS.\n */\nexport type AddonModFeedbackGetUnfinishedResponsesWSParams = {\n    feedbackid: number; // Feedback instance id.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_unfinished_responses WS.\n */\nexport type AddonModFeedbackGetUnfinishedResponsesWSResponse = {\n    responses: AddonModFeedbackWSUnfinishedResponse[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Unfinished response data returned by feedback_valuetmp_exporter.\n */\nexport type AddonModFeedbackWSUnfinishedResponse = {\n    id: number; // The record id.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    course_id: number; // The course id this record belongs to.\n    item: number; // The item id that was responded.\n    completed: number; // Reference to the feedback_completedtmp table.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    tmp_completed: number; // Old field - not used anymore.\n    value: string; // The response value.\n};\n\n/**\n * Params of mod_feedback_get_finished_responses WS.\n */\nexport type AddonModFeedbackGetFinishedResponsesWSParams = {\n    feedbackid: number; // Feedback instance id.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_finished_responses WS.\n */\nexport type AddonModFeedbackGetFinishedResponsesWSResponse = {\n    responses: AddonModFeedbackWSFinishedResponse[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Unfinished response data returned by feedback_value_exporter.\n */\nexport type AddonModFeedbackWSFinishedResponse = {\n    id: number; // The record id.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    course_id: number; // The course id this record belongs to.\n    item: number; // The item id that was responded.\n    completed: number; // Reference to the feedback_completed table.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    tmp_completed: number; // Old field - not used anymore.\n    value: string; // The response value.\n};\n\n/**\n * A response, either finished or unfinished.\n */\nexport type AddonModFeedbackWSResponse = AddonModFeedbackWSFinishedResponse | AddonModFeedbackWSUnfinishedResponse;\n\n/**\n * Params of mod_feedback_get_feedback_access_information WS.\n */\nexport type AddonModFeedbackGetFeedbackAccessInformationWSParams = {\n    feedbackid: number; // Feedback instance id.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_feedback_access_information WS.\n */\nexport type AddonModFeedbackGetFeedbackAccessInformationWSResponse = {\n    canviewanalysis: boolean; // Whether the user can view the analysis or not.\n    cancomplete: boolean; // Whether the user can complete the feedback or not.\n    cansubmit: boolean; // Whether the user can submit the feedback or not.\n    candeletesubmissions: boolean; // Whether the user can delete submissions or not.\n    canviewreports: boolean; // Whether the user can view the feedback reports or not.\n    canedititems: boolean; // Whether the user can edit feedback items or not.\n    isempty: boolean; // Whether the feedback has questions or not.\n    isopen: boolean; // Whether the feedback has active access time restrictions or not.\n    isalreadysubmitted: boolean; // Whether the feedback is already submitted or not.\n    isanonymous: boolean; // Whether the feedback is anonymous or not.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_feedback_get_feedbacks_by_courses WS.\n */\nexport type AddonModFeedbackGetFeedbacksByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_feedback_get_feedbacks_by_courses WS.\n */\nexport type AddonModFeedbackGetFeedbacksByCoursesWSResponse = {\n    feedbacks: AddonModFeedbackWSFeedback[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Feedback data returned by mod_feedback_get_feedbacks_by_courses WS.\n */\nexport type AddonModFeedbackWSFeedback = {\n    id: number; // The primary key of the record.\n    course: number; // Course id this feedback is part of.\n    name: string; // Feedback name.\n    intro: string; // Feedback introduction text.\n    introformat?: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    anonymous: number; // Whether the feedback is anonymous.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    email_notification?: boolean; // Whether email notifications will be sent to teachers.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    multiple_submit: boolean; // Whether multiple submissions are allowed.\n    autonumbering: boolean; // Whether questions should be auto-numbered.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    site_after_submit?: string; // Link to next page after submission.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    page_after_submit?: string; // Text to display after submission.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    page_after_submitformat?: number; // Page_after_submit format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    publish_stats: boolean; // Whether stats should be published.\n    timeopen?: number; // Allow answers from this time.\n    timeclose?: number; // Allow answers until this time.\n    timemodified?: number; // The time this record was modified.\n    completionsubmit: boolean; // If set to 1, then the activity will be automatically marked as complete on submission.\n    coursemodule: number; // Coursemodule.\n    introfiles: CoreWSExternalFile[]; // Introfiles.\n    pageaftersubmitfiles?: CoreWSExternalFile[]; // Pageaftersubmitfiles.\n};\n\n/**\n * Params of mod_feedback_get_items WS.\n */\nexport type AddonModFeedbackGetItemsWSParams = {\n    feedbackid: number; // Feedback instance id.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_items WS.\n */\nexport type AddonModFeedbackGetItemsWSResponse = {\n    items: AddonModFeedbackWSItem[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_feedback_get_non_respondents WS.\n */\nexport type AddonModFeedbackGetNonRespondentsWSParams = {\n    feedbackid: number; // Feedback instance id.\n    groupid?: number; // Group id, 0 means that the function will determine the user group.\n    sort?: string; // Sort param, must be firstname, lastname or lastaccess (default).\n    page?: number; // The page of records to return.\n    perpage?: number; // The number of records to return per page.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_non_respondents WS.\n */\nexport type AddonModFeedbackGetNonRespondentsWSResponse = {\n    users: AddonModFeedbackWSNonRespondent[];\n    total: number; // Total number of non respondents.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data returned by mod_feedback_get_non_respondents WS.\n */\nexport type AddonModFeedbackWSNonRespondent = {\n    courseid: number; // Course id.\n    userid: number; // The user id.\n    fullname: string; // User full name.\n    started: boolean; // If the user has started the attempt.\n};\n\n/**\n * Params of mod_feedback_get_page_items WS.\n */\nexport type AddonModFeedbackGetPageItemsWSParams = {\n    feedbackid: number; // Feedback instance id.\n    page: number; // The page to get starting by 0.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_page_items WS.\n */\nexport type AddonModFeedbackGetPageItemsWSResponse = {\n    items: AddonModFeedbackWSItem[];\n    hasprevpage: boolean; // Whether is a previous page.\n    hasnextpage: boolean; // Whether there are more pages.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Page items with some calculated data.\n */\nexport type AddonModFeedbackPageItems = Omit<AddonModFeedbackGetPageItemsWSResponse, 'items'> & {\n    items: AddonModFeedbackItem[];\n};\n\n/**\n * Params of mod_feedback_get_responses_analysis WS.\n */\nexport type AddonModFeedbackGetResponsesAnalysisWSParams = {\n    feedbackid: number; // Feedback instance id.\n    groupid?: number; // Group id, 0 means that the function will determine the user group.\n    page?: number; // The page of records to return.\n    perpage?: number; // The number of records to return per page.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_get_responses_analysis WS.\n */\nexport type AddonModFeedbackGetResponsesAnalysisWSResponse = {\n    attempts: AddonModFeedbackWSAttempt[];\n    totalattempts: number; // Total responses count.\n    anonattempts: AddonModFeedbackWSAnonAttempt[];\n    totalanonattempts: number; // Total anonymous responses count.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Attempt data returned by mod_feedback_get_responses_analysis WS.\n */\nexport type AddonModFeedbackWSAttempt = {\n    id: number; // Completed id.\n    courseid: number; // Course id.\n    userid: number; // User who responded.\n    timemodified: number; // Time modified for the response.\n    fullname: string; // User full name.\n    responses: AddonModFeedbackWSAttemptResponse[];\n};\n\n/**\n * Anonymous attempt data returned by mod_feedback_get_responses_analysis WS.\n */\nexport type AddonModFeedbackWSAnonAttempt = {\n    id: number; // Completed id.\n    courseid: number; // Course id.\n    // eslint-disable-next-line id-blacklist\n    number: number; // Response number.\n    responses: AddonModFeedbackWSAttemptResponse[];\n};\n\n/**\n * Response data returned by mod_feedback_get_responses_analysis WS.\n */\nexport type AddonModFeedbackWSAttemptResponse = {\n    id: number; // Response id.\n    name: string; // Response name.\n    printval: string; // Response ready for output.\n    rawval: string; // Response raw value.\n};\n\n/**\n * Params of mod_feedback_launch_feedback WS.\n */\nexport type AddonModFeedbackLaunchFeedbackWSParams = {\n    feedbackid: number; // Feedback instance id.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_launch_feedback WS.\n */\nexport type AddonModFeedbackLaunchFeedbackWSResponse = {\n    gopage: number; // The next page to go (-1 if we were already in the last page). 0 for first page.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_feedback_get_last_completed WS.\n */\nexport type AddonModFeedbackGetLastCompletedWSParams = {\n    feedbackid: number; // Feedback instance id.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Params of mod_feedback_view_feedback WS.\n */\nexport type AddonModFeedbackViewFeedbackWSParams = {\n    feedbackid: number; // Feedback instance id.\n    moduleviewed?: boolean; // If we need to mark the module as viewed for completion.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Params of mod_feedback_process_page WS.\n */\nexport type AddonModFeedbackProcessPageWSParams = {\n    feedbackid: number; // Feedback instance id.\n    page: number; // The page being processed.\n    responses?: { // The data to be processed.\n        name: string; // The response name (usually type[index]_id).\n        value: string | number; // The response value.\n    }[];\n    goprevious?: boolean; // Whether we want to jump to previous page.\n    courseid?: number; // Course where user completes the feedback (for site feedbacks only).\n};\n\n/**\n * Data returned by mod_feedback_process_page WS.\n */\nexport type AddonModFeedbackProcessPageWSResponse = {\n    jumpto: number; // The page to jump to.\n    completed: boolean; // If the user completed the feedback.\n    completionpagecontents: string; // The completion page contents.\n    siteaftersubmit: string; // The link (could be relative) to show after submit.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data returned by process page.\n */\nexport type AddonModFeedbackProcessPageResponse = {\n    jumpto: number | null; // The page to jump to.\n    completed: boolean; // If the user completed the feedback.\n    offline?: boolean; // Whether data has been stored in offline.\n} & Partial<AddonModFeedbackProcessPageWSResponse>;\n\n/**\n * Common options with a group ID.\n */\nexport type AddonModFeedbackGroupOptions = CoreCourseCommonModWSOptions & {\n    groupId?: number; // Group id, 0 means that the function will determine the user group. Defaults to 0.\n};\n\n/**\n * Common options with a group ID and page.\n */\nexport type AddonModFeedbackGroupPaginatedOptions = AddonModFeedbackGroupOptions & {\n    page?: number; // The page of records to return. The page of records to return.\n};\n\n/**\n * Common options with a group ID and page.\n */\nexport type AddonModFeedbackProcessPageOptions = {\n    goPrevious?: boolean; // Whether we want to jump to previous page.\n    formHasErrors?: boolean; // Whether the form we sent has required but empty fields (only used in offline).\n    cmId?: number; // Module ID.\n    courseId?: number; // Course ID the feedback belongs to.\n    siteId?: string; // Site ID. If not defined, current site.;\n};\n\n/**\n * Possible types of responses.\n */\nexport type AddonModFeedbackResponseValue = string | number;\n\ntype OfflineResponsesArray = {\n    id: string;\n    value: AddonModFeedbackResponseValue;\n}[];\n\n/**\n * Previous non respondents when using recursive function.\n */\nexport type AddonModFeedbackPreviousNonRespondents = {\n    page: number;\n    users: AddonModFeedbackWSNonRespondent[];\n};\n\n/**\n * All non respondents.\n */\nexport type AddonModFeedbackAllNonRespondent = AddonModFeedbackPreviousNonRespondents & {\n    total: number;\n};\n\nexport type AddonModFeedbackPreviousResponsesAnalysis = {\n    page: number;\n    attempts: AddonModFeedbackWSAttempt[];\n    anonattempts: AddonModFeedbackWSAnonAttempt[];\n};\n\nexport type AddonModFeedbackAllResponsesAnalysis = AddonModFeedbackPreviousResponsesAnalysis & {\n    totalattempts: number;\n    totalanonattempts: number;\n};\n\nexport type AddonModFeedbackGetAttemptPreviousData = {\n    page: number;\n    attemptsLoaded: number;\n    anonAttemptsLoaded: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}