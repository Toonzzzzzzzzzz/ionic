{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ViewContainerRef, EventEmitter } from '@angular/core';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CoreCompile } from '@features/compile/services/compile';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport * as i0 from \"@angular/core\";\nconst _c0 = [\"dynamicComponent\"];\n/**\n * This component has a behaviour similar to $compile for AngularJS. Given an HTML code, it will compile it so all its\n * components and directives are instantiated.\n *\n * IMPORTANT: Use this component only if it is a must. It will create and compile a new component and module everytime this\n * component is used, so it can slow down the app.\n *\n * This component has its own module to prevent circular dependencies. If you want to use it,\n * you need to import CoreCompileHtmlComponentModule.\n *\n * You can provide some Javascript code (as text) to be executed inside the component. The context of the javascript code (this)\n * will be the component instance created to compile the template. This means your javascript code can interact with the template.\n * The component instance will have most of the providers so you can use them in the javascript code. E.g. if you want to use\n * CoreAppProvider, you can do it with \"this.CoreAppProvider\".\n */\nexport class CoreCompileHtmlComponent {\n  constructor(changeDetector, element, differs) {\n    this.changeDetector = changeDetector;\n    this.extraImports = []; // Extra import modules.\n    this.extraProviders = []; // Extra providers.\n    this.forceCompile = false; // Set it to true to force compile even if the text/javascript hasn't changed.\n    this.created = new EventEmitter(); // Will emit an event when the component is instantiated.\n    this.compiling = new EventEmitter(); // Event that indicates whether the template is being compiled.\n    this.loaded = false;\n    this.creatingComponent = false;\n    this.pendingCalls = {};\n    this.element = element.nativeElement;\n    this.differ = differs.find([]).create();\n  }\n  /**\n   * @inheritdoc\n   */\n  ngDoCheck() {\n    if (!this.componentInstance || this.creatingComponent) {\n      return;\n    }\n    // Check if there's any change in the jsData object.\n    const changes = this.differ.diff(this.jsData || {});\n    if (changes) {\n      this.setInputData();\n      if (this.componentInstance.ngOnChanges) {\n        this.componentInstance.ngOnChanges(CoreDomUtils.createChangesFromKeyValueDiff(changes));\n      }\n    }\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnChanges(changes) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.container) {\n        return;\n      }\n      // Only compile if text/javascript has changed or the forceCompile flag has been set to true.\n      if (_this.text !== undefined && (changes.text || changes.javascript || changes.forceCompile && CoreUtils.isTrueOrOne(_this.forceCompile))) {\n        // Create a new component and a new module.\n        _this.creatingComponent = true;\n        _this.compiling.emit(true);\n        try {\n          var _this$componentRef;\n          const componentClass = yield _this.getComponentClass();\n          // Destroy previous components.\n          (_this$componentRef = _this.componentRef) === null || _this$componentRef === void 0 || _this$componentRef.destroy();\n          // Create the component.\n          _this.componentRef = yield CoreCompile.createAndCompileComponent(_this.text, componentClass, _this.container, _this.extraImports);\n          _this.componentRef && _this.created.emit(_this.componentRef.instance);\n          _this.loaded = true;\n        } catch (error) {\n          CoreDomUtils.showErrorModal(error);\n          _this.loaded = true;\n        } finally {\n          _this.creatingComponent = false;\n          _this.compiling.emit(false);\n        }\n      }\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnDestroy() {\n    var _this$componentRef2;\n    (_this$componentRef2 = this.componentRef) === null || _this$componentRef2 === void 0 || _this$componentRef2.destroy();\n  }\n  /**\n   * Get a class that defines the dynamic component.\n   *\n   * @returns The component class.\n   */\n  getComponentClass() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const compileInstance = _this2;\n      const lazyLibraries = yield CoreCompile.getLazyLibraries();\n      // Create the component, using the text as the template.\n      return class CoreCompileHtmlFakeComponent {\n        constructor() {\n          this.ongoingLifecycleHooks = new Set();\n          // Store this instance so it can be accessed by the outer component.\n          compileInstance.componentInstance = this;\n          // Create 2 empty properties that can be used by the template to store data.\n          this['dataObject'] = {};\n          this['dataArray'] = [];\n          // Inject the libraries.\n          CoreCompile.injectLibraries(this, [...lazyLibraries, ...compileInstance.extraProviders]);\n          // Always add these elements, they could be needed on component init (componentObservable).\n          this['ChangeDetectorRef'] = compileInstance.changeDetector;\n          this['componentContainer'] = compileInstance.element;\n          // Add the data passed to the component.\n          compileInstance.setInputData();\n        }\n        /**\n         * @inheritdoc\n         */\n        ngOnInit() {\n          // If there is some javascript to run, do it now.\n          if (compileInstance.javascript) {\n            CoreCompile.executeJavascript(this, compileInstance.javascript);\n          }\n          // Call the pending functions.\n          for (const name in compileInstance.pendingCalls) {\n            const pendingCall = compileInstance.pendingCalls[name];\n            if (typeof this[name] === 'function') {\n              // Call the function.\n              Promise.resolve(this[name].apply(this, pendingCall.params)).then(pendingCall.defer.resolve).catch(pendingCall.defer.reject);\n            } else {\n              // Function not defined, resolve the promise.\n              pendingCall.defer.resolve();\n            }\n          }\n          compileInstance.pendingCalls = {};\n        }\n        /**\n         * @inheritdoc\n         */\n        ngAfterContentInit() {\n          this.callLifecycleHookOverride('ngAfterContentInit');\n        }\n        /**\n         * @inheritdoc\n         */\n        ngAfterViewInit() {\n          this.callLifecycleHookOverride('ngAfterViewInit');\n        }\n        /**\n         * @inheritdoc\n         */\n        ngOnDestroy() {\n          this.callLifecycleHookOverride('ngOnDestroy');\n        }\n        /**\n         * Call a lifecycle method that can be overriden in plugins.\n         *\n         * This is necessary because overriding lifecycle hooks at runtime does not work in Angular. This may be happening\n         * because lifecycle hooks are special methods treated by the Angular compiler, so it is possible that it's storing\n         * a reference to the method defined during compilation. In order to work around that, this will call the actual method\n         * from the plugin without causing infinite loops in case it wasn't overriden.\n         *\n         * @param method Lifecycle hook method name.\n         */\n        callLifecycleHookOverride(method) {\n          if (this.ongoingLifecycleHooks.has(method)) {\n            return;\n          }\n          this.ongoingLifecycleHooks.add(method);\n          this[method]();\n          this.ongoingLifecycleHooks.delete(method);\n        }\n      };\n    })();\n  }\n  /**\n   * Set the JS data as input data of the component instance.\n   */\n  setInputData() {\n    if (!this.componentInstance) {\n      return;\n    }\n    for (const name in this.jsData) {\n      this.componentInstance[name] = this.jsData[name];\n    }\n  }\n  /**\n   * Call a certain function on the component instance.\n   *\n   * @param name Name of the function to call.\n   * @param params List of params to send to the function.\n   * @param callWhenCreated If this param is true and the component hasn't been created yet, call the function\n   *                        once the component has been created.\n   * @returns Result of the call. Undefined if no component instance or the function doesn't exist.\n   */\n  callComponentFunction(name, params, callWhenCreated = true) {\n    if (this.componentInstance) {\n      if (typeof this.componentInstance[name] === 'function') {\n        return this.componentInstance[name].apply(this.componentInstance, params);\n      }\n    } else if (callWhenCreated) {\n      // Call it when the component is created.\n      if (this.pendingCalls[name]) {\n        // Call already pending, just update the params (allow only 1 call per function until it's initialized).\n        this.pendingCalls[name].params = params;\n        return this.pendingCalls[name].defer.promise;\n      }\n      const defer = new CorePromisedValue();\n      this.pendingCalls[name] = {\n        params,\n        defer\n      };\n      return defer;\n    }\n  }\n}\n_class = CoreCompileHtmlComponent;\n_class.ɵfac = function CoreCompileHtmlComponent_Factory(t) {\n  return new (t || _class)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.KeyValueDiffers));\n};\n_class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: _class,\n  selectors: [[\"core-compile-html\"]],\n  viewQuery: function CoreCompileHtmlComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5, ViewContainerRef);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n    }\n  },\n  inputs: {\n    text: \"text\",\n    javascript: \"javascript\",\n    jsData: \"jsData\",\n    extraImports: \"extraImports\",\n    extraProviders: \"extraProviders\",\n    forceCompile: \"forceCompile\"\n  },\n  outputs: {\n    created: \"created\",\n    compiling: \"compiling\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature],\n  decls: 3,\n  vars: 1,\n  consts: [[3, \"hideUntil\"], [\"dynamicComponent\", \"\"]],\n  template: function CoreCompileHtmlComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"core-loading\", 0);\n      i0.ɵɵelementContainer(1, null, 1);\n      i0.ɵɵelementEnd();\n    }\n    if (rf & 2) {\n      i0.ɵɵproperty(\"hideUntil\", ctx.loaded);\n    }\n  },\n  styles: [\"[_nghost-%COMP%] { display: contents; }\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9jb3JlL2ZlYXR1cmVzL2NvbXBpbGUvY29tcG9uZW50cy9jb21waWxlLWh0bWwvY29tcGlsZS1odG1sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFFBQVEsaUJBQWlCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyI6aG9zdCB7IGRpc3BsYXk6IGNvbnRlbnRzOyB9Il0sInNvdXJjZVJvb3QiOiIifQ== */\"]\n});","map":{"version":3,"names":["ViewContainerRef","EventEmitter","CorePromisedValue","CoreCompile","CoreDomUtils","CoreUtils","CoreCompileHtmlComponent","constructor","changeDetector","element","differs","extraImports","extraProviders","forceCompile","created","compiling","loaded","creatingComponent","pendingCalls","nativeElement","differ","find","create","ngDoCheck","componentInstance","changes","diff","jsData","setInputData","ngOnChanges","createChangesFromKeyValueDiff","_this","_asyncToGenerator","container","text","undefined","javascript","isTrueOrOne","emit","_this$componentRef","componentClass","getComponentClass","componentRef","destroy","createAndCompileComponent","instance","error","showErrorModal","ngOnDestroy","_this$componentRef2","_this2","compileInstance","lazyLibraries","getLazyLibraries","CoreCompileHtmlFakeComponent","ongoingLifecycleHooks","Set","injectLibraries","ngOnInit","executeJavascript","name","pendingCall","Promise","resolve","apply","params","then","defer","catch","reject","ngAfterContentInit","callLifecycleHookOverride","ngAfterViewInit","method","has","add","delete","callComponentFunction","callWhenCreated","promise","i0","ɵɵdirectiveInject","ChangeDetectorRef","ElementRef","KeyValueDiffers","selectors","viewQuery","CoreCompileHtmlComponent_Query","rf","ctx","ɵɵelementStart","ɵɵelementContainer","ɵɵelementEnd","ɵɵproperty"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/compile/components/compile-html/compile-html.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n    Component,\n    Input,\n    OnInit,\n    OnChanges,\n    OnDestroy,\n    ViewContainerRef,\n    ViewChild,\n    ComponentRef,\n    SimpleChange,\n    ChangeDetectorRef,\n    ElementRef,\n    Output,\n    EventEmitter,\n    DoCheck,\n    KeyValueDiffers,\n    AfterContentInit,\n    AfterViewInit,\n    Type,\n    KeyValueDiffer,\n} from '@angular/core';\nimport { CorePromisedValue } from '@classes/promised-value';\n\nimport { CoreCompile } from '@features/compile/services/compile';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\n\n/**\n * This component has a behaviour similar to $compile for AngularJS. Given an HTML code, it will compile it so all its\n * components and directives are instantiated.\n *\n * IMPORTANT: Use this component only if it is a must. It will create and compile a new component and module everytime this\n * component is used, so it can slow down the app.\n *\n * This component has its own module to prevent circular dependencies. If you want to use it,\n * you need to import CoreCompileHtmlComponentModule.\n *\n * You can provide some Javascript code (as text) to be executed inside the component. The context of the javascript code (this)\n * will be the component instance created to compile the template. This means your javascript code can interact with the template.\n * The component instance will have most of the providers so you can use them in the javascript code. E.g. if you want to use\n * CoreAppProvider, you can do it with \"this.CoreAppProvider\".\n */\n@Component({\n    selector: 'core-compile-html',\n    template: '<core-loading [hideUntil]=\"loaded\"><ng-container #dynamicComponent /></core-loading>',\n    styles: [':host { display: contents; }'],\n})\nexport class CoreCompileHtmlComponent implements OnChanges, OnDestroy, DoCheck {\n\n    @Input() text!: string; // The HTML text to display.\n    @Input() javascript?: string; // The Javascript to execute in the component.\n    @Input() jsData?: Record<string, unknown>; // Data to pass to the fake component.\n    @Input() extraImports: unknown[] = []; // Extra import modules.\n    @Input() extraProviders: Type<unknown>[] = []; // Extra providers.\n    @Input() forceCompile = false; // Set it to true to force compile even if the text/javascript hasn't changed.\n    @Output() created = new EventEmitter<unknown>(); // Will emit an event when the component is instantiated.\n    @Output() compiling = new EventEmitter<boolean>(); // Event that indicates whether the template is being compiled.\n\n    loaded = false;\n    componentInstance?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n    // Get the container where to put the content.\n    @ViewChild('dynamicComponent', { read: ViewContainerRef }) container?: ViewContainerRef;\n\n    protected componentRef?: ComponentRef<unknown>;\n    protected element: HTMLElement;\n    protected differ: KeyValueDiffer<unknown, unknown>; // To detect changes in the jsData input.\n    protected creatingComponent = false;\n    protected pendingCalls = {};\n\n    constructor(\n        protected changeDetector: ChangeDetectorRef,\n        element: ElementRef,\n        differs: KeyValueDiffers,\n    ) {\n        this.element = element.nativeElement;\n        this.differ = differs.find([]).create();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngDoCheck(): void {\n        if (!this.componentInstance || this.creatingComponent) {\n            return;\n        }\n\n        // Check if there's any change in the jsData object.\n        const changes = this.differ.diff(this.jsData || {});\n        if (changes) {\n            this.setInputData();\n\n            if (this.componentInstance.ngOnChanges) {\n                this.componentInstance.ngOnChanges(CoreDomUtils.createChangesFromKeyValueDiff(changes));\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async ngOnChanges(changes: Record<string, SimpleChange>): Promise<void> {\n        if (!this.container) {\n            return;\n        }\n\n        // Only compile if text/javascript has changed or the forceCompile flag has been set to true.\n        if (this.text !== undefined && (changes.text || changes.javascript ||\n                (changes.forceCompile && CoreUtils.isTrueOrOne(this.forceCompile)))) {\n\n            // Create a new component and a new module.\n            this.creatingComponent = true;\n            this.compiling.emit(true);\n\n            try {\n                const componentClass = await this.getComponentClass();\n\n                // Destroy previous components.\n                this.componentRef?.destroy();\n\n                // Create the component.\n                this.componentRef = await CoreCompile.createAndCompileComponent(\n                    this.text,\n                    componentClass,\n                    this.container,\n                    this.extraImports,\n                );\n                this.componentRef && this.created.emit(this.componentRef.instance);\n\n                this.loaded = true;\n            } catch (error) {\n                CoreDomUtils.showErrorModal(error);\n\n                this.loaded = true;\n            } finally {\n                this.creatingComponent = false;\n                this.compiling.emit(false);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngOnDestroy(): void {\n        this.componentRef?.destroy();\n    }\n\n    /**\n     * Get a class that defines the dynamic component.\n     *\n     * @returns The component class.\n     */\n    protected async getComponentClass(): Promise<Type<unknown>> {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const compileInstance = this;\n        const lazyLibraries = await CoreCompile.getLazyLibraries();\n\n        // Create the component, using the text as the template.\n        return class CoreCompileHtmlFakeComponent implements OnInit, AfterContentInit, AfterViewInit, OnDestroy {\n\n            private ongoingLifecycleHooks: Set<keyof AfterViewInit | keyof AfterContentInit | keyof OnDestroy> = new Set();\n\n            constructor() {\n                // Store this instance so it can be accessed by the outer component.\n                compileInstance.componentInstance = this;\n\n                // Create 2 empty properties that can be used by the template to store data.\n                this['dataObject'] = {};\n                this['dataArray'] = [];\n\n                // Inject the libraries.\n                CoreCompile.injectLibraries(this, [\n                    ...lazyLibraries,\n                    ...compileInstance.extraProviders,\n                ]);\n\n                // Always add these elements, they could be needed on component init (componentObservable).\n                this['ChangeDetectorRef'] = compileInstance.changeDetector;\n                this['componentContainer'] = compileInstance.element;\n\n                // Add the data passed to the component.\n                compileInstance.setInputData();\n            }\n\n            /**\n             * @inheritdoc\n             */\n            ngOnInit(): void {\n                // If there is some javascript to run, do it now.\n                if (compileInstance.javascript) {\n                    CoreCompile.executeJavascript(this, compileInstance.javascript);\n                }\n\n                // Call the pending functions.\n                for (const name in compileInstance.pendingCalls) {\n                    const pendingCall = compileInstance.pendingCalls[name];\n\n                    if (typeof this[name] === 'function') {\n                        // Call the function.\n                        Promise.resolve(this[name].apply(this, pendingCall.params)).then(pendingCall.defer.resolve)\n                            .catch(pendingCall.defer.reject);\n                    } else {\n                        // Function not defined, resolve the promise.\n                        pendingCall.defer.resolve();\n                    }\n                }\n\n                compileInstance.pendingCalls = {};\n            }\n\n            /**\n             * @inheritdoc\n             */\n            ngAfterContentInit(): void {\n                this.callLifecycleHookOverride('ngAfterContentInit');\n            }\n\n            /**\n             * @inheritdoc\n             */\n            ngAfterViewInit(): void {\n                this.callLifecycleHookOverride('ngAfterViewInit');\n            }\n\n            /**\n             * @inheritdoc\n             */\n            ngOnDestroy(): void {\n                this.callLifecycleHookOverride('ngOnDestroy');\n            }\n\n            /**\n             * Call a lifecycle method that can be overriden in plugins.\n             *\n             * This is necessary because overriding lifecycle hooks at runtime does not work in Angular. This may be happening\n             * because lifecycle hooks are special methods treated by the Angular compiler, so it is possible that it's storing\n             * a reference to the method defined during compilation. In order to work around that, this will call the actual method\n             * from the plugin without causing infinite loops in case it wasn't overriden.\n             *\n             * @param method Lifecycle hook method name.\n             */\n            private callLifecycleHookOverride(method: keyof AfterViewInit | keyof AfterContentInit | keyof OnDestroy): void {\n                if (this.ongoingLifecycleHooks.has(method)) {\n                    return;\n                }\n\n                this.ongoingLifecycleHooks.add(method);\n                this[method]();\n                this.ongoingLifecycleHooks.delete(method);\n            }\n\n        };\n    }\n\n    /**\n     * Set the JS data as input data of the component instance.\n     */\n    protected setInputData(): void {\n        if (!this.componentInstance) {\n            return;\n        }\n\n        for (const name in this.jsData) {\n            this.componentInstance[name] = this.jsData[name];\n        }\n    }\n\n    /**\n     * Call a certain function on the component instance.\n     *\n     * @param name Name of the function to call.\n     * @param params List of params to send to the function.\n     * @param callWhenCreated If this param is true and the component hasn't been created yet, call the function\n     *                        once the component has been created.\n     * @returns Result of the call. Undefined if no component instance or the function doesn't exist.\n     */\n    callComponentFunction(name: string, params?: unknown[], callWhenCreated = true): unknown {\n        if (this.componentInstance) {\n            if (typeof this.componentInstance[name] === 'function') {\n                return this.componentInstance[name].apply(this.componentInstance, params);\n            }\n        } else if (callWhenCreated) {\n            // Call it when the component is created.\n\n            if (this.pendingCalls[name]) {\n                // Call already pending, just update the params (allow only 1 call per function until it's initialized).\n                this.pendingCalls[name].params = params;\n\n                return this.pendingCalls[name].defer.promise;\n            }\n\n            const defer = new CorePromisedValue();\n\n            this.pendingCalls[name] = {\n                params,\n                defer,\n            };\n\n            return defer;\n        }\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}