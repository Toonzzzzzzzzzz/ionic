{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreWS } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreFile } from '@services/file';\nimport { CoreError } from '@classes/errors/error';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModBook:';\n/**\n * Service that provides some features for books.\n */\nexport class AddonModBookProvider {\n  /**\n   * Get a book by course module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the book is retrieved.\n   */\n  getBook(courseId, cmId, options = {}) {\n    return this.getBookByField(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a book with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Common WS options.\n   * @returns Promise resolved when the book is retrieved.\n   */\n  getBookByField(courseId, key, value, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this.getBookDataCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModBookProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_book_get_books_by_courses', params, preSets);\n      // Search the book.\n      const book = response.books.find(book => book[key] == value);\n      if (book) {\n        return book;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get cache key for get book data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getBookDataCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'book:' + courseId;\n  }\n  /**\n   * Gets a chapter contents.\n   *\n   * @param contentsMap Contents map returned by getContentsMap.\n   * @param chapterId Chapter to retrieve.\n   * @param moduleId The module ID.\n   * @returns Promise resolved with the contents.\n   */\n  getChapterContent(contentsMap, chapterId, moduleId) {\n    return _asyncToGenerator(function* () {\n      const indexUrl = contentsMap[chapterId] ? contentsMap[chapterId].indexUrl : undefined;\n      if (!indexUrl) {\n        // It shouldn't happen.\n        throw new CoreError('Could not locate the index chapter.');\n      }\n      if (!CoreFile.isAvailable()) {\n        // We return the live URL.\n        return CoreSites.getRequiredCurrentSite().checkAndFixPluginfileURL(indexUrl);\n      }\n      const siteId = CoreSites.getCurrentSiteId();\n      const url = yield CoreFilepool.downloadUrl(siteId, indexUrl, false, AddonModBookProvider.COMPONENT, moduleId);\n      const content = yield CoreWS.getText(url);\n      // Now that we have the content, we update the SRC to point back to the external resource.\n      return CoreDomUtils.restoreSourcesInHtml(content, contentsMap[chapterId].paths);\n    })();\n  }\n  /**\n   * Convert an array of book contents into an object where contents are organized in chapters.\n   * Each chapter has an indexUrl and the list of contents in that chapter.\n   *\n   * @param contents The module contents.\n   * @returns Contents map.\n   */\n  getContentsMap(contents) {\n    const map = {};\n    if (!contents) {\n      return map;\n    }\n    contents.forEach(content => {\n      if (!this.isFileDownloadable(content)) {\n        return;\n      }\n      // Search the chapter number in the filepath.\n      const matches = content.filepath.match(/\\/(\\d+)\\//);\n      if (!matches || !matches[1]) {\n        return;\n      }\n      let key;\n      const chapter = matches[1];\n      const filepathIsChapter = content.filepath == '/' + chapter + '/';\n      // Init the chapter if it's not defined yet.\n      map[chapter] = map[chapter] || {\n        paths: {}\n      };\n      if (content.filename == 'index.html' && filepathIsChapter) {\n        // Index of the chapter, set indexUrl and tags of the chapter.\n        map[chapter].indexUrl = content.fileurl;\n        map[chapter].tags = content.tags;\n        return;\n      }\n      if (filepathIsChapter) {\n        // It's a file in the root folder OR the WS isn't returning the filepath as it should (MDL-53671).\n        // Try to get the path to the file from the URL.\n        const split = content.fileurl.split('mod_book/chapter' + content.filepath);\n        key = split[1] || content.filename; // Use filename if we couldn't find the path.\n      } else {\n        // Remove the chapter folder from the path and add the filename.\n        key = content.filepath.replace('/' + chapter + '/', '') + content.filename;\n      }\n      map[chapter].paths[CoreTextUtils.decodeURIComponent(key)] = content.fileurl;\n    });\n    return map;\n  }\n  /**\n   * Get the first chapter of a book.\n   *\n   * @param chapters The chapters list.\n   * @returns The chapter id.\n   */\n  getFirstChapter(chapters) {\n    if (!chapters || !chapters.length) {\n      return;\n    }\n    return chapters[0].id;\n  }\n  /**\n   * Get last chapter viewed in the app for a book.\n   *\n   * @param id Book instance ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with last chapter viewed, undefined if none.\n   */\n  getLastChapterViewed(id, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = yield site.getLastViewed(AddonModBookProvider.COMPONENT, id);\n      const chapterId = Number(entry === null || entry === void 0 ? void 0 : entry.value);\n      return isNaN(chapterId) ? undefined : chapterId;\n    })();\n  }\n  /**\n   * Get the book toc as an array.\n   *\n   * @param contents The module contents.\n   * @returns The toc.\n   */\n  getToc(contents) {\n    if (!contents || !contents.length || contents[0].content === undefined) {\n      return [];\n    }\n    return CoreTextUtils.parseJSON(contents[0].content, []);\n  }\n  /**\n   * Get the book toc as an array of chapters (not nested).\n   *\n   * @param contents The module contents.\n   * @returns The toc as a list.\n   */\n  getTocList(contents) {\n    // Convenience function to get chapter info.\n    const getChapterInfo = (chapter, chapterNumber, previousNumber = '') => {\n      const hidden = !!parseInt(chapter.hidden, 10);\n      const fullChapterNumber = previousNumber + (hidden ? 'x.' : chapterNumber + '.');\n      return {\n        id: parseInt(chapter.href.replace('/index.html', ''), 10),\n        title: chapter.title,\n        level: chapter.level,\n        indexNumber: fullChapterNumber,\n        hidden: hidden\n      };\n    };\n    const chapters = [];\n    const toc = this.getToc(contents);\n    let chapterNumber = 1;\n    toc.forEach(chapter => {\n      const tocChapter = getChapterInfo(chapter, chapterNumber);\n      // Add the chapter to the list.\n      chapters.push(tocChapter);\n      if (chapter.subitems) {\n        let subChapterNumber = 1;\n        // Add all the subchapters to the list.\n        chapter.subitems.forEach(subChapter => {\n          chapters.push(getChapterInfo(subChapter, subChapterNumber, tocChapter.indexNumber));\n          subChapterNumber++;\n        });\n      }\n      if (!parseInt(chapter.hidden, 10)) {\n        chapterNumber++;\n      }\n    });\n    return chapters;\n  }\n  /**\n   * Invalidates book data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateBookData(courseId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this2.getBookDataCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID of the module.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const promises = [];\n    promises.push(this.invalidateBookData(courseId, siteId));\n    promises.push(CoreFilepool.invalidateFilesByComponent(siteId, AddonModBookProvider.COMPONENT, moduleId));\n    promises.push(CoreCourse.invalidateModule(moduleId, siteId));\n    return CoreUtils.allPromises(promises);\n  }\n  /**\n   * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.\n   *\n   * @param file File to check.\n   * @returns Whether it's downloadable.\n   */\n  isFileDownloadable(file) {\n    return file.type === 'file';\n  }\n  /**\n   * Return whether or not the plugin is enabled.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n   */\n  isPluginEnabled(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.canDownloadFiles();\n    })();\n  }\n  /**\n   * Report a book as being viewed.\n   *\n   * @param id Module ID.\n   * @param chapterId Chapter ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(id, chapterId, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        bookid: id,\n        chapterid: chapterId\n      };\n      yield CoreCourseLogHelper.log('mod_book_view_book', params, AddonModBookProvider.COMPONENT, id, siteId);\n    })();\n  }\n  /**\n   * Store last chapter viewed in the app for a book.\n   *\n   * @param id Book instance ID.\n   * @param chapterId Chapter ID.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with last chapter viewed, undefined if none.\n   */\n  storeLastChapterViewed(id, chapterId, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.storeLastViewed(AddonModBookProvider.COMPONENT, id, chapterId, {\n        data: String(courseId)\n      });\n    })();\n  }\n}\n_class = AddonModBookProvider;\n_class.COMPONENT = 'mmaModBook';\n_class.ɵfac = function AddonModBookProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModBook = makeSingleton(AddonModBookProvider);","map":{"version":3,"names":["CoreSites","CoreSite","CoreWS","makeSingleton","Translate","CoreCourseLogHelper","CoreCourse","CoreUtils","CoreFilepool","CoreTextUtils","CoreDomUtils","CoreFile","CoreError","ROOT_CACHE_KEY","AddonModBookProvider","getBook","courseId","cmId","options","getBookByField","key","value","_this","_asyncToGenerator","site","getSite","siteId","params","courseids","preSets","_objectSpread","cacheKey","getBookDataCacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","response","read","book","books","find","instant","getChapterContent","contentsMap","chapterId","moduleId","indexUrl","undefined","isAvailable","getRequiredCurrentSite","checkAndFixPluginfileURL","getCurrentSiteId","url","downloadUrl","content","getText","restoreSourcesInHtml","paths","getContentsMap","contents","map","forEach","isFileDownloadable","matches","filepath","match","chapter","filepathIsChapter","filename","fileurl","tags","split","replace","decodeURIComponent","getFirstChapter","chapters","length","id","getLastChapterViewed","entry","getLastViewed","Number","isNaN","getToc","parseJSON","getTocList","getChapterInfo","chapterNumber","previousNumber","hidden","parseInt","fullChapterNumber","href","title","level","indexNumber","toc","tocChapter","push","subitems","subChapterNumber","subChapter","invalidateBookData","_this2","invalidateWsCacheForKey","invalidateContent","promises","invalidateFilesByComponent","invalidateModule","allPromises","file","type","isPluginEnabled","canDownloadFiles","logView","bookid","chapterid","log","storeLastChapterViewed","storeLastViewed","data","String","_class","factory","ɵfac","providedIn","AddonModBook"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/book/services/book.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites, CoreSitesCommonWSOptions } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreTagItem } from '@features/tag/services/tag';\nimport { CoreWSExternalWarning, CoreWSExternalFile, CoreWS } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreCourse, CoreCourseModuleContentFile } from '@features/course/services/course';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreFile } from '@services/file';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\n/**\n * Constants to define how the chapters and subchapters of a book should be displayed in that table of contents.\n */\nexport const enum AddonModBookNumbering {\n    NONE = 0,\n    NUMBERS = 1,\n    BULLETS = 2,\n    INDENTED = 3,\n}\n\n/**\n * Constants to define the navigation style used within a book.\n */\nexport const enum AddonModBookNavStyle {\n    TOC_ONLY = 0,\n    IMAGE = 1,\n    TEXT = 2,\n}\n\nconst ROOT_CACHE_KEY = 'mmaModBook:';\n\n/**\n * Service that provides some features for books.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModBookProvider {\n\n    static readonly COMPONENT = 'mmaModBook';\n\n    /**\n     * Get a book by course module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the book is retrieved.\n     */\n    getBook(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModBookBookWSData> {\n        return this.getBookByField(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a book with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Common WS options.\n     * @returns Promise resolved when the book is retrieved.\n     */\n    protected async getBookByField(\n        courseId: number,\n        key: string,\n        value: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModBookBookWSData> {\n\n        const site = await CoreSites.getSite(options.siteId);\n        const params: AddonModBookGetBooksByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getBookDataCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModBookProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        const response: AddonModBookGetBooksByCoursesWSResponse = await site.read('mod_book_get_books_by_courses', params, preSets);\n\n        // Search the book.\n        const book = response.books.find((book) => book[key] == value);\n        if (book) {\n            return book;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get cache key for get book data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getBookDataCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'book:' + courseId;\n    }\n\n    /**\n     * Gets a chapter contents.\n     *\n     * @param contentsMap Contents map returned by getContentsMap.\n     * @param chapterId Chapter to retrieve.\n     * @param moduleId The module ID.\n     * @returns Promise resolved with the contents.\n     */\n    async getChapterContent(contentsMap: AddonModBookContentsMap, chapterId: number, moduleId: number): Promise<string> {\n\n        const indexUrl = contentsMap[chapterId] ? contentsMap[chapterId].indexUrl : undefined;\n        if (!indexUrl) {\n            // It shouldn't happen.\n            throw new CoreError('Could not locate the index chapter.');\n        }\n\n        if (!CoreFile.isAvailable()) {\n            // We return the live URL.\n            return CoreSites.getRequiredCurrentSite().checkAndFixPluginfileURL(indexUrl);\n        }\n\n        const siteId = CoreSites.getCurrentSiteId();\n\n        const url = await CoreFilepool.downloadUrl(siteId, indexUrl, false, AddonModBookProvider.COMPONENT, moduleId);\n\n        const content = await CoreWS.getText(url);\n\n        // Now that we have the content, we update the SRC to point back to the external resource.\n        return CoreDomUtils.restoreSourcesInHtml(content, contentsMap[chapterId].paths);\n    }\n\n    /**\n     * Convert an array of book contents into an object where contents are organized in chapters.\n     * Each chapter has an indexUrl and the list of contents in that chapter.\n     *\n     * @param contents The module contents.\n     * @returns Contents map.\n     */\n    getContentsMap(contents: CoreCourseModuleContentFile[]): AddonModBookContentsMap {\n        const map: AddonModBookContentsMap = {};\n\n        if (!contents) {\n            return map;\n        }\n\n        contents.forEach((content) => {\n            if (!this.isFileDownloadable(content)) {\n                return;\n            }\n\n            // Search the chapter number in the filepath.\n            const matches = content.filepath.match(/\\/(\\d+)\\//);\n            if (!matches || !matches[1]) {\n                return;\n            }\n            let key: string;\n            const chapter: string = matches[1];\n            const filepathIsChapter = content.filepath == '/' + chapter + '/';\n\n            // Init the chapter if it's not defined yet.\n            map[chapter] = map[chapter] || { paths: {} };\n\n            if (content.filename == 'index.html' && filepathIsChapter) {\n                // Index of the chapter, set indexUrl and tags of the chapter.\n                map[chapter].indexUrl = content.fileurl;\n                map[chapter].tags = content.tags;\n\n                return;\n            }\n\n            if (filepathIsChapter) {\n                // It's a file in the root folder OR the WS isn't returning the filepath as it should (MDL-53671).\n                // Try to get the path to the file from the URL.\n                const split = content.fileurl.split('mod_book/chapter' + content.filepath);\n                key = split[1] || content.filename; // Use filename if we couldn't find the path.\n            } else {\n                // Remove the chapter folder from the path and add the filename.\n                key = content.filepath.replace('/' + chapter + '/', '') + content.filename;\n            }\n\n            map[chapter].paths[CoreTextUtils.decodeURIComponent(key)] = content.fileurl;\n        });\n\n        return map;\n    }\n\n    /**\n     * Get the first chapter of a book.\n     *\n     * @param chapters The chapters list.\n     * @returns The chapter id.\n     */\n    getFirstChapter(chapters: AddonModBookTocChapter[]): number | undefined {\n        if (!chapters || !chapters.length) {\n            return;\n        }\n\n        return chapters[0].id;\n    }\n\n    /**\n     * Get last chapter viewed in the app for a book.\n     *\n     * @param id Book instance ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with last chapter viewed, undefined if none.\n     */\n    async getLastChapterViewed(id: number, siteId?: string): Promise<number | undefined> {\n        const site = await CoreSites.getSite(siteId);\n        const entry = await site.getLastViewed(AddonModBookProvider.COMPONENT, id);\n\n        const chapterId = Number(entry?.value);\n\n        return isNaN(chapterId) ? undefined : chapterId;\n    }\n\n    /**\n     * Get the book toc as an array.\n     *\n     * @param contents The module contents.\n     * @returns The toc.\n     */\n    getToc(contents: CoreCourseModuleContentFile[]): AddonModBookTocChapterParsed[] {\n        if (!contents || !contents.length || contents[0].content === undefined) {\n            return [];\n        }\n\n        return CoreTextUtils.parseJSON(contents[0].content, []);\n    }\n\n    /**\n     * Get the book toc as an array of chapters (not nested).\n     *\n     * @param contents The module contents.\n     * @returns The toc as a list.\n     */\n    getTocList(contents: CoreCourseModuleContentFile[]): AddonModBookTocChapter[] {\n        // Convenience function to get chapter info.\n        const getChapterInfo = (\n            chapter: AddonModBookTocChapterParsed,\n            chapterNumber: number,\n            previousNumber: string = '',\n        ): AddonModBookTocChapter => {\n            const hidden = !!parseInt(chapter.hidden, 10);\n\n            const fullChapterNumber = previousNumber + (hidden ? 'x.' : chapterNumber + '.');\n\n            return {\n                id: parseInt(chapter.href.replace('/index.html', ''), 10),\n                title: chapter.title,\n                level: chapter.level,\n                indexNumber: fullChapterNumber,\n                hidden: hidden,\n            };\n        };\n\n        const chapters: AddonModBookTocChapter[] = [];\n        const toc = this.getToc(contents);\n\n        let chapterNumber = 1;\n        toc.forEach((chapter) => {\n            const tocChapter = getChapterInfo(chapter, chapterNumber);\n\n            // Add the chapter to the list.\n            chapters.push(tocChapter);\n\n            if (chapter.subitems) {\n                let subChapterNumber = 1;\n                // Add all the subchapters to the list.\n                chapter.subitems.forEach((subChapter) => {\n                    chapters.push(getChapterInfo(subChapter, subChapterNumber, tocChapter.indexNumber));\n                    subChapterNumber++;\n                });\n            }\n\n            if (!parseInt(chapter.hidden, 10)) {\n                chapterNumber++;\n            }\n        });\n\n        return chapters;\n    }\n\n    /**\n     * Invalidates book data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateBookData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getBookDataCacheKey(courseId));\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID of the module.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const promises: Promise<void>[] = [];\n\n        promises.push(this.invalidateBookData(courseId, siteId));\n        promises.push(CoreFilepool.invalidateFilesByComponent(siteId, AddonModBookProvider.COMPONENT, moduleId));\n        promises.push(CoreCourse.invalidateModule(moduleId, siteId));\n\n        return CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.\n     *\n     * @param file File to check.\n     * @returns Whether it's downloadable.\n     */\n    isFileDownloadable(file: CoreCourseModuleContentFile): boolean {\n        return file.type === 'file';\n    }\n\n    /**\n     * Return whether or not the plugin is enabled.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n     */\n    async isPluginEnabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.canDownloadFiles();\n    }\n\n    /**\n     * Report a book as being viewed.\n     *\n     * @param id Module ID.\n     * @param chapterId Chapter ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logView(id: number, chapterId?: number, siteId?: string): Promise<void> {\n        const params: AddonModBookViewBookWSParams = {\n            bookid: id,\n            chapterid: chapterId,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_book_view_book',\n            params,\n            AddonModBookProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Store last chapter viewed in the app for a book.\n     *\n     * @param id Book instance ID.\n     * @param chapterId Chapter ID.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with last chapter viewed, undefined if none.\n     */\n    async storeLastChapterViewed(id: number, chapterId: number, courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.storeLastViewed(AddonModBookProvider.COMPONENT, id, chapterId, { data: String(courseId) });\n    }\n\n}\n\nexport const AddonModBook = makeSingleton(AddonModBookProvider);\n\n/**\n * A book chapter inside the toc list.\n */\nexport type AddonModBookTocChapter = {\n    id: number; // ID to identify the chapter.\n    title: string; // Chapter's title.\n    level: number; // The chapter's level.\n    hidden: boolean; // The chapter is hidden.\n    indexNumber: string; // The chapter's number'.\n};\n\n/**\n * A book chapter parsed from JSON.\n */\ntype AddonModBookTocChapterParsed = {\n    title: string; // Chapter's title.\n    level: number; // The chapter's level.\n    hidden: string; // The chapter is hidden.\n    href: string;\n    subitems: AddonModBookTocChapterParsed[];\n};\n\n/**\n * Map of book contents. For each chapter it has its index URL and the list of paths of the files the chapter has. Each path\n * is identified by the relative path in the book, and the value is the URL of the file.\n */\nexport type AddonModBookContentsMap = {\n    [chapter: string]: {\n        indexUrl?: string;\n        paths: {[path: string]: string};\n        tags?: CoreTagItem[];\n    };\n};\n\n/**\n * Book returned by mod_book_get_books_by_courses.\n */\nexport type AddonModBookBookWSData = {\n    id: number; // Book id.\n    coursemodule: number; // Course module id.\n    course: number; // Course id.\n    name: string; // Book name.\n    intro: string; // The Book intro.\n    introformat: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    numbering: number; // Book numbering configuration.\n    navstyle: number; // Book navigation style configuration.\n    customtitles: number; // Book custom titles type.\n    revision?: number; // Book revision.\n    timecreated?: number; // Time of creation.\n    timemodified?: number; // Time of last modification.\n    section?: number; // Course section id.\n    visible?: boolean; // Visible.\n    groupmode?: number; // Group mode.\n    groupingid?: number; // Group id.\n};\n\n/**\n * Params of mod_book_get_books_by_courses WS.\n */\ntype AddonModBookGetBooksByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_book_get_books_by_courses WS.\n */\ntype AddonModBookGetBooksByCoursesWSResponse = {\n    books: AddonModBookBookWSData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_book_view_book WS.\n */\ntype AddonModBookViewBookWSParams = {\n    bookid: number; // Book instance id.\n    chapterid?: number; // Chapter id.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}