{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CorePath } from '@singletons/path';\nimport { OFFLINE_ENTRIES_TABLE_NAME } from './database/glossary';\nimport { GLOSSARY_ENTRY_ADDED, GLOSSARY_ENTRY_DELETED, GLOSSARY_ENTRY_UPDATED } from './glossary';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline glossary.\n */\nexport class AddonModGlossaryOfflineProvider {\n  /**\n   * Delete an offline entry.\n   *\n   * @param glossaryId Glossary ID.\n   * @param timecreated The time the entry was created.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteOfflineEntry(glossaryId, timecreated, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        glossaryid: glossaryId,\n        timecreated: timecreated\n      };\n      yield site.getDb().deleteRecords(OFFLINE_ENTRIES_TABLE_NAME, conditions);\n      CoreEvents.trigger(GLOSSARY_ENTRY_DELETED, {\n        glossaryId,\n        timecreated\n      });\n    })();\n  }\n  /**\n   * Get all the stored offline entries from all the glossaries.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with entries.\n   */\n  getAllOfflineEntries(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const records = yield site.getDb().getRecords(OFFLINE_ENTRIES_TABLE_NAME);\n      return records.map(record => _this.parseRecord(record));\n    })();\n  }\n  /**\n   * Get a stored offline entry.\n   *\n   * @param glossaryId Glossary ID.\n   * @param timeCreated The time the entry was created.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with entry.\n   */\n  getOfflineEntry(glossaryId, timeCreated, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        glossaryid: glossaryId,\n        timecreated: timeCreated\n      };\n      const record = yield site.getDb().getRecord(OFFLINE_ENTRIES_TABLE_NAME, conditions);\n      return _this2.parseRecord(record);\n    })();\n  }\n  /**\n   * Get all the stored add entry data from a certain glossary.\n   *\n   * @param glossaryId Glossary ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the entries belong to. If not defined, current user in site.\n   * @returns Promise resolved with entries.\n   */\n  getGlossaryOfflineEntries(glossaryId, siteId, userId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        glossaryid: glossaryId,\n        userid: userId || site.getUserId()\n      };\n      const records = yield site.getDb().getRecords(OFFLINE_ENTRIES_TABLE_NAME, conditions);\n      return records.map(record => _this3.parseRecord(record));\n    })();\n  }\n  /**\n   * Check if a concept is used offline.\n   *\n   * @param glossaryId Glossary ID.\n   * @param concept Concept to check.\n   * @param timeCreated Time of the entry we are editing.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if concept is found, false otherwise.\n   */\n  isConceptUsed(glossaryId, concept, timeCreated, siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const site = yield CoreSites.getSite(siteId);\n        const conditions = {\n          glossaryid: glossaryId,\n          concept: concept\n        };\n        const entries = yield site.getDb().getRecords(OFFLINE_ENTRIES_TABLE_NAME, conditions);\n        if (!entries.length) {\n          return false;\n        }\n        if (entries.length > 1 || !timeCreated) {\n          return true;\n        }\n        // If there's only one entry, check that is not the one we are editing.\n        return entries[0].timecreated !== timeCreated;\n      } catch (_unused) {\n        // No offline data found, return false.\n        return false;\n      }\n    })();\n  }\n  /**\n   * Save an offline entry to be sent later.\n   *\n   * @param glossaryId Glossary ID.\n   * @param concept Glossary entry concept.\n   * @param definition Glossary entry concept definition.\n   * @param courseId Course ID of the glossary.\n   * @param timecreated The time the entry was created. If not defined, current time.\n   * @param options Options for the entry.\n   * @param attachments Result of CoreFileUploaderProvider#storeFilesToUpload for attachments.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the entry belong to. If not defined, current user in site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  addOfflineEntry(glossaryId, concept, definition, courseId, timecreated, options, attachments, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        glossaryid: glossaryId,\n        courseid: courseId,\n        concept: concept,\n        definition: definition,\n        definitionformat: 'html',\n        options: JSON.stringify(options || {}),\n        attachments: JSON.stringify(attachments),\n        userid: userId || site.getUserId(),\n        timecreated\n      };\n      yield site.getDb().insertRecord(OFFLINE_ENTRIES_TABLE_NAME, entry);\n      CoreEvents.trigger(GLOSSARY_ENTRY_ADDED, {\n        glossaryId,\n        timecreated\n      }, siteId);\n      return false;\n    })();\n  }\n  /**\n   * Update an offline entry to be sent later.\n   *\n   * @param originalEntry Original entry data.\n   * @param concept Glossary entry concept.\n   * @param definition Glossary entry concept definition.\n   * @param options Options for the entry.\n   * @param attachments Result of CoreFileUploaderProvider#storeFilesToUpload for attachments.\n   */\n  updateOfflineEntry(originalEntry, concept, definition, options, attachments) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite();\n      const entry = {\n        concept: concept,\n        definition: definition,\n        definitionformat: 'html',\n        options: JSON.stringify(options || {}),\n        attachments: JSON.stringify(attachments)\n      };\n      yield site.getDb().updateRecords(OFFLINE_ENTRIES_TABLE_NAME, entry, _objectSpread(_objectSpread({}, originalEntry), {}, {\n        userid: site.getUserId()\n      }));\n      CoreEvents.trigger(GLOSSARY_ENTRY_UPDATED, {\n        glossaryId: originalEntry.glossaryid,\n        timecreated: originalEntry.timecreated\n      });\n    })();\n  }\n  /**\n   * Get the path to the folder where to store files for offline attachments in a glossary.\n   *\n   * @param glossaryId Glossary ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getGlossaryFolder(glossaryId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const siteFolderPath = CoreFile.getSiteFolder(site.getId());\n      const folderPath = 'offlineglossary/' + glossaryId;\n      return CorePath.concatenatePaths(siteFolderPath, folderPath);\n    })();\n  }\n  /**\n   * Get the path to the folder where to store files for an offline entry.\n   *\n   * @param glossaryId Glossary ID.\n   * @param concept The name of the entry.\n   * @param timeCreated Time to allow duplicated entries.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getEntryFolder(glossaryId, concept, timeCreated, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const folderPath = yield _this4.getGlossaryFolder(glossaryId, siteId);\n      return CorePath.concatenatePaths(folderPath, 'newentry_' + concept + '_' + timeCreated);\n    })();\n  }\n  /**\n   * Parse \"options\" and \"attachments\" columns of a fetched record.\n   *\n   * @param record Record object\n   * @returns Record object with columns parsed.\n   */\n  parseRecord(record) {\n    return Object.assign(record, {\n      options: CoreTextUtils.parseJSON(record.options),\n      attachments: record.attachments ? CoreTextUtils.parseJSON(record.attachments) : undefined\n    });\n  }\n}\n_class = AddonModGlossaryOfflineProvider;\n_class.ɵfac = function AddonModGlossaryOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModGlossaryOffline = makeSingleton(AddonModGlossaryOfflineProvider);","map":{"version":3,"names":["CoreFile","CoreSites","CoreTextUtils","makeSingleton","CoreEvents","CorePath","OFFLINE_ENTRIES_TABLE_NAME","GLOSSARY_ENTRY_ADDED","GLOSSARY_ENTRY_DELETED","GLOSSARY_ENTRY_UPDATED","AddonModGlossaryOfflineProvider","deleteOfflineEntry","glossaryId","timecreated","siteId","_asyncToGenerator","site","getSite","conditions","glossaryid","getDb","deleteRecords","trigger","getAllOfflineEntries","_this","records","getRecords","map","record","parseRecord","getOfflineEntry","timeCreated","_this2","getRecord","getGlossaryOfflineEntries","userId","_this3","userid","getUserId","isConceptUsed","concept","entries","length","_unused","addOfflineEntry","definition","courseId","options","attachments","entry","courseid","definitionformat","JSON","stringify","insertRecord","updateOfflineEntry","originalEntry","updateRecords","_objectSpread","getGlossaryFolder","siteFolderPath","getSiteFolder","getId","folderPath","concatenatePaths","getEntryFolder","_this4","Object","assign","parseJSON","undefined","factory","ɵfac","providedIn","AddonModGlossaryOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/glossary/services/glossary-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreFileUploaderStoreFilesResult } from '@features/fileuploader/services/fileuploader';\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CorePath } from '@singletons/path';\nimport { AddonModGlossaryOfflineEntryDBRecord, OFFLINE_ENTRIES_TABLE_NAME } from './database/glossary';\nimport { AddonModGlossaryEntryOption, GLOSSARY_ENTRY_ADDED, GLOSSARY_ENTRY_DELETED, GLOSSARY_ENTRY_UPDATED } from './glossary';\n\n/**\n * Service to handle offline glossary.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModGlossaryOfflineProvider {\n\n    /**\n     * Delete an offline entry.\n     *\n     * @param glossaryId Glossary ID.\n     * @param timecreated The time the entry was created.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    async deleteOfflineEntry(glossaryId: number, timecreated: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModGlossaryOfflineEntryDBRecord> = {\n            glossaryid: glossaryId,\n            timecreated: timecreated,\n        };\n\n        await site.getDb().deleteRecords(OFFLINE_ENTRIES_TABLE_NAME, conditions);\n\n        CoreEvents.trigger(GLOSSARY_ENTRY_DELETED, { glossaryId, timecreated });\n    }\n\n    /**\n     * Get all the stored offline entries from all the glossaries.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with entries.\n     */\n    async getAllOfflineEntries(siteId?: string): Promise<AddonModGlossaryOfflineEntry[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const records = await site.getDb().getRecords<AddonModGlossaryOfflineEntryDBRecord>(OFFLINE_ENTRIES_TABLE_NAME);\n\n        return records.map(record => this.parseRecord(record));\n    }\n\n    /**\n     * Get a stored offline entry.\n     *\n     * @param glossaryId Glossary ID.\n     * @param timeCreated The time the entry was created.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with entry.\n     */\n    async getOfflineEntry(\n        glossaryId: number,\n        timeCreated: number,\n        siteId?: string,\n    ): Promise<AddonModGlossaryOfflineEntry> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModGlossaryOfflineEntryDBRecord> = {\n            glossaryid: glossaryId,\n            timecreated: timeCreated,\n        };\n\n        const record = await site.getDb().getRecord<AddonModGlossaryOfflineEntryDBRecord>(OFFLINE_ENTRIES_TABLE_NAME, conditions);\n\n        return this.parseRecord(record);\n    }\n\n    /**\n     * Get all the stored add entry data from a certain glossary.\n     *\n     * @param glossaryId Glossary ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the entries belong to. If not defined, current user in site.\n     * @returns Promise resolved with entries.\n     */\n    async getGlossaryOfflineEntries(glossaryId: number, siteId?: string, userId?: number): Promise<AddonModGlossaryOfflineEntry[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModGlossaryOfflineEntryDBRecord> = {\n            glossaryid: glossaryId,\n            userid: userId || site.getUserId(),\n        };\n\n        const records = await site.getDb().getRecords<AddonModGlossaryOfflineEntryDBRecord>(OFFLINE_ENTRIES_TABLE_NAME, conditions);\n\n        return records.map(record => this.parseRecord(record));\n    }\n\n    /**\n     * Check if a concept is used offline.\n     *\n     * @param glossaryId Glossary ID.\n     * @param concept Concept to check.\n     * @param timeCreated Time of the entry we are editing.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if concept is found, false otherwise.\n     */\n    async isConceptUsed(glossaryId: number, concept: string, timeCreated?: number, siteId?: string): Promise<boolean> {\n        try {\n            const site = await CoreSites.getSite(siteId);\n\n            const conditions: Partial<AddonModGlossaryOfflineEntryDBRecord> = {\n                glossaryid: glossaryId,\n                concept: concept,\n            };\n\n            const entries =\n                await site.getDb().getRecords<AddonModGlossaryOfflineEntryDBRecord>(OFFLINE_ENTRIES_TABLE_NAME, conditions);\n\n            if (!entries.length) {\n                return false;\n            }\n\n            if (entries.length > 1 || !timeCreated) {\n                return true;\n            }\n\n            // If there's only one entry, check that is not the one we are editing.\n            return entries[0].timecreated !== timeCreated;\n        } catch {\n            // No offline data found, return false.\n            return false;\n        }\n    }\n\n    /**\n     * Save an offline entry to be sent later.\n     *\n     * @param glossaryId Glossary ID.\n     * @param concept Glossary entry concept.\n     * @param definition Glossary entry concept definition.\n     * @param courseId Course ID of the glossary.\n     * @param timecreated The time the entry was created. If not defined, current time.\n     * @param options Options for the entry.\n     * @param attachments Result of CoreFileUploaderProvider#storeFilesToUpload for attachments.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the entry belong to. If not defined, current user in site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async addOfflineEntry(\n        glossaryId: number,\n        concept: string,\n        definition: string,\n        courseId: number,\n        timecreated: number,\n        options?: Record<string, AddonModGlossaryEntryOption>,\n        attachments?: CoreFileUploaderStoreFilesResult,\n        siteId?: string,\n        userId?: number,\n    ): Promise<false> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entry: AddonModGlossaryOfflineEntryDBRecord = {\n            glossaryid: glossaryId,\n            courseid: courseId,\n            concept: concept,\n            definition: definition,\n            definitionformat: 'html',\n            options: JSON.stringify(options || {}),\n            attachments: JSON.stringify(attachments),\n            userid: userId || site.getUserId(),\n            timecreated,\n        };\n\n        await site.getDb().insertRecord(OFFLINE_ENTRIES_TABLE_NAME, entry);\n\n        CoreEvents.trigger(GLOSSARY_ENTRY_ADDED, { glossaryId, timecreated }, siteId);\n\n        return false;\n    }\n\n    /**\n     * Update an offline entry to be sent later.\n     *\n     * @param originalEntry Original entry data.\n     * @param concept Glossary entry concept.\n     * @param definition Glossary entry concept definition.\n     * @param options Options for the entry.\n     * @param attachments Result of CoreFileUploaderProvider#storeFilesToUpload for attachments.\n     */\n    async updateOfflineEntry(\n        originalEntry: Pick< AddonModGlossaryOfflineEntryDBRecord, 'glossaryid'|'courseid'|'concept'|'timecreated'>,\n        concept: string,\n        definition: string,\n        options?: Record<string, AddonModGlossaryEntryOption>,\n        attachments?: CoreFileUploaderStoreFilesResult,\n    ): Promise<void> {\n        const site = await CoreSites.getSite();\n        const entry: Omit<AddonModGlossaryOfflineEntryDBRecord, 'courseid'|'glossaryid'|'userid'|'timecreated'> = {\n            concept: concept,\n            definition: definition,\n            definitionformat: 'html',\n            options: JSON.stringify(options || {}),\n            attachments: JSON.stringify(attachments),\n        };\n\n        await site.getDb().updateRecords(OFFLINE_ENTRIES_TABLE_NAME, entry, {\n            ...originalEntry,\n            userid: site.getUserId(),\n        });\n\n        CoreEvents.trigger(GLOSSARY_ENTRY_UPDATED, {\n            glossaryId: originalEntry.glossaryid,\n            timecreated: originalEntry.timecreated,\n        });\n    }\n\n    /**\n     * Get the path to the folder where to store files for offline attachments in a glossary.\n     *\n     * @param glossaryId Glossary ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    async getGlossaryFolder(glossaryId: number, siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n\n        const siteFolderPath = CoreFile.getSiteFolder(site.getId());\n        const folderPath = 'offlineglossary/' + glossaryId;\n\n        return CorePath.concatenatePaths(siteFolderPath, folderPath);\n    }\n\n    /**\n     * Get the path to the folder where to store files for an offline entry.\n     *\n     * @param glossaryId Glossary ID.\n     * @param concept The name of the entry.\n     * @param timeCreated Time to allow duplicated entries.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    async getEntryFolder(glossaryId: number, concept: string, timeCreated: number, siteId?: string): Promise<string> {\n        const folderPath = await this.getGlossaryFolder(glossaryId, siteId);\n\n        return CorePath.concatenatePaths(folderPath, 'newentry_' + concept + '_' + timeCreated);\n    }\n\n    /**\n     * Parse \"options\" and \"attachments\" columns of a fetched record.\n     *\n     * @param record Record object\n     * @returns Record object with columns parsed.\n     */\n    protected parseRecord(record: AddonModGlossaryOfflineEntryDBRecord): AddonModGlossaryOfflineEntry {\n        return Object.assign(record, {\n            options: <Record<string, AddonModGlossaryEntryOption>> CoreTextUtils.parseJSON(record.options),\n            attachments: record.attachments ?\n                <CoreFileUploaderStoreFilesResult> CoreTextUtils.parseJSON(record.attachments) : undefined,\n        });\n    }\n\n}\n\nexport const AddonModGlossaryOffline = makeSingleton(AddonModGlossaryOfflineProvider);\n\n/**\n * Glossary offline entry with parsed data.\n */\nexport type AddonModGlossaryOfflineEntry = Omit<AddonModGlossaryOfflineEntryDBRecord, 'options'|'attachments'> & {\n    options: Record<string, AddonModGlossaryEntryOption>;\n    attachments?: CoreFileUploaderStoreFilesResult;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}