{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { SEARCH_HISTORY_TABLE_NAME } from './search-history-db';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\n/**\n * Service that enables adding a history to a search box.\n */\nexport class CoreSearchHistoryProvider {\n  /**\n   * Get a search area history sorted by use.\n   *\n   * @param searchArea Search Area Name.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the list of items when done.\n   */\n  getSearchHistory(searchArea, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        searcharea: searchArea\n      };\n      const history = yield site.getDb().getRecords(SEARCH_HISTORY_TABLE_NAME, conditions);\n      // Sorting by last used DESC.\n      return history.sort((a, b) => (b.lastused || 0) - (a.lastused || 0));\n    })();\n  }\n  /**\n   * Controls search limit and removes the last item if overflows.\n   *\n   * @param searchArea Search area to control\n   * @param db SQLite DB where to perform the search.\n   * @returns Resolved when done.\n   */\n  controlSearchLimit(searchArea, db) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const items = yield _this.getSearchHistory(searchArea);\n      if (items.length > CoreSearchHistoryProvider.HISTORY_LIMIT) {\n        // Over the limit. Remove the last.\n        const lastItem = items.pop();\n        if (!lastItem) {\n          return;\n        }\n        const searchItem = {\n          searcharea: lastItem.searcharea,\n          searchedtext: lastItem.searchedtext\n        };\n        yield db.deleteRecords(SEARCH_HISTORY_TABLE_NAME, searchItem);\n      }\n    })();\n  }\n  /**\n   * Updates the search history item if exists.\n   *\n   * @param searchArea Area where the search has been performed.\n   * @param text Text of the performed text.\n   * @param db SQLite DB where to perform the search.\n   * @returns True if exists, false otherwise.\n   */\n  updateExistingItem(searchArea, text, db) {\n    return _asyncToGenerator(function* () {\n      const searchItem = {\n        searcharea: searchArea,\n        searchedtext: text\n      };\n      try {\n        const existingItem = yield db.getRecord(SEARCH_HISTORY_TABLE_NAME, searchItem);\n        // If item exist, update time and number of times searched.\n        existingItem.lastused = Date.now();\n        existingItem.times++;\n        yield db.updateRecords(SEARCH_HISTORY_TABLE_NAME, existingItem, searchItem);\n        return true;\n      } catch (_unused) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Inserts a searched term on the history.\n   *\n   * @param searchArea Area where the search has been performed.\n   * @param text Text of the performed text.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  insertOrUpdateSearchText(searchArea, text, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const db = site.getDb();\n      const exists = yield _this2.updateExistingItem(searchArea, text, db);\n      if (!exists) {\n        // If item is new, control the history does not goes over the limit.\n        const searchItem = {\n          searcharea: searchArea,\n          searchedtext: text,\n          lastused: Date.now(),\n          times: 1\n        };\n        yield db.insertRecord(SEARCH_HISTORY_TABLE_NAME, searchItem);\n        yield _this2.controlSearchLimit(searchArea, db);\n      }\n    })();\n  }\n}\n_class = CoreSearchHistoryProvider;\n_class.HISTORY_LIMIT = 10;\n_class.ɵfac = function CoreSearchHistoryProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreSearchHistory = makeSingleton(CoreSearchHistoryProvider);","map":{"version":3,"names":["CoreSites","SEARCH_HISTORY_TABLE_NAME","makeSingleton","CoreSearchHistoryProvider","getSearchHistory","searchArea","siteId","_asyncToGenerator","site","getSite","conditions","searcharea","history","getDb","getRecords","sort","a","b","lastused","controlSearchLimit","db","_this","items","length","HISTORY_LIMIT","lastItem","pop","searchItem","searchedtext","deleteRecords","updateExistingItem","text","existingItem","getRecord","Date","now","times","updateRecords","_unused","insertOrUpdateSearchText","_this2","exists","insertRecord","_class","factory","ɵfac","providedIn","CoreSearchHistory"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/search/services/search-history.service.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreSites } from '@services/sites';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreSearchHistoryDBRecord, SEARCH_HISTORY_TABLE_NAME } from './search-history-db';\nimport { makeSingleton } from '@singletons';\n\n/**\n * Service that enables adding a history to a search box.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreSearchHistoryProvider {\n\n    protected static readonly HISTORY_LIMIT = 10;\n\n    /**\n     * Get a search area history sorted by use.\n     *\n     * @param searchArea Search Area Name.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the list of items when done.\n     */\n    async getSearchHistory(searchArea: string, siteId?: string): Promise<CoreSearchHistoryDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n        const conditions = {\n            searcharea: searchArea,\n        };\n\n        const history: CoreSearchHistoryDBRecord[] = await site.getDb().getRecords(SEARCH_HISTORY_TABLE_NAME, conditions);\n\n        // Sorting by last used DESC.\n        return history.sort((a, b) => (b.lastused || 0) - (a.lastused || 0));\n    }\n\n    /**\n     * Controls search limit and removes the last item if overflows.\n     *\n     * @param searchArea Search area to control\n     * @param db SQLite DB where to perform the search.\n     * @returns Resolved when done.\n     */\n    protected async controlSearchLimit(searchArea: string, db: SQLiteDB): Promise<void> {\n        const items = await this.getSearchHistory(searchArea);\n        if (items.length > CoreSearchHistoryProvider.HISTORY_LIMIT) {\n            // Over the limit. Remove the last.\n            const lastItem = items.pop();\n            if (!lastItem) {\n                return;\n            }\n\n            const searchItem = {\n                searcharea: lastItem.searcharea,\n                searchedtext: lastItem.searchedtext,\n            };\n\n            await db.deleteRecords(SEARCH_HISTORY_TABLE_NAME, searchItem);\n        }\n    }\n\n    /**\n     * Updates the search history item if exists.\n     *\n     * @param searchArea Area where the search has been performed.\n     * @param text Text of the performed text.\n     * @param db SQLite DB where to perform the search.\n     * @returns True if exists, false otherwise.\n     */\n    protected async updateExistingItem(searchArea: string, text: string, db: SQLiteDB): Promise<boolean> {\n        const searchItem = {\n            searcharea: searchArea,\n            searchedtext: text,\n        };\n\n        try {\n            const existingItem: CoreSearchHistoryDBRecord = await db.getRecord(SEARCH_HISTORY_TABLE_NAME, searchItem);\n\n            // If item exist, update time and number of times searched.\n            existingItem.lastused = Date.now();\n            existingItem.times++;\n\n            await db.updateRecords(SEARCH_HISTORY_TABLE_NAME, existingItem, searchItem);\n\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Inserts a searched term on the history.\n     *\n     * @param searchArea Area where the search has been performed.\n     * @param text Text of the performed text.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async insertOrUpdateSearchText(searchArea: string, text: string, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const db = site.getDb();\n\n        const exists = await this.updateExistingItem(searchArea, text, db);\n\n        if (!exists) {\n            // If item is new, control the history does not goes over the limit.\n            const searchItem: CoreSearchHistoryDBRecord = {\n                searcharea: searchArea,\n                searchedtext: text,\n                lastused: Date.now(),\n                times: 1,\n            };\n\n            await db.insertRecord(SEARCH_HISTORY_TABLE_NAME, searchItem);\n\n            await this.controlSearchLimit(searchArea, db);\n        }\n    }\n\n}\n\nexport const CoreSearchHistory = makeSingleton(CoreSearchHistoryProvider);\n"],"mappings":";;AAgBA,SAASA,SAAS,QAAQ,iBAAiB;AAE3C,SAAoCC,yBAAyB,QAAQ,qBAAqB;AAC1F,SAASC,aAAa,QAAQ,aAAa;;AAE3C;;;AAIA,OAAM,MAAOC,yBAAyB;EAIlC;;;;;;;EAOMC,gBAAgBA,CAACC,UAAkB,EAAEC,MAAe;IAAA,OAAAC,iBAAA;MACtD,MAAMC,IAAI,SAASR,SAAS,CAACS,OAAO,CAACH,MAAM,CAAC;MAC5C,MAAMI,UAAU,GAAG;QACfC,UAAU,EAAEN;OACf;MAED,MAAMO,OAAO,SAAsCJ,IAAI,CAACK,KAAK,EAAE,CAACC,UAAU,CAACb,yBAAyB,EAAES,UAAU,CAAC;MAEjH;MACA,OAAOE,OAAO,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,CAACA,CAAC,CAACC,QAAQ,IAAI,CAAC,KAAKF,CAAC,CAACE,QAAQ,IAAI,CAAC,CAAC,CAAC;IAAC;EACzE;EAEA;;;;;;;EAOgBC,kBAAkBA,CAACd,UAAkB,EAAEe,EAAY;IAAA,IAAAC,KAAA;IAAA,OAAAd,iBAAA;MAC/D,MAAMe,KAAK,SAASD,KAAI,CAACjB,gBAAgB,CAACC,UAAU,CAAC;MACrD,IAAIiB,KAAK,CAACC,MAAM,GAAGpB,yBAAyB,CAACqB,aAAa,EAAE;QACxD;QACA,MAAMC,QAAQ,GAAGH,KAAK,CAACI,GAAG,EAAE;QAC5B,IAAI,CAACD,QAAQ,EAAE;UACX;;QAGJ,MAAME,UAAU,GAAG;UACfhB,UAAU,EAAEc,QAAQ,CAACd,UAAU;UAC/BiB,YAAY,EAAEH,QAAQ,CAACG;SAC1B;QAED,MAAMR,EAAE,CAACS,aAAa,CAAC5B,yBAAyB,EAAE0B,UAAU,CAAC;;IAChE;EACL;EAEA;;;;;;;;EAQgBG,kBAAkBA,CAACzB,UAAkB,EAAE0B,IAAY,EAAEX,EAAY;IAAA,OAAAb,iBAAA;MAC7E,MAAMoB,UAAU,GAAG;QACfhB,UAAU,EAAEN,UAAU;QACtBuB,YAAY,EAAEG;OACjB;MAED,IAAI;QACA,MAAMC,YAAY,SAAoCZ,EAAE,CAACa,SAAS,CAAChC,yBAAyB,EAAE0B,UAAU,CAAC;QAEzG;QACAK,YAAY,CAACd,QAAQ,GAAGgB,IAAI,CAACC,GAAG,EAAE;QAClCH,YAAY,CAACI,KAAK,EAAE;QAEpB,MAAMhB,EAAE,CAACiB,aAAa,CAACpC,yBAAyB,EAAE+B,YAAY,EAAEL,UAAU,CAAC;QAE3E,OAAO,IAAI;OACd,CAAC,OAAAW,OAAA,EAAM;QACJ,OAAO,KAAK;;IACf;EACL;EAEA;;;;;;;;EAQMC,wBAAwBA,CAAClC,UAAkB,EAAE0B,IAAY,EAAEzB,MAAe;IAAA,IAAAkC,MAAA;IAAA,OAAAjC,iBAAA;MAC5E,MAAMC,IAAI,SAASR,SAAS,CAACS,OAAO,CAACH,MAAM,CAAC;MAC5C,MAAMc,EAAE,GAAGZ,IAAI,CAACK,KAAK,EAAE;MAEvB,MAAM4B,MAAM,SAASD,MAAI,CAACV,kBAAkB,CAACzB,UAAU,EAAE0B,IAAI,EAAEX,EAAE,CAAC;MAElE,IAAI,CAACqB,MAAM,EAAE;QACT;QACA,MAAMd,UAAU,GAA8B;UAC1ChB,UAAU,EAAEN,UAAU;UACtBuB,YAAY,EAAEG,IAAI;UAClBb,QAAQ,EAAEgB,IAAI,CAACC,GAAG,EAAE;UACpBC,KAAK,EAAE;SACV;QAED,MAAMhB,EAAE,CAACsB,YAAY,CAACzC,yBAAyB,EAAE0B,UAAU,CAAC;QAE5D,MAAMa,MAAI,CAACrB,kBAAkB,CAACd,UAAU,EAAEe,EAAE,CAAC;;IAChD;EACL;;SAxGSjB,yBAAyB;AAERwC,MAAA,CAAAnB,aAAa,GAAG,EAAE;;mBAFnCrB,MAAyB;AAAA;;SAAzBA,MAAyB;EAAAyC,OAAA,EAAzBzC,MAAyB,CAAA0C,IAAA;EAAAC,UAAA,EADZ;AAAM;AA6GhC,OAAO,MAAMC,iBAAiB,GAAG7C,aAAa,CAACC,yBAAyB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}