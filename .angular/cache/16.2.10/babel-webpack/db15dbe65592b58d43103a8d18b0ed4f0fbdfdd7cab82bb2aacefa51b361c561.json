{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreDelegate } from '@classes/delegate';\nimport { CoreCourse } from './course';\nimport { CoreSites } from '@services/sites';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./handlers/default-module\";\n/**\n * Delegate to register module handlers.\n */\nexport class CoreCourseModuleDelegateService extends CoreDelegate {\n  constructor(defaultHandler) {\n    super('CoreCourseModuleDelegate', true);\n    this.defaultHandler = defaultHandler;\n    this.featurePrefix = 'CoreCourseModuleDelegate_';\n    this.handlerNameProperty = 'modName';\n  }\n  /**\n   * Get the component to render the module.\n   *\n   * @param course The course object.\n   * @param module The module object.\n   * @returns Promise resolved with component to use, undefined if not found.\n   */\n  getMainComponent(course, module) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this.executeFunctionOnEnabled(module.modname, 'getMainComponent', [course, module]);\n      } catch (error) {\n        _this.logger.error('Error getting main component', error);\n      }\n    })();\n  }\n  /**\n   * Get the data required to display the module in the course contents view.\n   *\n   * @param modname The name of the module type.\n   * @param module The module object.\n   * @param courseId The course ID.\n   * @param sectionId The section ID.\n   * @param forCoursePage Whether the data will be used to render the course page.\n   * @returns Data to render the module.\n   */\n  getModuleDataFor(modname, module, courseId, sectionId, forCoursePage) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const data = yield _this2.executeFunctionOnEnabled(modname, 'getData', [module, courseId, sectionId, forCoursePage]);\n      if (data) {\n        var _data$showDownloadBut;\n        data.showDownloadButton = (_data$showDownloadBut = data.showDownloadButton) !== null && _data$showDownloadBut !== void 0 ? _data$showDownloadBut : true;\n      }\n      return data;\n    })();\n  }\n  /**\n   * Opens the activity page.\n   *\n   * @param modname The name of the module type.\n   * @param module The module object.\n   * @param courseId The course ID.\n   * @param options Options for the navigation.\n   * @returns Promise resolved when done.\n   */\n  openActivityPage(modname, module, courseId, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.executeFunctionOnEnabled(modname, 'openActivityPage', [module, courseId, options]);\n    })();\n  }\n  /**\n   * Check if a certain module type is disabled in a site.\n   *\n   * @param modname The name of the module type.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether module is disabled.\n   */\n  isModuleDisabled(modname, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this4.isModuleDisabledInSite(modname, site);\n    })();\n  }\n  /**\n   * Check if a certain module type is disabled in a site.\n   *\n   * @param modname The name of the module type.\n   * @param site Site. If not defined, use current site.\n   * @returns Whether module is disabled.\n   */\n  isModuleDisabledInSite(modname, site) {\n    const handler = this.getHandler(modname, false);\n    if (handler) {\n      site = site || CoreSites.getCurrentSite();\n      if (!site) {\n        return true;\n      }\n      return this.isFeatureDisabled(handler, site);\n    }\n    return false;\n  }\n  /**\n   * Whether to display the course refresher in single activity course format. If it returns false, a refresher must be\n   * included in the template that calls the doRefresh method of the component. Defaults to true.\n   *\n   * @param modname The name of the module type.\n   * @returns Whether the refresher should be displayed.\n   */\n  displayRefresherInSingleActivity(modname) {\n    return !!this.executeFunctionOnEnabled(modname, 'displayRefresherInSingleActivity');\n  }\n  /**\n   * Get the icon src for a certain type of module.\n   *\n   * @param modname The name of the module type.\n   * @param modicon The mod icon string.\n   * @param module The module to use.\n   * @returns Promise resolved with the icon src.\n   */\n  getModuleIconSrc(modname, modicon, module) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var _ref;\n      const icon = yield _this5.executeFunctionOnEnabled(modname, 'getIconSrc', [module, modicon]);\n      return (_ref = icon !== null && icon !== void 0 ? icon : CoreCourse.getModuleIconSrc(modname, modicon)) !== null && _ref !== void 0 ? _ref : '';\n    })();\n  }\n  /**\n   * Get whether the icon for the given module should be treated as a shape or a rich image.\n   *\n   * @param modname The name of the module type.\n   * @param modicon The mod icon string.\n   * @param module The module to use.\n   * @returns Whether the icon should be treated as a shape.\n   * @deprecated since 4.3. Now it uses platform information. This function is not used anymore.\n   */\n  moduleIconIsShape(modname, modicon, module) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this6.executeFunctionOnEnabled(modname, 'iconIsShape', [module, modicon]);\n    })();\n  }\n  /**\n   * Check if a certain type of module supports a certain feature.\n   *\n   * @param modname The modname.\n   * @param feature The feature to check.\n   * @param defaultValue Value to return if the module is not supported or doesn't know if it's supported.\n   * @returns The result of the supports check.\n   */\n  supportsFeature(modname, feature, defaultValue) {\n    var _result;\n    const handler = this.enabledHandlers[modname];\n    let result;\n    if (handler) {\n      if (handler.supportsFeature) {\n        // The handler specified a function to determine the feature, use it.\n        result = handler.supportsFeature(feature);\n      } else if (handler.supportedFeatures) {\n        // Handler has an object to determine the feature, use it.\n        result = handler.supportedFeatures[feature];\n      }\n    }\n    return (_result = result) !== null && _result !== void 0 ? _result : defaultValue;\n  }\n  /**\n   * Return true to show the manual completion regardless of the course's showcompletionconditions setting.\n   * Returns false by default.\n   *\n   * @param module Module.\n   * @returns Promise resolved with boolean: whether the manual completion should always be displayed.\n   */\n  manualCompletionAlwaysShown(module) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this7.executeFunctionOnEnabled(module.modname, 'manualCompletionAlwaysShown', [module]);\n      return !!result;\n    })();\n  }\n}\n_class = CoreCourseModuleDelegateService;\n_class.ɵfac = function CoreCourseModuleDelegateService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.CoreCourseModuleDefaultHandler));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCourseModuleDelegate = makeSingleton(CoreCourseModuleDelegateService);","map":{"version":3,"names":["CoreDelegate","CoreCourse","CoreSites","makeSingleton","CoreCourseModuleDelegateService","constructor","defaultHandler","featurePrefix","handlerNameProperty","getMainComponent","course","module","_this","_asyncToGenerator","executeFunctionOnEnabled","modname","error","logger","getModuleDataFor","courseId","sectionId","forCoursePage","_this2","data","_data$showDownloadBut","showDownloadButton","openActivityPage","options","_this3","isModuleDisabled","siteId","_this4","site","getSite","isModuleDisabledInSite","handler","getHandler","getCurrentSite","isFeatureDisabled","displayRefresherInSingleActivity","getModuleIconSrc","modicon","_this5","_ref","icon","moduleIconIsShape","_this6","supportsFeature","feature","defaultValue","_result","enabledHandlers","result","supportedFeatures","manualCompletionAlwaysShown","_this7","i0","ɵɵinject","i1","CoreCourseModuleDefaultHandler","factory","ɵfac","providedIn","CoreCourseModuleDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/services/module-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\nimport { SafeUrl } from '@angular/platform-browser';\n\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseModuleDefaultHandler } from './handlers/default-module';\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { CoreCourseAnyCourseData } from '@features/courses/services/courses';\nimport { CoreCourse } from './course';\nimport { CoreSites } from '@services/sites';\nimport { makeSingleton } from '@singletons';\nimport { CoreCourseModuleData } from './course-helper';\nimport { CoreNavigationOptions } from '@services/navigator';\nimport { CoreIonicColorNames } from '@singletons/colors';\n\n/**\n * Interface that all course module handlers must implement.\n */\nexport interface CoreCourseModuleHandler extends CoreDelegateHandler {\n    /**\n     * Name of the module. It should match the \"modname\" of the module returned in core_course_get_contents.\n     */\n    modName: string;\n\n    /**\n     * List of supported features. The keys should be the name of the feature.\n     * This is to replicate the \"plugin_supports\" function of Moodle.\n     * If you need some dynamic checks please implement the supportsFeature function.\n     */\n    supportedFeatures?: Record<string, unknown>;\n\n    /**\n     * Get the data required to display the module in the course contents view.\n     *\n     * @param module The module object.\n     * @param courseId The course ID.\n     * @param sectionId The section ID.\n     * @param forCoursePage Whether the data will be used to render the course page.\n     * @returns Data to render the module.\n     */\n    getData(\n        module: CoreCourseModuleData,\n        courseId: number,\n        sectionId?: number,\n        forCoursePage?: boolean,\n    ): Promise<CoreCourseModuleHandlerData> | CoreCourseModuleHandlerData;\n\n    /**\n     * Get the component to render the module. This is needed to support singleactivity course format.\n     * The component returned must implement CoreCourseModuleMainComponent.\n     * It's recommended to return the class of the component, but you can also return an instance of the component.\n     *\n     * @param course The course object.\n     * @param module The module object.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    getMainComponent(course: CoreCourseAnyCourseData, module: CoreCourseModuleData): Promise<Type<unknown> | undefined>;\n\n    /**\n     * Whether to display the course refresher in single activity course format. If it returns false, a refresher must be\n     * included in the template that calls the doRefresh method of the component. Defaults to true.\n     *\n     * @returns Whether the refresher should be displayed.\n     */\n    displayRefresherInSingleActivity?(): boolean;\n\n    /**\n     * Get the icon src for the module.\n     *\n     * @param module Module to get the icon from.\n     * @param modicon The mod icon string.\n     * @returns The icon src.\n     */\n    getIconSrc?(module?: CoreCourseModuleData, modicon?: string): Promise<string | undefined> | string | undefined;\n\n    /**\n     * Check whether the icon should be treated as a shape or a rich image.\n     *\n     * @param module Module to get the icon from.\n     * @param modicon The mod icon string.\n     * @returns Whether the icon should be treated as a shape.\n     * @deprecated since 4.3. Now it uses platform information. This function is not used anymore.\n     */\n    iconIsShape?(module?: CoreCourseModuleData, modicon?: string): Promise<boolean | undefined> | boolean | undefined;\n\n    /**\n     * Check if this type of module supports a certain feature.\n     * If this function is implemented, the supportedFeatures object will be ignored.\n     *\n     * @param feature The feature to check.\n     * @returns The result of the supports check.\n     */\n    supportsFeature?(feature: string): unknown;\n\n    /**\n     * Return true to show the manual completion regardless of the course's showcompletionconditions setting.\n     * Returns false by default.\n     *\n     * @param module Module.\n     * @returns Promise resolved with boolean: whether the manual completion should always be displayed.\n     */\n    manualCompletionAlwaysShown?(module: CoreCourseModuleData): Promise<boolean>;\n\n    /**\n     * Opens the activity page.\n     *\n     * @param module The module object.\n     * @param courseId The course ID.\n     * @param options Options for the navigation.\n     * @returns Promise resolved when done.\n     */\n    openActivityPage(module: CoreCourseModuleData, courseId: number, options?: CoreNavigationOptions): Promise<void>;\n}\n\n/**\n * Data needed to render the module in course contents.\n */\nexport interface CoreCourseModuleHandlerData {\n    /**\n     * The title to display in the module.\n     */\n    title: string;\n\n    /**\n     * The accessibility title to use in the module. If not provided, title will be used.\n     */\n    a11yTitle?: string;\n\n    /**\n     * The image to use as icon (path to the image).\n     */\n    icon?: string | SafeUrl;\n\n    /**\n     * The class to assign to the item.\n     */\n    class?: string;\n\n    /**\n     * The text to show in an extra badge.\n     */\n    extraBadge?: string;\n\n    /**\n     * The color of the extra badge. Default: primary.\n     *\n     * @deprecated since 4.3 Not used anymore.\n     */\n    extraBadgeColor?: CoreIonicColorNames;\n\n    /**\n     * Whether to display a button to download/refresh the module if it's downloadable.\n     * If it's set to true, the app will show a download/refresh button when needed and will handle the download of the\n     * module using CoreCourseModulePrefetchDelegate.\n     */\n    showDownloadButton?: boolean;\n\n    /**\n     * Wether activity has the custom cmlist item flag enabled.\n     *\n     * Activities like label uses this flag to indicate that it should be\n     * displayed as a custom course item instead of a tipical activity card.\n     */\n    hasCustomCmListItem?: boolean;\n\n    /**\n     * The buttons to display in the module item.\n     *\n     * @deprecated since 4.3 Use button instead. It will only display the first.\n     */\n    buttons?: CoreCourseModuleHandlerButton[];\n\n    /**\n     * The button to display in the module item.\n     */\n    button?: CoreCourseModuleHandlerButton;\n\n    /**\n     * Whether to display a spinner where the download button is displayed. The module icon, title, etc. will be displayed.\n     */\n    spinner?: boolean;\n\n    /**\n     * Whether the data is being loaded. If true, it will display a spinner in the whole module, nothing else will be shown.\n     */\n    loading?: boolean;\n\n    /**\n     * Action to perform when the module is clicked.\n     *\n     * @param event The click event.\n     * @param module The module object.\n     * @param courseId The course ID.\n     * @param options Options for the navigation.\n     * @returns Promise resolved when done.\n     */\n    action?(event: Event, module: CoreCourseModuleData, courseId: number, options?: CoreNavigationOptions): Promise<void> | void;\n\n    /**\n     * Updates the status of the module.\n     *\n     * @param status Module status.\n     */\n    updateStatus?(status: string): void;\n\n    /**\n     * On Destroy function in case it's needed.\n     */\n    onDestroy?(): void;\n}\n\n/**\n * Interface that all the components to render the module in singleactivity must implement.\n */\nexport interface CoreCourseModuleMainComponent {\n    /**\n     * Refresh the data.\n     *\n     * @param refresher Refresher.\n     * @param showErrors If show errors to the user of hide them.\n     * @returns Promise resolved when done.\n     */\n    doRefresh(refresher?: HTMLIonRefresherElement | null, showErrors?: boolean): Promise<void>;\n}\n\n/**\n * A button to display in a module item.\n */\nexport interface CoreCourseModuleHandlerButton {\n    /**\n     * The label to add to the button.\n     */\n    label: string;\n\n    /**\n     * The name of the button icon.\n     */\n    icon: string;\n\n    /**\n     * Whether the button should be hidden.\n     */\n    hidden?: boolean;\n\n    /**\n     * Action to perform when the button is clicked.\n     *\n     * @param event The click event.\n     * @param module The module object.\n     * @param courseId The course ID.\n     * @param options Options for the navigation.\n     * @returns Promise resolved when done.\n     */\n    action(event: Event, module: CoreCourseModuleData, courseId: number, options?: CoreNavigationOptions): Promise<void> | void;\n}\n\n/**\n * Delegate to register module handlers.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCourseModuleDelegateService extends CoreDelegate<CoreCourseModuleHandler> {\n\n    protected featurePrefix = 'CoreCourseModuleDelegate_';\n    protected handlerNameProperty = 'modName';\n\n    constructor(protected defaultHandler: CoreCourseModuleDefaultHandler) {\n        super('CoreCourseModuleDelegate', true);\n    }\n\n    /**\n     * Get the component to render the module.\n     *\n     * @param course The course object.\n     * @param module The module object.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    async getMainComponent(course: CoreCourseAnyCourseData, module: CoreCourseModuleData): Promise<Type<unknown> | undefined> {\n        try {\n            return await this.executeFunctionOnEnabled<Type<unknown>>(module.modname, 'getMainComponent', [course, module]);\n        } catch (error) {\n            this.logger.error('Error getting main component', error);\n        }\n    }\n\n    /**\n     * Get the data required to display the module in the course contents view.\n     *\n     * @param modname The name of the module type.\n     * @param module The module object.\n     * @param courseId The course ID.\n     * @param sectionId The section ID.\n     * @param forCoursePage Whether the data will be used to render the course page.\n     * @returns Data to render the module.\n     */\n    async getModuleDataFor(\n        modname: string,\n        module: CoreCourseModuleData,\n        courseId: number,\n        sectionId?: number,\n        forCoursePage?: boolean,\n    ): Promise<CoreCourseModuleHandlerData | undefined> {\n        const data = await this.executeFunctionOnEnabled<CoreCourseModuleHandlerData>(\n            modname,\n            'getData',\n            [module, courseId, sectionId, forCoursePage],\n        );\n\n        if (data) {\n            data.showDownloadButton = data.showDownloadButton ?? true;\n        }\n\n        return data;\n    }\n\n    /**\n     * Opens the activity page.\n     *\n     * @param modname The name of the module type.\n     * @param module The module object.\n     * @param courseId The course ID.\n     * @param options Options for the navigation.\n     * @returns Promise resolved when done.\n     */\n    async openActivityPage(\n        modname: string,\n        module: CoreCourseModuleData,\n        courseId: number,\n        options?: CoreNavigationOptions,\n    ): Promise<void> {\n        return this.executeFunctionOnEnabled<void>(\n            modname,\n            'openActivityPage',\n            [module, courseId, options],\n        );\n    }\n\n    /**\n     * Check if a certain module type is disabled in a site.\n     *\n     * @param modname The name of the module type.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether module is disabled.\n     */\n    async isModuleDisabled(modname: string, siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.isModuleDisabledInSite(modname, site);\n    }\n\n    /**\n     * Check if a certain module type is disabled in a site.\n     *\n     * @param modname The name of the module type.\n     * @param site Site. If not defined, use current site.\n     * @returns Whether module is disabled.\n     */\n    isModuleDisabledInSite(modname: string, site?: CoreSite): boolean {\n        const handler = this.getHandler(modname, false);\n\n        if (handler) {\n            site = site || CoreSites.getCurrentSite();\n\n            if (!site) {\n                return true;\n            }\n\n            return this.isFeatureDisabled(handler, site);\n        }\n\n        return false;\n    }\n\n    /**\n     * Whether to display the course refresher in single activity course format. If it returns false, a refresher must be\n     * included in the template that calls the doRefresh method of the component. Defaults to true.\n     *\n     * @param modname The name of the module type.\n     * @returns Whether the refresher should be displayed.\n     */\n    displayRefresherInSingleActivity(modname: string): boolean {\n        return !!this.executeFunctionOnEnabled<boolean>(modname, 'displayRefresherInSingleActivity');\n    }\n\n    /**\n     * Get the icon src for a certain type of module.\n     *\n     * @param modname The name of the module type.\n     * @param modicon The mod icon string.\n     * @param module The module to use.\n     * @returns Promise resolved with the icon src.\n     */\n    async getModuleIconSrc(modname: string, modicon?: string, module?: CoreCourseModuleData): Promise<string> {\n        const icon = await this.executeFunctionOnEnabled<Promise<string>>(modname, 'getIconSrc', [module, modicon]);\n\n        return icon ?? CoreCourse.getModuleIconSrc(modname, modicon) ?? '';\n    }\n\n    /**\n     * Get whether the icon for the given module should be treated as a shape or a rich image.\n     *\n     * @param modname The name of the module type.\n     * @param modicon The mod icon string.\n     * @param module The module to use.\n     * @returns Whether the icon should be treated as a shape.\n     * @deprecated since 4.3. Now it uses platform information. This function is not used anymore.\n     */\n    async moduleIconIsShape(modname: string, modicon?: string, module?: CoreCourseModuleData): Promise<boolean | undefined> {\n        return await this.executeFunctionOnEnabled<Promise<boolean>>(modname, 'iconIsShape', [module, modicon]);\n    }\n\n    /**\n     * Check if a certain type of module supports a certain feature.\n     *\n     * @param modname The modname.\n     * @param feature The feature to check.\n     * @param defaultValue Value to return if the module is not supported or doesn't know if it's supported.\n     * @returns The result of the supports check.\n     */\n    supportsFeature<T = unknown>(modname: string, feature: string, defaultValue: T): T {\n        const handler = this.enabledHandlers[modname];\n        let result: T | undefined;\n\n        if (handler) {\n            if (handler.supportsFeature) {\n                // The handler specified a function to determine the feature, use it.\n                result = <T> handler.supportsFeature(feature);\n            } else if (handler.supportedFeatures) {\n                // Handler has an object to determine the feature, use it.\n                result = <T> handler.supportedFeatures[feature];\n            }\n        }\n\n        return result ?? defaultValue;\n    }\n\n    /**\n     * Return true to show the manual completion regardless of the course's showcompletionconditions setting.\n     * Returns false by default.\n     *\n     * @param module Module.\n     * @returns Promise resolved with boolean: whether the manual completion should always be displayed.\n     */\n    async manualCompletionAlwaysShown(module: CoreCourseModuleData): Promise<boolean> {\n        const result = await this.executeFunctionOnEnabled<boolean>(module.modname, 'manualCompletionAlwaysShown', [module]);\n\n        return !!result;\n    }\n\n}\n\nexport const CoreCourseModuleDelegate = makeSingleton(CoreCourseModuleDelegateService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}