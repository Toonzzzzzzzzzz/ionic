{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreLang, CoreLangFormat } from '@services/lang';\nimport { CoreSites } from '@services/sites';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreMainMenuDelegate } from './mainmenu-delegate';\nimport { Device, makeSingleton } from '@singletons';\nimport { CoreArray } from '@singletons/array';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreScreen } from '@services/screen';\nimport { CorePlatform } from '@services/platform';\nimport * as i0 from \"@angular/core\";\n/**\n * Service that provides some features regarding Main Menu.\n */\nexport class CoreMainMenuProvider {\n  /**\n   * Get the current main menu handlers.\n   *\n   * @returns Promise resolved with the current main menu handlers.\n   */\n  getCurrentMainMenuHandlers() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const handlers = yield CoreMainMenuDelegate.getHandlersWhenLoaded();\n      return handlers.filter(handler => !handler.onlyInMore).slice(0, _this.getNumItems());\n    })();\n  }\n  /**\n   * Get a list of custom menu items.\n   *\n   * @param siteId Site to get custom items from.\n   * @returns List of custom menu items.\n   */\n  getCustomMenuItems(siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const customItems = yield Promise.all([_this2.getCustomMenuItemsFromSite(siteId), _this2.getCustomItemsFromConfig()]);\n      return CoreArray.flatten(customItems);\n    })();\n  }\n  /**\n   * Get a list of custom menu items for a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns List of custom menu items.\n   */\n  getCustomMenuItemsFromSite(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const itemsString = site.getStoredConfig('tool_mobile_custommenuitems');\n      const map = {};\n      const result = [];\n      let position = 0; // Position of each item, to keep the same order as it's configured.\n      if (!itemsString || typeof itemsString != 'string') {\n        // Setting not valid.\n        return result;\n      }\n      // Add items to the map.\n      const items = itemsString.split(/(?:\\r\\n|\\r|\\n)/);\n      items.forEach(item => {\n        const values = item.split('|');\n        const label = values[0] ? values[0].trim() : values[0];\n        const url = values[1] ? values[1].trim() : values[1];\n        const type = values[2] ? values[2].trim() : values[2];\n        const lang = (values[3] ? values[3].trim() : values[3]) || 'none';\n        let icon = values[4] ? values[4].trim() : values[4];\n        if (!label || !url || !type) {\n          // Invalid item, ignore it.\n          return;\n        }\n        const id = url + '#' + type;\n        if (!icon) {\n          // Icon not defined, use default one.\n          icon = type == 'embedded' ? 'fa-expand' : 'fa-link'; // @todo Find a better icon for embedded.\n        }\n\n        if (!map[id]) {\n          // New entry, add it to the map.\n          map[id] = {\n            url: url,\n            type: type,\n            position: position,\n            labels: {}\n          };\n          position++;\n        }\n        map[id].labels[lang.toLowerCase()] = {\n          label: label,\n          icon: icon\n        };\n      });\n      if (!position) {\n        // No valid items found, stop.\n        return result;\n      }\n      const currentLangApp = yield CoreLang.getCurrentLanguage();\n      const currentLangLMS = CoreLang.formatLanguage(currentLangApp, \"lms\" /* CoreLangFormat.LMS */);\n      const fallbackLang = CoreConstants.CONFIG.default_lang || 'en';\n      // Get the right label for each entry and add it to the result.\n      for (const id in map) {\n        var _ref, _ref2, _ref3, _ref4, _entry$labels$current;\n        const entry = map[id];\n        let data = (_ref = (_ref2 = (_ref3 = (_ref4 = (_entry$labels$current = entry.labels[currentLangApp]) !== null && _entry$labels$current !== void 0 ? _entry$labels$current : entry.labels[currentLangLMS]) !== null && _ref4 !== void 0 ? _ref4 : entry.labels[currentLangApp + '_only']) !== null && _ref3 !== void 0 ? _ref3 : entry.labels[currentLangLMS + '_only']) !== null && _ref2 !== void 0 ? _ref2 : entry.labels.none) !== null && _ref !== void 0 ? _ref : entry.labels[fallbackLang];\n        if (!data) {\n          // No valid label found, get the first one that is not \"_only\".\n          for (const lang in entry.labels) {\n            if (lang.indexOf('_only') == -1) {\n              data = entry.labels[lang];\n              break;\n            }\n          }\n          if (!data) {\n            // No valid label, ignore this entry.\n            continue;\n          }\n        }\n        result[entry.position] = {\n          url: entry.url,\n          type: entry.type,\n          label: data.label,\n          icon: data.icon\n        };\n      }\n      // Remove undefined values.\n      return result.filter(entry => entry !== undefined);\n    })();\n  }\n  /**\n   * Get a list of custom menu items from config.\n   *\n   * @returns List of custom menu items.\n   */\n  getCustomItemsFromConfig() {\n    return _asyncToGenerator(function* () {\n      const items = CoreConstants.CONFIG.customMainMenuItems;\n      if (!items) {\n        return [];\n      }\n      const currentLang = yield CoreLang.getCurrentLanguage();\n      const fallbackLang = CoreConstants.CONFIG.default_lang || 'en';\n      const replacements = {\n        devicetype: '',\n        osversion: Device.version\n      };\n      if (CorePlatform.isAndroid()) {\n        replacements.devicetype = 'Android';\n      } else if (CorePlatform.isIOS()) {\n        replacements.devicetype = 'iPhone or iPad';\n      } else {\n        replacements.devicetype = 'Other';\n      }\n      return items.filter(item => typeof item.label === 'string' || currentLang in item.label || fallbackLang in item.label).map(item => {\n        var _item$label$currentLa;\n        return _objectSpread(_objectSpread({}, item), {}, {\n          url: CoreTextUtils.replaceArguments(item.url, replacements, 'uri'),\n          label: typeof item.label === 'string' ? item.label : (_item$label$currentLa = item.label[currentLang]) !== null && _item$label$currentLa !== void 0 ? _item$label$currentLa : item.label[fallbackLang]\n        });\n      });\n    })();\n  }\n  /**\n   * Get the number of items to be shown on the main menu bar.\n   *\n   * @returns Number of items depending on the device width.\n   */\n  getNumItems() {\n    if (!this.isResponsiveMainMenuItemsDisabledInCurrentSite() && window && window.innerWidth) {\n      let numElements;\n      if (CoreScreen.isTablet) {\n        // Tablet, menu will be displayed vertically.\n        numElements = Math.floor(window.innerHeight / CoreMainMenuProvider.ITEM_MIN_WIDTH);\n      } else {\n        numElements = Math.floor(window.innerWidth / CoreMainMenuProvider.ITEM_MIN_WIDTH);\n        // Set a maximum elements to show and skip more button.\n        numElements = numElements >= 5 ? 5 : numElements;\n      }\n      // Set a mínimum elements to show and skip more button.\n      return numElements > 1 ? numElements - 1 : 1;\n    }\n    return CoreMainMenuProvider.NUM_MAIN_HANDLERS;\n  }\n  /**\n   * Get tabs placement depending on the device size.\n   *\n   * @returns Tabs placement including side value.\n   */\n  getTabPlacement() {\n    return CoreScreen.isTablet ? 'side' : 'bottom';\n  }\n  /**\n   * Check if a certain page is the root of a main menu tab.\n   *\n   * @param pageName Name of the page.\n   * @returns Promise resolved with boolean: whether it's the root of a main menu tab.\n   */\n  isMainMenuTab(pageName) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (pageName == CoreMainMenuProvider.MORE_PAGE_NAME) {\n        return true;\n      }\n      return _this3.isCurrentMainMenuHandler(pageName);\n    })();\n  }\n  /**\n   * Check if a certain page is the root of a main menu handler currently displayed.\n   *\n   * @param pageName Name of the page.\n   * @returns Promise resolved with boolean: whether it's the root of a main menu handler.\n   */\n  isCurrentMainMenuHandler(pageName) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const handlers = yield _this4.getCurrentMainMenuHandlers();\n      const handler = handlers.find(handler => {\n        var _exec$, _exec;\n        const tabRoot = (_exec$ = (_exec = /^[^/]+/.exec(handler.page)) === null || _exec === void 0 ? void 0 : _exec[0]) !== null && _exec$ !== void 0 ? _exec$ : handler.page;\n        return tabRoot == pageName;\n      });\n      return !!handler;\n    })();\n  }\n  /**\n   * Check if responsive main menu items is disabled in the current site.\n   *\n   * @returns Whether it's disabled.\n   */\n  isResponsiveMainMenuItemsDisabledInCurrentSite() {\n    const site = CoreSites.getCurrentSite();\n    return !!(site !== null && site !== void 0 && site.isFeatureDisabled('NoDelegate_ResponsiveMainMenuItems'));\n  }\n}\n_class = CoreMainMenuProvider;\n_class.NUM_MAIN_HANDLERS = 4;\n_class.ITEM_MIN_WIDTH = 72;\n// Min with of every item, based on 5 items on a 360 pixel wide screen.\n_class.MORE_PAGE_NAME = 'more';\n_class.MAIN_MENU_HANDLER_BADGE_UPDATED = 'main_menu_handler_badge_updated';\n_class.MAIN_MENU_VISIBILITY_UPDATED = 'main_menu_visbility_updated';\n_class.ɵfac = function CoreMainMenuProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreMainMenu = makeSingleton(CoreMainMenuProvider);","map":{"version":3,"names":["CoreLang","CoreLangFormat","CoreSites","CoreConstants","CoreMainMenuDelegate","Device","makeSingleton","CoreArray","CoreTextUtils","CoreScreen","CorePlatform","CoreMainMenuProvider","getCurrentMainMenuHandlers","_this","_asyncToGenerator","handlers","getHandlersWhenLoaded","filter","handler","onlyInMore","slice","getNumItems","getCustomMenuItems","siteId","_this2","customItems","Promise","all","getCustomMenuItemsFromSite","getCustomItemsFromConfig","flatten","site","getSite","itemsString","getStoredConfig","map","result","position","items","split","forEach","item","values","label","trim","url","type","lang","icon","id","labels","toLowerCase","currentLangApp","getCurrentLanguage","currentLangLMS","formatLanguage","fallbackLang","CONFIG","default_lang","_ref","_ref2","_ref3","_ref4","_entry$labels$current","entry","data","none","indexOf","undefined","customMainMenuItems","currentLang","replacements","devicetype","osversion","version","isAndroid","isIOS","_item$label$currentLa","_objectSpread","replaceArguments","isResponsiveMainMenuItemsDisabledInCurrentSite","window","innerWidth","numElements","isTablet","Math","floor","innerHeight","ITEM_MIN_WIDTH","NUM_MAIN_HANDLERS","getTabPlacement","isMainMenuTab","pageName","_this3","MORE_PAGE_NAME","isCurrentMainMenuHandler","_this4","find","_exec$","_exec","tabRoot","exec","page","getCurrentSite","isFeatureDisabled","_class","MAIN_MENU_HANDLER_BADGE_UPDATED","MAIN_MENU_VISIBILITY_UPDATED","factory","ɵfac","providedIn","CoreMainMenu"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/mainmenu/services/mainmenu.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreLang, CoreLangFormat, CoreLangLanguage } from '@services/lang';\nimport { CoreSites } from '@services/sites';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreMainMenuDelegate, CoreMainMenuHandlerToDisplay } from './mainmenu-delegate';\nimport { Device, makeSingleton } from '@singletons';\nimport { CoreArray } from '@singletons/array';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreScreen } from '@services/screen';\nimport { CorePlatform } from '@services/platform';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [CoreMainMenuProvider.MAIN_MENU_HANDLER_BADGE_UPDATED]: CoreMainMenuHandlerBadgeUpdatedEventData;\n        [CoreMainMenuProvider.MAIN_MENU_VISIBILITY_UPDATED]: void;\n    }\n\n}\n\n/**\n * Service that provides some features regarding Main Menu.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreMainMenuProvider {\n\n    static readonly NUM_MAIN_HANDLERS = 4;\n    static readonly ITEM_MIN_WIDTH = 72; // Min with of every item, based on 5 items on a 360 pixel wide screen.\n    static readonly MORE_PAGE_NAME = 'more';\n    static readonly MAIN_MENU_HANDLER_BADGE_UPDATED = 'main_menu_handler_badge_updated';\n    static readonly MAIN_MENU_VISIBILITY_UPDATED = 'main_menu_visbility_updated';\n\n    /**\n     * Get the current main menu handlers.\n     *\n     * @returns Promise resolved with the current main menu handlers.\n     */\n    async getCurrentMainMenuHandlers(): Promise<CoreMainMenuHandlerToDisplay[]> {\n        const handlers = await CoreMainMenuDelegate.getHandlersWhenLoaded();\n\n        return handlers.filter(handler => !handler.onlyInMore).slice(0, this.getNumItems());\n    }\n\n    /**\n     * Get a list of custom menu items.\n     *\n     * @param siteId Site to get custom items from.\n     * @returns List of custom menu items.\n     */\n    async getCustomMenuItems(siteId?: string): Promise<CoreMainMenuCustomItem[]> {\n        const customItems = await Promise.all([\n            this.getCustomMenuItemsFromSite(siteId),\n            this.getCustomItemsFromConfig(),\n        ]);\n\n        return CoreArray.flatten(customItems);\n    }\n\n    /**\n     * Get a list of custom menu items for a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns List of custom menu items.\n     */\n    protected async getCustomMenuItemsFromSite(siteId?: string): Promise<CoreMainMenuCustomItem[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const itemsString = site.getStoredConfig('tool_mobile_custommenuitems');\n        const map: CustomMenuItemsMap = {};\n        const result: CoreMainMenuCustomItem[] = [];\n\n        let position = 0; // Position of each item, to keep the same order as it's configured.\n\n        if (!itemsString || typeof itemsString != 'string') {\n            // Setting not valid.\n            return result;\n        }\n\n        // Add items to the map.\n        const items = itemsString.split(/(?:\\r\\n|\\r|\\n)/);\n        items.forEach((item) => {\n            const values = item.split('|');\n            const label = values[0] ? values[0].trim() : values[0];\n            const url = values[1] ? values[1].trim() : values[1];\n            const type = values[2] ? values[2].trim() : values[2];\n            const lang = (values[3] ? values[3].trim() : values[3]) || 'none';\n            let icon = values[4] ? values[4].trim() : values[4];\n\n            if (!label || !url || !type) {\n                // Invalid item, ignore it.\n                return;\n            }\n\n            const id = url + '#' + type;\n            if (!icon) {\n                // Icon not defined, use default one.\n                icon = type == 'embedded' ? 'fa-expand' : 'fa-link'; // @todo Find a better icon for embedded.\n            }\n\n            if (!map[id]) {\n                // New entry, add it to the map.\n                map[id] = {\n                    url: url,\n                    type: type,\n                    position: position,\n                    labels: {},\n                };\n                position++;\n            }\n\n            map[id].labels[lang.toLowerCase()] = {\n                label: label,\n                icon: icon,\n            };\n        });\n\n        if (!position) {\n            // No valid items found, stop.\n            return result;\n        }\n\n        const currentLangApp = await CoreLang.getCurrentLanguage();\n        const currentLangLMS = CoreLang.formatLanguage(currentLangApp, CoreLangFormat.LMS);\n        const fallbackLang = CoreConstants.CONFIG.default_lang || 'en';\n\n        // Get the right label for each entry and add it to the result.\n        for (const id in map) {\n            const entry = map[id];\n            let data = entry.labels[currentLangApp]\n                ?? entry.labels[currentLangLMS]\n                ?? entry.labels[currentLangApp + '_only']\n                ?? entry.labels[currentLangLMS + '_only']\n                ?? entry.labels.none\n                ?? entry.labels[fallbackLang];\n\n            if (!data) {\n                // No valid label found, get the first one that is not \"_only\".\n                for (const lang in entry.labels) {\n                    if (lang.indexOf('_only') == -1) {\n                        data = entry.labels[lang];\n                        break;\n                    }\n                }\n\n                if (!data) {\n                    // No valid label, ignore this entry.\n                    continue;\n                }\n            }\n\n            result[entry.position] = {\n                url: entry.url,\n                type: entry.type,\n                label: data.label,\n                icon: data.icon,\n            };\n        }\n\n        // Remove undefined values.\n        return result.filter((entry) => entry !== undefined);\n    }\n\n    /**\n     * Get a list of custom menu items from config.\n     *\n     * @returns List of custom menu items.\n     */\n    protected async getCustomItemsFromConfig(): Promise<CoreMainMenuCustomItem[]> {\n        const items = CoreConstants.CONFIG.customMainMenuItems;\n\n        if (!items) {\n            return [];\n        }\n\n        const currentLang = await CoreLang.getCurrentLanguage();\n\n        const fallbackLang = CoreConstants.CONFIG.default_lang || 'en';\n        const replacements = {\n            devicetype: '',\n            osversion: Device.version,\n        };\n\n        if (CorePlatform.isAndroid()) {\n            replacements.devicetype = 'Android';\n        } else if (CorePlatform.isIOS()) {\n            replacements.devicetype = 'iPhone or iPad';\n        } else {\n            replacements.devicetype = 'Other';\n        }\n\n        return items\n            .filter(item => typeof item.label === 'string' || currentLang in item.label || fallbackLang in item.label)\n            .map(item => ({\n                ...item,\n                url: CoreTextUtils.replaceArguments(item.url, replacements, 'uri'),\n                label: typeof item.label === 'string'\n                    ? item.label\n                    : item.label[currentLang] ?? item.label[fallbackLang],\n            }));\n    }\n\n    /**\n     * Get the number of items to be shown on the main menu bar.\n     *\n     * @returns Number of items depending on the device width.\n     */\n    getNumItems(): number {\n        if (!this.isResponsiveMainMenuItemsDisabledInCurrentSite() && window && window.innerWidth) {\n            let numElements: number;\n\n            if (CoreScreen.isTablet) {\n                // Tablet, menu will be displayed vertically.\n                numElements = Math.floor(window.innerHeight / CoreMainMenuProvider.ITEM_MIN_WIDTH);\n            } else {\n                numElements = Math.floor(window.innerWidth / CoreMainMenuProvider.ITEM_MIN_WIDTH);\n\n                // Set a maximum elements to show and skip more button.\n                numElements = numElements >= 5 ? 5 : numElements;\n            }\n\n            // Set a mínimum elements to show and skip more button.\n            return numElements > 1 ? numElements - 1 : 1;\n        }\n\n        return CoreMainMenuProvider.NUM_MAIN_HANDLERS;\n    }\n\n    /**\n     * Get tabs placement depending on the device size.\n     *\n     * @returns Tabs placement including side value.\n     */\n    getTabPlacement(): 'bottom' | 'side' {\n        return CoreScreen.isTablet ? 'side' : 'bottom';\n    }\n\n    /**\n     * Check if a certain page is the root of a main menu tab.\n     *\n     * @param pageName Name of the page.\n     * @returns Promise resolved with boolean: whether it's the root of a main menu tab.\n     */\n    async isMainMenuTab(pageName: string): Promise<boolean> {\n        if (pageName == CoreMainMenuProvider.MORE_PAGE_NAME) {\n            return true;\n        }\n\n        return this.isCurrentMainMenuHandler(pageName);\n    }\n\n    /**\n     * Check if a certain page is the root of a main menu handler currently displayed.\n     *\n     * @param pageName Name of the page.\n     * @returns Promise resolved with boolean: whether it's the root of a main menu handler.\n     */\n    async isCurrentMainMenuHandler(pageName: string): Promise<boolean> {\n        const handlers = await this.getCurrentMainMenuHandlers();\n\n        const handler = handlers.find((handler) => {\n            const tabRoot = /^[^/]+/.exec(handler.page)?.[0] ?? handler.page;\n\n            return tabRoot == pageName;\n        });\n\n        return !!handler;\n    }\n\n    /**\n     * Check if responsive main menu items is disabled in the current site.\n     *\n     * @returns Whether it's disabled.\n     */\n    protected isResponsiveMainMenuItemsDisabledInCurrentSite(): boolean {\n        const site = CoreSites.getCurrentSite();\n\n        return !!site?.isFeatureDisabled('NoDelegate_ResponsiveMainMenuItems');\n    }\n\n}\n\nexport const CoreMainMenu = makeSingleton(CoreMainMenuProvider);\n\n/**\n * Custom main menu item.\n */\nexport interface CoreMainMenuCustomItem {\n    /**\n     * Type of the item: app, inappbrowser, browser or embedded.\n     */\n    type: string;\n\n    /**\n     * Url of the item.\n     */\n    url: string;\n\n    /**\n     * Label to display for the item.\n     */\n    label: string;\n\n    /**\n     * Name of the icon to display for the item.\n     */\n    icon: string;\n}\n\n/**\n * Custom main menu item with localized text.\n */\nexport type CoreMainMenuLocalizedCustomItem = Omit<CoreMainMenuCustomItem, 'label'> & {\n    label: string | Record<CoreLangLanguage, string>;\n};\n\n/**\n * Map of custom menu items.\n */\ntype CustomMenuItemsMap = Record<string, {\n    url: string;\n    type: string;\n    position: number;\n    labels: {\n        [lang: string]: {\n            label: string;\n            icon: string;\n        };\n    };\n}>;\n\nexport type CoreMainMenuHandlerBadgeUpdatedEventData = {\n    handler: string; // Handler name.\n    value: number; // New counter value.\n};\n"],"mappings":";;;AAgBA,SAASA,QAAQ,EAAEC,cAAc,QAA0B,gBAAgB;AAC3E,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,aAAa,QAAQ,kBAAkB;AAChD,SAASC,oBAAoB,QAAsC,qBAAqB;AACxF,SAASC,MAAM,EAAEC,aAAa,QAAQ,aAAa;AACnD,SAASC,SAAS,QAAQ,mBAAmB;AAC7C,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,UAAU,QAAQ,kBAAkB;AAC7C,SAASC,YAAY,QAAQ,oBAAoB;;AAgBjD;;;AAIA,OAAM,MAAOC,oBAAoB;EAQ7B;;;;;EAKMC,0BAA0BA,CAAA;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAC5B,MAAMC,QAAQ,SAASX,oBAAoB,CAACY,qBAAqB,EAAE;MAEnE,OAAOD,QAAQ,CAACE,MAAM,CAACC,OAAO,IAAI,CAACA,OAAO,CAACC,UAAU,CAAC,CAACC,KAAK,CAAC,CAAC,EAAEP,KAAI,CAACQ,WAAW,EAAE,CAAC;IAAC;EACxF;EAEA;;;;;;EAMMC,kBAAkBA,CAACC,MAAe;IAAA,IAAAC,MAAA;IAAA,OAAAV,iBAAA;MACpC,MAAMW,WAAW,SAASC,OAAO,CAACC,GAAG,CAAC,CAClCH,MAAI,CAACI,0BAA0B,CAACL,MAAM,CAAC,EACvCC,MAAI,CAACK,wBAAwB,EAAE,CAClC,CAAC;MAEF,OAAOtB,SAAS,CAACuB,OAAO,CAACL,WAAW,CAAC;IAAC;EAC1C;EAEA;;;;;;EAMgBG,0BAA0BA,CAACL,MAAe;IAAA,OAAAT,iBAAA;MACtD,MAAMiB,IAAI,SAAS7B,SAAS,CAAC8B,OAAO,CAACT,MAAM,CAAC;MAE5C,MAAMU,WAAW,GAAGF,IAAI,CAACG,eAAe,CAAC,6BAA6B,CAAC;MACvE,MAAMC,GAAG,GAAuB,EAAE;MAClC,MAAMC,MAAM,GAA6B,EAAE;MAE3C,IAAIC,QAAQ,GAAG,CAAC,CAAC,CAAC;MAElB,IAAI,CAACJ,WAAW,IAAI,OAAOA,WAAW,IAAI,QAAQ,EAAE;QAChD;QACA,OAAOG,MAAM;;MAGjB;MACA,MAAME,KAAK,GAAGL,WAAW,CAACM,KAAK,CAAC,gBAAgB,CAAC;MACjDD,KAAK,CAACE,OAAO,CAAEC,IAAI,IAAI;QACnB,MAAMC,MAAM,GAAGD,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC;QAC9B,MAAMI,KAAK,GAAGD,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAACE,IAAI,EAAE,GAAGF,MAAM,CAAC,CAAC,CAAC;QACtD,MAAMG,GAAG,GAAGH,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAACE,IAAI,EAAE,GAAGF,MAAM,CAAC,CAAC,CAAC;QACpD,MAAMI,IAAI,GAAGJ,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAACE,IAAI,EAAE,GAAGF,MAAM,CAAC,CAAC,CAAC;QACrD,MAAMK,IAAI,GAAG,CAACL,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAACE,IAAI,EAAE,GAAGF,MAAM,CAAC,CAAC,CAAC,KAAK,MAAM;QACjE,IAAIM,IAAI,GAAGN,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAACE,IAAI,EAAE,GAAGF,MAAM,CAAC,CAAC,CAAC;QAEnD,IAAI,CAACC,KAAK,IAAI,CAACE,GAAG,IAAI,CAACC,IAAI,EAAE;UACzB;UACA;;QAGJ,MAAMG,EAAE,GAAGJ,GAAG,GAAG,GAAG,GAAGC,IAAI;QAC3B,IAAI,CAACE,IAAI,EAAE;UACP;UACAA,IAAI,GAAGF,IAAI,IAAI,UAAU,GAAG,WAAW,GAAG,SAAS,CAAC,CAAC;;;QAGzD,IAAI,CAACX,GAAG,CAACc,EAAE,CAAC,EAAE;UACV;UACAd,GAAG,CAACc,EAAE,CAAC,GAAG;YACNJ,GAAG,EAAEA,GAAG;YACRC,IAAI,EAAEA,IAAI;YACVT,QAAQ,EAAEA,QAAQ;YAClBa,MAAM,EAAE;WACX;UACDb,QAAQ,EAAE;;QAGdF,GAAG,CAACc,EAAE,CAAC,CAACC,MAAM,CAACH,IAAI,CAACI,WAAW,EAAE,CAAC,GAAG;UACjCR,KAAK,EAAEA,KAAK;UACZK,IAAI,EAAEA;SACT;MACL,CAAC,CAAC;MAEF,IAAI,CAACX,QAAQ,EAAE;QACX;QACA,OAAOD,MAAM;;MAGjB,MAAMgB,cAAc,SAASpD,QAAQ,CAACqD,kBAAkB,EAAE;MAC1D,MAAMC,cAAc,GAAGtD,QAAQ,CAACuD,cAAc,CAACH,cAAc,iCAAqB;MAClF,MAAMI,YAAY,GAAGrD,aAAa,CAACsD,MAAM,CAACC,YAAY,IAAI,IAAI;MAE9D;MACA,KAAK,MAAMT,EAAE,IAAId,GAAG,EAAE;QAAA,IAAAwB,IAAA,EAAAC,KAAA,EAAAC,KAAA,EAAAC,KAAA,EAAAC,qBAAA;QAClB,MAAMC,KAAK,GAAG7B,GAAG,CAACc,EAAE,CAAC;QACrB,IAAIgB,IAAI,IAAAN,IAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,qBAAA,GAAGC,KAAK,CAACd,MAAM,CAACE,cAAc,CAAC,cAAAW,qBAAA,cAAAA,qBAAA,GAChCC,KAAK,CAACd,MAAM,CAACI,cAAc,CAAC,cAAAQ,KAAA,cAAAA,KAAA,GAC5BE,KAAK,CAACd,MAAM,CAACE,cAAc,GAAG,OAAO,CAAC,cAAAS,KAAA,cAAAA,KAAA,GACtCG,KAAK,CAACd,MAAM,CAACI,cAAc,GAAG,OAAO,CAAC,cAAAM,KAAA,cAAAA,KAAA,GACtCI,KAAK,CAACd,MAAM,CAACgB,IAAI,cAAAP,IAAA,cAAAA,IAAA,GACjBK,KAAK,CAACd,MAAM,CAACM,YAAY,CAAC;QAEjC,IAAI,CAACS,IAAI,EAAE;UACP;UACA,KAAK,MAAMlB,IAAI,IAAIiB,KAAK,CAACd,MAAM,EAAE;YAC7B,IAAIH,IAAI,CAACoB,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE;cAC7BF,IAAI,GAAGD,KAAK,CAACd,MAAM,CAACH,IAAI,CAAC;cACzB;;;UAIR,IAAI,CAACkB,IAAI,EAAE;YACP;YACA;;;QAIR7B,MAAM,CAAC4B,KAAK,CAAC3B,QAAQ,CAAC,GAAG;UACrBQ,GAAG,EAAEmB,KAAK,CAACnB,GAAG;UACdC,IAAI,EAAEkB,KAAK,CAAClB,IAAI;UAChBH,KAAK,EAAEsB,IAAI,CAACtB,KAAK;UACjBK,IAAI,EAAEiB,IAAI,CAACjB;SACd;;MAGL;MACA,OAAOZ,MAAM,CAACnB,MAAM,CAAE+C,KAAK,IAAKA,KAAK,KAAKI,SAAS,CAAC;IAAC;EACzD;EAEA;;;;;EAKgBvC,wBAAwBA,CAAA;IAAA,OAAAf,iBAAA;MACpC,MAAMwB,KAAK,GAAGnC,aAAa,CAACsD,MAAM,CAACY,mBAAmB;MAEtD,IAAI,CAAC/B,KAAK,EAAE;QACR,OAAO,EAAE;;MAGb,MAAMgC,WAAW,SAAStE,QAAQ,CAACqD,kBAAkB,EAAE;MAEvD,MAAMG,YAAY,GAAGrD,aAAa,CAACsD,MAAM,CAACC,YAAY,IAAI,IAAI;MAC9D,MAAMa,YAAY,GAAG;QACjBC,UAAU,EAAE,EAAE;QACdC,SAAS,EAAEpE,MAAM,CAACqE;OACrB;MAED,IAAIhE,YAAY,CAACiE,SAAS,EAAE,EAAE;QAC1BJ,YAAY,CAACC,UAAU,GAAG,SAAS;OACtC,MAAM,IAAI9D,YAAY,CAACkE,KAAK,EAAE,EAAE;QAC7BL,YAAY,CAACC,UAAU,GAAG,gBAAgB;OAC7C,MAAM;QACHD,YAAY,CAACC,UAAU,GAAG,OAAO;;MAGrC,OAAOlC,KAAK,CACPrB,MAAM,CAACwB,IAAI,IAAI,OAAOA,IAAI,CAACE,KAAK,KAAK,QAAQ,IAAI2B,WAAW,IAAI7B,IAAI,CAACE,KAAK,IAAIa,YAAY,IAAIf,IAAI,CAACE,KAAK,CAAC,CACzGR,GAAG,CAACM,IAAI;QAAA,IAAAoC,qBAAA;QAAA,OAAAC,aAAA,CAAAA,aAAA,KACFrC,IAAI;UACPI,GAAG,EAAErC,aAAa,CAACuE,gBAAgB,CAACtC,IAAI,CAACI,GAAG,EAAE0B,YAAY,EAAE,KAAK,CAAC;UAClE5B,KAAK,EAAE,OAAOF,IAAI,CAACE,KAAK,KAAK,QAAQ,GAC/BF,IAAI,CAACE,KAAK,IAAAkC,qBAAA,GACVpC,IAAI,CAACE,KAAK,CAAC2B,WAAW,CAAC,cAAAO,qBAAA,cAAAA,qBAAA,GAAIpC,IAAI,CAACE,KAAK,CAACa,YAAY;QAAC;MAAA,CAC3D,CAAC;IAAC;EACZ;EAEA;;;;;EAKAnC,WAAWA,CAAA;IACP,IAAI,CAAC,IAAI,CAAC2D,8CAA8C,EAAE,IAAIC,MAAM,IAAIA,MAAM,CAACC,UAAU,EAAE;MACvF,IAAIC,WAAmB;MAEvB,IAAI1E,UAAU,CAAC2E,QAAQ,EAAE;QACrB;QACAD,WAAW,GAAGE,IAAI,CAACC,KAAK,CAACL,MAAM,CAACM,WAAW,GAAG5E,oBAAoB,CAAC6E,cAAc,CAAC;OACrF,MAAM;QACHL,WAAW,GAAGE,IAAI,CAACC,KAAK,CAACL,MAAM,CAACC,UAAU,GAAGvE,oBAAoB,CAAC6E,cAAc,CAAC;QAEjF;QACAL,WAAW,GAAGA,WAAW,IAAI,CAAC,GAAG,CAAC,GAAGA,WAAW;;MAGpD;MACA,OAAOA,WAAW,GAAG,CAAC,GAAGA,WAAW,GAAG,CAAC,GAAG,CAAC;;IAGhD,OAAOxE,oBAAoB,CAAC8E,iBAAiB;EACjD;EAEA;;;;;EAKAC,eAAeA,CAAA;IACX,OAAOjF,UAAU,CAAC2E,QAAQ,GAAG,MAAM,GAAG,QAAQ;EAClD;EAEA;;;;;;EAMMO,aAAaA,CAACC,QAAgB;IAAA,IAAAC,MAAA;IAAA,OAAA/E,iBAAA;MAChC,IAAI8E,QAAQ,IAAIjF,oBAAoB,CAACmF,cAAc,EAAE;QACjD,OAAO,IAAI;;MAGf,OAAOD,MAAI,CAACE,wBAAwB,CAACH,QAAQ,CAAC;IAAC;EACnD;EAEA;;;;;;EAMMG,wBAAwBA,CAACH,QAAgB;IAAA,IAAAI,MAAA;IAAA,OAAAlF,iBAAA;MAC3C,MAAMC,QAAQ,SAASiF,MAAI,CAACpF,0BAA0B,EAAE;MAExD,MAAMM,OAAO,GAAGH,QAAQ,CAACkF,IAAI,CAAE/E,OAAO,IAAI;QAAA,IAAAgF,MAAA,EAAAC,KAAA;QACtC,MAAMC,OAAO,IAAAF,MAAA,IAAAC,KAAA,GAAG,QAAQ,CAACE,IAAI,CAACnF,OAAO,CAACoF,IAAI,CAAC,cAAAH,KAAA,uBAA3BA,KAAA,CAA8B,CAAC,CAAC,cAAAD,MAAA,cAAAA,MAAA,GAAIhF,OAAO,CAACoF,IAAI;QAEhE,OAAOF,OAAO,IAAIR,QAAQ;MAC9B,CAAC,CAAC;MAEF,OAAO,CAAC,CAAC1E,OAAO;IAAC;EACrB;EAEA;;;;;EAKU8D,8CAA8CA,CAAA;IACpD,MAAMjD,IAAI,GAAG7B,SAAS,CAACqG,cAAc,EAAE;IAEvC,OAAO,CAAC,EAACxE,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEyE,iBAAiB,CAAC,oCAAoC,CAAC;EAC1E;;SA7PS7F,oBAAoB;AAEb8F,MAAA,CAAAhB,iBAAiB,GAAG,CAAC;AACrBgB,MAAA,CAAAjB,cAAc,GAAG,EAAE;AAAE;AACrBiB,MAAA,CAAAX,cAAc,GAAG,MAAM;AACvBW,MAAA,CAAAC,+BAA+B,GAAG,iCAAiC;AACnED,MAAA,CAAAE,4BAA4B,GAAG,6BAA6B;;mBANnEhG,MAAoB;AAAA;;SAApBA,MAAoB;EAAAiG,OAAA,EAApBjG,MAAoB,CAAAkG,IAAA;EAAAC,UAAA,EADP;AAAM;AAkQhC,OAAO,MAAMC,YAAY,GAAGzG,aAAa,CAACK,oBAAoB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}