{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreCancellablePromise } from '@classes/cancellable-promise';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\n/**\n * Singleton with helper functions for dom.\n */\nexport class CoreDom {\n  // Avoid creating singleton instances.\n  constructor() {\n    // Nothing to do.\n  }\n  /**\n   * Perform a dom closest function piercing the shadow DOM.\n   *\n   * @param node DOM Element.\n   * @param selector Selector to search.\n   * @returns Closest ancestor or null if not found.\n   */\n  static closest(node, selector) {\n    if (!node) {\n      return null;\n    }\n    if (node instanceof ShadowRoot) {\n      return CoreDom.closest(node.host, selector);\n    }\n    if (node instanceof HTMLElement) {\n      if (node.matches(selector)) {\n        return node;\n      } else {\n        return CoreDom.closest(node.parentNode, selector);\n      }\n    }\n    return CoreDom.closest(node.parentNode, selector);\n  }\n  /**\n   * Retrieve the position of a element relative to another element.\n   *\n   * @param element Element to get the position.\n   * @param parent Parent element to get relative position.\n   * @returns X and Y position.\n   */\n  static getRelativeElementPosition(element, parent) {\n    // Get the top, left coordinates of two elements\n    const elementRectangle = element.getBoundingClientRect();\n    const parentRectangle = parent.getBoundingClientRect();\n    // Calculate the top and left positions.\n    return {\n      x: elementRectangle.x - parentRectangle.x,\n      y: elementRectangle.y - parentRectangle.y\n    };\n  }\n  /**\n   * Check whether an element has been added to the DOM.\n   *\n   * @param element Element.\n   * @returns True if element has been added to the DOM, false otherwise.\n   */\n  static isElementInDom(element) {\n    return element.getRootNode({\n      composed: true\n    }) === document;\n  }\n  /**\n   * Check whether an element is intersecting the intersectionRatio in viewport.\n   *\n   * @param element Element to check.\n   * @param intersectionRatio Intersection ratio (From 0 to 1).\n   * @param container Container where element is located\n   * @returns True if in viewport.\n   */\n  static isElementInViewport(element, intersectionRatio = 1, container = null) {\n    var _containerRectangle$t, _containerRectangle$l, _containerRectangle$b, _containerRectangle$r;\n    const elementRectangle = element.getBoundingClientRect();\n    const containerRectangle = container === null || container === void 0 ? void 0 : container.getBoundingClientRect();\n    const elementArea = elementRectangle.width * elementRectangle.height;\n    if (elementArea == 0) {\n      return false;\n    }\n    const intersectionRectangle = {\n      top: Math.max((_containerRectangle$t = containerRectangle === null || containerRectangle === void 0 ? void 0 : containerRectangle.top) !== null && _containerRectangle$t !== void 0 ? _containerRectangle$t : 0, elementRectangle.top),\n      left: Math.max((_containerRectangle$l = containerRectangle === null || containerRectangle === void 0 ? void 0 : containerRectangle.left) !== null && _containerRectangle$l !== void 0 ? _containerRectangle$l : 0, elementRectangle.left),\n      bottom: Math.min((_containerRectangle$b = containerRectangle === null || containerRectangle === void 0 ? void 0 : containerRectangle.bottom) !== null && _containerRectangle$b !== void 0 ? _containerRectangle$b : window.innerHeight, elementRectangle.bottom),\n      right: Math.min((_containerRectangle$r = containerRectangle === null || containerRectangle === void 0 ? void 0 : containerRectangle.right) !== null && _containerRectangle$r !== void 0 ? _containerRectangle$r : window.innerWidth, elementRectangle.right)\n    };\n    const intersectionArea = (intersectionRectangle.right - intersectionRectangle.left) * (intersectionRectangle.bottom - intersectionRectangle.top);\n    return intersectionArea / elementArea >= intersectionRatio;\n  }\n  /**\n   * Check whether an element is visible or not.\n   *\n   * @param element Element.\n   * @param checkSize Wether to check size to check for visibility.\n   * @returns True if element is visible inside the DOM.\n   */\n  static isElementVisible(element, checkSize = true) {\n    if (checkSize) {\n      const dimensions = element.getBoundingClientRect();\n      if (dimensions.width === 0 || dimensions.height === 0) {\n        return false;\n      }\n    }\n    const style = getComputedStyle(element);\n    if (style.opacity === '0' || style.display === 'none' || style.visibility === 'hidden') {\n      return false;\n    }\n    return CoreDom.isElementInDom(element);\n  }\n  /**\n   * Runs a function when an element has been slotted.\n   *\n   * @param element HTML Element inside an ion-content to wait for slot.\n   * @param callback Function to execute on resize.\n   */\n  static onElementSlot(element, callback) {\n    var _element$assignedSlot;\n    if (!element.slot) {\n      // Element not declared to be slotted.\n      return;\n    }\n    const slotName = element.slot;\n    if (((_element$assignedSlot = element.assignedSlot) === null || _element$assignedSlot === void 0 ? void 0 : _element$assignedSlot.name) === slotName) {\n      // Slot already assigned.\n      callback();\n      return;\n    }\n    const content = element.closest('ion-content');\n    if (!content || !content.shadowRoot) {\n      // Cannot find content.\n      return;\n    }\n    const slots = content.shadowRoot.querySelectorAll('slot');\n    const slot = Array.from(slots).find(slot => slot.name === slotName);\n    if (!slot) {\n      // Slot not found.\n      return;\n    }\n    const slotListener = () => {\n      var _element$assignedSlot2;\n      if (((_element$assignedSlot2 = element.assignedSlot) === null || _element$assignedSlot2 === void 0 ? void 0 : _element$assignedSlot2.name) !== slotName) {\n        return;\n      }\n      callback();\n      // It would happen only once.\n      slot.removeEventListener('slotchange', slotListener);\n    };\n    slot.addEventListener('slotchange', slotListener);\n  }\n  /**\n   * Window resize is widely checked and may have many performance issues, debouce usage is needed to avoid calling it too much.\n   * This function helps setting up the debounce feature and remove listener easily.\n   *\n   * @param resizeFunction Function to execute on resize.\n   * @param debounceDelay Debounce time in ms.\n   * @returns Event observer to call off when finished.\n   */\n  static onWindowResize(resizeFunction, debounceDelay = 20) {\n    const resizeListener = CoreUtils.debounce( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (ev) {\n        yield CoreDomUtils.waitForResizeDone();\n        resizeFunction(ev);\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }(), debounceDelay);\n    window.addEventListener('resize', resizeListener);\n    return {\n      off: () => {\n        window.removeEventListener('resize', resizeListener);\n      }\n    };\n  }\n  /**\n   * Scroll to a certain element.\n   *\n   * @param element The element to scroll to.\n   * @param selector Selector to find the element to scroll to inside the defined element.\n   * @param scrollOptions Scroll Options.\n   * @returns Wether the scroll suceeded.\n   */\n  static scrollToElement(element, selector, scrollOptions = {}) {\n    return _asyncToGenerator(function* () {\n      var _element$closest;\n      if (selector) {\n        const foundElement = yield CoreDom.waitToBeInsideElement(element, selector);\n        if (!foundElement) {\n          // Element not found.\n          return false;\n        }\n        element = foundElement;\n      }\n      yield CoreDom.waitToBeVisible(element, false);\n      const content = (_element$closest = element.closest('ion-content')) !== null && _element$closest !== void 0 ? _element$closest : undefined;\n      if (!content) {\n        // Content to scroll, not found.\n        return false;\n      }\n      try {\n        var _scrollOptions$durati, _scrollOptions$addXAx, _scrollOptions$addYAx;\n        const position = CoreDom.getRelativeElementPosition(element, content);\n        const scrollElement = yield content.getScrollElement();\n        scrollOptions.duration = (_scrollOptions$durati = scrollOptions.duration) !== null && _scrollOptions$durati !== void 0 ? _scrollOptions$durati : 200;\n        scrollOptions.addXAxis = (_scrollOptions$addXAx = scrollOptions.addXAxis) !== null && _scrollOptions$addXAx !== void 0 ? _scrollOptions$addXAx : 0;\n        scrollOptions.addYAxis = (_scrollOptions$addYAx = scrollOptions.addYAxis) !== null && _scrollOptions$addYAx !== void 0 ? _scrollOptions$addYAx : 0;\n        yield content.scrollToPoint(position.x + scrollElement.scrollLeft + scrollOptions.addXAxis, position.y + scrollElement.scrollTop + scrollOptions.addYAxis, scrollOptions.duration);\n        return true;\n      } catch (_unused) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Search for an input with error (core-input-error directive) and scrolls to it if found.\n   *\n   * @param container The element that contains the element that must be scrolled.\n   * @returns True if the element is found, false otherwise.\n   */\n  static scrollToInputError(container) {\n    return _asyncToGenerator(function* () {\n      return CoreDom.scrollToElement(container, '.core-input-error');\n    })();\n  }\n  /**\n   * Has the scroll reached bottom?\n   *\n   * @param scrollElement Scroll Element.\n   * @param marginError Error margin when calculating.\n   * @returns Wether the scroll reached the bottom.\n   */\n  static scrollIsBottom(scrollElement, marginError = 0) {\n    if (!scrollElement) {\n      return true;\n    }\n    return scrollElement.scrollTop + scrollElement.clientHeight >= scrollElement.scrollHeight - marginError;\n  }\n  /**\n   * Move element to content so it can be slotted.\n   *\n   * @param element HTML Element.\n   * @param slot Slot name.\n   * @returns Promise resolved when done.\n   */\n  static slotOnContent(element, slot = 'fixed') {\n    var _element$parentElemen;\n    element.setAttribute('slot', slot);\n    if (((_element$parentElemen = element.parentElement) === null || _element$parentElemen === void 0 ? void 0 : _element$parentElemen.nodeName) === 'ION-CONTENT') {\n      return CoreCancellablePromise.resolve();\n    }\n    const domPromise = CoreDom.waitToBeInDOM(element);\n    return new CoreCancellablePromise( /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (resolve) {\n        var _element$parentElemen2;\n        yield domPromise;\n        // Move element to the nearest ion-content if it's not the parent\n        if (((_element$parentElemen2 = element.parentElement) === null || _element$parentElemen2 === void 0 ? void 0 : _element$parentElemen2.nodeName) !== 'ION-CONTENT') {\n          var _element$closest2;\n          (_element$closest2 = element.closest('ion-content')) === null || _element$closest2 === void 0 || _element$closest2.appendChild(element);\n        }\n        resolve();\n      });\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }(), () => {\n      domPromise.cancel();\n    });\n  }\n  /**\n   * Wait an element to be added to the root DOM.\n   *\n   * @param element Element to wait.\n   * @returns Cancellable promise.\n   */\n  static waitToBeInDOM(element) {\n    const root = element.getRootNode({\n      composed: true\n    });\n    if (root === document) {\n      // Already in DOM.\n      return CoreCancellablePromise.resolve();\n    }\n    let observer;\n    return new CoreCancellablePromise(resolve => {\n      observer = new MutationObserver(() => {\n        var _observer;\n        const root = element.getRootNode({\n          composed: true\n        });\n        if (root !== document) {\n          return;\n        }\n        (_observer = observer) === null || _observer === void 0 || _observer.disconnect();\n        resolve();\n      });\n      observer.observe(document.body, {\n        subtree: true,\n        childList: true\n      });\n    }, () => {\n      var _observer2;\n      (_observer2 = observer) === null || _observer2 === void 0 || _observer2.disconnect();\n    });\n  }\n  /**\n   * Wait an element to be in dom of another element using a selector\n   *\n   * @param container Element to wait.\n   * @returns Cancellable promise.\n   */\n  static waitToBeInsideElement(container, selector) {\n    return _asyncToGenerator(function* () {\n      yield CoreDom.waitToBeInDOM(container);\n      let element = container.querySelector(selector);\n      if (element) {\n        // Already in DOM.\n        return CoreCancellablePromise.resolve(element);\n      }\n      let observer;\n      return new CoreCancellablePromise(resolve => {\n        observer = new MutationObserver(() => {\n          var _observer3;\n          element = container.querySelector(selector);\n          if (!element) {\n            return;\n          }\n          (_observer3 = observer) === null || _observer3 === void 0 || _observer3.disconnect();\n          resolve(element);\n        });\n        observer.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      }, () => {\n        var _observer4;\n        (_observer4 = observer) === null || _observer4 === void 0 || _observer4.disconnect();\n      });\n    })();\n  }\n  static watchElementInViewport(element, intersectionRatioOrCallback, callback) {\n    const visibleCallback = callback !== null && callback !== void 0 ? callback : intersectionRatioOrCallback;\n    const intersectionRatio = typeof intersectionRatioOrCallback === 'number' ? intersectionRatioOrCallback : 1;\n    let visible = CoreDom.isElementInViewport(element, intersectionRatio);\n    const setVisible = newValue => {\n      if (visible === newValue) {\n        return;\n      }\n      visible = newValue;\n      visibleCallback(visible);\n    };\n    if (!('IntersectionObserver' in window)) {\n      const interval = setInterval(() => setVisible(CoreDom.isElementInViewport(element, intersectionRatio)), 50);\n      return () => clearInterval(interval);\n    }\n    const observer = new IntersectionObserver(([{\n      isIntersecting,\n      intersectionRatio\n    }]) => {\n      setVisible(isIntersecting && intersectionRatio >= intersectionRatio);\n    });\n    observer.observe(element);\n    return () => observer.disconnect();\n  }\n  /**\n   * Wait an element to be in dom and visible.\n   *\n   * @param element Element to wait.\n   * @param intersectionRatio Intersection ratio (From 0 to 1).\n   * @returns Cancellable promise.\n   */\n  static waitToBeInViewport(element, intersectionRatio = 1) {\n    var _this = this;\n    let unsubscribe;\n    const visiblePromise = CoreDom.waitToBeVisible(element);\n    return new CoreCancellablePromise( /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (resolve) {\n        yield visiblePromise;\n        if (CoreDom.isElementInViewport(element, intersectionRatio)) {\n          return resolve();\n        }\n        unsubscribe = _this.watchElementInViewport(element, intersectionRatio, inViewport => {\n          var _unsubscribe;\n          if (!inViewport) {\n            return;\n          }\n          resolve();\n          (_unsubscribe = unsubscribe) === null || _unsubscribe === void 0 || _unsubscribe();\n        });\n      });\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }(), () => {\n      var _unsubscribe2;\n      visiblePromise.cancel();\n      (_unsubscribe2 = unsubscribe) === null || _unsubscribe2 === void 0 || _unsubscribe2();\n    });\n  }\n  /**\n   * Wait an element to be in dom and visible.\n   *\n   * @param element Element to wait.\n   * @param checkSize Wether to check size to check for visibility.\n   * @returns Cancellable promise.\n   */\n  static waitToBeVisible(element, checkSize = true) {\n    const domPromise = CoreDom.waitToBeInDOM(element);\n    let interval;\n    // Mutations did not observe for visibility properties.\n    return new CoreCancellablePromise( /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (resolve) {\n        yield domPromise;\n        if (CoreDom.isElementVisible(element, checkSize)) {\n          return resolve();\n        }\n        interval = window.setInterval(() => {\n          if (!CoreDom.isElementVisible(element, checkSize)) {\n            return;\n          }\n          resolve();\n          window.clearInterval(interval);\n        }, 50);\n      });\n      return function (_x4) {\n        return _ref4.apply(this, arguments);\n      };\n    }(), () => {\n      domPromise.cancel();\n      window.clearInterval(interval);\n    });\n  }\n  /**\n   * Listen to click and Enter/Space keys in an element.\n   *\n   * @param element Element to listen to events.\n   * @param callback Callback to call when clicked or the key is pressed.\n   * @deprecated since 4.1.1: Use initializeClickableElementA11y instead.\n   */\n  static onActivate(element, callback) {\n    this.initializeClickableElementA11y(element, callback);\n  }\n  /**\n   * Initializes a clickable element a11y calling the click action when pressed enter or space\n   * and adding tabindex and role if needed.\n   *\n   * @param element Element to listen to events.\n   * @param callback Callback to call when clicked or the key is pressed.\n   */\n  static initializeClickableElementA11y(element, callback) {\n    const enabled = () => {\n      var _element$dataset$disa;\n      return !CoreUtils.isTrueOrOne((_element$dataset$disa = element.dataset.disabledA11yClicks) !== null && _element$dataset$disa !== void 0 ? _element$dataset$disa : 'false');\n    };\n    element.addEventListener('click', event => enabled() && callback(event));\n    element.addEventListener('keydown', event => {\n      if (!enabled()) {\n        return;\n      }\n      if (event.key === ' ' || event.key === 'Enter') {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    });\n    element.addEventListener('keyup', event => {\n      if (!enabled()) {\n        return;\n      }\n      if (event.key === ' ' || event.key === 'Enter') {\n        event.preventDefault();\n        event.stopPropagation();\n        callback(event);\n      }\n    });\n    if (element.tagName !== 'BUTTON' && element.tagName !== 'A') {\n      // Set tabindex if not previously set.\n      if (element.getAttribute('tabindex') === null) {\n        element.setAttribute('tabindex', element.disabled ? '-1' : '0');\n      }\n      // Set role if not previously set.\n      if (!element.getAttribute('role')) {\n        element.setAttribute('role', 'button');\n      }\n      element.classList.add('clickable');\n    }\n  }\n  /**\n   * Get CSS property value from computed styles.\n   *\n   * @param styles Computed styles.\n   * @param property Property name.\n   * @returns Property CSS value (may not be the same as the computed value).\n   */\n  static getCSSPropertyValue(styles, property) {\n    const value = styles.getPropertyValue(property);\n    if (property === 'font-size') {\n      if (this.fontSizeZoom === null) {\n        const baseFontSize = 20;\n        const span = document.createElement('span');\n        span.style.opacity = '0';\n        span.style.fontSize = `${baseFontSize}px`;\n        document.body.append(span);\n        this.fontSizeZoom = baseFontSize / Number(getComputedStyle(span).fontSize.slice(0, -2));\n        span.remove();\n      }\n      if (this.fontSizeZoom !== 1) {\n        return `calc(${this.fontSizeZoom} * ${value})`;\n      }\n    }\n    return value;\n  }\n  /**\n   * Replace tags on HTMLElement.\n   *\n   * @param element HTML Element where to replace the tags.\n   * @param originTags Origin tag to be replaced.\n   * @param destinationTags Destination tag to replace.\n   * @returns Element with tags replaced.\n   */\n  static replaceTags(element, originTags, destinationTags) {\n    if (typeof originTags === 'string') {\n      originTags = [originTags];\n    }\n    if (typeof destinationTags === 'string') {\n      destinationTags = [destinationTags];\n    }\n    if (originTags.length !== destinationTags.length) {\n      // Do nothing, incorrect input.\n      return element;\n    }\n    originTags.forEach((originTag, index) => {\n      const destinationTag = destinationTags[index];\n      const elems = Array.from(element.getElementsByTagName(originTag));\n      elems.forEach(elem => {\n        var _elem$parentNode;\n        const newElem = document.createElement(destinationTag);\n        newElem.innerHTML = elem.innerHTML;\n        if (elem.hasAttributes()) {\n          const attrs = Array.from(elem.attributes);\n          attrs.forEach(attr => {\n            newElem.setAttribute(attr.name, attr.value);\n          });\n        }\n        (_elem$parentNode = elem.parentNode) === null || _elem$parentNode === void 0 || _elem$parentNode.replaceChild(newElem, elem);\n      });\n    });\n    return element;\n  }\n}\n_class = CoreDom;\n_class.fontSizeZoom = null;","map":{"version":3,"names":["CoreCancellablePromise","CoreDomUtils","CoreUtils","CoreDom","constructor","closest","node","selector","ShadowRoot","host","HTMLElement","matches","parentNode","getRelativeElementPosition","element","parent","elementRectangle","getBoundingClientRect","parentRectangle","x","y","isElementInDom","getRootNode","composed","document","isElementInViewport","intersectionRatio","container","_containerRectangle$t","_containerRectangle$l","_containerRectangle$b","_containerRectangle$r","containerRectangle","elementArea","width","height","intersectionRectangle","top","Math","max","left","bottom","min","window","innerHeight","right","innerWidth","intersectionArea","isElementVisible","checkSize","dimensions","style","getComputedStyle","opacity","display","visibility","onElementSlot","callback","_element$assignedSlot","slot","slotName","assignedSlot","name","content","shadowRoot","slots","querySelectorAll","Array","from","find","slotListener","_element$assignedSlot2","removeEventListener","addEventListener","onWindowResize","resizeFunction","debounceDelay","resizeListener","debounce","_ref","_asyncToGenerator","ev","waitForResizeDone","_x","apply","arguments","off","scrollToElement","scrollOptions","_element$closest","foundElement","waitToBeInsideElement","waitToBeVisible","undefined","_scrollOptions$durati","_scrollOptions$addXAx","_scrollOptions$addYAx","position","scrollElement","getScrollElement","duration","addXAxis","addYAxis","scrollToPoint","scrollLeft","scrollTop","_unused","scrollToInputError","scrollIsBottom","marginError","clientHeight","scrollHeight","slotOnContent","_element$parentElemen","setAttribute","parentElement","nodeName","resolve","domPromise","waitToBeInDOM","_ref2","_element$parentElemen2","_element$closest2","appendChild","_x2","cancel","root","observer","MutationObserver","_observer","disconnect","observe","body","subtree","childList","_observer2","querySelector","_observer3","_observer4","watchElementInViewport","intersectionRatioOrCallback","visibleCallback","visible","setVisible","newValue","interval","setInterval","clearInterval","IntersectionObserver","isIntersecting","waitToBeInViewport","_this","unsubscribe","visiblePromise","_ref3","inViewport","_unsubscribe","_x3","_unsubscribe2","_ref4","_x4","onActivate","initializeClickableElementA11y","enabled","_element$dataset$disa","isTrueOrOne","dataset","disabledA11yClicks","event","key","preventDefault","stopPropagation","tagName","getAttribute","disabled","classList","add","getCSSPropertyValue","styles","property","value","getPropertyValue","fontSizeZoom","baseFontSize","span","createElement","fontSize","append","Number","slice","remove","replaceTags","originTags","destinationTags","length","forEach","originTag","index","destinationTag","elems","getElementsByTagName","elem","_elem$parentNode","newElem","innerHTML","hasAttributes","attrs","attributes","attr","replaceChild","_class"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/singletons/dom.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreCancellablePromise } from '@classes/cancellable-promise';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreEventObserver } from '@singletons/events';\n\n/**\n * Singleton with helper functions for dom.\n */\nexport class CoreDom {\n\n    static fontSizeZoom: number | null = null;\n\n    // Avoid creating singleton instances.\n    private constructor() {\n        // Nothing to do.\n    }\n\n    /**\n     * Perform a dom closest function piercing the shadow DOM.\n     *\n     * @param node DOM Element.\n     * @param selector Selector to search.\n     * @returns Closest ancestor or null if not found.\n     */\n    static closest<T = HTMLElement>(node: HTMLElement | Node | null, selector: string): T | null {\n        if (!node) {\n            return null;\n        }\n\n        if (node instanceof ShadowRoot) {\n            return CoreDom.closest(node.host, selector);\n        }\n\n        if (node instanceof HTMLElement) {\n            if (node.matches(selector)) {\n                return node as unknown as T;\n            } else {\n                return CoreDom.closest<T>(node.parentNode, selector);\n            }\n        }\n\n        return CoreDom.closest<T>(node.parentNode, selector);\n    }\n\n    /**\n     * Retrieve the position of a element relative to another element.\n     *\n     * @param element Element to get the position.\n     * @param parent Parent element to get relative position.\n     * @returns X and Y position.\n     */\n    static getRelativeElementPosition(element: HTMLElement, parent: HTMLElement): CoreCoordinates {\n        // Get the top, left coordinates of two elements\n        const elementRectangle = element.getBoundingClientRect();\n        const parentRectangle = parent.getBoundingClientRect();\n\n        // Calculate the top and left positions.\n        return {\n            x: elementRectangle.x - parentRectangle.x,\n            y: elementRectangle.y - parentRectangle.y,\n        };\n    }\n\n    /**\n     * Check whether an element has been added to the DOM.\n     *\n     * @param element Element.\n     * @returns True if element has been added to the DOM, false otherwise.\n     */\n    static isElementInDom(element: HTMLElement): boolean {\n        return element.getRootNode({ composed: true }) === document;\n    }\n\n    /**\n     * Check whether an element is intersecting the intersectionRatio in viewport.\n     *\n     * @param element Element to check.\n     * @param intersectionRatio Intersection ratio (From 0 to 1).\n     * @param container Container where element is located\n     * @returns True if in viewport.\n     */\n    static isElementInViewport(element: HTMLElement, intersectionRatio = 1, container: HTMLElement | null = null): boolean {\n        const elementRectangle = element.getBoundingClientRect();\n        const containerRectangle = container?.getBoundingClientRect();\n        const elementArea = elementRectangle.width * elementRectangle.height;\n\n        if (elementArea == 0) {\n            return false;\n        }\n\n        const intersectionRectangle = {\n            top: Math.max(containerRectangle?.top ?? 0, elementRectangle.top),\n            left: Math.max(containerRectangle?.left ?? 0, elementRectangle.left),\n            bottom: Math.min(containerRectangle?.bottom ?? window.innerHeight, elementRectangle.bottom),\n            right: Math.min(containerRectangle?.right ?? window.innerWidth, elementRectangle.right),\n        };\n\n        const intersectionArea = (intersectionRectangle.right - intersectionRectangle.left) *\n            (intersectionRectangle.bottom - intersectionRectangle.top);\n\n        return intersectionArea / elementArea >= intersectionRatio;\n    }\n\n    /**\n     * Check whether an element is visible or not.\n     *\n     * @param element Element.\n     * @param checkSize Wether to check size to check for visibility.\n     * @returns True if element is visible inside the DOM.\n     */\n    static isElementVisible(element: HTMLElement, checkSize = true): boolean {\n        if (checkSize) {\n            const dimensions = element.getBoundingClientRect();\n\n            if (dimensions.width === 0 || dimensions.height === 0) {\n                return false;\n            }\n        }\n\n        const style = getComputedStyle(element);\n        if (style.opacity === '0' || style.display === 'none' || style.visibility === 'hidden') {\n            return false;\n        }\n\n        return CoreDom.isElementInDom(element);\n    }\n\n    /**\n     * Runs a function when an element has been slotted.\n     *\n     * @param element HTML Element inside an ion-content to wait for slot.\n     * @param callback Function to execute on resize.\n     */\n    static onElementSlot(element: HTMLElement, callback: (ev?: Event) => void): void {\n        if (!element.slot) {\n            // Element not declared to be slotted.\n            return;\n        }\n\n        const slotName = element.slot;\n        if (element.assignedSlot?.name === slotName) {\n            // Slot already assigned.\n            callback();\n\n            return;\n        }\n\n        const content = element.closest('ion-content');\n        if (!content || !content.shadowRoot) {\n            // Cannot find content.\n            return;\n        }\n\n        const slots = content.shadowRoot.querySelectorAll('slot');\n        const slot = Array.from(slots).find((slot) => slot.name === slotName);\n\n        if (!slot) {\n            // Slot not found.\n            return;\n        }\n\n        const slotListener = () => {\n            if (element.assignedSlot?.name !== slotName) {\n                return;\n            }\n\n            callback();\n            // It would happen only once.\n            slot.removeEventListener('slotchange', slotListener);\n        };\n\n        slot.addEventListener('slotchange', slotListener);\n    }\n\n    /**\n     * Window resize is widely checked and may have many performance issues, debouce usage is needed to avoid calling it too much.\n     * This function helps setting up the debounce feature and remove listener easily.\n     *\n     * @param resizeFunction Function to execute on resize.\n     * @param debounceDelay Debounce time in ms.\n     * @returns Event observer to call off when finished.\n     */\n    static onWindowResize(resizeFunction: (ev?: Event) => void, debounceDelay = 20): CoreEventObserver {\n        const resizeListener = CoreUtils.debounce(async (ev?: Event) => {\n            await CoreDomUtils.waitForResizeDone();\n\n            resizeFunction(ev);\n        }, debounceDelay);\n\n        window.addEventListener('resize', resizeListener);\n\n        return {\n            off: (): void => {\n                window.removeEventListener('resize', resizeListener);\n            },\n        };\n    }\n\n    /**\n     * Scroll to a certain element.\n     *\n     * @param element The element to scroll to.\n     * @param selector Selector to find the element to scroll to inside the defined element.\n     * @param scrollOptions Scroll Options.\n     * @returns Wether the scroll suceeded.\n     */\n    static async scrollToElement(element: HTMLElement, selector?: string, scrollOptions: CoreScrollOptions = {}): Promise<boolean> {\n        if (selector) {\n            const foundElement = await CoreDom.waitToBeInsideElement(element, selector);\n            if (!foundElement) {\n                // Element not found.\n                return false;\n            }\n\n            element = foundElement;\n        }\n\n        await CoreDom.waitToBeVisible(element, false);\n\n        const content = element.closest<HTMLIonContentElement>('ion-content') ?? undefined;\n        if (!content) {\n            // Content to scroll, not found.\n            return false;\n        }\n\n        try {\n            const position = CoreDom.getRelativeElementPosition(element, content);\n            const scrollElement = await content.getScrollElement();\n\n            scrollOptions.duration = scrollOptions.duration ?? 200;\n            scrollOptions.addXAxis = scrollOptions.addXAxis ?? 0;\n            scrollOptions.addYAxis = scrollOptions.addYAxis ?? 0;\n\n            await content.scrollToPoint(\n                position.x + scrollElement.scrollLeft + scrollOptions.addXAxis,\n                position.y + scrollElement.scrollTop + scrollOptions.addYAxis,\n                scrollOptions.duration,\n            );\n\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Search for an input with error (core-input-error directive) and scrolls to it if found.\n     *\n     * @param container The element that contains the element that must be scrolled.\n     * @returns True if the element is found, false otherwise.\n     */\n    static async scrollToInputError(container: HTMLElement): Promise<boolean> {\n        return CoreDom.scrollToElement(container, '.core-input-error');\n    }\n\n    /**\n     * Has the scroll reached bottom?\n     *\n     * @param scrollElement Scroll Element.\n     * @param marginError Error margin when calculating.\n     * @returns Wether the scroll reached the bottom.\n     */\n    static scrollIsBottom(scrollElement?: HTMLElement, marginError = 0): boolean {\n        if (!scrollElement) {\n            return true;\n        }\n\n        return scrollElement.scrollTop + scrollElement.clientHeight >= scrollElement.scrollHeight - marginError;\n    }\n\n    /**\n     * Move element to content so it can be slotted.\n     *\n     * @param element HTML Element.\n     * @param slot Slot name.\n     * @returns Promise resolved when done.\n     */\n    static slotOnContent(element: HTMLElement, slot = 'fixed'): CoreCancellablePromise<void> {\n        element.setAttribute('slot', slot);\n        if (element.parentElement?.nodeName === 'ION-CONTENT') {\n            return CoreCancellablePromise.resolve();\n        }\n\n        const domPromise = CoreDom.waitToBeInDOM(element);\n\n        return new CoreCancellablePromise<void>(\n            async (resolve) => {\n                await domPromise;\n\n                // Move element to the nearest ion-content if it's not the parent\n                if (element.parentElement?.nodeName !== 'ION-CONTENT') {\n                    element.closest('ion-content')?.appendChild(element);\n                }\n\n                resolve();\n            },\n            () => {\n                domPromise.cancel();\n            },\n        );\n    }\n\n    /**\n     * Wait an element to be added to the root DOM.\n     *\n     * @param element Element to wait.\n     * @returns Cancellable promise.\n     */\n    static waitToBeInDOM(element: HTMLElement): CoreCancellablePromise<void> {\n        const root = element.getRootNode({ composed: true });\n\n        if (root === document) {\n            // Already in DOM.\n            return CoreCancellablePromise.resolve();\n        }\n\n        let observer: MutationObserver;\n\n        return new CoreCancellablePromise<void>(\n            (resolve) => {\n                observer = new MutationObserver(() => {\n                    const root = element.getRootNode({ composed: true });\n\n                    if (root !== document) {\n                        return;\n                    }\n\n                    observer?.disconnect();\n                    resolve();\n                });\n\n                observer.observe(document.body, { subtree: true, childList: true });\n            },\n            () => {\n                observer?.disconnect();\n            },\n        );\n    }\n\n    /**\n     * Wait an element to be in dom of another element using a selector\n     *\n     * @param container Element to wait.\n     * @returns Cancellable promise.\n     */\n    static async waitToBeInsideElement(container: HTMLElement, selector: string): Promise<CoreCancellablePromise<HTMLElement>> {\n        await CoreDom.waitToBeInDOM(container);\n\n        let element = container.querySelector<HTMLElement>(selector);\n        if (element) {\n            // Already in DOM.\n            return CoreCancellablePromise.resolve(element);\n        }\n\n        let observer: MutationObserver;\n\n        return new CoreCancellablePromise<HTMLElement>(\n            (resolve) => {\n                observer = new MutationObserver(() => {\n                    element = container.querySelector<HTMLElement>(selector);\n\n                    if (!element) {\n                        return;\n                    }\n\n                    observer?.disconnect();\n                    resolve(element);\n                });\n\n                observer.observe(container, { subtree: true, childList: true });\n            },\n            () => {\n                observer?.disconnect();\n            },\n        );\n    }\n\n    /**\n     * Watch whenever an elements visibility changes within the viewport.\n     *\n     * @param element Element to watch.\n     * @param intersectionRatio Intersection ratio (From 0 to 1).\n     * @param callback Callback when visibility changes.\n     * @returns Function to stop watching.\n     */\n    static watchElementInViewport(\n        element: HTMLElement,\n        intersectionRatio: number,\n        callback: (visible: boolean) => void,\n    ): () => void;\n\n    /**\n     * Watch whenever an elements visibility changes within the viewport.\n     *\n     * @param element Element to watch.\n     * @param callback Callback when visibility changes.\n     * @returns Function to stop watching.\n     */\n    static watchElementInViewport(element: HTMLElement, callback: (visible: boolean) => void): () => void;\n\n    static watchElementInViewport(\n        element: HTMLElement,\n        intersectionRatioOrCallback: number | ((visible: boolean) => void),\n        callback?: (visible: boolean) => void,\n    ): () => void {\n        const visibleCallback = callback ?? intersectionRatioOrCallback as (visible: boolean) => void;\n        const intersectionRatio = typeof intersectionRatioOrCallback === 'number' ? intersectionRatioOrCallback : 1;\n\n        let visible = CoreDom.isElementInViewport(element, intersectionRatio);\n        const setVisible = (newValue: boolean) => {\n            if (visible === newValue) {\n                return;\n            }\n\n            visible = newValue;\n            visibleCallback(visible);\n        };\n\n        if (!('IntersectionObserver' in window)) {\n            const interval = setInterval(() => setVisible(CoreDom.isElementInViewport(element, intersectionRatio)), 50);\n\n            return () => clearInterval(interval);\n        }\n\n        const observer = new IntersectionObserver(([{ isIntersecting, intersectionRatio }]) => {\n            setVisible(isIntersecting && intersectionRatio >= intersectionRatio);\n        });\n\n        observer.observe(element);\n\n        return () => observer.disconnect();\n    }\n\n    /**\n     * Wait an element to be in dom and visible.\n     *\n     * @param element Element to wait.\n     * @param intersectionRatio Intersection ratio (From 0 to 1).\n     * @returns Cancellable promise.\n     */\n    static waitToBeInViewport(element: HTMLElement, intersectionRatio = 1): CoreCancellablePromise<void> {\n        let unsubscribe: (() => void) | undefined;\n        const visiblePromise = CoreDom.waitToBeVisible(element);\n\n        return new CoreCancellablePromise<void>(\n            async (resolve) => {\n                await visiblePromise;\n\n                if (CoreDom.isElementInViewport(element, intersectionRatio)) {\n                    return resolve();\n                }\n\n                unsubscribe = this.watchElementInViewport(element, intersectionRatio, inViewport => {\n                    if (!inViewport) {\n                        return;\n                    }\n\n                    resolve();\n                    unsubscribe?.();\n                });\n            },\n            () => {\n                visiblePromise.cancel();\n                unsubscribe?.();\n            },\n        );\n    }\n\n    /**\n     * Wait an element to be in dom and visible.\n     *\n     * @param element Element to wait.\n     * @param checkSize Wether to check size to check for visibility.\n     * @returns Cancellable promise.\n     */\n    static waitToBeVisible(element: HTMLElement, checkSize = true): CoreCancellablePromise<void> {\n        const domPromise = CoreDom.waitToBeInDOM(element);\n\n        let interval: number | undefined;\n\n        // Mutations did not observe for visibility properties.\n        return new CoreCancellablePromise<void>(\n            async (resolve) => {\n                await domPromise;\n\n                if (CoreDom.isElementVisible(element, checkSize)) {\n                    return resolve();\n                }\n\n                interval = window.setInterval(() => {\n                    if (!CoreDom.isElementVisible(element, checkSize)) {\n                        return;\n                    }\n\n                    resolve();\n                    window.clearInterval(interval);\n                }, 50);\n            },\n            () => {\n                domPromise.cancel();\n                window.clearInterval(interval);\n            },\n        );\n    }\n\n    /**\n     * Listen to click and Enter/Space keys in an element.\n     *\n     * @param element Element to listen to events.\n     * @param callback Callback to call when clicked or the key is pressed.\n     * @deprecated since 4.1.1: Use initializeClickableElementA11y instead.\n     */\n    static onActivate(\n        element: HTMLElement & {disabled?: boolean},\n        callback: (event: MouseEvent | KeyboardEvent) => void,\n    ): void {\n        this.initializeClickableElementA11y(element, callback);\n    }\n\n    /**\n     * Initializes a clickable element a11y calling the click action when pressed enter or space\n     * and adding tabindex and role if needed.\n     *\n     * @param element Element to listen to events.\n     * @param callback Callback to call when clicked or the key is pressed.\n     */\n    static initializeClickableElementA11y(\n        element: HTMLElement & {disabled?: boolean},\n        callback: (event: MouseEvent | KeyboardEvent) => void,\n    ): void {\n        const enabled = () => !CoreUtils.isTrueOrOne(element.dataset.disabledA11yClicks ?? 'false');\n\n        element.addEventListener('click', (event) => enabled() && callback(event));\n\n        element.addEventListener('keydown', (event) => {\n            if (!enabled()) {\n                return;\n            }\n\n            if (event.key === ' ' || event.key === 'Enter') {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        });\n\n        element.addEventListener('keyup', (event) => {\n            if (!enabled()) {\n                return;\n            }\n\n            if (event.key === ' ' || event.key === 'Enter') {\n                event.preventDefault();\n                event.stopPropagation();\n\n                callback(event);\n            }\n        });\n\n        if (element.tagName !== 'BUTTON' && element.tagName !== 'A') {\n            // Set tabindex if not previously set.\n            if (element.getAttribute('tabindex') === null) {\n                element.setAttribute('tabindex', element.disabled ? '-1' : '0');\n            }\n\n            // Set role if not previously set.\n            if (!element.getAttribute('role')) {\n                element.setAttribute('role', 'button');\n            }\n\n            element.classList.add('clickable');\n        }\n    }\n\n    /**\n     * Get CSS property value from computed styles.\n     *\n     * @param styles Computed styles.\n     * @param property Property name.\n     * @returns Property CSS value (may not be the same as the computed value).\n     */\n    static getCSSPropertyValue(styles: CSSStyleDeclaration, property: string): string {\n        const value = styles.getPropertyValue(property);\n\n        if (property === 'font-size') {\n            if (this.fontSizeZoom === null) {\n                const baseFontSize = 20;\n                const span = document.createElement('span');\n                span.style.opacity = '0';\n                span.style.fontSize = `${baseFontSize}px`;\n\n                document.body.append(span);\n\n                this.fontSizeZoom = baseFontSize / Number(getComputedStyle(span).fontSize.slice(0, -2));\n\n                span.remove();\n            }\n\n            if (this.fontSizeZoom !== 1) {\n                return `calc(${this.fontSizeZoom} * ${value})`;\n            }\n        }\n\n        return value;\n    }\n\n    /**\n     * Replace tags on HTMLElement.\n     *\n     * @param element HTML Element where to replace the tags.\n     * @param originTags Origin tag to be replaced.\n     * @param destinationTags Destination tag to replace.\n     * @returns Element with tags replaced.\n     */\n    static replaceTags<T extends HTMLElement = HTMLElement>(\n        element: T,\n        originTags: string | string[],\n        destinationTags: string | string[],\n    ): T {\n        if (typeof originTags === 'string') {\n            originTags = [originTags];\n        }\n\n        if (typeof destinationTags === 'string') {\n            destinationTags = [destinationTags];\n        }\n\n        if (originTags.length !== destinationTags.length) {\n            // Do nothing, incorrect input.\n            return element;\n        }\n\n        originTags.forEach((originTag, index) => {\n            const destinationTag = destinationTags[index];\n            const elems = Array.from(element.getElementsByTagName(originTag));\n\n            elems.forEach((elem) => {\n                const newElem = document.createElement(destinationTag);\n                newElem.innerHTML = elem.innerHTML;\n\n                if (elem.hasAttributes()) {\n                    const attrs = Array.from(elem.attributes);\n                    attrs.forEach((attr) => {\n                        newElem.setAttribute(attr.name, attr.value);\n                    });\n                }\n\n                elem.parentNode?.replaceChild(newElem, elem);\n            });\n        });\n\n        return element;\n    }\n\n}\n\n/**\n * Coordinates of an element.\n */\nexport type CoreCoordinates = {\n    x: number; // X axis coordinates.\n    y: number; // Y axis coordinates.\n};\n\n/**\n * Scroll options.\n */\nexport type CoreScrollOptions = {\n    duration?: number;\n    addYAxis?: number;\n    addXAxis?: number;\n};\n\n/**\n * Source of a media element.\n */\nexport type CoreMediaSource = {\n    src: string;\n    type?: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}