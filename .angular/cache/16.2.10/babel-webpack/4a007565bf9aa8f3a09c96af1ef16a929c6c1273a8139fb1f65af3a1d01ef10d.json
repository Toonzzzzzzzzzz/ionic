{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { asyncObservable, ignoreErrors, zipIncludingComplete } from '@/core/utils/rxjs';\nimport { of, firstValueFrom } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { AddonEnrolGuest } from '@addons/enrol/guest/services/guest';\nimport { AddonEnrolSelf } from '@addons/enrol/self/services/self';\nimport { CoreEnrol } from '@features/enrol/services/enrol';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmCourses:';\n/**\n * Service that provides some features regarding lists of courses and categories.\n */\nexport class CoreCoursesProvider {\n  constructor() {\n    this.downloadOptionsEnabled = false;\n  }\n  /**\n   * Get categories. They can be filtered by id.\n   *\n   * @param categoryId Category ID to get.\n   * @param addSubcategories If it should add subcategories to the list.\n   * @param siteId Site to get the courses from. If not defined, use current site.\n   * @returns Promise resolved with the categories.\n   */\n  getCategories(categoryId, addSubcategories = false, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // Get parent when id is the root category.\n      const criteriaKey = categoryId == 0 ? 'parent' : 'id';\n      const params = {\n        criteria: [{\n          key: criteriaKey,\n          value: categoryId\n        }],\n        addsubcategories: addSubcategories\n      };\n      const preSets = {\n        cacheKey: _this.getCategoriesCacheKey(categoryId, addSubcategories),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      return site.read('core_course_get_categories', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for get categories methods WS call.\n   *\n   * @param categoryId Category ID to get.\n   * @param addSubcategories If add subcategories to the list.\n   * @returns Cache key.\n   */\n  getCategoriesCacheKey(categoryId, addSubcategories) {\n    return ROOT_CACHE_KEY + 'categories:' + categoryId + ':' + !!addSubcategories;\n  }\n  /**\n   * Given a list of course IDs to get course admin and nav options, return the list of courseIds to use.\n   *\n   * @param courseIds Course IDs.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with the list of course IDs.\n   */\n  getCourseIdsForAdminAndNavOptions(courseIds, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const siteHomeId = site.getSiteHomeId();\n      if (courseIds.length == 1) {\n        // Only 1 course, check if it belongs to the user courses. If so, use all user courses.\n        return _this2.getCourseIdsIfEnrolled(courseIds[0], siteId);\n      } else {\n        if (courseIds.length > 1 && courseIds.indexOf(siteHomeId) == -1) {\n          courseIds.push(siteHomeId);\n        }\n        // Sort the course IDs.\n        courseIds.sort((a, b) => b - a);\n        return courseIds;\n      }\n    })();\n  }\n  /**\n   * Given a course ID, if user is enrolled in the course it will return the IDs of all enrolled courses and site home.\n   * Return only the course ID otherwise.\n   *\n   * @param courseId Course Id.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with the list of course IDs.\n   */\n  getCourseIdsIfEnrolled(courseId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const siteHomeId = site.getSiteHomeId();\n      try {\n        // Check if user is enrolled in the course.\n        const courses = yield _this3.getUserCourses(true, siteId);\n        let useAllCourses = false;\n        if (courseId == siteHomeId) {\n          // It's site home, use all courses.\n          useAllCourses = true;\n        } else {\n          useAllCourses = !!courses.find(course => course.id == courseId);\n        }\n        if (useAllCourses) {\n          // User is enrolled, return all the courses.\n          const courseIds = courses.map(course => course.id);\n          // Always add the site home ID.\n          courseIds.push(siteHomeId);\n          // Sort the course IDs.\n          courseIds.sort((a, b) => b - a);\n          return courseIds;\n        }\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      return [courseId];\n    })();\n  }\n  /**\n   * Check if download a whole course is disabled in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n   */\n  isDownloadCourseDisabled(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this4.isDownloadCoursesDisabledInSite(site);\n    })();\n  }\n  /**\n   * Check if download a whole course is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether it's disabled.\n   */\n  isDownloadCourseDisabledInSite(site) {\n    site = site || CoreSites.getCurrentSite();\n    return !site || site.isOfflineDisabled() || site.isFeatureDisabled('NoDelegate_CoreCourseDownload');\n  }\n  /**\n   * Check if download all courses is disabled in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n   */\n  isDownloadCoursesDisabled(siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this5.isDownloadCoursesDisabledInSite(site);\n    })();\n  }\n  /**\n   * Check if download all courses is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether it's disabled.\n   */\n  isDownloadCoursesDisabledInSite(site) {\n    site = site || CoreSites.getCurrentSite();\n    return !site || site.isOfflineDisabled() || site.isFeatureDisabled('NoDelegate_CoreCoursesDownload');\n  }\n  /**\n   * Check if My Courses is disabled in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n   */\n  isMyCoursesDisabled(siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this6.isMyCoursesDisabledInSite(site);\n    })();\n  }\n  /**\n   * Check if My Courses is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether it's disabled.\n   */\n  isMyCoursesDisabledInSite(site) {\n    site = site || CoreSites.getCurrentSite();\n    return !site || site.isFeatureDisabled('CoreMainMenuDelegate_CoreCourses');\n  }\n  /**\n   * Check if Search Courses is disabled in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n   */\n  isSearchCoursesDisabled(siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this7.isSearchCoursesDisabledInSite(site);\n    })();\n  }\n  /**\n   * Check if Search Courses is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether it's disabled.\n   */\n  isSearchCoursesDisabledInSite(site) {\n    site = site || CoreSites.getCurrentSite();\n    return !site || site.isFeatureDisabled('CoreCourseOptionsDelegate_search');\n  }\n  /**\n   * Get course information if user has persmissions to view.\n   *\n   * @param id ID of the course to get.\n   * @param siteId Site to get the courses from. If not defined, use current site.\n   * @returns Promise resolved with the course.\n   */\n  getCourse(id, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const courses = yield _this8.getCourses([id], siteId);\n      if (courses && courses.length > 0) {\n        return courses[0];\n      }\n      throw Error('Course not found on core_course_get_courses');\n    })();\n  }\n  /**\n   * Get the enrolment methods from a course.\n   *\n   * @param courseId ID of the course.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the methods.\n   * @deprecated since 4.3. Use CoreEnrol.getSupportedCourseEnrolmentMethods instead.\n   */\n  getCourseEnrolmentMethods(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      return CoreEnrol.getSupportedCourseEnrolmentMethods(courseId, {\n        siteId\n      });\n    })();\n  }\n  /**\n   * Get info from a course guest enrolment method.\n   *\n   * @param instanceId Guest instance ID.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved when the info is retrieved.\n   * @deprecated since 4.3 use AddonEnrolGuest.getCourseGuestEnrolmentInfo instead.\n   */\n  getCourseGuestEnrolmentInfo(instanceId, siteId) {\n    return _asyncToGenerator(function* () {\n      return AddonEnrolGuest.getGuestEnrolmentInfo(instanceId, siteId);\n    })();\n  }\n  /**\n   * Get courses.\n   * Warning: if the user doesn't have permissions to view some of the courses passed the WS call will fail.\n   * The user must be able to view ALL the courses passed.\n   *\n   * @param ids List of IDs of the courses to get.\n   * @param siteId Site to get the courses from. If not defined, use current site.\n   * @returns Promise resolved with the courses.\n   */\n  getCourses(ids, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (!Array.isArray(ids)) {\n        throw Error('ids parameter should be an array');\n      }\n      if (ids.length === 0) {\n        return [];\n      }\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        options: {\n          ids: ids\n        }\n      };\n      const preSets = {\n        cacheKey: _this9.getCoursesCacheKey(ids),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      return site.read('core_course_get_courses', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for get courses WS call.\n   *\n   * @param ids Courses IDs.\n   * @returns Cache key.\n   */\n  getCoursesCacheKey(ids) {\n    return ROOT_CACHE_KEY + 'course:' + JSON.stringify(ids);\n  }\n  /**\n   * This function is meant to decrease WS calls.\n   * When requesting a single course that belongs to enrolled courses, request all enrolled courses because\n   * the WS call is probably cached.\n   *\n   * @param field The field to search.\n   * @param value The value to match.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the field and value to use.\n   */\n  fixCoursesByFieldParams(field = '', value = '', siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      if (field == 'id' || field == 'ids') {\n        let courseIds;\n        if (typeof value == 'string') {\n          courseIds = value.split(',').map(id => parseInt(id, 10));\n        } else {\n          courseIds = [value];\n        }\n        // Use the same optimization as in get admin and nav options. This will return the course IDs to use.\n        courseIds = yield _this10.getCourseIdsForAdminAndNavOptions(courseIds, siteId);\n        if (courseIds.length > 1) {\n          return {\n            field: 'ids',\n            value: courseIds.join(',')\n          };\n        } else {\n          return {\n            field: 'id',\n            value: Number(courseIds[0])\n          };\n        }\n      } else {\n        // Nothing to do.\n        return {\n          field: field,\n          value: value\n        };\n      }\n    })();\n  }\n  /**\n   * Get the first course returned by getCoursesByField.\n   *\n   * @param field The field to search. Can be left empty for all courses or:\n   *              id: course id.\n   *              ids: comma separated course ids.\n   *              shortname: course short name.\n   *              idnumber: course id number.\n   *              category: category id the course belongs to.\n   * @param value The value to match.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the first course.\n   */\n  getCourseByField(field, value, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const courses = yield _this11.getCoursesByField(field, value, siteId);\n      if (courses && courses.length > 0) {\n        return courses[0];\n      }\n      throw Error('Course not found on core_course_get_courses_by_field');\n    })();\n  }\n  /**\n   * Get courses. They can be filtered by field.\n   *\n   * @param field The field to search. Can be left empty for all courses or:\n   *              id: course id.\n   *              ids: comma separated course ids.\n   *              shortname: course short name.\n   *              idnumber: course id number.\n   *              category: category id the course belongs to.\n   * @param value The value to match.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the courses.\n   */\n  getCoursesByField(field = '', value = '', siteId) {\n    return firstValueFrom(this.getCoursesByFieldObservable(field, value, {\n      siteId\n    }));\n  }\n  /**\n   * Get courses. They can be filtered by field.\n   *\n   * @param field The field to search. Can be left empty for all courses or:\n   *              id: course id.\n   *              ids: comma separated course ids.\n   *              shortname: course short name.\n   *              idnumber: course id number.\n   *              category: category id the course belongs to.\n   * @param value The value to match.\n   * @param options Other options.\n   * @returns Observable that returns the courses.\n   */\n  getCoursesByFieldObservable(field = '', value = '', options = {}) {\n    var _this12 = this;\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      const siteId = options.siteId || CoreSites.getCurrentSiteId();\n      const originalValue = value;\n      const site = yield CoreSites.getSite(siteId);\n      // Fix params. Tries to use cached data, no need to use observer.\n      const fieldParams = yield _this12.fixCoursesByFieldParams(field, value, siteId);\n      const hasChanged = fieldParams.field != field || fieldParams.value != value;\n      field = fieldParams.field;\n      value = fieldParams.value;\n      const data = {\n        field: field,\n        value: field ? value : ''\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this12.getCoursesByFieldCacheKey(field, value),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const observable = site.readObservable('core_course_get_courses_by_field', data, preSets);\n      return observable.pipe(map(response => {\n        if (!response.courses) {\n          throw Error('WS core_course_get_courses_by_field failed');\n        }\n        if (field == 'ids' && hasChanged) {\n          // The list of courses requestes was changed to optimize it.\n          // Return only the ones that were being requested.\n          const courseIds = String(originalValue).split(',').map(id => parseInt(id, 10));\n          // Only courses from the original selection.\n          response.courses = response.courses.filter(course => courseIds.indexOf(course.id) >= 0);\n        }\n        // Courses will be sorted using sortorder if available.\n        return response.courses.sort((a, b) => {\n          if (a.sortorder === undefined && b.sortorder === undefined) {\n            return b.id - a.id;\n          }\n          if (a.sortorder === undefined) {\n            return 1;\n          }\n          if (b.sortorder === undefined) {\n            return -1;\n          }\n          return a.sortorder - b.sortorder;\n        });\n      }));\n    }));\n  }\n  /**\n   * Get cache key for get courses WS call.\n   *\n   * @param field The field to search.\n   * @param value The value to match.\n   * @returns Cache key.\n   */\n  getCoursesByFieldCacheKey(field = '', value = '') {\n    return ROOT_CACHE_KEY + 'coursesbyfield:' + field + ':' + value;\n  }\n  /**\n   * Get courses matching the given custom field. By default it will try not to use cache.\n   *\n   * @param customFieldName Custom field name.\n   * @param customFieldValue Custom field value.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the list of courses.\n   * @since 3.8\n   */\n  getEnrolledCoursesByCustomField(customFieldName, customFieldValue, siteId) {\n    return firstValueFrom(this.getEnrolledCoursesByCustomFieldObservable(customFieldName, customFieldValue, {\n      readingStrategy: 3 /* CoreSitesReadingStrategy.PREFER_NETWORK */,\n      siteId\n    }));\n  }\n  /**\n   * Get courses matching the given custom field.\n   *\n   * @param customFieldName Custom field name.\n   * @param customFieldValue Custom field value.\n   * @param options Common options.\n   * @returns Promise resolved with the list of courses.\n   * @since 3.8\n   */\n  getEnrolledCoursesByCustomFieldObservable(customFieldName, customFieldValue, options) {\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _options$readingStrat;\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        classification: 'customfield',\n        customfieldname: customFieldName,\n        customfieldvalue: customFieldValue\n      };\n      const preSets = _objectSpread({}, CoreSites.getReadingStrategyPreSets((_options$readingStrat = options.readingStrategy) !== null && _options$readingStrat !== void 0 ? _options$readingStrat : 3 /* CoreSitesReadingStrategy.PREFER_NETWORK */));\n      return site.readObservable('core_course_get_enrolled_courses_by_timeline_classification', params, preSets).pipe(map(response => response.courses));\n    }));\n  }\n  /**\n   * Get the navigation and administration options for the given courses.\n   *\n   * @param courseIds IDs of courses to get.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the options for each course.\n   */\n  getCoursesAdminAndNavOptions(courseIds, siteId) {\n    return firstValueFrom(this.getCoursesAdminAndNavOptionsObservable(courseIds, {\n      siteId\n    }));\n  }\n  /**\n   * Get the navigation and administration options for the given courses.\n   *\n   * @param courseIds IDs of courses to get.\n   * @param options Options.\n   * @returns Observable that returns the options for each course.\n   */\n  getCoursesAdminAndNavOptionsObservable(courseIds, options = {}) {\n    var _this13 = this;\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      const siteId = options.siteId || CoreSites.getCurrentSiteId();\n      // Get the list of courseIds to use based on the param. Tries to use cached data, no need to use observer.\n      courseIds = yield _this13.getCourseIdsForAdminAndNavOptions(courseIds, siteId);\n      // Get user navigation and administration options.\n      return zipIncludingComplete(ignoreErrors(_this13.getUserNavigationOptionsObservable(courseIds, options), {}), ignoreErrors(_this13.getUserAdministrationOptionsObservable(courseIds, options), {})).pipe(map(([navOptions, admOptions]) => ({\n        navOptions: navOptions,\n        admOptions: admOptions\n      })));\n    }));\n  }\n  /**\n   * Get cache key for get recent courses WS call.\n   *\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getRecentCoursesCacheKey(userId) {\n    return `${ROOT_CACHE_KEY}:recentcourses:${userId}`;\n  }\n  /**\n   * Get recent courses.\n   *\n   * @param options Options.\n   * @returns Promise resolved with courses.\n   * @since 3.6\n   */\n  getRecentCourses(options = {}) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const userId = options.userId || site.getUserId();\n      const params = {\n        userid: userId,\n        offset: options.offset || 0,\n        limit: options.limit || CoreCoursesProvider.RECENT_PER_PAGE,\n        sort: options.sort\n      };\n      const preSets = {\n        cacheKey: _this14.getRecentCoursesCacheKey(userId)\n      };\n      return site.read('core_course_get_recent_courses', params, preSets);\n    })();\n  }\n  /**\n   * Get the common part of the cache keys for user administration options WS calls.\n   *\n   * @returns Cache key.\n   */\n  getUserAdministrationOptionsCommonCacheKey() {\n    return ROOT_CACHE_KEY + 'administrationOptions:';\n  }\n  /**\n   * Get cache key for get user administration options WS call.\n   *\n   * @param courseIds IDs of courses to get.\n   * @returns Cache key.\n   */\n  getUserAdministrationOptionsCacheKey(courseIds) {\n    return this.getUserAdministrationOptionsCommonCacheKey() + courseIds.join(',');\n  }\n  /**\n   * Get user administration options for a set of courses.\n   *\n   * @param courseIds IDs of courses to get.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with administration options for each course.\n   */\n  getUserAdministrationOptions(courseIds, siteId) {\n    return firstValueFrom(this.getUserAdministrationOptionsObservable(courseIds, {\n      siteId\n    }));\n  }\n  /**\n   * Get user administration options for a set of courses.\n   *\n   * @param courseIds IDs of courses to get.\n   * @param options Options.\n   * @returns Observable that returns administration options for each course.\n   */\n  getUserAdministrationOptionsObservable(courseIds, options = {}) {\n    var _this15 = this;\n    if (!courseIds || courseIds.length == 0) {\n      return of({});\n    }\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: courseIds\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this15.getUserAdministrationOptionsCacheKey(courseIds),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const observable = site.readObservable('core_course_get_user_administration_options', params, preSets);\n      // Format returned data.\n      return observable.pipe(map(response => _this15.formatUserAdminOrNavOptions(response.courses)));\n    }));\n  }\n  /**\n   * Get the common part of the cache keys for user navigation options WS calls.\n   *\n   * @returns Cache key.\n   */\n  getUserNavigationOptionsCommonCacheKey() {\n    return ROOT_CACHE_KEY + 'navigationOptions:';\n  }\n  /**\n   * Get cache key for get user navigation options WS call.\n   *\n   * @returns Cache key.\n   */\n  getUserNavigationOptionsCacheKey(courseIds) {\n    return this.getUserNavigationOptionsCommonCacheKey() + courseIds.join(',');\n  }\n  /**\n   * Get user navigation options for a set of courses.\n   *\n   * @param courseIds IDs of courses to get.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with navigation options for each course.\n   */\n  getUserNavigationOptions(courseIds, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      return firstValueFrom(_this16.getUserNavigationOptionsObservable(courseIds, {\n        siteId\n      }));\n    })();\n  }\n  /**\n   * Get user navigation options for a set of courses.\n   *\n   * @param courseIds IDs of courses to get.\n   * @param options Options.\n   * @returns Observable that returns navigation options for each course.\n   */\n  getUserNavigationOptionsObservable(courseIds, options = {}) {\n    var _this17 = this;\n    if (!courseIds || courseIds.length == 0) {\n      return of({});\n    }\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: courseIds\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this17.getUserNavigationOptionsCacheKey(courseIds),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const observable = site.readObservable('core_course_get_user_navigation_options', params, preSets);\n      // Format returned data.\n      return observable.pipe(map(response => _this17.formatUserAdminOrNavOptions(response.courses)));\n    }));\n  }\n  /**\n   * Format user navigation or administration options.\n   *\n   * @param courses Navigation or administration options for each course.\n   * @returns Formatted options.\n   */\n  formatUserAdminOrNavOptions(courses) {\n    const result = {};\n    courses.forEach(course => {\n      const options = {};\n      if (course.options) {\n        course.options.forEach(option => {\n          options[option.name] = option.available;\n        });\n      }\n      result[course.id] = options;\n    });\n    return result;\n  }\n  /**\n   * Get a course the user is enrolled in. This function relies on getUserCourses.\n   * preferCache=true will try to speed up the response, but the data returned might not be updated.\n   *\n   * @param id ID of the course to get.\n   * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n   * @param siteId Site to get the courses from. If not defined, use current site.\n   * @returns Promise resolved with the course.\n   */\n  getUserCourse(id, preferCache, siteId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (!id) {\n        throw Error('Invalid id parameter on getUserCourse');\n      }\n      const courses = yield _this18.getUserCourses(preferCache, siteId);\n      const course = courses.find(course => course.id == id);\n      if (course) {\n        return course;\n      }\n      throw Error('Course not found on core_enrol_get_users_courses');\n    })();\n  }\n  /**\n   * Get user courses.\n   *\n   * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n   * @param siteId Site to get the courses from. If not defined, use current site.\n   * @param strategy Reading strategy.\n   * @returns Promise resolved with the courses.\n   */\n  getUserCourses(preferCache = false, siteId, strategy) {\n    var _strategy;\n    strategy = (_strategy = strategy) !== null && _strategy !== void 0 ? _strategy : preferCache ? 1 /* CoreSitesReadingStrategy.PREFER_CACHE */ : undefined;\n    return firstValueFrom(this.getUserCoursesObservable({\n      readingStrategy: strategy,\n      siteId\n    }));\n  }\n  /**\n   * Get user courses.\n   *\n   * @param options Options.\n   * @returns Observable that returns the courses.\n   */\n  getUserCoursesObservable(options = {}) {\n    var _this19 = this;\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const userId = site.getUserId();\n      const wsParams = {\n        userid: userId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this19.getUserCoursesCacheKey(),\n        getCacheUsingCacheKey: true,\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      if (site.isVersionGreaterEqualThan('3.7')) {\n        wsParams.returnusercount = false;\n      }\n      const observable = site.readObservable('core_enrol_get_users_courses', wsParams, preSets);\n      return observable.pipe(map(courses => {\n        if (_this19.userCoursesIds) {\n          // Check if the list of courses has changed.\n          const added = [];\n          const removed = [];\n          const previousIds = _this19.userCoursesIds;\n          const currentIds = new Set();\n          courses.forEach(course => {\n            // Move category field to categoryid on a course.\n            course.categoryid = course.category;\n            delete course.category;\n            currentIds.add(course.id);\n            if (!previousIds.has(course.id)) {\n              // Course added.\n              added.push(course.id);\n            }\n          });\n          if (courses.length - added.length !== previousIds.size) {\n            // A course was removed, check which one.\n            previousIds.forEach(id => {\n              if (!currentIds.has(id)) {\n                // Course removed.\n                removed.push(Number(id));\n              }\n            });\n          }\n          if (added.length || removed.length) {\n            // At least 1 course was added or removed, trigger the event.\n            CoreEvents.trigger(CoreCoursesProvider.EVENT_MY_COURSES_CHANGED, {\n              added: added,\n              removed: removed\n            }, site.getId());\n          }\n          _this19.userCoursesIds = currentIds;\n        } else {\n          const coursesIds = new Set();\n          // Store the list of courses.\n          courses.forEach(course => {\n            coursesIds.add(course.id);\n            // Move category field to categoryid on a course.\n            course.categoryid = course.category;\n            delete course.category;\n          });\n          _this19.userCoursesIds = coursesIds;\n        }\n        return courses;\n      }));\n    }));\n  }\n  /**\n   * Get cache key for get user courses WS call.\n   *\n   * @returns Cache key.\n   */\n  getUserCoursesCacheKey() {\n    return ROOT_CACHE_KEY + 'usercourses';\n  }\n  /**\n   * Invalidates get categories WS call.\n   *\n   * @param categoryId Category ID to get.\n   * @param addSubcategories If it should add subcategories to the list.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCategories(categoryId, addSubcategories, siteId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this20.getCategoriesCacheKey(categoryId, addSubcategories));\n    })();\n  }\n  /**\n   * Invalidates get course WS call.\n   *\n   * @param id Course ID.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCourse(id, siteId) {\n    return this.invalidateCourses([id], siteId);\n  }\n  /**\n   * Invalidates get course enrolment methods WS call.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   * @deprecated since 4.3 use CoreEnrol.invalidateCourseEnrolmentMethods instead.\n   */\n  invalidateCourseEnrolmentMethods(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      return CoreEnrol.invalidateCourseEnrolmentMethods(courseId, siteId);\n    })();\n  }\n  /**\n   * Invalidates get course guest enrolment info WS call.\n   *\n   * @param instanceId Guest instance ID.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   * @deprecated since 4.3 use CoreEnrolDelegate.invalidate instead.\n   */\n  invalidateCourseGuestEnrolmentInfo(instanceId, siteId) {\n    return _asyncToGenerator(function* () {\n      return AddonEnrolGuest.invalidateGuestEnrolmentInfo(instanceId, siteId);\n    })();\n  }\n  /**\n   * Invalidates the navigation and administration options for the given courses.\n   *\n   * @param courseIds IDs of courses to get.\n   * @param siteId Site ID to invalidate. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCoursesAdminAndNavOptions(courseIds, siteId) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const ids = yield _this21.getCourseIdsForAdminAndNavOptions(courseIds, siteId);\n      const promises = [];\n      promises.push(_this21.invalidateUserAdministrationOptionsForCourses(ids, siteId));\n      promises.push(_this21.invalidateUserNavigationOptionsForCourses(ids, siteId));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidates get courses WS call.\n   *\n   * @param ids Courses IDs.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCourses(ids, siteId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this22.getCoursesCacheKey(ids));\n    })();\n  }\n  /**\n   * Invalidates get courses by field WS call.\n   *\n   * @param field See getCoursesByField for info.\n   * @param value The value to match.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCoursesByField(field = '', value = '', siteId) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof value === 'string' && value.length === 0) {\n        return;\n      }\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const result = yield _this23.fixCoursesByFieldParams(field, value, siteId);\n      field = result.field;\n      value = result.value;\n      const site = yield CoreSites.getSite(siteId);\n      return site.invalidateWsCacheForKey(_this23.getCoursesByFieldCacheKey(field, value));\n    })();\n  }\n  /**\n   * Invalidates get recent courses WS call.\n   *\n   * @param userId User ID. If not defined, current user.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateRecentCourses(userId, siteId) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this24.getRecentCoursesCacheKey(userId || site.getUserId()));\n    })();\n  }\n  /**\n   * Invalidates all user administration options.\n   *\n   * @param siteId Site ID to invalidate. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserAdministrationOptions(siteId) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this25.getUserAdministrationOptionsCommonCacheKey());\n    })();\n  }\n  /**\n   * Invalidates user administration options for certain courses.\n   *\n   * @param courseIds IDs of courses.\n   * @param siteId Site ID to invalidate. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserAdministrationOptionsForCourses(courseIds, siteId) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this26.getUserAdministrationOptionsCacheKey(courseIds));\n    })();\n  }\n  /**\n   * Invalidates get user courses WS call.\n   *\n   * @param siteId Site ID to invalidate. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserCourses(siteId) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this27.getUserCoursesCacheKey());\n    })();\n  }\n  /**\n   * Invalidates all user navigation options.\n   *\n   * @param siteId Site ID to invalidate. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserNavigationOptions(siteId) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this28.getUserNavigationOptionsCommonCacheKey());\n    })();\n  }\n  /**\n   * Invalidates user navigation options for certain courses.\n   *\n   * @param courseIds IDs of courses.\n   * @param siteId Site ID to invalidate. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserNavigationOptionsForCourses(courseIds, siteId) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this29.getUserNavigationOptionsCacheKey(courseIds));\n    })();\n  }\n  /**\n   * Report a dashboard or my courses page view event.\n   *\n   * @param page Page to view.\n   */\n  logView(page) {\n    return _asyncToGenerator(function* () {\n      const site = CoreSites.getRequiredCurrentSite();\n      if (!site.wsAvailable('core_my_view_page')) {\n        return;\n      }\n      const params = {\n        page\n      };\n      yield site.write('core_my_view_page', params);\n    })();\n  }\n  /**\n   * Search courses.\n   *\n   * @param text Text to search.\n   * @param page Page to get.\n   * @param perPage Number of courses per page. Defaults to CoreCoursesProvider.SEARCH_PER_PAGE.\n   * @param limitToEnrolled Limit to enrolled courses.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the courses and the total of matches.\n   */\n  search(text, page = 0, perPage = CoreCoursesProvider.SEARCH_PER_PAGE, limitToEnrolled = false, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        criterianame: 'search',\n        criteriavalue: text,\n        page: page,\n        perpage: perPage,\n        limittoenrolled: limitToEnrolled\n      };\n      const preSets = {\n        getFromCache: false\n      };\n      const response = yield site.read('core_course_search_courses', params, preSets);\n      return {\n        total: response.total,\n        courses: response.courses\n      };\n    })();\n  }\n  /**\n   * Self enrol current user in a certain course.\n   *\n   * @param courseId Course ID.\n   * @param password Password to use.\n   * @param instanceId Enrol instance ID.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved if the user is enrolled. If the password is invalid, the promise is rejected\n   *         with an object with errorcode = CoreCoursesProvider.ENROL_INVALID_KEY.\n   * @deprecated since 4.3 use CoreEnrolDelegate.enrol instead.\n   */\n  selfEnrol(courseId, password = '', instanceId, siteId) {\n    return _asyncToGenerator(function* () {\n      return AddonEnrolSelf.selfEnrol(courseId, password, instanceId, siteId);\n    })();\n  }\n  /**\n   * Set favourite property on a course.\n   *\n   * @param courseId Course ID.\n   * @param favourite If favourite or unfavourite.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved when done.\n   */\n  setFavouriteCourse(courseId, favourite, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        courses: [{\n          id: courseId,\n          favourite: favourite\n        }]\n      };\n      return site.write('core_course_set_favourite_courses', params);\n    })();\n  }\n  /**\n   * Get download options enabled option.\n   *\n   * @returns True if enabled, false otherwise.\n   */\n  getCourseDownloadOptionsEnabled() {\n    return this.downloadOptionsEnabled;\n  }\n  /**\n   * Set trigger and save the download option.\n   *\n   * @param enable True to enable, false to disable.\n   */\n  setCourseDownloadOptionsEnabled(enable) {\n    if (this.downloadOptionsEnabled == enable) {\n      return;\n    }\n    this.downloadOptionsEnabled = enable;\n    CoreEvents.trigger(CoreCoursesProvider.EVENT_DASHBOARD_DOWNLOAD_ENABLED_CHANGED, {\n      enabled: enable\n    });\n  }\n}\n_class = CoreCoursesProvider;\n_class.SEARCH_PER_PAGE = 20;\n_class.RECENT_PER_PAGE = 10;\n_class.ENROL_INVALID_KEY = 'CoreCoursesEnrolInvalidKey';\n_class.EVENT_MY_COURSES_CHANGED = 'courses_my_courses_changed';\n// User course list changed while app is running.\n// A course was hidden/favourite, or user enroled in a course.\n_class.EVENT_MY_COURSES_UPDATED = 'courses_my_courses_updated';\n_class.EVENT_MY_COURSES_REFRESHED = 'courses_my_courses_refreshed';\n_class.EVENT_DASHBOARD_DOWNLOAD_ENABLED_CHANGED = 'dashboard_download_enabled_changed';\n// Actions for event EVENT_MY_COURSES_UPDATED.\n_class.ACTION_ENROL = 'enrol';\n// User enrolled in a course.\n_class.ACTION_STATE_CHANGED = 'state_changed';\n// Course state changed (hidden, favourite).\n_class.ACTION_VIEW = 'view';\n// Course viewed.\n// Possible states changed.\n_class.STATE_HIDDEN = 'hidden';\n_class.STATE_FAVOURITE = 'favourite';\n_class.ɵfac = function CoreCoursesProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCourses = makeSingleton(CoreCoursesProvider);","map":{"version":3,"names":["CoreSites","CoreSitesReadingStrategy","CoreSite","makeSingleton","CoreEvents","asyncObservable","ignoreErrors","zipIncludingComplete","of","firstValueFrom","map","AddonEnrolGuest","AddonEnrolSelf","CoreEnrol","ROOT_CACHE_KEY","CoreCoursesProvider","constructor","downloadOptionsEnabled","getCategories","categoryId","addSubcategories","siteId","_this","_asyncToGenerator","site","getSite","criteriaKey","params","criteria","key","value","addsubcategories","preSets","cacheKey","getCategoriesCacheKey","updateFrequency","FREQUENCY_RARELY","read","getCourseIdsForAdminAndNavOptions","courseIds","_this2","siteHomeId","getSiteHomeId","length","getCourseIdsIfEnrolled","indexOf","push","sort","a","b","courseId","_this3","courses","getUserCourses","useAllCourses","find","course","id","_unused","isDownloadCourseDisabled","_this4","isDownloadCoursesDisabledInSite","isDownloadCourseDisabledInSite","getCurrentSite","isOfflineDisabled","isFeatureDisabled","isDownloadCoursesDisabled","_this5","isMyCoursesDisabled","_this6","isMyCoursesDisabledInSite","isSearchCoursesDisabled","_this7","isSearchCoursesDisabledInSite","getCourse","_this8","getCourses","Error","getCourseEnrolmentMethods","getSupportedCourseEnrolmentMethods","getCourseGuestEnrolmentInfo","instanceId","getGuestEnrolmentInfo","ids","_this9","Array","isArray","options","getCoursesCacheKey","JSON","stringify","fixCoursesByFieldParams","field","_this10","split","parseInt","join","Number","getCourseByField","_this11","getCoursesByField","getCoursesByFieldObservable","_this12","getCurrentSiteId","originalValue","fieldParams","hasChanged","data","_objectSpread","getCoursesByFieldCacheKey","getReadingStrategyPreSets","readingStrategy","observable","readObservable","pipe","response","String","filter","sortorder","undefined","getEnrolledCoursesByCustomField","customFieldName","customFieldValue","getEnrolledCoursesByCustomFieldObservable","_options$readingStrat","classification","customfieldname","customfieldvalue","getCoursesAdminAndNavOptions","getCoursesAdminAndNavOptionsObservable","_this13","getUserNavigationOptionsObservable","getUserAdministrationOptionsObservable","navOptions","admOptions","getRecentCoursesCacheKey","userId","getRecentCourses","_this14","getUserId","userid","offset","limit","RECENT_PER_PAGE","getUserAdministrationOptionsCommonCacheKey","getUserAdministrationOptionsCacheKey","getUserAdministrationOptions","_this15","courseids","formatUserAdminOrNavOptions","getUserNavigationOptionsCommonCacheKey","getUserNavigationOptionsCacheKey","getUserNavigationOptions","_this16","_this17","result","forEach","option","name","available","getUserCourse","preferCache","_this18","strategy","_strategy","getUserCoursesObservable","_this19","wsParams","getUserCoursesCacheKey","getCacheUsingCacheKey","isVersionGreaterEqualThan","returnusercount","userCoursesIds","added","removed","previousIds","currentIds","Set","categoryid","category","add","has","size","trigger","EVENT_MY_COURSES_CHANGED","getId","coursesIds","invalidateCategories","_this20","invalidateWsCacheForKey","invalidateCourse","invalidateCourses","invalidateCourseEnrolmentMethods","invalidateCourseGuestEnrolmentInfo","invalidateGuestEnrolmentInfo","invalidateCoursesAdminAndNavOptions","_this21","promises","invalidateUserAdministrationOptionsForCourses","invalidateUserNavigationOptionsForCourses","Promise","all","_this22","invalidateCoursesByField","_this23","invalidateRecentCourses","_this24","invalidateUserAdministrationOptions","_this25","invalidateWsCacheForKeyStartingWith","_this26","invalidateUserCourses","_this27","invalidateUserNavigationOptions","_this28","_this29","logView","page","getRequiredCurrentSite","wsAvailable","write","search","text","perPage","SEARCH_PER_PAGE","limitToEnrolled","criterianame","criteriavalue","perpage","limittoenrolled","getFromCache","total","selfEnrol","password","setFavouriteCourse","favourite","getCourseDownloadOptionsEnabled","setCourseDownloadOptionsEnabled","enable","EVENT_DASHBOARD_DOWNLOAD_ENABLED_CHANGED","enabled","_class","ENROL_INVALID_KEY","EVENT_MY_COURSES_UPDATED","EVENT_MY_COURSES_REFRESHED","ACTION_ENROL","ACTION_STATE_CHANGED","ACTION_VIEW","STATE_HIDDEN","STATE_FAVOURITE","factory","ɵfac","providedIn","CoreCourses"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/courses/services/courses.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSite  } from '@classes/sites/site';\nimport { makeSingleton } from '@singletons';\nimport { CoreWarningsWSResponse, CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreCourseAnyCourseDataWithExtraInfoAndOptions, CoreCourseWithImageAndColor } from './courses-helper';\nimport { asyncObservable, ignoreErrors, zipIncludingComplete } from '@/core/utils/rxjs';\nimport { of, firstValueFrom } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { AddonEnrolGuest, AddonEnrolGuestInfo } from '@addons/enrol/guest/services/guest';\nimport { AddonEnrolSelf } from '@addons/enrol/self/services/self';\nimport { CoreEnrol, CoreEnrolEnrolmentInfo, CoreEnrolEnrolmentMethod } from '@features/enrol/services/enrol';\nimport { CoreSiteWSPreSets, WSObservable } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmCourses:';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [CoreCoursesProvider.EVENT_MY_COURSES_CHANGED]: CoreCoursesMyCoursesChangedEventData;\n        [CoreCoursesProvider.EVENT_MY_COURSES_UPDATED]: CoreCoursesMyCoursesUpdatedEventData;\n        [CoreCoursesProvider.EVENT_DASHBOARD_DOWNLOAD_ENABLED_CHANGED]: CoreCoursesDashboardDownloadEnabledChangedEventData;\n    }\n\n}\n\n/**\n * Service that provides some features regarding lists of courses and categories.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCoursesProvider {\n\n    static readonly SEARCH_PER_PAGE = 20;\n    static readonly RECENT_PER_PAGE = 10;\n    static readonly ENROL_INVALID_KEY = 'CoreCoursesEnrolInvalidKey';\n    static readonly EVENT_MY_COURSES_CHANGED = 'courses_my_courses_changed'; // User course list changed while app is running.\n    // A course was hidden/favourite, or user enroled in a course.\n    static readonly EVENT_MY_COURSES_UPDATED = 'courses_my_courses_updated';\n    static readonly EVENT_MY_COURSES_REFRESHED = 'courses_my_courses_refreshed';\n    static readonly EVENT_DASHBOARD_DOWNLOAD_ENABLED_CHANGED = 'dashboard_download_enabled_changed';\n\n    // Actions for event EVENT_MY_COURSES_UPDATED.\n    static readonly ACTION_ENROL = 'enrol'; // User enrolled in a course.\n    static readonly ACTION_STATE_CHANGED = 'state_changed'; // Course state changed (hidden, favourite).\n    static readonly ACTION_VIEW = 'view'; // Course viewed.\n\n    // Possible states changed.\n    static readonly STATE_HIDDEN = 'hidden';\n    static readonly STATE_FAVOURITE = 'favourite';\n\n    protected userCoursesIds?: Set<number>;\n    protected downloadOptionsEnabled = false;\n\n    /**\n     * Get categories. They can be filtered by id.\n     *\n     * @param categoryId Category ID to get.\n     * @param addSubcategories If it should add subcategories to the list.\n     * @param siteId Site to get the courses from. If not defined, use current site.\n     * @returns Promise resolved with the categories.\n     */\n    async getCategories(\n        categoryId: number,\n        addSubcategories: boolean = false,\n        siteId?: string,\n    ): Promise<CoreCourseGetCategoriesWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        // Get parent when id is the root category.\n        const criteriaKey = categoryId == 0 ? 'parent' : 'id';\n        const params: CoreCourseGetCategoriesWSParams = {\n            criteria: [\n                {\n                    key: criteriaKey,\n                    value: categoryId,\n                },\n            ],\n            addsubcategories: addSubcategories,\n        };\n\n        const preSets = {\n            cacheKey: this.getCategoriesCacheKey(categoryId, addSubcategories),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n\n        return site.read('core_course_get_categories', params, preSets);\n    }\n\n    /**\n     * Get cache key for get categories methods WS call.\n     *\n     * @param categoryId Category ID to get.\n     * @param addSubcategories If add subcategories to the list.\n     * @returns Cache key.\n     */\n    protected getCategoriesCacheKey(categoryId: number, addSubcategories?: boolean): string {\n        return ROOT_CACHE_KEY + 'categories:' + categoryId + ':' + !!addSubcategories;\n    }\n\n    /**\n     * Given a list of course IDs to get course admin and nav options, return the list of courseIds to use.\n     *\n     * @param courseIds Course IDs.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with the list of course IDs.\n     */\n    protected async getCourseIdsForAdminAndNavOptions(courseIds: number[], siteId?: string): Promise<number[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const siteHomeId = site.getSiteHomeId();\n        if (courseIds.length == 1) {\n            // Only 1 course, check if it belongs to the user courses. If so, use all user courses.\n            return this.getCourseIdsIfEnrolled(courseIds[0], siteId);\n        } else {\n            if (courseIds.length > 1 && courseIds.indexOf(siteHomeId) == -1) {\n                courseIds.push(siteHomeId);\n            }\n\n            // Sort the course IDs.\n            courseIds.sort((a, b) => b - a);\n\n            return courseIds;\n        }\n    }\n\n    /**\n     * Given a course ID, if user is enrolled in the course it will return the IDs of all enrolled courses and site home.\n     * Return only the course ID otherwise.\n     *\n     * @param courseId Course Id.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with the list of course IDs.\n     */\n    async getCourseIdsIfEnrolled(courseId: number, siteId?: string): Promise<number[]> {\n        const site = await CoreSites.getSite(siteId);\n        const siteHomeId = site.getSiteHomeId();\n\n        try {\n            // Check if user is enrolled in the course.\n            const courses = await this.getUserCourses(true, siteId);\n            let useAllCourses = false;\n\n            if (courseId == siteHomeId) {\n                // It's site home, use all courses.\n                useAllCourses = true;\n            } else {\n                useAllCourses = !!courses.find((course) => course.id == courseId);\n            }\n\n            if (useAllCourses) {\n                // User is enrolled, return all the courses.\n                const courseIds = courses.map((course) => course.id);\n\n                // Always add the site home ID.\n                courseIds.push(siteHomeId);\n\n                // Sort the course IDs.\n                courseIds.sort((a, b) => b - a);\n\n                return courseIds;\n            }\n        } catch {\n            // Ignore errors.\n        }\n\n        return [courseId];\n    }\n\n    /**\n     * Check if download a whole course is disabled in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n     */\n    async isDownloadCourseDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.isDownloadCoursesDisabledInSite(site);\n    }\n\n    /**\n     * Check if download a whole course is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether it's disabled.\n     */\n    isDownloadCourseDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !site || site.isOfflineDisabled() || site.isFeatureDisabled('NoDelegate_CoreCourseDownload');\n    }\n\n    /**\n     * Check if download all courses is disabled in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n     */\n    async isDownloadCoursesDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.isDownloadCoursesDisabledInSite(site);\n    }\n\n    /**\n     * Check if download all courses is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether it's disabled.\n     */\n    isDownloadCoursesDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !site || site.isOfflineDisabled() || site.isFeatureDisabled('NoDelegate_CoreCoursesDownload');\n    }\n\n    /**\n     * Check if My Courses is disabled in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n     */\n    async isMyCoursesDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.isMyCoursesDisabledInSite(site);\n    }\n\n    /**\n     * Check if My Courses is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether it's disabled.\n     */\n    isMyCoursesDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !site || site.isFeatureDisabled('CoreMainMenuDelegate_CoreCourses');\n    }\n\n    /**\n     * Check if Search Courses is disabled in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n     */\n    async isSearchCoursesDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.isSearchCoursesDisabledInSite(site);\n    }\n\n    /**\n     * Check if Search Courses is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether it's disabled.\n     */\n    isSearchCoursesDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !site || site.isFeatureDisabled('CoreCourseOptionsDelegate_search');\n    }\n\n    /**\n     * Get course information if user has persmissions to view.\n     *\n     * @param id ID of the course to get.\n     * @param siteId Site to get the courses from. If not defined, use current site.\n     * @returns Promise resolved with the course.\n     */\n    async getCourse(id: number, siteId?: string): Promise<CoreCourseGetCoursesData> {\n        const courses = await this.getCourses([id], siteId);\n\n        if (courses && courses.length > 0) {\n            return courses[0];\n        }\n\n        throw Error('Course not found on core_course_get_courses');\n    }\n\n    /**\n     * Get the enrolment methods from a course.\n     *\n     * @param courseId ID of the course.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the methods.\n     * @deprecated since 4.3. Use CoreEnrol.getSupportedCourseEnrolmentMethods instead.\n     */\n    async getCourseEnrolmentMethods(courseId: number, siteId?: string): Promise<CoreEnrolEnrolmentMethod[]> {\n        return CoreEnrol.getSupportedCourseEnrolmentMethods(courseId, { siteId });\n    }\n\n    /**\n     * Get info from a course guest enrolment method.\n     *\n     * @param instanceId Guest instance ID.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved when the info is retrieved.\n     * @deprecated since 4.3 use AddonEnrolGuest.getCourseGuestEnrolmentInfo instead.\n     */\n    async getCourseGuestEnrolmentInfo(instanceId: number, siteId?: string): Promise<AddonEnrolGuestInfo> {\n        return AddonEnrolGuest.getGuestEnrolmentInfo(instanceId, siteId);\n    }\n\n    /**\n     * Get courses.\n     * Warning: if the user doesn't have permissions to view some of the courses passed the WS call will fail.\n     * The user must be able to view ALL the courses passed.\n     *\n     * @param ids List of IDs of the courses to get.\n     * @param siteId Site to get the courses from. If not defined, use current site.\n     * @returns Promise resolved with the courses.\n     */\n    async getCourses(ids: number[], siteId?: string): Promise<CoreCourseGetCoursesWSResponse> {\n        if (!Array.isArray(ids)) {\n            throw Error('ids parameter should be an array');\n        }\n\n        if (ids.length === 0) {\n            return [];\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreCourseGetCoursesWSParams = {\n            options: {\n                ids: ids,\n            },\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCoursesCacheKey(ids),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n\n        return site.read('core_course_get_courses', params, preSets);\n    }\n\n    /**\n     * Get cache key for get courses WS call.\n     *\n     * @param ids Courses IDs.\n     * @returns Cache key.\n     */\n    protected getCoursesCacheKey(ids: number[]): string {\n        return ROOT_CACHE_KEY + 'course:' + JSON.stringify(ids);\n    }\n\n    /**\n     * This function is meant to decrease WS calls.\n     * When requesting a single course that belongs to enrolled courses, request all enrolled courses because\n     * the WS call is probably cached.\n     *\n     * @param field The field to search.\n     * @param value The value to match.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the field and value to use.\n     */\n    protected async fixCoursesByFieldParams(\n        field: string = '',\n        value: number | string = '',\n        siteId?: string,\n    ): Promise<{ field: string; value: number | string }> {\n\n        if (field == 'id' || field == 'ids') {\n            let courseIds: number[];\n            if (typeof value == 'string') {\n                courseIds = value.split(',').map((id) => parseInt(id, 10));\n            } else {\n                courseIds = [value];\n            }\n\n            // Use the same optimization as in get admin and nav options. This will return the course IDs to use.\n            courseIds = await this.getCourseIdsForAdminAndNavOptions(courseIds, siteId);\n\n            if (courseIds.length > 1) {\n                return { field: 'ids', value: courseIds.join(',') };\n            } else {\n                return { field: 'id', value: Number(courseIds[0]) };\n            }\n        } else {\n            // Nothing to do.\n            return { field: field, value: value };\n        }\n    }\n\n    /**\n     * Get the first course returned by getCoursesByField.\n     *\n     * @param field The field to search. Can be left empty for all courses or:\n     *              id: course id.\n     *              ids: comma separated course ids.\n     *              shortname: course short name.\n     *              idnumber: course id number.\n     *              category: category id the course belongs to.\n     * @param value The value to match.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the first course.\n     */\n    async getCourseByField(field?: string, value?: string | number, siteId?: string): Promise<CoreCourseSearchedData> {\n        const courses = await this.getCoursesByField(field, value, siteId);\n\n        if (courses && courses.length > 0) {\n            return courses[0];\n        }\n\n        throw Error('Course not found on core_course_get_courses_by_field');\n    }\n\n    /**\n     * Get courses. They can be filtered by field.\n     *\n     * @param field The field to search. Can be left empty for all courses or:\n     *              id: course id.\n     *              ids: comma separated course ids.\n     *              shortname: course short name.\n     *              idnumber: course id number.\n     *              category: category id the course belongs to.\n     * @param value The value to match.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the courses.\n     */\n    getCoursesByField(\n        field: string = '',\n        value: string | number = '',\n        siteId?: string,\n    ): Promise<CoreCourseSearchedData[]> {\n        return firstValueFrom(this.getCoursesByFieldObservable(field, value, { siteId }));\n    }\n\n    /**\n     * Get courses. They can be filtered by field.\n     *\n     * @param field The field to search. Can be left empty for all courses or:\n     *              id: course id.\n     *              ids: comma separated course ids.\n     *              shortname: course short name.\n     *              idnumber: course id number.\n     *              category: category id the course belongs to.\n     * @param value The value to match.\n     * @param options Other options.\n     * @returns Observable that returns the courses.\n     */\n    getCoursesByFieldObservable(\n        field: string = '',\n        value: string | number = '',\n        options: CoreSitesCommonWSOptions = {},\n    ): WSObservable<CoreCourseSearchedData[]> {\n        return asyncObservable(async () => {\n            const siteId = options.siteId || CoreSites.getCurrentSiteId();\n            const originalValue = value;\n\n            const site = await CoreSites.getSite(siteId);\n\n            // Fix params. Tries to use cached data, no need to use observer.\n            const fieldParams = await this.fixCoursesByFieldParams(field, value, siteId);\n\n            const hasChanged = fieldParams.field != field || fieldParams.value != value;\n            field = fieldParams.field;\n            value = fieldParams.value;\n            const data: CoreCourseGetCoursesByFieldWSParams = {\n                field: field,\n                value: field ? value : '',\n            };\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getCoursesByFieldCacheKey(field, value),\n                updateFrequency: CoreSite.FREQUENCY_RARELY,\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n            };\n\n            const observable = site.readObservable<CoreCourseGetCoursesByFieldWSResponse>(\n                'core_course_get_courses_by_field',\n                data,\n                preSets,\n            );\n\n            return observable.pipe(map(response => {\n                if (!response.courses) {\n                    throw Error('WS core_course_get_courses_by_field failed');\n                }\n\n                if (field == 'ids' && hasChanged) {\n                    // The list of courses requestes was changed to optimize it.\n                    // Return only the ones that were being requested.\n                    const courseIds = String(originalValue).split(',').map((id) => parseInt(id, 10));\n\n                    // Only courses from the original selection.\n                    response.courses = response.courses.filter((course) => courseIds.indexOf(course.id) >= 0);\n                }\n\n                // Courses will be sorted using sortorder if available.\n                return response.courses.sort((a, b) => {\n                    if (a.sortorder === undefined && b.sortorder === undefined) {\n                        return b.id - a.id;\n                    }\n\n                    if (a.sortorder === undefined) {\n                        return 1;\n                    }\n\n                    if (b.sortorder === undefined) {\n                        return -1;\n                    }\n\n                    return a.sortorder - b.sortorder;\n                });\n            }));\n        });\n    }\n\n    /**\n     * Get cache key for get courses WS call.\n     *\n     * @param field The field to search.\n     * @param value The value to match.\n     * @returns Cache key.\n     */\n    protected getCoursesByFieldCacheKey(field: string = '', value: string | number = ''): string {\n        return ROOT_CACHE_KEY + 'coursesbyfield:' + field + ':' + value;\n    }\n\n    /**\n     * Get courses matching the given custom field. By default it will try not to use cache.\n     *\n     * @param customFieldName Custom field name.\n     * @param customFieldValue Custom field value.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the list of courses.\n     * @since 3.8\n     */\n    getEnrolledCoursesByCustomField(\n        customFieldName: string,\n        customFieldValue: string,\n        siteId?: string,\n    ): Promise<CoreCourseSummaryData[]> {\n        return firstValueFrom(this.getEnrolledCoursesByCustomFieldObservable(customFieldName, customFieldValue, {\n            readingStrategy: CoreSitesReadingStrategy.PREFER_NETWORK,\n            siteId,\n        }));\n    }\n\n    /**\n     * Get courses matching the given custom field.\n     *\n     * @param customFieldName Custom field name.\n     * @param customFieldValue Custom field value.\n     * @param options Common options.\n     * @returns Promise resolved with the list of courses.\n     * @since 3.8\n     */\n    getEnrolledCoursesByCustomFieldObservable(\n        customFieldName: string,\n        customFieldValue: string,\n        options: CoreSitesCommonWSOptions,\n    ): WSObservable<CoreCourseSummaryData[]> {\n        return asyncObservable(async () => {\n            const site = await CoreSites.getSite(options. siteId);\n\n            const params: CoreCourseGetEnrolledCoursesByTimelineClassificationWSParams = {\n                classification: 'customfield',\n                customfieldname: customFieldName,\n                customfieldvalue: customFieldValue,\n            };\n            const preSets: CoreSiteWSPreSets = {\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy ?? CoreSitesReadingStrategy.PREFER_NETWORK),\n            };\n\n            return site.readObservable<CoreCourseGetEnrolledCoursesByTimelineClassificationWSResponse>(\n                'core_course_get_enrolled_courses_by_timeline_classification',\n                params,\n                preSets,\n            ).pipe(map(response => response.courses));\n        });\n    }\n\n    /**\n     * Get the navigation and administration options for the given courses.\n     *\n     * @param courseIds IDs of courses to get.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the options for each course.\n     */\n    getCoursesAdminAndNavOptions(\n        courseIds: number[],\n        siteId?: string,\n    ): Promise<{\n            navOptions: CoreCourseUserAdminOrNavOptionCourseIndexed;\n            admOptions: CoreCourseUserAdminOrNavOptionCourseIndexed;\n        }> {\n        return firstValueFrom(this.getCoursesAdminAndNavOptionsObservable(courseIds, { siteId }));\n    }\n\n    /**\n     * Get the navigation and administration options for the given courses.\n     *\n     * @param courseIds IDs of courses to get.\n     * @param options Options.\n     * @returns Observable that returns the options for each course.\n     */\n    getCoursesAdminAndNavOptionsObservable(\n        courseIds: number[],\n        options: CoreSitesCommonWSOptions = {},\n    ): WSObservable<{\n            navOptions: CoreCourseUserAdminOrNavOptionCourseIndexed;\n            admOptions: CoreCourseUserAdminOrNavOptionCourseIndexed;\n        }> {\n\n        return asyncObservable(async () => {\n            const siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n            // Get the list of courseIds to use based on the param. Tries to use cached data, no need to use observer.\n            courseIds = await this.getCourseIdsForAdminAndNavOptions(courseIds, siteId);\n\n            // Get user navigation and administration options.\n            return zipIncludingComplete(\n                ignoreErrors(this.getUserNavigationOptionsObservable(courseIds, options), {}),\n                ignoreErrors(this.getUserAdministrationOptionsObservable(courseIds, options), {}),\n            ).pipe(\n                map(([navOptions, admOptions]) => ({\n                    navOptions: navOptions as CoreCourseUserAdminOrNavOptionCourseIndexed,\n                    admOptions: admOptions as CoreCourseUserAdminOrNavOptionCourseIndexed,\n                })),\n            );\n        });\n    }\n\n    /**\n     * Get cache key for get recent courses WS call.\n     *\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getRecentCoursesCacheKey(userId: number): string {\n        return `${ROOT_CACHE_KEY}:recentcourses:${userId}`;\n    }\n\n    /**\n     * Get recent courses.\n     *\n     * @param options Options.\n     * @returns Promise resolved with courses.\n     * @since 3.6\n     */\n    async getRecentCourses(options: CoreCourseGetRecentCoursesOptions = {}): Promise<CoreCourseSummaryData[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const userId = options.userId || site.getUserId();\n        const params: CoreCourseGetRecentCoursesWSParams = {\n            userid: userId,\n            offset: options.offset || 0,\n            limit: options.limit || CoreCoursesProvider.RECENT_PER_PAGE,\n            sort: options.sort,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getRecentCoursesCacheKey(userId),\n        };\n\n        return site.read<CoreCourseSummaryData[]>('core_course_get_recent_courses', params, preSets);\n    }\n\n    /**\n     * Get the common part of the cache keys for user administration options WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getUserAdministrationOptionsCommonCacheKey(): string {\n        return ROOT_CACHE_KEY + 'administrationOptions:';\n    }\n\n    /**\n     * Get cache key for get user administration options WS call.\n     *\n     * @param courseIds IDs of courses to get.\n     * @returns Cache key.\n     */\n    protected getUserAdministrationOptionsCacheKey(courseIds: number[]): string {\n        return this.getUserAdministrationOptionsCommonCacheKey() + courseIds.join(',');\n    }\n\n    /**\n     * Get user administration options for a set of courses.\n     *\n     * @param courseIds IDs of courses to get.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with administration options for each course.\n     */\n    getUserAdministrationOptions(courseIds: number[], siteId?: string): Promise<CoreCourseUserAdminOrNavOptionCourseIndexed> {\n        return firstValueFrom(this.getUserAdministrationOptionsObservable(courseIds, { siteId }));\n    }\n\n    /**\n     * Get user administration options for a set of courses.\n     *\n     * @param courseIds IDs of courses to get.\n     * @param options Options.\n     * @returns Observable that returns administration options for each course.\n     */\n    getUserAdministrationOptionsObservable(\n        courseIds: number[],\n        options: CoreSitesCommonWSOptions = {},\n    ): WSObservable<CoreCourseUserAdminOrNavOptionCourseIndexed> {\n        if (!courseIds || courseIds.length == 0) {\n            return of({});\n        }\n\n        return asyncObservable(async () => {\n            const site = await CoreSites.getSite(options.siteId);\n\n            const params: CoreCourseGetUserAdminOrNavOptionsWSParams = {\n                courseids: courseIds,\n            };\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getUserAdministrationOptionsCacheKey(courseIds),\n                updateFrequency: CoreSite.FREQUENCY_RARELY,\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n            };\n\n            const observable = site.readObservable<CoreCourseGetUserAdminOrNavOptionsWSResponse>(\n                'core_course_get_user_administration_options',\n                params,\n                preSets,\n            );\n\n            // Format returned data.\n            return observable.pipe(map(response => this.formatUserAdminOrNavOptions(response.courses)));\n        });\n    }\n\n    /**\n     * Get the common part of the cache keys for user navigation options WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getUserNavigationOptionsCommonCacheKey(): string {\n        return ROOT_CACHE_KEY + 'navigationOptions:';\n    }\n\n    /**\n     * Get cache key for get user navigation options WS call.\n     *\n     * @returns Cache key.\n     */\n    protected getUserNavigationOptionsCacheKey(courseIds: number[]): string {\n        return this.getUserNavigationOptionsCommonCacheKey() + courseIds.join(',');\n    }\n\n    /**\n     * Get user navigation options for a set of courses.\n     *\n     * @param courseIds IDs of courses to get.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with navigation options for each course.\n     */\n    async getUserNavigationOptions(courseIds: number[], siteId?: string): Promise<CoreCourseUserAdminOrNavOptionCourseIndexed> {\n        return firstValueFrom(this.getUserNavigationOptionsObservable(courseIds, { siteId }));\n    }\n\n    /**\n     * Get user navigation options for a set of courses.\n     *\n     * @param courseIds IDs of courses to get.\n     * @param options Options.\n     * @returns Observable that returns navigation options for each course.\n     */\n    getUserNavigationOptionsObservable(\n        courseIds: number[],\n        options: CoreSitesCommonWSOptions = {},\n    ): WSObservable<CoreCourseUserAdminOrNavOptionCourseIndexed> {\n        if (!courseIds || courseIds.length == 0) {\n            return of({});\n        }\n\n        return asyncObservable(async () => {\n            const site = await CoreSites.getSite(options.siteId);\n\n            const params: CoreCourseGetUserAdminOrNavOptionsWSParams = {\n                courseids: courseIds,\n            };\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getUserNavigationOptionsCacheKey(courseIds),\n                updateFrequency: CoreSite.FREQUENCY_RARELY,\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n            };\n\n            const observable = site.readObservable<CoreCourseGetUserAdminOrNavOptionsWSResponse>(\n                'core_course_get_user_navigation_options',\n                params,\n                preSets,\n            );\n\n            // Format returned data.\n            return observable.pipe(map(response => this.formatUserAdminOrNavOptions(response.courses)));\n        });\n    }\n\n    /**\n     * Format user navigation or administration options.\n     *\n     * @param courses Navigation or administration options for each course.\n     * @returns Formatted options.\n     */\n    protected formatUserAdminOrNavOptions(courses: CoreCourseUserAdminOrNavOption[]): CoreCourseUserAdminOrNavOptionCourseIndexed {\n        const result = {};\n\n        courses.forEach((course) => {\n            const options = {};\n\n            if (course.options) {\n                course.options.forEach((option) => {\n                    options[option.name] = option.available;\n                });\n            }\n\n            result[course.id] = options;\n        });\n\n        return result;\n    }\n\n    /**\n     * Get a course the user is enrolled in. This function relies on getUserCourses.\n     * preferCache=true will try to speed up the response, but the data returned might not be updated.\n     *\n     * @param id ID of the course to get.\n     * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n     * @param siteId Site to get the courses from. If not defined, use current site.\n     * @returns Promise resolved with the course.\n     */\n    async getUserCourse(id: number, preferCache?: boolean, siteId?: string): Promise<CoreEnrolledCourseData> {\n        if (!id) {\n            throw Error('Invalid id parameter on getUserCourse');\n        }\n\n        const courses = await this.getUserCourses(preferCache, siteId);\n\n        const course = courses.find((course) => course.id == id);\n\n        if (course) {\n            return course;\n        }\n\n        throw Error('Course not found on core_enrol_get_users_courses');\n    }\n\n    /**\n     * Get user courses.\n     *\n     * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n     * @param siteId Site to get the courses from. If not defined, use current site.\n     * @param strategy Reading strategy.\n     * @returns Promise resolved with the courses.\n     */\n    getUserCourses(\n        preferCache: boolean = false,\n        siteId?: string,\n        strategy?: CoreSitesReadingStrategy,\n    ): Promise<CoreEnrolledCourseData[]> {\n        strategy = strategy ?? (preferCache ? CoreSitesReadingStrategy.PREFER_CACHE : undefined);\n\n        return firstValueFrom(this.getUserCoursesObservable({\n            readingStrategy: strategy,\n            siteId,\n        }));\n    }\n\n    /**\n     * Get user courses.\n     *\n     * @param options Options.\n     * @returns Observable that returns the courses.\n     */\n    getUserCoursesObservable(options: CoreSitesCommonWSOptions = {}): WSObservable<CoreEnrolledCourseData[]> {\n        return asyncObservable(async () => {\n            const site = await CoreSites.getSite(options.siteId);\n\n            const userId = site.getUserId();\n            const wsParams: CoreEnrolGetUsersCoursesWSParams = {\n                userid: userId,\n            };\n\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getUserCoursesCacheKey(),\n                getCacheUsingCacheKey: true,\n                updateFrequency: CoreSite.FREQUENCY_RARELY,\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n            };\n\n            if (site.isVersionGreaterEqualThan('3.7')) {\n                wsParams.returnusercount = false;\n            }\n\n            const observable = site.readObservable<CoreEnrolGetUsersCoursesWSResponse>(\n                'core_enrol_get_users_courses',\n                wsParams,\n                preSets,\n            );\n\n            return observable.pipe(map(courses => {\n                if (this.userCoursesIds) {\n                    // Check if the list of courses has changed.\n                    const added: number[] = [];\n                    const removed: number[] = [];\n                    const previousIds = this.userCoursesIds;\n                    const currentIds = new Set<number>();\n\n                    courses.forEach((course) => {\n                        // Move category field to categoryid on a course.\n                        course.categoryid = course.category;\n                        delete course.category;\n\n                        currentIds.add(course.id);\n\n                        if (!previousIds.has(course.id)) {\n                            // Course added.\n                            added.push(course.id);\n                        }\n                    });\n\n                    if (courses.length - added.length !== previousIds.size) {\n                        // A course was removed, check which one.\n                        previousIds.forEach((id) => {\n                            if (!currentIds.has(id)) {\n                                // Course removed.\n                                removed.push(Number(id));\n                            }\n                        });\n                    }\n\n                    if (added.length || removed.length) {\n                        // At least 1 course was added or removed, trigger the event.\n                        CoreEvents.trigger(CoreCoursesProvider.EVENT_MY_COURSES_CHANGED, {\n                            added: added,\n                            removed: removed,\n                        }, site.getId());\n                    }\n\n                    this.userCoursesIds = currentIds;\n                } else {\n                    const coursesIds = new Set<number>();\n\n                    // Store the list of courses.\n                    courses.forEach((course) => {\n                        coursesIds.add(course.id);\n\n                        // Move category field to categoryid on a course.\n                        course.categoryid = course.category;\n                        delete course.category;\n                    });\n\n                    this.userCoursesIds = coursesIds;\n                }\n\n                return courses;\n            }));\n        });\n    }\n\n    /**\n     * Get cache key for get user courses WS call.\n     *\n     * @returns Cache key.\n     */\n    protected getUserCoursesCacheKey(): string {\n        return ROOT_CACHE_KEY + 'usercourses';\n    }\n\n    /**\n     * Invalidates get categories WS call.\n     *\n     * @param categoryId Category ID to get.\n     * @param addSubcategories If it should add subcategories to the list.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCategories(categoryId: number, addSubcategories?: boolean, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCategoriesCacheKey(categoryId, addSubcategories));\n    }\n\n    /**\n     * Invalidates get course WS call.\n     *\n     * @param id Course ID.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    invalidateCourse(id: number, siteId?: string): Promise<void> {\n        return this.invalidateCourses([id], siteId);\n    }\n\n    /**\n     * Invalidates get course enrolment methods WS call.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     * @deprecated since 4.3 use CoreEnrol.invalidateCourseEnrolmentMethods instead.\n     */\n    async invalidateCourseEnrolmentMethods(courseId: number, siteId?: string): Promise<void> {\n        return CoreEnrol.invalidateCourseEnrolmentMethods(courseId, siteId);\n    }\n\n    /**\n     * Invalidates get course guest enrolment info WS call.\n     *\n     * @param instanceId Guest instance ID.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     * @deprecated since 4.3 use CoreEnrolDelegate.invalidate instead.\n     */\n    async invalidateCourseGuestEnrolmentInfo(instanceId: number, siteId?: string): Promise<void> {\n        return AddonEnrolGuest.invalidateGuestEnrolmentInfo(instanceId, siteId);\n    }\n\n    /**\n     * Invalidates the navigation and administration options for the given courses.\n     *\n     * @param courseIds IDs of courses to get.\n     * @param siteId Site ID to invalidate. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCoursesAdminAndNavOptions(courseIds: number[], siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const ids = await this.getCourseIdsForAdminAndNavOptions(courseIds, siteId);\n\n        const promises: Promise<void>[] = [];\n        promises.push(this.invalidateUserAdministrationOptionsForCourses(ids, siteId));\n        promises.push(this.invalidateUserNavigationOptionsForCourses(ids, siteId));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidates get courses WS call.\n     *\n     * @param ids Courses IDs.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCourses(ids: number[], siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCoursesCacheKey(ids));\n    }\n\n    /**\n     * Invalidates get courses by field WS call.\n     *\n     * @param field See getCoursesByField for info.\n     * @param value The value to match.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCoursesByField(field: string = '', value: number | string = '', siteId?: string): Promise<void> {\n        if (typeof value === 'string' && value.length === 0) {\n            return;\n        }\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const result = await this.fixCoursesByFieldParams(field, value, siteId);\n        field = result.field;\n        value = result.value;\n\n        const site = await CoreSites.getSite(siteId);\n\n        return site.invalidateWsCacheForKey(this.getCoursesByFieldCacheKey(field, value));\n    }\n\n    /**\n     * Invalidates get recent courses WS call.\n     *\n     * @param userId User ID. If not defined, current user.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateRecentCourses(userId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getRecentCoursesCacheKey(userId || site.getUserId()));\n    }\n\n    /**\n     * Invalidates all user administration options.\n     *\n     * @param siteId Site ID to invalidate. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserAdministrationOptions(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getUserAdministrationOptionsCommonCacheKey());\n    }\n\n    /**\n     * Invalidates user administration options for certain courses.\n     *\n     * @param courseIds IDs of courses.\n     * @param siteId Site ID to invalidate. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserAdministrationOptionsForCourses(courseIds: number[], siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getUserAdministrationOptionsCacheKey(courseIds));\n    }\n\n    /**\n     * Invalidates get user courses WS call.\n     *\n     * @param siteId Site ID to invalidate. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserCourses(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getUserCoursesCacheKey());\n    }\n\n    /**\n     * Invalidates all user navigation options.\n     *\n     * @param siteId Site ID to invalidate. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserNavigationOptions(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getUserNavigationOptionsCommonCacheKey());\n    }\n\n    /**\n     * Invalidates user navigation options for certain courses.\n     *\n     * @param courseIds IDs of courses.\n     * @param siteId Site ID to invalidate. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserNavigationOptionsForCourses(courseIds: number[], siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getUserNavigationOptionsCacheKey(courseIds));\n    }\n\n    /**\n     * Report a dashboard or my courses page view event.\n     *\n     * @param page Page to view.\n     */\n    async logView(page: 'my' | 'dashboard'): Promise<void> {\n        const site = CoreSites.getRequiredCurrentSite();\n        if (!site.wsAvailable('core_my_view_page')) {\n            return;\n        }\n\n        const params: CoreMyViewPageWSParams = { page };\n\n        await site.write('core_my_view_page', params);\n    }\n\n    /**\n     * Search courses.\n     *\n     * @param text Text to search.\n     * @param page Page to get.\n     * @param perPage Number of courses per page. Defaults to CoreCoursesProvider.SEARCH_PER_PAGE.\n     * @param limitToEnrolled Limit to enrolled courses.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the courses and the total of matches.\n     */\n    async search(\n        text: string,\n        page: number = 0,\n        perPage: number = CoreCoursesProvider.SEARCH_PER_PAGE,\n        limitToEnrolled: boolean = false,\n        siteId?: string,\n    ): Promise<{ total: number; courses: CoreCourseBasicSearchedData[] }> {\n        const site = await CoreSites.getSite(siteId);\n        const params: CoreCourseSearchCoursesWSParams = {\n            criterianame: 'search',\n            criteriavalue: text,\n            page: page,\n            perpage: perPage,\n            limittoenrolled: limitToEnrolled,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            getFromCache: false,\n        };\n\n        const response = await site.read<CoreCourseSearchCoursesWSResponse>('core_course_search_courses', params, preSets);\n\n        return ({ total: response.total, courses: response.courses });\n    }\n\n    /**\n     * Self enrol current user in a certain course.\n     *\n     * @param courseId Course ID.\n     * @param password Password to use.\n     * @param instanceId Enrol instance ID.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved if the user is enrolled. If the password is invalid, the promise is rejected\n     *         with an object with errorcode = CoreCoursesProvider.ENROL_INVALID_KEY.\n     * @deprecated since 4.3 use CoreEnrolDelegate.enrol instead.\n     */\n    async selfEnrol(courseId: number, password: string = '', instanceId?: number, siteId?: string): Promise<boolean> {\n        return AddonEnrolSelf.selfEnrol(courseId, password, instanceId, siteId);\n    }\n\n    /**\n     * Set favourite property on a course.\n     *\n     * @param courseId Course ID.\n     * @param favourite If favourite or unfavourite.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved when done.\n     */\n    async setFavouriteCourse(courseId: number, favourite: boolean, siteId?: string): Promise<CoreWarningsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreCourseSetFavouriteCoursesWSParams = {\n            courses: [\n                {\n                    id: courseId,\n                    favourite: favourite,\n                },\n            ],\n        };\n\n        return site.write('core_course_set_favourite_courses', params);\n    }\n\n    /**\n     * Get download options enabled option.\n     *\n     * @returns True if enabled, false otherwise.\n     */\n    getCourseDownloadOptionsEnabled(): boolean {\n        return this.downloadOptionsEnabled;\n    }\n\n    /**\n     * Set trigger and save the download option.\n     *\n     * @param enable True to enable, false to disable.\n     */\n    setCourseDownloadOptionsEnabled(enable: boolean): void {\n        if (this.downloadOptionsEnabled == enable) {\n            return;\n        }\n\n        this.downloadOptionsEnabled = enable;\n        CoreEvents.trigger(CoreCoursesProvider.EVENT_DASHBOARD_DOWNLOAD_ENABLED_CHANGED, { enabled: enable });\n    }\n\n}\n\nexport const CoreCourses = makeSingleton(CoreCoursesProvider);\n\n/**\n * Data sent to the EVENT_MY_COURSES_UPDATED.\n */\nexport type CoreCoursesMyCoursesUpdatedEventData = {\n    action: string; // Action performed.\n    courseId?: number; // Course ID affected (if any).\n    course?: CoreCourseAnyCourseData; // Course affected (if any).\n    state?: string; // Only for ACTION_STATE_CHANGED. The state that changed (hidden, favourite).\n    value?: boolean; // The new value for the state changed.\n};\n\n/**\n * Data sent to the EVENT_MY_COURSES_CHANGED.\n */\nexport type CoreCoursesMyCoursesChangedEventData = {\n    added: number[];\n    removed: number[];\n};\n\n/**\n * Data sent to the EVENT_DASHBOARD_DOWNLOAD_ENABLED_CHANGED.\n */\nexport type CoreCoursesDashboardDownloadEnabledChangedEventData = {\n    enabled: boolean;\n};\n\n/**\n * Params of core_enrol_get_users_courses WS.\n */\ntype CoreEnrolGetUsersCoursesWSParams = {\n    userid: number; // User id.\n    returnusercount?: boolean; // Include count of enrolled users for each course? This can add several seconds to the response\n    // time if a user is on several large courses, so set this to false if the value will not be used to improve performance.\n};\n\n/**\n * Data returned by core_enrol_get_users_courses WS.\n */\ntype CoreEnrolGetUsersCoursesWSResponse = (CoreEnrolledCourseData & {\n    category?: number; // Course category id.\n})[];\n\n/**\n * Basic data obtained form any course.\n */\nexport type CoreCourseBasicData = {\n    id: number; // Course id.\n    fullname: string; // Course full name.\n    displayname?: string; // Course display name.\n    shortname: string; // Course short name.\n    summary: string; // Summary.\n    summaryformat: number; // Summary format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    categoryid?: number; // Course category id.\n};\n\n/**\n * Basic data obtained from a course when the user is enrolled.\n */\nexport type CoreEnrolledCourseBasicData = CoreCourseBasicData & {\n    idnumber?: string; // Id number of course.\n    visible?: number; // 1 means visible, 0 means not yet visible course.\n    format?: string; // Course format: weeks, topics, social, site.\n    showgrades?: boolean; // True if grades are shown, otherwise false.\n    lang?: string; // Forced course language.\n    enablecompletion?: boolean; // True if completion is enabled, otherwise false.\n    startdate?: number; // Timestamp when the course start.\n    enddate?: number; // Timestamp when the course end.\n};\n\n/**\n * Course Data model received when the user is enrolled.\n */\nexport type CoreEnrolledCourseData = CoreEnrolledCourseBasicData & {\n    enrolledusercount?: number; // Number of enrolled users in this course.\n    completionhascriteria?: boolean; // If completion criteria is set.\n    completionusertracked?: boolean; // If the user is completion tracked.\n    progress?: number | null; // Progress percentage.\n    completed?: boolean; //  @since 3.6. Whether the course is completed.\n    marker?: number; //  @since 3.6. Course section marker.\n    lastaccess?: number; // @since 3.6. Last access to the course (timestamp).\n    isfavourite?: boolean; // If the user marked this course a favourite.\n    hidden?: boolean; // If the user hide the course from the dashboard.\n    overviewfiles?: CoreWSExternalFile[]; // @since 3.6.\n    showactivitydates?: boolean; // @since 3.11. Whether the activity dates are shown or not.\n    showcompletionconditions?: boolean; // @since 3.11. Whether the activity completion conditions are shown or not.\n    timemodified?: number; // @since 4.0. Last time course settings were updated (timestamp).\n};\n\n/**\n * Basic course data received on search.\n */\nexport type CoreCourseBasicSearchedData = CoreCourseBasicData & {\n    categoryid: number; // Category id.\n    categoryname: string; // Category name.\n    sortorder?: number; // Sort order in the category.\n    summaryfiles?: CoreWSExternalFile[];\n    overviewfiles: CoreWSExternalFile[];\n    contacts: { // Contact users.\n        id: number; // Contact user id.\n        fullname: string; // Contact user fullname.\n    }[];\n    enrollmentmethods: string[]; // Enrollment methods list.\n    customfields?: CoreCourseCustomField[]; // Custom fields and associated values.\n    showactivitydates?: boolean; // @since 3.11. Whether the activity dates are shown or not.\n    showcompletionconditions?: boolean; // @since 3.11. Whether the activity completion conditions are shown or not.\n};\n\nexport type CoreCourseSearchedData = CoreCourseBasicSearchedData & {\n    idnumber?: string; // Id number.\n    format?: string; // Course format: weeks, topics, social, site,..\n    showgrades?: number; // 1 if grades are shown, otherwise 0.\n    newsitems?: number; // Number of recent items appearing on the course page.\n    startdate?: number; // Timestamp when the course start.\n    enddate?: number; // Timestamp when the course end.\n    maxbytes?: number; // Largest size of file that can be uploaded into.\n    showreports?: number; // Are activity report shown (yes = 1, no =0).\n    visible?: number; // 1: available to student, 0:not available.\n    groupmode?: number; // No group, separate, visible.\n    groupmodeforce?: number; // 1: yes, 0: no.\n    defaultgroupingid?: number; // Default grouping id.\n    enablecompletion?: number; // Completion enabled? 1: yes 0: no.\n    completionnotify?: number; // 1: yes 0: no.\n    lang?: string; // Forced course language.\n    theme?: string; // Fame of the forced theme.\n    marker?: number; // Current course marker.\n    legacyfiles?: number; // If legacy files are enabled.\n    calendartype?: string; // Calendar type.\n    timecreated?: number; // Time when the course was created.\n    timemodified?: number; // Last time the course was updated.\n    requested?: number; // If is a requested course.\n    cacherev?: number; // Cache revision number.\n    filters?: { // Course filters.\n        filter: string; // Filter plugin name.\n        localstate: number; // Filter state: 1 for on, -1 for off, 0 if inherit.\n        inheritedstate: number; // 1 or 0 to use when localstate is set to inherit.\n    }[];\n    courseformatoptions?: CoreCourseFormatOption[]; // Additional options for particular course format.\n};\n\n/**\n * Course to render as list item.\n */\nexport type CoreCourseListItem = ((CoreCourseSearchedData & CoreCourseWithImageAndColor) |\nCoreCourseAnyCourseDataWithExtraInfoAndOptions) & {\n    isfavourite?: boolean; // If the user marked this course a favourite.\n    hidden?: boolean; // If the user hide the course from the dashboard.\n    completionusertracked?: boolean; // If the user is completion tracked.\n    progress?: number | null; // Progress percentage.\n};\n\nexport type CoreCourseGetCoursesData = CoreEnrolledCourseBasicData & {\n    categoryid: number; // Category id.\n    categorysortorder?: number; // Sort order into the category.\n    newsitems?: number; // Number of recent items appearing on the course page.\n    /**\n     * Number of weeks/topics.\n     *\n     * @deprecatedonmoodle since 2.4. Use courseformatoptions. This attribute is deprecated in moodle since 2.4 but still present.\n     */\n    numsections?: number;\n    maxbytes?: number; // Largest size of file that can be uploaded into the course.\n    showreports?: number; // Are activity report shown (yes = 1, no =0).\n    /**\n     * How the hidden sections in the course are displayed to students.\n     *\n     * @deprecatedonmoodle since 2.4. Use courseformatoptions. This attribute is deprecated in moodle since 2.4 but still present.\n     */\n    hiddensections?: number;\n    groupmode?: number; // No group, separate, visible.\n    groupmodeforce?: number; // 1: yes, 0: no.\n    defaultgroupingid?: number; // Default grouping id.\n    timecreated?: number; // Timestamp when the course have been created.\n    timemodified?: number; // Timestamp when the course have been modified.\n    completionnotify?: number; // 1: yes 0: no.\n    forcetheme?: string; // Name of the force theme.\n    courseformatoptions?: CoreCourseFormatOption[]; // Additional options for particular course format.\n    customfields?: CoreCourseCustomField[]; // Custom fields and associated values.\n    showactivitydates?: boolean; // @since 3.11. Whether the activity dates are shown or not.\n    showcompletionconditions?: boolean; // @since 3.11. Whether the activity completion conditions are shown or not.\n};\n\n/**\n * Course custom fields and associated values.\n */\nexport type CoreCourseCustomField = {\n    name: string; // The name of the custom field.\n    shortname: string; // The shortname of the custom field.\n    type: string; // The type of the custom field - text, checkbox...\n    valueraw: string; // The raw value of the custom field.\n    value: string; // The value of the custom field.\n};\n\n/**\n * Additional options for particular course format.\n */\nexport type CoreCourseFormatOption = {\n    name: string; // Course format option name.\n    value: string; // Course format option value.\n};\n\n/**\n * Indexed course format options.\n */\nexport type CoreCourseFormatOptionsIndexed = {\n    [name: string]: string;\n};\n\n/**\n * Params of core_course_get_courses_by_field WS.\n */\ntype CoreCourseGetCoursesByFieldWSParams = {\n    /**\n     * The field to search can be left empty for all courses or:\n     * id: course id\n     * ids: comma separated course ids\n     * shortname: course short name\n     * idnumber: course id number\n     * category: category id the course belongs to.\n     */\n    field?: string;\n    value?: string | number; // The value to match.\n};\n\n/**\n * Data returned by core_course_get_courses_by_field WS.\n */\nexport type CoreCourseGetCoursesByFieldWSResponse = {\n    courses: CoreCourseSearchedData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_course_search_courses WS.\n */\ntype CoreCourseSearchCoursesWSParams = {\n    criterianame: string; // Criteria name (search, modulelist (only admins), blocklist (only admins), tagid).\n    criteriavalue: string; // Criteria value.\n    page?: number; // Page number (0 based).\n    perpage?: number; // Items per page.\n    requiredcapabilities?: string[]; // Optional list of required capabilities (used to filter the list).\n    limittoenrolled?: boolean; // Limit to enrolled courses.\n    onlywithcompletion?: boolean; // Limit to courses where completion is enabled.\n};\n\n/**\n * Data returned by core_course_search_courses WS.\n */\nexport type CoreCourseSearchCoursesWSResponse = {\n    total: number; // Total course count.\n    courses: CoreCourseBasicSearchedData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_course_get_courses WS.\n */\ntype CoreCourseGetCoursesWSParams = {\n    options?: {\n        ids?: number[]; // List of course id. If empty return all courses except front page course.\n    }; // Options - operator OR is used.\n};\n\n/**\n * Data returned by core_course_get_courses WS.\n */\nexport type CoreCourseGetCoursesWSResponse = CoreCourseGetCoursesData[];\n\n/**\n * Course data exported by course_summary_exporter;\n */\nexport type CoreCourseSummaryData = CoreCourseBasicData & { // Course.\n    idnumber: string; // Idnumber.\n    startdate: number; // Startdate.\n    enddate: number; // Enddate.\n    visible: boolean; // Visible.\n    showactivitydates: boolean; // Showactivitydates.\n    showcompletionconditions: boolean; // Showcompletionconditions.\n    fullnamedisplay: string; // Fullnamedisplay.\n    viewurl: string; // Viewurl.\n    courseimage: string; // Courseimage.\n    progress?: number; // Progress.\n    hasprogress: boolean; // Hasprogress.\n    isfavourite: boolean; // Isfavourite.\n    hidden: boolean; // Hidden.\n    timeaccess?: number; // Timeaccess.\n    showshortname: boolean; // Showshortname.\n    coursecategory: string; // Coursecategory.\n};\n\n/**\n * Params of core_course_get_enrolled_courses_by_timeline_classification WS.\n */\ntype CoreCourseGetEnrolledCoursesByTimelineClassificationWSParams = {\n    classification: string; // Future, inprogress, or past.\n    limit?: number; // Result set limit.\n    offset?: number; // Result set offset.\n    sort?: string; // Sort string.\n    customfieldname?: string; // Used when classification = customfield.\n    customfieldvalue?: string; // Used when classification = customfield.\n};\n\n/**\n * Data returned by core_course_get_enrolled_courses_by_timeline_classification WS.\n */\nexport type CoreCourseGetEnrolledCoursesByTimelineClassificationWSResponse = {\n    courses: CoreCourseSummaryData[];\n    nextoffset: number; // Offset for the next request.\n};\n\n/**\n * Params of core_course_get_categories WS.\n */\ntype CoreCourseGetCategoriesWSParams = {\n    criteria?: { // Criteria.\n        /**\n         * The category column to search, expected keys (value format) are:\n         * \"id\" (int) the category id,\n         * \"ids\" (string) category ids separated by commas,\n         * \"name\" (string) the category name,\n         * \"parent\" (int) the parent category id,\n         * \"idnumber\" (string) category idnumber - user must have 'moodle/category:manage' to search on idnumber,\n         * \"visible\" (int) whether the returned categories must be visible or hidden.\n         * If the key is not passed, then the function return all categories that the user can see..\n         */\n        key: string;\n        value: string | number; // The value to match.\n    }[];\n    addsubcategories?: boolean; // Return the sub categories infos (1 - default) otherwise only the category info (0).\n};\n\n/**\n * Data returned by core_course_get_categories WS.\n */\nexport type CoreCourseGetCategoriesWSResponse = CoreCategoryData[];\n\n/**\n * Category data model.\n */\nexport type CoreCategoryData = {\n    id: number; // Category id.\n    name: string; // Category name.\n    idnumber?: string; // Category id number.\n    description: string; // Category description.\n    descriptionformat: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    parent: number; // Parent category id.\n    sortorder: number; // Category sorting order.\n    coursecount: number; // Number of courses in this category.\n    visible?: number; // 1: available, 0:not available.\n    visibleold?: number; // 1: available, 0:not available.\n    timemodified?: number; // Timestamp.\n    depth: number; // Category depth.\n    path: string; // Category path.\n    theme?: string; // Category theme.\n};\n\n/**\n * Params of core_course_get_user_navigation_options and core_course_get_user_administration_options WS.\n */\ntype CoreCourseGetUserAdminOrNavOptionsWSParams = {\n    courseids: number[];\n};\n\n/**\n * Data returned by core_course_get_user_navigation_options and core_course_get_user_administration_options WS.\n */\nexport type CoreCourseGetUserAdminOrNavOptionsWSResponse = {\n    courses: CoreCourseUserAdminOrNavOption[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Admin or navigation option data.\n */\nexport type CoreCourseUserAdminOrNavOption = {\n    id: number; // Course id.\n    options: {\n        name: string; // Option name.\n        available: boolean; // Whether the option is available or not.\n    }[];\n};\n\n/**\n * Indexed administration or navigation course options.\n */\nexport type CoreCourseUserAdminOrNavOptionCourseIndexed = {\n    [id: number]: CoreCourseUserAdminOrNavOptionIndexed;\n};\n\n/**\n * Indexed administration or navigation options.\n */\nexport type CoreCourseUserAdminOrNavOptionIndexed = {\n    [name: string]: // Option name.\n    boolean; // Whether the option is available or not.\n};\n\n/**\n * Course enrolment basic info.\n *\n * @deprecated since 4.3. Use CoreEnrolEnrolmentInfo instead.\n */\nexport type CoreCourseEnrolmentInfo = CoreEnrolEnrolmentInfo;\n\n/**\n * Course enrolment method.\n *\n * @deprecated since 4.3. Use CoreEnrolEnrolmentMethod instead.\n */\nexport type CoreCourseEnrolmentMethod = CoreEnrolEnrolmentMethod;\n\n/**\n * Params of core_course_get_recent_courses WS.\n */\nexport type CoreCourseGetRecentCoursesWSParams = {\n    userid?: number; // Id of the user, default to current user.\n    limit?: number; // Result set limit.\n    offset?: number; // Result set offset.\n    sort?: string; // Sort string.\n};\n\n/**\n * Options for getRecentCourses.\n */\nexport type CoreCourseGetRecentCoursesOptions = CoreSitesCommonWSOptions & {\n    userId?: number; // Id of the user, default to current user.\n    limit?: number; // Result set limit.\n    offset?: number; // Result set offset.\n    sort?: string; // Sort string.\n};\n\n/**\n * Params of core_course_set_favourite_courses WS.\n */\ntype CoreCourseSetFavouriteCoursesWSParams = {\n    courses: {\n        id: number; // Course ID.\n        favourite: boolean; // Favourite status.\n    }[];\n};\n\n/**\n * Any of the possible course data.\n */\nexport type CoreCourseAnyCourseData = CoreEnrolledCourseData | CoreCourseSearchedData | CoreCourseGetCoursesData;\n\n/**\n * Course data with admin and navigation option availability.\n */\nexport type CoreCourseAnyCourseDataWithOptions = CoreCourseAnyCourseData & {\n    navOptions?: CoreCourseUserAdminOrNavOptionIndexed;\n    admOptions?: CoreCourseUserAdminOrNavOptionIndexed;\n};\n\n/**\n * Params of core_my_view_page WS.\n */\ntype CoreMyViewPageWSParams = {\n    page: 'my' | 'dashboard'; // My page to trigger a view event.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}