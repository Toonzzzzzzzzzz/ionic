{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreNetwork } from '@services/network';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreGroups } from '@services/groups';\nimport { CoreLocalNotifications } from '@services/local-notifications';\nimport { CoreConfig } from '@services/config';\nimport { AddonCalendarOffline } from './calendar-offline';\nimport { CoreUser } from '@features/user/services/user';\nimport moment from 'moment-timezone';\nimport { EVENTS_TABLE } from './database/calendar';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { ApplicationInit, makeSingleton, Translate } from '@singletons';\nimport { AddonCalendarMainMenuHandlerService } from './handlers/mainmenu';\nimport { CoreNavigator } from '@services/navigator';\nimport { AddonCalendarSyncProvider } from './calendar-sync';\nimport { CorePath } from '@singletons/path';\nimport { CorePlatform } from '@services/platform';\nimport { CoreReminders, CoreRemindersService } from '@features/reminders/services/reminders';\nimport { CoreEvents } from '@singletons/events';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaCalendar:';\n/**\n * Main calendar Event types enumeration.\n */\nexport var AddonCalendarEventType;\n(function (AddonCalendarEventType) {\n  AddonCalendarEventType[\"SITE\"] = \"site\";\n  AddonCalendarEventType[\"CATEGORY\"] = \"category\";\n  AddonCalendarEventType[\"COURSE\"] = \"course\";\n  AddonCalendarEventType[\"GROUP\"] = \"group\";\n  AddonCalendarEventType[\"USER\"] = \"user\";\n})(AddonCalendarEventType || (AddonCalendarEventType = {}));\n/**\n * Units to set a reminder.\n *\n * @deprecated since 4.1 Use CoreReminderUnits instead.\n */\nexport var AddonCalendarReminderUnits;\n(function (AddonCalendarReminderUnits) {\n  AddonCalendarReminderUnits[AddonCalendarReminderUnits[\"MINUTE\"] = CoreConstants.SECONDS_MINUTE] = \"MINUTE\";\n  AddonCalendarReminderUnits[AddonCalendarReminderUnits[\"HOUR\"] = CoreConstants.SECONDS_HOUR] = \"HOUR\";\n  AddonCalendarReminderUnits[AddonCalendarReminderUnits[\"DAY\"] = CoreConstants.SECONDS_DAY] = \"DAY\";\n  AddonCalendarReminderUnits[AddonCalendarReminderUnits[\"WEEK\"] = CoreConstants.SECONDS_WEEK] = \"WEEK\";\n})(AddonCalendarReminderUnits || (AddonCalendarReminderUnits = {}));\n/**\n * Service to handle calendar events.\n */\nexport class AddonCalendarProvider {\n  constructor() {\n    this.weekDays = [{\n      shortname: 'addon.calendar.sun',\n      fullname: 'addon.calendar.sunday'\n    }, {\n      shortname: 'addon.calendar.mon',\n      fullname: 'addon.calendar.monday'\n    }, {\n      shortname: 'addon.calendar.tue',\n      fullname: 'addon.calendar.tuesday'\n    }, {\n      shortname: 'addon.calendar.wed',\n      fullname: 'addon.calendar.wednesday'\n    }, {\n      shortname: 'addon.calendar.thu',\n      fullname: 'addon.calendar.thursday'\n    }, {\n      shortname: 'addon.calendar.fri',\n      fullname: 'addon.calendar.friday'\n    }, {\n      shortname: 'addon.calendar.sat',\n      fullname: 'addon.calendar.saturday'\n    }];\n  }\n  // Calendar time in 12 hours format.\n  /**\n   * Check if a certain site allows creating and editing events.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if can create/edit.\n   * @since 3.7.1\n   */\n  canEditEvents(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const site = yield CoreSites.getSite(siteId);\n        return _this.canEditEventsInSite(site);\n      } catch (_unused) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Check if a certain site allows creating and editing events.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether events can be created and edited.\n   * @since 3.7.1\n   */\n  canEditEventsInSite(site) {\n    var _site;\n    site = site || CoreSites.getCurrentSite();\n    // The WS to create/edit events requires a fix that was integrated in 3.7.1.\n    return !!((_site = site) !== null && _site !== void 0 && _site.isVersionGreaterEqualThan('3.7.1'));\n  }\n  /**\n   * Given a number of seconds, convert it to a unit&value format compatible with reminders.\n   *\n   * @param seconds Number of seconds.\n   * @returns Value and unit.\n   * @deprecated since 4.1 Use CoreRemindersService.convertSecondsToValueAndUnit instead.\n   */\n  static convertSecondsToValueAndUnit(seconds) {\n    return CoreRemindersService.convertSecondsToValueAndUnit(seconds);\n  }\n  /**\n   * Delete an event.\n   *\n   * @param eventId Event ID to delete.\n   * @param name Name of the event to delete.\n   * @param deleteAll If it's a repeated event. whether to delete all events of the series.\n   * @param forceOffline True to always save it in offline.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteEvent(eventId, name, deleteAll = false, forceOffline = false, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Function to store the submission to be synchronized later.\n      const storeOffline = () => AddonCalendarOffline.markDeleted(eventId, name, deleteAll, siteId).then(() => false);\n      if (forceOffline || !CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      // If the event is already stored, discard it first.\n      yield AddonCalendarOffline.unmarkDeleted(eventId, siteId);\n      try {\n        yield _this2.deleteEventOnline(eventId, deleteAll, siteId);\n        return true;\n      } catch (error) {\n        if (error && !CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server, store in offline.\n          return storeOffline();\n        } else {\n          // The WebService has thrown an error, reject.\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Delete an event. It will fail if offline or cannot connect.\n   *\n   * @param eventId Event ID to delete.\n   * @param deleteAll If it's a repeated event. whether to delete all events of the series.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteEventOnline(eventId, deleteAll = false, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        events: [{\n          eventid: eventId,\n          repeat: deleteAll\n        }]\n      };\n      const preSets = {\n        responseExpected: false\n      };\n      yield site.write('core_calendar_delete_calendar_events', params, preSets);\n    })();\n  }\n  /**\n   * Delete a locally stored event cancelling all the reminders and notifications.\n   *\n   * @param eventId Event ID.\n   * @param siteId ID of the site the event belongs to. If not defined, use current site.\n   * @returns Resolved when done.\n   */\n  deleteLocalEvent(eventId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      siteId = site.getId();\n      const promises = [];\n      promises.push(site.getDb().deleteRecords(EVENTS_TABLE, {\n        id: eventId\n      }));\n      promises.push(CoreReminders.removeReminders({\n        instanceId: eventId,\n        component: AddonCalendarProvider.COMPONENT\n      }, siteId));\n      yield CoreUtils.ignoreErrors(Promise.all(promises));\n    })();\n  }\n  /**\n   * Initialize the service.\n   *\n   * @returns Promise resolved when done.\n   */\n  initialize() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      CoreLocalNotifications.registerClick(AddonCalendarProvider.COMPONENT, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (notification) {\n          yield ApplicationInit.donePromise;\n          _this3.notificationClicked(notification);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      CoreEvents.on(CoreEvents.SITE_ADDED, data => {\n        if (!data.siteId) {\n          return;\n        }\n        _this3.updateSiteEventReminders(data.siteId);\n      });\n    })();\n  }\n  /**\n   * Notification has been clicked.\n   *\n   * @param notification Calendar notification.\n   * @returns Promise resolved when done.\n   */\n  notificationClicked(notification) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const disabled = yield _this4.isDisabled(notification.siteId);\n      if (disabled) {\n        // The calendar is disabled in the site, don't open it.\n        return;\n      }\n      CoreNavigator.navigateToSitePath(AddonCalendarMainMenuHandlerService.PAGE_NAME, {\n        siteId: notification.siteId,\n        preferCurrentTab: false,\n        nextNavigation: {\n          path: `calendar/event/${notification.instanceId}`,\n          isSitePath: true\n        }\n      });\n    })();\n  }\n  /**\n   * Format event time. Similar to calendar_format_event_time.\n   *\n   * @param event Event to format.\n   * @param format Calendar time format (from getCalendarTimeFormat).\n   * @param useCommonWords Whether to use common words like \"Today\", \"Yesterday\", etc.\n   * @param seenDay Timestamp of day currently seen. If set, the function will not add links to this day.\n   * @param showTime Determine the show time GMT timestamp.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the formatted event time.\n   */\n  formatEventTime(event, format, useCommonWords = true, seenDay, showTime = 0, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const getTimeHtml = (time, a11yLangKey) => `<span aria-label=\"${Translate.instant(a11yLangKey, {\n        $a: CoreTextUtils.cleanTags(time)\n      })}\">${time}</span>`;\n      const getStartTimeHtml = time => getTimeHtml(time, 'core.startingtime');\n      const getEndTimeHtml = time => getTimeHtml(time, 'core.endingtime');\n      const start = event.timestart * 1000;\n      const end = (event.timestart + event.timeduration) * 1000;\n      let time;\n      if (event.timeduration) {\n        if (moment(start).isSame(end, 'day')) {\n          // Event starts and ends the same day.\n          if (event.timeduration == CoreConstants.SECONDS_DAY) {\n            time = Translate.instant('addon.calendar.allday');\n          } else {\n            time = getStartTimeHtml(CoreTimeUtils.userDate(start, format)) + ' <strong>&raquo;</strong> ' + getEndTimeHtml(CoreTimeUtils.userDate(end, format));\n          }\n        } else {\n          // Event lasts more than one day.\n          const timeStart = CoreTimeUtils.userDate(start, format);\n          const timeEnd = CoreTimeUtils.userDate(end, format);\n          const promises = [];\n          // Don't use common words when the event lasts more than one day.\n          let dayStart = _this5.getDayRepresentation(start, false) + ', ';\n          let dayEnd = _this5.getDayRepresentation(end, false) + ', ';\n          // Add links to the days if needed.\n          if (dayStart && (!seenDay || !moment(seenDay).isSame(start, 'day'))) {\n            promises.push(_this5.getViewUrl('day', event.timestart, undefined, siteId).then(url => {\n              dayStart = CoreUrlUtils.buildLink(url, dayStart);\n              return;\n            }));\n          }\n          if (dayEnd && (!seenDay || !moment(seenDay).isSame(end, 'day'))) {\n            promises.push(_this5.getViewUrl('day', end / 1000, undefined, siteId).then(url => {\n              dayEnd = CoreUrlUtils.buildLink(url, dayEnd);\n              return;\n            }));\n          }\n          yield Promise.all(promises);\n          return getStartTimeHtml(dayStart + timeStart) + ' <strong>&raquo;</strong> ' + getEndTimeHtml(dayEnd + timeEnd);\n        }\n      } else {\n        // There is no time duration.\n        time = getStartTimeHtml(CoreTimeUtils.userDate(start, format));\n      }\n      if (showTime) {\n        return time;\n      }\n      // Display day + time.\n      if (seenDay && moment(seenDay).isSame(start, 'day')) {\n        // This day is currently being displayed, don't add an link.\n        return _this5.getDayRepresentation(start, useCommonWords) + ', ' + time;\n      }\n      // Add link to view the day.\n      const url = yield _this5.getViewUrl('day', event.timestart, undefined, siteId);\n      return CoreUrlUtils.buildLink(url, _this5.getDayRepresentation(start, useCommonWords)) + ', ' + time;\n    })();\n  }\n  /**\n   * Get access information for a calendar (either course calendar or site calendar).\n   *\n   * @param courseId Course ID. If not defined, site calendar.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with object with access information.\n   * @since 3.7\n   */\n  getAccessInformation(courseId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {};\n      const preSets = {\n        cacheKey: _this6.getAccessInformationCacheKey(courseId)\n      };\n      if (courseId) {\n        params.courseid = courseId;\n      }\n      return site.read('core_calendar_get_calendar_access_information', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for calendar access information WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getAccessInformationCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'accessInformation:' + (courseId || 0);\n  }\n  /**\n   * Get all calendar events from local Db.\n   *\n   * @param siteId ID of the site the event belongs to. If not defined, use current site.\n   * @returns Promise resolved with all the events.\n   */\n  getAllEventsFromLocalDb(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getAllRecords(EVENTS_TABLE);\n    })();\n  }\n  /**\n   * Get the type of events a user can create (either course calendar or site calendar).\n   *\n   * @param courseId Course ID. If not defined, site calendar.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with an object indicating the types.\n   * @since 3.7\n   */\n  getAllowedEventTypes(courseId, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {};\n      const preSets = {\n        cacheKey: _this7.getAllowedEventTypesCacheKey(courseId)\n      };\n      if (courseId) {\n        params.courseid = courseId;\n      }\n      const response = yield site.read('core_calendar_get_allowed_event_types', params, preSets);\n      // Convert the array to an object.\n      const result = {};\n      if (response.allowedeventtypes) {\n        response.allowedeventtypes.forEach(type => {\n          result[type] = true;\n        });\n      }\n      return result;\n    })();\n  }\n  /**\n   * Get cache key for calendar allowed event types WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getAllowedEventTypesCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'allowedEventTypes:' + (courseId || 0);\n  }\n  /**\n   * Get the \"look ahead\" for a certain user.\n   *\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolved with the look ahead (number of days).\n   */\n  getCalendarLookAhead(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      let value;\n      try {\n        value = yield CoreUser.getUserPreference('calendar_lookahead');\n      } catch (_unused2) {\n        // Ignore errors.\n      }\n      if (value === undefined || value === null) {\n        value = site.getStoredConfig('calendar_lookahead');\n      }\n      return parseInt(value, 10);\n    })();\n  }\n  /**\n   * Get the time format to use in calendar.\n   *\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolved with the format.\n   */\n  getCalendarTimeFormat(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      let format;\n      try {\n        format = yield CoreUser.getUserPreference('calendar_timeformat');\n      } catch (_unused3) {\n        // Ignore errors.\n      }\n      if (!format || format === '0') {\n        format = site.getStoredConfig('calendar_site_timeformat');\n      }\n      if (format === AddonCalendarProvider.CALENDAR_TF_12) {\n        format = Translate.instant('core.strftimetime12');\n      } else if (format === AddonCalendarProvider.CALENDAR_TF_24) {\n        format = Translate.instant('core.strftimetime24');\n      }\n      return format && format !== '0' ? format : Translate.instant('core.strftimetime');\n    })();\n  }\n  /**\n   * Return the representation day. Equivalent to Moodle's calendar_day_representation.\n   *\n   * @param time Timestamp to get the day from.\n   * @param useCommonWords Whether to use common words like \"Today\", \"Yesterday\", etc.\n   * @returns The formatted date/time.\n   */\n  getDayRepresentation(time, useCommonWords = true) {\n    if (!useCommonWords) {\n      // We don't want words, just a date.\n      return CoreTimeUtils.userDate(time, 'core.strftimedayshort');\n    }\n    const date = moment(time);\n    const today = moment();\n    if (date.isSame(today, 'day')) {\n      return Translate.instant('addon.calendar.today');\n    }\n    if (date.isSame(today.clone().subtract(1, 'days'), 'day')) {\n      return Translate.instant('addon.calendar.yesterday');\n    }\n    if (date.isSame(today.clone().add(1, 'days'), 'day')) {\n      return Translate.instant('addon.calendar.tomorrow');\n    }\n    return CoreTimeUtils.userDate(time, 'core.strftimedayshort');\n  }\n  /**\n   * Get the configured default notification time.\n   *\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolved with the default time (in seconds).\n   * @deprecated since 4.1 Use CoreReminders.getDefaultNotificationTime instead.\n   */\n  getDefaultNotificationTime(siteId) {\n    return _asyncToGenerator(function* () {\n      return CoreReminders.getDefaultNotificationTime(siteId);\n    })();\n  }\n  /**\n   * Get a calendar event. If the server request fails and data is not cached, try to get it from local DB.\n   *\n   * @param id Event ID.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolved when the event data is retrieved.\n   */\n  getEvent(id, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const preSets = {\n        cacheKey: _this8.getEventCacheKey(id),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      const params = {\n        options: {\n          userevents: false,\n          siteevents: false\n        },\n        events: {\n          eventids: [id]\n        }\n      };\n      try {\n        const response = yield site.read('core_calendar_get_calendar_events', params, preSets);\n        // The WebService returns all category events. Check the response to search for the event we want.\n        const event = response.events.find(e => e.id == id);\n        return event || _this8.getEventFromLocalDb(id);\n      } catch (_unused4) {\n        return _this8.getEventFromLocalDb(id);\n      }\n    })();\n  }\n  /**\n   * Get a calendar event by ID. This function returns more data than getEvent, but it isn't available in all Moodles.\n   *\n   * @param id Event ID.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolved when the event data is retrieved.\n   */\n  getEventById(id, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const preSets = {\n        cacheKey: _this9.getEventCacheKey(id),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      const params = {\n        eventid: id\n      };\n      try {\n        const response = yield site.read('core_calendar_get_calendar_event_by_id', params, preSets);\n        _this9.updateLocalEvents([response.event], {\n          siteId\n        });\n        return response.event;\n      } catch (error) {\n        try {\n          return yield _this9.getEventFromLocalDb(id);\n        } catch (_unused5) {\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Get cache key for a single event WS call.\n   *\n   * @param id Event ID.\n   * @returns Cache key.\n   */\n  getEventCacheKey(id) {\n    return ROOT_CACHE_KEY + 'events:' + id;\n  }\n  /**\n   * Get a calendar event from local Db.\n   *\n   * @param id Event ID.\n   * @param siteId ID of the site the event belongs to. If not defined, use current site.\n   * @returns Promise resolved when the event data is retrieved.\n   */\n  getEventFromLocalDb(id, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const record = yield site.getDb().getRecord(EVENTS_TABLE, {\n        id: id\n      });\n      const eventConverted = record;\n      const originalEvent = record;\n      const recordAsRecord = record;\n      // Calculate data to match the new WS.\n      eventConverted.descriptionformat = originalEvent.format;\n      eventConverted.iscourseevent = originalEvent.eventtype == AddonCalendarEventType.COURSE;\n      eventConverted.iscategoryevent = originalEvent.eventtype == AddonCalendarEventType.CATEGORY;\n      eventConverted.normalisedeventtype = _this10.getEventType(recordAsRecord);\n      try {\n        eventConverted.category = CoreTextUtils.parseJSON(recordAsRecord.category || '');\n      } catch (_unused6) {\n        // Ignore errors.\n      }\n      try {\n        eventConverted.course = CoreTextUtils.parseJSON(recordAsRecord.course || '');\n      } catch (_unused7) {\n        // Ignore errors.\n      }\n      try {\n        eventConverted.subscription = CoreTextUtils.parseJSON(recordAsRecord.subscription || '');\n      } catch (_unused8) {\n        // Ignore errors.\n      }\n      return eventConverted;\n    })();\n  }\n  /**\n   * Adds an event reminder and schedule a new notification.\n   *\n   * @param event Event to set the reminder.\n   * @param timebefore Amount of seconds of the reminder. Undefined for default reminder.\n   * @param siteId ID of the site the event belongs to. If not defined, use current site.\n   * @returns Promise resolved when the notification is updated.\n   */\n  addEventReminder(event, timebefore, siteId) {\n    return _asyncToGenerator(function* () {\n      var _timebefore;\n      timebefore = (_timebefore = timebefore) !== null && _timebefore !== void 0 ? _timebefore : CoreRemindersService.DEFAULT_REMINDER_TIMEBEFORE;\n      const previousReminders = yield CoreReminders.getReminders({\n        instanceId: event.id,\n        component: AddonCalendarProvider.COMPONENT\n      }, siteId);\n      if (previousReminders.some(reminder => reminder.timebefore === timebefore)) {\n        // Already exists.\n        return;\n      }\n      const url = 'url' in event ? event.url || '' : '';\n      const reminder = {\n        component: AddonCalendarProvider.COMPONENT,\n        instanceId: event.id,\n        type: event.eventtype,\n        time: event.timestart,\n        timebefore,\n        title: event.name,\n        url\n      };\n      yield CoreReminders.addReminder(reminder, siteId);\n    })();\n  }\n  /**\n   * Return the normalised event type.\n   * Activity events are normalised to be course events.\n   *\n   * @param event The event to get its type.\n   * @returns Event type.\n   */\n  getEventType(event) {\n    if (event.modulename) {\n      return 'course';\n    }\n    return event.eventtype;\n  }\n  /**\n   * Remove an event reminder and cancel the notification.\n   *\n   * @param id Reminder ID.\n   * @param siteId ID of the site the event belongs to. If not defined, use current site.\n   * @returns Promise resolved when the notification is updated.\n   * @deprecated since 4.1. Use CoreReminders.removeReminder instead.\n   */\n  deleteEventReminder(id, siteId) {\n    return _asyncToGenerator(function* () {\n      yield CoreReminders.removeReminder(id, siteId);\n    })();\n  }\n  /**\n   * Get calendar events for a certain day.\n   *\n   * @param year Year to get.\n   * @param month Month to get.\n   * @param day Day to get.\n   * @param courseId Course to get.\n   * @param categoryId Category to get.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the response.\n   */\n  getDayEvents(year, month, day, courseId, categoryId, ignoreCache = false, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        year: year,\n        month: month,\n        day: day\n      };\n      if (courseId) {\n        params.courseid = courseId;\n      }\n      if (categoryId) {\n        params.categoryid = categoryId;\n      }\n      const preSets = {\n        cacheKey: _this11.getDayEventsCacheKey(year, month, day, courseId, categoryId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const response = yield site.read('core_calendar_get_calendar_day_view', params, preSets);\n      _this11.updateLocalEvents(response.events, {\n        siteId\n      });\n      return response;\n    })();\n  }\n  /**\n   * Get prefix cache key for day events WS calls.\n   *\n   * @returns Prefix Cache key.\n   */\n  getDayEventsPrefixCacheKey() {\n    return ROOT_CACHE_KEY + 'day:';\n  }\n  /**\n   * Get prefix cache key for a certain day for day events WS calls.\n   *\n   * @param year Year to get.\n   * @param month Month to get.\n   * @param day Day to get.\n   * @returns Prefix Cache key.\n   */\n  getDayEventsDayPrefixCacheKey(year, month, day) {\n    return this.getDayEventsPrefixCacheKey() + year + ':' + month + ':' + day + ':';\n  }\n  /**\n   * Get cache key for day events WS calls.\n   *\n   * @param year Year to get.\n   * @param month Month to get.\n   * @param day Day to get.\n   * @param courseId Course to get.\n   * @param categoryId Category to get.\n   * @returns Cache key.\n   */\n  getDayEventsCacheKey(year, month, day, courseId, categoryId) {\n    return this.getDayEventsDayPrefixCacheKey(year, month, day) + (courseId ? courseId : '') + ':' + (categoryId ? categoryId : '');\n  }\n  /**\n   * Get a calendar reminders from local Db.\n   *\n   * @param eventId Event ID.\n   * @param siteId ID of the site the event belongs to. If not defined, use current site.\n   * @returns Promise resolved when the event data is retrieved.\n   * @deprecated since 4.1. Use CoreReminders.getReminders instead.\n   */\n  getEventReminders(eventId, siteId) {\n    return _asyncToGenerator(function* () {\n      return CoreReminders.getReminders({\n        instanceId: eventId,\n        component: AddonCalendarProvider.COMPONENT\n      }, siteId);\n    })();\n  }\n  /**\n   * Get the events in a certain period. The period is calculated like this:\n   *     start time: now + daysToStart\n   *     end time: start time + daysInterval\n   * E.g. using provider.getEventsList(undefined, 30, 30) is going to get the events starting after 30 days from now\n   * and ending before 60 days from now.\n   *\n   * @param initialTime Timestamp when the first fetch was done. If not defined, current time.\n   * @param daysToStart Number of days from now to start getting events.\n   * @param daysInterval Number of days between timestart and timeend.\n   * @param siteId Site to get the events from. If not defined, use current site.\n   * @returns Promise to be resolved when the events are retrieved.\n   */\n  getEventsList(initialTime, daysToStart = 0, daysInterval = AddonCalendarProvider.DAYS_INTERVAL, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      initialTime = initialTime || CoreTimeUtils.timestamp();\n      const site = yield CoreSites.getSite(siteId);\n      siteId = site.getId();\n      const start = initialTime + CoreConstants.SECONDS_DAY * daysToStart;\n      const end = start + CoreConstants.SECONDS_DAY * daysInterval - 1;\n      const events = {\n        courseids: [],\n        groupids: []\n      };\n      const params = {\n        options: {\n          userevents: true,\n          siteevents: true,\n          timestart: start,\n          timeend: end\n        },\n        events: events\n      };\n      const promises = [];\n      promises.push(CoreCourses.getUserCourses(false, siteId).then(courses => {\n        events.courseids = courses.map(course => course.id);\n        events.courseids.push(site.getSiteHomeId()); // Add front page.\n        return;\n      }));\n      promises.push(CoreGroups.getAllUserGroups(siteId).then(groups => {\n        events.groupids = groups.map(group => group.id);\n        return;\n      }));\n      yield Promise.all(promises);\n      // We need to retrieve cached data using cache key because we have timestamp in the params.\n      const preSets = {\n        cacheKey: _this12.getEventsListCacheKey(daysToStart, daysInterval),\n        getCacheUsingCacheKey: true,\n        uniqueCacheKey: true,\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      const response = yield site.read('core_calendar_get_calendar_events', params, preSets);\n      _this12.updateLocalEvents(response.events, {\n        siteId\n      });\n      return response.events;\n    })();\n  }\n  /**\n   * Get prefix cache key for events list WS calls.\n   *\n   * @returns Prefix Cache key.\n   */\n  getEventsListPrefixCacheKey() {\n    return ROOT_CACHE_KEY + 'events:';\n  }\n  /**\n   * Get cache key for events list WS calls.\n   *\n   * @param daysToStart Number of days from now to start getting events.\n   * @param daysInterval Number of days between timestart and timeend.\n   * @returns Cache key.\n   */\n  getEventsListCacheKey(daysToStart, daysInterval) {\n    return this.getEventsListPrefixCacheKey() + daysToStart + ':' + daysInterval;\n  }\n  /**\n   * Get calendar events from local Db that have the same repeatid.\n   *\n   * @param repeatId Repeat Id of the event.\n   * @param siteId ID of the site the event belongs to. If not defined, use current site.\n   * @returns Promise resolved with all the events.\n   */\n  getLocalEventsByRepeatIdFromLocalDb(repeatId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecords(EVENTS_TABLE, {\n        repeatid: repeatId\n      });\n    })();\n  }\n  /**\n   * Get monthly calendar events.\n   *\n   * @param year Year to get.\n   * @param month Month to get.\n   * @param courseId Course to get.\n   * @param categoryId Category to get.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the response.\n   */\n  getMonthlyEvents(year, month, courseId, categoryId, ignoreCache = false, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        year: year,\n        month: month,\n        mini: true // Set mini to 1 to prevent returning the course selector HTML.\n      };\n\n      if (courseId) {\n        params.courseid = courseId;\n      }\n      if (categoryId) {\n        params.categoryid = categoryId;\n      }\n      const preSets = {\n        cacheKey: _this13.getMonthlyEventsCacheKey(year, month, courseId, categoryId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const response = yield site.read('core_calendar_get_calendar_monthly_view', params, preSets);\n      response.weeks.forEach(week => {\n        week.days.forEach(day => {\n          _this13.updateLocalEvents(day.events, {\n            siteId\n          });\n        });\n      });\n      // Store starting week day preference, we need it in offline to show months that are not in cache.\n      if (CoreNetwork.isOnline()) {\n        CoreConfig.set(AddonCalendarProvider.STARTING_WEEK_DAY, response.daynames[0].dayno);\n      }\n      return response;\n    })();\n  }\n  /**\n   * Get prefix cache key for monthly events WS calls.\n   *\n   * @returns Prefix Cache key.\n   */\n  getMonthlyEventsPrefixCacheKey() {\n    return ROOT_CACHE_KEY + 'monthly:';\n  }\n  /**\n   * Get prefix cache key for a certain month for monthly events WS calls.\n   *\n   * @param year Year to get.\n   * @param month Month to get.\n   * @returns Prefix Cache key.\n   */\n  getMonthlyEventsMonthPrefixCacheKey(year, month) {\n    return this.getMonthlyEventsPrefixCacheKey() + year + ':' + month + ':';\n  }\n  /**\n   * Get cache key for monthly events WS calls.\n   *\n   * @param year Year to get.\n   * @param month Month to get.\n   * @param courseId Course to get.\n   * @param categoryId Category to get.\n   * @returns Cache key.\n   */\n  getMonthlyEventsCacheKey(year, month, courseId, categoryId) {\n    return this.getMonthlyEventsMonthPrefixCacheKey(year, month) + (courseId ? courseId : '') + ':' + (categoryId ? categoryId : '');\n  }\n  /**\n   * Given a value and a unit, return the translated label.\n   *\n   * @param value Value.\n   * @param unit Unit.\n   * @param addDefaultLabel Whether to add the \"Default\" text.\n   * @returns Translated label.\n   * @deprecated since 4.1 Use CoreReminders.getUnitValueLabel instead.\n   */\n  getUnitValueLabel(value, unit, addDefaultLabel = false) {\n    return CoreReminders.getUnitValueLabel(value, unit, addDefaultLabel);\n  }\n  /**\n   * Get upcoming calendar events.\n   *\n   * @param courseId Course to get.\n   * @param categoryId Category to get.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the response.\n   */\n  getUpcomingEvents(courseId, categoryId, ignoreCache = false, siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {};\n      if (courseId) {\n        params.courseid = courseId;\n      }\n      if (categoryId) {\n        params.categoryid = categoryId;\n      }\n      const preSets = {\n        cacheKey: _this14.getUpcomingEventsCacheKey(courseId, categoryId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const response = yield site.read('core_calendar_get_calendar_upcoming_view', params, preSets);\n      _this14.updateLocalEvents(response.events, {\n        siteId\n      });\n      return response;\n    })();\n  }\n  /**\n   * Get prefix cache key for upcoming events WS calls.\n   *\n   * @returns Prefix Cache key.\n   */\n  getUpcomingEventsPrefixCacheKey() {\n    return ROOT_CACHE_KEY + 'upcoming:';\n  }\n  /**\n   * Get cache key for upcoming events WS calls.\n   *\n   * @param courseId Course to get.\n   * @param categoryId Category to get.\n   * @returns Cache key.\n   */\n  getUpcomingEventsCacheKey(courseId, categoryId) {\n    return this.getUpcomingEventsPrefixCacheKey() + (courseId ? courseId : '') + ':' + (categoryId ? categoryId : '');\n  }\n  /**\n   * Get URL to view a calendar.\n   *\n   * @param view The view to load: 'month', 'day', 'upcoming', etc.\n   * @param time Time to load. If not defined, current time.\n   * @param courseId Course to load. If not defined, all courses.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the URL.x\n   */\n  getViewUrl(view, time, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      let url = CorePath.concatenatePaths(site.getURL(), 'calendar/view.php?view=' + view);\n      if (time) {\n        url += '&time=' + time;\n      }\n      if (courseId) {\n        url += '&course=' + courseId;\n      }\n      return url;\n    })();\n  }\n  /**\n   * Get the week days, already ordered according to a specified starting day.\n   *\n   * @param startingDay Starting day. 0=Sunday, 1=Monday, ...\n   * @returns Week days.\n   */\n  getWeekDays(startingDay) {\n    startingDay = startingDay || 0;\n    return this.weekDays.slice(startingDay).concat(this.weekDays.slice(0, startingDay));\n  }\n  /**\n   * Invalidates access information.\n   *\n   * @param courseId Course ID. If not defined, site calendar.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAccessInformation(courseId, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this15.getAccessInformationCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidates allowed event types.\n   *\n   * @param courseId Course ID. If not defined, site calendar.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllowedEventTypes(courseId, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this16.getAllowedEventTypesCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidates day events for all days.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllDayEvents(siteId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this17.getDayEventsPrefixCacheKey());\n    })();\n  }\n  /**\n   * Invalidates day events for a certain day.\n   *\n   * @param year Year.\n   * @param month Month.\n   * @param day Day.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateDayEvents(year, month, day, siteId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this18.getDayEventsDayPrefixCacheKey(year, month, day));\n    })();\n  }\n  /**\n   * Invalidates events list and all the single events and related info.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the list is invalidated.\n   */\n  invalidateEventsList(siteId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      siteId = site.getId();\n      const promises = [];\n      promises.push(CoreCourses.invalidateUserCourses(siteId));\n      promises.push(CoreGroups.invalidateAllUserGroups(siteId));\n      promises.push(site.invalidateWsCacheForKeyStartingWith(_this19.getEventsListPrefixCacheKey()));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidates a single event.\n   *\n   * @param eventId List of courses or course ids.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the list is invalidated.\n   */\n  invalidateEvent(eventId, siteId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this20.getEventCacheKey(eventId));\n    })();\n  }\n  /**\n   * Invalidates monthly events for all months.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllMonthlyEvents(siteId) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this21.getMonthlyEventsPrefixCacheKey());\n    })();\n  }\n  /**\n   * Invalidates monthly events for a certain months.\n   *\n   * @param year Year.\n   * @param month Month.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateMonthlyEvents(year, month, siteId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this22.getMonthlyEventsMonthPrefixCacheKey(year, month));\n    })();\n  }\n  /**\n   * Invalidates upcoming events for all courses and categories.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllUpcomingEvents(siteId) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this23.getUpcomingEventsPrefixCacheKey());\n    })();\n  }\n  /**\n   * Invalidates upcoming events for a certain course or category.\n   *\n   * @param courseId Course ID.\n   * @param categoryId Category ID.\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUpcomingEvents(courseId, categoryId, siteId) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this24.getUpcomingEventsCacheKey(courseId, categoryId));\n    })();\n  }\n  /**\n   * Invalidates look ahead setting.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateLookAhead(siteId) {\n    return _asyncToGenerator(function* () {\n      yield CoreUser.invalidateUserPreference('calendar_lookahead', siteId);\n    })();\n  }\n  /**\n   * Invalidates time format setting.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateTimeFormat(siteId) {\n    return CoreUser.invalidateUserPreference('calendar_timeformat', siteId);\n  }\n  /**\n   * Check if Calendar is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether it's disabled.\n   */\n  isCalendarDisabledInSite(site) {\n    var _site2;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site2 = site) !== null && _site2 !== void 0 && _site2.isFeatureDisabled('CoreMainMenuDelegate_AddonCalendar'));\n  }\n  /**\n   * Check if Calendar is disabled in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n   */\n  isDisabled(siteId) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this25.isCalendarDisabledInSite(site);\n    })();\n  }\n  /**\n   * Get the next events for all the sites and schedules their notifications.\n   *\n   * @returns Promise resolved when done.\n   * @deprecated since 4.1 Use AddonCalendar.updateAllSitesEventReminders.\n   */\n  scheduleAllSitesEventsNotifications() {\n    return _asyncToGenerator(function* () {\n      yield AddonCalendar.updateAllSitesEventReminders();\n    })();\n  }\n  /**\n   * Get the next events for all the sites and updates their reminders.\n   */\n  updateAllSitesEventReminders() {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      yield CorePlatform.ready();\n      const siteIds = yield CoreSites.getSitesIds();\n      yield Promise.all(siteIds.map(siteId => _this26.updateSiteEventReminders(siteId)));\n    })();\n  }\n  /**\n   * Get the next events for a site and updates their reminders.\n   *\n   * @param siteId Site ID.\n   */\n  updateSiteEventReminders(siteId) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      // Check if calendar is disabled for the site.\n      const disabled = yield _this27.isDisabled(siteId);\n      if (disabled) {\n        return;\n      }\n      // Get first events to store/update them in local database and update their reminders.\n      yield _this27.getEventsList(undefined, undefined, undefined, siteId);\n    })();\n  }\n  /**\n   * Get the next events for all the sites and schedules their notifications.\n   *\n   * @returns Promise resolved when done.\n   * @deprecated since 4.1. No replacement for that function.\n   */\n  scheduleEventsNotifications(events, siteId) {\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield AddonCalendar.updateEventsReminders(events, siteId);\n    })();\n  }\n  /**\n   * Schedules the notifications for a list of events.\n   * If an event notification time is 0, cancel its scheduled notification (if any).\n   * If local notification plugin is not enabled, resolve the promise.\n   *\n   * @param events Events to schedule.\n   * @param siteId ID of the site the events belong to.\n   * @returns Promise resolved when all the notifications have been scheduled.\n   */\n  updateEventsReminders(events, siteId) {\n    return _asyncToGenerator(function* () {\n      yield Promise.all(events.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (event) {\n          if (event.timestart * 1000 <= Date.now()) {\n            // The event has already started, don't schedule it.\n            // @TODO Decide when to completelly remove expired events.\n            return CoreReminders.cancelReminder(event.id, AddonCalendarProvider.COMPONENT, siteId);\n          }\n          const reminders = yield CoreReminders.getReminders({\n            instanceId: event.id,\n            component: AddonCalendarProvider.COMPONENT\n          }, siteId);\n          yield Promise.all(reminders.map( /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(function* (reminder) {\n              if (reminder.time !== event.timestart || reminder.title !== event.name) {\n                reminder.time = event.timestart;\n                reminder.title = event.name;\n                CoreReminders.updateReminder(reminder, siteId);\n              }\n            });\n            return function (_x3) {\n              return _ref3.apply(this, arguments);\n            };\n          }()));\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Set the default notification time.\n   *\n   * @param time New default time.\n   * @param siteId ID of the site. If not defined, use current site.\n   * @returns Promise resolved when stored.\n   * @deprecated since 4.1 Use CoreReminders.setDefaultNotificationTime.\n   */\n  setDefaultNotificationTime(time, siteId) {\n    return _asyncToGenerator(function* () {\n      yield CoreReminders.setDefaultNotificationTime(time, siteId);\n    })();\n  }\n  /**\n   * Store an event in local DB as it is.\n   *\n   * @param event Event to store.\n   * @param options Options.\n   * @returns Promise resolved when stored.\n   */\n  storeEventInLocalDb(event, options = {}) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      var _options$addDefaultRe;\n      const site = yield CoreSites.getSite(options.siteId);\n      const addDefaultReminder = (_options$addDefaultRe = options.addDefaultReminder) !== null && _options$addDefaultRe !== void 0 ? _options$addDefaultRe : true;\n      // Don't store data that can be calculated like formattedtime, iscategoryevent, etc.\n      let eventRecord = {\n        id: event.id,\n        name: event.name,\n        description: event.description || '',\n        eventtype: event.eventtype,\n        timestart: event.timestart,\n        timeduration: event.timeduration,\n        categoryid: event.categoryid,\n        groupid: event.groupid,\n        userid: event.userid,\n        instance: event.instance,\n        modulename: event.modulename,\n        timemodified: event.timemodified,\n        repeatid: event.repeatid,\n        visible: event.visible\n      };\n      if ('descriptionformat' in event) {\n        var _event$course;\n        eventRecord = Object.assign(eventRecord, {\n          courseid: (_event$course = event.course) === null || _event$course === void 0 ? void 0 : _event$course.id,\n          location: event.location,\n          eventcount: event.eventcount,\n          timesort: event.timesort,\n          category: event.category ? JSON.stringify(event.category) : undefined,\n          course: event.course ? JSON.stringify(event.course) : undefined,\n          subscription: event.subscription ? JSON.stringify(event.subscription) : undefined,\n          canedit: event.canedit ? 1 : 0,\n          candelete: event.candelete ? 1 : 0,\n          deleteurl: event.deleteurl,\n          editurl: event.editurl,\n          viewurl: event.viewurl,\n          isactionevent: event.isactionevent ? 1 : 0,\n          url: event.url\n        });\n        if ('islastday' in event) {\n          eventRecord = Object.assign(eventRecord, {\n            islastday: event.islastday ? 1 : 0,\n            popupname: event.popupname,\n            mindaytimestamp: event.mindaytimestamp,\n            maxdaytimestamp: event.maxdaytimestamp,\n            draggable: event.draggable ? 1 : 0\n          });\n        }\n      } else if ('uuid' in event) {\n        eventRecord = Object.assign(eventRecord, {\n          courseid: event.courseid,\n          uuid: event.uuid,\n          sequence: event.sequence,\n          subscriptionid: event.subscriptionid\n        });\n      }\n      if (addDefaultReminder) {\n        yield _this28.addDefaultEventReminder(eventRecord, site.getId());\n      }\n      yield site.getDb().insertRecord(EVENTS_TABLE, eventRecord);\n    })();\n  }\n  /**\n   * Adds the default event reminder.\n   *\n   * @param event Event to add the reminder to.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  addDefaultEventReminder(event, siteId) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      // Add default reminder if the event isn't stored already and doesn't have any reminder.\n      const eventExist = yield CoreUtils.promiseWorks(_this29.getEventFromLocalDb(event.id, siteId));\n      if (eventExist) {\n        return;\n      }\n      const reminders = yield CoreReminders.getReminders({\n        instanceId: event.id,\n        component: AddonCalendarProvider.COMPONENT\n      }, siteId);\n      if (reminders.length > 0) {\n        // It already has reminders.\n        return;\n      }\n      // No reminders, create the default one.\n      yield _this29.addEventReminder(event, undefined, siteId);\n    })();\n  }\n  /**\n   * Store events in local DB.\n   *\n   * @param events Events to store.\n   * @param options Options.\n   * @returns Promise resolved when the events are stored.\n   */\n  storeEventsInLocalDB(events, options = {}) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all(events.map(event => _this30.storeEventInLocalDb(event, options)));\n    })();\n  }\n  /**\n   * Update local events, storing them in DB and also updating their reminders.\n   *\n   * @param events Events to store or update.\n   * @param options Options.\n   */\n  updateLocalEvents(events, options = {}) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      yield _this31.storeEventsInLocalDB(events, options);\n      yield _this31.updateEventsReminders(events, options.siteId);\n    })();\n  }\n  /**\n   * Submit a calendar event.\n   *\n   * @param eventId ID of the event. Negative value to edit offline event. If undefined/null, create a new event.\n   * @param formData Form data.\n   * @param options Calendar submit event options.\n   * @returns Promise resolved with the event and a boolean indicating if data was sent to server or stored in offline.\n   */\n  submitEvent(eventId, formData, options = {}) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      const siteId = options.siteId || CoreSites.getCurrentSiteId();\n      // Function to store the event to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* () {\n          var _options$reminders;\n          const event = yield AddonCalendarOffline.saveEvent(eventId, formData, siteId);\n          // Now save the reminders if any.\n          if ((_options$reminders = options.reminders) !== null && _options$reminders !== void 0 && _options$reminders.length) {\n            yield CoreUtils.ignoreErrors(Promise.all(options.reminders.map(reminder => _this32.addEventReminder(event, reminder.time, siteId))));\n          }\n          return {\n            sent: false,\n            event\n          };\n        });\n        return function storeOffline() {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n      if (options.forceOffline || !CoreNetwork.isOnline()) {\n        // App is offline, store the event.\n        return storeOffline();\n      }\n      if (eventId) {\n        // If the event is already stored, discard it first.\n        yield AddonCalendarOffline.deleteEvent(eventId, siteId);\n      }\n      try {\n        var _options$reminders2;\n        const event = yield _this32.submitEventOnline(eventId, formData, siteId);\n        // Now save the reminders if any.\n        if ((_options$reminders2 = options.reminders) !== null && _options$reminders2 !== void 0 && _options$reminders2.length) {\n          yield CoreUtils.ignoreErrors(Promise.all(options.reminders.map(reminder => _this32.addEventReminder(event, reminder.time, siteId))));\n        }\n        return {\n          sent: true,\n          event\n        };\n      } catch (error) {\n        if (error && !CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server, store in offline.\n          return storeOffline();\n        } else {\n          // The WebService has thrown an error, reject.\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Submit an event, either to create it or to edit it. It will fail if offline or cannot connect.\n   *\n   * @param eventId ID of the event. If undefined/null or negative number, create a new event.\n   * @param formData Form data.\n   * @param siteId Site ID. If not provided, current site.\n   * @returns Promise resolved when done.\n   */\n  submitEventOnline(eventId = 0, formData, siteId) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      siteId = site.getId();\n      // Add data that is \"hidden\" in web.\n      formData.id = eventId > 0 ? eventId : 0;\n      formData.userid = site.getUserId();\n      formData.visible = 1;\n      formData.instance = 0;\n      if (eventId > 0) {\n        formData['_qf__core_calendar_local_event_forms_update'] = 1;\n      } else {\n        formData['_qf__core_calendar_local_event_forms_create'] = 1;\n      }\n      const params = {\n        formdata: CoreUtils.objectToGetParams(formData)\n      };\n      const result = yield site.write('core_calendar_submit_create_update_form', params);\n      if (result.validationerror || !result.event) {\n        // Simulate a WS error.\n        throw new CoreWSError({\n          message: Translate.instant('core.invalidformdata'),\n          errorcode: 'validationerror'\n        });\n      }\n      if (eventId < 0) {\n        // Offline event has been sent. Change reminders instanceId if any.\n        yield CoreUtils.ignoreErrors(CoreReminders.updateReminders({\n          instanceId: result.event.id\n        }, {\n          instanceId: eventId,\n          component: AddonCalendarProvider.COMPONENT\n        }, siteId));\n      }\n      if (formData.id === 0) {\n        // Store the new event in local DB.\n        yield CoreUtils.ignoreErrors(_this33.storeEventInLocalDb(result.event, {\n          addDefaultReminder: false,\n          siteId\n        }));\n      }\n      return result.event;\n    })();\n  }\n}\n_class = AddonCalendarProvider;\n_class.DAYS_INTERVAL = 30;\n_class.COMPONENT = 'AddonCalendarEvents';\n_class.STARTING_WEEK_DAY = 'addon_calendar_starting_week_day';\n_class.NEW_EVENT_EVENT = 'addon_calendar_new_event';\n_class.NEW_EVENT_DISCARDED_EVENT = 'addon_calendar_new_event_discarded';\n_class.EDIT_EVENT_EVENT = 'addon_calendar_edit_event';\n_class.DELETED_EVENT_EVENT = 'addon_calendar_deleted_event';\n_class.UNDELETED_EVENT_EVENT = 'addon_calendar_undeleted_event';\n_class.FILTER_CHANGED_EVENT = 'addon_calendar_filter_changed_event';\n_class.CALENDAR_TF_24 = '%H:%M';\n// Calendar time in 24 hours format.\n_class.CALENDAR_TF_12 = '%I:%M %p';\n_class.ɵfac = function AddonCalendarProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonCalendar = makeSingleton(AddonCalendarProvider);","map":{"version":3,"names":["CoreSites","CoreSite","CoreNetwork","CoreTextUtils","CoreTimeUtils","CoreUrlUtils","CoreUtils","CoreGroups","CoreLocalNotifications","CoreConfig","AddonCalendarOffline","CoreUser","moment","EVENTS_TABLE","CoreCourses","CoreConstants","CoreWSError","ApplicationInit","makeSingleton","Translate","AddonCalendarMainMenuHandlerService","CoreNavigator","AddonCalendarSyncProvider","CorePath","CorePlatform","CoreReminders","CoreRemindersService","CoreEvents","ROOT_CACHE_KEY","AddonCalendarEventType","AddonCalendarReminderUnits","SECONDS_MINUTE","SECONDS_HOUR","SECONDS_DAY","SECONDS_WEEK","AddonCalendarProvider","constructor","weekDays","shortname","fullname","canEditEvents","siteId","_this","_asyncToGenerator","site","getSite","canEditEventsInSite","_unused","_site","getCurrentSite","isVersionGreaterEqualThan","convertSecondsToValueAndUnit","seconds","deleteEvent","eventId","name","deleteAll","forceOffline","_this2","getCurrentSiteId","storeOffline","markDeleted","then","isOnline","unmarkDeleted","deleteEventOnline","error","isWebServiceError","params","events","eventid","repeat","preSets","responseExpected","write","deleteLocalEvent","getId","promises","push","getDb","deleteRecords","id","removeReminders","instanceId","component","COMPONENT","ignoreErrors","Promise","all","initialize","_this3","registerClick","_ref","notification","donePromise","notificationClicked","_x","apply","arguments","on","SITE_ADDED","data","updateSiteEventReminders","_this4","disabled","isDisabled","navigateToSitePath","PAGE_NAME","preferCurrentTab","nextNavigation","path","isSitePath","formatEventTime","event","format","useCommonWords","seenDay","showTime","_this5","getTimeHtml","time","a11yLangKey","instant","$a","cleanTags","getStartTimeHtml","getEndTimeHtml","start","timestart","end","timeduration","isSame","userDate","timeStart","timeEnd","dayStart","getDayRepresentation","dayEnd","getViewUrl","undefined","url","buildLink","getAccessInformation","courseId","_this6","cacheKey","getAccessInformationCacheKey","courseid","read","getAllEventsFromLocalDb","getAllRecords","getAllowedEventTypes","_this7","getAllowedEventTypesCacheKey","response","result","allowedeventtypes","forEach","type","getCalendarLookAhead","value","getUserPreference","_unused2","getStoredConfig","parseInt","getCalendarTimeFormat","_unused3","CALENDAR_TF_12","CALENDAR_TF_24","date","today","clone","subtract","add","getDefaultNotificationTime","getEvent","_this8","getEventCacheKey","updateFrequency","FREQUENCY_RARELY","options","userevents","siteevents","eventids","find","e","getEventFromLocalDb","_unused4","getEventById","_this9","updateLocalEvents","_unused5","_this10","record","getRecord","eventConverted","originalEvent","recordAsRecord","descriptionformat","iscourseevent","eventtype","COURSE","iscategoryevent","CATEGORY","normalisedeventtype","getEventType","category","parseJSON","_unused6","course","_unused7","subscription","_unused8","addEventReminder","timebefore","_timebefore","DEFAULT_REMINDER_TIMEBEFORE","previousReminders","getReminders","some","reminder","title","addReminder","modulename","deleteEventReminder","removeReminder","getDayEvents","year","month","day","categoryId","ignoreCache","_this11","categoryid","getDayEventsCacheKey","FREQUENCY_SOMETIMES","getFromCache","emergencyCache","getDayEventsPrefixCacheKey","getDayEventsDayPrefixCacheKey","getEventReminders","getEventsList","initialTime","daysToStart","daysInterval","DAYS_INTERVAL","_this12","timestamp","courseids","groupids","timeend","getUserCourses","courses","map","getSiteHomeId","getAllUserGroups","groups","group","getEventsListCacheKey","getCacheUsingCacheKey","uniqueCacheKey","getEventsListPrefixCacheKey","getLocalEventsByRepeatIdFromLocalDb","repeatId","getRecords","repeatid","getMonthlyEvents","_this13","mini","getMonthlyEventsCacheKey","weeks","week","days","set","STARTING_WEEK_DAY","daynames","dayno","getMonthlyEventsPrefixCacheKey","getMonthlyEventsMonthPrefixCacheKey","getUnitValueLabel","unit","addDefaultLabel","getUpcomingEvents","_this14","getUpcomingEventsCacheKey","getUpcomingEventsPrefixCacheKey","view","concatenatePaths","getURL","getWeekDays","startingDay","slice","concat","invalidateAccessInformation","_this15","invalidateWsCacheForKey","invalidateAllowedEventTypes","_this16","invalidateAllDayEvents","_this17","invalidateWsCacheForKeyStartingWith","invalidateDayEvents","_this18","invalidateEventsList","_this19","invalidateUserCourses","invalidateAllUserGroups","invalidateEvent","_this20","invalidateAllMonthlyEvents","_this21","invalidateMonthlyEvents","_this22","invalidateAllUpcomingEvents","_this23","invalidateUpcomingEvents","_this24","invalidateLookAhead","invalidateUserPreference","invalidateTimeFormat","isCalendarDisabledInSite","_site2","isFeatureDisabled","_this25","scheduleAllSitesEventsNotifications","AddonCalendar","updateAllSitesEventReminders","_this26","ready","siteIds","getSitesIds","_this27","scheduleEventsNotifications","updateEventsReminders","_ref2","Date","now","cancelReminder","reminders","_ref3","updateReminder","_x3","_x2","setDefaultNotificationTime","storeEventInLocalDb","_this28","_options$addDefaultRe","addDefaultReminder","eventRecord","description","groupid","userid","instance","timemodified","visible","_event$course","Object","assign","location","eventcount","timesort","JSON","stringify","canedit","candelete","deleteurl","editurl","viewurl","isactionevent","islastday","popupname","mindaytimestamp","maxdaytimestamp","draggable","uuid","sequence","subscriptionid","addDefaultEventReminder","insertRecord","_this29","eventExist","promiseWorks","length","storeEventsInLocalDB","_this30","_this31","submitEvent","formData","_this32","_ref4","_options$reminders","saveEvent","sent","_options$reminders2","submitEventOnline","_this33","getUserId","formdata","objectToGetParams","validationerror","message","errorcode","updateReminders","_class","NEW_EVENT_EVENT","NEW_EVENT_DISCARDED_EVENT","EDIT_EVENT_EVENT","DELETED_EVENT_EVENT","UNDELETED_EVENT_EVENT","FILTER_CHANGED_EVENT","factory","ɵfac","providedIn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/calendar/services/calendar.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreNetwork } from '@services/network';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreGroups } from '@services/groups';\nimport { CoreLocalNotifications } from '@services/local-notifications';\nimport { CoreConfig } from '@services/config';\nimport { AddonCalendarOffline } from './calendar-offline';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreWSExternalWarning, CoreWSDate } from '@services/ws';\nimport moment from 'moment-timezone';\nimport { AddonCalendarEventDBRecord, EVENTS_TABLE } from './database/calendar';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { ContextLevel, CoreConstants } from '@/core/constants';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { ApplicationInit, makeSingleton, Translate } from '@singletons';\nimport { AddonCalendarOfflineEventDBRecord } from './database/calendar-offline';\nimport { AddonCalendarMainMenuHandlerService } from './handlers/mainmenu';\nimport { SafeUrl } from '@angular/platform-browser';\nimport { CoreNavigator } from '@services/navigator';\nimport { AddonCalendarFilter } from './calendar-helper';\nimport { AddonCalendarSyncEvents, AddonCalendarSyncProvider } from './calendar-sync';\nimport { CorePath } from '@singletons/path';\nimport { CorePlatform } from '@services/platform';\nimport {\n    CoreReminderData,\n    CoreReminders,\n    CoreRemindersPushNotificationData,\n    CoreRemindersService,\n    CoreRemindersUnits,\n    CoreReminderValueAndUnit,\n} from '@features/reminders/services/reminders';\nimport { CoreReminderDBRecord } from '@features/reminders/services/database/reminders';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaCalendar:';\n\n/**\n * Main calendar Event types enumeration.\n */\nexport enum AddonCalendarEventType {\n    SITE = 'site',\n    CATEGORY = 'category',\n    COURSE = 'course',\n    GROUP = 'group',\n    USER = 'user',\n}\n\n/**\n * Units to set a reminder.\n *\n * @deprecated since 4.1 Use CoreReminderUnits instead.\n */\nexport enum AddonCalendarReminderUnits {\n    MINUTE = CoreConstants.SECONDS_MINUTE,\n    HOUR = CoreConstants.SECONDS_HOUR,\n    DAY = CoreConstants.SECONDS_DAY,\n    WEEK = CoreConstants.SECONDS_WEEK,\n}\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonCalendarProvider.NEW_EVENT_EVENT]: AddonCalendarUpdatedEventEvent;\n        [AddonCalendarProvider.EDIT_EVENT_EVENT]: AddonCalendarUpdatedEventEvent;\n        [AddonCalendarProvider.DELETED_EVENT_EVENT]: AddonCalendarUpdatedEventEvent;\n        [AddonCalendarProvider.UNDELETED_EVENT_EVENT]: AddonCalendarUpdatedEventEvent;\n        [AddonCalendarProvider.FILTER_CHANGED_EVENT]: AddonCalendarFilter;\n        [AddonCalendarSyncProvider.MANUAL_SYNCED]: AddonCalendarSyncEvents;\n        [AddonCalendarSyncProvider.AUTO_SYNCED]: AddonCalendarSyncEvents;\n    }\n\n}\n\n/**\n * Service to handle calendar events.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonCalendarProvider {\n\n    static readonly DAYS_INTERVAL = 30;\n    static readonly COMPONENT = 'AddonCalendarEvents';\n\n    static readonly STARTING_WEEK_DAY = 'addon_calendar_starting_week_day';\n    static readonly NEW_EVENT_EVENT = 'addon_calendar_new_event';\n    static readonly NEW_EVENT_DISCARDED_EVENT = 'addon_calendar_new_event_discarded';\n    static readonly EDIT_EVENT_EVENT = 'addon_calendar_edit_event';\n    static readonly DELETED_EVENT_EVENT = 'addon_calendar_deleted_event';\n    static readonly UNDELETED_EVENT_EVENT = 'addon_calendar_undeleted_event';\n    static readonly FILTER_CHANGED_EVENT = 'addon_calendar_filter_changed_event';\n\n    static readonly CALENDAR_TF_24 = '%H:%M'; // Calendar time in 24 hours format.\n    static readonly CALENDAR_TF_12 = '%I:%M %p'; // Calendar time in 12 hours format.\n\n    protected weekDays: AddonCalendarWeekDaysTranslationKeys[] = [\n        {\n            shortname: 'addon.calendar.sun',\n            fullname: 'addon.calendar.sunday',\n        },\n        {\n            shortname: 'addon.calendar.mon',\n            fullname: 'addon.calendar.monday',\n        },\n        {\n            shortname: 'addon.calendar.tue',\n            fullname: 'addon.calendar.tuesday',\n        },\n        {\n            shortname: 'addon.calendar.wed',\n            fullname: 'addon.calendar.wednesday',\n        },\n        {\n            shortname: 'addon.calendar.thu',\n            fullname: 'addon.calendar.thursday',\n        },\n        {\n            shortname: 'addon.calendar.fri',\n            fullname: 'addon.calendar.friday',\n        },\n        {\n            shortname: 'addon.calendar.sat',\n            fullname: 'addon.calendar.saturday',\n        },\n    ];\n\n    /**\n     * Check if a certain site allows creating and editing events.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if can create/edit.\n     * @since 3.7.1\n     */\n    async canEditEvents(siteId?: string): Promise<boolean> {\n        try {\n            const site = await CoreSites.getSite(siteId);\n\n            return this.canEditEventsInSite(site);\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Check if a certain site allows creating and editing events.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether events can be created and edited.\n     * @since 3.7.1\n     */\n    canEditEventsInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        // The WS to create/edit events requires a fix that was integrated in 3.7.1.\n        return !!site?.isVersionGreaterEqualThan('3.7.1');\n    }\n\n    /**\n     * Given a number of seconds, convert it to a unit&value format compatible with reminders.\n     *\n     * @param seconds Number of seconds.\n     * @returns Value and unit.\n     * @deprecated since 4.1 Use CoreRemindersService.convertSecondsToValueAndUnit instead.\n     */\n    static convertSecondsToValueAndUnit(seconds: number): CoreReminderValueAndUnit {\n        return CoreRemindersService.convertSecondsToValueAndUnit(seconds);\n    }\n\n    /**\n     * Delete an event.\n     *\n     * @param eventId Event ID to delete.\n     * @param name Name of the event to delete.\n     * @param deleteAll If it's a repeated event. whether to delete all events of the series.\n     * @param forceOffline True to always save it in offline.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteEvent(\n        eventId: number,\n        name: string,\n        deleteAll = false,\n        forceOffline = false,\n        siteId?: string,\n    ): Promise<boolean> {\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Function to store the submission to be synchronized later.\n        const storeOffline = (): Promise<boolean> =>\n            AddonCalendarOffline.markDeleted(eventId, name, deleteAll, siteId).then(() => false);\n\n        if (forceOffline || !CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        // If the event is already stored, discard it first.\n        await AddonCalendarOffline.unmarkDeleted(eventId, siteId);\n        try {\n            await this.deleteEventOnline(eventId, deleteAll, siteId);\n\n            return true;\n        } catch (error) {\n            if (error && !CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server, store in offline.\n                return storeOffline();\n            } else {\n                // The WebService has thrown an error, reject.\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Delete an event. It will fail if offline or cannot connect.\n     *\n     * @param eventId Event ID to delete.\n     * @param deleteAll If it's a repeated event. whether to delete all events of the series.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteEventOnline(eventId: number, deleteAll = false, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonCalendarDeleteCalendarEventsWSParams = {\n            events: [\n                {\n                    eventid: eventId,\n                    repeat: deleteAll,\n                },\n            ],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            responseExpected: false,\n        };\n\n        await site.write('core_calendar_delete_calendar_events', params, preSets);\n    }\n\n    /**\n     * Delete a locally stored event cancelling all the reminders and notifications.\n     *\n     * @param eventId Event ID.\n     * @param siteId ID of the site the event belongs to. If not defined, use current site.\n     * @returns Resolved when done.\n     */\n    protected async deleteLocalEvent(eventId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        siteId = site.getId();\n\n        const promises: Promise<unknown>[] = [];\n\n        promises.push(site.getDb().deleteRecords(\n            EVENTS_TABLE,\n            { id: eventId },\n        ));\n        promises.push(CoreReminders.removeReminders({\n            instanceId: eventId,\n            component: AddonCalendarProvider.COMPONENT,\n        } , siteId));\n\n        await CoreUtils.ignoreErrors(Promise.all(promises));\n    }\n\n    /**\n     * Initialize the service.\n     *\n     * @returns Promise resolved when done.\n     */\n    async initialize(): Promise<void> {\n        CoreLocalNotifications.registerClick<CoreRemindersPushNotificationData>(\n            AddonCalendarProvider.COMPONENT,\n            async (notification) => {\n                await ApplicationInit.donePromise;\n\n                this.notificationClicked(notification);\n            },\n        );\n\n        CoreEvents.on(CoreEvents.SITE_ADDED, (data) => {\n            if (!data.siteId) {\n                return;\n            }\n\n            this.updateSiteEventReminders(data.siteId);\n        });\n    }\n\n    /**\n     * Notification has been clicked.\n     *\n     * @param notification Calendar notification.\n     * @returns Promise resolved when done.\n     */\n    async notificationClicked(notification: CoreRemindersPushNotificationData): Promise<void> {\n        const disabled = await this.isDisabled(notification.siteId);\n        if (disabled) {\n            // The calendar is disabled in the site, don't open it.\n            return;\n        }\n\n        CoreNavigator.navigateToSitePath(\n            AddonCalendarMainMenuHandlerService.PAGE_NAME,\n            {\n                siteId: notification.siteId,\n                preferCurrentTab: false,\n                nextNavigation: {\n                    path: `calendar/event/${notification.instanceId}`,\n                    isSitePath: true,\n                },\n            },\n        );\n    }\n\n    /**\n     * Format event time. Similar to calendar_format_event_time.\n     *\n     * @param event Event to format.\n     * @param format Calendar time format (from getCalendarTimeFormat).\n     * @param useCommonWords Whether to use common words like \"Today\", \"Yesterday\", etc.\n     * @param seenDay Timestamp of day currently seen. If set, the function will not add links to this day.\n     * @param showTime Determine the show time GMT timestamp.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the formatted event time.\n     */\n    async formatEventTime(\n        event: AddonCalendarEventToDisplay,\n        format?: string,\n        useCommonWords = true,\n        seenDay?: number,\n        showTime = 0,\n        siteId?: string,\n    ): Promise<string> {\n\n        const getTimeHtml = (time: string, a11yLangKey: string): string =>\n            `<span aria-label=\"${Translate.instant(a11yLangKey, { $a: CoreTextUtils.cleanTags(time) })}\">${time}</span>`;\n        const getStartTimeHtml = (time: string): string => getTimeHtml(time, 'core.startingtime');\n        const getEndTimeHtml = (time: string): string => getTimeHtml(time, 'core.endingtime');\n\n        const start = event.timestart * 1000;\n        const end = (event.timestart + event.timeduration) * 1000;\n        let time: string;\n\n        if (event.timeduration) {\n\n            if (moment(start).isSame(end, 'day')) {\n                // Event starts and ends the same day.\n                if (event.timeduration == CoreConstants.SECONDS_DAY) {\n                    time = Translate.instant('addon.calendar.allday');\n                } else {\n                    time = getStartTimeHtml(CoreTimeUtils.userDate(start, format)) + ' <strong>&raquo;</strong> ' +\n                            getEndTimeHtml(CoreTimeUtils.userDate(end, format));\n                }\n\n            } else {\n                // Event lasts more than one day.\n                const timeStart = CoreTimeUtils.userDate(start, format);\n                const timeEnd = CoreTimeUtils.userDate(end, format);\n                const promises: Promise<void>[] = [];\n\n                // Don't use common words when the event lasts more than one day.\n                let dayStart = this.getDayRepresentation(start, false) + ', ';\n                let dayEnd = this.getDayRepresentation(end, false) + ', ';\n\n                // Add links to the days if needed.\n                if (dayStart && (!seenDay || !moment(seenDay).isSame(start, 'day'))) {\n                    promises.push(this.getViewUrl('day', event.timestart, undefined, siteId).then((url) => {\n                        dayStart = CoreUrlUtils.buildLink(url, dayStart);\n\n                        return;\n                    }));\n                }\n                if (dayEnd && (!seenDay || !moment(seenDay).isSame(end, 'day'))) {\n                    promises.push(this.getViewUrl('day', end / 1000, undefined, siteId).then((url) => {\n                        dayEnd = CoreUrlUtils.buildLink(url, dayEnd);\n\n                        return;\n                    }));\n                }\n\n                await Promise.all(promises);\n\n                return getStartTimeHtml(dayStart + timeStart) + ' <strong>&raquo;</strong> ' +\n                    getEndTimeHtml(dayEnd + timeEnd);\n            }\n        } else {\n            // There is no time duration.\n            time = getStartTimeHtml(CoreTimeUtils.userDate(start, format));\n        }\n\n        if (showTime) {\n            return time;\n        }\n\n        // Display day + time.\n        if (seenDay && moment(seenDay).isSame(start, 'day')) {\n            // This day is currently being displayed, don't add an link.\n            return this.getDayRepresentation(start, useCommonWords) + ', ' + time;\n        }\n\n        // Add link to view the day.\n        const url = await this.getViewUrl('day', event.timestart, undefined, siteId);\n\n        return CoreUrlUtils.buildLink(url, this.getDayRepresentation(start, useCommonWords)) + ', ' + time;\n    }\n\n    /**\n     * Get access information for a calendar (either course calendar or site calendar).\n     *\n     * @param courseId Course ID. If not defined, site calendar.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with object with access information.\n     * @since 3.7\n     */\n    async getAccessInformation(courseId?: number, siteId?: string): Promise<AddonCalendarGetCalendarAccessInformationWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonCalendarGetCalendarAccessInformationWSParams = {};\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAccessInformationCacheKey(courseId),\n        };\n        if (courseId) {\n            params.courseid = courseId;\n        }\n\n        return site.read('core_calendar_get_calendar_access_information', params, preSets);\n    }\n\n    /**\n     * Get cache key for calendar access information WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getAccessInformationCacheKey(courseId?: number): string {\n        return ROOT_CACHE_KEY + 'accessInformation:' + (courseId || 0);\n    }\n\n    /**\n     * Get all calendar events from local Db.\n     *\n     * @param siteId ID of the site the event belongs to. If not defined, use current site.\n     * @returns Promise resolved with all the events.\n     */\n    async getAllEventsFromLocalDb(siteId?: string): Promise<AddonCalendarEventDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getAllRecords(EVENTS_TABLE);\n    }\n\n    /**\n     * Get the type of events a user can create (either course calendar or site calendar).\n     *\n     * @param courseId Course ID. If not defined, site calendar.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with an object indicating the types.\n     * @since 3.7\n     */\n    async getAllowedEventTypes(courseId?: number, siteId?: string): Promise<{[name: string]: boolean}> {\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonCalendarGetAllowedEventTypesWSParams = {};\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAllowedEventTypesCacheKey(courseId),\n        };\n        if (courseId) {\n            params.courseid = courseId;\n        }\n        const response: AddonCalendarGetAllowedEventTypesWSResponse =\n            await site.read('core_calendar_get_allowed_event_types', params, preSets);\n\n        // Convert the array to an object.\n        const result: {[name: string]: boolean} = {};\n        if (response.allowedeventtypes) {\n            response.allowedeventtypes.forEach((type) => {\n                result[type] = true;\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Get cache key for calendar allowed event types WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getAllowedEventTypesCacheKey(courseId?: number): string {\n        return ROOT_CACHE_KEY + 'allowedEventTypes:' + (courseId || 0);\n    }\n\n    /**\n     * Get the \"look ahead\" for a certain user.\n     *\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolved with the look ahead (number of days).\n     */\n    async getCalendarLookAhead(siteId?: string): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n        let value: string | undefined | null;\n        try {\n            value = await CoreUser.getUserPreference('calendar_lookahead');\n        } catch {\n            // Ignore errors.\n        }\n\n        if (value === undefined || value === null) {\n            value = site.getStoredConfig('calendar_lookahead');\n        }\n\n        return parseInt(value as string, 10);\n    }\n\n    /**\n     * Get the time format to use in calendar.\n     *\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolved with the format.\n     */\n    async getCalendarTimeFormat(siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n        let format: string | undefined | null;\n\n        try {\n            format = await CoreUser.getUserPreference('calendar_timeformat');\n        } catch {\n            // Ignore errors.\n        }\n\n        if (!format || format === '0') {\n            format = site.getStoredConfig('calendar_site_timeformat');\n        }\n\n        if (format === AddonCalendarProvider.CALENDAR_TF_12) {\n            format = Translate.instant('core.strftimetime12');\n        } else if (format === AddonCalendarProvider.CALENDAR_TF_24) {\n            format = Translate.instant('core.strftimetime24');\n        }\n\n        return format && format !== '0' ? format : Translate.instant('core.strftimetime');\n    }\n\n    /**\n     * Return the representation day. Equivalent to Moodle's calendar_day_representation.\n     *\n     * @param time Timestamp to get the day from.\n     * @param useCommonWords Whether to use common words like \"Today\", \"Yesterday\", etc.\n     * @returns The formatted date/time.\n     */\n    getDayRepresentation(time: number, useCommonWords: boolean = true): string {\n\n        if (!useCommonWords) {\n            // We don't want words, just a date.\n            return CoreTimeUtils.userDate(time, 'core.strftimedayshort');\n        }\n\n        const date = moment(time);\n        const today = moment();\n\n        if (date.isSame(today, 'day')) {\n            return Translate.instant('addon.calendar.today');\n        }\n        if (date.isSame(today.clone().subtract(1, 'days'), 'day')) {\n            return Translate.instant('addon.calendar.yesterday');\n        }\n        if (date.isSame(today.clone().add(1, 'days'), 'day')) {\n            return Translate.instant('addon.calendar.tomorrow');\n        }\n\n        return CoreTimeUtils.userDate(time, 'core.strftimedayshort');\n    }\n\n    /**\n     * Get the configured default notification time.\n     *\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolved with the default time (in seconds).\n     * @deprecated since 4.1 Use CoreReminders.getDefaultNotificationTime instead.\n     */\n    async getDefaultNotificationTime(siteId?: string): Promise<number> {\n        return CoreReminders.getDefaultNotificationTime(siteId);\n    }\n\n    /**\n     * Get a calendar event. If the server request fails and data is not cached, try to get it from local DB.\n     *\n     * @param id Event ID.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolved when the event data is retrieved.\n     */\n    async getEvent(id: number, siteId?: string): Promise<AddonCalendarGetEventsEvent | AddonCalendarEventBase> {\n        const site = await CoreSites.getSite(siteId);\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEventCacheKey(id),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n        const params: AddonCalendarGetCalendarEventsWSParams = {\n            options: {\n                userevents: false,\n                siteevents: false,\n            },\n            events: {\n                eventids: [\n                    id,\n                ],\n            },\n        };\n        try {\n            const response: AddonCalendarGetCalendarEventsWSResponse =\n                await site.read('core_calendar_get_calendar_events', params, preSets);\n            // The WebService returns all category events. Check the response to search for the event we want.\n            const event = response.events.find((e) => e.id == id);\n\n            return event || this.getEventFromLocalDb(id);\n        } catch {\n            return this.getEventFromLocalDb(id);\n        }\n    }\n\n    /**\n     * Get a calendar event by ID. This function returns more data than getEvent, but it isn't available in all Moodles.\n     *\n     * @param id Event ID.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolved when the event data is retrieved.\n     */\n    async getEventById(id: number, siteId?: string): Promise<AddonCalendarEvent> {\n        const site = await CoreSites.getSite(siteId);\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEventCacheKey(id),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n        const params: AddonCalendarGetCalendarEventByIdWSParams = {\n            eventid: id,\n        };\n        try {\n            const response: AddonCalendarGetCalendarEventByIdWSResponse =\n                await site.read('core_calendar_get_calendar_event_by_id', params, preSets);\n\n            this.updateLocalEvents([response.event], { siteId });\n\n            return response.event;\n        } catch (error) {\n            try {\n                return (await this.getEventFromLocalDb(id)) as AddonCalendarEvent;\n            } catch {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Get cache key for a single event WS call.\n     *\n     * @param id Event ID.\n     * @returns Cache key.\n     */\n    protected getEventCacheKey(id: number): string {\n        return ROOT_CACHE_KEY + 'events:' + id;\n    }\n\n    /**\n     * Get a calendar event from local Db.\n     *\n     * @param id Event ID.\n     * @param siteId ID of the site the event belongs to. If not defined, use current site.\n     * @returns Promise resolved when the event data is retrieved.\n     */\n    async getEventFromLocalDb(id: number, siteId?: string): Promise<AddonCalendarGetEventsEvent | AddonCalendarEvent> {\n        const site = await CoreSites.getSite(siteId);\n        const record: AddonCalendarGetEventsEvent | AddonCalendarEvent | AddonCalendarEventDBRecord =\n            await site.getDb().getRecord(EVENTS_TABLE, { id: id });\n\n        const eventConverted = record as AddonCalendarEvent;\n        const originalEvent = record as AddonCalendarGetEventsEvent;\n        const recordAsRecord = record as AddonCalendarEventDBRecord;\n\n        // Calculate data to match the new WS.\n        eventConverted.descriptionformat = originalEvent.format;\n        eventConverted.iscourseevent = originalEvent.eventtype == AddonCalendarEventType.COURSE;\n        eventConverted.iscategoryevent = originalEvent.eventtype == AddonCalendarEventType.CATEGORY;\n        eventConverted.normalisedeventtype = this.getEventType(recordAsRecord);\n        try {\n            eventConverted.category = CoreTextUtils.parseJSON(recordAsRecord.category || '');\n        } catch {\n            // Ignore errors.\n        }\n\n        try {\n            eventConverted.course = CoreTextUtils.parseJSON(recordAsRecord.course || '');\n        } catch {\n            // Ignore errors.\n        }\n        try {\n            eventConverted.subscription = CoreTextUtils.parseJSON(recordAsRecord.subscription || '');\n        } catch {\n            // Ignore errors.\n        }\n\n        return eventConverted;\n    }\n\n    /**\n     * Adds an event reminder and schedule a new notification.\n     *\n     * @param event Event to set the reminder.\n     * @param timebefore Amount of seconds of the reminder. Undefined for default reminder.\n     * @param siteId ID of the site the event belongs to. If not defined, use current site.\n     * @returns Promise resolved when the notification is updated.\n     */\n    async addEventReminder(\n        event: AddonCalendarEvent | AddonCalendarEventDBRecord | AddonCalendarEventToDisplay | AddonCalendarOfflineEventDBRecord,\n        timebefore?: number,\n        siteId?: string,\n    ): Promise<void> {\n\n        timebefore = timebefore ?? CoreRemindersService.DEFAULT_REMINDER_TIMEBEFORE;\n\n        const previousReminders = await CoreReminders.getReminders({\n            instanceId: event.id,\n            component: AddonCalendarProvider.COMPONENT,\n        }, siteId);\n\n        if (previousReminders.some((reminder) => reminder.timebefore === timebefore)) {\n            // Already exists.\n            return;\n        }\n\n        const url = 'url' in event\n            ? event.url || ''\n            : '';\n\n        const reminder: CoreReminderData = {\n            component: AddonCalendarProvider.COMPONENT,\n            instanceId: event.id,\n            type: event.eventtype,\n            time: event.timestart,\n            timebefore,\n            title: event.name,\n            url,\n        };\n\n        await CoreReminders.addReminder(reminder, siteId);\n    }\n\n    /**\n     * Return the normalised event type.\n     * Activity events are normalised to be course events.\n     *\n     * @param event The event to get its type.\n     * @returns Event type.\n     */\n    getEventType(event: { modulename?: string; eventtype: AddonCalendarEventType | string }): string {\n        if (event.modulename) {\n            return 'course';\n        }\n\n        return event.eventtype;\n    }\n\n    /**\n     * Remove an event reminder and cancel the notification.\n     *\n     * @param id Reminder ID.\n     * @param siteId ID of the site the event belongs to. If not defined, use current site.\n     * @returns Promise resolved when the notification is updated.\n     * @deprecated since 4.1. Use CoreReminders.removeReminder instead.\n     */\n    async deleteEventReminder(id: number, siteId?: string): Promise<void> {\n        await CoreReminders.removeReminder(id, siteId);\n    }\n\n    /**\n     * Get calendar events for a certain day.\n     *\n     * @param year Year to get.\n     * @param month Month to get.\n     * @param day Day to get.\n     * @param courseId Course to get.\n     * @param categoryId Category to get.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the response.\n     */\n    async getDayEvents(\n        year: number,\n        month: number,\n        day: number,\n        courseId?: number,\n        categoryId?: number,\n        ignoreCache = false,\n        siteId?: string,\n    ): Promise<AddonCalendarCalendarDay> {\n\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonCalendarGetCalendarDayViewWSParams = {\n            year: year,\n            month: month,\n            day: day,\n        };\n        if (courseId) {\n            params.courseid = courseId;\n        }\n        if (categoryId) {\n            params.categoryid = categoryId;\n        }\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getDayEventsCacheKey(year, month, day, courseId, categoryId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n        if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n        const response: AddonCalendarCalendarDay = await site.read('core_calendar_get_calendar_day_view', params, preSets);\n        this.updateLocalEvents(response.events, { siteId });\n\n        return response;\n    }\n\n    /**\n     * Get prefix cache key for day events WS calls.\n     *\n     * @returns Prefix Cache key.\n     */\n    protected getDayEventsPrefixCacheKey(): string {\n        return ROOT_CACHE_KEY + 'day:';\n    }\n\n    /**\n     * Get prefix cache key for a certain day for day events WS calls.\n     *\n     * @param year Year to get.\n     * @param month Month to get.\n     * @param day Day to get.\n     * @returns Prefix Cache key.\n     */\n    protected getDayEventsDayPrefixCacheKey(year: number, month: number, day: number): string {\n        return this.getDayEventsPrefixCacheKey() + year + ':' + month + ':' + day + ':';\n    }\n\n    /**\n     * Get cache key for day events WS calls.\n     *\n     * @param year Year to get.\n     * @param month Month to get.\n     * @param day Day to get.\n     * @param courseId Course to get.\n     * @param categoryId Category to get.\n     * @returns Cache key.\n     */\n    protected getDayEventsCacheKey(year: number, month: number, day: number, courseId?: number, categoryId?: number): string {\n        return this.getDayEventsDayPrefixCacheKey(year, month, day) + (courseId ? courseId : '') + ':' +\n                (categoryId ? categoryId : '');\n    }\n\n    /**\n     * Get a calendar reminders from local Db.\n     *\n     * @param eventId Event ID.\n     * @param siteId ID of the site the event belongs to. If not defined, use current site.\n     * @returns Promise resolved when the event data is retrieved.\n     * @deprecated since 4.1. Use CoreReminders.getReminders instead.\n     */\n    async getEventReminders(eventId: number, siteId?: string): Promise<CoreReminderDBRecord[]> {\n        return CoreReminders.getReminders({\n            instanceId: eventId,\n            component: AddonCalendarProvider.COMPONENT,\n        }, siteId);\n    }\n\n    /**\n     * Get the events in a certain period. The period is calculated like this:\n     *     start time: now + daysToStart\n     *     end time: start time + daysInterval\n     * E.g. using provider.getEventsList(undefined, 30, 30) is going to get the events starting after 30 days from now\n     * and ending before 60 days from now.\n     *\n     * @param initialTime Timestamp when the first fetch was done. If not defined, current time.\n     * @param daysToStart Number of days from now to start getting events.\n     * @param daysInterval Number of days between timestart and timeend.\n     * @param siteId Site to get the events from. If not defined, use current site.\n     * @returns Promise to be resolved when the events are retrieved.\n     */\n    async getEventsList(\n        initialTime?: number,\n        daysToStart: number = 0,\n        daysInterval: number = AddonCalendarProvider.DAYS_INTERVAL,\n        siteId?: string,\n    ): Promise<AddonCalendarGetEventsEvent[]> {\n\n        initialTime = initialTime || CoreTimeUtils.timestamp();\n\n        const site = await CoreSites.getSite(siteId);\n        siteId = site.getId();\n\n        const start = initialTime + (CoreConstants.SECONDS_DAY * daysToStart);\n        const end = start + (CoreConstants.SECONDS_DAY * daysInterval) - 1;\n\n        const events = {\n            courseids: <number[]> [],\n            groupids: <number[]> [],\n        };\n        const params: AddonCalendarGetCalendarEventsWSParams = {\n            options: {\n                userevents: true,\n                siteevents: true,\n                timestart: start,\n                timeend: end,\n            },\n            events: events,\n        };\n\n        const promises: Promise<void>[] = [];\n\n        promises.push(CoreCourses.getUserCourses(false, siteId).then((courses) => {\n            events.courseids = courses.map((course) => course.id);\n            events.courseids.push(site.getSiteHomeId()); // Add front page.\n\n            return;\n        }));\n\n        promises.push(CoreGroups.getAllUserGroups(siteId).then((groups) => {\n            events.groupids = groups.map((group) => group.id);\n\n            return;\n        }));\n\n        await Promise.all(promises);\n\n        // We need to retrieve cached data using cache key because we have timestamp in the params.\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEventsListCacheKey(daysToStart, daysInterval),\n            getCacheUsingCacheKey: true,\n            uniqueCacheKey: true,\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n        const response =\n            await site.read<AddonCalendarGetCalendarEventsWSResponse>('core_calendar_get_calendar_events', params, preSets);\n\n        this.updateLocalEvents(response.events, { siteId });\n\n        return response.events;\n    }\n\n    /**\n     * Get prefix cache key for events list WS calls.\n     *\n     * @returns Prefix Cache key.\n     */\n    protected getEventsListPrefixCacheKey(): string {\n        return ROOT_CACHE_KEY + 'events:';\n    }\n\n    /**\n     * Get cache key for events list WS calls.\n     *\n     * @param daysToStart Number of days from now to start getting events.\n     * @param daysInterval Number of days between timestart and timeend.\n     * @returns Cache key.\n     */\n    protected getEventsListCacheKey(daysToStart: number, daysInterval: number): string {\n        return this.getEventsListPrefixCacheKey() + daysToStart + ':' + daysInterval;\n    }\n\n    /**\n     * Get calendar events from local Db that have the same repeatid.\n     *\n     * @param repeatId Repeat Id of the event.\n     * @param siteId ID of the site the event belongs to. If not defined, use current site.\n     * @returns Promise resolved with all the events.\n     */\n    async getLocalEventsByRepeatIdFromLocalDb(repeatId: number, siteId?: string): Promise<AddonCalendarEventDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecords(EVENTS_TABLE, { repeatid: repeatId });\n    }\n\n    /**\n     * Get monthly calendar events.\n     *\n     * @param year Year to get.\n     * @param month Month to get.\n     * @param courseId Course to get.\n     * @param categoryId Category to get.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the response.\n     */\n    async getMonthlyEvents(\n        year: number,\n        month: number,\n        courseId?: number,\n        categoryId?: number,\n        ignoreCache = false,\n        siteId?: string,\n    ): Promise<AddonCalendarMonth> {\n\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonCalendarGetCalendarMonthlyViewWSParams = {\n            year: year,\n            month: month,\n            mini: true, // Set mini to 1 to prevent returning the course selector HTML.\n        };\n        if (courseId) {\n            params.courseid = courseId;\n        }\n        if (categoryId) {\n            params.categoryid = categoryId;\n        }\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getMonthlyEventsCacheKey(year, month, courseId, categoryId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n        if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        const response = await site.read<AddonCalendarMonth>('core_calendar_get_calendar_monthly_view', params, preSets);\n        response.weeks.forEach((week) => {\n            week.days.forEach((day) => {\n                this.updateLocalEvents(day.events, { siteId });\n            });\n        });\n\n        // Store starting week day preference, we need it in offline to show months that are not in cache.\n        if (CoreNetwork.isOnline()) {\n            CoreConfig.set(AddonCalendarProvider.STARTING_WEEK_DAY, response.daynames[0].dayno);\n        }\n\n        return response;\n    }\n\n    /**\n     * Get prefix cache key for monthly events WS calls.\n     *\n     * @returns Prefix Cache key.\n     */\n    protected getMonthlyEventsPrefixCacheKey(): string {\n        return ROOT_CACHE_KEY + 'monthly:';\n    }\n\n    /**\n     * Get prefix cache key for a certain month for monthly events WS calls.\n     *\n     * @param year Year to get.\n     * @param month Month to get.\n     * @returns Prefix Cache key.\n     */\n    protected getMonthlyEventsMonthPrefixCacheKey(year: number, month: number): string {\n        return this.getMonthlyEventsPrefixCacheKey() + year + ':' + month + ':';\n    }\n\n    /**\n     * Get cache key for monthly events WS calls.\n     *\n     * @param year Year to get.\n     * @param month Month to get.\n     * @param courseId Course to get.\n     * @param categoryId Category to get.\n     * @returns Cache key.\n     */\n    protected getMonthlyEventsCacheKey(year: number, month: number, courseId?: number, categoryId?: number): string {\n        return this.getMonthlyEventsMonthPrefixCacheKey(year, month) + (courseId ? courseId : '') + ':' +\n                (categoryId ? categoryId : '');\n    }\n\n    /**\n     * Given a value and a unit, return the translated label.\n     *\n     * @param value Value.\n     * @param unit Unit.\n     * @param addDefaultLabel Whether to add the \"Default\" text.\n     * @returns Translated label.\n     * @deprecated since 4.1 Use CoreReminders.getUnitValueLabel instead.\n     */\n    getUnitValueLabel(value: number, unit: CoreRemindersUnits, addDefaultLabel = false): string {\n        return CoreReminders.getUnitValueLabel(value, unit, addDefaultLabel);\n    }\n\n    /**\n     * Get upcoming calendar events.\n     *\n     * @param courseId Course to get.\n     * @param categoryId Category to get.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the response.\n     */\n    async getUpcomingEvents(\n        courseId?: number,\n        categoryId?: number,\n        ignoreCache = false,\n        siteId?: string,\n    ): Promise<AddonCalendarUpcoming> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonCalendarGetCalendarUpcomingViewWSParams = {};\n        if (courseId) {\n            params.courseid = courseId;\n        }\n\n        if (categoryId) {\n            params.categoryid = categoryId;\n        }\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getUpcomingEventsCacheKey(courseId, categoryId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n\n        if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        const response = await site.read<AddonCalendarUpcoming>('core_calendar_get_calendar_upcoming_view', params, preSets);\n        this.updateLocalEvents(response.events, { siteId });\n\n        return response;\n    }\n\n    /**\n     * Get prefix cache key for upcoming events WS calls.\n     *\n     * @returns Prefix Cache key.\n     */\n    protected getUpcomingEventsPrefixCacheKey(): string {\n        return ROOT_CACHE_KEY + 'upcoming:';\n    }\n\n    /**\n     * Get cache key for upcoming events WS calls.\n     *\n     * @param courseId Course to get.\n     * @param categoryId Category to get.\n     * @returns Cache key.\n     */\n    protected getUpcomingEventsCacheKey(courseId?: number, categoryId?: number): string {\n        return this.getUpcomingEventsPrefixCacheKey() + (courseId ? courseId : '') + ':' + (categoryId ? categoryId : '');\n    }\n\n    /**\n     * Get URL to view a calendar.\n     *\n     * @param view The view to load: 'month', 'day', 'upcoming', etc.\n     * @param time Time to load. If not defined, current time.\n     * @param courseId Course to load. If not defined, all courses.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the URL.x\n     */\n    async getViewUrl(view: string, time?: number, courseId?: string, siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n        let url = CorePath.concatenatePaths(site.getURL(), 'calendar/view.php?view=' + view);\n\n        if (time) {\n            url += '&time=' + time;\n        }\n        if (courseId) {\n            url += '&course=' + courseId;\n        }\n\n        return url;\n    }\n\n    /**\n     * Get the week days, already ordered according to a specified starting day.\n     *\n     * @param startingDay Starting day. 0=Sunday, 1=Monday, ...\n     * @returns Week days.\n     */\n    getWeekDays(startingDay?: number): AddonCalendarWeekDaysTranslationKeys[] {\n        startingDay = startingDay || 0;\n\n        return this.weekDays.slice(startingDay).concat(this.weekDays.slice(0, startingDay));\n    }\n\n    /**\n     * Invalidates access information.\n     *\n     * @param courseId Course ID. If not defined, site calendar.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAccessInformation(courseId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAccessInformationCacheKey(courseId));\n    }\n\n    /**\n     * Invalidates allowed event types.\n     *\n     * @param courseId Course ID. If not defined, site calendar.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllowedEventTypes(courseId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAllowedEventTypesCacheKey(courseId));\n    }\n\n    /**\n     * Invalidates day events for all days.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllDayEvents(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getDayEventsPrefixCacheKey());\n    }\n\n    /**\n     * Invalidates day events for a certain day.\n     *\n     * @param year Year.\n     * @param month Month.\n     * @param day Day.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateDayEvents(year: number, month: number, day: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getDayEventsDayPrefixCacheKey(year, month, day));\n    }\n\n    /**\n     * Invalidates events list and all the single events and related info.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the list is invalidated.\n     */\n    async invalidateEventsList(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        siteId = site.getId();\n        const promises: Promise<void>[] = [];\n        promises.push(CoreCourses.invalidateUserCourses(siteId));\n        promises.push(CoreGroups.invalidateAllUserGroups(siteId));\n        promises.push(site.invalidateWsCacheForKeyStartingWith(this.getEventsListPrefixCacheKey()));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidates a single event.\n     *\n     * @param eventId List of courses or course ids.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the list is invalidated.\n     */\n    async invalidateEvent(eventId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getEventCacheKey(eventId));\n    }\n\n    /**\n     * Invalidates monthly events for all months.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllMonthlyEvents(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getMonthlyEventsPrefixCacheKey());\n    }\n\n    /**\n     * Invalidates monthly events for a certain months.\n     *\n     * @param year Year.\n     * @param month Month.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateMonthlyEvents(year: number, month: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getMonthlyEventsMonthPrefixCacheKey(year, month));\n    }\n\n    /**\n     * Invalidates upcoming events for all courses and categories.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllUpcomingEvents(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getUpcomingEventsPrefixCacheKey());\n    }\n\n    /**\n     * Invalidates upcoming events for a certain course or category.\n     *\n     * @param courseId Course ID.\n     * @param categoryId Category ID.\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUpcomingEvents(courseId?: number, categoryId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getUpcomingEventsCacheKey(courseId, categoryId));\n    }\n\n    /**\n     * Invalidates look ahead setting.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateLookAhead(siteId?: string): Promise<void> {\n        await CoreUser.invalidateUserPreference('calendar_lookahead', siteId);\n    }\n\n    /**\n     * Invalidates time format setting.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    invalidateTimeFormat(siteId?: string): Promise<void> {\n        return CoreUser.invalidateUserPreference('calendar_timeformat', siteId);\n    }\n\n    /**\n     * Check if Calendar is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether it's disabled.\n     */\n    isCalendarDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site?.isFeatureDisabled('CoreMainMenuDelegate_AddonCalendar');\n    }\n\n    /**\n     * Check if Calendar is disabled in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n     */\n    async isDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.isCalendarDisabledInSite(site);\n    }\n\n    /**\n     * Get the next events for all the sites and schedules their notifications.\n     *\n     * @returns Promise resolved when done.\n     * @deprecated since 4.1 Use AddonCalendar.updateAllSitesEventReminders.\n     */\n    async scheduleAllSitesEventsNotifications(): Promise<void> {\n        await AddonCalendar.updateAllSitesEventReminders();\n    }\n\n    /**\n     * Get the next events for all the sites and updates their reminders.\n     */\n    async updateAllSitesEventReminders(): Promise<void> {\n        await CorePlatform.ready();\n\n        const siteIds = await CoreSites.getSitesIds();\n\n        await Promise.all(siteIds.map(siteId => this.updateSiteEventReminders(siteId)));\n    }\n\n    /**\n     * Get the next events for a site and updates their reminders.\n     *\n     * @param siteId Site ID.\n     */\n    async updateSiteEventReminders(siteId: string): Promise<void> {\n        // Check if calendar is disabled for the site.\n        const disabled = await this.isDisabled(siteId);\n        if (disabled) {\n            return;\n        }\n\n        // Get first events to store/update them in local database and update their reminders.\n        await this.getEventsList(undefined, undefined, undefined, siteId);\n    }\n\n    /**\n     * Get the next events for all the sites and schedules their notifications.\n     *\n     * @returns Promise resolved when done.\n     * @deprecated since 4.1. No replacement for that function.\n     */\n    async scheduleEventsNotifications(\n        events: ({ id: number; timestart: number; timeduration: number; name: string})[],\n        siteId?: string,\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await AddonCalendar.updateEventsReminders(events, siteId);\n    }\n\n    /**\n     * Schedules the notifications for a list of events.\n     * If an event notification time is 0, cancel its scheduled notification (if any).\n     * If local notification plugin is not enabled, resolve the promise.\n     *\n     * @param events Events to schedule.\n     * @param siteId ID of the site the events belong to.\n     * @returns Promise resolved when all the notifications have been scheduled.\n     */\n    protected async updateEventsReminders(\n        events: ({ id: number; timestart: number; name: string})[],\n        siteId: string,\n    ): Promise<void> {\n        await Promise.all(events.map(async (event) => {\n            if (event.timestart * 1000 <= Date.now()) {\n                // The event has already started, don't schedule it.\n\n                // @TODO Decide when to completelly remove expired events.\n                return CoreReminders.cancelReminder(event.id, AddonCalendarProvider.COMPONENT, siteId);\n            }\n\n            const reminders = await CoreReminders.getReminders({\n                instanceId: event.id,\n                component: AddonCalendarProvider.COMPONENT,\n            }, siteId);\n\n            await Promise.all(reminders.map(async (reminder) => {\n                if (reminder.time !== event.timestart || reminder.title !== event.name) {\n                    reminder.time = event.timestart;\n                    reminder.title = event.name;\n\n                    CoreReminders.updateReminder(\n                        reminder,\n                        siteId,\n                    );\n                }\n            }));\n        }));\n    }\n\n    /**\n     * Set the default notification time.\n     *\n     * @param time New default time.\n     * @param siteId ID of the site. If not defined, use current site.\n     * @returns Promise resolved when stored.\n     * @deprecated since 4.1 Use CoreReminders.setDefaultNotificationTime.\n     */\n    async setDefaultNotificationTime(time: number, siteId?: string): Promise<void> {\n        await CoreReminders.setDefaultNotificationTime(time, siteId);\n    }\n\n    /**\n     * Store an event in local DB as it is.\n     *\n     * @param event Event to store.\n     * @param options Options.\n     * @returns Promise resolved when stored.\n     */\n    protected async storeEventInLocalDb(\n        event: AddonCalendarGetEventsEvent | AddonCalendarCalendarEvent | AddonCalendarEvent,\n        options: AddonCalendarStoreEventsOptions = {},\n    ): Promise<void> {\n        const site = await CoreSites.getSite(options.siteId);\n        const addDefaultReminder = options.addDefaultReminder ?? true;\n\n        // Don't store data that can be calculated like formattedtime, iscategoryevent, etc.\n        let eventRecord: AddonCalendarEventDBRecord = {\n            id: event.id,\n            name: event.name,\n            description: event.description || '',\n            eventtype: event.eventtype,\n            timestart: event.timestart,\n            timeduration: event.timeduration,\n            categoryid: event.categoryid,\n            groupid: event.groupid,\n            userid: event.userid,\n            instance: event.instance,\n            modulename: event.modulename,\n            timemodified: event.timemodified,\n            repeatid: event.repeatid,\n            visible: event.visible,\n        };\n\n        if ('descriptionformat' in event) {\n            eventRecord = Object.assign(eventRecord, {\n                courseid: event.course?.id,\n                location: event.location,\n                eventcount: event.eventcount,\n                timesort: event.timesort,\n                category: event.category ? JSON.stringify(event.category) : undefined,\n                course: event.course ? JSON.stringify(event.course) : undefined,\n                subscription: event.subscription ? JSON.stringify(event.subscription) : undefined,\n                canedit: event.canedit ? 1 : 0,\n                candelete: event.candelete ? 1 : 0,\n                deleteurl: event.deleteurl,\n                editurl: event.editurl,\n                viewurl: event.viewurl,\n                isactionevent: event.isactionevent ? 1 : 0,\n                url: event.url,\n            });\n\n            if ('islastday' in event) {\n                eventRecord = Object.assign(eventRecord, {\n                    islastday: event.islastday ? 1 : 0,\n                    popupname: event.popupname,\n                    mindaytimestamp: event.mindaytimestamp,\n                    maxdaytimestamp: event.maxdaytimestamp,\n                    draggable: event.draggable ? 1 : 0,\n                });\n            }\n        } else if ('uuid' in event) {\n            eventRecord = Object.assign(eventRecord, {\n                courseid: event.courseid,\n                uuid: event.uuid,\n                sequence: event.sequence,\n                subscriptionid: event.subscriptionid,\n            });\n        }\n\n        if (addDefaultReminder) {\n            await this.addDefaultEventReminder(eventRecord, site.getId());\n        }\n\n        await site.getDb().insertRecord(EVENTS_TABLE, eventRecord);\n    }\n\n    /**\n     * Adds the default event reminder.\n     *\n     * @param event Event to add the reminder to.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    protected async addDefaultEventReminder(event: AddonCalendarEventDBRecord, siteId?: string): Promise<void> {\n        // Add default reminder if the event isn't stored already and doesn't have any reminder.\n        const eventExist = await CoreUtils.promiseWorks(this.getEventFromLocalDb(event.id, siteId));\n        if (eventExist) {\n            return;\n        }\n\n        const reminders = await CoreReminders.getReminders({\n            instanceId: event.id,\n            component: AddonCalendarProvider.COMPONENT,\n        }, siteId);\n\n        if (reminders.length > 0) {\n            // It already has reminders.\n            return;\n        }\n\n        // No reminders, create the default one.\n        await this.addEventReminder(event, undefined, siteId);\n    }\n\n    /**\n     * Store events in local DB.\n     *\n     * @param events Events to store.\n     * @param options Options.\n     * @returns Promise resolved when the events are stored.\n     */\n    protected async storeEventsInLocalDB(\n        events: (AddonCalendarGetEventsEvent | AddonCalendarCalendarEvent | AddonCalendarEvent)[],\n        options: AddonCalendarStoreEventsOptions = {},\n    ): Promise<void> {\n        await Promise.all(events.map((event) => this.storeEventInLocalDb(event, options)));\n    }\n\n    /**\n     * Update local events, storing them in DB and also updating their reminders.\n     *\n     * @param events Events to store or update.\n     * @param options Options.\n     */\n    protected async updateLocalEvents(\n        events: (AddonCalendarGetEventsEvent | AddonCalendarCalendarEvent | AddonCalendarEvent)[],\n        options: AddonCalendarStoreEventsOptions = {},\n    ): Promise<void> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        await this.storeEventsInLocalDB(events, options);\n        await this.updateEventsReminders(events, options.siteId);\n    }\n\n    /**\n     * Submit a calendar event.\n     *\n     * @param eventId ID of the event. Negative value to edit offline event. If undefined/null, create a new event.\n     * @param formData Form data.\n     * @param options Calendar submit event options.\n     * @returns Promise resolved with the event and a boolean indicating if data was sent to server or stored in offline.\n     */\n    async submitEvent(\n        eventId: number | undefined,\n        formData: AddonCalendarSubmitCreateUpdateFormDataWSParams,\n        options: AddonCalendarSubmitEventOptions = {},\n    ): Promise<{sent: boolean; event: AddonCalendarOfflineEventDBRecord | AddonCalendarEvent}> {\n\n        const siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        // Function to store the event to be synchronized later.\n        const storeOffline = async (): Promise<{ sent: boolean; event: AddonCalendarOfflineEventDBRecord }> => {\n            const event = await AddonCalendarOffline.saveEvent(eventId, formData, siteId);\n\n            // Now save the reminders if any.\n            if (options.reminders?.length) {\n                await CoreUtils.ignoreErrors(\n                    Promise.all(options.reminders.map((reminder) =>\n                        this.addEventReminder(event, reminder.time, siteId))),\n                );\n            }\n\n            return { sent: false, event };\n        };\n\n        if (options.forceOffline || !CoreNetwork.isOnline()) {\n            // App is offline, store the event.\n            return storeOffline();\n        }\n\n        if (eventId) {\n            // If the event is already stored, discard it first.\n            await AddonCalendarOffline.deleteEvent(eventId, siteId);\n        }\n        try {\n            const event = await this.submitEventOnline(eventId, formData, siteId);\n\n            // Now save the reminders if any.\n            if (options.reminders?.length) {\n                await CoreUtils.ignoreErrors(\n                    Promise.all(options.reminders.map((reminder) =>\n                        this.addEventReminder(event, reminder.time, siteId))),\n                );\n            }\n\n            return ({ sent: true, event });\n        } catch (error) {\n            if (error && !CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server, store in offline.\n                return storeOffline();\n            } else {\n                // The WebService has thrown an error, reject.\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Submit an event, either to create it or to edit it. It will fail if offline or cannot connect.\n     *\n     * @param eventId ID of the event. If undefined/null or negative number, create a new event.\n     * @param formData Form data.\n     * @param siteId Site ID. If not provided, current site.\n     * @returns Promise resolved when done.\n     */\n    async submitEventOnline(\n        eventId: number = 0,\n        formData: AddonCalendarSubmitCreateUpdateFormDataWSParams,\n        siteId?: string,\n    ): Promise<AddonCalendarEvent> {\n        const site = await CoreSites.getSite(siteId);\n        siteId = site.getId();\n\n        // Add data that is \"hidden\" in web.\n        formData.id = eventId > 0 ? eventId : 0;\n        formData.userid = site.getUserId();\n        formData.visible = 1;\n        formData.instance = 0;\n        if (eventId > 0) {\n            formData['_qf__core_calendar_local_event_forms_update'] = 1;\n        } else {\n            formData['_qf__core_calendar_local_event_forms_create'] = 1;\n        }\n\n        const params: AddonCalendarSubmitCreateUpdateFormWSParams = {\n            formdata: CoreUtils.objectToGetParams(formData),\n        };\n        const result =\n            await site.write<AddonCalendarSubmitCreateUpdateFormWSResponse>('core_calendar_submit_create_update_form', params);\n\n        if (result.validationerror || !result.event) {\n            // Simulate a WS error.\n            throw new CoreWSError({\n                message: Translate.instant('core.invalidformdata'),\n                errorcode: 'validationerror',\n            });\n        }\n\n        if (eventId < 0) {\n            // Offline event has been sent. Change reminders instanceId if any.\n            await CoreUtils.ignoreErrors(\n                CoreReminders.updateReminders(\n                    { instanceId: result.event.id },\n                    {\n                        instanceId: eventId,\n                        component: AddonCalendarProvider.COMPONENT,\n                    },\n                    siteId,\n                ),\n            );\n        }\n\n        if (formData.id === 0) {\n            // Store the new event in local DB.\n            await CoreUtils.ignoreErrors(this.storeEventInLocalDb(result.event, { addDefaultReminder: false, siteId }));\n        }\n\n        return result.event;\n    }\n\n}\n\nexport const AddonCalendar = makeSingleton(AddonCalendarProvider);\n\n/**\n * Data returned by calendar's events_exporter.\n * Data returned by core_calendar_get_action_events_by_course and core_calendar_get_action_events_by_timesort WS.\n */\nexport type AddonCalendarEvents = {\n    events: AddonCalendarEvent[]; // Events.\n    firstid: number; // Firstid.\n    lastid: number; // Lastid.\n};\n\n/**\n * Params of core_calendar_get_action_events_by_courses WS.\n */\nexport type AddonCalendarGetActionEventsByCoursesWSParams = {\n    courseids: number[];\n    timesortfrom?: number; // Time sort from.\n    timesortto?: number; // Time sort to.\n    limitnum?: number; // Limit number.\n    searchvalue?: string; // The value a user wishes to search against.\n};\n\n/**\n * Data returned by calendar's events_grouped_by_course_exporter.\n * Data returned by core_calendar_get_action_events_by_courses WS.\n */\nexport type AddonCalendarEventsGroupedByCourse = {\n    groupedbycourse: AddonCalendarEventsSameCourse[]; // Groupped by course.\n};\n\n/**\n * Params of core_calendar_get_action_events_by_course WS.\n */\nexport type AddonCalendarGetActionEventsByCourseWSParams = {\n    courseid: number; // Course id.\n    timesortfrom?: number; // Time sort from.\n    timesortto?: number; // Time sort to.\n    aftereventid?: number; // The last seen event id.\n    limitnum?: number; // Limit number.\n    searchvalue?: string; // The value a user wishes to search against.\n};\n\n/**\n * Params of core_calendar_get_action_events_by_timesort WS.\n */\nexport type AddonCalendarGetActionEventsByTimesortWSParams = {\n    timesortfrom?: number; // Time sort from.\n    timesortto?: number; // Time sort to.\n    aftereventid?: number; // The last seen event id.\n    limitnum?: number; // Limit number.\n    limittononsuspendedevents?: boolean; // Limit the events to courses the user is not suspended in.\n    userid?: number; // The user id.\n    searchvalue?: string; // The value a user wishes to search against.\n};\n\n/**\n * Data returned by calendar's events_same_course_exporter.\n */\nexport type AddonCalendarEventsSameCourse = AddonCalendarEvents & {\n    courseid: number; // Courseid.\n};\n\n/**\n * Data returned by calendar's event_exporter_base.\n */\nexport type AddonCalendarEventBase = {\n    id: number; // Id.\n    name: string; // Name.\n    description?: string; // Description.\n    descriptionformat?: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    location?: string; // @since 3.6. Location.\n    categoryid?: number; // Categoryid.\n    groupid?: number; // Groupid.\n    userid?: number; // Userid.\n    repeatid?: number; // Repeatid.\n    eventcount?: number; // Eventcount.\n    component?: string; // Component.\n    modulename?: string; // Modulename.\n    activityname?: string; // Activityname.\n    activitystr?: string; // Activitystr.\n    instance?: number; // Instance.\n    eventtype: AddonCalendarEventType | string; // Eventtype.\n    timestart: number; // Timestart.\n    timeduration: number; // Timeduration.\n    timesort: number; // Timesort.\n    timeusermidnight: number; // Timeusermidnight.\n    visible: number; // Visible.\n    timemodified: number; // Timemodified.\n    overdue?: boolean; // Overdue.\n    icon: {\n        key: string; // Key.\n        component: string; // Component.\n        alttext: string; // Alttext.\n        iconurl?: string; // @since 4.2. Icon image url.\n    };\n    category?: {\n        id: number; // Id.\n        name: string; // Name.\n        idnumber: string; // Idnumber.\n        description?: string; // Description.\n        parent: number; // Parent.\n        coursecount: number; // Coursecount.\n        visible: number; // Visible.\n        timemodified: number; // Timemodified.\n        depth: number; // Depth.\n        nestedname: string; // Nestedname.\n        url: string; // Url.\n    };\n    course?: {\n        id: number; // Id.\n        fullname: string; // Fullname.\n        shortname: string; // Shortname.\n        idnumber: string; // Idnumber.\n        summary: string; // Summary.\n        summaryformat: number; // Summary format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n        startdate: number; // Startdate.\n        enddate: number; // Enddate.\n        visible: boolean; // @since 3.8. Visible.\n        fullnamedisplay: string; // Fullnamedisplay.\n        viewurl: string; // Viewurl.\n        courseimage: string; // @since 3.6. Courseimage.\n        progress?: number; // @since 3.6. Progress.\n        hasprogress: boolean; // @since 3.6. Hasprogress.\n        isfavourite: boolean; // @since 3.6. Isfavourite.\n        hidden: boolean; // @since 3.6. Hidden.\n        timeaccess?: number; // @since 3.6. Timeaccess.\n        showshortname: boolean; // @since 3.6. Showshortname.\n        coursecategory: string; // @since 3.7. Coursecategory.\n    };\n    subscription?: {\n        displayeventsource: boolean; // Displayeventsource.\n        subscriptionname?: string; // Subscriptionname.\n        subscriptionurl?: string; // Subscriptionurl.\n    };\n    canedit: boolean; // Canedit.\n    candelete: boolean; // Candelete.\n    deleteurl: string; // Deleteurl.\n    editurl: string; // Editurl.\n    viewurl: string; // Viewurl.\n    formattedtime: string; // Formattedtime.\n    isactionevent: boolean; // Isactionevent.\n    iscourseevent: boolean; // Iscourseevent.\n    iscategoryevent: boolean; // Iscategoryevent.\n    groupname?: string; // Groupname.\n    normalisedeventtype: string; // @since 3.7. Normalisedeventtype.\n    normalisedeventtypetext: string; // @since 3.7. Normalisedeventtypetext.\n};\n\n/**\n * Data returned by calendar's event_exporter. Don't confuse it with AddonCalendarCalendarEvent.\n */\nexport type AddonCalendarEvent = AddonCalendarEventBase & {\n    url: string; // Url.\n    purpose?: string; // Purpose. @since 4.0\n    action?: {\n        name: string; // Name.\n        url: string; // Url.\n        itemcount: number; // Itemcount.\n        actionable: boolean; // Actionable.\n        showitemcount: boolean; // Showitemcount.\n    };\n};\n\n/**\n * Data returned by calendar's calendar_event_exporter. Don't confuse it with AddonCalendarEvent.\n */\nexport type AddonCalendarCalendarEvent = AddonCalendarEventBase & {\n    url: string; // Url.\n    islastday: boolean; // Islastday.\n    popupname: string; // Popupname.\n    mindaytimestamp?: number; // Mindaytimestamp.\n    mindayerror?: string; // Mindayerror.\n    maxdaytimestamp?: number; // Maxdaytimestamp.\n    maxdayerror?: string; // Maxdayerror.\n    draggable: boolean; // Draggable.\n};\n\n/**\n * Any of the possible types of events.\n */\nexport type AddonCalendarAnyEvent = AddonCalendarGetEventsEvent | AddonCalendarEvent | AddonCalendarCalendarEvent;\n\n/**\n * Data returned by calendar's calendar_day_exporter. Don't confuse it with AddonCalendarDay.\n */\nexport type AddonCalendarCalendarDay = {\n    events: AddonCalendarCalendarEvent[]; // Events.\n    defaulteventcontext: number; // Defaulteventcontext.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    filter_selector: string; // Filter_selector.\n    courseid: number; // Courseid.\n    categoryid?: number; // Categoryid.\n    neweventtimestamp: number; // Neweventtimestamp.\n    date: CoreWSDate;\n    periodname: string; // Periodname.\n    previousperiod: CoreWSDate;\n    previousperiodlink: string; // Previousperiodlink.\n    previousperiodname: string; // Previousperiodname.\n    nextperiod: CoreWSDate;\n    nextperiodname: string; // Nextperiodname.\n    nextperiodlink: string; // Nextperiodlink.\n    larrow: string; // Larrow.\n    rarrow: string; // Rarrow.\n};\n\n/**\n * Params of core_calendar_get_calendar_monthly_view WS.\n */\nexport type AddonCalendarGetCalendarMonthlyViewWSParams = {\n    year: number; // Year to be viewed.\n    month: number; // Month to be viewed.\n    courseid?: number; // Course being viewed.\n    categoryid?: number; // Category being viewed.\n    includenavigation?: boolean; // Whether to show course navigation.\n    mini?: boolean; // Whether to return the mini month view or not.\n    day?: number; // Day to be viewed.\n};\n\n/**\n * Data returned by calendar's month_exporter and core_calendar_get_calendar_monthly_view WS.\n */\nexport type AddonCalendarMonth = {\n    url: string; // Url.\n    courseid: number; // Courseid.\n    categoryid?: number; // Categoryid.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    filter_selector?: string; // Filter_selector.\n    weeks: AddonCalendarWeek[]; // Weeks.\n    daynames: AddonCalendarDayName[]; // Daynames.\n    view: string; // View.\n    date: CoreWSDate;\n    periodname: string; // Periodname.\n    includenavigation: boolean; // Includenavigation.\n    initialeventsloaded: boolean; // Initialeventsloaded.\n    previousperiod: CoreWSDate;\n    previousperiodlink: string; // Previousperiodlink.\n    previousperiodname: string; // Previousperiodname.\n    nextperiod: CoreWSDate;\n    nextperiodname: string; // Nextperiodname.\n    nextperiodlink: string; // Nextperiodlink.\n    larrow: string; // Larrow.\n    rarrow: string; // Rarrow.\n    defaulteventcontext: number; // Defaulteventcontext.\n};\n\n/**\n * Data returned by calendar's week_exporter.\n */\nexport type AddonCalendarWeek = {\n    prepadding: number[]; // Prepadding.\n    postpadding: number[]; // Postpadding.\n    days: AddonCalendarWeekDay[]; // Days.\n};\n\n/**\n * Data returned by calendar's week_day_exporter.\n */\nexport type AddonCalendarWeekDay = AddonCalendarDay & {\n    istoday: boolean; // Istoday.\n    isweekend: boolean; // Isweekend.\n    popovertitle: string; // Popovertitle.\n    ispast?: boolean; // Calculated in the app. Whether the day is in the past.\n    filteredEvents?: AddonCalendarEventToDisplay[]; // Calculated in the app. Filtered events.\n    eventsFormated?: AddonCalendarEventToDisplay[]; // Events.\n    periodName?: string;\n};\n\n/**\n * Data returned by calendar's day_exporter. Don't confuse it with AddonCalendarCalendarDay.\n */\nexport type AddonCalendarDay = {\n    seconds: number; // Seconds.\n    minutes: number; // Minutes.\n    hours: number; // Hours.\n    mday: number; // Mday.\n    wday: number; // Wday.\n    year: number; // Year.\n    yday: number; // Yday.\n    timestamp: number; // Timestamp.\n    neweventtimestamp: number; // Neweventtimestamp.\n    viewdaylink?: string; // Viewdaylink.\n    events: AddonCalendarCalendarEvent[]; // Events.\n    hasevents: boolean; // Hasevents.\n    calendareventtypes: AddonCalendarEventType[]; // Calendareventtypes.\n    previousperiod: number; // Previousperiod.\n    nextperiod: number; // Nextperiod.\n    navigation: string; // Navigation.\n    haslastdayofevent: boolean; // Haslastdayofevent.\n};\n\n/**\n * Data returned by calendar's day_name_exporter.\n */\nexport type AddonCalendarDayName = {\n    dayno: number; // Dayno.\n    shortname: string; // Shortname.\n    fullname: string; // Fullname.\n};\n\n/**\n * Params of core_calendar_get_calendar_upcoming_view WS.\n */\ntype AddonCalendarGetCalendarUpcomingViewWSParams = {\n    courseid?: number; // Course being viewed.\n    categoryid?: number; // Category being viewed.\n};\n\n/**\n * Data returned by calendar's calendar_upcoming_exporter and core_calendar_get_calendar_upcoming_view WS.\n */\nexport type AddonCalendarUpcoming = {\n    events: AddonCalendarCalendarEvent[]; // Events.\n    defaulteventcontext: number; // Defaulteventcontext.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    filter_selector: string; // Filter_selector.\n    courseid: number; // Courseid.\n    categoryid?: number; // Categoryid.\n    isloggedin: boolean; // Isloggedin.\n    date: CoreWSDate; // @since 3.8. Date.\n};\n\n/**\n * Params of core_calendar_get_calendar_access_information WS.\n */\ntype AddonCalendarGetCalendarAccessInformationWSParams = {\n    courseid?: number; // Course to check, empty for site calendar events.\n};\n\n/**\n * Data returned by core_calendar_get_calendar_access_information WS.\n */\nexport type AddonCalendarGetCalendarAccessInformationWSResponse = {\n    canmanageentries: boolean; // Whether the user can manage entries.\n    canmanageownentries: boolean; // Whether the user can manage its own entries.\n    canmanagegroupentries: boolean; // Whether the user can manage group entries.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_calendar_get_allowed_event_types WS.\n */\ntype AddonCalendarGetAllowedEventTypesWSParams = {\n    courseid?: number; // Course to check, empty for site.\n};\n\n/**\n * Data returned by core_calendar_get_allowed_event_types WS.\n */\nexport type AddonCalendarGetAllowedEventTypesWSResponse = {\n    allowedeventtypes: AddonCalendarEventType[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_calendar_get_calendar_events WS.\n */\ntype AddonCalendarGetCalendarEventsWSParams = {\n    events?: {\n        eventids?: number[]; // List of event ids.\n        courseids?: number[]; // List of course ids for which events will be returned.\n        groupids?: number[]; // List of group ids for which events should be returned.\n        categoryids?: number[]; // List of category ids for which events will be returned.\n    }; // Event details.\n    options?: {\n        userevents?: boolean; // Set to true to return current user's user events.\n        siteevents?: boolean; // Set to true to return site events.\n        timestart?: number; // Time from which events should be returned.\n        timeend?: number; // Time to which the events should be returned. We treat 0 and null as no end.\n        ignorehidden?: boolean; // Ignore hidden events or not.\n    }; // Options.\n};\n\n/**\n * Data returned by core_calendar_get_calendar_events WS.\n */\nexport type AddonCalendarGetCalendarEventsWSResponse = {\n    events: AddonCalendarGetEventsEvent[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Event data returned by WS core_calendar_get_calendar_events.\n */\nexport type AddonCalendarGetEventsEvent = {\n    id: number; // Event id.\n    name: string; // Event name.\n    description?: string; // Description.\n    format: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    courseid: number; // Course id.\n    categoryid?: number; // Category id (only for category events).\n    groupid: number; // Group id.\n    userid: number; // User id.\n    repeatid: number; // Repeat id.\n    modulename?: string; // Module name.\n    instance: number; // Instance id.\n    eventtype: AddonCalendarEventType; // Event type.\n    timestart: number; // Timestart.\n    timeduration: number; // Time duration.\n    visible: number; // Visible.\n    uuid?: string; // Unique id of ical events.\n    sequence: number; // Sequence.\n    timemodified: number; // Time modified.\n    subscriptionid?: number; // Subscription id.\n};\n\n/**\n * Params of core_calendar_get_calendar_event_by_id WS.\n */\ntype AddonCalendarGetCalendarEventByIdWSParams = {\n    eventid: number; // The event id to be retrieved.\n};\n\n/**\n * Data returned by core_calendar_get_calendar_event_by_id WS.\n */\nexport type AddonCalendarGetCalendarEventByIdWSResponse = {\n    event: AddonCalendarEvent; // Event.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result of WS core_calendar_submit_create_update_form.\n */\nexport type AddonCalendarSubmitCreateUpdateFormResult = {\n    event?: AddonCalendarEvent; // Event.\n    validationerror: boolean; // Invalid form data.\n};\n\n/**\n * Params of core_calendar_delete_calendar_events WS.\n */\ntype AddonCalendarDeleteCalendarEventsWSParams = {\n    events: {\n        eventid: number; // Event ID.\n        repeat: boolean; // Delete comeplete series if repeated event.\n    }[];\n};\n\n/**\n * Params of core_calendar_get_calendar_day_view WS.\n */\ntype AddonCalendarGetCalendarDayViewWSParams = {\n    year: number; // Year to be viewed.\n    month: number; // Month to be viewed.\n    day: number; // Day to be viewed.\n    courseid?: number; // Course being viewed.\n    categoryid?: number; // Category being viewed.\n};\n\n/**\n * Params of core_calendar_submit_create_update_form WS.\n */\ntype AddonCalendarSubmitCreateUpdateFormWSParams = {\n    formdata: string; // The data from the event form. See @AddonCalendarSubmitCreateUpdateFormDataWSParams\n};\n\n/**\n * Form data on AddonCalendarSubmitCreateUpdateFormWSParams.\n */\nexport type AddonCalendarSubmitCreateUpdateFormDataWSParams = Omit<AddonCalendarOfflineEventDBRecord, 'id'|'description'> & {\n    id?: number;\n    description?: {\n        text: string;\n        format: number;\n        itemid: number; // File area ID.\n    };\n    visible?: number;\n    instance?: number;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    _qf__core_calendar_local_event_forms_update?: number;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    _qf__core_calendar_local_event_forms_create?: number;\n};\n\n/**\n * Data returned by core_calendar_submit_create_update_form WS.\n */\nexport type AddonCalendarSubmitCreateUpdateFormWSResponse = {\n    event?: AddonCalendarEvent;\n    validationerror?: boolean; // Invalid form data.\n};\n\nexport type AddonCalendarWeekDaysTranslationKeys = { shortname: string; fullname: string };\n\nexport type AddonCalendarEventToDisplay = Partial<AddonCalendarCalendarEvent> & {\n    id: number;\n    name: string;\n    timestart: number;\n    timeduration: number;\n    eventcount: number;\n    eventtype: AddonCalendarEventType | string;\n    courseid?: number;\n    offline?: boolean;\n    showDate?: boolean; // Calculated in the app. Whether date should be shown before this event.\n    endsSameDay?: boolean; // Calculated in the app. Whether the event finishes the same day it starts.\n    deleted?: boolean; // Calculated in the app. Whether it has been deleted in offline.\n    encodedLocation?: SafeUrl; // Calculated in the app. Sanitized location link.\n    eventIcon?: string; // Calculated in the app. Event icon.\n    iconTitle?: string;\n    moduleIcon?: string; // Calculated in the app. Module icon.\n    formattedType: string; // Calculated in the app. Formatted type.\n    duration?: number; // Calculated in the app. Duration of offline event.\n    format?: number; // Calculated in the app. Format of offline event.\n    timedurationuntil?: number; // Calculated in the app. Time duration until of offline event.\n    timedurationminutes?: number; // Calculated in the app. Time duration in minutes of offline event.\n    ispast?: boolean; // Calculated in the app. Whether the event is in the past.\n    contextLevel?: ContextLevel;\n    contextInstanceId?: number;\n    purpose?: string; // Purpose. @since 4.0\n};\n\n/**\n * Event triggered when an event is modified with event types:\n * NEW_EVENT_EVENT, EDIT_EVENT_EVENT, DELETED_EVENT_EVENT, UNDELETED_EVENT_EVENT.\n */\nexport type AddonCalendarUpdatedEventEvent = {\n    eventId: number;\n    oldEventId?: number; // Old event ID. Used when an offline event is sent.\n    sent?: boolean;\n};\n\n/**\n * Value and unit for reminders.\n *\n * @deprecated since 4.1, use CoreReminderValueAndUnit instead.\n */\nexport type AddonCalendarValueAndUnit = CoreReminderValueAndUnit;\n\n/**\n * Options to pass to submit event.\n */\nexport type AddonCalendarSubmitEventOptions = {\n    reminders?: {\n        time?: number;\n    }[];\n    forceOffline?: boolean;\n    siteId?: string; // Site ID. If not defined, current site.\n};\n\n/**\n * Options to pass to store events in local DB.\n */\nexport type AddonCalendarStoreEventsOptions = {\n    addDefaultReminder?: boolean; // Whether to add default reminder for new events with no reminders. Defaults to true.\n    siteId?: string; // Site ID. If not defined, current site.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}