{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreNetwork } from '@services/network';\nimport { CoreDB } from '@services/db';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreFile } from '@services/file';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreLogger } from '@singletons/logger';\nimport { Translate } from '@singletons';\nimport { CoreSites } from '@services/sites';\nimport { asyncInstance } from '../../utils/async-instance';\nimport { CoreDatabaseCachingStrategy } from '../database/database-table-proxy';\nimport { CONFIG_TABLE, LAST_VIEWED_TABLE, WS_CACHE_TABLE } from '@services/database/sites';\nimport { map } from 'rxjs/operators';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreAuthenticatedSite } from './authenticated-site';\nimport { firstValueFrom } from 'rxjs';\n/**\n * Class that represents a site (combination of site + user).\n * It will have all the site data and provide utility functions regarding a site.\n */\nexport class CoreSite extends CoreAuthenticatedSite {\n  /**\n   * Create a site.\n   *\n   * @param id Site ID.\n   * @param siteUrl Site URL.\n   * @param token Site's WS token.\n   * @param otherData Other data.\n   */\n  constructor(id, siteUrl, token, otherData = {}) {\n    super(siteUrl, token, otherData);\n    this.lastAutoLogin = 0;\n    this.id = id;\n    this.config = otherData.config;\n    this.loggedOut = otherData.loggedOut;\n    this.logger = CoreLogger.getInstance('CoreSite');\n    this.cacheTable = asyncInstance(() => CoreSites.getSiteTable(WS_CACHE_TABLE, {\n      siteId: this.getId(),\n      database: this.getDb(),\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.None\n      }\n    }));\n    this.configTable = asyncInstance(() => CoreSites.getSiteTable(CONFIG_TABLE, {\n      siteId: this.getId(),\n      database: this.getDb(),\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.Eager\n      },\n      primaryKeyColumns: ['name']\n    }));\n    this.lastViewedTable = asyncInstance(() => CoreSites.getSiteTable(LAST_VIEWED_TABLE, {\n      siteId: this.getId(),\n      database: this.getDb(),\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.Eager\n      },\n      primaryKeyColumns: ['component', 'id']\n    }));\n    this.setInfo(otherData.info);\n    this.calculateOfflineDisabled();\n    this.db = CoreDB.getDB('Site-' + this.id);\n  }\n  /**\n   * Get site ID.\n   *\n   * @returns Site ID.\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Get site DB.\n   *\n   * @returns Site DB.\n   */\n  getDb() {\n    return this.db;\n  }\n  /**\n   * Check if user logged out from the site and needs to authenticate again.\n   *\n   * @returns Whether is logged out.\n   */\n  isLoggedOut() {\n    return !!this.loggedOut;\n  }\n  /**\n   * Get OAuth ID.\n   *\n   * @returns OAuth ID.\n   */\n  getOAuthId() {\n    return this.oauthId;\n  }\n  /**\n   * Set site config.\n   *\n   * @param config Config.\n   */\n  setConfig(config) {\n    if (config) {\n      config.tool_mobile_disabledfeatures = CoreTextUtils.treatDisabledFeatures(config.tool_mobile_disabledfeatures);\n    }\n    this.config = config;\n    this.calculateOfflineDisabled();\n  }\n  /**\n   * Set site logged out.\n   *\n   * @param loggedOut True if logged out and needs to authenticate again, false otherwise.\n   */\n  setLoggedOut(loggedOut) {\n    this.loggedOut = !!loggedOut;\n  }\n  /**\n   * Set OAuth ID.\n   *\n   * @param oauthId OAuth ID.\n   */\n  setOAuthId(oauthId) {\n    this.oauthId = oauthId;\n  }\n  /**\n   * Check if the user authenticated in the site using an OAuth method.\n   *\n   * @returns Whether the user authenticated in the site using an OAuth method.\n   */\n  isOAuth() {\n    return this.oauthId != null && this.oauthId !== undefined;\n  }\n  /**\n   * @inheritdoc\n   */\n  getCacheEntryById(id) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.cacheTable.getOneByPrimaryKey({\n        id\n      });\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  getCacheEntriesByKey(key) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.cacheTable.getMany({\n        key\n      });\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  storeCacheEntry(entry) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield _this3.cacheTable.insert(entry);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  deleteFromCache(method, data, preSets, allCacheKey) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (allCacheKey) {\n        yield _this4.cacheTable.delete({\n          key: preSets.cacheKey\n        });\n      } else {\n        yield _this4.cacheTable.deleteByPrimaryKey({\n          id: _this4.getCacheId(method, data)\n        });\n      }\n    })();\n  }\n  /**\n   * Gets the size of cached data for a specific component or component instance.\n   *\n   * @param component Component name\n   * @param componentId Optional component id (if not included, returns sum for whole component)\n   * @returns Promise resolved when we have calculated the size\n   */\n  getComponentCacheSize(component, componentId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const params = [component];\n      let extraClause = '';\n      if (componentId !== undefined && componentId !== null) {\n        params.push(componentId);\n        extraClause = ' AND componentId = ?';\n      }\n      return _this5.cacheTable.reduce({\n        sql: 'SUM(length(data))',\n        js: (size, record) => size + record.data.length,\n        jsInitialValue: 0\n      }, {\n        sql: 'WHERE component = ?' + extraClause,\n        sqlParams: params,\n        js: record => record.component === component && (params.length === 1 || record.componentId === componentId)\n      });\n    })();\n  }\n  /**\n   * Deletes WS cache entries for all methods relating to a specific component (and\n   * optionally component id).\n   *\n   * @param component Component name.\n   * @param componentId Component id.\n   * @returns Promise resolved when the entries are deleted.\n   */\n  deleteComponentFromCache(component, componentId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (!component) {\n        return;\n      }\n      const params = {\n        component\n      };\n      if (componentId) {\n        params['componentId'] = componentId;\n      }\n      yield _this6.cacheTable.delete(params);\n    })();\n  }\n  /*\n   * Uploads a file using Cordova File API.\n   *\n   * @param filePath File path.\n   * @param options File upload options.\n   * @param onProgress Function to call on progress.\n   * @returns Promise resolved when uploaded.\n   */\n  uploadFile(filePath, options, onProgress) {\n    if (!options.fileArea) {\n      options.fileArea = 'draft';\n    }\n    return CoreWS.uploadFile(filePath, options, {\n      siteUrl: this.siteUrl,\n      wsToken: this.token || ''\n    }, onProgress);\n  }\n  /**\n   * Invalidates all caches related to the site.\n   */\n  invalidateCaches() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all([CoreFilepool.invalidateAllFiles(_this7.getId()), _this7.invalidateWsCache()]);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateWsCache() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      _this8.logger.debug('Invalidate all the cache for site: ' + _this8.id);\n      try {\n        yield _this8.cacheTable.update({\n          expirationTime: 0\n        });\n      } finally {\n        CoreEvents.trigger(CoreEvents.WS_CACHE_INVALIDATED, {}, _this8.getId());\n      }\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateWsCacheForKey(key) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (!key) {\n        return;\n      }\n      _this9.logger.debug('Invalidate cache for key: ' + key);\n      yield _this9.cacheTable.update({\n        expirationTime: 0\n      }, {\n        key\n      });\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateWsCacheForKeyStartingWith(key) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      if (!key) {\n        return;\n      }\n      _this10.logger.debug('Invalidate cache for key starting with: ' + key);\n      yield _this10.cacheTable.updateWhere({\n        expirationTime: 0\n      }, {\n        sql: 'key LIKE ?',\n        sqlParams: [key + '%'],\n        js: record => {\n          var _record$key;\n          return !!((_record$key = record.key) !== null && _record$key !== void 0 && _record$key.startsWith(key));\n        }\n      });\n    })();\n  }\n  /**\n   * Check if tokenpluginfile can be used, and fix the URL afterwards.\n   *\n   * @param url The url to be fixed.\n   * @returns Promise resolved with the fixed URL.\n   */\n  checkAndFixPluginfileURL(url) {\n    return this.checkTokenPluginFile(url).then(() => this.fixPluginfileURL(url));\n  }\n  /**\n   * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.\n   * Uses CoreUtilsProvider.fixPluginfileURL, passing site's token.\n   *\n   * @param url The url to be fixed.\n   * @returns Fixed URL.\n   */\n  fixPluginfileURL(url) {\n    const accessKey = this.tokenPluginFileWorks || this.tokenPluginFileWorks === undefined ? this.infos && this.infos.userprivateaccesskey : undefined;\n    return CoreUrlUtils.fixPluginfileURL(url, this.token || '', this.siteUrl, accessKey);\n  }\n  /**\n   * Deletes site's DB.\n   *\n   * @returns Promise to be resolved when the DB is deleted.\n   */\n  deleteDB() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreDB.deleteDB('Site-' + _this11.id);\n    })();\n  }\n  /**\n   * Deletes site's folder.\n   *\n   * @returns Promise to be resolved when the DB is deleted.\n   */\n  deleteFolder() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreFile.isAvailable() || !_this12.id) {\n        return;\n      }\n      const siteFolder = CoreFile.getSiteFolder(_this12.id);\n      // Ignore any errors, removeDir fails if folder doesn't exists.\n      yield CoreUtils.ignoreErrors(CoreFile.removeDir(siteFolder));\n    })();\n  }\n  /**\n   * Get space usage of the site.\n   *\n   * @returns Promise resolved with the site space usage (size).\n   */\n  getSpaceUsage() {\n    if (CoreFile.isAvailable() && this.id) {\n      const siteFolderPath = CoreFile.getSiteFolder(this.id);\n      return CoreFile.getDirectorySize(siteFolderPath).catch(() => 0);\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n  /**\n   * Gets an approximation of the cache table usage of the site.\n   *\n   * Currently this is just the total length of the data fields in the cache table.\n   *\n   * @returns Promise resolved with the total size of all data in the cache table (bytes)\n   */\n  getCacheUsage() {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      return _this13.cacheTable.reduce({\n        sql: 'SUM(length(data))',\n        js: (size, record) => size + record.data.length,\n        jsInitialValue: 0\n      });\n    })();\n  }\n  /**\n   * Gets a total of the file and cache usage.\n   *\n   * @returns Promise with the total of getSpaceUsage and getCacheUsage\n   */\n  getTotalUsage() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const space = yield _this14.getSpaceUsage();\n      const cache = yield _this14.getCacheUsage();\n      return space + cache;\n    })();\n  }\n  /**\n   * Check if GET method is supported for AJAX calls.\n   *\n   * @returns Whether it's supported.\n   */\n  isAjaxGetSupported() {\n    return !!this.getInfo() && this.isVersionGreaterEqualThan('3.8');\n  }\n  /**\n   * Open a URL in browser using auto-login in the Moodle site if available.\n   *\n   * @param url The URL to open.\n   * @param alertMessage If defined, an alert will be shown before opening the browser.\n   * @param options Other options.\n   * @returns Promise resolved when done, rejected otherwise.\n   */\n  openInBrowserWithAutoLogin(url, alertMessage, options = {}) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      yield _this15.openWithAutoLogin(false, url, options, alertMessage);\n    })();\n  }\n  /**\n   * Open a URL in browser using auto-login in the Moodle site if available and the URL belongs to the site.\n   *\n   * @param url The URL to open.\n   * @param alertMessage If defined, an alert will be shown before opening the browser.\n   * @param options Other options.\n   * @returns Promise resolved when done, rejected otherwise.\n   * @deprecated since 4.1. Use openInBrowserWithAutoLogin instead, now it always checks that URL belongs to same site.\n   */\n  openInBrowserWithAutoLoginIfSameSite(url, alertMessage, options = {}) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      return _this16.openInBrowserWithAutoLogin(url, alertMessage, options);\n    })();\n  }\n  /**\n   * Open a URL in inappbrowser using auto-login in the Moodle site if available.\n   *\n   * @param url The URL to open.\n   * @param options Override default options passed to InAppBrowser.\n   * @param alertMessage If defined, an alert will be shown before opening the inappbrowser.\n   * @returns Promise resolved when done.\n   */\n  openInAppWithAutoLogin(url, options, alertMessage) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const iabInstance = yield _this17.openWithAutoLogin(true, url, options, alertMessage);\n      return iabInstance;\n    })();\n  }\n  /**\n   * Open a URL in inappbrowser using auto-login in the Moodle site if available and the URL belongs to the site.\n   *\n   * @param url The URL to open.\n   * @param options Override default options passed to inappbrowser.\n   * @param alertMessage If defined, an alert will be shown before opening the inappbrowser.\n   * @returns Promise resolved when done.\n   * @deprecated since 4.1. Use openInAppWithAutoLogin instead, now it always checks that URL belongs to same site.\n   */\n  openInAppWithAutoLoginIfSameSite(url, options, alertMessage) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      return _this18.openInAppWithAutoLogin(url, options, alertMessage);\n    })();\n  }\n  /**\n   * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available.\n   *\n   * @param inApp True to open it in InAppBrowser, false to open in browser.\n   * @param url The URL to open.\n   * @param options Override default options passed to $cordovaInAppBrowser#open.\n   * @param alertMessage If defined, an alert will be shown before opening the browser/inappbrowser.\n   * @returns Promise resolved when done. Resolve param is returned only if inApp=true.\n   */\n  openWithAutoLogin(inApp, url, options = {}, alertMessage) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      // Get the URL to open.\n      const autoLoginUrl = yield _this19.getAutoLoginUrl(url);\n      if (alertMessage) {\n        // Show an alert first.\n        const alert = yield CoreDomUtils.showAlert(Translate.instant('core.notice'), alertMessage, undefined, 3000);\n        yield alert.onDidDismiss();\n        options.showBrowserWarning = false; // A warning already shown, no need to show another.\n      }\n\n      options.originalUrl = url;\n      // Open the URL.\n      if (inApp) {\n        return CoreUtils.openInApp(autoLoginUrl, options);\n      } else {\n        return CoreUtils.openInBrowser(autoLoginUrl, options);\n      }\n    })();\n  }\n  /**\n   * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available and the URL belongs to the site.\n   *\n   * @param inApp True to open it in InAppBrowser, false to open in browser.\n   * @param url The URL to open.\n   * @param options Override default options passed to inappbrowser.\n   * @param alertMessage If defined, an alert will be shown before opening the browser/inappbrowser.\n   * @returns Promise resolved when done. Resolve param is returned only if inApp=true.\n   * @deprecated since 4.1. Use openWithAutoLogin instead, now it always checks that URL belongs to same site.\n   */\n  openWithAutoLoginIfSameSite(inApp, url, options = {}, alertMessage) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      return _this20.openWithAutoLogin(inApp, url, options, alertMessage);\n    })();\n  }\n  getConfig(name, ignoreCache) {\n    return firstValueFrom(this.getConfigObservable(name, ignoreCache ? 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */ : undefined));\n  }\n  getConfigObservable(name, readingStrategy) {\n    const preSets = _objectSpread({\n      cacheKey: this.getConfigCacheKey()\n    }, CoreSites.getReadingStrategyPreSets(readingStrategy));\n    return this.readObservable('tool_mobile_get_config', {}, preSets).pipe(map(config => {\n      if (name) {\n        // Return the requested setting.\n        for (const x in config.settings) {\n          if (config.settings[x].name == name) {\n            return String(config.settings[x].value);\n          }\n        }\n        throw new CoreError('Site config not found: ' + name);\n      } else {\n        // Return all settings in the same array.\n        const settings = {};\n        config.settings.forEach(setting => {\n          settings[setting.name] = String(setting.value);\n        });\n        return settings;\n      }\n    }));\n  }\n  /**\n   * Invalidates config WS call.\n   *\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateConfig() {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      yield _this21.invalidateWsCacheForKey(_this21.getConfigCacheKey());\n    })();\n  }\n  /**\n   * Get cache key for getConfig WS calls.\n   *\n   * @returns Cache key.\n   */\n  getConfigCacheKey() {\n    return 'tool_mobile_get_config';\n  }\n  getStoredConfig(name) {\n    if (!this.config) {\n      return;\n    }\n    if (name) {\n      return this.config[name];\n    } else {\n      return this.config;\n    }\n  }\n  /**\n   * @inheritdoc\n   */\n  getDisabledFeatures() {\n    return this.config ? this.getStoredConfig('tool_mobile_disabledfeatures') : super.getDisabledFeatures();\n  }\n  /**\n   * @inheritdoc\n   */\n  triggerSiteEvent(eventName, data) {\n    CoreEvents.trigger(eventName, data, this.id);\n  }\n  /**\n   * Calculate if offline is disabled in the site.\n   */\n  calculateOfflineDisabled() {\n    this.offlineDisabled = this.isFeatureDisabled('NoDelegate_CoreOffline');\n  }\n  /**\n   * Get whether offline is disabled in the site.\n   *\n   * @returns Whether it's disabled.\n   */\n  isOfflineDisabled() {\n    return this.offlineDisabled;\n  }\n  /**\n   * Given a URL, convert it to a URL that will auto-login if supported.\n   *\n   * @param url The URL to convert.\n   * @param showModal Whether to show a loading modal.\n   * @returns Promise resolved with the converted URL.\n   */\n  getAutoLoginUrl(url, showModal = true) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this22.privateToken) {\n        // No private token, don't change the URL.\n        return url;\n      }\n      if (!_this22.containsUrl(url)) {\n        // URL doesn't belong to the site, don't auto login.\n        return url;\n      }\n      if (_this22.lastAutoLogin > 0) {\n        const timeBetweenRequests = yield CoreUtils.ignoreErrors(_this22.getConfig('tool_mobile_autologinmintimebetweenreq'), CoreConstants.SECONDS_MINUTE * 6);\n        if (CoreTimeUtils.timestamp() - _this22.lastAutoLogin < Number(timeBetweenRequests)) {\n          // Not enough time has passed since last auto login.\n          return url;\n        }\n      }\n      const userId = _this22.getUserId();\n      const params = {\n        privatetoken: _this22.privateToken\n      };\n      let modal;\n      if (showModal) {\n        modal = yield CoreDomUtils.showModalLoading();\n      }\n      try {\n        // Use write to not use cache.\n        const data = yield _this22.write('tool_mobile_get_autologin_key', params);\n        if (!data.autologinurl || !data.key) {\n          // Not valid data, return the same URL.\n          return url;\n        }\n        _this22.lastAutoLogin = CoreTimeUtils.timestamp();\n        return data.autologinurl + '?userid=' + userId + '&key=' + data.key + '&urltogo=' + encodeURIComponent(url);\n      } catch (error) {\n        // Couldn't get autologin key, return the same URL.\n        return url;\n      } finally {\n        var _modal;\n        (_modal = modal) === null || _modal === void 0 || _modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Deletes a site setting.\n   *\n   * @param name The config name.\n   * @returns Promise resolved when done.\n   */\n  deleteSiteConfig(name) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      yield _this23.configTable.deleteByPrimaryKey({\n        name\n      });\n    })();\n  }\n  /**\n   * Get a site setting on local device.\n   *\n   * @param name The config name.\n   * @param defaultValue Default value to use if the entry is not found.\n   * @returns Resolves upon success along with the config data. Reject on failure.\n   */\n  getLocalSiteConfig(name, defaultValue) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const entry = yield _this24.configTable.getOneByPrimaryKey({\n          name\n        });\n        return entry.value;\n      } catch (error) {\n        if (defaultValue !== undefined) {\n          return defaultValue;\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Set a site setting on local device.\n   *\n   * @param name The config name.\n   * @param value The config value. Can only store number or strings.\n   * @returns Promise resolved when done.\n   */\n  setLocalSiteConfig(name, value) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      yield _this25.configTable.insert({\n        name,\n        value\n      });\n    })();\n  }\n  /*\n   * Check if tokenpluginfile script works in the site.\n   *\n   * @param url URL to check.\n   * @returns Promise resolved with boolean: whether it works or not.\n   */\n  checkTokenPluginFile(url) {\n    if (!CoreUrlUtils.canUseTokenPluginFile(url, this.siteUrl, this.infos && this.infos.userprivateaccesskey)) {\n      // Cannot use tokenpluginfile.\n      return Promise.resolve(false);\n    } else if (this.tokenPluginFileWorks !== undefined) {\n      // Already checked.\n      return Promise.resolve(this.tokenPluginFileWorks);\n    } else if (this.tokenPluginFileWorksPromise) {\n      // Check ongoing, use the same promise.\n      return this.tokenPluginFileWorksPromise;\n    } else if (!CoreNetwork.isOnline()) {\n      // Not online, cannot check it. Assume it's working, but don't save the result.\n      return Promise.resolve(true);\n    }\n    url = this.fixPluginfileURL(url);\n    this.tokenPluginFileWorksPromise = CoreWS.urlWorks(url).then(result => {\n      this.tokenPluginFileWorks = result;\n      return result;\n    });\n    return this.tokenPluginFileWorksPromise;\n  }\n  /**\n   * Deletes last viewed records based on some conditions.\n   *\n   * @param conditions Conditions.\n   * @returns Promise resolved when done.\n   */\n  deleteLastViewed(conditions) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      yield _this26.lastViewedTable.delete(conditions);\n    })();\n  }\n  /**\n   * Get a last viewed record for a component+id.\n   *\n   * @param component The component.\n   * @param id ID.\n   * @returns Resolves with last viewed record, undefined if not found.\n   */\n  getLastViewed(component, id) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this27.lastViewedTable.getOneByPrimaryKey({\n          component,\n          id\n        });\n      } catch (_unused) {\n        // Not found.\n      }\n    })();\n  }\n  /**\n   * Get several last viewed for a certain component.\n   *\n   * @param component The component.\n   * @param ids IDs. If not provided or empty, return all last viewed for a component.\n   * @returns Resolves with last viewed records, undefined if error.\n   */\n  getComponentLastViewed(component, ids = []) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (!ids.length) {\n          return yield _this28.lastViewedTable.getMany({\n            component\n          });\n        }\n        const whereAndParams = SQLiteDB.getInOrEqual(ids);\n        whereAndParams.sql = 'id ' + whereAndParams.sql + ' AND component = ?';\n        whereAndParams.params.push(component);\n        return yield _this28.lastViewedTable.getManyWhere({\n          sql: whereAndParams.sql,\n          sqlParams: whereAndParams.params,\n          js: record => record.component === component && ids.includes(record.id)\n        });\n      } catch (_unused2) {\n        // Not found.\n      }\n    })();\n  }\n  /**\n   * Store a last viewed record.\n   *\n   * @param component The component.\n   * @param id ID.\n   * @param value Last viewed item value.\n   * @param options Options.\n   * @returns Promise resolved when done.\n   */\n  storeLastViewed(component, id, value, options = {}) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      var _options$timeaccess;\n      yield _this29.lastViewedTable.insert({\n        component,\n        id,\n        value: String(value),\n        data: options.data,\n        timeaccess: (_options$timeaccess = options.timeaccess) !== null && _options$timeaccess !== void 0 ? _options$timeaccess : Date.now()\n      });\n    })();\n  }\n}","map":{"version":3,"names":["CoreNetwork","CoreDB","CoreEvents","CoreFile","CoreWS","CoreDomUtils","CoreTextUtils","CoreTimeUtils","CoreUrlUtils","CoreUtils","CoreConstants","SQLiteDB","CoreError","CoreLogger","Translate","CoreSites","asyncInstance","CoreDatabaseCachingStrategy","CONFIG_TABLE","LAST_VIEWED_TABLE","WS_CACHE_TABLE","map","CoreFilepool","CoreAuthenticatedSite","firstValueFrom","CoreSite","constructor","id","siteUrl","token","otherData","lastAutoLogin","config","loggedOut","logger","getInstance","cacheTable","getSiteTable","siteId","getId","database","getDb","cachingStrategy","None","configTable","Eager","primaryKeyColumns","lastViewedTable","setInfo","info","calculateOfflineDisabled","db","getDB","isLoggedOut","getOAuthId","oauthId","setConfig","tool_mobile_disabledfeatures","treatDisabledFeatures","setLoggedOut","setOAuthId","isOAuth","undefined","getCacheEntryById","_this","_asyncToGenerator","getOneByPrimaryKey","getCacheEntriesByKey","key","_this2","getMany","storeCacheEntry","entry","_this3","insert","deleteFromCache","method","data","preSets","allCacheKey","_this4","delete","cacheKey","deleteByPrimaryKey","getCacheId","getComponentCacheSize","component","componentId","_this5","params","extraClause","push","reduce","sql","js","size","record","length","jsInitialValue","sqlParams","deleteComponentFromCache","_this6","uploadFile","filePath","options","onProgress","fileArea","wsToken","invalidateCaches","_this7","Promise","all","invalidateAllFiles","invalidateWsCache","_this8","debug","update","expirationTime","trigger","WS_CACHE_INVALIDATED","invalidateWsCacheForKey","_this9","invalidateWsCacheForKeyStartingWith","_this10","updateWhere","_record$key","startsWith","checkAndFixPluginfileURL","url","checkTokenPluginFile","then","fixPluginfileURL","accessKey","tokenPluginFileWorks","infos","userprivateaccesskey","deleteDB","_this11","deleteFolder","_this12","isAvailable","siteFolder","getSiteFolder","ignoreErrors","removeDir","getSpaceUsage","siteFolderPath","getDirectorySize","catch","resolve","getCacheUsage","_this13","getTotalUsage","_this14","space","cache","isAjaxGetSupported","getInfo","isVersionGreaterEqualThan","openInBrowserWithAutoLogin","alertMessage","_this15","openWithAutoLogin","openInBrowserWithAutoLoginIfSameSite","_this16","openInAppWithAutoLogin","_this17","iabInstance","openInAppWithAutoLoginIfSameSite","_this18","inApp","_this19","autoLoginUrl","getAutoLoginUrl","alert","showAlert","instant","onDidDismiss","showBrowserWarning","originalUrl","openInApp","openInBrowser","openWithAutoLoginIfSameSite","_this20","getConfig","name","ignoreCache","getConfigObservable","readingStrategy","_objectSpread","getConfigCacheKey","getReadingStrategyPreSets","readObservable","pipe","x","settings","String","value","forEach","setting","invalidateConfig","_this21","getStoredConfig","getDisabledFeatures","triggerSiteEvent","eventName","offlineDisabled","isFeatureDisabled","isOfflineDisabled","showModal","_this22","privateToken","containsUrl","timeBetweenRequests","SECONDS_MINUTE","timestamp","Number","userId","getUserId","privatetoken","modal","showModalLoading","write","autologinurl","encodeURIComponent","error","_modal","dismiss","deleteSiteConfig","_this23","getLocalSiteConfig","defaultValue","_this24","setLocalSiteConfig","_this25","canUseTokenPluginFile","tokenPluginFileWorksPromise","isOnline","urlWorks","result","deleteLastViewed","conditions","_this26","getLastViewed","_this27","_unused","getComponentLastViewed","ids","_this28","whereAndParams","getInOrEqual","getManyWhere","includes","_unused2","storeLastViewed","_this29","_options$timeaccess","timeaccess","Date","now"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/sites/site.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { InAppBrowserObject, InAppBrowserOptions } from '@awesome-cordova-plugins/in-app-browser';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreDB } from '@services/db';\nimport { CoreEventData, CoreEvents } from '@singletons/events';\nimport { CoreFile } from '@services/file';\nimport {\n    CoreWS,\n    CoreWSFileUploadOptions,\n    CoreWSExternalWarning,\n    CoreWSUploadFileResult,\n} from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils, CoreUtilsOpenInBrowserOptions } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreLogger } from '@singletons/logger';\nimport { Translate } from '@singletons';\nimport { CoreIonLoadingElement } from '../ion-loading';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { asyncInstance, AsyncInstance } from '../../utils/async-instance';\nimport { CoreDatabaseTable } from '../database/database-table';\nimport { CoreDatabaseCachingStrategy } from '../database/database-table-proxy';\nimport {\n    CONFIG_TABLE,\n    CoreSiteConfigDBRecord,\n    CoreSiteLastViewedDBRecord,\n    CoreSiteWSCacheRecord,\n    LAST_VIEWED_TABLE,\n    WS_CACHE_TABLE,\n} from '@services/database/sites';\nimport { map } from 'rxjs/operators';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSiteInfo } from './unauthenticated-site';\nimport { CoreAuthenticatedSite, CoreAuthenticatedSiteOptionalData, CoreSiteWSPreSets, WSObservable } from './authenticated-site';\nimport { firstValueFrom } from 'rxjs';\n\n/**\n * Class that represents a site (combination of site + user).\n * It will have all the site data and provide utility functions regarding a site.\n */\nexport class CoreSite extends CoreAuthenticatedSite {\n\n    id: string;\n    config?: CoreSiteConfig;\n    loggedOut?: boolean;\n\n    protected db!: SQLiteDB;\n    protected cacheTable: AsyncInstance<CoreDatabaseTable<CoreSiteWSCacheRecord>>;\n    protected configTable: AsyncInstance<CoreDatabaseTable<CoreSiteConfigDBRecord, 'name'>>;\n    protected lastViewedTable: AsyncInstance<CoreDatabaseTable<CoreSiteLastViewedDBRecord, 'component' | 'id'>>;\n    protected lastAutoLogin = 0;\n    protected tokenPluginFileWorks?: boolean;\n    protected tokenPluginFileWorksPromise?: Promise<boolean>;\n    protected oauthId?: number;\n\n    /**\n     * Create a site.\n     *\n     * @param id Site ID.\n     * @param siteUrl Site URL.\n     * @param token Site's WS token.\n     * @param otherData Other data.\n     */\n    constructor(\n        id: string,\n        siteUrl: string,\n        token: string,\n        otherData: CoreSiteOptionalData = {},\n    ) {\n        super(siteUrl, token, otherData);\n\n        this.id = id;\n        this.config = otherData.config;\n        this.loggedOut = otherData.loggedOut;\n        this.logger = CoreLogger.getInstance('CoreSite');\n\n        this.cacheTable = asyncInstance(() => CoreSites.getSiteTable(WS_CACHE_TABLE, {\n            siteId: this.getId(),\n            database: this.getDb(),\n            config: { cachingStrategy: CoreDatabaseCachingStrategy.None },\n        }));\n\n        this.configTable = asyncInstance(() => CoreSites.getSiteTable(CONFIG_TABLE, {\n            siteId: this.getId(),\n            database: this.getDb(),\n            config: { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            primaryKeyColumns: ['name'],\n        }));\n\n        this.lastViewedTable = asyncInstance(() => CoreSites.getSiteTable(LAST_VIEWED_TABLE, {\n            siteId: this.getId(),\n            database: this.getDb(),\n            config: { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            primaryKeyColumns: ['component', 'id'],\n        }));\n        this.setInfo(otherData.info);\n        this.calculateOfflineDisabled();\n\n        this.db = CoreDB.getDB('Site-' + this.id);\n    }\n\n    /**\n     * Get site ID.\n     *\n     * @returns Site ID.\n     */\n    getId(): string {\n        return this.id;\n    }\n\n    /**\n     * Get site DB.\n     *\n     * @returns Site DB.\n     */\n    getDb(): SQLiteDB {\n        return this.db;\n    }\n\n    /**\n     * Check if user logged out from the site and needs to authenticate again.\n     *\n     * @returns Whether is logged out.\n     */\n    isLoggedOut(): boolean {\n        return !!this.loggedOut;\n    }\n\n    /**\n     * Get OAuth ID.\n     *\n     * @returns OAuth ID.\n     */\n    getOAuthId(): number | undefined {\n        return this.oauthId;\n    }\n\n    /**\n     * Set site config.\n     *\n     * @param config Config.\n     */\n    setConfig(config: CoreSiteConfig): void {\n        if (config) {\n            config.tool_mobile_disabledfeatures = CoreTextUtils.treatDisabledFeatures(config.tool_mobile_disabledfeatures);\n        }\n\n        this.config = config;\n        this.calculateOfflineDisabled();\n    }\n\n    /**\n     * Set site logged out.\n     *\n     * @param loggedOut True if logged out and needs to authenticate again, false otherwise.\n     */\n    setLoggedOut(loggedOut: boolean): void {\n        this.loggedOut = !!loggedOut;\n    }\n\n    /**\n     * Set OAuth ID.\n     *\n     * @param oauthId OAuth ID.\n     */\n    setOAuthId(oauthId: number | undefined): void {\n        this.oauthId = oauthId;\n    }\n\n    /**\n     * Check if the user authenticated in the site using an OAuth method.\n     *\n     * @returns Whether the user authenticated in the site using an OAuth method.\n     */\n    isOAuth(): boolean {\n        return this.oauthId != null && this.oauthId !== undefined;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected async getCacheEntryById(id: string): Promise<CoreSiteWSCacheRecord> {\n        return this.cacheTable.getOneByPrimaryKey({ id });\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected async getCacheEntriesByKey(key: string): Promise<CoreSiteWSCacheRecord[]> {\n        return this.cacheTable.getMany({ key });\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected async storeCacheEntry(entry: CoreSiteWSCacheRecord): Promise<void> {\n        await this.cacheTable.insert(entry);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected async deleteFromCache(method: string, data: any, preSets: CoreSiteWSPreSets, allCacheKey?: boolean): Promise<void> {\n        if (allCacheKey) {\n            await this.cacheTable.delete({ key: preSets.cacheKey });\n        } else {\n            await this.cacheTable.deleteByPrimaryKey({ id: this.getCacheId(method, data) });\n        }\n    }\n\n    /**\n     * Gets the size of cached data for a specific component or component instance.\n     *\n     * @param component Component name\n     * @param componentId Optional component id (if not included, returns sum for whole component)\n     * @returns Promise resolved when we have calculated the size\n     */\n    async getComponentCacheSize(component: string, componentId?: number): Promise<number> {\n        const params: Array<string | number> = [component];\n        let extraClause = '';\n        if (componentId !== undefined && componentId !== null) {\n            params.push(componentId);\n            extraClause = ' AND componentId = ?';\n        }\n\n        return this.cacheTable.reduce(\n            {\n                sql: 'SUM(length(data))',\n                js: (size, record) => size + record.data.length,\n                jsInitialValue: 0,\n            },\n            {\n                sql: 'WHERE component = ?' + extraClause,\n                sqlParams: params,\n                js: record => record.component === component && (params.length === 1 || record.componentId === componentId),\n            },\n        );\n    }\n\n    /**\n     * Deletes WS cache entries for all methods relating to a specific component (and\n     * optionally component id).\n     *\n     * @param component Component name.\n     * @param componentId Component id.\n     * @returns Promise resolved when the entries are deleted.\n     */\n    async deleteComponentFromCache(component: string, componentId?: number): Promise<void> {\n        if (!component) {\n            return;\n        }\n\n        const params = { component };\n\n        if (componentId) {\n            params['componentId'] = componentId;\n        }\n\n        await this.cacheTable.delete(params);\n    }\n\n    /*\n     * Uploads a file using Cordova File API.\n     *\n     * @param filePath File path.\n     * @param options File upload options.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when uploaded.\n     */\n    uploadFile(\n        filePath: string,\n        options: CoreWSFileUploadOptions,\n        onProgress?: (event: ProgressEvent) => void,\n    ): Promise<CoreWSUploadFileResult> {\n        if (!options.fileArea) {\n            options.fileArea = 'draft';\n        }\n\n        return CoreWS.uploadFile(filePath, options, {\n            siteUrl: this.siteUrl,\n            wsToken: this.token || '',\n        }, onProgress);\n    }\n\n    /**\n     * Invalidates all caches related to the site.\n     */\n    async invalidateCaches(): Promise<void> {\n        await Promise.all([\n            CoreFilepool.invalidateAllFiles(this.getId()),\n            this.invalidateWsCache(),\n        ]);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async invalidateWsCache(): Promise<void> {\n        this.logger.debug('Invalidate all the cache for site: ' + this.id);\n\n        try {\n            await this.cacheTable.update({ expirationTime: 0 });\n        } finally {\n            CoreEvents.trigger(CoreEvents.WS_CACHE_INVALIDATED, {}, this.getId());\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async invalidateWsCacheForKey(key: string): Promise<void> {\n        if (!key) {\n            return;\n        }\n\n        this.logger.debug('Invalidate cache for key: ' + key);\n\n        await this.cacheTable.update({ expirationTime: 0 }, { key });\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async invalidateWsCacheForKeyStartingWith(key: string): Promise<void> {\n        if (!key) {\n            return;\n        }\n\n        this.logger.debug('Invalidate cache for key starting with: ' + key);\n\n        await this.cacheTable.updateWhere({ expirationTime: 0 }, {\n            sql: 'key LIKE ?',\n            sqlParams: [key + '%'],\n            js: record => !!record.key?.startsWith(key),\n        });\n    }\n\n    /**\n     * Check if tokenpluginfile can be used, and fix the URL afterwards.\n     *\n     * @param url The url to be fixed.\n     * @returns Promise resolved with the fixed URL.\n     */\n    checkAndFixPluginfileURL(url: string): Promise<string> {\n        return this.checkTokenPluginFile(url).then(() => this.fixPluginfileURL(url));\n    }\n\n    /**\n     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.\n     * Uses CoreUtilsProvider.fixPluginfileURL, passing site's token.\n     *\n     * @param url The url to be fixed.\n     * @returns Fixed URL.\n     */\n    fixPluginfileURL(url: string): string {\n        const accessKey = this.tokenPluginFileWorks || this.tokenPluginFileWorks === undefined ?\n            this.infos && this.infos.userprivateaccesskey : undefined;\n\n        return CoreUrlUtils.fixPluginfileURL(url, this.token || '', this.siteUrl, accessKey);\n    }\n\n    /**\n     * Deletes site's DB.\n     *\n     * @returns Promise to be resolved when the DB is deleted.\n     */\n    async deleteDB(): Promise<void> {\n        await CoreDB.deleteDB('Site-' + this.id);\n    }\n\n    /**\n     * Deletes site's folder.\n     *\n     * @returns Promise to be resolved when the DB is deleted.\n     */\n    async deleteFolder(): Promise<void> {\n        if (!CoreFile.isAvailable() || !this.id) {\n            return;\n        }\n\n        const siteFolder = CoreFile.getSiteFolder(this.id);\n\n        // Ignore any errors, removeDir fails if folder doesn't exists.\n        await CoreUtils.ignoreErrors(CoreFile.removeDir(siteFolder));\n    }\n\n    /**\n     * Get space usage of the site.\n     *\n     * @returns Promise resolved with the site space usage (size).\n     */\n    getSpaceUsage(): Promise<number> {\n        if (CoreFile.isAvailable() && this.id) {\n            const siteFolderPath = CoreFile.getSiteFolder(this.id);\n\n            return CoreFile.getDirectorySize(siteFolderPath).catch(() => 0);\n        } else {\n            return Promise.resolve(0);\n        }\n    }\n\n    /**\n     * Gets an approximation of the cache table usage of the site.\n     *\n     * Currently this is just the total length of the data fields in the cache table.\n     *\n     * @returns Promise resolved with the total size of all data in the cache table (bytes)\n     */\n    async getCacheUsage(): Promise<number> {\n        return this.cacheTable.reduce({\n            sql: 'SUM(length(data))',\n            js: (size, record) => size + record.data.length,\n            jsInitialValue: 0,\n        });\n    }\n\n    /**\n     * Gets a total of the file and cache usage.\n     *\n     * @returns Promise with the total of getSpaceUsage and getCacheUsage\n     */\n    async getTotalUsage(): Promise<number> {\n        const space = await this.getSpaceUsage();\n        const cache = await this.getCacheUsage();\n\n        return space + cache;\n    }\n\n    /**\n     * Check if GET method is supported for AJAX calls.\n     *\n     * @returns Whether it's supported.\n     */\n    protected isAjaxGetSupported(): boolean {\n        return !!this.getInfo() && this.isVersionGreaterEqualThan('3.8');\n    }\n\n    /**\n     * Open a URL in browser using auto-login in the Moodle site if available.\n     *\n     * @param url The URL to open.\n     * @param alertMessage If defined, an alert will be shown before opening the browser.\n     * @param options Other options.\n     * @returns Promise resolved when done, rejected otherwise.\n     */\n    async openInBrowserWithAutoLogin(\n        url: string,\n        alertMessage?: string,\n        options: CoreUtilsOpenInBrowserOptions = {},\n    ): Promise<void> {\n        await this.openWithAutoLogin(false, url, options, alertMessage);\n    }\n\n    /**\n     * Open a URL in browser using auto-login in the Moodle site if available and the URL belongs to the site.\n     *\n     * @param url The URL to open.\n     * @param alertMessage If defined, an alert will be shown before opening the browser.\n     * @param options Other options.\n     * @returns Promise resolved when done, rejected otherwise.\n     * @deprecated since 4.1. Use openInBrowserWithAutoLogin instead, now it always checks that URL belongs to same site.\n     */\n    async openInBrowserWithAutoLoginIfSameSite(\n        url: string,\n        alertMessage?: string,\n        options: CoreUtilsOpenInBrowserOptions = {},\n    ): Promise<void> {\n        return this.openInBrowserWithAutoLogin(url, alertMessage, options);\n    }\n\n    /**\n     * Open a URL in inappbrowser using auto-login in the Moodle site if available.\n     *\n     * @param url The URL to open.\n     * @param options Override default options passed to InAppBrowser.\n     * @param alertMessage If defined, an alert will be shown before opening the inappbrowser.\n     * @returns Promise resolved when done.\n     */\n    async openInAppWithAutoLogin(url: string, options?: InAppBrowserOptions, alertMessage?: string): Promise<InAppBrowserObject> {\n        const iabInstance = <InAppBrowserObject> await this.openWithAutoLogin(true, url, options, alertMessage);\n\n        return iabInstance;\n    }\n\n    /**\n     * Open a URL in inappbrowser using auto-login in the Moodle site if available and the URL belongs to the site.\n     *\n     * @param url The URL to open.\n     * @param options Override default options passed to inappbrowser.\n     * @param alertMessage If defined, an alert will be shown before opening the inappbrowser.\n     * @returns Promise resolved when done.\n     * @deprecated since 4.1. Use openInAppWithAutoLogin instead, now it always checks that URL belongs to same site.\n     */\n    async openInAppWithAutoLoginIfSameSite(\n        url: string,\n        options?: InAppBrowserOptions,\n        alertMessage?: string,\n    ): Promise<InAppBrowserObject> {\n        return this.openInAppWithAutoLogin(url, options, alertMessage);\n    }\n\n    /**\n     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available.\n     *\n     * @param inApp True to open it in InAppBrowser, false to open in browser.\n     * @param url The URL to open.\n     * @param options Override default options passed to $cordovaInAppBrowser#open.\n     * @param alertMessage If defined, an alert will be shown before opening the browser/inappbrowser.\n     * @returns Promise resolved when done. Resolve param is returned only if inApp=true.\n     */\n    async openWithAutoLogin(\n        inApp: boolean,\n        url: string,\n        options: InAppBrowserOptions & CoreUtilsOpenInBrowserOptions = {},\n        alertMessage?: string,\n    ): Promise<InAppBrowserObject | void> {\n        // Get the URL to open.\n        const autoLoginUrl = await this.getAutoLoginUrl(url);\n\n        if (alertMessage) {\n            // Show an alert first.\n            const alert = await CoreDomUtils.showAlert(\n                Translate.instant('core.notice'),\n                alertMessage,\n                undefined,\n                3000,\n            );\n\n            await alert.onDidDismiss();\n            options.showBrowserWarning = false; // A warning already shown, no need to show another.\n        }\n\n        options.originalUrl = url;\n\n        // Open the URL.\n        if (inApp) {\n            return CoreUtils.openInApp(autoLoginUrl, options);\n        } else {\n            return CoreUtils.openInBrowser(autoLoginUrl, options);\n        }\n    }\n\n    /**\n     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available and the URL belongs to the site.\n     *\n     * @param inApp True to open it in InAppBrowser, false to open in browser.\n     * @param url The URL to open.\n     * @param options Override default options passed to inappbrowser.\n     * @param alertMessage If defined, an alert will be shown before opening the browser/inappbrowser.\n     * @returns Promise resolved when done. Resolve param is returned only if inApp=true.\n     * @deprecated since 4.1. Use openWithAutoLogin instead, now it always checks that URL belongs to same site.\n     */\n    async openWithAutoLoginIfSameSite(\n        inApp: boolean,\n        url: string,\n        options: InAppBrowserOptions & CoreUtilsOpenInBrowserOptions = {},\n        alertMessage?: string,\n    ): Promise<InAppBrowserObject | void> {\n        return this.openWithAutoLogin(inApp, url, options, alertMessage);\n    }\n\n    /**\n     * Get the config of this site.\n     * It is recommended to use getStoredConfig instead since it's faster and doesn't use network.\n     *\n     * @param name Name of the setting to get. If not set or false, all settings will be returned.\n     * @param ignoreCache True if it should ignore cached data.\n     * @returns Promise resolved with site config.\n     */\n    getConfig(name?: undefined, ignoreCache?: boolean): Promise<CoreSiteConfig>;\n    getConfig(name: string, ignoreCache?: boolean): Promise<string>;\n    getConfig(name?: string, ignoreCache?: boolean): Promise<string | CoreSiteConfig> {\n        return firstValueFrom(\n            this.getConfigObservable(<string> name, ignoreCache ? CoreSitesReadingStrategy.ONLY_NETWORK : undefined),\n        );\n    }\n\n    /**\n     * Get the config of this site.\n     * It is recommended to use getStoredConfig instead since it's faster and doesn't use network.\n     *\n     * @param name Name of the setting to get. If not set or false, all settings will be returned.\n     * @param readingStrategy Reading strategy.\n     * @returns Observable returning site config.\n     */\n    getConfigObservable(name?: undefined, readingStrategy?: CoreSitesReadingStrategy): WSObservable<CoreSiteConfig>;\n    getConfigObservable(name: string, readingStrategy?: CoreSitesReadingStrategy): WSObservable<string>;\n    getConfigObservable(name?: string, readingStrategy?: CoreSitesReadingStrategy): WSObservable<string | CoreSiteConfig> {\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getConfigCacheKey(),\n            ...CoreSites.getReadingStrategyPreSets(readingStrategy),\n        };\n\n        return this.readObservable<CoreSiteConfigResponse>('tool_mobile_get_config', {}, preSets).pipe(map(config => {\n            if (name) {\n                // Return the requested setting.\n                for (const x in config.settings) {\n                    if (config.settings[x].name == name) {\n                        return String(config.settings[x].value);\n                    }\n                }\n\n                throw new CoreError('Site config not found: ' + name);\n            } else {\n                // Return all settings in the same array.\n                const settings: CoreSiteConfig = {};\n                config.settings.forEach((setting) => {\n                    settings[setting.name] = String(setting.value);\n                });\n\n                return settings;\n            }\n        }));\n    }\n\n    /**\n     * Invalidates config WS call.\n     *\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateConfig(): Promise<void> {\n        await this.invalidateWsCacheForKey(this.getConfigCacheKey());\n    }\n\n    /**\n     * Get cache key for getConfig WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getConfigCacheKey(): string {\n        return 'tool_mobile_get_config';\n    }\n\n    /**\n     * Get the stored config of this site.\n     *\n     * @param name Name of the setting to get. If not set, all settings will be returned.\n     * @returns Site config or a specific setting.\n     */\n    getStoredConfig(): CoreSiteConfig | undefined;\n    getStoredConfig(name: string): string | undefined;\n    getStoredConfig(name?: string): string | CoreSiteConfig | undefined {\n        if (!this.config) {\n            return;\n        }\n\n        if (name) {\n            return this.config[name];\n        } else {\n            return this.config;\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected getDisabledFeatures(): string | undefined {\n        return this.config ? this.getStoredConfig('tool_mobile_disabledfeatures') : super.getDisabledFeatures();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected triggerSiteEvent<Fallback = unknown, Event extends string = string>(\n        eventName: Event,\n        data?: CoreEventData<Event, Fallback>,\n    ): void {\n        CoreEvents.trigger(eventName, data, this.id);\n    }\n\n    /**\n     * Calculate if offline is disabled in the site.\n     */\n    calculateOfflineDisabled(): void {\n        this.offlineDisabled = this.isFeatureDisabled('NoDelegate_CoreOffline');\n    }\n\n    /**\n     * Get whether offline is disabled in the site.\n     *\n     * @returns Whether it's disabled.\n     */\n    isOfflineDisabled(): boolean {\n        return this.offlineDisabled;\n    }\n\n    /**\n     * Given a URL, convert it to a URL that will auto-login if supported.\n     *\n     * @param url The URL to convert.\n     * @param showModal Whether to show a loading modal.\n     * @returns Promise resolved with the converted URL.\n     */\n    async getAutoLoginUrl(url: string, showModal: boolean = true): Promise<string> {\n        if (!this.privateToken) {\n            // No private token, don't change the URL.\n            return url;\n        }\n\n        if (!this.containsUrl(url)) {\n            // URL doesn't belong to the site, don't auto login.\n            return url;\n        }\n\n        if (this.lastAutoLogin > 0) {\n            const timeBetweenRequests = await CoreUtils.ignoreErrors(\n                this.getConfig('tool_mobile_autologinmintimebetweenreq'),\n                CoreConstants.SECONDS_MINUTE * 6,\n            );\n\n            if (CoreTimeUtils.timestamp() - this.lastAutoLogin < Number(timeBetweenRequests)) {\n                // Not enough time has passed since last auto login.\n                return url;\n            }\n        }\n\n        const userId = this.getUserId();\n        const params = {\n            privatetoken: this.privateToken,\n        };\n        let modal: CoreIonLoadingElement | undefined;\n\n        if (showModal) {\n            modal = await CoreDomUtils.showModalLoading();\n        }\n\n        try {\n            // Use write to not use cache.\n            const data = await this.write<CoreSiteAutologinKeyResult>('tool_mobile_get_autologin_key', params);\n\n            if (!data.autologinurl || !data.key) {\n                // Not valid data, return the same URL.\n                return url;\n            }\n\n            this.lastAutoLogin = CoreTimeUtils.timestamp();\n\n            return data.autologinurl + '?userid=' + userId + '&key=' + data.key + '&urltogo=' + encodeURIComponent(url);\n        } catch (error) {\n            // Couldn't get autologin key, return the same URL.\n            return url;\n        } finally {\n            modal?.dismiss();\n        }\n    }\n\n    /**\n     * Deletes a site setting.\n     *\n     * @param name The config name.\n     * @returns Promise resolved when done.\n     */\n    async deleteSiteConfig(name: string): Promise<void> {\n        await this.configTable.deleteByPrimaryKey({ name });\n    }\n\n    /**\n     * Get a site setting on local device.\n     *\n     * @param name The config name.\n     * @param defaultValue Default value to use if the entry is not found.\n     * @returns Resolves upon success along with the config data. Reject on failure.\n     */\n    async getLocalSiteConfig<T extends number | string>(name: string, defaultValue?: T): Promise<T> {\n        try {\n            const entry = await this.configTable.getOneByPrimaryKey({ name });\n\n            return <T> entry.value;\n        } catch (error) {\n            if (defaultValue !== undefined) {\n                return defaultValue;\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Set a site setting on local device.\n     *\n     * @param name The config name.\n     * @param value The config value. Can only store number or strings.\n     * @returns Promise resolved when done.\n     */\n    async setLocalSiteConfig(name: string, value: number | string): Promise<void> {\n        await this.configTable.insert({ name, value });\n    }\n\n    /*\n     * Check if tokenpluginfile script works in the site.\n     *\n     * @param url URL to check.\n     * @returns Promise resolved with boolean: whether it works or not.\n     */\n    checkTokenPluginFile(url: string): Promise<boolean> {\n        if (!CoreUrlUtils.canUseTokenPluginFile(url, this.siteUrl, this.infos && this.infos.userprivateaccesskey)) {\n            // Cannot use tokenpluginfile.\n            return Promise.resolve(false);\n        } else if (this.tokenPluginFileWorks !== undefined) {\n            // Already checked.\n            return Promise.resolve(this.tokenPluginFileWorks);\n        } else if (this.tokenPluginFileWorksPromise) {\n            // Check ongoing, use the same promise.\n            return this.tokenPluginFileWorksPromise;\n        } else if (!CoreNetwork.isOnline()) {\n            // Not online, cannot check it. Assume it's working, but don't save the result.\n            return Promise.resolve(true);\n        }\n\n        url = this.fixPluginfileURL(url);\n\n        this.tokenPluginFileWorksPromise = CoreWS.urlWorks(url).then((result) => {\n            this.tokenPluginFileWorks = result;\n\n            return result;\n        });\n\n        return this.tokenPluginFileWorksPromise;\n    }\n\n    /**\n     * Deletes last viewed records based on some conditions.\n     *\n     * @param conditions Conditions.\n     * @returns Promise resolved when done.\n     */\n    async deleteLastViewed(conditions?: Partial<CoreSiteLastViewedDBRecord>): Promise<void> {\n        await this.lastViewedTable.delete(conditions);\n    }\n\n    /**\n     * Get a last viewed record for a component+id.\n     *\n     * @param component The component.\n     * @param id ID.\n     * @returns Resolves with last viewed record, undefined if not found.\n     */\n    async getLastViewed(component: string, id: number): Promise<CoreSiteLastViewedDBRecord | undefined> {\n        try {\n            return await this.lastViewedTable.getOneByPrimaryKey({ component, id });\n        } catch {\n            // Not found.\n        }\n    }\n\n    /**\n     * Get several last viewed for a certain component.\n     *\n     * @param component The component.\n     * @param ids IDs. If not provided or empty, return all last viewed for a component.\n     * @returns Resolves with last viewed records, undefined if error.\n     */\n    async getComponentLastViewed(component: string, ids: number[] = []): Promise<CoreSiteLastViewedDBRecord[] | undefined> {\n        try {\n            if (!ids.length) {\n                return await this.lastViewedTable.getMany({ component });\n            }\n\n            const whereAndParams = SQLiteDB.getInOrEqual(ids);\n\n            whereAndParams.sql = 'id ' + whereAndParams.sql + ' AND component = ?';\n            whereAndParams.params.push(component);\n\n            return await this.lastViewedTable.getManyWhere({\n                sql: whereAndParams.sql,\n                sqlParams: whereAndParams.params,\n                js: (record) => record.component === component && ids.includes(record.id),\n            });\n        } catch {\n            // Not found.\n        }\n    }\n\n    /**\n     * Store a last viewed record.\n     *\n     * @param component The component.\n     * @param id ID.\n     * @param value Last viewed item value.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async storeLastViewed(\n        component: string,\n        id: number,\n        value: string | number,\n        options: CoreSiteStoreLastViewedOptions = {},\n    ): Promise<void> {\n        await this.lastViewedTable.insert({\n            component,\n            id,\n            value: String(value),\n            data: options.data,\n            timeaccess: options.timeaccess ?? Date.now(),\n        });\n    }\n\n}\n\n/**\n * Optional data to create a site.\n */\nexport type CoreSiteOptionalData = CoreAuthenticatedSiteOptionalData & {\n    info?: CoreSiteInfo;\n    config?: CoreSiteConfig;\n    loggedOut?: boolean;\n};\n\n/**\n * Result of WS tool_mobile_get_config.\n */\nexport type CoreSiteConfigResponse = {\n    settings: { // Settings.\n        name: string; // The name of the setting.\n        value: string | number; // The value of the setting.\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Site config indexed by name.\n */\nexport type CoreSiteConfig = Record<string, string> & {\n    supportavailability?: string; // String representation of CoreSiteConfigSupportAvailability.\n    searchbanner?: string; // Search banner text.\n    searchbannerenable?: string; // Whether search banner is enabled.\n};\n\n/**\n * Result of WS tool_mobile_get_autologin_key.\n */\nexport type CoreSiteAutologinKeyResult = {\n    key: string; // Auto-login key for a single usage with time expiration.\n    autologinurl: string; // Auto-login URL.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Options for storeLastViewed.\n */\nexport type CoreSiteStoreLastViewedOptions = {\n    data?: string; // Other data.\n    timeaccess?: number; // Accessed time. If not set, current time.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}