{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreFilterDelegate } from './filter-delegate';\nimport { CoreFilter } from './filter';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseHelper } from '@features/course/services/course-helper';\nimport { firstValueFrom } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n/**\n * Helper service to provide filter functionalities.\n */\nexport class CoreFilterHelperProvider {\n  constructor() {\n    /**\n     * When a module context is requested, we request all the modules in a course to decrease WS calls. If there are a lot of\n     * modules, checking the cache of all contexts can be really slow, so we use this memory cache to speed up the process.\n     */\n    this.moduleContextsCache = {};\n    this.logger = CoreLogger.getInstance('CoreFilterHelperProvider');\n    CoreEvents.on(CoreEvents.WS_CACHE_INVALIDATED, data => {\n      delete this.moduleContextsCache[data.siteId || ''];\n    });\n    CoreEvents.on(CoreEvents.SITE_STORAGE_DELETED, data => {\n      delete this.moduleContextsCache[data.siteId || ''];\n    });\n  }\n  /**\n   * Get the contexts of all blocks in a course.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the contexts.\n   */\n  getBlocksContexts(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      // Use stale while revalidate, but always use the first value. If data is updated it will be stored in DB.\n      const blocks = yield firstValueFrom(CoreCourse.getCourseBlocksObservable(courseId, {\n        readingStrategy: 4 /* CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE */,\n        siteId\n      }));\n      const contexts = [];\n      blocks.forEach(block => {\n        contexts.push({\n          contextlevel: 'block',\n          instanceid: block.instanceid\n        });\n      });\n      return contexts;\n    })();\n  }\n  /**\n   * Get some filters from memory cache. If not in cache, get them and store them in cache.\n   *\n   * @param contextLevel The context level.\n   * @param instanceId Instance ID related to the context.\n   * @param getFilters Function to get filter contexts from.\n   * @param options Options for format text.\n   * @param site Site. If not defined, current site.\n   * @returns Promise resolved with the filters.\n   */\n  getCacheableFilters(contextLevel, instanceId, getFilters, options, site) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _options$courseId, _options$courseId2;\n      // Check the memory cache first.\n      const result = _this.getFromMemoryCache((_options$courseId = options.courseId) !== null && _options$courseId !== void 0 ? _options$courseId : -1, contextLevel, instanceId, site);\n      if (result) {\n        return result;\n      }\n      const siteId = site.getId();\n      const contexts = yield getFilters();\n      const filters = yield CoreFilter.getAvailableInContexts(contexts, siteId);\n      _this.storeInMemoryCache((_options$courseId2 = options.courseId) !== null && _options$courseId2 !== void 0 ? _options$courseId2 : -1, contextLevel, filters, siteId);\n      return filters[contextLevel][instanceId] || [];\n    })();\n  }\n  /**\n   * If user is enrolled in the course, return contexts of all enrolled courses to decrease number of WS requests.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the contexts.\n   */\n  getCourseContexts(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const courseIds = yield CoreCourses.getCourseIdsIfEnrolled(courseId, siteId);\n      const contexts = [];\n      courseIds.forEach(courseId => {\n        contexts.push({\n          contextlevel: 'course',\n          instanceid: courseId\n        });\n      });\n      return contexts;\n    })();\n  }\n  /**\n   * Get the contexts of all course modules in a course.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the contexts.\n   */\n  getCourseModulesContexts(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      // Use stale while revalidate, but always use the first value. If data is updated it will be stored in DB.\n      const sections = yield firstValueFrom(CoreCourse.getSectionsObservable(courseId, {\n        excludeContents: true,\n        readingStrategy: 4 /* CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE */,\n        siteId\n      }));\n      const contexts = [];\n      sections.forEach(section => {\n        if (section.modules) {\n          section.modules.forEach(module => {\n            if (CoreCourseHelper.canUserViewModule(module, section)) {\n              contexts.push({\n                contextlevel: 'module',\n                instanceid: module.id\n              });\n            }\n          });\n        }\n      });\n      return contexts;\n    })();\n  }\n  /**\n   * Get the filters in a certain context, performing some checks like the site version.\n   * It's recommended to use this function instead of canGetFilters + getEnabledFilters because this function will check if\n   * it's really needed to call the WS.\n   *\n   * @param contextLevel The context level.\n   * @param instanceId Instance ID related to the context.\n   * @param options Options for format text.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the filters.\n   */\n  getFilters(contextLevel, instanceId, options, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      options = options || {};\n      options.contextLevel = contextLevel;\n      options.instanceId = instanceId;\n      options.filter = false;\n      try {\n        const site = yield CoreSites.getSite(siteId);\n        siteId = site.getId();\n        const canGet = yield CoreFilter.canGetFilters(siteId);\n        if (!canGet) {\n          options.filter = true;\n          // We cannot check which filters are available, apply them all.\n          return yield CoreFilterDelegate.getEnabledFilters(contextLevel, instanceId);\n        }\n        const courseId = options.courseId;\n        let hasFilters = true;\n        if (contextLevel == 'system' || contextLevel == 'course' && instanceId == site.getSiteHomeId()) {\n          // No need to check the site filters because we're requesting the same context, so we'd do the same twice.\n        } else {\n          // Check if site has any filter to treat.\n          hasFilters = yield _this2.siteHasFiltersToTreat(options, siteId);\n        }\n        if (!hasFilters) {\n          return [];\n        }\n        options.filter = true;\n        if (contextLevel == 'module' && courseId) {\n          // Get all the modules filters with a single call to decrease the number of WS calls.\n          const getFilters = () => _this2.getCourseModulesContexts(courseId, siteId);\n          return yield _this2.getCacheableFilters(contextLevel, instanceId, getFilters, options, site);\n        } else if (contextLevel == 'course') {\n          // If enrolled, get all enrolled courses filters with a single call to decrease number of WS calls.\n          const getFilters = () => _this2.getCourseContexts(instanceId, siteId);\n          return yield _this2.getCacheableFilters(contextLevel, instanceId, getFilters, options, site);\n        } else if (contextLevel == 'block' && courseId && CoreCourse.canGetCourseBlocks(site)) {\n          // Get all the course blocks filters with a single call to decrease number of WS calls.\n          const getFilters = () => _this2.getBlocksContexts(courseId, siteId);\n          return yield _this2.getCacheableFilters(contextLevel, instanceId, getFilters, options, site);\n        }\n        return yield CoreFilter.getAvailableInContext(contextLevel, instanceId, siteId);\n      } catch (error) {\n        _this2.logger.error('Error getting filters, return an empty array', error, contextLevel, instanceId);\n        return [];\n      }\n    })();\n  }\n  /**\n   * Get filters and format text.\n   *\n   * @param text Text to filter.\n   * @param contextLevel The context level.\n   * @param instanceId Instance ID related to the context.\n   * @param options Options for format text.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the formatted text and the filters.\n   */\n  getFiltersAndFormatText(text, contextLevel, instanceId, options, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const filters = yield _this3.getFilters(contextLevel, instanceId, options, siteId);\n      text = yield CoreFilter.formatText(text, options, filters, siteId);\n      return {\n        text,\n        filters: filters\n      };\n    })();\n  }\n  /**\n   * Get module context filters from the memory cache.\n   *\n   * @param courseId Course the module belongs to.\n   * @param contextLevel Context level.\n   * @param instanceId Instance ID.\n   * @param site Site.\n   * @returns The filters, undefined if not found.\n   */\n  getFromMemoryCache(courseId, contextLevel, instanceId, site) {\n    var _this$moduleContextsC;\n    const siteId = site.getId();\n    // Check if we have the context in the memory cache.\n    if (!((_this$moduleContextsC = this.moduleContextsCache[siteId]) !== null && _this$moduleContextsC !== void 0 && (_this$moduleContextsC = _this$moduleContextsC[courseId]) !== null && _this$moduleContextsC !== void 0 && _this$moduleContextsC[contextLevel])) {\n      return;\n    }\n    const cachedData = this.moduleContextsCache[siteId][courseId][contextLevel];\n    if (!CoreNetwork.isOnline() || Date.now() <= cachedData.time + site.getExpirationDelay(CoreSite.FREQUENCY_RARELY)) {\n      // We can use cache, return the filters if found.\n      return cachedData.contexts[contextLevel] && cachedData.contexts[contextLevel][instanceId];\n    }\n  }\n  /**\n   * Check if site has available any filter that should be treated by the app.\n   *\n   * @param options Options passed to the filters.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it has filters to treat.\n   */\n  siteHasFiltersToTreat(options, siteId) {\n    return _asyncToGenerator(function* () {\n      options = options || {};\n      const site = yield CoreSites.getSite(siteId);\n      // Get filters at site level.\n      const filters = yield CoreFilter.getAvailableInContext('system', 0, site.getId());\n      return CoreFilterDelegate.shouldBeApplied(filters, options, site);\n    })();\n  }\n  /**\n   * Store filters in the memory cache.\n   *\n   * @param courseId Course the module belongs to.\n   * @param contextLevel Context level.\n   * @param contexts Contexts.\n   * @param siteId Site ID.\n   */\n  storeInMemoryCache(courseId, contextLevel, contexts, siteId) {\n    this.moduleContextsCache[siteId] = this.moduleContextsCache[siteId] || {};\n    this.moduleContextsCache[siteId][courseId] = this.moduleContextsCache[siteId][courseId] || {};\n    this.moduleContextsCache[siteId][courseId][contextLevel] = {\n      contexts: contexts,\n      time: Date.now()\n    };\n  }\n}\n_class = CoreFilterHelperProvider;\n_class.ɵfac = function CoreFilterHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFilterHelper = makeSingleton(CoreFilterHelperProvider);","map":{"version":3,"names":["CoreNetwork","CoreSites","CoreFilterDelegate","CoreFilter","CoreCourse","CoreCourses","makeSingleton","CoreEvents","CoreLogger","CoreSite","CoreCourseHelper","firstValueFrom","CoreFilterHelperProvider","constructor","moduleContextsCache","logger","getInstance","on","WS_CACHE_INVALIDATED","data","siteId","SITE_STORAGE_DELETED","getBlocksContexts","courseId","_asyncToGenerator","blocks","getCourseBlocksObservable","readingStrategy","contexts","forEach","block","push","contextlevel","instanceid","getCacheableFilters","contextLevel","instanceId","getFilters","options","site","_this","_options$courseId","_options$courseId2","result","getFromMemoryCache","getId","filters","getAvailableInContexts","storeInMemoryCache","getCourseContexts","courseIds","getCourseIdsIfEnrolled","getCourseModulesContexts","sections","getSectionsObservable","excludeContents","section","modules","module","canUserViewModule","id","_this2","filter","getSite","canGet","canGetFilters","getEnabledFilters","hasFilters","getSiteHomeId","siteHasFiltersToTreat","canGetCourseBlocks","getAvailableInContext","error","getFiltersAndFormatText","text","_this3","formatText","_this$moduleContextsC","cachedData","isOnline","Date","now","time","getExpirationDelay","FREQUENCY_RARELY","shouldBeApplied","factory","ɵfac","providedIn","CoreFilterHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/filter/services/filter-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreFilterDelegate } from './filter-delegate';\nimport {\n    CoreFilter,\n    CoreFilterFilter,\n    CoreFilterFormatTextOptions,\n    CoreFilterClassifiedFilters,\n    CoreFiltersGetAvailableInContextWSParamContext,\n} from './filter';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents, CoreEventSiteData } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseHelper } from '@features/course/services/course-helper';\nimport { firstValueFrom } from 'rxjs';\n\n/**\n * Helper service to provide filter functionalities.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFilterHelperProvider {\n\n    protected logger: CoreLogger;\n\n    /**\n     * When a module context is requested, we request all the modules in a course to decrease WS calls. If there are a lot of\n     * modules, checking the cache of all contexts can be really slow, so we use this memory cache to speed up the process.\n     */\n    protected moduleContextsCache: {\n        [siteId: string]: {\n            [courseId: number]: {\n                [contextLevel: string]: {\n                    contexts: CoreFilterClassifiedFilters;\n                    time: number;\n                };\n            };\n        };\n    } = {};\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreFilterHelperProvider');\n\n        CoreEvents.on(CoreEvents.WS_CACHE_INVALIDATED, (data: CoreEventSiteData) => {\n            delete this.moduleContextsCache[data.siteId || ''];\n        });\n\n        CoreEvents.on(CoreEvents.SITE_STORAGE_DELETED, (data: CoreEventSiteData) => {\n            delete this.moduleContextsCache[data.siteId || ''];\n        });\n    }\n\n    /**\n     * Get the contexts of all blocks in a course.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the contexts.\n     */\n    async getBlocksContexts(courseId: number, siteId?: string): Promise<CoreFiltersGetAvailableInContextWSParamContext[]> {\n        // Use stale while revalidate, but always use the first value. If data is updated it will be stored in DB.\n        const blocks = await firstValueFrom(CoreCourse.getCourseBlocksObservable(courseId, {\n            readingStrategy: CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE,\n            siteId,\n        }));\n\n        const contexts: CoreFiltersGetAvailableInContextWSParamContext[] = [];\n\n        blocks.forEach((block) => {\n            contexts.push({\n                contextlevel: 'block',\n                instanceid: block.instanceid,\n            });\n        });\n\n        return contexts;\n    }\n\n    /**\n     * Get some filters from memory cache. If not in cache, get them and store them in cache.\n     *\n     * @param contextLevel The context level.\n     * @param instanceId Instance ID related to the context.\n     * @param getFilters Function to get filter contexts from.\n     * @param options Options for format text.\n     * @param site Site. If not defined, current site.\n     * @returns Promise resolved with the filters.\n     */\n    protected async getCacheableFilters(\n        contextLevel: string,\n        instanceId: number,\n        getFilters: () => Promise<CoreFiltersGetAvailableInContextWSParamContext[]>,\n        options: CoreFilterFormatTextOptions,\n        site: CoreSite,\n    ): Promise<CoreFilterFilter[]> {\n\n        // Check the memory cache first.\n        const result = this.getFromMemoryCache(options.courseId ?? -1, contextLevel, instanceId, site);\n        if (result) {\n            return result;\n        }\n\n        const siteId = site.getId();\n\n        const contexts = await getFilters();\n\n        const filters = await CoreFilter.getAvailableInContexts(contexts, siteId);\n\n        this.storeInMemoryCache(options.courseId ?? -1, contextLevel, filters, siteId);\n\n        return filters[contextLevel][instanceId] || [];\n    }\n\n    /**\n     * If user is enrolled in the course, return contexts of all enrolled courses to decrease number of WS requests.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the contexts.\n     */\n    async getCourseContexts(courseId: number, siteId?: string): Promise<CoreFiltersGetAvailableInContextWSParamContext[]> {\n        const courseIds = await CoreCourses.getCourseIdsIfEnrolled(courseId, siteId);\n\n        const contexts: CoreFiltersGetAvailableInContextWSParamContext[] = [];\n\n        courseIds.forEach((courseId) => {\n            contexts.push({\n                contextlevel: 'course',\n                instanceid: courseId,\n            });\n        });\n\n        return contexts;\n    }\n\n    /**\n     * Get the contexts of all course modules in a course.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the contexts.\n     */\n    async getCourseModulesContexts(courseId: number, siteId?: string): Promise<CoreFiltersGetAvailableInContextWSParamContext[]> {\n        // Use stale while revalidate, but always use the first value. If data is updated it will be stored in DB.\n        const sections = await firstValueFrom(CoreCourse.getSectionsObservable(courseId, {\n            excludeContents: true,\n            readingStrategy: CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE,\n            siteId,\n        }));\n\n        const contexts: CoreFiltersGetAvailableInContextWSParamContext[] = [];\n\n        sections.forEach((section) => {\n            if (section.modules) {\n                section.modules.forEach((module) => {\n                    if (CoreCourseHelper.canUserViewModule(module, section)) {\n                        contexts.push({\n                            contextlevel: 'module',\n                            instanceid: module.id,\n                        });\n                    }\n                });\n            }\n        });\n\n        return contexts;\n    }\n\n    /**\n     * Get the filters in a certain context, performing some checks like the site version.\n     * It's recommended to use this function instead of canGetFilters + getEnabledFilters because this function will check if\n     * it's really needed to call the WS.\n     *\n     * @param contextLevel The context level.\n     * @param instanceId Instance ID related to the context.\n     * @param options Options for format text.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the filters.\n     */\n    async getFilters(\n        contextLevel: string,\n        instanceId: number,\n        options?: CoreFilterFormatTextOptions,\n        siteId?: string,\n    ): Promise<CoreFilterFilter[]> {\n        options = options || {};\n        options.contextLevel = contextLevel;\n        options.instanceId = instanceId;\n        options.filter = false;\n\n        try {\n            const site = await CoreSites.getSite(siteId);\n\n            siteId = site.getId();\n\n            const canGet = await CoreFilter.canGetFilters(siteId);\n            if (!canGet) {\n                options.filter = true;\n\n                // We cannot check which filters are available, apply them all.\n                return await CoreFilterDelegate.getEnabledFilters(contextLevel, instanceId);\n            }\n\n            const courseId = options.courseId;\n            let hasFilters = true;\n\n            if (contextLevel == 'system' || (contextLevel == 'course' && instanceId == site.getSiteHomeId())) {\n                // No need to check the site filters because we're requesting the same context, so we'd do the same twice.\n            } else {\n                // Check if site has any filter to treat.\n                hasFilters = await this.siteHasFiltersToTreat(options, siteId);\n            }\n\n            if (!hasFilters) {\n                return [];\n            }\n\n            options.filter = true;\n\n            if (contextLevel == 'module' && courseId) {\n                // Get all the modules filters with a single call to decrease the number of WS calls.\n                const getFilters = () => this.getCourseModulesContexts(courseId, siteId);\n\n                return await this.getCacheableFilters(contextLevel, instanceId, getFilters, options, site);\n\n            } else if (contextLevel == 'course') {\n                // If enrolled, get all enrolled courses filters with a single call to decrease number of WS calls.\n                const getFilters = () => this.getCourseContexts(instanceId, siteId);\n\n                return await this.getCacheableFilters(contextLevel, instanceId, getFilters, options, site);\n            } else if (contextLevel == 'block' && courseId && CoreCourse.canGetCourseBlocks(site)) {\n                // Get all the course blocks filters with a single call to decrease number of WS calls.\n                const getFilters = () => this.getBlocksContexts(courseId, siteId);\n\n                return await this.getCacheableFilters(contextLevel, instanceId, getFilters, options, site);\n            }\n\n            return await CoreFilter.getAvailableInContext(contextLevel, instanceId, siteId);\n        } catch (error) {\n            this.logger.error('Error getting filters, return an empty array', error, contextLevel, instanceId);\n\n            return [];\n        }\n    }\n\n    /**\n     * Get filters and format text.\n     *\n     * @param text Text to filter.\n     * @param contextLevel The context level.\n     * @param instanceId Instance ID related to the context.\n     * @param options Options for format text.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the formatted text and the filters.\n     */\n    async getFiltersAndFormatText(\n        text: string,\n        contextLevel: string,\n        instanceId: number,\n        options?: CoreFilterFormatTextOptions,\n        siteId?: string,\n    ): Promise<{text: string; filters: CoreFilterFilter[]}> {\n\n        const filters = await this.getFilters(contextLevel, instanceId, options, siteId);\n\n        text = await CoreFilter.formatText(text, options, filters, siteId);\n\n        return { text, filters: filters };\n    }\n\n    /**\n     * Get module context filters from the memory cache.\n     *\n     * @param courseId Course the module belongs to.\n     * @param contextLevel Context level.\n     * @param instanceId Instance ID.\n     * @param site Site.\n     * @returns The filters, undefined if not found.\n     */\n    protected getFromMemoryCache(\n        courseId: number,\n        contextLevel: string,\n        instanceId: number,\n        site: CoreSite,\n    ): CoreFilterFilter[] | undefined {\n\n        const siteId = site.getId();\n\n        // Check if we have the context in the memory cache.\n        if (!this.moduleContextsCache[siteId]?.[courseId]?.[contextLevel]) {\n            return;\n        }\n\n        const cachedData = this.moduleContextsCache[siteId][courseId][contextLevel];\n\n        if (!CoreNetwork.isOnline() || Date.now() <= cachedData.time + site.getExpirationDelay(CoreSite.FREQUENCY_RARELY)) {\n            // We can use cache, return the filters if found.\n            return cachedData.contexts[contextLevel] && cachedData.contexts[contextLevel][instanceId];\n        }\n    }\n\n    /**\n     * Check if site has available any filter that should be treated by the app.\n     *\n     * @param options Options passed to the filters.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it has filters to treat.\n     */\n    async siteHasFiltersToTreat(options?: CoreFilterFormatTextOptions, siteId?: string): Promise<boolean> {\n        options = options || {};\n\n        const site = await CoreSites.getSite(siteId);\n\n        // Get filters at site level.\n        const filters = await CoreFilter.getAvailableInContext('system', 0, site.getId());\n\n        return CoreFilterDelegate.shouldBeApplied(filters, options, site);\n    }\n\n    /**\n     * Store filters in the memory cache.\n     *\n     * @param courseId Course the module belongs to.\n     * @param contextLevel Context level.\n     * @param contexts Contexts.\n     * @param siteId Site ID.\n     */\n    protected storeInMemoryCache(\n        courseId: number,\n        contextLevel: string,\n        contexts: CoreFilterClassifiedFilters,\n        siteId: string,\n    ): void {\n\n        this.moduleContextsCache[siteId] = this.moduleContextsCache[siteId] || {};\n        this.moduleContextsCache[siteId][courseId] = this.moduleContextsCache[siteId][courseId] || {};\n        this.moduleContextsCache[siteId][courseId][contextLevel] = {\n            contexts: contexts,\n            time: Date.now(),\n        };\n    }\n\n}\n\nexport const CoreFilterHelper = makeSingleton(CoreFilterHelperProvider);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}