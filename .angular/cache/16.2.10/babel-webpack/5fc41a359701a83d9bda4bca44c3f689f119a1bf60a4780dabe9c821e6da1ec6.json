{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreDelegate } from '@classes/delegate';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\n/**\n * Delegate to register access rules for quiz module.\n */\nexport class AddonModQuizAccessRuleDelegateService extends CoreDelegate {\n  constructor() {\n    super('AddonModQuizAccessRulesDelegate', true);\n    this.handlerNameProperty = 'ruleName';\n  }\n  /**\n   * Get the handler for a certain rule.\n   *\n   * @param ruleName Name of the access rule.\n   * @returns Handler. Undefined if no handler found for the rule.\n   */\n  getAccessRuleHandler(ruleName) {\n    return this.getHandler(ruleName, true);\n  }\n  /**\n   * Given a list of rules, get some fixed preflight data (data that doesn't require user interaction).\n   *\n   * @param rules List of active rules names.\n   * @param quiz Quiz.\n   * @param preflightData Object where to store the preflight data.\n   * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when all the data has been gathered.\n   */\n  getFixedPreflightData(rules, quiz, preflightData, attempt, prefetch, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      rules = rules || [];\n      yield CoreUtils.ignoreErrors(CoreUtils.allPromises(rules.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (rule) {\n          yield _this.executeFunctionOnEnabled(rule, 'getFixedPreflightData', [quiz, preflightData, attempt, prefetch, siteId]);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }())));\n    })();\n  }\n  /**\n   * Get the Component to use to display the access rule preflight.\n   *\n   * @param rule Rule.\n   * @returns Promise resolved with the component to use, undefined if not found.\n   */\n  getPreflightComponent(rule) {\n    return Promise.resolve(this.executeFunctionOnEnabled(rule, 'getPreflightComponent', []));\n  }\n  /**\n   * Check if an access rule is supported.\n   *\n   * @param ruleName Name of the rule.\n   * @returns Whether it's supported.\n   */\n  isAccessRuleSupported(ruleName) {\n    return this.hasHandler(ruleName, true);\n  }\n  /**\n   * Given a list of rules, check if preflight check is required.\n   *\n   * @param rules List of active rules names.\n   * @param quiz Quiz.\n   * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it's required.\n   */\n  isPreflightCheckRequired(rules, quiz, attempt, prefetch, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      rules = rules || [];\n      let isRequired = false;\n      yield CoreUtils.ignoreErrors(CoreUtils.allPromises(rules.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (rule) {\n          const ruleRequired = yield _this2.isPreflightCheckRequiredForRule(rule, quiz, attempt, prefetch, siteId);\n          isRequired = isRequired || ruleRequired;\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }())));\n      return isRequired;\n    })();\n  }\n  /**\n   * Check if preflight check is required for a certain rule.\n   *\n   * @param rule Rule name.\n   * @param quiz Quiz.\n   * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it's required.\n   */\n  isPreflightCheckRequiredForRule(rule, quiz, attempt, prefetch, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const isRequired = yield _this3.executeFunctionOnEnabled(rule, 'isPreflightCheckRequired', [quiz, attempt, prefetch, siteId]);\n      return !!isRequired;\n    })();\n  }\n  /**\n   * Notify all rules that the preflight check has passed.\n   *\n   * @param rules List of active rules names.\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param preflightData Preflight data gathered.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  notifyPreflightCheckPassed(rules, quiz, attempt, preflightData, prefetch, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      rules = rules || [];\n      yield CoreUtils.ignoreErrors(CoreUtils.allPromises(rules.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (rule) {\n          yield _this4.executeFunctionOnEnabled(rule, 'notifyPreflightCheckPassed', [quiz, attempt, preflightData, prefetch, siteId]);\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }())));\n    })();\n  }\n  /**\n   * Notify all rules that the preflight check has failed.\n   *\n   * @param rules List of active rules names.\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param preflightData Preflight data gathered.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  notifyPreflightCheckFailed(rules, quiz, attempt, preflightData, prefetch, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      rules = rules || [];\n      yield CoreUtils.ignoreErrors(CoreUtils.allPromises(rules.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (rule) {\n          yield _this5.executeFunctionOnEnabled(rule, 'notifyPreflightCheckFailed', [quiz, attempt, preflightData, prefetch, siteId]);\n        });\n        return function (_x4) {\n          return _ref4.apply(this, arguments);\n        };\n      }())));\n    })();\n  }\n  /**\n   * Whether or not the time left of an attempt should be displayed.\n   *\n   * @param rules List of active rules names.\n   * @param attempt The attempt.\n   * @param endTime The attempt end time (in seconds).\n   * @param timeNow The current time in seconds.\n   * @returns Whether it should be displayed.\n   */\n  shouldShowTimeLeft(rules, attempt, endTime, timeNow) {\n    rules = rules || [];\n    for (const i in rules) {\n      const rule = rules[i];\n      if (this.executeFunctionOnEnabled(rule, 'shouldShowTimeLeft', [attempt, endTime, timeNow])) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n_class = AddonModQuizAccessRuleDelegateService;\n_class.ɵfac = function AddonModQuizAccessRuleDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModQuizAccessRuleDelegate = makeSingleton(AddonModQuizAccessRuleDelegateService);","map":{"version":3,"names":["CoreDelegate","CoreUtils","makeSingleton","AddonModQuizAccessRuleDelegateService","constructor","handlerNameProperty","getAccessRuleHandler","ruleName","getHandler","getFixedPreflightData","rules","quiz","preflightData","attempt","prefetch","siteId","_this","_asyncToGenerator","ignoreErrors","allPromises","map","_ref","rule","executeFunctionOnEnabled","_x","apply","arguments","getPreflightComponent","Promise","resolve","isAccessRuleSupported","hasHandler","isPreflightCheckRequired","_this2","isRequired","_ref2","ruleRequired","isPreflightCheckRequiredForRule","_x2","_this3","notifyPreflightCheckPassed","_this4","_ref3","_x3","notifyPreflightCheckFailed","_this5","_ref4","_x4","shouldShowTimeLeft","endTime","timeNow","i","factory","ɵfac","providedIn","AddonModQuizAccessRuleDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/quiz/services/access-rules-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\n\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { AddonModQuizAttemptWSData, AddonModQuizQuizWSData } from './quiz';\n\n/**\n * Interface that all access rules handlers must implement.\n */\nexport interface AddonModQuizAccessRuleHandler extends CoreDelegateHandler {\n\n    /**\n     * Name of the rule the handler supports. E.g. 'password'.\n     */\n    ruleName: string;\n\n    /**\n     * Whether the rule requires a preflight check when prefetch/start/continue an attempt.\n     *\n     * @param quiz The quiz the rule belongs to.\n     * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Whether the rule requires a preflight check.\n     */\n    isPreflightCheckRequired(\n        quiz: AddonModQuizQuizWSData,\n        attempt?: AddonModQuizAttemptWSData,\n        prefetch?: boolean,\n        siteId?: string,\n    ): boolean | Promise<boolean>;\n\n    /**\n     * Add preflight data that doesn't require user interaction. The data should be added to the preflightData param.\n     *\n     * @param quiz The quiz the rule belongs to.\n     * @param preflightData Object where to add the preflight data.\n     * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done if async, void if it's synchronous.\n     */\n    getFixedPreflightData?(\n        quiz: AddonModQuizQuizWSData,\n        preflightData: Record<string, string>,\n        attempt?: AddonModQuizAttemptWSData,\n        prefetch?: boolean,\n        siteId?: string,\n    ): void | Promise<void>;\n\n    /**\n     * Return the Component to use to display the access rule preflight.\n     * Implement this if your access rule requires a preflight check with user interaction.\n     * It's recommended to return the class of the component, but you can also return an instance of the component.\n     *\n     * @returns The component (or promise resolved with component) to use, undefined if not found.\n     */\n    getPreflightComponent?(): undefined | Type<unknown> | Promise<Type<unknown>>;\n\n    /**\n     * Function called when the preflight check has passed. This is a chance to record that fact in some way.\n     *\n     * @param quiz The quiz the rule belongs to.\n     * @param attempt The attempt started/continued.\n     * @param preflightData Preflight data gathered.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done if async, void if it's synchronous.\n     */\n    notifyPreflightCheckPassed?(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData | undefined,\n        preflightData: Record<string, string>,\n        prefetch?: boolean,\n        siteId?: string,\n    ): void | Promise<void>;\n\n    /**\n     * Function called when the preflight check fails. This is a chance to record that fact in some way.\n     *\n     * @param quiz The quiz the rule belongs to.\n     * @param attempt The attempt started/continued.\n     * @param preflightData Preflight data gathered.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done if async, void if it's synchronous.\n     */\n    notifyPreflightCheckFailed?(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData | undefined,\n        preflightData: Record<string, string>,\n        prefetch?: boolean,\n        siteId?: string,\n    ): void | Promise<void>;\n\n    /**\n     * Whether or not the time left of an attempt should be displayed.\n     *\n     * @param attempt The attempt.\n     * @param endTime The attempt end time (in seconds).\n     * @param timeNow The current time in seconds.\n     * @returns Whether it should be displayed.\n     */\n    shouldShowTimeLeft?(attempt: AddonModQuizAttemptWSData, endTime: number, timeNow: number): boolean;\n}\n\n/**\n * Delegate to register access rules for quiz module.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModQuizAccessRuleDelegateService extends CoreDelegate<AddonModQuizAccessRuleHandler> {\n\n    protected handlerNameProperty = 'ruleName';\n\n    constructor() {\n        super('AddonModQuizAccessRulesDelegate', true);\n    }\n\n    /**\n     * Get the handler for a certain rule.\n     *\n     * @param ruleName Name of the access rule.\n     * @returns Handler. Undefined if no handler found for the rule.\n     */\n    getAccessRuleHandler(ruleName: string): AddonModQuizAccessRuleHandler {\n        return this.getHandler(ruleName, true);\n    }\n\n    /**\n     * Given a list of rules, get some fixed preflight data (data that doesn't require user interaction).\n     *\n     * @param rules List of active rules names.\n     * @param quiz Quiz.\n     * @param preflightData Object where to store the preflight data.\n     * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when all the data has been gathered.\n     */\n    async getFixedPreflightData(\n        rules: string[],\n        quiz: AddonModQuizQuizWSData,\n        preflightData: Record<string, string>,\n        attempt?: AddonModQuizAttemptWSData,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        rules = rules || [];\n\n        await CoreUtils.ignoreErrors(CoreUtils.allPromises(rules.map(async (rule) => {\n            await this.executeFunctionOnEnabled(rule, 'getFixedPreflightData', [quiz, preflightData, attempt, prefetch, siteId]);\n        })));\n    }\n\n    /**\n     * Get the Component to use to display the access rule preflight.\n     *\n     * @param rule Rule.\n     * @returns Promise resolved with the component to use, undefined if not found.\n     */\n    getPreflightComponent(rule: string): Promise<Type<unknown> | undefined> {\n        return Promise.resolve(this.executeFunctionOnEnabled(rule, 'getPreflightComponent', []));\n    }\n\n    /**\n     * Check if an access rule is supported.\n     *\n     * @param ruleName Name of the rule.\n     * @returns Whether it's supported.\n     */\n    isAccessRuleSupported(ruleName: string): boolean {\n        return this.hasHandler(ruleName, true);\n    }\n\n    /**\n     * Given a list of rules, check if preflight check is required.\n     *\n     * @param rules List of active rules names.\n     * @param quiz Quiz.\n     * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it's required.\n     */\n    async isPreflightCheckRequired(\n        rules: string[],\n        quiz: AddonModQuizQuizWSData,\n        attempt?: AddonModQuizAttemptWSData,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<boolean> {\n        rules = rules || [];\n        let isRequired = false;\n\n        await CoreUtils.ignoreErrors(CoreUtils.allPromises(rules.map(async (rule) => {\n            const ruleRequired = await this.isPreflightCheckRequiredForRule(rule, quiz, attempt, prefetch, siteId);\n\n            isRequired = isRequired || ruleRequired;\n        })));\n\n        return isRequired;\n    }\n\n    /**\n     * Check if preflight check is required for a certain rule.\n     *\n     * @param rule Rule name.\n     * @param quiz Quiz.\n     * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it's required.\n     */\n    async isPreflightCheckRequiredForRule(\n        rule: string,\n        quiz: AddonModQuizQuizWSData,\n        attempt?: AddonModQuizAttemptWSData,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<boolean> {\n        const isRequired = await this.executeFunctionOnEnabled(rule, 'isPreflightCheckRequired', [quiz, attempt, prefetch, siteId]);\n\n        return !!isRequired;\n    }\n\n    /**\n     * Notify all rules that the preflight check has passed.\n     *\n     * @param rules List of active rules names.\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param preflightData Preflight data gathered.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async notifyPreflightCheckPassed(\n        rules: string[],\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData | undefined,\n        preflightData: Record<string, string>,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        rules = rules || [];\n\n        await CoreUtils.ignoreErrors(CoreUtils.allPromises(rules.map(async (rule) => {\n            await this.executeFunctionOnEnabled(\n                rule,\n                'notifyPreflightCheckPassed',\n                [quiz, attempt, preflightData, prefetch, siteId],\n            );\n        })));\n    }\n\n    /**\n     * Notify all rules that the preflight check has failed.\n     *\n     * @param rules List of active rules names.\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param preflightData Preflight data gathered.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async notifyPreflightCheckFailed(\n        rules: string[],\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData | undefined,\n        preflightData: Record<string, string>,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        rules = rules || [];\n\n        await CoreUtils.ignoreErrors(CoreUtils.allPromises(rules.map(async (rule) => {\n            await this.executeFunctionOnEnabled(\n                rule,\n                'notifyPreflightCheckFailed',\n                [quiz, attempt, preflightData, prefetch, siteId],\n            );\n        })));\n    }\n\n    /**\n     * Whether or not the time left of an attempt should be displayed.\n     *\n     * @param rules List of active rules names.\n     * @param attempt The attempt.\n     * @param endTime The attempt end time (in seconds).\n     * @param timeNow The current time in seconds.\n     * @returns Whether it should be displayed.\n     */\n    shouldShowTimeLeft(rules: string[], attempt: AddonModQuizAttemptWSData, endTime: number, timeNow: number): boolean {\n        rules = rules || [];\n\n        for (const i in rules) {\n            const rule = rules[i];\n\n            if (this.executeFunctionOnEnabled(rule, 'shouldShowTimeLeft', [attempt, endTime, timeNow])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n}\n\nexport const AddonModQuizAccessRuleDelegate = makeSingleton(AddonModQuizAccessRuleDelegateService);\n"],"mappings":";;AAgBA,SAASA,YAAY,QAA6B,mBAAmB;AACrE,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,aAAa,QAAQ,aAAa;;AAuG3C;;;AAIA,OAAM,MAAOC,qCAAsC,SAAQH,YAA2C;EAIlGI,YAAA;IACI,KAAK,CAAC,iCAAiC,EAAE,IAAI,CAAC;IAHxC,KAAAC,mBAAmB,GAAG,UAAU;EAI1C;EAEA;;;;;;EAMAC,oBAAoBA,CAACC,QAAgB;IACjC,OAAO,IAAI,CAACC,UAAU,CAACD,QAAQ,EAAE,IAAI,CAAC;EAC1C;EAEA;;;;;;;;;;;EAWME,qBAAqBA,CACvBC,KAAe,EACfC,IAA4B,EAC5BC,aAAqC,EACrCC,OAAmC,EACnCC,QAAkB,EAClBC,MAAe;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAEfP,KAAK,GAAGA,KAAK,IAAI,EAAE;MAEnB,MAAMT,SAAS,CAACiB,YAAY,CAACjB,SAAS,CAACkB,WAAW,CAACT,KAAK,CAACU,GAAG;QAAA,IAAAC,IAAA,GAAAJ,iBAAA,CAAC,WAAOK,IAAI,EAAI;UACxE,MAAMN,KAAI,CAACO,wBAAwB,CAACD,IAAI,EAAE,uBAAuB,EAAE,CAACX,IAAI,EAAEC,aAAa,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,MAAM,CAAC,CAAC;QACxH,CAAC;QAAA,iBAAAS,EAAA;UAAA,OAAAH,IAAA,CAAAI,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC,CAAC,CAAC;IAAC;EACT;EAEA;;;;;;EAMAC,qBAAqBA,CAACL,IAAY;IAC9B,OAAOM,OAAO,CAACC,OAAO,CAAC,IAAI,CAACN,wBAAwB,CAACD,IAAI,EAAE,uBAAuB,EAAE,EAAE,CAAC,CAAC;EAC5F;EAEA;;;;;;EAMAQ,qBAAqBA,CAACvB,QAAgB;IAClC,OAAO,IAAI,CAACwB,UAAU,CAACxB,QAAQ,EAAE,IAAI,CAAC;EAC1C;EAEA;;;;;;;;;;EAUMyB,wBAAwBA,CAC1BtB,KAAe,EACfC,IAA4B,EAC5BE,OAAmC,EACnCC,QAAkB,EAClBC,MAAe;IAAA,IAAAkB,MAAA;IAAA,OAAAhB,iBAAA;MAEfP,KAAK,GAAGA,KAAK,IAAI,EAAE;MACnB,IAAIwB,UAAU,GAAG,KAAK;MAEtB,MAAMjC,SAAS,CAACiB,YAAY,CAACjB,SAAS,CAACkB,WAAW,CAACT,KAAK,CAACU,GAAG;QAAA,IAAAe,KAAA,GAAAlB,iBAAA,CAAC,WAAOK,IAAI,EAAI;UACxE,MAAMc,YAAY,SAASH,MAAI,CAACI,+BAA+B,CAACf,IAAI,EAAEX,IAAI,EAAEE,OAAO,EAAEC,QAAQ,EAAEC,MAAM,CAAC;UAEtGmB,UAAU,GAAGA,UAAU,IAAIE,YAAY;QAC3C,CAAC;QAAA,iBAAAE,GAAA;UAAA,OAAAH,KAAA,CAAAV,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC,CAAC,CAAC;MAEJ,OAAOQ,UAAU;IAAC;EACtB;EAEA;;;;;;;;;;EAUMG,+BAA+BA,CACjCf,IAAY,EACZX,IAA4B,EAC5BE,OAAmC,EACnCC,QAAkB,EAClBC,MAAe;IAAA,IAAAwB,MAAA;IAAA,OAAAtB,iBAAA;MAEf,MAAMiB,UAAU,SAASK,MAAI,CAAChB,wBAAwB,CAACD,IAAI,EAAE,0BAA0B,EAAE,CAACX,IAAI,EAAEE,OAAO,EAAEC,QAAQ,EAAEC,MAAM,CAAC,CAAC;MAE3H,OAAO,CAAC,CAACmB,UAAU;IAAC;EACxB;EAEA;;;;;;;;;;;EAWMM,0BAA0BA,CAC5B9B,KAAe,EACfC,IAA4B,EAC5BE,OAA8C,EAC9CD,aAAqC,EACrCE,QAAkB,EAClBC,MAAe;IAAA,IAAA0B,MAAA;IAAA,OAAAxB,iBAAA;MAEfP,KAAK,GAAGA,KAAK,IAAI,EAAE;MAEnB,MAAMT,SAAS,CAACiB,YAAY,CAACjB,SAAS,CAACkB,WAAW,CAACT,KAAK,CAACU,GAAG;QAAA,IAAAsB,KAAA,GAAAzB,iBAAA,CAAC,WAAOK,IAAI,EAAI;UACxE,MAAMmB,MAAI,CAAClB,wBAAwB,CAC/BD,IAAI,EACJ,4BAA4B,EAC5B,CAACX,IAAI,EAAEE,OAAO,EAAED,aAAa,EAAEE,QAAQ,EAAEC,MAAM,CAAC,CACnD;QACL,CAAC;QAAA,iBAAA4B,GAAA;UAAA,OAAAD,KAAA,CAAAjB,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC,CAAC,CAAC;IAAC;EACT;EAEA;;;;;;;;;;;EAWMkB,0BAA0BA,CAC5BlC,KAAe,EACfC,IAA4B,EAC5BE,OAA8C,EAC9CD,aAAqC,EACrCE,QAAkB,EAClBC,MAAe;IAAA,IAAA8B,MAAA;IAAA,OAAA5B,iBAAA;MAEfP,KAAK,GAAGA,KAAK,IAAI,EAAE;MAEnB,MAAMT,SAAS,CAACiB,YAAY,CAACjB,SAAS,CAACkB,WAAW,CAACT,KAAK,CAACU,GAAG;QAAA,IAAA0B,KAAA,GAAA7B,iBAAA,CAAC,WAAOK,IAAI,EAAI;UACxE,MAAMuB,MAAI,CAACtB,wBAAwB,CAC/BD,IAAI,EACJ,4BAA4B,EAC5B,CAACX,IAAI,EAAEE,OAAO,EAAED,aAAa,EAAEE,QAAQ,EAAEC,MAAM,CAAC,CACnD;QACL,CAAC;QAAA,iBAAAgC,GAAA;UAAA,OAAAD,KAAA,CAAArB,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC,CAAC,CAAC;IAAC;EACT;EAEA;;;;;;;;;EASAsB,kBAAkBA,CAACtC,KAAe,EAAEG,OAAkC,EAAEoC,OAAe,EAAEC,OAAe;IACpGxC,KAAK,GAAGA,KAAK,IAAI,EAAE;IAEnB,KAAK,MAAMyC,CAAC,IAAIzC,KAAK,EAAE;MACnB,MAAMY,IAAI,GAAGZ,KAAK,CAACyC,CAAC,CAAC;MAErB,IAAI,IAAI,CAAC5B,wBAAwB,CAACD,IAAI,EAAE,oBAAoB,EAAE,CAACT,OAAO,EAAEoC,OAAO,EAAEC,OAAO,CAAC,CAAC,EAAE;QACxF,OAAO,IAAI;;;IAInB,OAAO,KAAK;EAChB;;SApMS/C,qCAAsC;;mBAAtCA,MAAqC;AAAA;;SAArCA,MAAqC;EAAAiD,OAAA,EAArCjD,MAAqC,CAAAkD,IAAA;EAAAC,UAAA,EADxB;AAAM;AAyMhC,OAAO,MAAMC,8BAA8B,GAAGrD,aAAa,CAACC,qCAAqC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}