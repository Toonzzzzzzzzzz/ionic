{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _class;\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, NgZone } from '@singletons';\nimport * as i0 from \"@angular/core\";\n/**\n * Behat Dom Utils helper functions.\n */\nexport class TestingBehatDomUtilsService {\n  /**\n   * Check if an element is clickable.\n   *\n   * @param element Element.\n   * @returns Whether the element is clickable or not.\n   */\n  isElementClickable(element) {\n    return element.getAttribute('aria-disabled') !== 'true' && !element.hasAttribute('disabled');\n  }\n  /**\n   * Check if an element is visible.\n   *\n   * @param element Element.\n   * @param container Container. If set, the function will also check parent elements visibility.\n   * @returns Whether the element is visible or not.\n   */\n  isElementVisible(element, container) {\n    if (element.getAttribute('aria-hidden') === 'true' || getComputedStyle(element).display === 'none') {\n      return false;\n    }\n    if (element.tagName === 'SWIPER-SLIDE') {\n      // Check if the slide is visible (in the viewport).\n      const bounding = element.getBoundingClientRect();\n      if (bounding.right <= 0 || bounding.left >= window.innerWidth) {\n        return false;\n      }\n    }\n    if (!container) {\n      return true;\n    }\n    const parentElement = this.getParentElement(element);\n    if (parentElement === container) {\n      return true;\n    }\n    if (!parentElement) {\n      return false;\n    }\n    return this.isElementVisible(parentElement, container);\n  }\n  /**\n   * Check if an element is selected.\n   *\n   * @param element Element.\n   * @param container Container.\n   * @returns Whether the element is selected or not.\n   */\n  isElementSelected(element, container) {\n    const ariaCurrent = element.getAttribute('aria-current');\n    if (ariaCurrent && ariaCurrent !== 'false' || element.getAttribute('aria-selected') === 'true' || element.getAttribute('aria-checked') === 'true') {\n      return true;\n    }\n    const parentElement = this.getParentElement(element);\n    if (!parentElement || parentElement === container) {\n      return false;\n    }\n    return this.isElementSelected(parentElement, container);\n  }\n  /**\n   * Finds elements within a given container with exact info.\n   *\n   * @param container Parent element to search the element within\n   * @param text Text to look for\n   * @param options Search options.\n   * @returns Elements containing the given text with exact boolean.\n   */\n  findElementsBasedOnTextWithinWithExact(container, text, options) {\n    // Escape double quotes to prevent breaking the query selector.\n    const escapedText = text.replace(/\"/g, '\\\\\"');\n    const attributesSelector = `[aria-label*=\"${escapedText}\"], a[title*=\"${escapedText}\"], ` + `img[alt*=\"${escapedText}\"], [placeholder*=\"${escapedText}\"]`;\n    const elements = Array.from(container.querySelectorAll(attributesSelector)).filter(element => this.isElementVisible(element, container) && (!options.onlyClickable || this.isElementClickable(element))).map(element => {\n      const exact = this.checkElementLabel(element, text);\n      return {\n        element,\n        exact\n      };\n    });\n    const treeWalker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_DOCUMENT_FRAGMENT | NodeFilter.SHOW_TEXT,\n    // eslint-disable-line no-bitwise\n    {\n      acceptNode: node => {\n        if (node instanceof HTMLStyleElement || node instanceof HTMLLinkElement || node instanceof HTMLScriptElement) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        if (!(node instanceof HTMLElement)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (options.onlyClickable && !this.isElementClickable(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        if (!this.isElementVisible(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    });\n    let fallbackCandidates = [];\n    let currentNode = null;\n    // eslint-disable-next-line no-cond-assign\n    while (currentNode = treeWalker.nextNode()) {\n      if (currentNode instanceof Text) {\n        var _currentNode$textCont;\n        if ((_currentNode$textCont = currentNode.textContent) !== null && _currentNode$textCont !== void 0 && _currentNode$textCont.includes(text) && currentNode.parentElement) {\n          elements.push({\n            element: currentNode.parentElement,\n            exact: currentNode.textContent.trim() === text\n          });\n        }\n        continue;\n      }\n      if (currentNode instanceof HTMLElement) {\n        const labelledBy = currentNode.getAttribute('aria-labelledby');\n        const labelElement = labelledBy && container.querySelector(`#${labelledBy}`);\n        if (labelElement && labelElement.innerText && labelElement.innerText.includes(text)) {\n          elements.push({\n            element: currentNode,\n            exact: labelElement.innerText.trim() == text\n          });\n          continue;\n        }\n      }\n      if (currentNode instanceof Element && currentNode.shadowRoot) {\n        for (const childNode of Array.from(currentNode.shadowRoot.childNodes)) {\n          if (!(childNode instanceof HTMLElement) || childNode instanceof HTMLStyleElement || childNode instanceof HTMLLinkElement || childNode instanceof HTMLScriptElement) {\n            continue;\n          }\n          if (childNode.matches(attributesSelector)) {\n            elements.push({\n              element: childNode,\n              exact: this.checkElementLabel(childNode, text)\n            });\n            continue;\n          }\n          elements.push(...this.findElementsBasedOnTextWithinWithExact(childNode, text, options));\n        }\n      }\n      // Allow searching text split into different elements in some cases.\n      if (elements.length === 0 && currentNode instanceof HTMLElement && TestingBehatDomUtilsService.MULTI_ELEM_ALLOWED.includes(currentNode.tagName) && currentNode.innerText.includes(text)) {\n        // Only keep the child elements in the candidates list.\n        fallbackCandidates = fallbackCandidates.filter(entry => !entry.element.contains(currentNode));\n        fallbackCandidates.push({\n          element: currentNode,\n          exact: currentNode.innerText.trim() == text\n        });\n      }\n    }\n    return elements.length > 0 ? elements : fallbackCandidates;\n  }\n  /**\n   * Checks an element has exactly the same label (title, alt or aria-label).\n   *\n   * @param element Element to check.\n   * @param text Text to check.\n   * @returns If text matches any of the label attributes.\n   */\n  checkElementLabel(element, text) {\n    return element.title === text || element.getAttribute('alt') === text || element.getAttribute('aria-label') === text || element.getAttribute('placeholder') === text;\n  }\n  /**\n   * Finds elements within a given container.\n   *\n   * @param container Parent element to search the element within.\n   * @param text Text to look for.\n   * @param options Search options.\n   * @returns Elements containing the given text.\n   */\n  findElementsBasedOnTextWithin(container, text, options) {\n    const elements = this.findElementsBasedOnTextWithinWithExact(container, text, options);\n    // Give more relevance to exact matches.\n    elements.sort((a, b) => Number(b.exact) - Number(a.exact));\n    return elements.map(element => element.element);\n  }\n  /**\n   * Given a list of elements, get the top ancestors among all of them.\n   *\n   * This will remote duplicates and drop any elements nested within each other.\n   *\n   * @param elements Elements list.\n   * @returns Top ancestors.\n   */\n  getTopAncestors(elements) {\n    const uniqueElements = new Set(elements);\n    for (const element of uniqueElements) {\n      for (const otherElement of uniqueElements) {\n        if (otherElement === element) {\n          continue;\n        }\n        if (element.contains(otherElement)) {\n          uniqueElements.delete(otherElement);\n        }\n      }\n    }\n    return Array.from(uniqueElements);\n  }\n  /**\n   * Get parent element, including Shadow DOM parents.\n   *\n   * @param element Element.\n   * @returns Parent element.\n   */\n  getParentElement(element) {\n    return element.parentElement || element.getRootNode() && element.getRootNode().host || null;\n  }\n  /**\n   * Get closest element matching a selector, without traversing up a given container.\n   *\n   * @param element Element.\n   * @param selector Selector.\n   * @param container Topmost container to search within.\n   * @returns Closest matching element.\n   */\n  getClosestMatching(element, selector, container) {\n    if (element.matches(selector)) {\n      return element;\n    }\n    if (element === container || !element.parentElement) {\n      return null;\n    }\n    return this.getClosestMatching(element.parentElement, selector, container);\n  }\n  /**\n   * Function to find top container elements.\n   *\n   * @param containerName Whether to search inside the a container name.\n   * @returns Found top container elements.\n   */\n  getCurrentTopContainerElements(containerName) {\n    const topContainers = [];\n    let containers = Array.from(document.querySelectorAll(['ion-alert.hydrated', 'ion-popover.hydrated', 'ion-action-sheet.hydrated', 'ion-modal.hydrated', 'core-user-tours-user-tour.is-active', 'ion-toast.hydrated', 'page-core-mainmenu', 'ion-app'].join(', ')));\n    containers = containers.filter(container => {\n      if (container.tagName === 'ION-ALERT') {\n        // For some reason, in Behat sometimes alerts aren't removed from DOM, the close animation doesn't finish.\n        // Filter alerts with pointer-events none since that style is set before the close animation starts.\n        return container.style.pointerEvents !== 'none';\n      }\n      // Ignore pages that are inside other visible pages.\n      return container.tagName !== 'ION-PAGE' || !container.closest('.ion-page.ion-page-hidden');\n    })\n    // Sort them by z-index.\n    .sort((a, b) => Number(getComputedStyle(b).zIndex) - Number(getComputedStyle(a).zIndex));\n    if (containerName === 'split-view content') {\n      // Find non hidden pages inside the containers.\n      containers.some(container => {\n        var _pageContainers$find;\n        if (!container.classList.contains('ion-page')) {\n          return false;\n        }\n        const pageContainers = Array.from(container.querySelectorAll('.ion-page:not(.ion-page-hidden)'));\n        let topContainer = (_pageContainers$find = pageContainers.find(page => !page.closest('.ion-page.ion-page-hidden'))) !== null && _pageContainers$find !== void 0 ? _pageContainers$find : null;\n        topContainer = (topContainer || container).querySelector('core-split-view ion-router-outlet');\n        topContainer && topContainers.push(topContainer);\n        return !!topContainer;\n      });\n      return topContainers;\n    }\n    // Get containers until one blocks other views.\n    containers.some(container => {\n      if (container.tagName === 'ION-TOAST') {\n        var _container$shadowRoot;\n        container = ((_container$shadowRoot = container.shadowRoot) === null || _container$shadowRoot === void 0 ? void 0 : _container$shadowRoot.querySelector('.toast-container')) || container;\n      }\n      topContainers.push(container);\n      // If container has backdrop it blocks the rest of the UI.\n      return container.querySelector(':scope > ion-backdrop') || container.classList.contains('backdrop');\n    });\n    return topContainers;\n  }\n  /**\n   * Find a field.\n   *\n   * @param field Field name.\n   * @returns Field element.\n   */\n  findField(field) {\n    const input = this.findElementBasedOnText({\n      text: field,\n      selector: 'input, textarea, [contenteditable=\"true\"], ion-select, ion-datetime'\n    }, {\n      onlyClickable: false,\n      containerName: ''\n    });\n    if (input) {\n      return input;\n    }\n    const label = this.findElementBasedOnText({\n      text: field,\n      selector: 'label'\n    }, {\n      onlyClickable: false,\n      containerName: ''\n    });\n    if (label) {\n      const inputId = label.getAttribute('for');\n      return inputId && document.getElementById(inputId) || undefined;\n    }\n  }\n  /**\n   * Function to find element based on their text or Aria label.\n   *\n   * @param locator Element locator.\n   * @param options Search options.\n   * @returns First found element.\n   */\n  findElementBasedOnText(locator, options = {}) {\n    return this.findElementsBasedOnText(locator, options)[0];\n  }\n  /**\n   * Function to find elements based on their text or Aria label.\n   *\n   * @param locator Element locator.\n   * @param options Search options.\n   * @returns Found elements\n   */\n  findElementsBasedOnText(locator, options) {\n    var _options$containerNam;\n    const topContainers = this.getCurrentTopContainerElements((_options$containerNam = options.containerName) !== null && _options$containerNam !== void 0 ? _options$containerNam : '');\n    let elements = [];\n    for (let i = 0; i < topContainers.length; i++) {\n      elements = elements.concat(this.findElementsBasedOnTextInContainer(locator, topContainers[i], options));\n      if (elements.length) {\n        break;\n      }\n    }\n    return elements;\n  }\n  /**\n   * Function to find elements based on their text or Aria label.\n   *\n   * @param locator Element locator.\n   * @param topContainer Container to search in.\n   * @param options Search options.\n   * @returns Found elements\n   */\n  findElementsBasedOnTextInContainer(locator, topContainer, options) {\n    let container = topContainer;\n    if (locator.within) {\n      const withinElements = this.findElementsBasedOnTextInContainer(locator.within, topContainer, options);\n      if (withinElements.length === 0) {\n        return [];\n      } else if (withinElements.length > 1) {\n        const withinElementsAncestors = this.getTopAncestors(withinElements);\n        if (withinElementsAncestors.length > 1) {\n          // Too many matches for within text.\n          return [];\n        }\n        topContainer = container = withinElementsAncestors[0];\n      } else {\n        topContainer = container = withinElements[0];\n      }\n    }\n    if (topContainer && locator.near) {\n      const nearElements = this.findElementsBasedOnTextInContainer(locator.near, topContainer, _objectSpread(_objectSpread({}, options), {}, {\n        onlyClickable: false\n      }));\n      if (nearElements.length === 0) {\n        return [];\n      } else if (nearElements.length > 1) {\n        const nearElementsAncestors = this.getTopAncestors(nearElements);\n        if (nearElementsAncestors.length > 1) {\n          // Too many matches for near text.\n          return [];\n        }\n        container = this.getParentElement(nearElementsAncestors[0]);\n      } else {\n        container = this.getParentElement(nearElements[0]);\n      }\n    }\n    do {\n      if (!container) {\n        break;\n      }\n      const elements = this.findElementsBasedOnTextWithin(container, locator.text, options);\n      let filteredElements = elements;\n      if (locator.selector) {\n        filteredElements = [];\n        const selector = locator.selector;\n        elements.forEach(element => {\n          const closest = this.getClosestMatching(element, selector, container);\n          if (closest) {\n            filteredElements.push(closest);\n          }\n        });\n      }\n      if (filteredElements.length > 0) {\n        return filteredElements;\n      }\n    } while (container !== topContainer && (container = this.getParentElement(container)) && container !== topContainer);\n    return [];\n  }\n  /**\n   * Make sure that an element is visible and wait to trigger the callback.\n   *\n   * @param element Element.\n   * @returns Promise resolved with the DOM rectangle.\n   */\n  ensureElementVisible(element) {\n    return _asyncToGenerator(function* () {\n      const initialRect = element.getBoundingClientRect();\n      element.scrollIntoView(false);\n      const promise = new CorePromisedValue();\n      requestAnimationFrame(() => {\n        const rect = element.getBoundingClientRect();\n        if (initialRect.y !== rect.y) {\n          setTimeout(() => {\n            promise.resolve(rect);\n          }, 300);\n          return;\n        }\n        promise.resolve(rect);\n      });\n      return promise;\n    })();\n  }\n  /**\n   * Press an element.\n   *\n   * @param element Element to press.\n   */\n  pressElement(element) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield NgZone.run( /*#__PURE__*/_asyncToGenerator(function* () {\n        const promise = new CorePromisedValue();\n        // Events don't bubble up across Shadow DOM boundaries, and some buttons\n        // may not work without doing this.\n        const parentElement = _this.getParentElement(element);\n        if (parentElement && parentElement.matches('ion-button, ion-back-button')) {\n          element = parentElement;\n        }\n        const rect = yield _this.ensureElementVisible(element);\n        // Simulate a mouse click on the button.\n        const eventOptions = {\n          clientX: rect.left + rect.width / 2,\n          clientY: rect.top + rect.height / 2,\n          bubbles: true,\n          view: window,\n          cancelable: true\n        };\n        // There are some buttons in the app that don't respond to click events, for example\n        // buttons using the core-supress-events directive. That's why we need to send both\n        // click and mouse events.\n        element.dispatchEvent(new MouseEvent('mousedown', eventOptions));\n        setTimeout(() => {\n          element.dispatchEvent(new MouseEvent('mouseup', eventOptions));\n          element.click();\n          promise.resolve();\n        }, 300);\n        return promise;\n      }));\n    })();\n  }\n  /**\n   * Set an element value.\n   *\n   * @param element HTML to set.\n   * @param value Value to be set.\n   */\n  setElementValue(element, value) {\n    return _asyncToGenerator(function* () {\n      yield NgZone.run( /*#__PURE__*/_asyncToGenerator(function* () {\n        const promise = new CorePromisedValue();\n        // Functions to get/set value depending on field type.\n        const setValue = text => {\n          if (element.tagName === 'ION-SELECT' && 'value' in element) {\n            value = value.trim();\n            const optionValue = Array.from(element.querySelectorAll('ion-select-option')).find(option => option.innerHTML.trim() === value);\n            if (optionValue) {\n              element.value = optionValue.value;\n            }\n          } else if ('value' in element) {\n            element.value = text;\n          } else {\n            element.innerHTML = text;\n          }\n        };\n        const getValue = () => {\n          if ('value' in element) {\n            return element.value;\n          } else {\n            return element.innerHTML;\n          }\n        };\n        // Pretend we have cut and pasted the new text.\n        let event;\n        if (getValue() !== '') {\n          event = new InputEvent('input', {\n            bubbles: true,\n            view: window,\n            cancelable: true,\n            inputType: 'deleteByCut'\n          });\n          yield CoreUtils.nextTick();\n          setValue('');\n          element.dispatchEvent(event);\n        }\n        if (value !== '') {\n          event = new InputEvent('input', {\n            bubbles: true,\n            view: window,\n            cancelable: true,\n            inputType: 'insertFromPaste',\n            data: value\n          });\n          yield CoreUtils.nextTick();\n          setValue(value);\n          element.dispatchEvent(event);\n        }\n        promise.resolve();\n        return promise;\n      }));\n    })();\n  }\n}\n_class = TestingBehatDomUtilsService;\n_class.MULTI_ELEM_ALLOWED = ['P', 'SPAN', 'ION-LABEL'];\n_class.ɵfac = function TestingBehatDomUtilsService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const TestingBehatDomUtils = makeSingleton(TestingBehatDomUtilsService);","map":{"version":3,"names":["CorePromisedValue","CoreUtils","makeSingleton","NgZone","TestingBehatDomUtilsService","isElementClickable","element","getAttribute","hasAttribute","isElementVisible","container","getComputedStyle","display","tagName","bounding","getBoundingClientRect","right","left","window","innerWidth","parentElement","getParentElement","isElementSelected","ariaCurrent","findElementsBasedOnTextWithinWithExact","text","options","escapedText","replace","attributesSelector","elements","Array","from","querySelectorAll","filter","onlyClickable","map","exact","checkElementLabel","treeWalker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_DOCUMENT_FRAGMENT","SHOW_TEXT","acceptNode","node","HTMLStyleElement","HTMLLinkElement","HTMLScriptElement","FILTER_REJECT","HTMLElement","FILTER_ACCEPT","fallbackCandidates","currentNode","nextNode","Text","_currentNode$textCont","textContent","includes","push","trim","labelledBy","labelElement","querySelector","innerText","Element","shadowRoot","childNode","childNodes","matches","length","MULTI_ELEM_ALLOWED","entry","contains","title","findElementsBasedOnTextWithin","sort","a","b","Number","getTopAncestors","uniqueElements","Set","otherElement","delete","getRootNode","host","getClosestMatching","selector","getCurrentTopContainerElements","containerName","topContainers","containers","join","style","pointerEvents","closest","zIndex","some","_pageContainers$find","classList","pageContainers","topContainer","find","page","_container$shadowRoot","findField","field","input","findElementBasedOnText","label","inputId","getElementById","undefined","locator","findElementsBasedOnText","_options$containerNam","i","concat","findElementsBasedOnTextInContainer","within","withinElements","withinElementsAncestors","near","nearElements","_objectSpread","nearElementsAncestors","filteredElements","forEach","ensureElementVisible","_asyncToGenerator","initialRect","scrollIntoView","promise","requestAnimationFrame","rect","y","setTimeout","resolve","pressElement","_this","run","eventOptions","clientX","width","clientY","top","height","bubbles","view","cancelable","dispatchEvent","MouseEvent","click","setElementValue","value","setValue","optionValue","option","innerHTML","getValue","event","InputEvent","inputType","nextTick","data","_class","factory","ɵfac","providedIn","TestingBehatDomUtils"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/testing/services/behat-dom.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, NgZone } from '@singletons';\nimport { TestingBehatElementLocator, TestingBehatFindOptions } from './behat-runtime';\n\n/**\n * Behat Dom Utils helper functions.\n */\n@Injectable({ providedIn: 'root' })\nexport class TestingBehatDomUtilsService {\n\n    protected static readonly MULTI_ELEM_ALLOWED = ['P', 'SPAN', 'ION-LABEL'];\n\n    /**\n     * Check if an element is clickable.\n     *\n     * @param element Element.\n     * @returns Whether the element is clickable or not.\n     */\n    isElementClickable(element: HTMLElement): boolean {\n        return element.getAttribute('aria-disabled') !== 'true' && !element.hasAttribute('disabled');\n    }\n\n    /**\n     * Check if an element is visible.\n     *\n     * @param element Element.\n     * @param container Container. If set, the function will also check parent elements visibility.\n     * @returns Whether the element is visible or not.\n     */\n    isElementVisible(element: HTMLElement, container?: HTMLElement): boolean {\n        if (element.getAttribute('aria-hidden') === 'true' || getComputedStyle(element).display === 'none') {\n            return false;\n        }\n\n        if (element.tagName === 'SWIPER-SLIDE') {\n            // Check if the slide is visible (in the viewport).\n            const bounding = element.getBoundingClientRect();\n            if (bounding.right <= 0 || bounding.left >= window.innerWidth) {\n                return false;\n            }\n        }\n\n        if (!container) {\n            return true;\n        }\n\n        const parentElement = this.getParentElement(element);\n        if (parentElement === container) {\n            return true;\n        }\n\n        if (!parentElement) {\n            return false;\n        }\n\n        return this.isElementVisible(parentElement, container);\n    }\n\n    /**\n     * Check if an element is selected.\n     *\n     * @param element Element.\n     * @param container Container.\n     * @returns Whether the element is selected or not.\n     */\n    isElementSelected(element: HTMLElement, container: HTMLElement): boolean {\n        const ariaCurrent = element.getAttribute('aria-current');\n        if (\n            (ariaCurrent && ariaCurrent !== 'false') ||\n            (element.getAttribute('aria-selected') === 'true') ||\n            (element.getAttribute('aria-checked') === 'true')\n        ) {\n            return true;\n        }\n\n        const parentElement = this.getParentElement(element);\n        if (!parentElement || parentElement === container) {\n            return false;\n        }\n\n        return this.isElementSelected(parentElement, container);\n    }\n\n    /**\n     * Finds elements within a given container with exact info.\n     *\n     * @param container Parent element to search the element within\n     * @param text Text to look for\n     * @param options Search options.\n     * @returns Elements containing the given text with exact boolean.\n     */\n    protected findElementsBasedOnTextWithinWithExact(\n        container: HTMLElement,\n        text: string,\n        options: TestingBehatFindOptions,\n    ): ElementsWithExact[] {\n        // Escape double quotes to prevent breaking the query selector.\n        const escapedText = text.replace(/\"/g, '\\\\\"');\n        const attributesSelector = `[aria-label*=\"${escapedText}\"], a[title*=\"${escapedText}\"], ` +\n            `img[alt*=\"${escapedText}\"], [placeholder*=\"${escapedText}\"]`;\n\n        const elements = Array.from(container.querySelectorAll<HTMLElement>(attributesSelector))\n            .filter(\n                element => this.isElementVisible(element, container) &&\n                    (!options.onlyClickable || this.isElementClickable(element)),\n            )\n            .map((element) => {\n                const exact = this.checkElementLabel(element, text);\n\n                return { element, exact };\n            });\n\n        const treeWalker = document.createTreeWalker(\n            container,\n            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_DOCUMENT_FRAGMENT | NodeFilter.SHOW_TEXT,  // eslint-disable-line no-bitwise\n            {\n                acceptNode: node => {\n                    if (\n                        node instanceof HTMLStyleElement ||\n                        node instanceof HTMLLinkElement ||\n                        node instanceof HTMLScriptElement\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    if (!(node instanceof HTMLElement)) {\n                        return NodeFilter.FILTER_ACCEPT;\n                    }\n\n                    if (options.onlyClickable && !this.isElementClickable(node)) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    if (!this.isElementVisible(node)) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    return NodeFilter.FILTER_ACCEPT;\n                },\n            },\n        );\n\n        let fallbackCandidates: ElementsWithExact[] = [];\n        let currentNode: Node | null = null;\n        // eslint-disable-next-line no-cond-assign\n        while (currentNode = treeWalker.nextNode()) {\n            if (currentNode instanceof Text) {\n                if (currentNode.textContent?.includes(text) && currentNode.parentElement) {\n                    elements.push({\n                        element: currentNode.parentElement,\n                        exact: currentNode.textContent.trim() === text,\n                    });\n                }\n\n                continue;\n            }\n\n            if (currentNode instanceof HTMLElement) {\n                const labelledBy = currentNode.getAttribute('aria-labelledby');\n                const labelElement = labelledBy && container.querySelector<HTMLElement>(`#${labelledBy}`);\n                if (labelElement && labelElement.innerText && labelElement.innerText.includes(text)) {\n                    elements.push({\n                        element: currentNode,\n                        exact: labelElement.innerText.trim() == text,\n                    });\n\n                    continue;\n                }\n            }\n\n            if (currentNode instanceof Element && currentNode.shadowRoot) {\n                for (const childNode of Array.from(currentNode.shadowRoot.childNodes)) {\n                    if (!(childNode instanceof HTMLElement) || (\n                        childNode instanceof HTMLStyleElement ||\n                        childNode instanceof HTMLLinkElement ||\n                        childNode instanceof HTMLScriptElement)) {\n                        continue;\n                    }\n\n                    if (childNode.matches(attributesSelector)) {\n                        elements.push({\n                            element: childNode,\n                            exact: this.checkElementLabel(childNode, text),\n                        });\n\n                        continue;\n                    }\n\n                    elements.push(...this.findElementsBasedOnTextWithinWithExact(childNode, text, options));\n                }\n            }\n\n            // Allow searching text split into different elements in some cases.\n            if (\n                elements.length === 0 &&\n                currentNode instanceof HTMLElement &&\n                TestingBehatDomUtilsService.MULTI_ELEM_ALLOWED.includes(currentNode.tagName) &&\n                currentNode.innerText.includes(text)\n            ) {\n                // Only keep the child elements in the candidates list.\n                fallbackCandidates = fallbackCandidates.filter(entry => !entry.element.contains(currentNode));\n                fallbackCandidates.push({\n                    element: currentNode,\n                    exact: currentNode.innerText.trim() == text,\n                });\n            }\n        }\n\n        return elements.length > 0 ? elements : fallbackCandidates;\n    }\n\n    /**\n     * Checks an element has exactly the same label (title, alt or aria-label).\n     *\n     * @param element Element to check.\n     * @param text Text to check.\n     * @returns If text matches any of the label attributes.\n     */\n    protected checkElementLabel(element: HTMLElement, text: string): boolean {\n        return element.title === text ||\n            element.getAttribute('alt') === text ||\n            element.getAttribute('aria-label') === text ||\n            element.getAttribute('placeholder') === text;\n    }\n\n    /**\n     * Finds elements within a given container.\n     *\n     * @param container Parent element to search the element within.\n     * @param text Text to look for.\n     * @param options Search options.\n     * @returns Elements containing the given text.\n     */\n    protected findElementsBasedOnTextWithin(\n        container: HTMLElement,\n        text: string,\n        options: TestingBehatFindOptions,\n    ): HTMLElement[] {\n        const elements = this.findElementsBasedOnTextWithinWithExact(container, text, options);\n\n        // Give more relevance to exact matches.\n        elements.sort((a, b) => Number(b.exact) - Number(a.exact));\n\n        return elements.map(element => element.element);\n    }\n\n    /**\n     * Given a list of elements, get the top ancestors among all of them.\n     *\n     * This will remote duplicates and drop any elements nested within each other.\n     *\n     * @param elements Elements list.\n     * @returns Top ancestors.\n     */\n    protected getTopAncestors(elements: HTMLElement[]): HTMLElement[] {\n        const uniqueElements = new Set(elements);\n\n        for (const element of uniqueElements) {\n            for (const otherElement of uniqueElements) {\n                if (otherElement === element) {\n                    continue;\n                }\n\n                if (element.contains(otherElement)) {\n                    uniqueElements.delete(otherElement);\n                }\n            }\n        }\n\n        return Array.from(uniqueElements);\n    }\n\n    /**\n     * Get parent element, including Shadow DOM parents.\n     *\n     * @param element Element.\n     * @returns Parent element.\n     */\n    protected getParentElement(element: HTMLElement): HTMLElement | null {\n        return element.parentElement ||\n            (element.getRootNode() && (element.getRootNode() as ShadowRoot).host as HTMLElement) ||\n            null;\n    }\n\n    /**\n     * Get closest element matching a selector, without traversing up a given container.\n     *\n     * @param element Element.\n     * @param selector Selector.\n     * @param container Topmost container to search within.\n     * @returns Closest matching element.\n     */\n    protected getClosestMatching(element: HTMLElement, selector: string, container: HTMLElement | null): HTMLElement | null {\n        if (element.matches(selector)) {\n            return element;\n        }\n\n        if (element === container || !element.parentElement) {\n            return null;\n        }\n\n        return this.getClosestMatching(element.parentElement, selector, container);\n    }\n\n    /**\n     * Function to find top container elements.\n     *\n     * @param containerName Whether to search inside the a container name.\n     * @returns Found top container elements.\n     */\n    protected getCurrentTopContainerElements(containerName: string): HTMLElement[] {\n        const topContainers: HTMLElement[] = [];\n        let containers = Array.from(document.querySelectorAll<HTMLElement>([\n            'ion-alert.hydrated',\n            'ion-popover.hydrated',\n            'ion-action-sheet.hydrated',\n            'ion-modal.hydrated',\n            'core-user-tours-user-tour.is-active',\n            'ion-toast.hydrated',\n            'page-core-mainmenu',\n            'ion-app',\n        ].join(', ')));\n\n        containers = containers\n            .filter(container => {\n                if (container.tagName === 'ION-ALERT') {\n                    // For some reason, in Behat sometimes alerts aren't removed from DOM, the close animation doesn't finish.\n                    // Filter alerts with pointer-events none since that style is set before the close animation starts.\n                    return container.style.pointerEvents !== 'none';\n                }\n\n                // Ignore pages that are inside other visible pages.\n                return container.tagName !== 'ION-PAGE' || !container.closest('.ion-page.ion-page-hidden');\n            })\n            // Sort them by z-index.\n            .sort((a, b) =>  Number(getComputedStyle(b).zIndex) - Number(getComputedStyle(a).zIndex));\n\n        if (containerName === 'split-view content') {\n            // Find non hidden pages inside the containers.\n            containers.some(container => {\n                if (!container.classList.contains('ion-page')) {\n                    return false;\n                }\n\n                const pageContainers = Array.from(container.querySelectorAll<HTMLElement>('.ion-page:not(.ion-page-hidden)'));\n                let topContainer = pageContainers.find((page) => !page.closest('.ion-page.ion-page-hidden')) ?? null;\n\n                topContainer = (topContainer || container).querySelector<HTMLElement>('core-split-view ion-router-outlet');\n                topContainer && topContainers.push(topContainer);\n\n                return !!topContainer;\n            });\n\n            return topContainers;\n        }\n\n        // Get containers until one blocks other views.\n        containers.some(container => {\n            if (container.tagName === 'ION-TOAST') {\n                container = container.shadowRoot?.querySelector('.toast-container') || container;\n            }\n            topContainers.push(container);\n\n            // If container has backdrop it blocks the rest of the UI.\n            return container.querySelector(':scope > ion-backdrop') || container.classList.contains('backdrop');\n        });\n\n        return topContainers;\n    }\n\n    /**\n     * Find a field.\n     *\n     * @param field Field name.\n     * @returns Field element.\n     */\n    findField(field: string): HTMLElement | HTMLInputElement | undefined {\n        const input = this.findElementBasedOnText(\n            { text: field, selector: 'input, textarea, [contenteditable=\"true\"], ion-select, ion-datetime' },\n            { onlyClickable: false, containerName: '' },\n        );\n\n        if (input) {\n            return input;\n        }\n\n        const label = this.findElementBasedOnText(\n            { text: field, selector: 'label' },\n            { onlyClickable: false, containerName: '' },\n        );\n\n        if (label) {\n            const inputId = label.getAttribute('for');\n\n            return (inputId && document.getElementById(inputId)) || undefined;\n        }\n    }\n\n    /**\n     * Function to find element based on their text or Aria label.\n     *\n     * @param locator Element locator.\n     * @param options Search options.\n     * @returns First found element.\n     */\n    findElementBasedOnText(\n        locator: TestingBehatElementLocator,\n        options: TestingBehatFindOptions = {},\n    ): HTMLElement | undefined {\n        return this.findElementsBasedOnText(locator, options)[0];\n    }\n\n    /**\n     * Function to find elements based on their text or Aria label.\n     *\n     * @param locator Element locator.\n     * @param options Search options.\n     * @returns Found elements\n     */\n    protected findElementsBasedOnText(\n        locator: TestingBehatElementLocator,\n        options: TestingBehatFindOptions,\n    ): HTMLElement[] {\n        const topContainers = this.getCurrentTopContainerElements(options.containerName ?? '');\n        let elements: HTMLElement[] = [];\n\n        for (let i = 0; i < topContainers.length; i++) {\n            elements = elements.concat(this.findElementsBasedOnTextInContainer(locator, topContainers[i], options));\n            if (elements.length) {\n                break;\n            }\n        }\n\n        return elements;\n    }\n\n    /**\n     * Function to find elements based on their text or Aria label.\n     *\n     * @param locator Element locator.\n     * @param topContainer Container to search in.\n     * @param options Search options.\n     * @returns Found elements\n     */\n    protected findElementsBasedOnTextInContainer(\n        locator: TestingBehatElementLocator,\n        topContainer: HTMLElement,\n        options: TestingBehatFindOptions,\n    ): HTMLElement[] {\n        let container: HTMLElement | null = topContainer;\n\n        if (locator.within) {\n            const withinElements = this.findElementsBasedOnTextInContainer(locator.within, topContainer, options);\n\n            if (withinElements.length === 0) {\n                return [];\n            } else if (withinElements.length > 1) {\n                const withinElementsAncestors = this.getTopAncestors(withinElements);\n\n                if (withinElementsAncestors.length > 1) {\n                    // Too many matches for within text.\n                    return [];\n                }\n\n                topContainer = container = withinElementsAncestors[0];\n            } else {\n                topContainer = container = withinElements[0];\n            }\n        }\n\n        if (topContainer && locator.near) {\n            const nearElements = this.findElementsBasedOnTextInContainer(locator.near, topContainer, {\n                ...options,\n                onlyClickable: false,\n            });\n\n            if (nearElements.length === 0) {\n                return [];\n            } else if (nearElements.length > 1) {\n                const nearElementsAncestors = this.getTopAncestors(nearElements);\n\n                if (nearElementsAncestors.length > 1) {\n                    // Too many matches for near text.\n                    return [];\n                }\n\n                container = this.getParentElement(nearElementsAncestors[0]);\n            } else {\n                container = this.getParentElement(nearElements[0]);\n            }\n        }\n\n        do {\n            if (!container) {\n                break;\n            }\n\n            const elements = this.findElementsBasedOnTextWithin(container, locator.text, options);\n\n            let filteredElements: HTMLElement[] = elements;\n\n            if (locator.selector) {\n                filteredElements = [];\n                const selector = locator.selector;\n\n                elements.forEach((element) => {\n                    const closest = this.getClosestMatching(element, selector, container);\n                    if (closest) {\n                        filteredElements.push(closest);\n                    }\n                });\n            }\n\n            if (filteredElements.length > 0) {\n                return filteredElements;\n            }\n\n        } while (container !== topContainer && (container = this.getParentElement(container)) && container !== topContainer);\n\n        return [];\n    }\n\n    /**\n     * Make sure that an element is visible and wait to trigger the callback.\n     *\n     * @param element Element.\n     * @returns Promise resolved with the DOM rectangle.\n     */\n    protected async ensureElementVisible(element: HTMLElement): Promise<DOMRect> {\n        const initialRect = element.getBoundingClientRect();\n\n        element.scrollIntoView(false);\n\n        const promise = new CorePromisedValue<DOMRect>();\n\n        requestAnimationFrame(() => {\n            const rect = element.getBoundingClientRect();\n\n            if (initialRect.y !== rect.y) {\n                setTimeout(() => {\n                    promise.resolve(rect);\n                }, 300);\n\n                return;\n            }\n\n            promise.resolve(rect);\n        });\n\n        return promise;\n    }\n\n    /**\n     * Press an element.\n     *\n     * @param element Element to press.\n     */\n    async pressElement(element: HTMLElement): Promise<void> {\n        await NgZone.run(async () => {\n            const promise = new CorePromisedValue<void>();\n\n            // Events don't bubble up across Shadow DOM boundaries, and some buttons\n            // may not work without doing this.\n            const parentElement = this.getParentElement(element);\n\n            if (parentElement && parentElement.matches('ion-button, ion-back-button')) {\n                element = parentElement;\n            }\n\n            const rect = await this.ensureElementVisible(element);\n\n            // Simulate a mouse click on the button.\n            const eventOptions: MouseEventInit = {\n                clientX: rect.left + rect.width / 2,\n                clientY: rect.top + rect.height / 2,\n                bubbles: true,\n                view: window,\n                cancelable: true,\n            };\n\n            // There are some buttons in the app that don't respond to click events, for example\n            // buttons using the core-supress-events directive. That's why we need to send both\n            // click and mouse events.\n            element.dispatchEvent(new MouseEvent('mousedown', eventOptions));\n\n            setTimeout(() => {\n                element.dispatchEvent(new MouseEvent('mouseup', eventOptions));\n                element.click();\n\n                promise.resolve();\n            }, 300);\n\n            return promise;\n        });\n    }\n\n    /**\n     * Set an element value.\n     *\n     * @param element HTML to set.\n     * @param value Value to be set.\n     */\n    async setElementValue(element: HTMLInputElement | HTMLElement, value: string): Promise<void> {\n        await NgZone.run(async () => {\n            const promise = new CorePromisedValue<void>();\n\n            // Functions to get/set value depending on field type.\n            const setValue = (text: string) => {\n                if (element.tagName === 'ION-SELECT' && 'value' in element) {\n                    value = value.trim();\n                    const optionValue = Array.from(element.querySelectorAll('ion-select-option'))\n                        .find((option) => option.innerHTML.trim() === value);\n\n                    if (optionValue) {\n                        element.value = optionValue.value;\n                    }\n                } else if ('value' in element) {\n                    element.value = text;\n                } else {\n                    element.innerHTML = text;\n                }\n            };\n            const getValue = () => {\n                if ('value' in element) {\n                    return element.value;\n                } else {\n                    return element.innerHTML;\n                }\n            };\n\n            // Pretend we have cut and pasted the new text.\n            let event: InputEvent;\n            if (getValue() !== '') {\n                event = new InputEvent('input', {\n                    bubbles: true,\n                    view: window,\n                    cancelable: true,\n                    inputType: 'deleteByCut',\n                });\n\n                await CoreUtils.nextTick();\n                setValue('');\n                element.dispatchEvent(event);\n            }\n\n            if (value !== '') {\n                event = new InputEvent('input', {\n                    bubbles: true,\n                    view: window,\n                    cancelable: true,\n                    inputType: 'insertFromPaste',\n                    data: value,\n                });\n\n                await CoreUtils.nextTick();\n                setValue(value);\n                element.dispatchEvent(event);\n            }\n\n            promise.resolve();\n\n            return promise;\n        });\n    }\n\n}\n\nexport const TestingBehatDomUtils = makeSingleton(TestingBehatDomUtilsService);\n\ntype ElementsWithExact = {\n    element: HTMLElement;\n    exact: boolean;\n};\n"],"mappings":";;;AAeA,SAASA,iBAAiB,QAAQ,yBAAyB;AAC3D,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,aAAa,EAAEC,MAAM,QAAQ,aAAa;;AAGnD;;;AAIA,OAAM,MAAOC,2BAA2B;EAIpC;;;;;;EAMAC,kBAAkBA,CAACC,OAAoB;IACnC,OAAOA,OAAO,CAACC,YAAY,CAAC,eAAe,CAAC,KAAK,MAAM,IAAI,CAACD,OAAO,CAACE,YAAY,CAAC,UAAU,CAAC;EAChG;EAEA;;;;;;;EAOAC,gBAAgBA,CAACH,OAAoB,EAAEI,SAAuB;IAC1D,IAAIJ,OAAO,CAACC,YAAY,CAAC,aAAa,CAAC,KAAK,MAAM,IAAII,gBAAgB,CAACL,OAAO,CAAC,CAACM,OAAO,KAAK,MAAM,EAAE;MAChG,OAAO,KAAK;;IAGhB,IAAIN,OAAO,CAACO,OAAO,KAAK,cAAc,EAAE;MACpC;MACA,MAAMC,QAAQ,GAAGR,OAAO,CAACS,qBAAqB,EAAE;MAChD,IAAID,QAAQ,CAACE,KAAK,IAAI,CAAC,IAAIF,QAAQ,CAACG,IAAI,IAAIC,MAAM,CAACC,UAAU,EAAE;QAC3D,OAAO,KAAK;;;IAIpB,IAAI,CAACT,SAAS,EAAE;MACZ,OAAO,IAAI;;IAGf,MAAMU,aAAa,GAAG,IAAI,CAACC,gBAAgB,CAACf,OAAO,CAAC;IACpD,IAAIc,aAAa,KAAKV,SAAS,EAAE;MAC7B,OAAO,IAAI;;IAGf,IAAI,CAACU,aAAa,EAAE;MAChB,OAAO,KAAK;;IAGhB,OAAO,IAAI,CAACX,gBAAgB,CAACW,aAAa,EAAEV,SAAS,CAAC;EAC1D;EAEA;;;;;;;EAOAY,iBAAiBA,CAAChB,OAAoB,EAAEI,SAAsB;IAC1D,MAAMa,WAAW,GAAGjB,OAAO,CAACC,YAAY,CAAC,cAAc,CAAC;IACxD,IACKgB,WAAW,IAAIA,WAAW,KAAK,OAAO,IACtCjB,OAAO,CAACC,YAAY,CAAC,eAAe,CAAC,KAAK,MAAO,IACjDD,OAAO,CAACC,YAAY,CAAC,cAAc,CAAC,KAAK,MAAO,EACnD;MACE,OAAO,IAAI;;IAGf,MAAMa,aAAa,GAAG,IAAI,CAACC,gBAAgB,CAACf,OAAO,CAAC;IACpD,IAAI,CAACc,aAAa,IAAIA,aAAa,KAAKV,SAAS,EAAE;MAC/C,OAAO,KAAK;;IAGhB,OAAO,IAAI,CAACY,iBAAiB,CAACF,aAAa,EAAEV,SAAS,CAAC;EAC3D;EAEA;;;;;;;;EAQUc,sCAAsCA,CAC5Cd,SAAsB,EACtBe,IAAY,EACZC,OAAgC;IAEhC;IACA,MAAMC,WAAW,GAAGF,IAAI,CAACG,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC;IAC7C,MAAMC,kBAAkB,GAAG,iBAAiBF,WAAW,iBAAiBA,WAAW,MAAM,GACrF,aAAaA,WAAW,sBAAsBA,WAAW,IAAI;IAEjE,MAAMG,QAAQ,GAAGC,KAAK,CAACC,IAAI,CAACtB,SAAS,CAACuB,gBAAgB,CAAcJ,kBAAkB,CAAC,CAAC,CACnFK,MAAM,CACH5B,OAAO,IAAI,IAAI,CAACG,gBAAgB,CAACH,OAAO,EAAEI,SAAS,CAAC,KAC/C,CAACgB,OAAO,CAACS,aAAa,IAAI,IAAI,CAAC9B,kBAAkB,CAACC,OAAO,CAAC,CAAC,CACnE,CACA8B,GAAG,CAAE9B,OAAO,IAAI;MACb,MAAM+B,KAAK,GAAG,IAAI,CAACC,iBAAiB,CAAChC,OAAO,EAAEmB,IAAI,CAAC;MAEnD,OAAO;QAAEnB,OAAO;QAAE+B;MAAK,CAAE;IAC7B,CAAC,CAAC;IAEN,MAAME,UAAU,GAAGC,QAAQ,CAACC,gBAAgB,CACxC/B,SAAS,EACTgC,UAAU,CAACC,YAAY,GAAGD,UAAU,CAACE,sBAAsB,GAAGF,UAAU,CAACG,SAAS;IAAG;IACrF;MACIC,UAAU,EAAEC,IAAI,IAAG;QACf,IACIA,IAAI,YAAYC,gBAAgB,IAChCD,IAAI,YAAYE,eAAe,IAC/BF,IAAI,YAAYG,iBAAiB,EACnC;UACE,OAAOR,UAAU,CAACS,aAAa;;QAGnC,IAAI,EAAEJ,IAAI,YAAYK,WAAW,CAAC,EAAE;UAChC,OAAOV,UAAU,CAACW,aAAa;;QAGnC,IAAI3B,OAAO,CAACS,aAAa,IAAI,CAAC,IAAI,CAAC9B,kBAAkB,CAAC0C,IAAI,CAAC,EAAE;UACzD,OAAOL,UAAU,CAACS,aAAa;;QAGnC,IAAI,CAAC,IAAI,CAAC1C,gBAAgB,CAACsC,IAAI,CAAC,EAAE;UAC9B,OAAOL,UAAU,CAACS,aAAa;;QAGnC,OAAOT,UAAU,CAACW,aAAa;MACnC;KACH,CACJ;IAED,IAAIC,kBAAkB,GAAwB,EAAE;IAChD,IAAIC,WAAW,GAAgB,IAAI;IACnC;IACA,OAAOA,WAAW,GAAGhB,UAAU,CAACiB,QAAQ,EAAE,EAAE;MACxC,IAAID,WAAW,YAAYE,IAAI,EAAE;QAAA,IAAAC,qBAAA;QAC7B,IAAI,CAAAA,qBAAA,GAAAH,WAAW,CAACI,WAAW,cAAAD,qBAAA,eAAvBA,qBAAA,CAAyBE,QAAQ,CAACnC,IAAI,CAAC,IAAI8B,WAAW,CAACnC,aAAa,EAAE;UACtEU,QAAQ,CAAC+B,IAAI,CAAC;YACVvD,OAAO,EAAEiD,WAAW,CAACnC,aAAa;YAClCiB,KAAK,EAAEkB,WAAW,CAACI,WAAW,CAACG,IAAI,EAAE,KAAKrC;WAC7C,CAAC;;QAGN;;MAGJ,IAAI8B,WAAW,YAAYH,WAAW,EAAE;QACpC,MAAMW,UAAU,GAAGR,WAAW,CAAChD,YAAY,CAAC,iBAAiB,CAAC;QAC9D,MAAMyD,YAAY,GAAGD,UAAU,IAAIrD,SAAS,CAACuD,aAAa,CAAc,IAAIF,UAAU,EAAE,CAAC;QACzF,IAAIC,YAAY,IAAIA,YAAY,CAACE,SAAS,IAAIF,YAAY,CAACE,SAAS,CAACN,QAAQ,CAACnC,IAAI,CAAC,EAAE;UACjFK,QAAQ,CAAC+B,IAAI,CAAC;YACVvD,OAAO,EAAEiD,WAAW;YACpBlB,KAAK,EAAE2B,YAAY,CAACE,SAAS,CAACJ,IAAI,EAAE,IAAIrC;WAC3C,CAAC;UAEF;;;MAIR,IAAI8B,WAAW,YAAYY,OAAO,IAAIZ,WAAW,CAACa,UAAU,EAAE;QAC1D,KAAK,MAAMC,SAAS,IAAItC,KAAK,CAACC,IAAI,CAACuB,WAAW,CAACa,UAAU,CAACE,UAAU,CAAC,EAAE;UACnE,IAAI,EAAED,SAAS,YAAYjB,WAAW,CAAC,IACnCiB,SAAS,YAAYrB,gBAAgB,IACrCqB,SAAS,YAAYpB,eAAe,IACpCoB,SAAS,YAAYnB,iBAAkB,EAAE;YACzC;;UAGJ,IAAImB,SAAS,CAACE,OAAO,CAAC1C,kBAAkB,CAAC,EAAE;YACvCC,QAAQ,CAAC+B,IAAI,CAAC;cACVvD,OAAO,EAAE+D,SAAS;cAClBhC,KAAK,EAAE,IAAI,CAACC,iBAAiB,CAAC+B,SAAS,EAAE5C,IAAI;aAChD,CAAC;YAEF;;UAGJK,QAAQ,CAAC+B,IAAI,CAAC,GAAG,IAAI,CAACrC,sCAAsC,CAAC6C,SAAS,EAAE5C,IAAI,EAAEC,OAAO,CAAC,CAAC;;;MAI/F;MACA,IACII,QAAQ,CAAC0C,MAAM,KAAK,CAAC,IACrBjB,WAAW,YAAYH,WAAW,IAClChD,2BAA2B,CAACqE,kBAAkB,CAACb,QAAQ,CAACL,WAAW,CAAC1C,OAAO,CAAC,IAC5E0C,WAAW,CAACW,SAAS,CAACN,QAAQ,CAACnC,IAAI,CAAC,EACtC;QACE;QACA6B,kBAAkB,GAAGA,kBAAkB,CAACpB,MAAM,CAACwC,KAAK,IAAI,CAACA,KAAK,CAACpE,OAAO,CAACqE,QAAQ,CAACpB,WAAW,CAAC,CAAC;QAC7FD,kBAAkB,CAACO,IAAI,CAAC;UACpBvD,OAAO,EAAEiD,WAAW;UACpBlB,KAAK,EAAEkB,WAAW,CAACW,SAAS,CAACJ,IAAI,EAAE,IAAIrC;SAC1C,CAAC;;;IAIV,OAAOK,QAAQ,CAAC0C,MAAM,GAAG,CAAC,GAAG1C,QAAQ,GAAGwB,kBAAkB;EAC9D;EAEA;;;;;;;EAOUhB,iBAAiBA,CAAChC,OAAoB,EAAEmB,IAAY;IAC1D,OAAOnB,OAAO,CAACsE,KAAK,KAAKnD,IAAI,IACzBnB,OAAO,CAACC,YAAY,CAAC,KAAK,CAAC,KAAKkB,IAAI,IACpCnB,OAAO,CAACC,YAAY,CAAC,YAAY,CAAC,KAAKkB,IAAI,IAC3CnB,OAAO,CAACC,YAAY,CAAC,aAAa,CAAC,KAAKkB,IAAI;EACpD;EAEA;;;;;;;;EAQUoD,6BAA6BA,CACnCnE,SAAsB,EACtBe,IAAY,EACZC,OAAgC;IAEhC,MAAMI,QAAQ,GAAG,IAAI,CAACN,sCAAsC,CAACd,SAAS,EAAEe,IAAI,EAAEC,OAAO,CAAC;IAEtF;IACAI,QAAQ,CAACgD,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKC,MAAM,CAACD,CAAC,CAAC3C,KAAK,CAAC,GAAG4C,MAAM,CAACF,CAAC,CAAC1C,KAAK,CAAC,CAAC;IAE1D,OAAOP,QAAQ,CAACM,GAAG,CAAC9B,OAAO,IAAIA,OAAO,CAACA,OAAO,CAAC;EACnD;EAEA;;;;;;;;EAQU4E,eAAeA,CAACpD,QAAuB;IAC7C,MAAMqD,cAAc,GAAG,IAAIC,GAAG,CAACtD,QAAQ,CAAC;IAExC,KAAK,MAAMxB,OAAO,IAAI6E,cAAc,EAAE;MAClC,KAAK,MAAME,YAAY,IAAIF,cAAc,EAAE;QACvC,IAAIE,YAAY,KAAK/E,OAAO,EAAE;UAC1B;;QAGJ,IAAIA,OAAO,CAACqE,QAAQ,CAACU,YAAY,CAAC,EAAE;UAChCF,cAAc,CAACG,MAAM,CAACD,YAAY,CAAC;;;;IAK/C,OAAOtD,KAAK,CAACC,IAAI,CAACmD,cAAc,CAAC;EACrC;EAEA;;;;;;EAMU9D,gBAAgBA,CAACf,OAAoB;IAC3C,OAAOA,OAAO,CAACc,aAAa,IACvBd,OAAO,CAACiF,WAAW,EAAE,IAAKjF,OAAO,CAACiF,WAAW,EAAiB,CAACC,IAAoB,IACpF,IAAI;EACZ;EAEA;;;;;;;;EAQUC,kBAAkBA,CAACnF,OAAoB,EAAEoF,QAAgB,EAAEhF,SAA6B;IAC9F,IAAIJ,OAAO,CAACiE,OAAO,CAACmB,QAAQ,CAAC,EAAE;MAC3B,OAAOpF,OAAO;;IAGlB,IAAIA,OAAO,KAAKI,SAAS,IAAI,CAACJ,OAAO,CAACc,aAAa,EAAE;MACjD,OAAO,IAAI;;IAGf,OAAO,IAAI,CAACqE,kBAAkB,CAACnF,OAAO,CAACc,aAAa,EAAEsE,QAAQ,EAAEhF,SAAS,CAAC;EAC9E;EAEA;;;;;;EAMUiF,8BAA8BA,CAACC,aAAqB;IAC1D,MAAMC,aAAa,GAAkB,EAAE;IACvC,IAAIC,UAAU,GAAG/D,KAAK,CAACC,IAAI,CAACQ,QAAQ,CAACP,gBAAgB,CAAc,CAC/D,oBAAoB,EACpB,sBAAsB,EACtB,2BAA2B,EAC3B,oBAAoB,EACpB,qCAAqC,EACrC,oBAAoB,EACpB,oBAAoB,EACpB,SAAS,CACZ,CAAC8D,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAEdD,UAAU,GAAGA,UAAU,CAClB5D,MAAM,CAACxB,SAAS,IAAG;MAChB,IAAIA,SAAS,CAACG,OAAO,KAAK,WAAW,EAAE;QACnC;QACA;QACA,OAAOH,SAAS,CAACsF,KAAK,CAACC,aAAa,KAAK,MAAM;;MAGnD;MACA,OAAOvF,SAAS,CAACG,OAAO,KAAK,UAAU,IAAI,CAACH,SAAS,CAACwF,OAAO,CAAC,2BAA2B,CAAC;IAC9F,CAAC;IACD;IAAA,CACCpB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAMC,MAAM,CAACtE,gBAAgB,CAACqE,CAAC,CAAC,CAACmB,MAAM,CAAC,GAAGlB,MAAM,CAACtE,gBAAgB,CAACoE,CAAC,CAAC,CAACoB,MAAM,CAAC,CAAC;IAE7F,IAAIP,aAAa,KAAK,oBAAoB,EAAE;MACxC;MACAE,UAAU,CAACM,IAAI,CAAC1F,SAAS,IAAG;QAAA,IAAA2F,oBAAA;QACxB,IAAI,CAAC3F,SAAS,CAAC4F,SAAS,CAAC3B,QAAQ,CAAC,UAAU,CAAC,EAAE;UAC3C,OAAO,KAAK;;QAGhB,MAAM4B,cAAc,GAAGxE,KAAK,CAACC,IAAI,CAACtB,SAAS,CAACuB,gBAAgB,CAAc,iCAAiC,CAAC,CAAC;QAC7G,IAAIuE,YAAY,IAAAH,oBAAA,GAAGE,cAAc,CAACE,IAAI,CAAEC,IAAI,IAAK,CAACA,IAAI,CAACR,OAAO,CAAC,2BAA2B,CAAC,CAAC,cAAAG,oBAAA,cAAAA,oBAAA,GAAI,IAAI;QAEpGG,YAAY,GAAG,CAACA,YAAY,IAAI9F,SAAS,EAAEuD,aAAa,CAAc,mCAAmC,CAAC;QAC1GuC,YAAY,IAAIX,aAAa,CAAChC,IAAI,CAAC2C,YAAY,CAAC;QAEhD,OAAO,CAAC,CAACA,YAAY;MACzB,CAAC,CAAC;MAEF,OAAOX,aAAa;;IAGxB;IACAC,UAAU,CAACM,IAAI,CAAC1F,SAAS,IAAG;MACxB,IAAIA,SAAS,CAACG,OAAO,KAAK,WAAW,EAAE;QAAA,IAAA8F,qBAAA;QACnCjG,SAAS,GAAG,EAAAiG,qBAAA,GAAAjG,SAAS,CAAC0D,UAAU,cAAAuC,qBAAA,uBAApBA,qBAAA,CAAsB1C,aAAa,CAAC,kBAAkB,CAAC,KAAIvD,SAAS;;MAEpFmF,aAAa,CAAChC,IAAI,CAACnD,SAAS,CAAC;MAE7B;MACA,OAAOA,SAAS,CAACuD,aAAa,CAAC,uBAAuB,CAAC,IAAIvD,SAAS,CAAC4F,SAAS,CAAC3B,QAAQ,CAAC,UAAU,CAAC;IACvG,CAAC,CAAC;IAEF,OAAOkB,aAAa;EACxB;EAEA;;;;;;EAMAe,SAASA,CAACC,KAAa;IACnB,MAAMC,KAAK,GAAG,IAAI,CAACC,sBAAsB,CACrC;MAAEtF,IAAI,EAAEoF,KAAK;MAAEnB,QAAQ,EAAE;IAAqE,CAAE,EAChG;MAAEvD,aAAa,EAAE,KAAK;MAAEyD,aAAa,EAAE;IAAE,CAAE,CAC9C;IAED,IAAIkB,KAAK,EAAE;MACP,OAAOA,KAAK;;IAGhB,MAAME,KAAK,GAAG,IAAI,CAACD,sBAAsB,CACrC;MAAEtF,IAAI,EAAEoF,KAAK;MAAEnB,QAAQ,EAAE;IAAO,CAAE,EAClC;MAAEvD,aAAa,EAAE,KAAK;MAAEyD,aAAa,EAAE;IAAE,CAAE,CAC9C;IAED,IAAIoB,KAAK,EAAE;MACP,MAAMC,OAAO,GAAGD,KAAK,CAACzG,YAAY,CAAC,KAAK,CAAC;MAEzC,OAAQ0G,OAAO,IAAIzE,QAAQ,CAAC0E,cAAc,CAACD,OAAO,CAAC,IAAKE,SAAS;;EAEzE;EAEA;;;;;;;EAOAJ,sBAAsBA,CAClBK,OAAmC,EACnC1F,OAAA,GAAmC,EAAE;IAErC,OAAO,IAAI,CAAC2F,uBAAuB,CAACD,OAAO,EAAE1F,OAAO,CAAC,CAAC,CAAC,CAAC;EAC5D;EAEA;;;;;;;EAOU2F,uBAAuBA,CAC7BD,OAAmC,EACnC1F,OAAgC;IAAA,IAAA4F,qBAAA;IAEhC,MAAMzB,aAAa,GAAG,IAAI,CAACF,8BAA8B,EAAA2B,qBAAA,GAAC5F,OAAO,CAACkE,aAAa,cAAA0B,qBAAA,cAAAA,qBAAA,GAAI,EAAE,CAAC;IACtF,IAAIxF,QAAQ,GAAkB,EAAE;IAEhC,KAAK,IAAIyF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1B,aAAa,CAACrB,MAAM,EAAE+C,CAAC,EAAE,EAAE;MAC3CzF,QAAQ,GAAGA,QAAQ,CAAC0F,MAAM,CAAC,IAAI,CAACC,kCAAkC,CAACL,OAAO,EAAEvB,aAAa,CAAC0B,CAAC,CAAC,EAAE7F,OAAO,CAAC,CAAC;MACvG,IAAII,QAAQ,CAAC0C,MAAM,EAAE;QACjB;;;IAIR,OAAO1C,QAAQ;EACnB;EAEA;;;;;;;;EAQU2F,kCAAkCA,CACxCL,OAAmC,EACnCZ,YAAyB,EACzB9E,OAAgC;IAEhC,IAAIhB,SAAS,GAAuB8F,YAAY;IAEhD,IAAIY,OAAO,CAACM,MAAM,EAAE;MAChB,MAAMC,cAAc,GAAG,IAAI,CAACF,kCAAkC,CAACL,OAAO,CAACM,MAAM,EAAElB,YAAY,EAAE9E,OAAO,CAAC;MAErG,IAAIiG,cAAc,CAACnD,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,EAAE;OACZ,MAAM,IAAImD,cAAc,CAACnD,MAAM,GAAG,CAAC,EAAE;QAClC,MAAMoD,uBAAuB,GAAG,IAAI,CAAC1C,eAAe,CAACyC,cAAc,CAAC;QAEpE,IAAIC,uBAAuB,CAACpD,MAAM,GAAG,CAAC,EAAE;UACpC;UACA,OAAO,EAAE;;QAGbgC,YAAY,GAAG9F,SAAS,GAAGkH,uBAAuB,CAAC,CAAC,CAAC;OACxD,MAAM;QACHpB,YAAY,GAAG9F,SAAS,GAAGiH,cAAc,CAAC,CAAC,CAAC;;;IAIpD,IAAInB,YAAY,IAAIY,OAAO,CAACS,IAAI,EAAE;MAC9B,MAAMC,YAAY,GAAG,IAAI,CAACL,kCAAkC,CAACL,OAAO,CAACS,IAAI,EAAErB,YAAY,EAAAuB,aAAA,CAAAA,aAAA,KAChFrG,OAAO;QACVS,aAAa,EAAE;MAAK,EACvB,CAAC;MAEF,IAAI2F,YAAY,CAACtD,MAAM,KAAK,CAAC,EAAE;QAC3B,OAAO,EAAE;OACZ,MAAM,IAAIsD,YAAY,CAACtD,MAAM,GAAG,CAAC,EAAE;QAChC,MAAMwD,qBAAqB,GAAG,IAAI,CAAC9C,eAAe,CAAC4C,YAAY,CAAC;QAEhE,IAAIE,qBAAqB,CAACxD,MAAM,GAAG,CAAC,EAAE;UAClC;UACA,OAAO,EAAE;;QAGb9D,SAAS,GAAG,IAAI,CAACW,gBAAgB,CAAC2G,qBAAqB,CAAC,CAAC,CAAC,CAAC;OAC9D,MAAM;QACHtH,SAAS,GAAG,IAAI,CAACW,gBAAgB,CAACyG,YAAY,CAAC,CAAC,CAAC,CAAC;;;IAI1D,GAAG;MACC,IAAI,CAACpH,SAAS,EAAE;QACZ;;MAGJ,MAAMoB,QAAQ,GAAG,IAAI,CAAC+C,6BAA6B,CAACnE,SAAS,EAAE0G,OAAO,CAAC3F,IAAI,EAAEC,OAAO,CAAC;MAErF,IAAIuG,gBAAgB,GAAkBnG,QAAQ;MAE9C,IAAIsF,OAAO,CAAC1B,QAAQ,EAAE;QAClBuC,gBAAgB,GAAG,EAAE;QACrB,MAAMvC,QAAQ,GAAG0B,OAAO,CAAC1B,QAAQ;QAEjC5D,QAAQ,CAACoG,OAAO,CAAE5H,OAAO,IAAI;UACzB,MAAM4F,OAAO,GAAG,IAAI,CAACT,kBAAkB,CAACnF,OAAO,EAAEoF,QAAQ,EAAEhF,SAAS,CAAC;UACrE,IAAIwF,OAAO,EAAE;YACT+B,gBAAgB,CAACpE,IAAI,CAACqC,OAAO,CAAC;;QAEtC,CAAC,CAAC;;MAGN,IAAI+B,gBAAgB,CAACzD,MAAM,GAAG,CAAC,EAAE;QAC7B,OAAOyD,gBAAgB;;KAG9B,QAAQvH,SAAS,KAAK8F,YAAY,KAAK9F,SAAS,GAAG,IAAI,CAACW,gBAAgB,CAACX,SAAS,CAAC,CAAC,IAAIA,SAAS,KAAK8F,YAAY;IAEnH,OAAO,EAAE;EACb;EAEA;;;;;;EAMgB2B,oBAAoBA,CAAC7H,OAAoB;IAAA,OAAA8H,iBAAA;MACrD,MAAMC,WAAW,GAAG/H,OAAO,CAACS,qBAAqB,EAAE;MAEnDT,OAAO,CAACgI,cAAc,CAAC,KAAK,CAAC;MAE7B,MAAMC,OAAO,GAAG,IAAIvI,iBAAiB,EAAW;MAEhDwI,qBAAqB,CAAC,MAAK;QACvB,MAAMC,IAAI,GAAGnI,OAAO,CAACS,qBAAqB,EAAE;QAE5C,IAAIsH,WAAW,CAACK,CAAC,KAAKD,IAAI,CAACC,CAAC,EAAE;UAC1BC,UAAU,CAAC,MAAK;YACZJ,OAAO,CAACK,OAAO,CAACH,IAAI,CAAC;UACzB,CAAC,EAAE,GAAG,CAAC;UAEP;;QAGJF,OAAO,CAACK,OAAO,CAACH,IAAI,CAAC;MACzB,CAAC,CAAC;MAEF,OAAOF,OAAO;IAAC;EACnB;EAEA;;;;;EAKMM,YAAYA,CAACvI,OAAoB;IAAA,IAAAwI,KAAA;IAAA,OAAAV,iBAAA;MACnC,MAAMjI,MAAM,CAAC4I,GAAG,eAAAX,iBAAA,CAAC,aAAW;QACxB,MAAMG,OAAO,GAAG,IAAIvI,iBAAiB,EAAQ;QAE7C;QACA;QACA,MAAMoB,aAAa,GAAG0H,KAAI,CAACzH,gBAAgB,CAACf,OAAO,CAAC;QAEpD,IAAIc,aAAa,IAAIA,aAAa,CAACmD,OAAO,CAAC,6BAA6B,CAAC,EAAE;UACvEjE,OAAO,GAAGc,aAAa;;QAG3B,MAAMqH,IAAI,SAASK,KAAI,CAACX,oBAAoB,CAAC7H,OAAO,CAAC;QAErD;QACA,MAAM0I,YAAY,GAAmB;UACjCC,OAAO,EAAER,IAAI,CAACxH,IAAI,GAAGwH,IAAI,CAACS,KAAK,GAAG,CAAC;UACnCC,OAAO,EAAEV,IAAI,CAACW,GAAG,GAAGX,IAAI,CAACY,MAAM,GAAG,CAAC;UACnCC,OAAO,EAAE,IAAI;UACbC,IAAI,EAAErI,MAAM;UACZsI,UAAU,EAAE;SACf;QAED;QACA;QACA;QACAlJ,OAAO,CAACmJ,aAAa,CAAC,IAAIC,UAAU,CAAC,WAAW,EAAEV,YAAY,CAAC,CAAC;QAEhEL,UAAU,CAAC,MAAK;UACZrI,OAAO,CAACmJ,aAAa,CAAC,IAAIC,UAAU,CAAC,SAAS,EAAEV,YAAY,CAAC,CAAC;UAC9D1I,OAAO,CAACqJ,KAAK,EAAE;UAEfpB,OAAO,CAACK,OAAO,EAAE;QACrB,CAAC,EAAE,GAAG,CAAC;QAEP,OAAOL,OAAO;MAClB,CAAC,EAAC;IAAC;EACP;EAEA;;;;;;EAMMqB,eAAeA,CAACtJ,OAAuC,EAAEuJ,KAAa;IAAA,OAAAzB,iBAAA;MACxE,MAAMjI,MAAM,CAAC4I,GAAG,eAAAX,iBAAA,CAAC,aAAW;QACxB,MAAMG,OAAO,GAAG,IAAIvI,iBAAiB,EAAQ;QAE7C;QACA,MAAM8J,QAAQ,GAAIrI,IAAY,IAAI;UAC9B,IAAInB,OAAO,CAACO,OAAO,KAAK,YAAY,IAAI,OAAO,IAAIP,OAAO,EAAE;YACxDuJ,KAAK,GAAGA,KAAK,CAAC/F,IAAI,EAAE;YACpB,MAAMiG,WAAW,GAAGhI,KAAK,CAACC,IAAI,CAAC1B,OAAO,CAAC2B,gBAAgB,CAAC,mBAAmB,CAAC,CAAC,CACxEwE,IAAI,CAAEuD,MAAM,IAAKA,MAAM,CAACC,SAAS,CAACnG,IAAI,EAAE,KAAK+F,KAAK,CAAC;YAExD,IAAIE,WAAW,EAAE;cACbzJ,OAAO,CAACuJ,KAAK,GAAGE,WAAW,CAACF,KAAK;;WAExC,MAAM,IAAI,OAAO,IAAIvJ,OAAO,EAAE;YAC3BA,OAAO,CAACuJ,KAAK,GAAGpI,IAAI;WACvB,MAAM;YACHnB,OAAO,CAAC2J,SAAS,GAAGxI,IAAI;;QAEhC,CAAC;QACD,MAAMyI,QAAQ,GAAGA,CAAA,KAAK;UAClB,IAAI,OAAO,IAAI5J,OAAO,EAAE;YACpB,OAAOA,OAAO,CAACuJ,KAAK;WACvB,MAAM;YACH,OAAOvJ,OAAO,CAAC2J,SAAS;;QAEhC,CAAC;QAED;QACA,IAAIE,KAAiB;QACrB,IAAID,QAAQ,EAAE,KAAK,EAAE,EAAE;UACnBC,KAAK,GAAG,IAAIC,UAAU,CAAC,OAAO,EAAE;YAC5Bd,OAAO,EAAE,IAAI;YACbC,IAAI,EAAErI,MAAM;YACZsI,UAAU,EAAE,IAAI;YAChBa,SAAS,EAAE;WACd,CAAC;UAEF,MAAMpK,SAAS,CAACqK,QAAQ,EAAE;UAC1BR,QAAQ,CAAC,EAAE,CAAC;UACZxJ,OAAO,CAACmJ,aAAa,CAACU,KAAK,CAAC;;QAGhC,IAAIN,KAAK,KAAK,EAAE,EAAE;UACdM,KAAK,GAAG,IAAIC,UAAU,CAAC,OAAO,EAAE;YAC5Bd,OAAO,EAAE,IAAI;YACbC,IAAI,EAAErI,MAAM;YACZsI,UAAU,EAAE,IAAI;YAChBa,SAAS,EAAE,iBAAiB;YAC5BE,IAAI,EAAEV;WACT,CAAC;UAEF,MAAM5J,SAAS,CAACqK,QAAQ,EAAE;UAC1BR,QAAQ,CAACD,KAAK,CAAC;UACfvJ,OAAO,CAACmJ,aAAa,CAACU,KAAK,CAAC;;QAGhC5B,OAAO,CAACK,OAAO,EAAE;QAEjB,OAAOL,OAAO;MAClB,CAAC,EAAC;IAAC;EACP;;SA/oBSnI,2BAA2B;AAEVoK,MAAA,CAAA/F,kBAAkB,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,WAAW,CAAC;;mBAFhErE,MAA2B;AAAA;;SAA3BA,MAA2B;EAAAqK,OAAA,EAA3BrK,MAA2B,CAAAsK,IAAA;EAAAC,UAAA,EADd;AAAM;AAopBhC,OAAO,MAAMC,oBAAoB,GAAG1K,aAAa,CAACE,2BAA2B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}