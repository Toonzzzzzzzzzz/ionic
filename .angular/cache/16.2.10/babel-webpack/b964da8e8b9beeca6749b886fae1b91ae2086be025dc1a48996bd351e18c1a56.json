{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile } from '@services/file';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, NgZone, Translate, Diagnostic } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreWindow } from '@singletons/window';\nimport { CoreContentLinksHelper } from '@features/contentlinks/services/contentlinks-helper';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport * as i0 from \"@angular/core\";\n/*\n * \"Utils\" service with helper functions for iframes, embed and similar.\n */\nexport class CoreIframeUtilsProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('CoreIframeUtilsProvider');\n  }\n  /**\n   * Check if a frame uses an online URL but the app is offline. If it does, the iframe is hidden and a warning is shown.\n   *\n   * @param element The frame to check (iframe, embed, ...).\n   * @param isSubframe Whether it's a frame inside another frame.\n   * @returns True if frame is online and the app is offline, false otherwise.\n   */\n  checkOnlineFrameInOffline(element, isSubframe) {\n    const src = 'src' in element ? element.src : element.data;\n    if (src && src != 'about:blank' && !CoreUrlUtils.isLocalFileUrl(src) && !CoreNetwork.isOnline()) {\n      if (element.classList.contains('core-iframe-offline-disabled')) {\n        // Iframe already hidden, stop.\n        return true;\n      }\n      // The frame has an online URL but the app is offline. Show a warning, or a link if the URL can be opened in the app.\n      this.addOfflineWarning(element, src, isSubframe);\n      // If the network changes, check it again.\n      const subscription = CoreNetwork.onConnectShouldBeStable().subscribe(() => {\n        // Execute the callback in the Angular zone, so change detection doesn't stop working.\n        NgZone.run(() => {\n          if (!this.checkOnlineFrameInOffline(element, isSubframe)) {\n            // Now the app is online, no need to check connection again.\n            subscription.unsubscribe();\n          }\n        });\n      });\n      return true;\n    } else if (element.classList.contains('core-iframe-offline-disabled') && element.parentElement) {\n      // Reload the frame.\n      if ('src' in element) {\n        // eslint-disable-next-line no-self-assign\n        element.src = element.src;\n      } else {\n        // eslint-disable-next-line no-self-assign\n        element.data = element.data;\n      }\n      // Remove the warning and show the iframe\n      CoreDomUtils.removeElement(element.parentElement, 'div.core-iframe-offline-warning');\n      element.classList.remove('core-iframe-offline-disabled');\n      if (isSubframe) {\n        element.style.display = '';\n      }\n    }\n    return false;\n  }\n  /**\n   * Add an offline warning message.\n   *\n   * @param element The frame to check (iframe, embed, ...).\n   * @param src Frame src.\n   * @param isSubframe Whether it's a frame inside another frame.\n   * @returns Promise resolved when done.\n   */\n  addOfflineWarning(element, src, isSubframe) {\n    return _asyncToGenerator(function* () {\n      var _site$getInfo, _element$parentElemen2;\n      const site = CoreSites.getCurrentSite();\n      const username = site ? (_site$getInfo = site.getInfo()) === null || _site$getInfo === void 0 ? void 0 : _site$getInfo.username : undefined;\n      const div = document.createElement('div');\n      div.classList.add('core-iframe-offline-warning', 'ion-padding', 'ion-text-center');\n      // Add a class to specify that the iframe is hidden.\n      element.classList.add('core-iframe-offline-disabled');\n      if (isSubframe) {\n        // We cannot apply CSS styles in subframes, just hide the iframe.\n        element.style.display = 'none';\n      }\n      const canHandleLink = yield CoreContentLinksHelper.canHandleLink(src, undefined, username);\n      if (!canHandleLink) {\n        var _element$parentElemen;\n        div.innerHTML = (isSubframe ? '' : '<div class=\"core-iframe-network-error\"></div>') + '<p>' + Translate.instant('core.networkerroriframemsg') + '</p>';\n        (_element$parentElemen = element.parentElement) === null || _element$parentElemen === void 0 || _element$parentElemen.insertBefore(div, element);\n        return;\n      }\n      let link;\n      if (isSubframe) {\n        // Ionic styles are not available in subframes, adding some minimal inline styles.\n        link = document.createElement('a');\n        link.style.display = 'block';\n        link.style.padding = '1em';\n        link.style.fontWeight = '500';\n        link.style.textAlign = 'center';\n        link.style.textTransform = 'uppercase';\n        link.style.cursor = 'pointer';\n      } else {\n        link = document.createElement('ion-button');\n        link.setAttribute('expand', 'block');\n        link.setAttribute('size', 'default');\n        link.classList.add('button', 'button-block', 'button-default', 'button-solid', 'ion-activatable', 'ion-focusable');\n      }\n      link.innerHTML = Translate.instant('core.viewembeddedcontent');\n      link.onclick = event => {\n        CoreContentLinksHelper.handleLink(src, username);\n        event.preventDefault();\n      };\n      div.appendChild(link);\n      (_element$parentElemen2 = element.parentElement) === null || _element$parentElemen2 === void 0 || _element$parentElemen2.insertBefore(div, element);\n    })();\n  }\n  /**\n   * Get auto-login URL for an iframe.\n   *\n   * @param iframe Iframe element.\n   * @param url Original URL.\n   * @returns Promise resolved with the URL.\n   */\n  getAutoLoginUrlForIframe(iframe, url) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const currentSite = CoreSites.getCurrentSite();\n      if (!currentSite) {\n        return url;\n      }\n      if (_this.waitAutoLoginDefer) {\n        // Another iframe is already using auto-login. Wait for it to finish.\n        yield _this.waitAutoLoginDefer;\n        // Return the original URL, we can't request a new auto-login.\n        return url;\n      }\n      // First iframe requesting auto-login.\n      _this.waitAutoLoginDefer = new CorePromisedValue();\n      const finalUrl = yield currentSite.getAutoLoginUrl(url, false);\n      // Resolve the promise once the iframe is loaded, or after a certain time.\n      const unblock = () => {\n        if (!_this.waitAutoLoginDefer) {\n          // Not blocked.\n          return;\n        }\n        _this.waitAutoLoginDefer.resolve();\n        delete _this.waitAutoLoginDefer;\n      };\n      iframe.addEventListener('load', () => unblock());\n      setTimeout(() => unblock(), 15000);\n      return finalUrl;\n    })();\n  }\n  /**\n   * Given an element, return the content window and document.\n   * Please notice that the element should be an iframe, embed or similar.\n   *\n   * @param element Element to treat (iframe, embed, ...).\n   * @returns Window and Document.\n   */\n  getContentWindowAndDocument(element) {\n    const src = 'src' in element ? element.src : element.data;\n    if (src !== 'about:blank' && !CoreUrlUtils.isLocalFileUrl(src)) {\n      // No permissions to access the iframe.\n      return {\n        window: null,\n        document: null\n      };\n    }\n    let contentWindow = 'contentWindow' in element ? element.contentWindow : null;\n    let contentDocument = null;\n    try {\n      contentDocument = 'contentDocument' in element && element.contentDocument ? element.contentDocument : contentWindow && contentWindow.document;\n    } catch (_unused) {\n      // Ignore errors.\n    }\n    if (!contentWindow && contentDocument) {\n      // It's probably an <object>. Try to get the window.\n      contentWindow = contentDocument.defaultView;\n    }\n    if (!contentWindow && 'getSVGDocument' in element) {\n      // It's probably an <embed>. Try to get the window and the document.\n      try {\n        contentDocument = element.getSVGDocument();\n      } catch (_unused2) {\n        // Ignore errors.\n      }\n      if (contentDocument && contentDocument.defaultView) {\n        contentWindow = contentDocument.defaultView;\n      } else if (element.window) {\n        contentWindow = element.window;\n      } else if (element.getWindow) {\n        contentWindow = element.getWindow();\n      }\n    }\n    return {\n      window: contentWindow,\n      document: contentDocument\n    };\n  }\n  /**\n   * Handle some iframe messages.\n   *\n   * @param event Message event.\n   */\n  handleIframeMessage(event) {\n    if (!event.data || event.data.environment != 'moodleapp' || event.data.context != 'iframe') {\n      return;\n    }\n    switch (event.data.action) {\n      case 'window_open':\n        this.windowOpen(event.data.url, event.data.name);\n        break;\n      case 'link_clicked':\n        this.linkClicked(event.data.link);\n        break;\n    }\n  }\n  /**\n   * Redefine the open method in the contentWindow of an element and the sub frames.\n   * Please notice that the element should be an iframe, embed or similar.\n   *\n   * @param element Element to treat (iframe, embed, ...).\n   * @param contentWindow The window of the element contents.\n   * @param contentDocument The document of the element contents.\n   */\n  redefineWindowOpen(element, contentWindow, contentDocument) {\n    if (contentWindow) {\n      // Intercept window.open.\n      contentWindow.open = (url, name) => {\n        this.windowOpen(url, name, element);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return null;\n      };\n    }\n    if (contentDocument.body) {\n      // Search sub frames.\n      CoreIframeUtilsProvider.FRAME_TAGS.forEach(tag => {\n        const elements = Array.from(contentDocument.body.querySelectorAll(tag));\n        elements.forEach(subElement => {\n          this.treatFrame(subElement, true);\n        });\n      });\n    }\n  }\n  /**\n   * Intercept window.open in a frame and its subframes, shows an error modal instead.\n   * Search links (<a>) and open them in browser or InAppBrowser if needed.\n   *\n   * @param element Element to treat (iframe, embed, ...).\n   * @param isSubframe Whether it's a frame inside another frame.\n   */\n  treatFrame(element, isSubframe) {\n    if (!element) {\n      return;\n    }\n    element.classList.add('core-loading');\n    const treatElement = (sendResizeEvent = false) => {\n      this.checkOnlineFrameInOffline(element, isSubframe);\n      const {\n        window,\n        document\n      } = this.getContentWindowAndDocument(element);\n      // Redefine window.open in this element and sub frames, it might have been loaded already.\n      if (window && document) {\n        this.redefineWindowOpen(element, window, document);\n      }\n      // Treat links.\n      if (document) {\n        this.treatFrameLinks(element, document);\n      }\n      // Iframe content has been loaded.\n      // Send a resize events to the iframe so it calculates the right size if needed.\n      if (window && sendResizeEvent) {\n        element.classList.remove('core-loading');\n        setTimeout(() => window.dispatchEvent && window.dispatchEvent(new Event('resize')), 1000);\n      }\n    };\n    treatElement();\n    // Element loaded, redefine window.open and treat links again.\n    element.addEventListener('load', () => treatElement(true));\n  }\n  /**\n   * Search links (<a>) in a frame and open them in browser or InAppBrowser if needed.\n   * Only links that haven't been treated by the frame's Javascript will be treated.\n   *\n   * @param element Element to treat (iframe, embed, ...).\n   * @param contentDocument The document of the element contents.\n   */\n  treatFrameLinks(element, contentDocument) {\n    if (!contentDocument) {\n      return;\n    }\n    contentDocument.addEventListener('click', event => {\n      if (event.defaultPrevented) {\n        // Event already prevented by some other code.\n        return;\n      }\n      // Find the link being clicked.\n      let el = event.target;\n      while (el && el.tagName !== 'A' && el.tagName !== 'a') {\n        el = el.parentElement;\n      }\n      const link = el;\n      if (!link || link.treated) {\n        return;\n      }\n      // Add click listener to the link, this way if the iframe has added a listener to the link it will be executed first.\n      link.treated = true;\n      link.addEventListener('click', event => this.linkClicked(link, element, event));\n    }, {\n      capture: true // Use capture to fix this listener not called if the element clicked is too deep in the DOM.\n    });\n  }\n  /**\n   * Handle a window.open called by a frame.\n   *\n   * @param url URL passed to window.open.\n   * @param name Name passed to window.open.\n   * @param element HTML element of the frame.\n   * @returns Promise resolved when done.\n   */\n  windowOpen(url, name, element) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const scheme = CoreUrlUtils.getUrlScheme(url);\n      if (!scheme) {\n        // It's a relative URL, use the frame src to create the full URL.\n        const src = element ? 'src' in element ? element.src : element.data : null;\n        if (src) {\n          const dirAndFile = CoreFile.getFileAndDirectoryFromPath(src);\n          if (dirAndFile.directory) {\n            url = CorePath.concatenatePaths(dirAndFile.directory, url);\n          } else {\n            _this2.logger.warn('Cannot get iframe dir path to open relative url', url, element);\n            return;\n          }\n        } else {\n          _this2.logger.warn('Cannot get iframe src to open relative url', url, element);\n          return;\n        }\n      }\n      if (name == '_self') {\n        // Link should be loaded in the same frame.\n        if (!element) {\n          _this2.logger.warn('Cannot load URL in iframe because the element was not supplied', url);\n          return;\n        }\n        if (element.tagName.toLowerCase() == 'object') {\n          element.setAttribute('data', url);\n        } else {\n          element.setAttribute('src', url);\n        }\n      } else {\n        try {\n          // It's an external link or a local file, check if it can be opened in the app.\n          yield CoreWindow.open(url, name);\n        } catch (error) {\n          CoreDomUtils.showErrorModal(error);\n        }\n      }\n    })();\n  }\n  /**\n   * A link inside a frame was clicked.\n   *\n   * @param link Link clicked, or data of the link clicked.\n   * @param element Frame element.\n   * @param event Click event.\n   * @returns Promise resolved when done.\n   */\n  linkClicked(link, element, event) {\n    return _asyncToGenerator(function* () {\n      if (event && event.defaultPrevented) {\n        // Event already prevented by some other code.\n        return;\n      }\n      const urlParts = CoreUrl.parse(link.href);\n      const originalHref = 'getAttribute' in link ? link.getAttribute('href') : link.originalHref;\n      if (!link.href || !originalHref || originalHref == '#' || !urlParts || urlParts.protocol == 'javascript') {\n        // Links with no URL and Javascript links are ignored.\n        return;\n      }\n      if (urlParts.protocol && !CoreUrlUtils.isLocalFileUrlScheme(urlParts.protocol, urlParts.domain || '')) {\n        // Scheme suggests it's an external resource.\n        event && event.preventDefault();\n        const frameSrc = element && (element.src || element.data);\n        // If the frame is not local, check the target to identify how to treat the link.\n        if (element && frameSrc && !CoreUrlUtils.isLocalFileUrl(frameSrc) && (!link.target || link.target == '_self')) {\n          // Load the link inside the frame itself.\n          if (element.tagName.toLowerCase() == 'object') {\n            element.setAttribute('data', link.href);\n          } else {\n            element.setAttribute('src', link.href);\n          }\n          return;\n        }\n        // The frame is local or the link needs to be opened in a new window. Open in browser.\n        if (!CoreSites.isLoggedIn()) {\n          CoreUtils.openInBrowser(link.href);\n        } else {\n          var _CoreSites$getCurrent;\n          yield (_CoreSites$getCurrent = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent === void 0 ? void 0 : _CoreSites$getCurrent.openInBrowserWithAutoLogin(link.href);\n        }\n      } else if (link.target == '_parent' || link.target == '_top' || link.target == '_blank') {\n        // Opening links with _parent, _top or _blank can break the app. We'll open it in InAppBrowser.\n        event && event.preventDefault();\n        const filename = link.href.substring(link.href.lastIndexOf('/') + 1);\n        if (!CoreFileHelper.isOpenableInApp({\n          filename\n        })) {\n          try {\n            yield CoreFileHelper.showConfirmOpenUnsupportedFile(false, {\n              filename\n            });\n          } catch (error) {\n            return; // Cancelled, stop.\n          }\n        }\n\n        try {\n          yield CoreUtils.openFile(link.href);\n        } catch (error) {\n          CoreDomUtils.showErrorModal(error);\n        }\n      } else if (CorePlatform.isIOS() && (!link.target || link.target == '_self') && element) {\n        // In cordova ios 4.1.0 links inside iframes stopped working. We'll manually treat them.\n        event && event.preventDefault();\n        if (element.tagName.toLowerCase() == 'object') {\n          element.setAttribute('data', link.href);\n        } else {\n          element.setAttribute('src', link.href);\n        }\n      }\n    })();\n  }\n  /**\n   * Inject code to the iframes because we cannot access the online ones.\n   *\n   * @param userScriptWindow Window.\n   */\n  injectiOSScripts(userScriptWindow) {\n    var _userScriptWindow$WKU;\n    const wwwPath = CoreFile.getWWWAbsolutePath();\n    const linksPath = CorePath.concatenatePaths(wwwPath, 'assets/js/iframe-treat-links.js');\n    (_userScriptWindow$WKU = userScriptWindow.WKUserScript) === null || _userScriptWindow$WKU === void 0 || _userScriptWindow$WKU.addScript({\n      id: 'CoreIframeUtilsLinksScript',\n      file: linksPath\n    });\n    // Handle post messages received by iframes.\n    window.addEventListener('message', event => this.handleIframeMessage(event));\n  }\n  /**\n   * Fix cookies for an iframe URL.\n   *\n   * @param url URL of the iframe.\n   * @returns Promise resolved when done.\n   */\n  fixIframeCookies(url) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!CorePlatform.isIOS() || !url || CoreUrlUtils.isLocalFileUrl(url)) {\n        // No need to fix cookies.\n        return;\n      }\n      // Save a \"fake\" cookie for the iframe's domain to fix a bug in WKWebView.\n      try {\n        const win = window;\n        const urlParts = CoreUrl.parse(url);\n        if (urlParts !== null && urlParts !== void 0 && urlParts.domain && win.WKWebViewCookies) {\n          yield win.WKWebViewCookies.setCookie({\n            name: 'MoodleAppCookieForWKWebView',\n            value: '1',\n            domain: urlParts.domain\n          });\n        }\n      } catch (err) {\n        // Ignore errors.\n        _this3.logger.error('Error setting cookie', err);\n      }\n    })();\n  }\n  /**\n   * Check whether the help should be displayed in current OS.\n   *\n   * @returns Boolean.\n   */\n  shouldDisplayHelp() {\n    return CorePlatform.isIOS() && CorePlatform.getPlatformMajorVersion() >= 14;\n  }\n  /**\n   * Check whether the help should be displayed for a certain iframe.\n   *\n   * @param url Iframe URL.\n   * @returns Boolean.\n   */\n  shouldDisplayHelpForUrl(url) {\n    return this.shouldDisplayHelp() && !CoreUrlUtils.isLocalFileUrl(url);\n  }\n  /**\n   * Open help modal for iframes.\n   */\n  openIframeHelpModal() {\n    CoreDomUtils.showAlertWithOptions({\n      header: Translate.instant('core.settings.ioscookies'),\n      message: Translate.instant('core.ioscookieshelp'),\n      buttons: [{\n        text: Translate.instant('core.cancel'),\n        role: 'cancel'\n      }, {\n        text: Translate.instant('core.opensettings'),\n        handler: () => {\n          Diagnostic.switchToSettings();\n        }\n      }]\n    });\n  }\n}\n_class = CoreIframeUtilsProvider;\n_class.FRAME_TAGS = ['iframe', 'frame', 'object', 'embed'];\n_class.ɵfac = function CoreIframeUtilsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreIframeUtils = makeSingleton(CoreIframeUtilsProvider);","map":{"version":3,"names":["CoreNetwork","CoreFile","CoreFileHelper","CoreSites","CoreDomUtils","CoreUrlUtils","CoreUtils","makeSingleton","NgZone","Translate","Diagnostic","CoreLogger","CoreUrl","CoreWindow","CoreContentLinksHelper","CorePath","CorePromisedValue","CorePlatform","CoreIframeUtilsProvider","constructor","logger","getInstance","checkOnlineFrameInOffline","element","isSubframe","src","data","isLocalFileUrl","isOnline","classList","contains","addOfflineWarning","subscription","onConnectShouldBeStable","subscribe","run","unsubscribe","parentElement","removeElement","remove","style","display","_asyncToGenerator","_site$getInfo","_element$parentElemen2","site","getCurrentSite","username","getInfo","undefined","div","document","createElement","add","canHandleLink","_element$parentElemen","innerHTML","instant","insertBefore","link","padding","fontWeight","textAlign","textTransform","cursor","setAttribute","onclick","event","handleLink","preventDefault","appendChild","getAutoLoginUrlForIframe","iframe","url","_this","currentSite","waitAutoLoginDefer","finalUrl","getAutoLoginUrl","unblock","resolve","addEventListener","setTimeout","getContentWindowAndDocument","window","contentWindow","contentDocument","_unused","defaultView","getSVGDocument","_unused2","getWindow","handleIframeMessage","environment","context","action","windowOpen","name","linkClicked","redefineWindowOpen","open","body","FRAME_TAGS","forEach","tag","elements","Array","from","querySelectorAll","subElement","treatFrame","treatElement","sendResizeEvent","treatFrameLinks","dispatchEvent","Event","defaultPrevented","el","target","tagName","treated","capture","_this2","scheme","getUrlScheme","dirAndFile","getFileAndDirectoryFromPath","directory","concatenatePaths","warn","toLowerCase","error","showErrorModal","urlParts","parse","href","originalHref","getAttribute","protocol","isLocalFileUrlScheme","domain","frameSrc","isLoggedIn","openInBrowser","_CoreSites$getCurrent","openInBrowserWithAutoLogin","filename","substring","lastIndexOf","isOpenableInApp","showConfirmOpenUnsupportedFile","openFile","isIOS","injectiOSScripts","userScriptWindow","_userScriptWindow$WKU","wwwPath","getWWWAbsolutePath","linksPath","WKUserScript","addScript","id","file","fixIframeCookies","_this3","win","WKWebViewCookies","setCookie","value","err","shouldDisplayHelp","getPlatformMajorVersion","shouldDisplayHelpForUrl","openIframeHelpModal","showAlertWithOptions","header","message","buttons","text","role","handler","switchToSettings","_class","factory","ɵfac","providedIn","CoreIframeUtils"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/utils/iframe.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { WKUserScriptWindow } from 'cordova-plugin-wkuserscript';\nimport { WKWebViewCookiesWindow } from 'cordova-plugin-wkwebview-cookies';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile } from '@services/file';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\n\nimport { makeSingleton, NgZone, Translate, Diagnostic } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreWindow } from '@singletons/window';\nimport { CoreContentLinksHelper } from '@features/contentlinks/services/contentlinks-helper';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { FrameElement } from '@classes/element-controllers/FrameElementController';\n\ntype CoreFrameElement = FrameElement & {\n    window?: Window;\n    getWindow?(): Window;\n};\n\n/*\n * \"Utils\" service with helper functions for iframes, embed and similar.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreIframeUtilsProvider {\n\n    static readonly FRAME_TAGS = ['iframe', 'frame', 'object', 'embed'];\n\n    protected logger: CoreLogger;\n    protected waitAutoLoginDefer?: CorePromisedValue<void>;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreIframeUtilsProvider');\n    }\n\n    /**\n     * Check if a frame uses an online URL but the app is offline. If it does, the iframe is hidden and a warning is shown.\n     *\n     * @param element The frame to check (iframe, embed, ...).\n     * @param isSubframe Whether it's a frame inside another frame.\n     * @returns True if frame is online and the app is offline, false otherwise.\n     */\n    checkOnlineFrameInOffline(element: CoreFrameElement, isSubframe?: boolean): boolean {\n        const src = 'src' in element ? element.src : element.data;\n\n        if (src && src != 'about:blank' && !CoreUrlUtils.isLocalFileUrl(src) && !CoreNetwork.isOnline()) {\n            if (element.classList.contains('core-iframe-offline-disabled')) {\n                // Iframe already hidden, stop.\n                return true;\n            }\n\n            // The frame has an online URL but the app is offline. Show a warning, or a link if the URL can be opened in the app.\n            this.addOfflineWarning(element, src, isSubframe);\n\n            // If the network changes, check it again.\n            const subscription = CoreNetwork.onConnectShouldBeStable().subscribe(() => {\n                // Execute the callback in the Angular zone, so change detection doesn't stop working.\n                NgZone.run(() => {\n                    if (!this.checkOnlineFrameInOffline(element, isSubframe)) {\n                        // Now the app is online, no need to check connection again.\n                        subscription.unsubscribe();\n                    }\n                });\n            });\n\n            return true;\n        } else if (element.classList.contains('core-iframe-offline-disabled') && element.parentElement) {\n            // Reload the frame.\n            if ('src' in element) {\n                // eslint-disable-next-line no-self-assign\n                element.src = element.src;\n\n            } else {\n                // eslint-disable-next-line no-self-assign\n                element.data = element.data;\n            }\n\n            // Remove the warning and show the iframe\n            CoreDomUtils.removeElement(element.parentElement, 'div.core-iframe-offline-warning');\n            element.classList.remove('core-iframe-offline-disabled');\n\n            if (isSubframe) {\n                element.style.display = '';\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Add an offline warning message.\n     *\n     * @param element The frame to check (iframe, embed, ...).\n     * @param src Frame src.\n     * @param isSubframe Whether it's a frame inside another frame.\n     * @returns Promise resolved when done.\n     */\n    protected async addOfflineWarning(element: HTMLElement, src: string, isSubframe?: boolean): Promise<void> {\n        const site = CoreSites.getCurrentSite();\n        const username = site ? site.getInfo()?.username : undefined;\n\n        const div = document.createElement('div');\n        div.classList.add('core-iframe-offline-warning', 'ion-padding', 'ion-text-center');\n\n        // Add a class to specify that the iframe is hidden.\n        element.classList.add('core-iframe-offline-disabled');\n        if (isSubframe) {\n            // We cannot apply CSS styles in subframes, just hide the iframe.\n            element.style.display = 'none';\n        }\n\n        const canHandleLink = await CoreContentLinksHelper.canHandleLink(src, undefined, username);\n\n        if (!canHandleLink) {\n            div.innerHTML = (isSubframe ? '' : '<div class=\"core-iframe-network-error\"></div>') +\n                '<p>' + Translate.instant('core.networkerroriframemsg') + '</p>';\n\n            element.parentElement?.insertBefore(div, element);\n\n            return;\n        }\n\n        let link: HTMLElement | undefined;\n\n        if (isSubframe) {\n            // Ionic styles are not available in subframes, adding some minimal inline styles.\n            link = document.createElement('a');\n            link.style.display = 'block';\n            link.style.padding = '1em';\n            link.style.fontWeight = '500';\n            link.style.textAlign = 'center';\n            link.style.textTransform = 'uppercase';\n            link.style.cursor = 'pointer';\n        } else {\n            link = document.createElement('ion-button');\n            link.setAttribute('expand', 'block');\n            link.setAttribute('size', 'default');\n            link.classList.add(\n                'button',\n                'button-block',\n                'button-default',\n                'button-solid',\n                'ion-activatable',\n                'ion-focusable',\n            );\n        }\n\n        link.innerHTML = Translate.instant('core.viewembeddedcontent');\n\n        link.onclick = (event: Event): void => {\n            CoreContentLinksHelper.handleLink(src, username);\n            event.preventDefault();\n        };\n\n        div.appendChild(link);\n\n        element.parentElement?.insertBefore(div, element);\n    }\n\n    /**\n     * Get auto-login URL for an iframe.\n     *\n     * @param iframe Iframe element.\n     * @param url Original URL.\n     * @returns Promise resolved with the URL.\n     */\n    async getAutoLoginUrlForIframe(iframe: HTMLIFrameElement, url: string): Promise<string> {\n        const currentSite = CoreSites.getCurrentSite();\n        if (!currentSite) {\n            return url;\n        }\n\n        if (this.waitAutoLoginDefer) {\n            // Another iframe is already using auto-login. Wait for it to finish.\n            await this.waitAutoLoginDefer;\n\n            // Return the original URL, we can't request a new auto-login.\n            return url;\n        }\n\n        // First iframe requesting auto-login.\n        this.waitAutoLoginDefer = new CorePromisedValue();\n\n        const finalUrl = await currentSite.getAutoLoginUrl(url, false);\n\n        // Resolve the promise once the iframe is loaded, or after a certain time.\n        const unblock = () => {\n            if (!this.waitAutoLoginDefer) {\n                // Not blocked.\n                return;\n            }\n\n            this.waitAutoLoginDefer.resolve();\n            delete this.waitAutoLoginDefer;\n        };\n\n        iframe.addEventListener('load', () => unblock());\n        setTimeout(() => unblock(), 15000);\n\n        return finalUrl;\n    }\n\n    /**\n     * Given an element, return the content window and document.\n     * Please notice that the element should be an iframe, embed or similar.\n     *\n     * @param element Element to treat (iframe, embed, ...).\n     * @returns Window and Document.\n     */\n    getContentWindowAndDocument(element: CoreFrameElement): { window: Window | null; document: Document | null } {\n        const src = 'src' in element ? element.src : element.data;\n        if (src !== 'about:blank' && !CoreUrlUtils.isLocalFileUrl(src)) {\n            // No permissions to access the iframe.\n            return { window: null, document: null };\n        }\n\n        let contentWindow: Window | null = 'contentWindow' in element ? element.contentWindow : null;\n        let contentDocument: Document | null = null;\n\n        try {\n            contentDocument = 'contentDocument' in element && element.contentDocument\n                ? element.contentDocument\n                : contentWindow && contentWindow.document;\n        } catch {\n            // Ignore errors.\n        }\n\n        if (!contentWindow && contentDocument) {\n            // It's probably an <object>. Try to get the window.\n            contentWindow = contentDocument.defaultView;\n        }\n\n        if (!contentWindow && 'getSVGDocument' in element) {\n            // It's probably an <embed>. Try to get the window and the document.\n            try {\n                contentDocument = element.getSVGDocument();\n            } catch {\n                // Ignore errors.\n            }\n\n            if (contentDocument && contentDocument.defaultView) {\n                contentWindow = contentDocument.defaultView;\n            } else if (element.window) {\n                contentWindow = element.window;\n            } else if (element.getWindow) {\n                contentWindow = element.getWindow();\n            }\n        }\n\n        return { window: contentWindow, document: contentDocument };\n    }\n\n    /**\n     * Handle some iframe messages.\n     *\n     * @param event Message event.\n     */\n    handleIframeMessage(event: MessageEvent): void {\n        if (!event.data || event.data.environment != 'moodleapp' || event.data.context != 'iframe') {\n            return;\n        }\n\n        switch (event.data.action) {\n            case 'window_open':\n                this.windowOpen(event.data.url, event.data.name);\n                break;\n\n            case 'link_clicked':\n                this.linkClicked(event.data.link);\n                break;\n        }\n    }\n\n    /**\n     * Redefine the open method in the contentWindow of an element and the sub frames.\n     * Please notice that the element should be an iframe, embed or similar.\n     *\n     * @param element Element to treat (iframe, embed, ...).\n     * @param contentWindow The window of the element contents.\n     * @param contentDocument The document of the element contents.\n     */\n    redefineWindowOpen(\n        element: CoreFrameElement,\n        contentWindow: Window,\n        contentDocument: Document,\n    ): void {\n        if (contentWindow) {\n            // Intercept window.open.\n            contentWindow.open = (url: string, name: string) => {\n                this.windowOpen(url, name, element);\n\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                return null as any;\n            };\n        }\n\n        if (contentDocument.body) {\n            // Search sub frames.\n            CoreIframeUtilsProvider.FRAME_TAGS.forEach((tag) => {\n                const elements = Array.from(contentDocument.body.querySelectorAll(tag));\n                elements.forEach((subElement: CoreFrameElement) => {\n                    this.treatFrame(subElement, true);\n                });\n            });\n        }\n    }\n\n    /**\n     * Intercept window.open in a frame and its subframes, shows an error modal instead.\n     * Search links (<a>) and open them in browser or InAppBrowser if needed.\n     *\n     * @param element Element to treat (iframe, embed, ...).\n     * @param isSubframe Whether it's a frame inside another frame.\n     */\n    treatFrame(element: CoreFrameElement, isSubframe?: boolean): void {\n        if (!element) {\n            return;\n        }\n\n        element.classList.add('core-loading');\n\n        const treatElement = (sendResizeEvent: boolean = false) => {\n            this.checkOnlineFrameInOffline(element, isSubframe);\n\n            const { window, document } = this.getContentWindowAndDocument(element);\n\n            // Redefine window.open in this element and sub frames, it might have been loaded already.\n            if (window && document) {\n                this.redefineWindowOpen(element, window, document);\n            }\n\n            // Treat links.\n            if (document) {\n                this.treatFrameLinks(element, document);\n            }\n\n            // Iframe content has been loaded.\n            // Send a resize events to the iframe so it calculates the right size if needed.\n            if (window && sendResizeEvent) {\n                element.classList.remove('core-loading');\n\n                setTimeout(() => window.dispatchEvent && window.dispatchEvent(new Event('resize')), 1000);\n            }\n        };\n\n        treatElement();\n\n        // Element loaded, redefine window.open and treat links again.\n        element.addEventListener('load', () => treatElement(true));\n    }\n\n    /**\n     * Search links (<a>) in a frame and open them in browser or InAppBrowser if needed.\n     * Only links that haven't been treated by the frame's Javascript will be treated.\n     *\n     * @param element Element to treat (iframe, embed, ...).\n     * @param contentDocument The document of the element contents.\n     */\n    treatFrameLinks(element: CoreFrameElement, contentDocument: Document): void {\n        if (!contentDocument) {\n            return;\n        }\n\n        contentDocument.addEventListener('click', (event) => {\n            if (event.defaultPrevented) {\n                // Event already prevented by some other code.\n                return;\n            }\n\n            // Find the link being clicked.\n            let el: Element | null = event.target as Element;\n            while (el && el.tagName !== 'A' && el.tagName !== 'a') {\n                el = el.parentElement;\n            }\n\n            const link = <CoreIframeHTMLAnchorElement> el;\n            if (!link || link.treated) {\n                return;\n            }\n\n            // Add click listener to the link, this way if the iframe has added a listener to the link it will be executed first.\n            link.treated = true;\n            link.addEventListener('click', event => this.linkClicked(link, element, event));\n        }, {\n            capture: true, // Use capture to fix this listener not called if the element clicked is too deep in the DOM.\n        });\n    }\n\n    /**\n     * Handle a window.open called by a frame.\n     *\n     * @param url URL passed to window.open.\n     * @param name Name passed to window.open.\n     * @param element HTML element of the frame.\n     * @returns Promise resolved when done.\n     */\n    protected async windowOpen(url: string, name: string, element?: CoreFrameElement): Promise<void> {\n        const scheme = CoreUrlUtils.getUrlScheme(url);\n        if (!scheme) {\n            // It's a relative URL, use the frame src to create the full URL.\n            const src = element\n                ? ('src' in element ? element.src : element.data)\n                : null;\n            if (src) {\n                const dirAndFile = CoreFile.getFileAndDirectoryFromPath(src);\n                if (dirAndFile.directory) {\n                    url = CorePath.concatenatePaths(dirAndFile.directory, url);\n                } else {\n                    this.logger.warn('Cannot get iframe dir path to open relative url', url, element);\n\n                    return;\n                }\n            } else {\n                this.logger.warn('Cannot get iframe src to open relative url', url, element);\n\n                return;\n            }\n        }\n\n        if (name == '_self') {\n            // Link should be loaded in the same frame.\n            if (!element) {\n                this.logger.warn('Cannot load URL in iframe because the element was not supplied', url);\n\n                return;\n            }\n\n            if (element.tagName.toLowerCase() == 'object') {\n                element.setAttribute('data', url);\n            } else {\n                element.setAttribute('src', url);\n            }\n        } else {\n            try {\n                // It's an external link or a local file, check if it can be opened in the app.\n                await CoreWindow.open(url, name);\n            } catch (error) {\n                CoreDomUtils.showErrorModal(error);\n            }\n        }\n    }\n\n    /**\n     * A link inside a frame was clicked.\n     *\n     * @param link Link clicked, or data of the link clicked.\n     * @param element Frame element.\n     * @param event Click event.\n     * @returns Promise resolved when done.\n     */\n    protected async linkClicked(\n        link: CoreIframeHTMLAnchorElement | {href: string; target?: string; originalHref?: string},\n        element?: CoreFrameElement,\n        event?: Event,\n    ): Promise<void> {\n        if (event && event.defaultPrevented) {\n            // Event already prevented by some other code.\n            return;\n        }\n\n        const urlParts = CoreUrl.parse(link.href);\n        const originalHref = 'getAttribute' in link ? link.getAttribute('href') : link.originalHref;\n        if (!link.href || !originalHref || originalHref == '#' || !urlParts || urlParts.protocol == 'javascript') {\n            // Links with no URL and Javascript links are ignored.\n            return;\n        }\n\n        if (urlParts.protocol && !CoreUrlUtils.isLocalFileUrlScheme(urlParts.protocol, urlParts.domain || '')) {\n            // Scheme suggests it's an external resource.\n            event && event.preventDefault();\n\n            const frameSrc = element && ((<HTMLIFrameElement> element).src || (<HTMLObjectElement> element).data);\n\n            // If the frame is not local, check the target to identify how to treat the link.\n            if (\n                element &&\n                frameSrc &&\n                !CoreUrlUtils.isLocalFileUrl(frameSrc) &&\n                (!link.target || link.target == '_self')\n            ) {\n                // Load the link inside the frame itself.\n                if (element.tagName.toLowerCase() == 'object') {\n                    element.setAttribute('data', link.href);\n                } else {\n                    element.setAttribute('src', link.href);\n                }\n\n                return;\n            }\n\n            // The frame is local or the link needs to be opened in a new window. Open in browser.\n            if (!CoreSites.isLoggedIn()) {\n                CoreUtils.openInBrowser(link.href);\n            } else {\n                await CoreSites.getCurrentSite()?.openInBrowserWithAutoLogin(link.href);\n            }\n        } else if (link.target == '_parent' || link.target == '_top' || link.target == '_blank') {\n            // Opening links with _parent, _top or _blank can break the app. We'll open it in InAppBrowser.\n            event && event.preventDefault();\n\n            const filename = link.href.substring(link.href.lastIndexOf('/') + 1);\n\n            if (!CoreFileHelper.isOpenableInApp({ filename })) {\n                try {\n                    await CoreFileHelper.showConfirmOpenUnsupportedFile(false, { filename });\n                } catch (error) {\n                    return; // Cancelled, stop.\n                }\n            }\n\n            try {\n                await CoreUtils.openFile(link.href);\n            } catch (error) {\n                CoreDomUtils.showErrorModal(error);\n            }\n        } else if (CorePlatform.isIOS() && (!link.target || link.target == '_self') && element) {\n            // In cordova ios 4.1.0 links inside iframes stopped working. We'll manually treat them.\n            event && event.preventDefault();\n            if (element.tagName.toLowerCase() == 'object') {\n                element.setAttribute('data', link.href);\n            } else {\n                element.setAttribute('src', link.href);\n            }\n        }\n    }\n\n    /**\n     * Inject code to the iframes because we cannot access the online ones.\n     *\n     * @param userScriptWindow Window.\n     */\n    injectiOSScripts(userScriptWindow: WKUserScriptWindow): void {\n        const wwwPath = CoreFile.getWWWAbsolutePath();\n        const linksPath = CorePath.concatenatePaths(wwwPath, 'assets/js/iframe-treat-links.js');\n\n        userScriptWindow.WKUserScript?.addScript({ id: 'CoreIframeUtilsLinksScript', file: linksPath });\n\n        // Handle post messages received by iframes.\n        window.addEventListener('message', (event) => this.handleIframeMessage(event));\n    }\n\n    /**\n     * Fix cookies for an iframe URL.\n     *\n     * @param url URL of the iframe.\n     * @returns Promise resolved when done.\n     */\n    async fixIframeCookies(url: string): Promise<void> {\n        if (!CorePlatform.isIOS() || !url || CoreUrlUtils.isLocalFileUrl(url)) {\n            // No need to fix cookies.\n            return;\n        }\n\n        // Save a \"fake\" cookie for the iframe's domain to fix a bug in WKWebView.\n        try {\n            const win = <WKWebViewCookiesWindow> window;\n            const urlParts = CoreUrl.parse(url);\n\n            if (urlParts?.domain && win.WKWebViewCookies) {\n                await win.WKWebViewCookies.setCookie({\n                    name: 'MoodleAppCookieForWKWebView',\n                    value: '1',\n                    domain: urlParts.domain,\n                });\n            }\n        } catch (err) {\n            // Ignore errors.\n            this.logger.error('Error setting cookie', err);\n        }\n    }\n\n    /**\n     * Check whether the help should be displayed in current OS.\n     *\n     * @returns Boolean.\n     */\n    shouldDisplayHelp(): boolean {\n        return CorePlatform.isIOS() && CorePlatform.getPlatformMajorVersion() >= 14;\n    }\n\n    /**\n     * Check whether the help should be displayed for a certain iframe.\n     *\n     * @param url Iframe URL.\n     * @returns Boolean.\n     */\n    shouldDisplayHelpForUrl(url: string): boolean {\n        return this.shouldDisplayHelp() && !CoreUrlUtils.isLocalFileUrl(url);\n    }\n\n    /**\n     * Open help modal for iframes.\n     */\n    openIframeHelpModal(): void {\n        CoreDomUtils.showAlertWithOptions({\n            header: Translate.instant('core.settings.ioscookies'),\n            message: Translate.instant('core.ioscookieshelp'),\n            buttons: [\n                {\n                    text: Translate.instant('core.cancel'),\n                    role: 'cancel',\n                },\n                {\n                    text: Translate.instant('core.opensettings'),\n                    handler: (): void => {\n                        Diagnostic.switchToSettings();\n                    },\n                },\n            ],\n        });\n    }\n\n}\n\nexport const CoreIframeUtils = makeSingleton(CoreIframeUtilsProvider);\n\n/**\n * Subtype of HTMLAnchorElement, with some calculated data.\n */\ntype CoreIframeHTMLAnchorElement = HTMLAnchorElement & {\n    treated?: boolean; // Whether the element has been treated already.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}