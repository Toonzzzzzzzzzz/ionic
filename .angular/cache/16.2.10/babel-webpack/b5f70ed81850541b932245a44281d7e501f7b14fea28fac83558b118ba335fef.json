{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { HttpResponse } from '@angular/common/http';\nimport { FileUploadOptions } from '@awesome-cordova-plugins/file-transfer/ngx';\nimport { Md5 } from 'ts-md5/dist/md5';\nimport { firstValueFrom } from 'rxjs';\nimport { timeout } from 'rxjs/operators';\nimport { CoreNativeToAngularHttpResponse } from '@classes/native-to-angular-http';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile } from '@services/file';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreInterceptor } from '@classes/interceptor';\nimport { makeSingleton, Translate, FileTransfer, Http, NativeHttp } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreAjaxError } from '@classes/errors/ajaxerror';\nimport { CoreAjaxWSError } from '@classes/errors/ajaxwserror';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreHttpError } from '@classes/errors/httperror';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { CoreSiteError } from '@classes/errors/siteerror';\nimport { CoreUserGuestSupportConfig } from '@features/user/classes/support/guest-support-config';\nimport { CoreSites } from '@services/sites';\nimport { CoreLang } from './lang';\nimport { CoreErrorLogs } from '@singletons/error-logs';\nimport * as i0 from \"@angular/core\";\n/**\n * This service allows performing WS calls and download/upload files.\n */\nexport class CoreWSProvider {\n  constructor() {\n    this.mimeTypeCache = {}; // A \"cache\" to store file mimetypes to decrease HEAD requests.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.ongoingCalls = {};\n    this.retryCalls = [];\n    this.retryTimeout = 0;\n    this.logger = CoreLogger.getInstance('CoreWSProvider');\n  }\n  /**\n   * Adds the call data to an special queue to be processed when retrying.\n   *\n   * @param method The WebService method to be called.\n   * @param siteUrl Complete site url to perform the call.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra settings and information.\n   * @returns Deferred promise resolved with the response data in success and rejected with the error if it fails.\n   */\n  addToRetryQueue(method, siteUrl, data, preSets) {\n    const call = {\n      method,\n      siteUrl,\n      data,\n      preSets,\n      deferred: new CorePromisedValue()\n    };\n    this.retryCalls.push(call);\n    return call.deferred;\n  }\n  /**\n   * A wrapper function for a moodle WebService call.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method. It's recommended to call convertValuesToString before passing the data.\n   * @param preSets Extra settings and information.\n   * @returns Promise resolved with the response data in success and rejected if it fails.\n   */\n  call(method, data, preSets) {\n    if (!preSets) {\n      throw new CoreError(Translate.instant('core.unexpectederror'));\n    } else if (!CoreNetwork.isOnline()) {\n      throw new CoreNetworkError();\n    }\n    preSets.typeExpected = preSets.typeExpected || 'object';\n    if (preSets.responseExpected === undefined) {\n      preSets.responseExpected = true;\n    }\n    const dataToSend = Object.assign({}, data); // Create a new object so the changes don't affect the original data.\n    dataToSend['wsfunction'] = method;\n    dataToSend['wstoken'] = preSets.wsToken;\n    const siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';\n    // There are some ongoing retry calls, wait for timeout.\n    if (this.retryCalls.length > 0) {\n      this.logger.warn('Calls locked, trying later...');\n      return this.addToRetryQueue(method, siteUrl, dataToSend, preSets);\n    } else {\n      return this.performPost(method, siteUrl, dataToSend, preSets);\n    }\n  }\n  /**\n   * Call a Moodle WS using the AJAX API. Please use it if the WS layer is not an option.\n   * It uses a cache to prevent duplicate requests.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra settings and information. Only some\n   * @returns Promise resolved with the response data in success and rejected with CoreAjaxError.\n   */\n  callAjax(method, data, preSets) {\n    const cacheParams = {\n      methodname: method,\n      args: data\n    };\n    let promise = this.getPromiseHttp('ajax', preSets.siteUrl, cacheParams);\n    if (!promise) {\n      promise = this.performAjax(method, data, preSets);\n      promise = this.setPromiseHttp(promise, 'ajax', preSets.siteUrl, cacheParams);\n    }\n    return promise;\n  }\n  /**\n   * Converts an objects values to strings where appropriate.\n   * Arrays (associative or otherwise) will be maintained, null values will be removed.\n   *\n   * @param data The data that needs all the non-object values set to strings.\n   * @param stripUnicode If Unicode long chars need to be stripped.\n   * @returns The cleaned object or null if some strings becomes empty after stripping Unicode.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  convertValuesToString(data, stripUnicode) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const result = Array.isArray(data) ? [] : {};\n    for (const key in data) {\n      let value = data[key];\n      if (value == null) {\n        // Skip null or undefined value.\n        continue;\n      } else if (typeof value == 'object') {\n        // Object or array.\n        value = this.convertValuesToString(value, stripUnicode);\n        if (value == null) {\n          return null;\n        }\n      } else if (typeof value == 'string') {\n        if (stripUnicode) {\n          const stripped = CoreTextUtils.stripUnicode(value);\n          if (stripped != value && stripped.trim().length == 0) {\n            return null;\n          }\n          value = stripped;\n        }\n      } else if (typeof value == 'boolean') {\n        /* Moodle does not allow \"true\" or \"false\" in WS parameters, only in POST parameters.\n           We've been using \"true\" and \"false\" for WS settings \"filter\" and \"fileurl\",\n           we keep it this way to avoid changing cache keys. */\n        if (key == 'moodlewssettingfilter' || key == 'moodlewssettingfileurl') {\n          value = value ? 'true' : 'false';\n        } else {\n          value = value ? '1' : '0';\n        }\n      } else if (typeof value == 'number') {\n        value = String(value);\n      } else {\n        // Unknown type.\n        continue;\n      }\n      if (Array.isArray(result)) {\n        result.push(value);\n      } else {\n        result[key] = value;\n      }\n    }\n    return result;\n  }\n  /**\n   * It will check if response has failed and throw the propper error.\n   *\n   * @param response WS response.\n   * @param defaultMessage Message to be used in case warnings is empty.\n   */\n  throwOnFailedStatus(response, defaultMessage) {\n    if (!response.status) {\n      if (response.warnings && response.warnings.length) {\n        throw new CoreWSError(response.warnings[0]);\n      }\n      throw new CoreError(defaultMessage);\n    }\n  }\n  /**\n   * Downloads a file from Moodle using Cordova File API.\n   *\n   * @param url Download url.\n   * @param path Local path to store the file.\n   * @param addExtension True if extension need to be added to the final path.\n   * @param onProgress Function to call on progress.\n   * @returns Promise resolved with the downloaded file.\n   */\n  downloadFile(url, path, addExtension, onProgress) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.logger.debug('Downloading file', url, path, addExtension);\n      if (!CoreNetwork.isOnline()) {\n        throw new CoreNetworkError();\n      }\n      // Use a tmp path to download the file and then move it to final location.\n      // This is because if the download fails, the local file is deleted.\n      const tmpPath = path + '.tmp';\n      try {\n        // Create the tmp file as an empty file.\n        const fileEntry = yield CoreFile.createFile(tmpPath);\n        const transfer = FileTransfer.create();\n        onProgress && transfer.onProgress(onProgress);\n        // Download the file in the tmp file.\n        yield transfer.download(url, fileEntry.toURL(), true, {\n          headers: {\n            'User-Agent': navigator.userAgent\n          }\n        });\n        let extension = '';\n        if (addExtension) {\n          extension = CoreMimetypeUtils.getFileExtension(path) || '';\n          // Google Drive extensions will be considered invalid since Moodle usually converts them.\n          if (!extension || ['gdoc', 'gsheet', 'gslides', 'gdraw', 'php'].includes(extension)) {\n            // Not valid, get the file's mimetype.\n            const mimetype = yield _this.getRemoteFileMimeType(url);\n            if (mimetype) {\n              const remoteExtension = CoreMimetypeUtils.getExtension(mimetype, url);\n              // If the file is from Google Drive, ignore mimetype application/json.\n              if (remoteExtension && (!extension || mimetype != 'application/json')) {\n                if (extension) {\n                  // Remove existing extension since we will use another one.\n                  path = CoreMimetypeUtils.removeExtension(path);\n                }\n                path += '.' + remoteExtension;\n                extension = remoteExtension;\n              }\n            }\n          }\n        }\n        // Move the file to the final location.\n        const movedEntry = yield CoreFile.moveFile(tmpPath, path);\n        _this.logger.debug(`Success downloading file ${url} to ${path} with extension ${extension}`);\n        // Also return the extension and path.\n        return Object.assign(movedEntry, {\n          extension: extension,\n          path: path\n        });\n      } catch (error) {\n        _this.logger.error(`Error downloading ${url} to ${path}`, error);\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Get a promise from the cache.\n   *\n   * @param method Method of the HTTP request.\n   * @param url Base URL of the HTTP request.\n   * @param params Params of the HTTP request.\n   * @returns the on going call if any.\n   */\n  getPromiseHttp(method, url, params) {\n    const queueItemId = this.getQueueItemId(method, url, params);\n    if (this.ongoingCalls[queueItemId] !== undefined) {\n      return this.ongoingCalls[queueItemId];\n    }\n  }\n  /**\n   * Perform a HEAD request to get the mimetype of a remote file.\n   *\n   * @param url File URL.\n   * @param ignoreCache True to ignore cache, false otherwise.\n   * @returns Promise resolved with the mimetype or '' if failure.\n   */\n  getRemoteFileMimeType(url, ignoreCache) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const cachedMimeType = _this2.mimeTypeCache[url];\n      if (cachedMimeType && !ignoreCache) {\n        return cachedMimeType;\n      }\n      try {\n        const response = yield _this2.performHead(url);\n        let mimeType = response.headers.get('Content-Type');\n        if (mimeType) {\n          // Remove \"parameters\" like charset.\n          mimeType = mimeType.split(';')[0];\n        }\n        _this2.mimeTypeCache[url] = mimeType;\n        return mimeType || '';\n      } catch (error) {\n        // Error, resolve with empty mimetype.\n        return '';\n      }\n    })();\n  }\n  /**\n   * Perform a HEAD request to get the size of a remote file.\n   *\n   * @param url File URL.\n   * @returns Promise resolved with the size or -1 if failure.\n   */\n  getRemoteFileSize(url) {\n    return this.performHead(url).then(response => {\n      const contentLength = response.headers.get('Content-Length');\n      const size = contentLength ? parseInt(contentLength, 10) : 0;\n      if (size) {\n        return size;\n      }\n      return -1;\n    }).catch(() => -1);\n  }\n  /**\n   * Get a request timeout based on the network connection.\n   *\n   * @returns Timeout in ms.\n   */\n  getRequestTimeout() {\n    return CoreNetwork.isNetworkAccessLimited() ? CoreConstants.WS_TIMEOUT : CoreConstants.WS_TIMEOUT_WIFI;\n  }\n  /**\n   * Get the unique queue item id of the cache for a HTTP request.\n   *\n   * @param method Method of the HTTP request.\n   * @param url Base URL of the HTTP request.\n   * @param params Params of the HTTP request.\n   * @returns Queue item ID.\n   */\n  getQueueItemId(method, url, params) {\n    if (params) {\n      url += '###' + CoreInterceptor.serialize(params);\n    }\n    return method + '#' + Md5.hashAsciiStr(url);\n  }\n  /**\n   * Call a Moodle WS using the AJAX API.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra settings and information. Only some\n   * @returns Promise resolved with the response data in success and rejected with CoreAjaxError.\n   */\n  performAjax(method, data, preSets) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let promise;\n      if (preSets.siteUrl === undefined) {\n        const unexpectedError = new CoreAjaxError(Translate.instant('core.unexpectederror'));\n        CoreErrorLogs.addErrorLog({\n          method,\n          type: 'CoreAjaxError',\n          message: Translate.instant('core.unexpectederror'),\n          time: new Date().getTime(),\n          data\n        });\n        throw unexpectedError;\n      } else if (!CoreNetwork.isOnline()) {\n        const networkError = new CoreAjaxError(Translate.instant('core.networkerrormsg'));\n        CoreErrorLogs.addErrorLog({\n          method,\n          type: 'CoreAjaxError',\n          message: Translate.instant('core.networkerrormsg'),\n          time: new Date().getTime(),\n          data\n        });\n        throw networkError;\n      }\n      if (preSets.responseExpected === undefined) {\n        preSets.responseExpected = true;\n      }\n      const script = preSets.noLogin ? 'service-nologin.php' : 'service.php';\n      const ajaxData = [{\n        index: 0,\n        methodname: method,\n        args: _this3.convertValuesToString(data)\n      }];\n      const lang = yield CoreLang.getCurrentLanguage(\"lms\" /* CoreLangFormat.LMS */);\n      // The info= parameter has no function. It is just to help with debugging.\n      // We call it info to match the parameter name use by Moodle's AMD ajax module.\n      let siteUrl = preSets.siteUrl + '/lib/ajax/' + script + '?info=' + method + `&lang=${lang}`;\n      if (preSets.noLogin && preSets.useGet) {\n        // Send params using GET.\n        siteUrl += '&args=' + encodeURIComponent(JSON.stringify(ajaxData));\n        promise = _this3.sendHTTPRequest(siteUrl, {\n          method: 'get'\n        });\n      } else {\n        promise = _this3.sendHTTPRequest(siteUrl, {\n          method: 'post',\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data: ajaxData,\n          serializer: 'json'\n        });\n      }\n      return promise.then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (response) {\n          let data = response.body;\n          // Some moodle web services return null.\n          // If the responseExpected value is set then so long as no data is returned, we create a blank object.\n          if (!data && !preSets.responseExpected) {\n            data = [{}];\n          }\n          // Check if error. Ajax layer should always return an object (if error) or an array (if success).\n          if (!data || typeof data != 'object') {\n            var _CoreSites$getCurrent;\n            const message = CoreSites.isLoggedIn() ? Translate.instant('core.siteunavailablehelp', {\n              site: (_CoreSites$getCurrent = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent === void 0 ? void 0 : _CoreSites$getCurrent.siteUrl\n            }) : Translate.instant('core.sitenotfoundhelp');\n            throw new CoreAjaxError({\n              message,\n              supportConfig: yield CoreUserGuestSupportConfig.forSite(preSets.siteUrl),\n              errorcode: 'invalidresponse',\n              errorDetails: Translate.instant('core.serverconnection', {\n                details: Translate.instant('core.errorinvalidresponse', {\n                  method\n                })\n              })\n            });\n          } else if (data.error) {\n            throw new CoreAjaxWSError(data);\n          }\n          // Get the first response since only one request was done.\n          data = data[0];\n          if (data.error) {\n            throw new CoreAjaxWSError(data.exception);\n          }\n          return data.data;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }(), /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (data) {\n          var _CoreSites$getCurrent2, _CoreTextUtils$getErr, _CoreTextUtils$getErr2, _CoreTextUtils$getErr3, _CoreTextUtils$getErr4, _CoreTextUtils$getErr5, _CoreTextUtils$getErr6, _CoreTextUtils$getErr7;\n          const message = CoreSites.isLoggedIn() ? Translate.instant('core.siteunavailablehelp', {\n            site: (_CoreSites$getCurrent2 = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent2 === void 0 ? void 0 : _CoreSites$getCurrent2.siteUrl\n          }) : Translate.instant('core.sitenotfoundhelp');\n          const options = {\n            message,\n            supportConfig: yield CoreUserGuestSupportConfig.forSite(preSets.siteUrl)\n          };\n          if (CorePlatform.isMobile()) {\n            switch (data.status) {\n              case NativeHttp.ErrorCode.SSL_EXCEPTION:\n                options.errorcode = 'invalidcertificate';\n                options.errorDetails = Translate.instant('core.certificaterror', {\n                  details: (_CoreTextUtils$getErr = CoreTextUtils.getErrorMessageFromError(data.error)) !== null && _CoreTextUtils$getErr !== void 0 ? _CoreTextUtils$getErr : 'Invalid certificate'\n                });\n                break;\n              case NativeHttp.ErrorCode.SERVER_NOT_FOUND:\n                options.errorcode = 'servernotfound';\n                options.errorDetails = (_CoreTextUtils$getErr2 = CoreTextUtils.getErrorMessageFromError(data.error)) !== null && _CoreTextUtils$getErr2 !== void 0 ? _CoreTextUtils$getErr2 : 'Server could not be found';\n                break;\n              case NativeHttp.ErrorCode.TIMEOUT:\n                options.errorcode = 'requesttimeout';\n                options.errorDetails = (_CoreTextUtils$getErr3 = CoreTextUtils.getErrorMessageFromError(data.error)) !== null && _CoreTextUtils$getErr3 !== void 0 ? _CoreTextUtils$getErr3 : 'Request timed out';\n                break;\n              case NativeHttp.ErrorCode.UNSUPPORTED_URL:\n                options.errorcode = 'unsupportedurl';\n                options.errorDetails = (_CoreTextUtils$getErr4 = CoreTextUtils.getErrorMessageFromError(data.error)) !== null && _CoreTextUtils$getErr4 !== void 0 ? _CoreTextUtils$getErr4 : 'Url not supported';\n                break;\n              case NativeHttp.ErrorCode.NOT_CONNECTED:\n                options.errorcode = 'connectionerror';\n                options.errorDetails = (_CoreTextUtils$getErr5 = CoreTextUtils.getErrorMessageFromError(data.error)) !== null && _CoreTextUtils$getErr5 !== void 0 ? _CoreTextUtils$getErr5 : 'Connection error, is network available?';\n                break;\n              case NativeHttp.ErrorCode.ABORTED:\n                options.errorcode = 'requestaborted';\n                options.errorDetails = (_CoreTextUtils$getErr6 = CoreTextUtils.getErrorMessageFromError(data.error)) !== null && _CoreTextUtils$getErr6 !== void 0 ? _CoreTextUtils$getErr6 : 'Request aborted';\n                break;\n              case NativeHttp.ErrorCode.POST_PROCESSING_FAILED:\n                options.errorcode = 'requestprocessingfailed';\n                options.errorDetails = (_CoreTextUtils$getErr7 = CoreTextUtils.getErrorMessageFromError(data.error)) !== null && _CoreTextUtils$getErr7 !== void 0 ? _CoreTextUtils$getErr7 : 'Request processing failed';\n                break;\n            }\n          }\n          if (!options.errorcode) {\n            switch (data.status) {\n              case 404:\n                options.errorcode = 'endpointnotfound';\n                options.errorDetails = Translate.instant('core.ajaxendpointnotfound', {\n                  $a: CoreSite.MINIMUM_MOODLE_VERSION\n                });\n                break;\n              default:\n                {\n                  var _CoreTextUtils$getErr8;\n                  const details = (_CoreTextUtils$getErr8 = CoreTextUtils.getErrorMessageFromError(data.error)) !== null && _CoreTextUtils$getErr8 !== void 0 ? _CoreTextUtils$getErr8 : 'Unknown error';\n                  options.errorcode = 'serverconnectionajax';\n                  options.errorDetails = Translate.instant('core.serverconnection', {\n                    details: `[Response status code: ${data.status}] ${details}`\n                  });\n                }\n                break;\n            }\n          }\n          throw new CoreAjaxError(options, 1, data.status);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()).catch(error => {\n        const type = `CoreAjaxError - ${error.errorcode}`;\n        CoreErrorLogs.addErrorLog({\n          method,\n          type,\n          message: error,\n          time: new Date().getTime(),\n          data\n        });\n        throw error;\n      });\n    })();\n  }\n  /**\n   * Perform a HEAD request and save the promise while waiting to be resolved.\n   *\n   * @param url URL to perform the request.\n   * @returns Promise resolved with the response.\n   */\n  performHead(url) {\n    let promise = this.getPromiseHttp('head', url);\n    if (!promise) {\n      promise = this.sendHTTPRequest(url, {\n        method: 'head',\n        responseType: 'text'\n      });\n      promise = this.setPromiseHttp(promise, 'head', url);\n    }\n    return promise;\n  }\n  /**\n   * Perform the post call. It can be split into several requests.\n   *\n   * @param method The WebService method to be called.\n   * @param siteUrl Complete site url to perform the call.\n   * @param ajaxData Arguments to pass to the method.\n   * @param preSets Extra settings and information.\n   * @returns Promise resolved with the response data in success and rejected with CoreWSError if it fails.\n   */\n  performPost(method, siteUrl, ajaxData, preSets) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const options = {};\n      // This is done because some returned values like 0 are treated as null if responseType is json.\n      if (preSets.typeExpected == 'number' || preSets.typeExpected == 'boolean' || preSets.typeExpected == 'string') {\n        options.responseType = 'text';\n      }\n      if (!preSets.splitRequest || !ajaxData[preSets.splitRequest.param]) {\n        return _this4.performSinglePost(method, siteUrl, ajaxData, preSets, options);\n      }\n      // Split the request into several requests if needed.\n      const promises = [];\n      const splitParam = ajaxData[preSets.splitRequest.param];\n      for (let i = 0; i < splitParam.length; i += preSets.splitRequest.maxLength) {\n        // Limit the array sent.\n        const limitedData = Object.assign({}, ajaxData);\n        limitedData[preSets.splitRequest.param] = splitParam.slice(i, i + preSets.splitRequest.maxLength);\n        promises.push(_this4.performSinglePost(method, siteUrl, limitedData, preSets, options));\n      }\n      const results = yield Promise.all(promises);\n      // Combine the results.\n      const firstResult = results.shift();\n      if (preSets.splitRequest.combineCallback) {\n        return results.reduce(preSets.splitRequest.combineCallback, firstResult);\n      }\n      return results.reduce((previous, current) => _this4.combineObjectsArrays(previous, current), firstResult);\n    })();\n  }\n  /**\n   * Combine the arrays of two objects, adding them to the first object.\n   *\n   * @param object1 First object.\n   * @param object2 Second object.\n   * @returns First object with items added.\n   */\n  combineObjectsArrays(object1, object2) {\n    for (const name in object2) {\n      const value = object2[name];\n      if (Array.isArray(value)) {\n        object1[name] = object1[name].concat(value);\n      }\n    }\n    return object1;\n  }\n  /**\n   * Perform a single post request.\n   *\n   * @param method The WebService method to be called.\n   * @param siteUrl Complete site url to perform the call.\n   * @param ajaxData Arguments to pass to the method.\n   * @param preSets Extra settings and information.\n   * @param options Request options.\n   * @returns Promise resolved with the response data in success and rejected with CoreWSError if it fails.\n   */\n  performSinglePost(method, siteUrl, ajaxData, preSets, options) {\n    var _this5 = this;\n    // We add the method name to the URL purely to help with debugging.\n    // This duplicates what is in the ajaxData, but that does no harm.\n    // POST variables take precedence over GET.\n    const requestUrl = siteUrl + '&wsfunction=' + method;\n    // Perform the post request.\n    const promise = firstValueFrom(Http.post(requestUrl, ajaxData, options).pipe(timeout(this.getRequestTimeout())));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return promise.then( /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (data) {\n        // Some moodle web services always return null, and some others can return a primitive type or null.\n        if (data === null && (!preSets.responseExpected || preSets.typeExpected !== 'object')) {\n          return null;\n        }\n        const typeExpected = preSets.typeExpected === 'jsonstring' ? 'string' : preSets.typeExpected;\n        if (!data) {\n          throw yield _this5.createCannotConnectSiteError(preSets.siteUrl, {\n            errorcode: 'serverconnectionpost',\n            errorDetails: Translate.instant('core.serverconnection', {\n              details: Translate.instant('core.errorinvalidresponse', {\n                method\n              })\n            })\n          });\n        } else if (typeof data !== typeExpected) {\n          // If responseType is text an string will be returned, parse before returning.\n          if (typeof data == 'string') {\n            if (typeExpected === 'number') {\n              data = Number(data);\n              if (isNaN(data)) {\n                _this5.logger.warn(`Response expected type \"${typeExpected}\" cannot be parsed to number`);\n                throw yield _this5.createCannotConnectSiteError(preSets.siteUrl, {\n                  errorcode: 'invalidresponse',\n                  errorDetails: Translate.instant('core.errorinvalidresponse', {\n                    method\n                  })\n                });\n              }\n            } else if (typeExpected === 'boolean') {\n              if (data === 'true') {\n                data = true;\n              } else if (data === 'false') {\n                data = false;\n              } else {\n                _this5.logger.warn(`Response expected type \"${typeExpected}\" is not true or false`);\n                throw yield _this5.createCannotConnectSiteError(preSets.siteUrl, {\n                  errorcode: 'invalidresponse',\n                  errorDetails: Translate.instant('core.errorinvalidresponse', {\n                    method\n                  })\n                });\n              }\n            } else {\n              _this5.logger.warn('Response of type \"' + typeof data + `\" received, expecting \"${typeExpected}\"`);\n              throw yield _this5.createCannotConnectSiteError(preSets.siteUrl, {\n                errorcode: 'invalidresponse',\n                errorDetails: Translate.instant('core.errorinvalidresponse', {\n                  method\n                })\n              });\n            }\n          } else {\n            _this5.logger.warn('Response of type \"' + typeof data + `\" received, expecting \"${typeExpected}\"`);\n            throw yield _this5.createCannotConnectSiteError(preSets.siteUrl, {\n              errorcode: 'invalidresponse',\n              errorDetails: Translate.instant('core.errorinvalidresponse', {\n                method\n              })\n            });\n          }\n        }\n        if (data.exception !== undefined) {\n          // Special debugging for site plugins, otherwise it's hard to debug errors if the data is cached.\n          if (method == 'tool_mobile_get_content') {\n            _this5.logger.error('Error calling WS', method, data);\n          }\n          throw new CoreWSError(data);\n        }\n        if (data.debuginfo !== undefined) {\n          throw new CoreError('Error. ' + data.message);\n        }\n        return data;\n      });\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }(), /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (error) {\n        var _CoreTextUtils$getErr10;\n        // If server has heavy load, retry after some seconds.\n        if (error.status == 429) {\n          const retryPromise = _this5.addToRetryQueue(method, siteUrl, ajaxData, preSets);\n          // Only process the queue one time.\n          if (_this5.retryTimeout == 0) {\n            _this5.retryTimeout = parseInt(error.headers.get('Retry-After'), 10) || 5;\n            _this5.logger.warn(`${error.statusText}. Retrying in ${_this5.retryTimeout} seconds. ` + `${_this5.retryCalls.length} calls left.`);\n            setTimeout(() => {\n              _this5.logger.warn(`Retrying now with ${_this5.retryCalls.length} calls to process.`);\n              // Finish timeout.\n              _this5.retryTimeout = 0;\n              _this5.processRetryQueue();\n            }, _this5.retryTimeout * 1000);\n          } else {\n            _this5.logger.warn('Calls locked, trying later...');\n          }\n          return retryPromise;\n        } else if (error.status === -2) {\n          var _CoreTextUtils$getErr9;\n          throw yield _this5.createCannotConnectSiteError(preSets.siteUrl, {\n            errorcode: 'invalidcertificate',\n            errorDetails: Translate.instant('core.certificaterror', {\n              details: (_CoreTextUtils$getErr9 = CoreTextUtils.getErrorMessageFromError(error)) !== null && _CoreTextUtils$getErr9 !== void 0 ? _CoreTextUtils$getErr9 : 'Unknown error'\n            })\n          });\n        } else if (error.status > 0) {\n          throw _this5.createHttpError(error, error.status);\n        }\n        throw new CoreError(Translate.instant('core.serverconnection', {\n          details: (_CoreTextUtils$getErr10 = CoreTextUtils.getErrorMessageFromError(error)) !== null && _CoreTextUtils$getErr10 !== void 0 ? _CoreTextUtils$getErr10 : 'Unknown error'\n        }));\n      });\n      return function (_x4) {\n        return _ref4.apply(this, arguments);\n      };\n    }()).catch(err => {\n      CoreErrorLogs.addErrorLog({\n        method,\n        type: String(err),\n        message: String(err.exception),\n        time: new Date().getTime(),\n        data: ajaxData\n      });\n      throw err;\n    });\n  }\n  /**\n   * Retry all requests in the queue.\n   * This function uses recursion in order to add a delay between requests to reduce stress.\n   */\n  processRetryQueue() {\n    if (this.retryCalls.length > 0 && this.retryTimeout == 0) {\n      const call = this.retryCalls[0];\n      this.retryCalls.shift();\n      // Add a delay between calls.\n      setTimeout(() => {\n        call.deferred.resolve(this.performPost(call.method, call.siteUrl, call.data, call.preSets));\n        this.processRetryQueue();\n      }, 200);\n    } else {\n      this.logger.warn(`Retry queue has stopped with ${this.retryCalls.length} calls and ${this.retryTimeout} timeout secs.`);\n    }\n  }\n  /**\n   * Save promise on the cache.\n   *\n   * @param promise Promise to be saved.\n   * @param method Method of the HTTP request.\n   * @param url Base URL of the HTTP request.\n   * @param params Params of the HTTP request.\n   * @returns The promise saved.\n   */\n  setPromiseHttp(promise, method, url, params) {\n    const queueItemId = this.getQueueItemId(method, url, params);\n    this.ongoingCalls[queueItemId] = promise;\n    // HTTP not finished, but we should delete the promise after timeout.\n    const timeout = setTimeout(() => {\n      delete this.ongoingCalls[queueItemId];\n    }, this.getRequestTimeout());\n    // HTTP finished, delete from ongoing.\n    return promise.finally(() => {\n      delete this.ongoingCalls[queueItemId];\n      clearTimeout(timeout);\n    });\n  }\n  /**\n   * A wrapper function for a synchronous Moodle WebService call.\n   * Warning: This function should only be used if synchronous is a must. It's recommended to use call.\n   *\n   * @param method The WebService method to be called.\n   * @param data Arguments to pass to the method.\n   * @param preSets Extra settings and information.\n   * @returns Promise resolved with the response data in success and rejected with the error message if it fails.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  syncCall(method, data, preSets) {\n    try {\n      if (!preSets) {\n        throw new CoreError(Translate.instant('core.unexpectederror'));\n      } else if (!CoreNetwork.isOnline()) {\n        throw new CoreNetworkError();\n      }\n      preSets.typeExpected = preSets.typeExpected || 'object';\n      if (preSets.responseExpected === undefined) {\n        preSets.responseExpected = true;\n      }\n      data = this.convertValuesToString(data || {}, preSets.cleanUnicode);\n      if (data == null) {\n        // Empty cleaned text found.\n        throw new CoreError(Translate.instant('core.unicodenotsupportedcleanerror'));\n      }\n      data.wsfunction = method;\n      data.wstoken = preSets.wsToken;\n      const siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';\n      // Serialize data.\n      data = CoreInterceptor.serialize(data);\n      // Perform sync request using XMLHttpRequest.\n      const xhr = new XMLHttpRequest();\n      xhr.open('post', siteUrl, false);\n      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');\n      xhr.send(data);\n      // Get response.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      data = 'response' in xhr ? xhr.response : xhr.responseText;\n      // Check status.\n      const status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);\n      if (status < 200 || status >= 300) {\n        // Request failed.\n        throw new CoreError(data);\n      }\n      // Treat response.\n      data = CoreTextUtils.parseJSON(data);\n      // Some moodle web services return null.\n      // If the responseExpected value is set then so long as no data is returned, we create a blank object.\n      if ((!data || !data.data) && !preSets.responseExpected) {\n        data = {};\n      }\n      if (!data) {\n        throw new CoreError(Translate.instant('core.serverconnection', {\n          details: Translate.instant('core.errorinvalidresponse', {\n            method\n          })\n        }));\n      } else if (typeof data != preSets.typeExpected) {\n        this.logger.warn('Response of type \"' + typeof data + '\" received, expecting \"' + preSets.typeExpected + '\"');\n        throw new CoreError(Translate.instant('core.errorinvalidresponse', {\n          method\n        }));\n      }\n      if (data.exception !== undefined || data.debuginfo !== undefined) {\n        throw new CoreWSError(data);\n      }\n      return data;\n    } catch (err) {\n      let errorType = '';\n      if (err instanceof CoreError) {\n        errorType = 'CoreError';\n      } else if (err instanceof CoreWSError) {\n        errorType = 'CoreWSError';\n      }\n      CoreErrorLogs.addErrorLog({\n        method,\n        type: errorType,\n        message: String(err),\n        time: new Date().getTime(),\n        data\n      });\n      throw err;\n    }\n  }\n  /*\n   * Uploads a file.\n   *\n   * @param filePath File path.\n   * @param options File upload options.\n   * @param preSets Must contain siteUrl and wsToken.\n   * @param onProgress Function to call on progress.\n   * @returns Promise resolved when uploaded.\n   */\n  uploadFile(filePath, options, preSets, onProgress) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      _this6.logger.debug(`Trying to upload file: ${filePath}`);\n      if (!filePath || !options || !preSets) {\n        throw new CoreError('Invalid options passed to upload file.');\n      }\n      if (!CoreNetwork.isOnline()) {\n        throw new CoreNetworkError();\n      }\n      const uploadUrl = preSets.siteUrl + '/webservice/upload.php';\n      const transfer = FileTransfer.create();\n      onProgress && transfer.onProgress(onProgress);\n      options.httpMethod = 'POST';\n      options.params = {\n        token: preSets.wsToken,\n        filearea: options.fileArea || 'draft',\n        itemid: options.itemId || 0\n      };\n      options.chunkedMode = false;\n      options.headers = {\n        'User-Agent': navigator.userAgent\n      };\n      options['Connection'] = 'close';\n      let success;\n      try {\n        success = yield transfer.upload(filePath, uploadUrl, options, true);\n      } catch (error) {\n        var _error$http_status;\n        _this6.logger.error('Error while uploading file', filePath, error);\n        throw _this6.createHttpError(error, (_error$http_status = error.http_status) !== null && _error$http_status !== void 0 ? _error$http_status : 0);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const data = CoreTextUtils.parseJSON(success.response, null, error => _this6.logger.error('Error parsing response from upload', success.response, error));\n      if (data === null) {\n        throw yield _this6.createCannotConnectSiteError(preSets.siteUrl, {\n          errorcode: 'invalidresponse',\n          errorDetails: Translate.instant('core.errorinvalidresponse', {\n            method: 'upload.php'\n          })\n        });\n      }\n      if (!data) {\n        throw yield _this6.createCannotConnectSiteError(preSets.siteUrl, {\n          errorcode: 'serverconnectionupload',\n          errorDetails: Translate.instant('core.serverconnection', {\n            details: Translate.instant('core.errorinvalidresponse', {\n              method: 'upload.php'\n            })\n          })\n        });\n      } else if (typeof data != 'object') {\n        _this6.logger.warn('Upload file: Response of type \"' + typeof data + '\" received, expecting \"object\"');\n        throw yield _this6.createCannotConnectSiteError(preSets.siteUrl, {\n          errorcode: 'invalidresponse',\n          errorDetails: Translate.instant('core.errorinvalidresponse', {\n            method: 'upload.php'\n          })\n        });\n      }\n      if (data.exception !== undefined) {\n        throw new CoreWSError(data);\n      } else if (data.error !== undefined) {\n        throw new CoreWSError({\n          errorcode: data.errortype,\n          message: data.error\n        });\n      } else if (data[0] && data[0].error !== undefined) {\n        throw new CoreWSError({\n          errorcode: data[0].errortype,\n          message: data[0].error\n        });\n      }\n      // We uploaded only 1 file, so we only return the first file returned.\n      _this6.logger.debug('Successfully uploaded file', filePath);\n      return data[0];\n    })();\n  }\n  /**\n   * Create a CoreHttpError based on a certain error.\n   *\n   * @param error Original error.\n   * @param status Status code (if any).\n   * @returns CoreHttpError.\n   */\n  createHttpError(error, status) {\n    var _CoreSites$getCurrent3;\n    const message = CoreTextUtils.buildSeveralParagraphsMessage([CoreSites.isLoggedIn() ? Translate.instant('core.siteunavailablehelp', {\n      site: (_CoreSites$getCurrent3 = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent3 === void 0 ? void 0 : _CoreSites$getCurrent3.siteUrl\n    }) : Translate.instant('core.sitenotfoundhelp'), CoreTextUtils.getHTMLBodyContent(CoreTextUtils.getErrorMessageFromError(error) || '')]);\n    return new CoreHttpError(message, status);\n  }\n  /**\n   * Perform an HTTP request requesting for a text response.\n   *\n   * @param url Url to get.\n   * @returns Resolved with the text when done.\n   */\n  getText(url) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      // Fetch the URL content.\n      const options = {\n        method: 'get',\n        responseType: 'text'\n      };\n      const response = yield _this7.sendHTTPRequest(url, options);\n      const content = response.body;\n      if (typeof content !== 'string') {\n        throw new Error('Error reading content');\n      }\n      return content;\n    })();\n  }\n  /**\n   * Send an HTTP request. In mobile devices it will use the cordova plugin.\n   *\n   * @param url URL of the request.\n   * @param options Options for the request.\n   * @returns Promise resolved with the response.\n   */\n  sendHTTPRequest(url, options) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // Set default values.\n      options.responseType = options.responseType || 'json';\n      options.timeout = options.timeout === undefined ? _this8.getRequestTimeout() : options.timeout;\n      if (CorePlatform.isMobile()) {\n        // Use the cordova plugin.\n        if (url.indexOf('file://') === 0) {\n          // We cannot load local files using the http native plugin. Use file provider instead.\n          const content = options.responseType == 'json' ? yield CoreFile.readFile(url, 4 /* CoreFileFormat.FORMATJSON */) : yield CoreFile.readFile(url, 0 /* CoreFileFormat.FORMATTEXT */);\n          return new HttpResponse({\n            body: content,\n            headers: undefined,\n            status: 200,\n            statusText: 'OK',\n            url\n          });\n        }\n        return NativeHttp.sendRequest(url, options).then(response => new CoreNativeToAngularHttpResponse(response));\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let observable;\n        const angularOptions = options;\n        // Use Angular's library.\n        switch (angularOptions.method) {\n          case 'get':\n            observable = Http.get(url, {\n              headers: angularOptions.headers,\n              params: angularOptions.params,\n              observe: 'response',\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              responseType: angularOptions.responseType\n            });\n            break;\n          case 'post':\n            if (angularOptions.serializer == 'json') {\n              angularOptions.data = JSON.stringify(angularOptions.data);\n            }\n            observable = Http.post(url, angularOptions.data, {\n              headers: angularOptions.headers,\n              observe: 'response',\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              responseType: angularOptions.responseType\n            });\n            break;\n          case 'head':\n            observable = Http.head(url, {\n              headers: angularOptions.headers,\n              observe: 'response',\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              responseType: angularOptions.responseType\n            });\n            break;\n          default:\n            throw new CoreError('Method not implemented yet.');\n        }\n        if (angularOptions.timeout) {\n          observable = observable.pipe(timeout(angularOptions.timeout));\n        }\n        return firstValueFrom(observable);\n      }\n    })();\n  }\n  /**\n   * Check if a URL works (it returns a 2XX status).\n   *\n   * @param url URL to check.\n   * @returns Promise resolved with boolean: whether it works.\n   */\n  urlWorks(url) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const result = yield _this9.performHead(url);\n        return result.status >= 200 && result.status < 300;\n      } catch (error) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Create an error to be thrown when it isn't possible to connect to a site.\n   *\n   * @param siteUrl Site url.\n   * @param options Error options.\n   * @returns Cannot connect error.\n   */\n  createCannotConnectSiteError(siteUrl, options) {\n    return _asyncToGenerator(function* () {\n      var _CoreSites$getCurrent4;\n      return new CoreSiteError(_objectSpread(_objectSpread({}, options), {}, {\n        supportConfig: yield CoreUserGuestSupportConfig.forSite(siteUrl),\n        message: CoreSites.isLoggedIn() ? Translate.instant('core.siteunavailablehelp', {\n          site: (_CoreSites$getCurrent4 = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent4 === void 0 ? void 0 : _CoreSites$getCurrent4.siteUrl\n        }) : Translate.instant('core.sitenotfoundhelp')\n      }));\n    })();\n  }\n}\n_class = CoreWSProvider;\n_class.ɵfac = function CoreWSProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreWS = makeSingleton(CoreWSProvider);","map":{"version":3,"names":["HttpResponse","FileUploadOptions","Md5","firstValueFrom","timeout","CoreNativeToAngularHttpResponse","CoreNetwork","CoreFile","CoreMimetypeUtils","CoreTextUtils","CoreConstants","CoreError","CoreInterceptor","makeSingleton","Translate","FileTransfer","Http","NativeHttp","CoreLogger","CoreWSError","CoreAjaxError","CoreAjaxWSError","CoreNetworkError","CoreSite","CoreHttpError","CorePromisedValue","CorePlatform","CoreSiteError","CoreUserGuestSupportConfig","CoreSites","CoreLang","CoreErrorLogs","CoreWSProvider","constructor","mimeTypeCache","ongoingCalls","retryCalls","retryTimeout","logger","getInstance","addToRetryQueue","method","siteUrl","data","preSets","call","deferred","push","instant","isOnline","typeExpected","responseExpected","undefined","dataToSend","Object","assign","wsToken","length","warn","performPost","callAjax","cacheParams","methodname","args","promise","getPromiseHttp","performAjax","setPromiseHttp","convertValuesToString","stripUnicode","result","Array","isArray","key","value","stripped","trim","String","throwOnFailedStatus","response","defaultMessage","status","warnings","downloadFile","url","path","addExtension","onProgress","_this","_asyncToGenerator","debug","tmpPath","fileEntry","createFile","transfer","create","download","toURL","headers","navigator","userAgent","extension","getFileExtension","includes","mimetype","getRemoteFileMimeType","remoteExtension","getExtension","removeExtension","movedEntry","moveFile","error","params","queueItemId","getQueueItemId","ignoreCache","_this2","cachedMimeType","performHead","mimeType","get","split","getRemoteFileSize","then","contentLength","size","parseInt","catch","getRequestTimeout","isNetworkAccessLimited","WS_TIMEOUT","WS_TIMEOUT_WIFI","serialize","hashAsciiStr","_this3","unexpectedError","addErrorLog","type","message","time","Date","getTime","networkError","script","noLogin","ajaxData","index","lang","getCurrentLanguage","useGet","encodeURIComponent","JSON","stringify","sendHTTPRequest","serializer","_ref","body","_CoreSites$getCurrent","isLoggedIn","site","getCurrentSite","supportConfig","forSite","errorcode","errorDetails","details","exception","_x","apply","arguments","_ref2","_CoreSites$getCurrent2","_CoreTextUtils$getErr","_CoreTextUtils$getErr2","_CoreTextUtils$getErr3","_CoreTextUtils$getErr4","_CoreTextUtils$getErr5","_CoreTextUtils$getErr6","_CoreTextUtils$getErr7","options","isMobile","ErrorCode","SSL_EXCEPTION","getErrorMessageFromError","SERVER_NOT_FOUND","TIMEOUT","UNSUPPORTED_URL","NOT_CONNECTED","ABORTED","POST_PROCESSING_FAILED","$a","MINIMUM_MOODLE_VERSION","_CoreTextUtils$getErr8","_x2","responseType","_this4","splitRequest","param","performSinglePost","promises","splitParam","i","maxLength","limitedData","slice","results","Promise","all","firstResult","shift","combineCallback","reduce","previous","current","combineObjectsArrays","object1","object2","name","concat","_this5","requestUrl","post","pipe","_ref3","createCannotConnectSiteError","Number","isNaN","debuginfo","_x3","_ref4","_CoreTextUtils$getErr10","retryPromise","statusText","setTimeout","processRetryQueue","_CoreTextUtils$getErr9","createHttpError","_x4","err","resolve","finally","clearTimeout","syncCall","cleanUnicode","wsfunction","wstoken","xhr","XMLHttpRequest","open","setRequestHeader","send","responseText","Math","max","parseJSON","errorType","uploadFile","filePath","_this6","uploadUrl","httpMethod","token","filearea","fileArea","itemid","itemId","chunkedMode","success","upload","_error$http_status","http_status","errortype","_CoreSites$getCurrent3","buildSeveralParagraphsMessage","getHTMLBodyContent","getText","_this7","content","Error","_this8","indexOf","readFile","sendRequest","observable","angularOptions","observe","head","urlWorks","_this9","_CoreSites$getCurrent4","_objectSpread","factory","ɵfac","providedIn","CoreWS"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/ws.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { HttpResponse, HttpParams, HttpErrorResponse } from '@angular/common/http';\n\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\nimport { FileUploadOptions, FileUploadResult } from '@awesome-cordova-plugins/file-transfer/ngx';\nimport { Md5 } from 'ts-md5/dist/md5';\nimport { Observable, firstValueFrom } from 'rxjs';\nimport { timeout } from 'rxjs/operators';\n\nimport { CoreNativeToAngularHttpResponse } from '@classes/native-to-angular-http';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile, CoreFileFormat } from '@services/file';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextErrorObject, CoreTextUtils } from '@services/utils/text';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreInterceptor } from '@classes/interceptor';\nimport { makeSingleton, Translate, FileTransfer, Http, NativeHttp } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreAjaxError } from '@classes/errors/ajaxerror';\nimport { CoreAjaxWSError } from '@classes/errors/ajaxwserror';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreHttpError } from '@classes/errors/httperror';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { CoreSiteError, CoreSiteErrorOptions } from '@classes/errors/siteerror';\nimport { CoreUserGuestSupportConfig } from '@features/user/classes/support/guest-support-config';\nimport { CoreSites } from '@services/sites';\nimport { CoreLang, CoreLangFormat } from './lang';\nimport { CoreErrorLogs } from '@singletons/error-logs';\n\n/**\n * This service allows performing WS calls and download/upload files.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreWSProvider {\n\n    protected logger: CoreLogger;\n    protected mimeTypeCache: {[url: string]: string | null} = {}; // A \"cache\" to store file mimetypes to decrease HEAD requests.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected ongoingCalls: {[queueItemId: string]: Promise<any>} = {};\n    protected retryCalls: RetryCall[] = [];\n    protected retryTimeout = 0;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreWSProvider');\n    }\n\n    /**\n     * Adds the call data to an special queue to be processed when retrying.\n     *\n     * @param method The WebService method to be called.\n     * @param siteUrl Complete site url to perform the call.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra settings and information.\n     * @returns Deferred promise resolved with the response data in success and rejected with the error if it fails.\n     */\n    protected addToRetryQueue<T = unknown>(\n        method: string,\n        siteUrl: string,\n        data: Record<string, unknown>,\n        preSets: CoreWSPreSets,\n    ): Promise<T> {\n        const call = {\n            method,\n            siteUrl,\n            data,\n            preSets,\n            deferred: new CorePromisedValue<T>(),\n        };\n\n        this.retryCalls.push(call);\n\n        return call.deferred;\n    }\n\n    /**\n     * A wrapper function for a moodle WebService call.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method. It's recommended to call convertValuesToString before passing the data.\n     * @param preSets Extra settings and information.\n     * @returns Promise resolved with the response data in success and rejected if it fails.\n     */\n    call<T = unknown>(method: string, data: Record<string, unknown>, preSets: CoreWSPreSets): Promise<T> {\n        if (!preSets) {\n            throw new CoreError(Translate.instant('core.unexpectederror'));\n        } else if (!CoreNetwork.isOnline()) {\n            throw new CoreNetworkError();\n        }\n\n        preSets.typeExpected = preSets.typeExpected || 'object';\n        if (preSets.responseExpected === undefined) {\n            preSets.responseExpected = true;\n        }\n\n        const dataToSend = Object.assign({}, data); // Create a new object so the changes don't affect the original data.\n        dataToSend['wsfunction'] = method;\n        dataToSend['wstoken'] = preSets.wsToken;\n        const siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';\n\n        // There are some ongoing retry calls, wait for timeout.\n        if (this.retryCalls.length > 0) {\n            this.logger.warn('Calls locked, trying later...');\n\n            return this.addToRetryQueue<T>(method, siteUrl, dataToSend, preSets);\n        } else {\n            return this.performPost<T>(method, siteUrl, dataToSend, preSets);\n        }\n    }\n\n    /**\n     * Call a Moodle WS using the AJAX API. Please use it if the WS layer is not an option.\n     * It uses a cache to prevent duplicate requests.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra settings and information. Only some\n     * @returns Promise resolved with the response data in success and rejected with CoreAjaxError.\n     */\n    callAjax<T = unknown>(method: string, data: Record<string, unknown>, preSets: CoreWSAjaxPreSets): Promise<T> {\n        const cacheParams = {\n            methodname: method,\n            args: data,\n        };\n\n        let promise = this.getPromiseHttp<T>('ajax', preSets.siteUrl, cacheParams);\n\n        if (!promise) {\n            promise = this.performAjax<T>(method, data, preSets);\n            promise = this.setPromiseHttp<T>(promise, 'ajax', preSets.siteUrl, cacheParams);\n        }\n\n        return promise;\n    }\n\n    /**\n     * Converts an objects values to strings where appropriate.\n     * Arrays (associative or otherwise) will be maintained, null values will be removed.\n     *\n     * @param data The data that needs all the non-object values set to strings.\n     * @param stripUnicode If Unicode long chars need to be stripped.\n     * @returns The cleaned object or null if some strings becomes empty after stripping Unicode.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    convertValuesToString(data: any, stripUnicode?: boolean): any {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const result: any = Array.isArray(data) ? [] : {};\n\n        for (const key in data) {\n            let value = data[key];\n\n            if (value == null) {\n                // Skip null or undefined value.\n                continue;\n            } else if (typeof value == 'object') {\n                // Object or array.\n                value = this.convertValuesToString(value, stripUnicode);\n                if (value == null) {\n                    return null;\n                }\n            } else if (typeof value == 'string') {\n                if (stripUnicode) {\n                    const stripped = CoreTextUtils.stripUnicode(value);\n                    if (stripped != value && stripped.trim().length == 0) {\n                        return null;\n                    }\n                    value = stripped;\n                }\n            } else if (typeof value == 'boolean') {\n                /* Moodle does not allow \"true\" or \"false\" in WS parameters, only in POST parameters.\n                   We've been using \"true\" and \"false\" for WS settings \"filter\" and \"fileurl\",\n                   we keep it this way to avoid changing cache keys. */\n                if (key == 'moodlewssettingfilter' || key == 'moodlewssettingfileurl') {\n                    value = value ? 'true' : 'false';\n                } else {\n                    value = value ? '1' : '0';\n                }\n            } else if (typeof value == 'number') {\n                value = String(value);\n            } else {\n                // Unknown type.\n                continue;\n            }\n\n            if (Array.isArray(result)) {\n                result.push(value);\n            } else {\n                result[key] = value;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * It will check if response has failed and throw the propper error.\n     *\n     * @param response WS response.\n     * @param defaultMessage Message to be used in case warnings is empty.\n     */\n    throwOnFailedStatus(response: CoreStatusWithWarningsWSResponse, defaultMessage: string): void {\n        if (!response.status) {\n            if (response.warnings && response.warnings.length) {\n                throw new CoreWSError(response.warnings[0]);\n            }\n\n            throw new CoreError(defaultMessage);\n        }\n    }\n\n    /**\n     * Downloads a file from Moodle using Cordova File API.\n     *\n     * @param url Download url.\n     * @param path Local path to store the file.\n     * @param addExtension True if extension need to be added to the final path.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved with the downloaded file.\n     */\n    async downloadFile(\n        url: string,\n        path: string,\n        addExtension?: boolean,\n        onProgress?: (event: ProgressEvent) => void,\n    ): Promise<CoreWSDownloadedFileEntry> {\n        this.logger.debug('Downloading file', url, path, addExtension);\n\n        if (!CoreNetwork.isOnline()) {\n            throw new CoreNetworkError();\n        }\n\n        // Use a tmp path to download the file and then move it to final location.\n        // This is because if the download fails, the local file is deleted.\n        const tmpPath = path + '.tmp';\n\n        try {\n            // Create the tmp file as an empty file.\n            const fileEntry = await CoreFile.createFile(tmpPath);\n\n            const transfer = FileTransfer.create();\n            onProgress && transfer.onProgress(onProgress);\n\n            // Download the file in the tmp file.\n            await transfer.download(url, fileEntry.toURL(), true, {\n                headers: {\n                    'User-Agent': navigator.userAgent,\n                },\n            });\n\n            let extension = '';\n\n            if (addExtension) {\n                extension = CoreMimetypeUtils.getFileExtension(path) || '';\n\n                // Google Drive extensions will be considered invalid since Moodle usually converts them.\n                if (!extension || ['gdoc', 'gsheet', 'gslides', 'gdraw', 'php'].includes(extension)) {\n                    // Not valid, get the file's mimetype.\n                    const mimetype = await this.getRemoteFileMimeType(url);\n\n                    if (mimetype) {\n                        const remoteExtension = CoreMimetypeUtils.getExtension(mimetype, url);\n                        // If the file is from Google Drive, ignore mimetype application/json.\n                        if (remoteExtension && (!extension || mimetype != 'application/json')) {\n                            if (extension) {\n                                // Remove existing extension since we will use another one.\n                                path = CoreMimetypeUtils.removeExtension(path);\n                            }\n                            path += '.' + remoteExtension;\n\n                            extension = remoteExtension;\n                        }\n                    }\n                }\n            }\n\n            // Move the file to the final location.\n            const movedEntry = await CoreFile.moveFile(tmpPath, path);\n\n            this.logger.debug(`Success downloading file ${url} to ${path} with extension ${extension}`);\n\n            // Also return the extension and path.\n            return <CoreWSDownloadedFileEntry> Object.assign(movedEntry, {\n                extension: extension,\n                path: path,\n            });\n        } catch (error) {\n            this.logger.error(`Error downloading ${url} to ${path}`, error);\n\n            throw error;\n        }\n    }\n\n    /**\n     * Get a promise from the cache.\n     *\n     * @param method Method of the HTTP request.\n     * @param url Base URL of the HTTP request.\n     * @param params Params of the HTTP request.\n     * @returns the on going call if any.\n     */\n    protected getPromiseHttp<T = unknown>(method: string, url: string, params?: Record<string, unknown>): Promise<T> | undefined {\n        const queueItemId = this.getQueueItemId(method, url, params);\n        if (this.ongoingCalls[queueItemId] !== undefined) {\n            return this.ongoingCalls[queueItemId];\n        }\n    }\n\n    /**\n     * Perform a HEAD request to get the mimetype of a remote file.\n     *\n     * @param url File URL.\n     * @param ignoreCache True to ignore cache, false otherwise.\n     * @returns Promise resolved with the mimetype or '' if failure.\n     */\n    async getRemoteFileMimeType(url: string, ignoreCache?: boolean): Promise<string> {\n        const cachedMimeType = this.mimeTypeCache[url];\n        if (cachedMimeType && !ignoreCache) {\n            return cachedMimeType;\n        }\n\n        try {\n            const response = await this.performHead(url);\n\n            let mimeType = response.headers.get('Content-Type');\n            if (mimeType) {\n                // Remove \"parameters\" like charset.\n                mimeType = mimeType.split(';')[0];\n            }\n            this.mimeTypeCache[url] = mimeType;\n\n            return mimeType || '';\n        } catch (error) {\n            // Error, resolve with empty mimetype.\n            return '';\n        }\n    }\n\n    /**\n     * Perform a HEAD request to get the size of a remote file.\n     *\n     * @param url File URL.\n     * @returns Promise resolved with the size or -1 if failure.\n     */\n    getRemoteFileSize(url: string): Promise<number> {\n        return this.performHead(url).then((response) => {\n            const contentLength = response.headers.get('Content-Length');\n            const size = contentLength ? parseInt(contentLength, 10) : 0;\n\n            if (size) {\n                return size;\n            }\n\n            return -1;\n        }).catch(() => -1);\n    }\n\n    /**\n     * Get a request timeout based on the network connection.\n     *\n     * @returns Timeout in ms.\n     */\n    getRequestTimeout(): number {\n        return CoreNetwork.isNetworkAccessLimited() ? CoreConstants.WS_TIMEOUT : CoreConstants.WS_TIMEOUT_WIFI;\n    }\n\n    /**\n     * Get the unique queue item id of the cache for a HTTP request.\n     *\n     * @param method Method of the HTTP request.\n     * @param url Base URL of the HTTP request.\n     * @param params Params of the HTTP request.\n     * @returns Queue item ID.\n     */\n    protected getQueueItemId(method: string, url: string, params?: Record<string, unknown>): string {\n        if (params) {\n            url += '###' + CoreInterceptor.serialize(params);\n        }\n\n        return method + '#' + Md5.hashAsciiStr(url);\n    }\n\n    /**\n     * Call a Moodle WS using the AJAX API.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra settings and information. Only some\n     * @returns Promise resolved with the response data in success and rejected with CoreAjaxError.\n     */\n    protected async performAjax<T = unknown> (\n        method: string,\n        data: Record<string, unknown>,\n        preSets: CoreWSAjaxPreSets,\n    ): Promise<T> {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let promise: Promise<HttpResponse<any>>;\n\n        if (preSets.siteUrl === undefined) {\n            const unexpectedError = new CoreAjaxError(Translate.instant('core.unexpectederror'));\n            CoreErrorLogs.addErrorLog({\n                method,\n                type: 'CoreAjaxError',\n                message: Translate.instant('core.unexpectederror'),\n                time: new Date().getTime(),\n                data,\n            });\n            throw unexpectedError;\n        } else if (!CoreNetwork.isOnline()) {\n            const networkError = new CoreAjaxError(Translate.instant('core.networkerrormsg'));\n            CoreErrorLogs.addErrorLog({\n                method,\n                type: 'CoreAjaxError',\n                message: Translate.instant('core.networkerrormsg'),\n                time: new Date().getTime(),\n                data,\n            });\n            throw networkError;\n        }\n\n        if (preSets.responseExpected === undefined) {\n            preSets.responseExpected = true;\n        }\n\n        const script = preSets.noLogin ? 'service-nologin.php' : 'service.php';\n        const ajaxData = [{\n            index: 0,\n            methodname: method,\n            args: this.convertValuesToString(data),\n        }];\n\n        const lang = await CoreLang.getCurrentLanguage(CoreLangFormat.LMS);\n\n        // The info= parameter has no function. It is just to help with debugging.\n        // We call it info to match the parameter name use by Moodle's AMD ajax module.\n        let siteUrl = preSets.siteUrl + '/lib/ajax/' + script + '?info=' + method + `&lang=${lang}`;\n\n        if (preSets.noLogin && preSets.useGet) {\n            // Send params using GET.\n            siteUrl += '&args=' + encodeURIComponent(JSON.stringify(ajaxData));\n\n            promise = this.sendHTTPRequest<T>(siteUrl, {\n                method: 'get',\n            });\n        } else {\n            promise = this.sendHTTPRequest<T>(siteUrl, {\n                method: 'post',\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                data: <any> ajaxData,\n                serializer: 'json',\n            });\n        }\n\n        return promise.then(async (response) => {\n            let data = response.body;\n\n            // Some moodle web services return null.\n            // If the responseExpected value is set then so long as no data is returned, we create a blank object.\n            if (!data && !preSets.responseExpected) {\n                data = [{}];\n            }\n\n            // Check if error. Ajax layer should always return an object (if error) or an array (if success).\n            if (!data || typeof data != 'object') {\n                const message = CoreSites.isLoggedIn()\n                    ? Translate.instant('core.siteunavailablehelp', { site: CoreSites.getCurrentSite()?.siteUrl })\n                    : Translate.instant('core.sitenotfoundhelp');\n\n                throw new CoreAjaxError({\n                    message,\n                    supportConfig: await CoreUserGuestSupportConfig.forSite(preSets.siteUrl),\n                    errorcode: 'invalidresponse',\n                    errorDetails: Translate.instant('core.serverconnection', {\n                        details: Translate.instant('core.errorinvalidresponse', { method }),\n                    }),\n                });\n            } else if (data.error) {\n                throw new CoreAjaxWSError(data);\n            }\n\n            // Get the first response since only one request was done.\n            data = data[0];\n\n            if (data.error) {\n                throw new CoreAjaxWSError(data.exception);\n            }\n\n            return data.data;\n        }, async (data: HttpErrorResponse) => {\n            const message = CoreSites.isLoggedIn()\n                ? Translate.instant('core.siteunavailablehelp', { site: CoreSites.getCurrentSite()?.siteUrl })\n                : Translate.instant('core.sitenotfoundhelp');\n\n            const options: CoreSiteErrorOptions = {\n                message,\n                supportConfig: await CoreUserGuestSupportConfig.forSite(preSets.siteUrl),\n            };\n\n            if (CorePlatform.isMobile()) {\n                switch (data.status) {\n                    case NativeHttp.ErrorCode.SSL_EXCEPTION:\n                        options.errorcode = 'invalidcertificate';\n                        options.errorDetails = Translate.instant('core.certificaterror', {\n                            details: CoreTextUtils.getErrorMessageFromError(data.error) ?? 'Invalid certificate',\n                        });\n                        break;\n                    case NativeHttp.ErrorCode.SERVER_NOT_FOUND:\n                        options.errorcode = 'servernotfound';\n                        options.errorDetails = CoreTextUtils.getErrorMessageFromError(data.error) ?? 'Server could not be found';\n                        break;\n                    case NativeHttp.ErrorCode.TIMEOUT:\n                        options.errorcode = 'requesttimeout';\n                        options.errorDetails = CoreTextUtils.getErrorMessageFromError(data.error) ?? 'Request timed out';\n                        break;\n                    case NativeHttp.ErrorCode.UNSUPPORTED_URL:\n                        options.errorcode = 'unsupportedurl';\n                        options.errorDetails = CoreTextUtils.getErrorMessageFromError(data.error) ?? 'Url not supported';\n                        break;\n                    case NativeHttp.ErrorCode.NOT_CONNECTED:\n                        options.errorcode = 'connectionerror';\n                        options.errorDetails = CoreTextUtils.getErrorMessageFromError(data.error)\n                            ?? 'Connection error, is network available?';\n                        break;\n                    case NativeHttp.ErrorCode.ABORTED:\n                        options.errorcode = 'requestaborted';\n                        options.errorDetails = CoreTextUtils.getErrorMessageFromError(data.error) ?? 'Request aborted';\n                        break;\n                    case NativeHttp.ErrorCode.POST_PROCESSING_FAILED:\n                        options.errorcode = 'requestprocessingfailed';\n                        options.errorDetails = CoreTextUtils.getErrorMessageFromError(data.error) ?? 'Request processing failed';\n                        break;\n                }\n            }\n\n            if (!options.errorcode) {\n                switch (data.status) {\n                    case 404:\n                        options.errorcode = 'endpointnotfound';\n                        options.errorDetails = Translate.instant('core.ajaxendpointnotfound', {\n                            $a: CoreSite.MINIMUM_MOODLE_VERSION,\n                        });\n                        break;\n                    default: {\n                        const details = CoreTextUtils.getErrorMessageFromError(data.error) ?? 'Unknown error';\n\n                        options.errorcode = 'serverconnectionajax';\n                        options.errorDetails = Translate.instant('core.serverconnection', {\n                            details: `[Response status code: ${data.status}] ${details}`,\n                        });\n                    }\n                        break;\n                }\n            }\n\n            throw new CoreAjaxError(options, 1, data.status);\n        }).catch(error => {\n            const type = `CoreAjaxError - ${error.errorcode}`;\n            CoreErrorLogs.addErrorLog({ method, type, message: error, time: new Date().getTime(), data });\n            throw error;\n        });\n    }\n\n    /**\n     * Perform a HEAD request and save the promise while waiting to be resolved.\n     *\n     * @param url URL to perform the request.\n     * @returns Promise resolved with the response.\n     */\n    performHead<T = unknown>(url: string): Promise<HttpResponse<T>> {\n        let promise = this.getPromiseHttp<HttpResponse<T>>('head', url);\n\n        if (!promise) {\n            promise = this.sendHTTPRequest<T>(url, {\n                method: 'head',\n                responseType: 'text',\n            });\n\n            promise = this.setPromiseHttp<HttpResponse<T>>(promise, 'head', url);\n        }\n\n        return promise;\n    }\n\n    /**\n     * Perform the post call. It can be split into several requests.\n     *\n     * @param method The WebService method to be called.\n     * @param siteUrl Complete site url to perform the call.\n     * @param ajaxData Arguments to pass to the method.\n     * @param preSets Extra settings and information.\n     * @returns Promise resolved with the response data in success and rejected with CoreWSError if it fails.\n     */\n    async performPost<T = unknown>(\n        method: string,\n        siteUrl: string,\n        ajaxData: Record<string, unknown>,\n        preSets: CoreWSPreSets,\n    ): Promise<T> {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const options: any = {};\n\n        // This is done because some returned values like 0 are treated as null if responseType is json.\n        if (preSets.typeExpected == 'number' || preSets.typeExpected == 'boolean' || preSets.typeExpected == 'string') {\n            options.responseType = 'text';\n        }\n\n        if (!preSets.splitRequest || !ajaxData[preSets.splitRequest.param]) {\n            return this.performSinglePost(method, siteUrl, ajaxData, preSets, options);\n        }\n\n        // Split the request into several requests if needed.\n        const promises: Promise<T>[] = [];\n        const splitParam = <unknown[]> ajaxData[preSets.splitRequest.param];\n\n        for (let i = 0; i < splitParam.length; i += preSets.splitRequest.maxLength) {\n            // Limit the array sent.\n            const limitedData = Object.assign({}, ajaxData);\n            limitedData[preSets.splitRequest.param] = splitParam.slice(i, i + preSets.splitRequest.maxLength);\n\n            promises.push(this.performSinglePost(method, siteUrl, limitedData, preSets, options));\n        }\n\n        const results = await Promise.all(promises);\n\n        // Combine the results.\n        const firstResult = results.shift();\n\n        if (preSets.splitRequest.combineCallback) {\n            return <T> results.reduce(preSets.splitRequest.combineCallback, firstResult);\n        }\n\n        return <T> results.reduce((previous: T, current: T) => this.combineObjectsArrays<T>(previous, current), firstResult);\n    }\n\n    /**\n     * Combine the arrays of two objects, adding them to the first object.\n     *\n     * @param object1 First object.\n     * @param object2 Second object.\n     * @returns First object with items added.\n     */\n    protected combineObjectsArrays<T>(object1: T, object2: T): T {\n        for (const name in object2) {\n            const value = object2[name];\n\n            if (Array.isArray(value)) {\n                (object1 as Record<string, unknown>)[name] = (object1[name] as typeof value).concat(value);\n            }\n        }\n\n        return object1;\n    }\n\n    /**\n     * Perform a single post request.\n     *\n     * @param method The WebService method to be called.\n     * @param siteUrl Complete site url to perform the call.\n     * @param ajaxData Arguments to pass to the method.\n     * @param preSets Extra settings and information.\n     * @param options Request options.\n     * @returns Promise resolved with the response data in success and rejected with CoreWSError if it fails.\n     */\n    protected performSinglePost<T>(\n        method: string,\n        siteUrl: string,\n        ajaxData: Record<string, unknown>,\n        preSets: CoreWSPreSets,\n        options: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    ): Promise<T> {\n\n        // We add the method name to the URL purely to help with debugging.\n        // This duplicates what is in the ajaxData, but that does no harm.\n        // POST variables take precedence over GET.\n        const requestUrl = siteUrl + '&wsfunction=' + method;\n\n        // Perform the post request.\n        const promise = firstValueFrom(Http.post(requestUrl, ajaxData, options).pipe(timeout(this.getRequestTimeout())));\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return promise.then(async (data: any) => {\n            // Some moodle web services always return null, and some others can return a primitive type or null.\n            if (data === null && (!preSets.responseExpected || preSets.typeExpected !== 'object')) {\n                return null;\n            }\n\n            const typeExpected = preSets.typeExpected === 'jsonstring' ? 'string' : preSets.typeExpected;\n\n            if (!data) {\n                throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                    errorcode: 'serverconnectionpost',\n                    errorDetails: Translate.instant('core.serverconnection', {\n                        details: Translate.instant('core.errorinvalidresponse', { method }),\n                    }),\n                });\n            } else if (typeof data !== typeExpected) {\n                // If responseType is text an string will be returned, parse before returning.\n                if (typeof data == 'string') {\n                    if (typeExpected === 'number') {\n                        data = Number(data);\n                        if (isNaN(data)) {\n                            this.logger.warn(`Response expected type \"${typeExpected}\" cannot be parsed to number`);\n\n                            throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                                errorcode: 'invalidresponse',\n                                errorDetails: Translate.instant('core.errorinvalidresponse', { method }),\n                            });\n                        }\n                    } else if (typeExpected === 'boolean') {\n                        if (data === 'true') {\n                            data = true;\n                        } else if (data === 'false') {\n                            data = false;\n                        } else {\n                            this.logger.warn(`Response expected type \"${typeExpected}\" is not true or false`);\n\n                            throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                                errorcode: 'invalidresponse',\n                                errorDetails: Translate.instant('core.errorinvalidresponse', { method }),\n                            });\n                        }\n                    } else {\n                        this.logger.warn('Response of type \"' + typeof data + `\" received, expecting \"${typeExpected}\"`);\n\n                        throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                            errorcode: 'invalidresponse',\n                            errorDetails: Translate.instant('core.errorinvalidresponse', { method }),\n                        });\n                    }\n                } else {\n                    this.logger.warn('Response of type \"' + typeof data + `\" received, expecting \"${typeExpected}\"`);\n\n                    throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                        errorcode: 'invalidresponse',\n                        errorDetails: Translate.instant('core.errorinvalidresponse', { method }),\n                    });\n                }\n            }\n\n            if (data.exception !== undefined) {\n                // Special debugging for site plugins, otherwise it's hard to debug errors if the data is cached.\n                if (method == 'tool_mobile_get_content') {\n                    this.logger.error('Error calling WS', method, data);\n                }\n\n                throw new CoreWSError(data);\n            }\n\n            if (data.debuginfo !== undefined) {\n                throw new CoreError('Error. ' + data.message);\n            }\n\n            return data;\n        }, async (error) => {\n            // If server has heavy load, retry after some seconds.\n            if (error.status == 429) {\n                const retryPromise = this.addToRetryQueue<T>(method, siteUrl, ajaxData, preSets);\n\n                // Only process the queue one time.\n                if (this.retryTimeout == 0) {\n                    this.retryTimeout = parseInt(error.headers.get('Retry-After'), 10) || 5;\n                    this.logger.warn(`${error.statusText}. Retrying in ${this.retryTimeout} seconds. ` +\n                        `${this.retryCalls.length} calls left.`);\n\n                    setTimeout(() => {\n                        this.logger.warn(`Retrying now with ${this.retryCalls.length} calls to process.`);\n                        // Finish timeout.\n                        this.retryTimeout = 0;\n                        this.processRetryQueue();\n                    }, this.retryTimeout * 1000);\n                } else {\n                    this.logger.warn('Calls locked, trying later...');\n                }\n\n                return retryPromise;\n            } else if (error.status === -2) {\n                throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                    errorcode: 'invalidcertificate',\n                    errorDetails: Translate.instant('core.certificaterror', {\n                        details: CoreTextUtils.getErrorMessageFromError(error) ?? 'Unknown error',\n                    }),\n                });\n            } else if (error.status > 0) {\n                throw this.createHttpError(error, error.status);\n            }\n\n            throw new CoreError(Translate.instant('core.serverconnection', {\n                details: CoreTextUtils.getErrorMessageFromError(error) ?? 'Unknown error',\n            }));\n        }).catch(err => {\n            CoreErrorLogs.addErrorLog({\n                method,\n                type: String(err),\n                message: String(err.exception),\n                time: new Date().getTime(),\n                data: ajaxData,\n            });\n            throw err;\n        });\n    }\n\n    /**\n     * Retry all requests in the queue.\n     * This function uses recursion in order to add a delay between requests to reduce stress.\n     */\n    protected processRetryQueue(): void {\n        if (this.retryCalls.length > 0 && this.retryTimeout == 0) {\n            const call = this.retryCalls[0];\n            this.retryCalls.shift();\n\n            // Add a delay between calls.\n            setTimeout(() => {\n                call.deferred.resolve(this.performPost(call.method, call.siteUrl, call.data, call.preSets));\n                this.processRetryQueue();\n            }, 200);\n        } else {\n            this.logger.warn(`Retry queue has stopped with ${this.retryCalls.length} calls and ${this.retryTimeout} timeout secs.`);\n        }\n    }\n\n    /**\n     * Save promise on the cache.\n     *\n     * @param promise Promise to be saved.\n     * @param method Method of the HTTP request.\n     * @param url Base URL of the HTTP request.\n     * @param params Params of the HTTP request.\n     * @returns The promise saved.\n     */\n    protected setPromiseHttp<T = unknown>(\n        promise: Promise<T>,\n        method: string,\n        url: string,\n        params?: Record<string, unknown>,\n    ): Promise<T> {\n        const queueItemId = this.getQueueItemId(method, url, params);\n\n        this.ongoingCalls[queueItemId] = promise;\n\n        // HTTP not finished, but we should delete the promise after timeout.\n        const timeout = setTimeout(() => {\n            delete this.ongoingCalls[queueItemId];\n        }, this.getRequestTimeout());\n\n        // HTTP finished, delete from ongoing.\n        return promise.finally(() => {\n            delete this.ongoingCalls[queueItemId];\n\n            clearTimeout(timeout);\n        });\n    }\n\n    /**\n     * A wrapper function for a synchronous Moodle WebService call.\n     * Warning: This function should only be used if synchronous is a must. It's recommended to use call.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra settings and information.\n     * @returns Promise resolved with the response data in success and rejected with the error message if it fails.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    syncCall<T = unknown>(method: string, data: any, preSets: CoreWSPreSets): T {\n        try {\n            if (!preSets) {\n                throw new CoreError(Translate.instant('core.unexpectederror'));\n            } else if (!CoreNetwork.isOnline()) {\n                throw new CoreNetworkError();\n            }\n\n            preSets.typeExpected = preSets.typeExpected || 'object';\n            if (preSets.responseExpected === undefined) {\n                preSets.responseExpected = true;\n            }\n\n            data = this.convertValuesToString(data || {}, preSets.cleanUnicode);\n            if (data == null) {\n                // Empty cleaned text found.\n                throw new CoreError(Translate.instant('core.unicodenotsupportedcleanerror'));\n            }\n\n            data.wsfunction = method;\n            data.wstoken = preSets.wsToken;\n            const siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';\n\n            // Serialize data.\n            data = CoreInterceptor.serialize(data);\n\n            // Perform sync request using XMLHttpRequest.\n            const xhr = new XMLHttpRequest();\n            xhr.open('post', siteUrl, false);\n            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');\n\n            xhr.send(data);\n\n            // Get response.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data = ('response' in xhr) ? xhr.response : (<any> xhr).responseText;\n\n            // Check status.\n            const status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);\n            if (status < 200 || status >= 300) {\n                // Request failed.\n                throw new CoreError(data);\n            }\n\n            // Treat response.\n            data = CoreTextUtils.parseJSON(data);\n\n            // Some moodle web services return null.\n            // If the responseExpected value is set then so long as no data is returned, we create a blank object.\n            if ((!data || !data.data) && !preSets.responseExpected) {\n                data = {};\n            }\n\n            if (!data) {\n                throw new CoreError(Translate.instant('core.serverconnection', {\n                    details: Translate.instant('core.errorinvalidresponse', { method }),\n                }));\n            } else if (typeof data != preSets.typeExpected) {\n                this.logger.warn('Response of type \"' + typeof data + '\" received, expecting \"' + preSets.typeExpected + '\"');\n                throw new CoreError(Translate.instant('core.errorinvalidresponse', { method }));\n            }\n\n            if (data.exception !== undefined || data.debuginfo !== undefined) {\n                throw new CoreWSError(data);\n            }\n\n            return data;\n        } catch (err) {\n            let errorType = '';\n\n            if (err instanceof CoreError) {\n                errorType = 'CoreError';\n            } else if (err instanceof CoreWSError) {\n                errorType = 'CoreWSError';\n            }\n\n            CoreErrorLogs.addErrorLog({ method, type: errorType, message: String(err), time: new Date().getTime(), data });\n            throw err;\n        }\n    }\n\n    /*\n     * Uploads a file.\n     *\n     * @param filePath File path.\n     * @param options File upload options.\n     * @param preSets Must contain siteUrl and wsToken.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when uploaded.\n     */\n    async uploadFile(\n        filePath: string,\n        options: CoreWSFileUploadOptions,\n        preSets: CoreWSPreSets,\n        onProgress?: (event: ProgressEvent) => void,\n    ): Promise<CoreWSUploadFileResult> {\n        this.logger.debug(`Trying to upload file: ${filePath}`);\n\n        if (!filePath || !options || !preSets) {\n            throw new CoreError('Invalid options passed to upload file.');\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            throw new CoreNetworkError();\n        }\n\n        const uploadUrl = preSets.siteUrl + '/webservice/upload.php';\n        const transfer = FileTransfer.create();\n\n        onProgress && transfer.onProgress(onProgress);\n\n        options.httpMethod = 'POST';\n        options.params = {\n            token: preSets.wsToken,\n            filearea: options.fileArea || 'draft',\n            itemid: options.itemId || 0,\n        };\n        options.chunkedMode = false;\n        options.headers = {\n            'User-Agent': navigator.userAgent,\n        };\n        options['Connection'] = 'close';\n\n        let success: FileUploadResult;\n\n        try {\n            success = await transfer.upload(filePath, uploadUrl, options, true);\n        } catch (error) {\n            this.logger.error('Error while uploading file', filePath, error);\n\n            throw this.createHttpError(error, error.http_status ?? 0);\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data = CoreTextUtils.parseJSON<any>(\n            success.response,\n            null,\n            error => this.logger.error('Error parsing response from upload', success.response, error),\n        );\n\n        if (data === null) {\n            throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                errorcode: 'invalidresponse',\n                errorDetails: Translate.instant('core.errorinvalidresponse', { method: 'upload.php' }),\n            });\n        }\n\n        if (!data) {\n            throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                errorcode: 'serverconnectionupload',\n                errorDetails: Translate.instant('core.serverconnection', {\n                    details: Translate.instant('core.errorinvalidresponse', { method: 'upload.php' }),\n                }),\n            });\n        } else if (typeof data != 'object') {\n            this.logger.warn('Upload file: Response of type \"' + typeof data + '\" received, expecting \"object\"');\n\n            throw await this.createCannotConnectSiteError(preSets.siteUrl, {\n                errorcode: 'invalidresponse',\n                errorDetails: Translate.instant('core.errorinvalidresponse', { method: 'upload.php' }),\n            });\n        }\n\n        if (data.exception !== undefined) {\n            throw new CoreWSError(data);\n        } else if (data.error !== undefined) {\n            throw new CoreWSError({\n                errorcode: data.errortype,\n                message: data.error,\n            });\n        } else if (data[0] && data[0].error !== undefined) {\n            throw new CoreWSError({\n                errorcode: data[0].errortype,\n                message: data[0].error,\n            });\n        }\n\n        // We uploaded only 1 file, so we only return the first file returned.\n        this.logger.debug('Successfully uploaded file', filePath);\n\n        return data[0];\n    }\n\n    /**\n     * Create a CoreHttpError based on a certain error.\n     *\n     * @param error Original error.\n     * @param status Status code (if any).\n     * @returns CoreHttpError.\n     */\n    protected createHttpError(error: CoreTextErrorObject, status: number): CoreHttpError {\n        const message = CoreTextUtils.buildSeveralParagraphsMessage([\n            CoreSites.isLoggedIn()\n                ? Translate.instant('core.siteunavailablehelp', { site: CoreSites.getCurrentSite()?.siteUrl })\n                : Translate.instant('core.sitenotfoundhelp'),\n            CoreTextUtils.getHTMLBodyContent(CoreTextUtils.getErrorMessageFromError(error) || ''),\n        ]);\n\n        return new CoreHttpError(message, status);\n    }\n\n    /**\n     * Perform an HTTP request requesting for a text response.\n     *\n     * @param url Url to get.\n     * @returns Resolved with the text when done.\n     */\n    async getText(url: string): Promise<string> {\n        // Fetch the URL content.\n        const options: HttpRequestOptions = {\n            method: 'get',\n            responseType: 'text',\n        };\n\n        const response = await this.sendHTTPRequest<string>(url, options);\n\n        const content = response.body;\n\n        if (typeof content !== 'string') {\n            throw new Error('Error reading content');\n        }\n\n        return content;\n    }\n\n    /**\n     * Send an HTTP request. In mobile devices it will use the cordova plugin.\n     *\n     * @param url URL of the request.\n     * @param options Options for the request.\n     * @returns Promise resolved with the response.\n     */\n    async sendHTTPRequest<T = unknown>(url: string, options: HttpRequestOptions): Promise<HttpResponse<T>> {\n        // Set default values.\n        options.responseType = options.responseType || 'json';\n        options.timeout = options.timeout === undefined ? this.getRequestTimeout() : options.timeout;\n\n        if (CorePlatform.isMobile()) {\n            // Use the cordova plugin.\n            if (url.indexOf('file://') === 0) {\n                // We cannot load local files using the http native plugin. Use file provider instead.\n                const content = options.responseType == 'json' ?\n                    await CoreFile.readFile<T>(url, CoreFileFormat.FORMATJSON) :\n                    await CoreFile.readFile(url, CoreFileFormat.FORMATTEXT);\n\n                return new HttpResponse<T>({\n                    body: <T> content,\n                    headers: undefined,\n                    status: 200,\n                    statusText: 'OK',\n                    url,\n                });\n            }\n\n            return NativeHttp.sendRequest(url, options).then((response) => new CoreNativeToAngularHttpResponse(response));\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let observable: Observable<HttpResponse<any>>;\n            const angularOptions = <AngularHttpRequestOptions> options;\n\n            // Use Angular's library.\n            switch (angularOptions.method) {\n                case 'get':\n                    observable = Http.get(url, {\n                        headers: angularOptions.headers,\n                        params: angularOptions.params,\n                        observe: 'response',\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        responseType: <any> angularOptions.responseType,\n                    });\n                    break;\n\n                case 'post':\n                    if (angularOptions.serializer == 'json') {\n                        angularOptions.data = JSON.stringify(angularOptions.data);\n                    }\n\n                    observable = Http.post(url, angularOptions.data, {\n                        headers: angularOptions.headers,\n                        observe: 'response',\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        responseType: <any> angularOptions.responseType,\n                    });\n                    break;\n\n                case 'head':\n                    observable = Http.head(url, {\n                        headers: angularOptions.headers,\n                        observe: 'response',\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        responseType: <any> angularOptions.responseType,\n                    });\n                    break;\n\n                default:\n                    throw new CoreError('Method not implemented yet.');\n            }\n\n            if (angularOptions.timeout) {\n                observable = observable.pipe(timeout(angularOptions.timeout));\n            }\n\n            return firstValueFrom(observable);\n        }\n    }\n\n    /**\n     * Check if a URL works (it returns a 2XX status).\n     *\n     * @param url URL to check.\n     * @returns Promise resolved with boolean: whether it works.\n     */\n    async urlWorks(url: string): Promise<boolean> {\n        try {\n            const result = await this.performHead(url);\n\n            return result.status >= 200 && result.status < 300;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Create an error to be thrown when it isn't possible to connect to a site.\n     *\n     * @param siteUrl Site url.\n     * @param options Error options.\n     * @returns Cannot connect error.\n     */\n    protected async createCannotConnectSiteError(\n        siteUrl: string,\n        options?: Partial<CoreSiteErrorOptions>,\n    ): Promise<CoreSiteError> {\n        return new CoreSiteError({\n            ...options,\n            supportConfig: await CoreUserGuestSupportConfig.forSite(siteUrl),\n            message: CoreSites.isLoggedIn()\n                ? Translate.instant('core.siteunavailablehelp', { site: CoreSites.getCurrentSite()?.siteUrl })\n                : Translate.instant('core.sitenotfoundhelp'),\n        });\n    }\n\n}\n\nexport const CoreWS = makeSingleton(CoreWSProvider);\n\n/**\n * File upload options.\n */\nexport interface CoreWSFileUploadOptions extends FileUploadOptions {\n    /**\n     * The file area where to put the file. By default, 'draft'.\n     */\n    fileArea?: string;\n\n    /**\n     * Item ID of the area where to put the file. By default, 0.\n     */\n    itemId?: number;\n}\n\n/**\n * Structure of warnings returned by WS.\n */\nexport type CoreWSExternalWarning = {\n    /**\n     * Item.\n     */\n    item?: string;\n\n    /**\n     * Item id.\n     */\n    itemid?: number;\n\n    /**\n     * The warning code can be used by the client app to implement specific behaviour.\n     */\n    warningcode: string;\n\n    /**\n     * Untranslated english message to explain the warning.\n     */\n    message: string;\n\n};\n\n/**\n * Special response structure of many webservices that contains success status and warnings.\n */\nexport type CoreStatusWithWarningsWSResponse = {\n    status: boolean; // Status: true if success.\n    offline?: boolean; // True if information has been stored in offline for future use.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Special response structure of many webservices that contains only warnings.\n */\nexport type CoreWarningsWSResponse = {\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Structure of files returned by WS.\n */\nexport type CoreWSExternalFile = {\n    fileurl: string; // Downloadable file url.\n    filename?: string; // File name.\n    filepath?: string; // File path.\n    filesize?: number; // File size.\n    timemodified?: number; // Time modified.\n    mimetype?: string; // File mime type.\n    isexternalfile?: number; // Whether is an external file.\n    repositorytype?: string; // The repository type for external files.\n};\n\n/**\n * Structure of files returned by stored_file_exporter.\n */\nexport type CoreWSStoredFile = {\n    contextid: number; // Contextid.\n    component: string; // Component.\n    filearea: string; // Filearea.\n    itemid: number; // Itemid.\n    filepath: string; // Filepath.\n    filename: string; // Filename.\n    isdir: boolean; // Isdir.\n    isimage: boolean; // Isimage.\n    timemodified: number; // Timemodified.\n    timecreated: number; // Timecreated.\n    filesize: number; // Filesize.\n    author: string; // Author.\n    license: string; // License.\n    filenameshort: string; // Filenameshort.\n    filesizeformatted: string; // Filesizeformatted.\n    icon: string; // Icon.\n    timecreatedformatted: string; // Timecreatedformatted.\n    timemodifiedformatted: string; // Timemodifiedformatted.\n    url: string; // Url.\n    urls: {\n        export?: string; // The URL used to export the attachment.\n    };\n    html: {\n        plagiarism?: string; // The HTML source for the Plagiarism Response.\n    };\n    mimetype: undefined; // File mimetype. @todo Not implemented yet in Moodle, see MDL-71354.\n};\n\n/**\n * Common file structures returned by WS.\n */\nexport type CoreWSFile = CoreWSExternalFile | CoreWSStoredFile;\n\n/**\n * Data returned by date_exporter.\n */\nexport type CoreWSDate = {\n    seconds: number; // Seconds.\n    minutes: number; // Minutes.\n    hours: number; // Hours.\n    mday: number; // Mday.\n    wday: number; // Wday.\n    mon: number; // Mon.\n    year: number; // Year.\n    yday: number; // Yday.\n    weekday: string; // Weekday.\n    month: string; // Month.\n    timestamp: number; // Timestamp.\n};\n\n/**\n * PreSets accepted by the WS call.\n */\nexport type CoreWSPreSets = {\n    /**\n     * The site URL.\n     */\n    siteUrl: string;\n\n    /**\n     * The Webservice token.\n     */\n    wsToken: string;\n\n    /**\n     * Defaults to true. Set to false when the expected response is null.\n     */\n    responseExpected?: boolean;\n\n    /**\n     * Defaults to 'object'. Use it when you expect a type that's not an object|array.\n     */\n    typeExpected?: CoreWSTypeExpected;\n\n    /**\n     * Defaults to false. Clean multibyte Unicode chars from data.\n     */\n    cleanUnicode?: boolean;\n\n    /**\n     * Whether to split a request if it has too many parameters. Sending too many parameters to the site\n     * can cause the request to fail (see PHP's max_input_vars).\n     */\n    splitRequest?: CoreWSPreSetsSplitRequest;\n};\n\nexport type CoreWSTypeExpected = 'boolean'|'number'|'string'|'jsonstring'|'object';\n\n/**\n * Options to split a request.\n */\nexport type CoreWSPreSetsSplitRequest = {\n    /**\n     * Name of the parameter used to split the request if too big. Must be an array parameter.\n     */\n    param: string;\n\n    /**\n     * Max number of entries sent per request.\n     */\n    maxLength: number;\n\n    /**\n     * Callback to combine the results. If not supplied, arrays in the result will be concatenated.\n     */\n    combineCallback?: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown;\n};\n\n/**\n * PreSets accepted by AJAX WS calls.\n */\nexport type CoreWSAjaxPreSets = {\n    /**\n     * The site URL.\n     */\n    siteUrl: string;\n\n    /**\n     * Defaults to true. Set to false when the expected response is null.\n     */\n    responseExpected?: boolean;\n\n    /**\n     * Whether to use the no-login endpoint instead of the normal one. Use it for requests that don't require authentication.\n     */\n    noLogin?: boolean;\n\n    /**\n     * Whether to send the parameters via GET. Only if noLogin is true.\n     */\n    useGet?: boolean;\n};\n\n/**\n * Options for HTTP requests.\n */\nexport type HttpRequestOptions = {\n    /**\n     * The HTTP method.\n     */\n    method: 'get' | 'post' | 'put' | 'patch' | 'head' | 'delete' | 'options' | 'upload' | 'download';\n\n    /**\n     * Payload to send to the server. Only applicable on post, put or patch methods.\n     */\n    data?: Record<string, unknown>;\n\n    /**\n     * Query params to be appended to the URL (only applicable on get, head, delete, upload or download methods).\n     */\n    params?: Record<string, string | number>;\n\n    /**\n     * Response type. Defaults to json.\n     */\n    responseType?: 'json' | 'text' | 'arraybuffer' | 'blob';\n\n    /**\n     * Timeout for the request in seconds. If undefined, the default value will be used. If null, no timeout.\n     */\n    timeout?: number;\n\n    /**\n     * Serializer to use. Defaults to 'urlencoded'. Only for mobile environments.\n     */\n    serializer?: 'json' | 'urlencoded' | 'utf8' | 'multipart';\n\n    /**\n     * Whether to follow redirects. Defaults to true. Only for mobile environments.\n     */\n    followRedirect?: boolean;\n\n    /**\n     * Headers. Only for mobile environments.\n     */\n    headers?: Record<string, string>;\n\n    /**\n     * File paths to use for upload or download. Only for mobile environments.\n     */\n    filePath?: string | string[];\n\n    /**\n     * Name to use during upload. Only for mobile environments.\n     */\n    name?: string | string[];\n};\n\n/**\n * Options for JSON HTTP requests using Angular Http.\n */\ntype AngularHttpRequestOptions = Omit<HttpRequestOptions, 'data'|'params'> & {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data?: Record<string, any> | string;\n    params?: HttpParams | {\n        [param: string]: string | string[];\n    };\n};\n\n/**\n * Data needed to retry a WS call.\n */\ntype RetryCall = {\n    method: string;\n    siteUrl: string;\n    data: Record<string, unknown>;\n    preSets: CoreWSPreSets;\n    deferred: CorePromisedValue;\n};\n\n/**\n * Downloaded file entry. It includes some calculated data.\n */\nexport type CoreWSDownloadedFileEntry = FileEntry & {\n    extension: string; // File extension.\n    path: string; // File path.\n};\n\nexport type CoreWSUploadFileResult = {\n    component: string; // Component the file was uploaded to.\n    context: string; // Context the file was uploaded to.\n    userid: number; // User that uploaded the file.\n    filearea: string; // File area the file was uploaded to.\n    filename: string; // File name.\n    filepath: string; // File path.\n    itemid: number; // Item ID the file was uploaded to.\n    license: string; // File license.\n    author: string; // Author name.\n    source: string; // File source.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}