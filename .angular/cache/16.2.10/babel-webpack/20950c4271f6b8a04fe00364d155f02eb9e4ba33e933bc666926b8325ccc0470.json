{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreFileUploader } from '@features/fileuploader/services/fileuploader';\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport { DATA_ENTRY_TABLE } from './database/data';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle Offline data.\n */\nexport class AddonModDataOfflineProvider {\n  /**\n   * Delete all the actions of an entry.\n   *\n   * @param dataId Database ID.\n   * @param entryId Database entry ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteAllEntryActions(dataId, entryId, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const actions = yield _this.getEntryActions(dataId, entryId, siteId);\n      const promises = actions.map(action => {\n        _this.deleteEntry(dataId, entryId, action.action, siteId);\n      });\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Delete an stored entry.\n   *\n   * @param dataId Database ID.\n   * @param entryId Database entry Id.\n   * @param action Action to be done\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteEntry(dataId, entryId, action, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield _this2.deleteEntryFiles(dataId, entryId, action, site.id);\n      yield site.getDb().deleteRecords(DATA_ENTRY_TABLE, {\n        dataid: dataId,\n        entryid: entryId,\n        action\n      });\n    })();\n  }\n  /**\n   * Delete entry offline files.\n   *\n   * @param dataId Database ID.\n   * @param entryId Database entry ID.\n   * @param action Action to be done.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteEntryFiles(dataId, entryId, action, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = yield CoreUtils.ignoreErrors(_this3.getEntry(dataId, entryId, action, site.id));\n      if (!entry || !entry.fields) {\n        // Entry not found or no fields, ignore.\n        return;\n      }\n      const promises = [];\n      entry.fields.forEach(field => {\n        const value = CoreTextUtils.parseJSON(field.value, null);\n        if (!value || !value.offline) {\n          return;\n        }\n        const promise = _this3.getEntryFieldFolder(dataId, entryId, field.fieldid, site.id).then(folderPath => CoreFileUploader.getStoredFiles(folderPath)).then(files => CoreFileUploader.clearTmpFiles(files)).catch(() => {});\n        promises.push(promise);\n      });\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Get all the stored entry data from all the databases.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with entries.\n   */\n  getAllEntries(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entries = yield site.getDb().getAllRecords(DATA_ENTRY_TABLE);\n      return entries.map(entry => _this4.parseRecord(entry));\n    })();\n  }\n  /**\n   * Get all the stored entry actions from a certain database, sorted by modification time.\n   *\n   * @param dataId Database ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with entries.\n   */\n  getDatabaseEntries(dataId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entries = yield site.getDb().getRecords(DATA_ENTRY_TABLE, {\n        dataid: dataId\n      }, 'timemodified');\n      return entries.map(entry => _this5.parseRecord(entry));\n    })();\n  }\n  /**\n   * Get an stored entry data.\n   *\n   * @param dataId Database ID.\n   * @param entryId Database entry Id.\n   * @param action Action to be done\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with entry.\n   */\n  getEntry(dataId, entryId, action, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = yield site.getDb().getRecord(DATA_ENTRY_TABLE, {\n        dataid: dataId,\n        entryid: entryId,\n        action\n      });\n      return _this6.parseRecord(entry);\n    })();\n  }\n  /**\n   * Get an all stored entry actions data.\n   *\n   * @param dataId Database ID.\n   * @param entryId Database entry Id.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with entry actions.\n   */\n  getEntryActions(dataId, entryId, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entries = yield site.getDb().getRecords(DATA_ENTRY_TABLE, {\n        dataid: dataId,\n        entryid: entryId\n      });\n      return entries.map(entry => _this7.parseRecord(entry));\n    })();\n  }\n  /**\n   * Check if there are offline entries to send.\n   *\n   * @param dataId Database ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has offline answers, false otherwise.\n   */\n  hasOfflineData(dataId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return CoreUtils.promiseWorks(site.getDb().recordExists(DATA_ENTRY_TABLE, {\n        dataid: dataId\n      }));\n    })();\n  }\n  /**\n   * Get the path to the folder where to store files for offline files in a database.\n   *\n   * @param dataId Database ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getDatabaseFolder(dataId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const siteFolderPath = CoreFile.getSiteFolder(site.getId());\n      const folderPath = 'offlinedatabase/' + dataId;\n      return CorePath.concatenatePaths(siteFolderPath, folderPath);\n    })();\n  }\n  /**\n   * Get the path to the folder where to store files for a new offline entry.\n   *\n   * @param dataId Database ID.\n   * @param entryId The ID of the entry.\n   * @param fieldId Field ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the path.\n   */\n  getEntryFieldFolder(dataId, entryId, fieldId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const folderPath = yield _this8.getDatabaseFolder(dataId, siteId);\n      return CorePath.concatenatePaths(folderPath, entryId + '_' + fieldId);\n    })();\n  }\n  /**\n   * Parse \"fields\" of an offline record.\n   *\n   * @param record Record object\n   * @returns Record object with columns parsed.\n   */\n  parseRecord(record) {\n    return Object.assign(record, {\n      fields: CoreTextUtils.parseJSON(record.fields)\n    });\n  }\n  /**\n   * Save an entry data to be sent later.\n   *\n   * @param dataId Database ID.\n   * @param entryId Database entry Id. If action is add entryId should be 0 and -timemodified will be used.\n   * @param action Action to be done to the entry: [add, edit, delete, approve, disapprove]\n   * @param courseId Course ID of the database.\n   * @param groupId Group ID. Only provided when adding.\n   * @param fields Array of field data of the entry if needed.\n   * @param timemodified The time the entry was modified. If not defined, current time.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  saveEntry(dataId, entryId, action, courseId, groupId = 0, fields, timemodified, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      timemodified = timemodified || Date.now();\n      entryId = entryId === undefined || entryId === null ? -timemodified : entryId;\n      const entry = {\n        dataid: dataId,\n        courseid: courseId,\n        groupid: groupId,\n        action,\n        entryid: entryId,\n        fields: JSON.stringify(fields || []),\n        timemodified\n      };\n      yield site.getDb().insertRecord(DATA_ENTRY_TABLE, entry);\n      return entry;\n    })();\n  }\n}\n_class = AddonModDataOfflineProvider;\n_class.ɵfac = function AddonModDataOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModDataOffline = makeSingleton(AddonModDataOfflineProvider);","map":{"version":3,"names":["CoreFileUploader","CoreFile","CoreSites","CoreTextUtils","CoreUtils","makeSingleton","CorePath","DATA_ENTRY_TABLE","AddonModDataOfflineProvider","deleteAllEntryActions","dataId","entryId","siteId","_this","_asyncToGenerator","actions","getEntryActions","promises","map","action","deleteEntry","Promise","all","_this2","site","getSite","deleteEntryFiles","id","getDb","deleteRecords","dataid","entryid","_this3","entry","ignoreErrors","getEntry","fields","forEach","field","value","parseJSON","offline","promise","getEntryFieldFolder","fieldid","then","folderPath","getStoredFiles","files","clearTmpFiles","catch","push","getAllEntries","_this4","entries","getAllRecords","parseRecord","getDatabaseEntries","_this5","getRecords","_this6","getRecord","_this7","hasOfflineData","promiseWorks","recordExists","getDatabaseFolder","siteFolderPath","getSiteFolder","getId","concatenatePaths","fieldId","_this8","record","Object","assign","saveEntry","courseId","groupId","timemodified","Date","now","undefined","courseid","groupid","JSON","stringify","insertRecord","factory","ɵfac","providedIn","AddonModDataOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/data/services/data-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreFileUploader, CoreFileUploaderStoreFilesResult } from '@features/fileuploader/services/fileuploader';\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport { AddonModDataAction, AddonModDataEntryWSField } from './data';\nimport { AddonModDataEntryDBRecord, DATA_ENTRY_TABLE } from './database/data';\n\n/**\n * Service to handle Offline data.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModDataOfflineProvider {\n\n    /**\n     * Delete all the actions of an entry.\n     *\n     * @param dataId Database ID.\n     * @param entryId Database entry ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    async deleteAllEntryActions(dataId: number, entryId: number, siteId?: string): Promise<void> {\n        const actions = await this.getEntryActions(dataId, entryId, siteId);\n\n        const promises = actions.map((action) => {\n            this.deleteEntry(dataId, entryId, action.action, siteId);\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Delete an stored entry.\n     *\n     * @param dataId Database ID.\n     * @param entryId Database entry Id.\n     * @param action Action to be done\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    async deleteEntry(dataId: number, entryId: number, action: AddonModDataAction, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await this.deleteEntryFiles(dataId, entryId, action, site.id);\n\n        await site.getDb().deleteRecords(DATA_ENTRY_TABLE, {\n            dataid: dataId,\n            entryid: entryId,\n            action,\n        });\n    }\n\n    /**\n     * Delete entry offline files.\n     *\n     * @param dataId Database ID.\n     * @param entryId Database entry ID.\n     * @param action Action to be done.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    protected async deleteEntryFiles(dataId: number, entryId: number, action: AddonModDataAction, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const entry = await CoreUtils.ignoreErrors(this.getEntry(dataId, entryId, action, site.id));\n\n        if (!entry || !entry.fields) {\n            // Entry not found or no fields, ignore.\n            return;\n        }\n\n        const promises: Promise<void>[] = [];\n\n        entry.fields.forEach((field) => {\n            const value = CoreTextUtils.parseJSON<CoreFileUploaderStoreFilesResult | null>(field.value, null);\n\n            if (!value || !value.offline) {\n                return;\n            }\n\n            const promise = this.getEntryFieldFolder(dataId, entryId, field.fieldid, site.id).then((folderPath) =>\n                CoreFileUploader.getStoredFiles(folderPath)).then((files) =>\n                CoreFileUploader.clearTmpFiles(files)).catch(() => { // Files not found, ignore.\n            });\n\n            promises.push(promise);\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Get all the stored entry data from all the databases.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with entries.\n     */\n    async getAllEntries(siteId?: string): Promise<AddonModDataOfflineAction[]> {\n        const site = await CoreSites.getSite(siteId);\n        const entries = await site.getDb().getAllRecords<AddonModDataEntryDBRecord>(DATA_ENTRY_TABLE);\n\n        return entries.map((entry) => this.parseRecord(entry));\n    }\n\n    /**\n     * Get all the stored entry actions from a certain database, sorted by modification time.\n     *\n     * @param dataId Database ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with entries.\n     */\n    async getDatabaseEntries(dataId: number, siteId?: string): Promise<AddonModDataOfflineAction[]> {\n        const site = await CoreSites.getSite(siteId);\n        const entries = await site.getDb().getRecords<AddonModDataEntryDBRecord>(\n            DATA_ENTRY_TABLE,\n            { dataid: dataId },\n            'timemodified',\n        );\n\n        return entries.map((entry) => this.parseRecord(entry));\n    }\n\n    /**\n     * Get an stored entry data.\n     *\n     * @param dataId Database ID.\n     * @param entryId Database entry Id.\n     * @param action Action to be done\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with entry.\n     */\n    async getEntry(\n        dataId: number,\n        entryId: number,\n        action: AddonModDataAction,\n        siteId?: string,\n    ): Promise<AddonModDataOfflineAction> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entry = await site.getDb().getRecord<AddonModDataEntryDBRecord>(DATA_ENTRY_TABLE, {\n            dataid: dataId, entryid: entryId,\n            action,\n        });\n\n        return this.parseRecord(entry);\n    }\n\n    /**\n     * Get an all stored entry actions data.\n     *\n     * @param dataId Database ID.\n     * @param entryId Database entry Id.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with entry actions.\n     */\n    async getEntryActions(dataId: number, entryId: number, siteId?: string): Promise<AddonModDataOfflineAction[]> {\n        const site = await CoreSites.getSite(siteId);\n        const entries = await site.getDb().getRecords<AddonModDataEntryDBRecord>(\n            DATA_ENTRY_TABLE,\n            { dataid: dataId, entryid: entryId },\n        );\n\n        return entries.map((entry) => this.parseRecord(entry));\n    }\n\n    /**\n     * Check if there are offline entries to send.\n     *\n     * @param dataId Database ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has offline answers, false otherwise.\n     */\n    async hasOfflineData(dataId: number, siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return CoreUtils.promiseWorks(\n            site.getDb().recordExists(DATA_ENTRY_TABLE, { dataid: dataId }),\n        );\n    }\n\n    /**\n     * Get the path to the folder where to store files for offline files in a database.\n     *\n     * @param dataId Database ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    protected async getDatabaseFolder(dataId: number, siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n        const siteFolderPath = CoreFile.getSiteFolder(site.getId());\n        const folderPath = 'offlinedatabase/' + dataId;\n\n        return CorePath.concatenatePaths(siteFolderPath, folderPath);\n    }\n\n    /**\n     * Get the path to the folder where to store files for a new offline entry.\n     *\n     * @param dataId Database ID.\n     * @param entryId The ID of the entry.\n     * @param fieldId Field ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the path.\n     */\n    async getEntryFieldFolder(dataId: number, entryId: number, fieldId: number, siteId?: string): Promise<string> {\n        const folderPath = await this.getDatabaseFolder(dataId, siteId);\n\n        return CorePath.concatenatePaths(folderPath, entryId + '_' + fieldId);\n    }\n\n    /**\n     * Parse \"fields\" of an offline record.\n     *\n     * @param record Record object\n     * @returns Record object with columns parsed.\n     */\n    protected parseRecord(record: AddonModDataEntryDBRecord): AddonModDataOfflineAction {\n        return Object.assign(record, {\n            fields: CoreTextUtils.parseJSON<AddonModDataEntryWSField[]>(record.fields),\n        });\n    }\n\n    /**\n     * Save an entry data to be sent later.\n     *\n     * @param dataId Database ID.\n     * @param entryId Database entry Id. If action is add entryId should be 0 and -timemodified will be used.\n     * @param action Action to be done to the entry: [add, edit, delete, approve, disapprove]\n     * @param courseId Course ID of the database.\n     * @param groupId Group ID. Only provided when adding.\n     * @param fields Array of field data of the entry if needed.\n     * @param timemodified The time the entry was modified. If not defined, current time.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async saveEntry(\n        dataId: number,\n        entryId: number,\n        action: AddonModDataAction,\n        courseId: number,\n        groupId = 0,\n        fields?: AddonModDataEntryWSField[],\n        timemodified?: number,\n        siteId?: string,\n    ): Promise<AddonModDataEntryDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        timemodified = timemodified || Date.now();\n        entryId = entryId === undefined || entryId === null ? -timemodified : entryId;\n\n        const entry: AddonModDataEntryDBRecord = {\n            dataid: dataId,\n            courseid: courseId,\n            groupid: groupId,\n            action,\n            entryid: entryId,\n            fields: JSON.stringify(fields || []),\n            timemodified,\n        };\n\n        await site.getDb().insertRecord(DATA_ENTRY_TABLE, entry);\n\n        return entry;\n    }\n\n}\nexport const AddonModDataOffline = makeSingleton(AddonModDataOfflineProvider);\n\n/**\n * Entry action stored offline.\n */\nexport type AddonModDataOfflineAction = Omit<AddonModDataEntryDBRecord, 'fields'> & {\n    fields: AddonModDataEntryWSField[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}