{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { PAGE_ATTEMPTS_TABLE_NAME, RETAKES_TABLE_NAME } from './database/lesson';\nimport { AddonModLessonProvider } from './lesson';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline lesson.\n */\nexport class AddonModLessonOfflineProvider {\n  /**\n   * Delete an offline attempt.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Lesson retake number.\n   * @param pageId Page ID.\n   * @param timemodified The timemodified of the attempt.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteAttempt(lessonId, retake, pageId, timemodified, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(PAGE_ATTEMPTS_TABLE_NAME, {\n        lessonid: lessonId,\n        retake: retake,\n        pageid: pageId,\n        timemodified: timemodified\n      });\n    })();\n  }\n  /**\n   * Delete offline lesson retake.\n   *\n   * @param lessonId Lesson ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteRetake(lessonId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(RETAKES_TABLE_NAME, {\n        lessonid: lessonId\n      });\n    })();\n  }\n  /**\n   * Delete offline attempts for a retake and page.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Lesson retake number.\n   * @param pageId Page ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteRetakeAttemptsForPage(lessonId, retake, pageId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(PAGE_ATTEMPTS_TABLE_NAME, {\n        lessonid: lessonId,\n        retake: retake,\n        pageid: pageId\n      });\n    })();\n  }\n  /**\n   * Mark a retake as finished.\n   *\n   * @param lessonId Lesson ID.\n   * @param courseId Course ID the lesson belongs to.\n   * @param retake Retake number.\n   * @param finished Whether retake is finished.\n   * @param outOfTime If the user ran out of time.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  finishRetake(lessonId, courseId, retake, finished, outOfTime, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // Get current stored retake (if any). If not found, it will create a new one.\n      const entry = yield _this.getRetakeWithFallback(lessonId, courseId, retake, site.id);\n      entry.finished = finished ? 1 : 0;\n      entry.outoftime = outOfTime ? 1 : 0;\n      entry.timemodified = CoreTimeUtils.timestamp();\n      yield site.getDb().insertRecord(RETAKES_TABLE_NAME, entry);\n    })();\n  }\n  /**\n   * Get all the offline page attempts in a certain site.\n   *\n   * @param siteId Site ID. If not set, use current site.\n   * @returns Promise resolved when the offline attempts are retrieved.\n   */\n  getAllAttempts(siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      const attempts = yield db.getAllRecords(PAGE_ATTEMPTS_TABLE_NAME);\n      return _this2.parsePageAttempts(attempts);\n    })();\n  }\n  /**\n   * Get all the lessons that have offline data in a certain site.\n   *\n   * @param siteId Site ID. If not set, use current site.\n   * @returns Promise resolved with an object containing the lessons.\n   */\n  getAllLessonsWithData(siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const lessons = {};\n      const [pageAttempts, retakes] = yield Promise.all([CoreUtils.ignoreErrors(_this3.getAllAttempts(siteId)), CoreUtils.ignoreErrors(_this3.getAllRetakes(siteId))]);\n      _this3.getLessonsFromEntries(lessons, pageAttempts || []);\n      _this3.getLessonsFromEntries(lessons, retakes || []);\n      return CoreUtils.objectToArray(lessons);\n    })();\n  }\n  /**\n   * Get all the offline retakes in a certain site.\n   *\n   * @param siteId Site ID. If not set, use current site.\n   * @returns Promise resolved when the offline retakes are retrieved.\n   */\n  getAllRetakes(siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      return db.getAllRecords(RETAKES_TABLE_NAME);\n    })();\n  }\n  /**\n   * Retrieve the last offline attempt stored in a retake.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Retake number.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the attempt (undefined if no attempts).\n   */\n  getLastQuestionPageAttempt(lessonId, retake, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      try {\n        const retakeData = yield _this4.getRetakeWithFallback(lessonId, 0, retake, siteId);\n        if (!retakeData.lastquestionpage) {\n          // No question page attempted.\n          return;\n        }\n        const attempts = yield _this4.getRetakeAttemptsForPage(lessonId, retake, retakeData.lastquestionpage, siteId);\n        // Return the attempt with highest timemodified.\n        return attempts.reduce((a, b) => a && a.timemodified > b.timemodified ? a : b, undefined);\n      } catch (_unused) {\n        // Error, return undefined.\n      }\n    })();\n  }\n  /**\n   * Retrieve all offline attempts for a lesson.\n   *\n   * @param lessonId Lesson ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the attempts.\n   */\n  getLessonAttempts(lessonId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const attempts = yield site.getDb().getRecords(PAGE_ATTEMPTS_TABLE_NAME, {\n        lessonid: lessonId\n      });\n      return _this5.parsePageAttempts(attempts);\n    })();\n  }\n  /**\n   * Given a list of DB entries (either retakes or page attempts), get the list of lessons.\n   *\n   * @param lessons Object where to store the lessons.\n   * @param entries List of DB entries.\n   */\n  getLessonsFromEntries(lessons, entries) {\n    entries.forEach(entry => {\n      if (!lessons[entry.lessonid]) {\n        lessons[entry.lessonid] = {\n          id: entry.lessonid,\n          courseId: entry.courseid\n        };\n      }\n    });\n  }\n  /**\n   * Get attempts for question pages and retake in a lesson.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Retake number.\n   * @param correct True to only fetch correct attempts, false to get them all.\n   * @param pageId If defined, only get attempts on this page.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the attempts.\n   */\n  getQuestionsAttempts(lessonId, retake, correct, pageId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const attempts = pageId ? yield _this6.getRetakeAttemptsForPage(lessonId, retake, pageId, siteId) : yield _this6.getRetakeAttemptsForType(lessonId, retake, AddonModLessonProvider.TYPE_QUESTION, siteId);\n      if (correct) {\n        return attempts.filter(attempt => !!attempt.correct);\n      }\n      return attempts;\n    })();\n  }\n  /**\n   * Retrieve a retake from site DB.\n   *\n   * @param lessonId Lesson ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the retake.\n   */\n  getRetake(lessonId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecord(RETAKES_TABLE_NAME, {\n        lessonid: lessonId\n      });\n    })();\n  }\n  /**\n   * Retrieve all offline attempts for a retake.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Retake number.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the retake attempts.\n   */\n  getRetakeAttempts(lessonId, retake, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const attempts = yield site.getDb().getRecords(PAGE_ATTEMPTS_TABLE_NAME, {\n        lessonid: lessonId,\n        retake\n      });\n      return _this7.parsePageAttempts(attempts);\n    })();\n  }\n  /**\n   * Retrieve offline attempts for a retake and page.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Lesson retake number.\n   * @param pageId Page ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the retake attempts.\n   */\n  getRetakeAttemptsForPage(lessonId, retake, pageId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const attempts = yield site.getDb().getRecords(PAGE_ATTEMPTS_TABLE_NAME, {\n        lessonid: lessonId,\n        retake,\n        pageid: pageId\n      });\n      return _this8.parsePageAttempts(attempts);\n    })();\n  }\n  /**\n   * Retrieve offline attempts for certain pages for a retake.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Retake number.\n   * @param type Type of the pages to get: TYPE_QUESTION or TYPE_STRUCTURE.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the retake attempts.\n   */\n  getRetakeAttemptsForType(lessonId, retake, type, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const attempts = yield site.getDb().getRecords(PAGE_ATTEMPTS_TABLE_NAME, {\n        lessonid: lessonId,\n        retake,\n        type\n      });\n      return _this9.parsePageAttempts(attempts);\n    })();\n  }\n  /**\n   * Get stored retake. If not found or doesn't match the retake number, return a new one.\n   *\n   * @param lessonId Lesson ID.\n   * @param courseId Course ID the lesson belongs to.\n   * @param retake Retake number.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the retake.\n   */\n  getRetakeWithFallback(lessonId, courseId, retake, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // Get current stored retake.\n        const retakeData = yield _this10.getRetake(lessonId, siteId);\n        if (retakeData.retake == retake) {\n          return retakeData;\n        }\n      } catch (_unused2) {\n        // No retake, create a new one.\n      }\n      // Create a new retake.\n      return {\n        lessonid: lessonId,\n        retake,\n        courseid: courseId,\n        finished: 0\n      };\n    })();\n  }\n  /**\n   * Check if there is a finished retake for a certain lesson.\n   *\n   * @param lessonId Lesson ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean.\n   */\n  hasFinishedRetake(lessonId, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const retake = yield _this11.getRetake(lessonId, siteId);\n        return !!retake.finished;\n      } catch (_unused3) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Check if a lesson has offline data.\n   *\n   * @param lessonId Lesson ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean.\n   */\n  hasOfflineData(lessonId, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const [retake, attempts] = yield Promise.all([CoreUtils.ignoreErrors(_this12.getRetake(lessonId, siteId)), CoreUtils.ignoreErrors(_this12.getLessonAttempts(lessonId, siteId))]);\n      return !!retake || !!(attempts !== null && attempts !== void 0 && attempts.length);\n    })();\n  }\n  /**\n   * Check if there are offline attempts for a retake.\n   *\n   * @param lessonId Lesson ID.\n   * @param retake Retake number.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with a boolean.\n   */\n  hasRetakeAttempts(lessonId, retake, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const list = yield _this13.getRetakeAttempts(lessonId, retake, siteId);\n        return !!list.length;\n      } catch (_unused4) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Parse some properties of a page attempt.\n   *\n   * @param attempt The attempt to treat.\n   * @returns The treated attempt.\n   */\n  parsePageAttempt(attempt) {\n    return _objectSpread(_objectSpread({}, attempt), {}, {\n      data: attempt.data ? CoreTextUtils.parseJSON(attempt.data) : null,\n      useranswer: attempt.useranswer ? CoreTextUtils.parseJSON(attempt.useranswer) : null\n    });\n  }\n  /**\n   * Parse some properties of some page attempts.\n   *\n   * @param attempts The attempts to treat.\n   * @returns The treated attempts.\n   */\n  parsePageAttempts(attempts) {\n    return attempts.map(attempt => this.parsePageAttempt(attempt));\n  }\n  /**\n   * Process a lesson page, saving its data.\n   *\n   * @param lessonId Lesson ID.\n   * @param courseId Course ID the lesson belongs to.\n   * @param retake Retake number.\n   * @param page Page.\n   * @param data Data to save.\n   * @param newPageId New page ID (calculated).\n   * @param answerId The answer ID that the user answered.\n   * @param correct If answer is correct. Only for question pages.\n   * @param userAnswer The user's answer (userresponse from checkAnswer).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  processPage(lessonId, courseId, retake, page, data, newPageId, answerId, correct, userAnswer, siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        lessonid: lessonId,\n        retake: retake,\n        pageid: page.id,\n        timemodified: CoreTimeUtils.timestamp(),\n        courseid: courseId,\n        data: data ? JSON.stringify(data) : null,\n        type: page.type,\n        newpageid: newPageId,\n        correct: correct ? 1 : 0,\n        answerid: answerId || null,\n        useranswer: userAnswer ? JSON.stringify(userAnswer) : null\n      };\n      yield site.getDb().insertRecord(PAGE_ATTEMPTS_TABLE_NAME, entry);\n      if (page.type == AddonModLessonProvider.TYPE_QUESTION) {\n        // It's a question page, set it as last question page attempted.\n        yield _this14.setLastQuestionPageAttempted(lessonId, courseId, retake, page.id, siteId);\n      }\n    })();\n  }\n  /**\n   * Set the last question page attempted in a retake.\n   *\n   * @param lessonId Lesson ID.\n   * @param courseId Course ID the lesson belongs to.\n   * @param retake Retake number.\n   * @param lastPage ID of the last question page attempted.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  setLastQuestionPageAttempted(lessonId, courseId, retake, lastPage, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // Get current stored retake (if any). If not found, it will create a new one.\n      const entry = yield _this15.getRetakeWithFallback(lessonId, courseId, retake, site.id);\n      entry.lastquestionpage = lastPage;\n      entry.timemodified = CoreTimeUtils.timestamp();\n      yield site.getDb().insertRecord(RETAKES_TABLE_NAME, entry);\n    })();\n  }\n}\n_class = AddonModLessonOfflineProvider;\n_class.ɵfac = function AddonModLessonOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModLessonOffline = makeSingleton(AddonModLessonOfflineProvider);","map":{"version":3,"names":["CoreSites","CoreTextUtils","CoreTimeUtils","CoreUtils","makeSingleton","PAGE_ATTEMPTS_TABLE_NAME","RETAKES_TABLE_NAME","AddonModLessonProvider","AddonModLessonOfflineProvider","deleteAttempt","lessonId","retake","pageId","timemodified","siteId","_asyncToGenerator","site","getSite","getDb","deleteRecords","lessonid","pageid","deleteRetake","deleteRetakeAttemptsForPage","finishRetake","courseId","finished","outOfTime","_this","entry","getRetakeWithFallback","id","outoftime","timestamp","insertRecord","getAllAttempts","_this2","db","getSiteDb","attempts","getAllRecords","parsePageAttempts","getAllLessonsWithData","_this3","lessons","pageAttempts","retakes","Promise","all","ignoreErrors","getAllRetakes","getLessonsFromEntries","objectToArray","getLastQuestionPageAttempt","_this4","getCurrentSiteId","retakeData","lastquestionpage","getRetakeAttemptsForPage","reduce","a","b","undefined","_unused","getLessonAttempts","_this5","getRecords","entries","forEach","courseid","getQuestionsAttempts","correct","_this6","getRetakeAttemptsForType","TYPE_QUESTION","filter","attempt","getRetake","getRecord","getRetakeAttempts","_this7","_this8","type","_this9","_this10","_unused2","hasFinishedRetake","_this11","_unused3","hasOfflineData","_this12","length","hasRetakeAttempts","_this13","list","_unused4","parsePageAttempt","_objectSpread","data","parseJSON","useranswer","map","processPage","page","newPageId","answerId","userAnswer","_this14","JSON","stringify","newpageid","answerid","setLastQuestionPageAttempted","lastPage","_this15","factory","ɵfac","providedIn","AddonModLessonOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/lesson/services/lesson-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { CoreFormFields } from '@singletons/form';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport {\n    AddonModLessonPageAttemptDBRecord,\n    AddonModLessonRetakeDBRecord,\n    PAGE_ATTEMPTS_TABLE_NAME,\n    RETAKES_TABLE_NAME,\n} from './database/lesson';\n\nimport { AddonModLessonPageWSData, AddonModLessonProvider } from './lesson';\n\n/**\n * Service to handle offline lesson.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModLessonOfflineProvider {\n\n    /**\n     * Delete an offline attempt.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Lesson retake number.\n     * @param pageId Page ID.\n     * @param timemodified The timemodified of the attempt.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteAttempt(lessonId: number, retake: number, pageId: number, timemodified: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(PAGE_ATTEMPTS_TABLE_NAME, <Partial<AddonModLessonPageAttemptDBRecord>> {\n            lessonid: lessonId,\n            retake: retake,\n            pageid: pageId,\n            timemodified: timemodified,\n        });\n    }\n\n    /**\n     * Delete offline lesson retake.\n     *\n     * @param lessonId Lesson ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteRetake(lessonId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(RETAKES_TABLE_NAME, <Partial<AddonModLessonRetakeDBRecord>> { lessonid: lessonId });\n    }\n\n    /**\n     * Delete offline attempts for a retake and page.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Lesson retake number.\n     * @param pageId Page ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteRetakeAttemptsForPage(lessonId: number, retake: number, pageId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(PAGE_ATTEMPTS_TABLE_NAME, <Partial<AddonModLessonPageAttemptDBRecord>> {\n            lessonid: lessonId,\n            retake: retake,\n            pageid: pageId,\n        });\n    }\n\n    /**\n     * Mark a retake as finished.\n     *\n     * @param lessonId Lesson ID.\n     * @param courseId Course ID the lesson belongs to.\n     * @param retake Retake number.\n     * @param finished Whether retake is finished.\n     * @param outOfTime If the user ran out of time.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    async finishRetake(\n        lessonId: number,\n        courseId: number,\n        retake: number,\n        finished?: boolean,\n        outOfTime?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        // Get current stored retake (if any). If not found, it will create a new one.\n        const entry = await this.getRetakeWithFallback(lessonId, courseId, retake, site.id);\n\n        entry.finished = finished ? 1 : 0;\n        entry.outoftime = outOfTime ? 1 : 0;\n        entry.timemodified = CoreTimeUtils.timestamp();\n\n        await site.getDb().insertRecord(RETAKES_TABLE_NAME, entry);\n    }\n\n    /**\n     * Get all the offline page attempts in a certain site.\n     *\n     * @param siteId Site ID. If not set, use current site.\n     * @returns Promise resolved when the offline attempts are retrieved.\n     */\n    async getAllAttempts(siteId?: string): Promise<AddonModLessonPageAttemptRecord[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        const attempts = await db.getAllRecords<AddonModLessonPageAttemptDBRecord>(PAGE_ATTEMPTS_TABLE_NAME);\n\n        return this.parsePageAttempts(attempts);\n    }\n\n    /**\n     * Get all the lessons that have offline data in a certain site.\n     *\n     * @param siteId Site ID. If not set, use current site.\n     * @returns Promise resolved with an object containing the lessons.\n     */\n    async getAllLessonsWithData(siteId?: string): Promise<AddonModLessonLessonStoredData[]> {\n        const lessons: Record<number, AddonModLessonLessonStoredData> = {};\n\n        const [pageAttempts, retakes] = await Promise.all([\n            CoreUtils.ignoreErrors(this.getAllAttempts(siteId)),\n            CoreUtils.ignoreErrors(this.getAllRetakes(siteId)),\n        ]);\n\n        this.getLessonsFromEntries(lessons, pageAttempts || []);\n        this.getLessonsFromEntries(lessons, retakes || []);\n\n        return CoreUtils.objectToArray(lessons);\n    }\n\n    /**\n     * Get all the offline retakes in a certain site.\n     *\n     * @param siteId Site ID. If not set, use current site.\n     * @returns Promise resolved when the offline retakes are retrieved.\n     */\n    async getAllRetakes(siteId?: string): Promise<AddonModLessonRetakeDBRecord[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        return db.getAllRecords(RETAKES_TABLE_NAME);\n    }\n\n    /**\n     * Retrieve the last offline attempt stored in a retake.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Retake number.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the attempt (undefined if no attempts).\n     */\n    async getLastQuestionPageAttempt(\n        lessonId: number,\n        retake: number,\n        siteId?: string,\n    ): Promise<AddonModLessonPageAttemptRecord | undefined> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        try {\n            const retakeData = await this.getRetakeWithFallback(lessonId, 0, retake, siteId);\n            if (!retakeData.lastquestionpage) {\n                // No question page attempted.\n                return;\n            }\n\n            const attempts = await this.getRetakeAttemptsForPage(lessonId, retake, retakeData.lastquestionpage, siteId);\n\n            // Return the attempt with highest timemodified.\n            return attempts.reduce(\n                (a, b) => a && a.timemodified > b.timemodified ? a : b,\n                <AddonModLessonPageAttemptRecord | undefined> undefined,\n            );\n        } catch {\n            // Error, return undefined.\n        }\n    }\n\n    /**\n     * Retrieve all offline attempts for a lesson.\n     *\n     * @param lessonId Lesson ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the attempts.\n     */\n    async getLessonAttempts(lessonId: number, siteId?: string): Promise<AddonModLessonPageAttemptRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const attempts = await site.getDb().getRecords<AddonModLessonPageAttemptDBRecord>(\n            PAGE_ATTEMPTS_TABLE_NAME,\n            { lessonid: lessonId },\n        );\n\n        return this.parsePageAttempts(attempts);\n    }\n\n    /**\n     * Given a list of DB entries (either retakes or page attempts), get the list of lessons.\n     *\n     * @param lessons Object where to store the lessons.\n     * @param entries List of DB entries.\n     */\n    protected getLessonsFromEntries(\n        lessons: Record<number, AddonModLessonLessonStoredData>,\n        entries: (AddonModLessonPageAttemptRecord | AddonModLessonRetakeDBRecord)[],\n    ): void {\n        entries.forEach((entry) => {\n            if (!lessons[entry.lessonid]) {\n                lessons[entry.lessonid] = {\n                    id: entry.lessonid,\n                    courseId: entry.courseid,\n                };\n            }\n        });\n    }\n\n    /**\n     * Get attempts for question pages and retake in a lesson.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Retake number.\n     * @param correct True to only fetch correct attempts, false to get them all.\n     * @param pageId If defined, only get attempts on this page.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the attempts.\n     */\n    async getQuestionsAttempts(\n        lessonId: number,\n        retake: number,\n        correct?: boolean,\n        pageId?: number,\n        siteId?: string,\n    ): Promise<AddonModLessonPageAttemptRecord[]> {\n        const attempts = pageId ?\n            await this.getRetakeAttemptsForPage(lessonId, retake, pageId, siteId) :\n            await this.getRetakeAttemptsForType(lessonId, retake, AddonModLessonProvider.TYPE_QUESTION, siteId);\n\n        if (correct) {\n            return attempts.filter((attempt) => !!attempt.correct);\n        }\n\n        return attempts;\n    }\n\n    /**\n     * Retrieve a retake from site DB.\n     *\n     * @param lessonId Lesson ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the retake.\n     */\n    async getRetake(lessonId: number, siteId?: string): Promise<AddonModLessonRetakeDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecord(RETAKES_TABLE_NAME, { lessonid: lessonId });\n    }\n\n    /**\n     * Retrieve all offline attempts for a retake.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Retake number.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the retake attempts.\n     */\n    async getRetakeAttempts(lessonId: number, retake: number, siteId?: string): Promise<AddonModLessonPageAttemptRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const attempts = await site.getDb().getRecords<AddonModLessonPageAttemptDBRecord>(\n            PAGE_ATTEMPTS_TABLE_NAME,\n            <Partial<AddonModLessonPageAttemptDBRecord>> {\n                lessonid: lessonId,\n                retake,\n            },\n        );\n\n        return this.parsePageAttempts(attempts);\n    }\n\n    /**\n     * Retrieve offline attempts for a retake and page.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Lesson retake number.\n     * @param pageId Page ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the retake attempts.\n     */\n    async getRetakeAttemptsForPage(\n        lessonId: number,\n        retake: number,\n        pageId: number,\n        siteId?: string,\n    ): Promise<AddonModLessonPageAttemptRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const attempts = await site.getDb().getRecords<AddonModLessonPageAttemptDBRecord>(\n            PAGE_ATTEMPTS_TABLE_NAME,\n            <Partial<AddonModLessonPageAttemptDBRecord>> {\n                lessonid: lessonId,\n                retake,\n                pageid: pageId,\n            },\n        );\n\n        return this.parsePageAttempts(attempts);\n    }\n\n    /**\n     * Retrieve offline attempts for certain pages for a retake.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Retake number.\n     * @param type Type of the pages to get: TYPE_QUESTION or TYPE_STRUCTURE.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the retake attempts.\n     */\n    async getRetakeAttemptsForType(\n        lessonId: number,\n        retake: number,\n        type: number,\n        siteId?: string,\n    ): Promise<AddonModLessonPageAttemptRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const attempts = await site.getDb().getRecords<AddonModLessonPageAttemptDBRecord>(\n            PAGE_ATTEMPTS_TABLE_NAME,\n            <Partial<AddonModLessonPageAttemptDBRecord>> {\n                lessonid: lessonId,\n                retake,\n                type,\n            },\n        );\n\n        return this.parsePageAttempts(attempts);\n    }\n\n    /**\n     * Get stored retake. If not found or doesn't match the retake number, return a new one.\n     *\n     * @param lessonId Lesson ID.\n     * @param courseId Course ID the lesson belongs to.\n     * @param retake Retake number.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the retake.\n     */\n    protected async getRetakeWithFallback(\n        lessonId: number,\n        courseId: number,\n        retake: number,\n        siteId?: string,\n    ): Promise<AddonModLessonRetakeDBRecord> {\n        try {\n            // Get current stored retake.\n            const retakeData = await this.getRetake(lessonId, siteId);\n\n            if (retakeData.retake == retake) {\n                return retakeData;\n            }\n        } catch {\n            // No retake, create a new one.\n        }\n\n        // Create a new retake.\n        return {\n            lessonid: lessonId,\n            retake,\n            courseid: courseId,\n            finished: 0,\n        };\n    }\n\n    /**\n     * Check if there is a finished retake for a certain lesson.\n     *\n     * @param lessonId Lesson ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean.\n     */\n    async hasFinishedRetake(lessonId: number, siteId?: string): Promise<boolean> {\n        try {\n            const retake = await this.getRetake(lessonId, siteId);\n\n            return !!retake.finished;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Check if a lesson has offline data.\n     *\n     * @param lessonId Lesson ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean.\n     */\n    async hasOfflineData(lessonId: number, siteId?: string): Promise<boolean> {\n        const [retake, attempts] = await Promise.all([\n            CoreUtils.ignoreErrors(this.getRetake(lessonId, siteId)),\n            CoreUtils.ignoreErrors(this.getLessonAttempts(lessonId, siteId)),\n        ]);\n\n        return !!retake || !!attempts?.length;\n    }\n\n    /**\n     * Check if there are offline attempts for a retake.\n     *\n     * @param lessonId Lesson ID.\n     * @param retake Retake number.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with a boolean.\n     */\n    async hasRetakeAttempts(lessonId: number, retake: number, siteId?: string): Promise<boolean> {\n        try {\n            const list = await this.getRetakeAttempts(lessonId, retake, siteId);\n\n            return !!list.length;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Parse some properties of a page attempt.\n     *\n     * @param attempt The attempt to treat.\n     * @returns The treated attempt.\n     */\n    protected parsePageAttempt(attempt: AddonModLessonPageAttemptDBRecord): AddonModLessonPageAttemptRecord {\n        return {\n            ...attempt,\n            data: attempt.data ? CoreTextUtils.parseJSON(attempt.data) : null,\n            useranswer: attempt.useranswer ? CoreTextUtils.parseJSON(attempt.useranswer) : null,\n        };\n    }\n\n    /**\n     * Parse some properties of some page attempts.\n     *\n     * @param attempts The attempts to treat.\n     * @returns The treated attempts.\n     */\n    protected parsePageAttempts(attempts: AddonModLessonPageAttemptDBRecord[]): AddonModLessonPageAttemptRecord[] {\n        return attempts.map((attempt) => this.parsePageAttempt(attempt));\n    }\n\n    /**\n     * Process a lesson page, saving its data.\n     *\n     * @param lessonId Lesson ID.\n     * @param courseId Course ID the lesson belongs to.\n     * @param retake Retake number.\n     * @param page Page.\n     * @param data Data to save.\n     * @param newPageId New page ID (calculated).\n     * @param answerId The answer ID that the user answered.\n     * @param correct If answer is correct. Only for question pages.\n     * @param userAnswer The user's answer (userresponse from checkAnswer).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    async processPage(\n        lessonId: number,\n        courseId: number,\n        retake: number,\n        page: AddonModLessonPageWSData,\n        data: CoreFormFields,\n        newPageId: number,\n        answerId?: number,\n        correct?: boolean,\n        userAnswer?: unknown,\n        siteId?: string,\n    ): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const entry: AddonModLessonPageAttemptDBRecord = {\n            lessonid: lessonId,\n            retake: retake,\n            pageid: page.id,\n            timemodified: CoreTimeUtils.timestamp(),\n            courseid: courseId,\n            data: data ? JSON.stringify(data) : null,\n            type: page.type,\n            newpageid: newPageId,\n            correct: correct ? 1 : 0,\n            answerid: answerId || null,\n            useranswer: userAnswer ? JSON.stringify(userAnswer) : null,\n        };\n\n        await site.getDb().insertRecord(PAGE_ATTEMPTS_TABLE_NAME, entry);\n\n        if (page.type == AddonModLessonProvider.TYPE_QUESTION) {\n            // It's a question page, set it as last question page attempted.\n            await this.setLastQuestionPageAttempted(lessonId, courseId, retake, page.id, siteId);\n        }\n    }\n\n    /**\n     * Set the last question page attempted in a retake.\n     *\n     * @param lessonId Lesson ID.\n     * @param courseId Course ID the lesson belongs to.\n     * @param retake Retake number.\n     * @param lastPage ID of the last question page attempted.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    async setLastQuestionPageAttempted(\n        lessonId: number,\n        courseId: number,\n        retake: number,\n        lastPage: number,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        // Get current stored retake (if any). If not found, it will create a new one.\n        const entry = await this.getRetakeWithFallback(lessonId, courseId, retake, site.id);\n\n        entry.lastquestionpage = lastPage;\n        entry.timemodified = CoreTimeUtils.timestamp();\n\n        await site.getDb().insertRecord(RETAKES_TABLE_NAME, entry);\n    }\n\n}\n\nexport const AddonModLessonOffline = makeSingleton(AddonModLessonOfflineProvider);\n\n/**\n * Attempt DB record with parsed data.\n */\nexport type AddonModLessonPageAttemptRecord = Omit<AddonModLessonPageAttemptDBRecord, 'data'|'useranswer'> & {\n    data: CoreFormFields | null;\n    useranswer: unknown | null;\n};\n\n/**\n * Lesson data stored in DB.\n */\nexport type AddonModLessonLessonStoredData = {\n    id: number;\n    courseId: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}