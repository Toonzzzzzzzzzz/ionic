{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport moment from 'moment-timezone';\nimport { CoreSites } from '@services/sites';\nimport { CoreCourse, CoreCourseProvider, CoreCourseModuleCompletionTracking, CoreCourseModuleCompletionStatus } from './course';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreLogger } from '@singletons/logger';\nimport { ApplicationInit, makeSingleton, Translate } from '@singletons';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreArray } from '@singletons/array';\nimport { CoreCourseOffline } from './course-offline';\nimport { CoreCourseOptionsDelegate } from './course-options-delegate';\nimport { CoreCourseModuleDelegate } from './module-delegate';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseModulePrefetchDelegate } from './module-prefetch-delegate';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile } from '@services/file';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreFilterHelper } from '@features/filter/services/filter-helper';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreSiteHome } from '@features/sitehome/services/sitehome';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreSiteHomeHomeHandlerService } from '@features/sitehome/services/handlers/sitehome-home';\nimport { CoreCourseSummaryPage } from '../pages/course-summary/course-summary.page';\nimport { CoreLocalNotifications } from '@services/local-notifications';\nimport { CoreEnrol } from '@features/enrol/services/enrol';\nimport { CoreEnrolAction, CoreEnrolDelegate } from '@features/enrol/services/enrol-delegate';\nimport * as i0 from \"@angular/core\";\n/**\n * Helper to gather some common course functions.\n */\nexport class CoreCourseHelperProvider {\n  constructor() {\n    this.courseDwnPromises = {};\n    this.logger = CoreLogger.getInstance('CoreCourseHelperProvider');\n  }\n  /**\n   * This function treats every module on the sections provided to load the handler data, treat completion\n   * and navigate to a module page if required. It also returns if sections has content.\n   *\n   * @param sections List of sections to treat modules.\n   * @param courseId Course ID of the modules.\n   * @param completionStatus List of completion status.\n   * @param courseName Not used since 4.0\n   * @param forCoursePage Whether the data will be used to render the course page.\n   * @returns Whether the sections have content.\n   */\n  addHandlerDataForModules(sections, courseId, completionStatus, courseName, forCoursePage = false) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let hasContent = false;\n      const formattedSections = yield Promise.all(sections.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (courseSection) {\n          const section = _objectSpread(_objectSpread({}, courseSection), {}, {\n            hasContent: _this.sectionHasContent(courseSection)\n          });\n          if (!section.hasContent) {\n            return section;\n          }\n          hasContent = true;\n          yield Promise.all(section.modules.map( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (module) {\n              module.handlerData = yield CoreCourseModuleDelegate.getModuleDataFor(module.modname, module, courseId, section.id, forCoursePage);\n              if (!module.completiondata && completionStatus && completionStatus[module.id] !== undefined) {\n                // Should not happen on > 3.6. Check if activity has completions and if it's marked.\n                const activityStatus = completionStatus[module.id];\n                module.completiondata = {\n                  state: activityStatus.state,\n                  timecompleted: activityStatus.timecompleted,\n                  overrideby: activityStatus.overrideby || 0,\n                  valueused: activityStatus.valueused,\n                  tracking: activityStatus.tracking,\n                  courseId,\n                  cmid: module.id\n                };\n              }\n              // Check if the module is stealth.\n              module.isStealth = CoreCourseHelper.isModuleStealth(module, section);\n            });\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }()));\n          return section;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return {\n        hasContent,\n        sections: formattedSections\n      };\n    })();\n  }\n  /**\n   * Module is stealth.\n   *\n   * @param module Module to check.\n   * @param section Section to check.\n   * @returns Wether the module is stealth.\n   */\n  isModuleStealth(module, section) {\n    // visibleoncoursepage can be 1 for teachers when the section is hidden.\n    return !!module.visible && (!module.visibleoncoursepage || !!section && !section.visible);\n  }\n  /**\n   * Module is visible by the user.\n   *\n   * @param module Module to check.\n   * @param section Section to check. Omitted if not defined.\n   * @returns Wether the section is visible by the user.\n   */\n  canUserViewModule(module, section) {\n    return module.uservisible !== false && (!section || CoreCourseHelper.canUserViewSection(section));\n  }\n  /**\n   * Section is stealth.\n   * This should not be true on Moodle 4.0 onwards.\n   *\n   * @param section Section to check.\n   * @returns Wether section is stealth (accessible but not visible to students).\n   */\n  isSectionStealth(section) {\n    return section.hiddenbynumsections === 1 || section.id === CoreCourseProvider.STEALTH_MODULES_SECTION_ID;\n  }\n  /**\n   * Section is visible by the user.\n   *\n   * @param section Section to check.\n   * @returns Wether the section is visible by the user.\n   */\n  canUserViewSection(section) {\n    return section.uservisible !== false;\n  }\n  /**\n   * Calculate the status of a section.\n   *\n   * @param section Section to calculate its status. It can't be \"All sections\".\n   * @param courseId Course ID the section belongs to.\n   * @param refresh True if it shouldn't use module status cache (slower).\n   * @param checkUpdates Whether to use the WS to check updates. Defaults to true.\n   * @returns Promise resolved when the status is calculated.\n   */\n  calculateSectionStatus(section, courseId, refresh, checkUpdates = true) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (section.id == CoreCourseProvider.ALL_SECTIONS_ID) {\n        throw new CoreError('Invalid section');\n      }\n      const sectionWithStatus = section;\n      // Get the status of this section.\n      const result = yield CoreCourseModulePrefetchDelegate.getModulesStatus(section.modules, courseId, section.id, refresh, true, checkUpdates);\n      // Check if it's being downloaded.\n      const downloadId = _this2.getSectionDownloadId(section);\n      if (CoreCourseModulePrefetchDelegate.isBeingDownloaded(downloadId)) {\n        result.status = CoreConstants.DOWNLOADING;\n      }\n      sectionWithStatus.downloadStatus = result.status;\n      // Set this section data.\n      if (result.status !== CoreConstants.DOWNLOADING) {\n        sectionWithStatus.isDownloading = false;\n        sectionWithStatus.total = 0;\n      } else {\n        // Section is being downloaded.\n        sectionWithStatus.isDownloading = true;\n        CoreCourseModulePrefetchDelegate.setOnProgress(downloadId, data => {\n          sectionWithStatus.count = data.count;\n          sectionWithStatus.total = data.total;\n        });\n      }\n      return {\n        statusData: result,\n        section: sectionWithStatus\n      };\n    })();\n  }\n  /**\n   * Calculate the status of a list of sections, setting attributes to determine the icons/data to be shown.\n   *\n   * @param sections Sections to calculate their status.\n   * @param courseId Course ID the sections belong to.\n   * @param refresh True if it shouldn't use module status cache (slower).\n   * @param checkUpdates Whether to use the WS to check updates. Defaults to true.\n   * @returns Promise resolved when the states are calculated.\n   */\n  calculateSectionsStatus(sections, courseId, refresh, checkUpdates = true) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      let allSectionsSection;\n      let allSectionsStatus = CoreConstants.NOT_DOWNLOADABLE;\n      const promises = sections.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (section) {\n          section.isCalculating = true;\n          if (section.id === CoreCourseProvider.ALL_SECTIONS_ID) {\n            // \"All sections\" section status is calculated using the status of the rest of sections.\n            allSectionsSection = section;\n            return;\n          }\n          try {\n            const result = yield _this3.calculateSectionStatus(section, courseId, refresh, checkUpdates);\n            // Calculate \"All sections\" status.\n            allSectionsStatus = CoreFilepool.determinePackagesStatus(allSectionsStatus, result.statusData.status);\n          } finally {\n            section.isCalculating = false;\n          }\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }());\n      try {\n        yield Promise.all(promises);\n        if (allSectionsSection) {\n          // Set \"All sections\" data.\n          allSectionsSection.downloadStatus = allSectionsStatus;\n          allSectionsSection.isDownloading = allSectionsStatus === CoreConstants.DOWNLOADING;\n        }\n        return sections;\n      } finally {\n        if (allSectionsSection) {\n          allSectionsSection.isCalculating = false;\n        }\n      }\n    })();\n  }\n  /**\n   * Show a confirm and prefetch a course. It will retrieve the sections and the course options if not provided.\n   * This function will set the icon to \"spinner\" when starting and it will also set it back to the initial icon if the\n   * user cancels. All the other updates of the icon should be made when CoreEvents.COURSE_STATUS_CHANGED is received.\n   *\n   * @param data An object where to store the course icon and title: \"prefetchCourseIcon\", \"title\" and \"downloadSucceeded\".\n   * @param course Course to prefetch.\n   * @param options Other options.\n   * @returns Promise resolved when the download finishes, rejected if an error occurs or the user cancels.\n   */\n  confirmAndPrefetchCourse(data, course, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const initialIcon = data.icon;\n      const initialStatus = data.status;\n      const initialStatusTranslatable = data.statusTranslatable;\n      const siteId = CoreSites.getCurrentSiteId();\n      data.downloadSucceeded = false;\n      data.icon = CoreConstants.ICON_DOWNLOADING;\n      data.status = CoreConstants.DOWNLOADING;\n      data.loading = true;\n      data.statusTranslatable = 'core.downloading';\n      try {\n        // Get the sections first if needed.\n        if (!options.sections) {\n          options.sections = yield CoreCourse.getSections(course.id, false, true);\n        }\n        // Confirm the download.\n        yield _this4.confirmDownloadSizeSection(course.id, undefined, options.sections, true);\n        // User confirmed, get the course handlers if needed.\n        if (!options.courseHandlers) {\n          options.courseHandlers = yield CoreCourseOptionsDelegate.getHandlersToDisplay(course, false, options.isGuest);\n        }\n        if (!options.menuHandlers) {\n          options.menuHandlers = yield CoreCourseOptionsDelegate.getMenuHandlersToDisplay(course, false, options.isGuest);\n        }\n        // Now we have all the data, download the course.\n        yield _this4.prefetchCourse(course, options.sections, options.courseHandlers, options.menuHandlers, siteId);\n        // Download successful.\n        data.downloadSucceeded = true;\n        data.loading = false;\n      } catch (error) {\n        // User cancelled or there was an error.\n        data.icon = initialIcon;\n        data.status = initialStatus;\n        data.statusTranslatable = initialStatusTranslatable;\n        data.loading = false;\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Confirm and prefetches a list of courses.\n   *\n   * @param courses List of courses to download.\n   * @param options Other options.\n   * @returns Resolved when downloaded, rejected if error or canceled.\n   */\n  confirmAndPrefetchCourses(courses, options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const siteId = CoreSites.getCurrentSiteId();\n      // Confirm the download without checking size because it could take a while.\n      yield CoreDomUtils.showConfirm(Translate.instant('core.areyousure'), Translate.instant('core.courses.downloadcourses'));\n      const total = courses.length;\n      let count = 0;\n      const promises = courses.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (course) {\n          const subPromises = [];\n          let sections;\n          let handlers = [];\n          let menuHandlers = [];\n          let success = true;\n          // Get the sections and the handlers.\n          subPromises.push(CoreCourse.getSections(course.id, false, true).then(courseSections => {\n            sections = courseSections;\n            return;\n          }));\n          subPromises.push(CoreCourseOptionsDelegate.getHandlersToDisplay(course, false).then(cHandlers => {\n            handlers = cHandlers;\n            return;\n          }));\n          subPromises.push(CoreCourseOptionsDelegate.getMenuHandlersToDisplay(course, false).then(mHandlers => {\n            menuHandlers = mHandlers;\n            return;\n          }));\n          return Promise.all(subPromises).then(() => _this5.prefetchCourse(course, sections, handlers, menuHandlers, siteId)).catch(error => {\n            success = false;\n            throw error;\n          }).finally(() => {\n            // Course downloaded or failed, notify the progress.\n            count++;\n            if (options.onProgress) {\n              options.onProgress({\n                count: count,\n                total: total,\n                courseId: course.id,\n                success: success\n              });\n            }\n          });\n        });\n        return function (_x4) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n      if (options.onProgress) {\n        // Notify the start of the download.\n        options.onProgress({\n          count: 0,\n          total: total,\n          success: true\n        });\n      }\n      return CoreUtils.allPromises(promises);\n    })();\n  }\n  /**\n   * Calculate the size to download a section and show a confirm modal if needed.\n   *\n   * @param courseId Course ID the section belongs to.\n   * @param section Section. If not provided, all sections.\n   * @param sections List of sections. Used when downloading all the sections.\n   * @param alwaysConfirm True to show a confirm even if the size isn't high, false otherwise.\n   * @returns Promise resolved if the user confirms or there's no need to confirm.\n   */\n  confirmDownloadSizeSection(courseId, section, sections, alwaysConfirm) {\n    return _asyncToGenerator(function* () {\n      let hasEmbeddedFiles = false;\n      let sizeSum = {\n        size: 0,\n        total: true\n      };\n      // Calculate the size of the download.\n      if (section && section.id != CoreCourseProvider.ALL_SECTIONS_ID) {\n        sizeSum = yield CoreCourseModulePrefetchDelegate.getDownloadSize(section.modules, courseId);\n        // Check if the section has embedded files in the description.\n        hasEmbeddedFiles = CoreFilepool.extractDownloadableFilesFromHtml(section.summary).length > 0;\n      } else if (sections) {\n        yield Promise.all(sections.map( /*#__PURE__*/function () {\n          var _ref5 = _asyncToGenerator(function* (section) {\n            if (section.id == CoreCourseProvider.ALL_SECTIONS_ID) {\n              return;\n            }\n            const sectionSize = yield CoreCourseModulePrefetchDelegate.getDownloadSize(section.modules, courseId);\n            sizeSum.total = sizeSum.total && sectionSize.total;\n            sizeSum.size += sectionSize.size;\n            // Check if the section has embedded files in the description.\n            if (!hasEmbeddedFiles && CoreFilepool.extractDownloadableFilesFromHtml(section.summary).length > 0) {\n              hasEmbeddedFiles = true;\n            }\n          });\n          return function (_x5) {\n            return _ref5.apply(this, arguments);\n          };\n        }()));\n      } else {\n        throw new CoreError('Either section or list of sections needs to be supplied.');\n      }\n      if (hasEmbeddedFiles) {\n        sizeSum.total = false;\n      }\n      // Show confirm modal if needed.\n      yield CoreDomUtils.confirmDownloadSize(sizeSum, undefined, undefined, undefined, undefined, alwaysConfirm);\n    })();\n  }\n  /**\n   * Check whether a course is accessed using guest access and if it requires user input to enter.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Data about guest access info.\n   */\n  courseUsesGuestAccessInfo(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const accessData = {\n        guestAccess: false\n      };\n      try {\n        try {\n          // Check if user is enrolled. If enrolled, no guest access.\n          yield CoreCourses.getUserCourse(courseId, false, siteId);\n          return accessData;\n        } catch (_unused) {\n          // Ignore errors.\n        }\n        try {\n          // The user is not enrolled in the course. Use getCourses to see if it's an admin/manager and can see the course.\n          yield CoreCourses.getCourse(courseId, siteId);\n          return accessData;\n        } catch (_unused2) {\n          // Ignore errors.\n        }\n        // Check if guest access is enabled.\n        const enrolmentMethods = yield CoreEnrol.getSupportedCourseEnrolmentMethods(courseId, {\n          action: CoreEnrolAction.GUEST,\n          siteId\n        });\n        if (!enrolmentMethods) {\n          return accessData;\n        }\n        const results = yield Promise.all(enrolmentMethods.map(method => CoreEnrolDelegate.canAccess(method)));\n        results.forEach(result => {\n          accessData.guestAccess = accessData.guestAccess || result.canAccess;\n          if (accessData.requiresUserInput !== false && result.canAccess) {\n            var _result$requiresUserI;\n            accessData.requiresUserInput = (_result$requiresUserI = result.requiresUserInput) !== null && _result$requiresUserI !== void 0 ? _result$requiresUserI : accessData.requiresUserInput;\n          }\n        });\n        // eslint-disable-next-line deprecation/deprecation\n        accessData.passwordRequired = accessData.requiresUserInput; // For backwards compatibility.\n        return accessData;\n      } catch (_unused3) {\n        return accessData;\n      }\n    })();\n  }\n  /**\n   * Create and return a section for \"All sections\".\n   *\n   * @returns Created section.\n   */\n  createAllSectionsSection() {\n    return {\n      id: CoreCourseProvider.ALL_SECTIONS_ID,\n      name: Translate.instant('core.course.allsections'),\n      hasContent: true,\n      summary: '',\n      summaryformat: 1,\n      modules: []\n    };\n  }\n  /**\n   * Determine the status of a list of courses.\n   *\n   * @param courses Courses\n   * @returns Promise resolved with the status.\n   */\n  determineCoursesStatus(courses) {\n    return _asyncToGenerator(function* () {\n      // Get the status of each course.\n      const promises = [];\n      const siteId = CoreSites.getCurrentSiteId();\n      courses.forEach(course => {\n        promises.push(CoreCourse.getCourseStatus(course.id, siteId));\n      });\n      const statuses = yield Promise.all(promises);\n      // Now determine the status of the whole list.\n      let status = statuses[0];\n      const filepool = CoreFilepool.instance;\n      for (let i = 1; i < statuses.length; i++) {\n        status = filepool.determinePackagesStatus(status, statuses[i]);\n      }\n      return status;\n    })();\n  }\n  /**\n   * Convenience function to open a module main file, downloading the package if needed.\n   * This is meant for modules like mod_resource.\n   *\n   * @param module The module to download.\n   * @param courseId The course ID of the module.\n   * @param component The component to link the files to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param files List of files of the module. If not provided, use module.contents.\n   * @param siteId The site ID. If not defined, current site.\n   * @param options Options to open the file.\n   * @returns Resolved on success.\n   */\n  downloadModuleAndOpenFile(module, courseId, component, componentId, files, siteId, options = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!files || !files.length) {\n        // Try to use module contents.\n        files = yield CoreCourse.getModuleContents(module);\n      }\n      if (!files.length) {\n        throw new CoreError(Translate.instant('core.filenotfound'));\n      }\n      const mainFile = files[0];\n      if (!CoreFileHelper.isOpenableInApp(mainFile)) {\n        yield CoreFileHelper.showConfirmOpenUnsupportedFile(false, mainFile);\n      }\n      const site = yield CoreSites.getSite(siteId);\n      // Check if the file should be opened in browser.\n      if (CoreFileHelper.shouldOpenInBrowser(mainFile)) {\n        return _this6.openModuleFileInBrowser(mainFile.fileurl, site, module, courseId, component, componentId, files, options);\n      }\n      // File shouldn't be opened in browser. Download the module if it needs to be downloaded.\n      const result = yield _this6.downloadModuleWithMainFileIfNeeded(module, courseId, component || '', componentId, files, siteId, options);\n      if (CoreUrlUtils.isLocalFileUrl(result.path)) {\n        return CoreUtils.openFile(result.path, options);\n      }\n      /* In iOS, if we use the same URL in embedded browser and background download then the download only\n      downloads a few bytes (cached ones). Add a hash to the URL so both URLs are different. */\n      result.path = result.path + '#moodlemobile-embedded';\n      try {\n        yield CoreUtils.openOnlineFile(result.path);\n      } catch (error) {\n        // Error opening the file, some apps don't allow opening online files.\n        if (!CoreFile.isAvailable()) {\n          throw error;\n        } else if (result.status === CoreConstants.DOWNLOADING) {\n          throw new CoreError(Translate.instant('core.erroropenfiledownloading'));\n        }\n        let path;\n        if (result.status === CoreConstants.NOT_DOWNLOADED) {\n          // Not downloaded, download it now and return the local file.\n          yield _this6.downloadModule(module, courseId, component, componentId, files, siteId);\n          path = yield CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n        } else {\n          // File is outdated or stale and can't be opened in online, return the local URL.\n          path = yield CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n        }\n        yield CoreUtils.openFile(path, options);\n      }\n    })();\n  }\n  /**\n   * Convenience function to open a module main file in case it needs to be opened in browser.\n   *\n   * @param fileUrl URL of the main file.\n   * @param site Site instance.\n   * @param module The module to download.\n   * @param courseId The course ID of the module.\n   * @param component The component to link the files to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param files List of files of the module. If not provided, use module.contents.\n   * @param options Options to open the file. Only used if not opened in browser.\n   * @returns Resolved on success.\n   */\n  openModuleFileInBrowser(fileUrl, site, module, courseId, component, componentId, files, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreNetwork.isOnline()) {\n        // Not online, get the offline file. It will fail if not found.\n        let path;\n        try {\n          path = yield CoreFilepool.getInternalUrlByUrl(site.getId(), fileUrl);\n        } catch (_unused4) {\n          throw new CoreNetworkError();\n        }\n        return CoreUtils.openFile(path, options);\n      }\n      // Open in browser.\n      let fixedUrl = yield site.checkAndFixPluginfileURL(fileUrl);\n      fixedUrl = fixedUrl.replace('&offline=1', '');\n      // Remove forcedownload when followed by another param.\n      fixedUrl = fixedUrl.replace(/forcedownload=\\d+&/, '');\n      // Remove forcedownload when not followed by any param.\n      fixedUrl = fixedUrl.replace(/[?|&]forcedownload=\\d+/, '');\n      CoreUtils.openInBrowser(fixedUrl);\n      if (CoreFile.isAvailable()) {\n        // Download the file if needed (file outdated or not downloaded).\n        // Download will be in background, don't return the promise.\n        _this7.downloadModule(module, courseId, component, componentId, files, site.getId());\n      }\n    })();\n  }\n  /**\n   * Convenience function to download a module that has a main file and return the local file's path and other info.\n   * This is meant for modules like mod_resource.\n   *\n   * @param module The module to download.\n   * @param courseId The course ID of the module.\n   * @param component The component to link the files to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param files List of files of the module. If not provided, use module.contents.\n   * @param siteId The site ID. If not defined, current site.\n   * @param options Options to open the file.\n   * @returns Promise resolved when done.\n   */\n  downloadModuleWithMainFileIfNeeded(module, courseId, component, componentId, files, siteId, options = {}) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!files || !files.length) {\n        // Module not valid, stop.\n        throw new CoreError('File list not supplied.');\n      }\n      const mainFile = files[0];\n      const site = yield CoreSites.getSite(siteId);\n      const fixedUrl = yield site.checkAndFixPluginfileURL(mainFile.fileurl);\n      if (!CoreFile.isAvailable()) {\n        return {\n          path: fixedUrl,\n          fixedUrl\n        };\n      }\n      // The file system is available.\n      const status = yield CoreFilepool.getPackageStatus(siteId, component, componentId);\n      let path = '';\n      if (status === CoreConstants.DOWNLOADING) {\n        // Use the online URL.\n        path = fixedUrl;\n      } else if (status === CoreConstants.DOWNLOADED) {\n        try {\n          // Get the local file URL.\n          path = yield CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n        } catch (error) {\n          // File not found, mark the module as not downloaded.\n          yield CoreFilepool.storePackageStatus(siteId, CoreConstants.NOT_DOWNLOADED, component, componentId);\n        }\n      }\n      if (!path) {\n        try {\n          path = yield _this8.downloadModuleWithMainFile(module, courseId, fixedUrl, files, status, component, componentId, siteId, options);\n        } catch (error) {\n          if (status !== CoreConstants.OUTDATED) {\n            throw error;\n          }\n          // Use the local file even if it's outdated.\n          try {\n            path = yield CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n          } catch (_unused5) {\n            throw error;\n          }\n        }\n      }\n      return {\n        path,\n        fixedUrl,\n        status\n      };\n    })();\n  }\n  /**\n   * Convenience function to download a module that has a main file and return the local file's path and other info.\n   * This is meant for modules like mod_resource.\n   *\n   * @param module The module to download.\n   * @param courseId The course ID of the module.\n   * @param fixedUrl Main file's fixed URL.\n   * @param files List of files of the module.\n   * @param status The package status.\n   * @param component The component to link the files to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param siteId The site ID. If not defined, current site.\n   * @param options Options to open the file.\n   * @returns Promise resolved when done.\n   */\n  downloadModuleWithMainFile(module, courseId, fixedUrl, files, status, component, componentId, siteId, options = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const isOnline = CoreNetwork.isOnline();\n      const mainFile = files[0];\n      const timemodified = mainFile.timemodified || 0;\n      if (!isOnline && status === CoreConstants.NOT_DOWNLOADED) {\n        // Not downloaded and we're offline, reject.\n        throw new CoreNetworkError();\n      }\n      const shouldDownloadFirst = yield CoreFilepool.shouldDownloadFileBeforeOpen(fixedUrl, mainFile.filesize, options);\n      if (shouldDownloadFirst) {\n        // Download and then return the local URL.\n        yield _this9.downloadModule(module, courseId, component, componentId, files, siteId);\n        return CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n      }\n      // Start the download if in wifi, but return the URL right away so the file is opened.\n      if (CoreNetwork.isWifi()) {\n        _this9.downloadModule(module, courseId, component, componentId, files, siteId);\n      }\n      if (!CoreFileHelper.isStateDownloaded(status) || isOnline) {\n        // Not downloaded or online, return the online URL.\n        return fixedUrl;\n      } else {\n        // Outdated but offline, so we return the local URL. Use getUrlByUrl so it's added to the queue.\n        return CoreFilepool.getUrlByUrl(siteId, mainFile.fileurl, component, componentId, timemodified, false, false, mainFile);\n      }\n    })();\n  }\n  /**\n   * Convenience function to download a module.\n   *\n   * @param module The module to download.\n   * @param courseId The course ID of the module.\n   * @param component The component to link the files to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param files List of files of the module. If not provided, use module.contents.\n   * @param siteId The site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  downloadModule(module, courseId, component, componentId, files, siteId) {\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const prefetchHandler = CoreCourseModulePrefetchDelegate.getPrefetchHandlerFor(module.modname);\n      if (prefetchHandler) {\n        // Use the prefetch handler to download the module.\n        if (prefetchHandler.download) {\n          return prefetchHandler.download(module, courseId);\n        }\n        return prefetchHandler.prefetch(module, courseId, true);\n      }\n      // There's no prefetch handler for the module, just download the files.\n      files = files || module.contents || [];\n      yield CoreFilepool.downloadOrPrefetchFiles(siteId, files, false, false, component, componentId);\n    })();\n  }\n  /**\n   * Get a course. It will first check the user courses, and fallback to another WS if not enrolled.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the course.\n   */\n  getCourse(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Try with enrolled courses first.\n      try {\n        const course = yield CoreCourses.getUserCourse(courseId, false, siteId);\n        return {\n          enrolled: true,\n          course: course\n        };\n      } catch (_unused6) {\n        // Not enrolled or an error happened. Try to use another WebService.\n      }\n      const course = yield CoreCourses.getCourseByField('id', courseId, siteId);\n      return {\n        enrolled: false,\n        course: course\n      };\n    })();\n  }\n  /**\n   * Get a course, wait for any course format plugin to load, and open the course page. It basically chains the functions\n   * getCourse and openCourse.\n   *\n   * @param courseId Course ID.\n   * @param params Other params to pass to the course page.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  getAndOpenCourse(courseId, params, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const modal = yield CoreDomUtils.showModalLoading();\n      let course;\n      try {\n        const data = yield _this10.getCourse(courseId, siteId);\n        course = data.course;\n      } catch (_unused7) {\n        // Cannot get course, return a \"fake\".\n        course = {\n          id: courseId\n        };\n      }\n      modal === null || modal === void 0 || modal.dismiss();\n      return _this10.openCourse(course, {\n        params,\n        siteId\n      });\n    })();\n  }\n  /**\n   * Check if the course has a block with that name.\n   *\n   * @param courseId Course ID.\n   * @param name Block name to search.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if the block exists or false otherwise.\n   * @since 3.7\n   */\n  hasABlockNamed(courseId, name, siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const blocks = yield CoreCourse.getCourseBlocks(courseId, siteId);\n        return blocks.some(block => block.name == name);\n      } catch (_unused8) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Initialize the prefetch icon for selected courses.\n   *\n   * @param courses Courses array to get info from.\n   * @param prefetch Prefetch information.\n   * @returns Resolved with the prefetch information updated when done.\n   */\n  initPrefetchCoursesIcons(courses, prefetch) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (!courses || courses.length <= 0) {\n        // Not enough courses.\n        prefetch.icon = '';\n        return prefetch;\n      }\n      const status = yield _this11.determineCoursesStatus(courses);\n      prefetch = _this11.getCoursesPrefetchStatusInfo(status);\n      if (prefetch.loading) {\n        // It seems all courses are being downloaded, show a download button instead.\n        prefetch.icon = CoreConstants.ICON_NOT_DOWNLOADED;\n      }\n      return prefetch;\n    })();\n  }\n  /**\n   * Load offline completion into a list of sections.\n   * This should be used in 3.6 sites or higher, where the course contents already include the completion.\n   *\n   * @param courseId The course to get the completion.\n   * @param sections List of sections of the course.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  loadOfflineCompletion(courseId, sections, siteId) {\n    return _asyncToGenerator(function* () {\n      const offlineCompletions = yield CoreCourseOffline.getCourseManualCompletions(courseId, siteId);\n      if (!offlineCompletions || !offlineCompletions.length) {\n        // No offline completion.\n        return;\n      }\n      const totalOffline = offlineCompletions.length;\n      let loaded = 0;\n      const offlineCompletionsMap = CoreUtils.arrayToObject(offlineCompletions, 'cmid');\n      // Load the offline data in the modules.\n      for (let i = 0; i < sections.length; i++) {\n        const section = sections[i];\n        if (!section.modules || !section.modules.length) {\n          // Section has no modules, ignore it.\n          continue;\n        }\n        for (let j = 0; j < section.modules.length; j++) {\n          const module = section.modules[j];\n          const offlineCompletion = offlineCompletionsMap[module.id];\n          if (offlineCompletion && module.completiondata !== undefined && offlineCompletion.timecompleted >= module.completiondata.timecompleted * 1000) {\n            // The module has offline completion. Load it.\n            module.completiondata.state = offlineCompletion.completed;\n            module.completiondata.offline = true;\n            // If all completions have been loaded, stop.\n            loaded++;\n            if (loaded == totalOffline) {\n              break;\n            }\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Load offline completion for a certain module.\n   * This should be used in 3.6 sites or higher, where the course contents already include the completion.\n   *\n   * @param courseId The course to get the completion.\n   * @param module The module.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  loadModuleOfflineCompletion(courseId, module, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!module.completiondata) {\n        return;\n      }\n      const offlineCompletions = yield CoreCourseOffline.getCourseManualCompletions(courseId, siteId);\n      const offlineCompletion = offlineCompletions.find(completion => completion.cmid == module.id);\n      if (offlineCompletion && offlineCompletion.timecompleted >= module.completiondata.timecompleted * 1000) {\n        // The module has offline completion. Load it.\n        module.completiondata.state = offlineCompletion.completed;\n        module.completiondata.offline = true;\n      }\n    })();\n  }\n  /**\n   * Prefetch all the courses in the array.\n   *\n   * @param courses Courses array to prefetch.\n   * @param prefetch Prefetch information to be updated.\n   * @returns Promise resolved when done.\n   */\n  prefetchCourses(courses, prefetch) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      prefetch.loading = true;\n      prefetch.icon = CoreConstants.ICON_DOWNLOADING;\n      prefetch.badge = '';\n      const prefetchOptions = {\n        onProgress: progress => {\n          prefetch.badge = progress.count + ' / ' + progress.total;\n          prefetch.badgeA11yText = Translate.instant('core.course.downloadcoursesprogressdescription', progress);\n          prefetch.count = progress.count;\n          prefetch.total = progress.total;\n        }\n      };\n      try {\n        yield _this12.confirmAndPrefetchCourses(courses, prefetchOptions);\n        prefetch.icon = CoreConstants.ICON_OUTDATED;\n      } finally {\n        prefetch.loading = false;\n        prefetch.badge = '';\n      }\n    })();\n  }\n  /**\n   * Get a course download promise (if any).\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Download promise, undefined if not found.\n   */\n  getCourseDownloadPromise(courseId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    return this.courseDwnPromises[siteId] && this.courseDwnPromises[siteId][courseId];\n  }\n  /**\n   * Get a course status icon and the langkey to use as a title.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the icon name and the title key.\n   */\n  getCourseStatusIconAndTitle(courseId, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const status = yield CoreCourse.getCourseStatus(courseId, siteId);\n      return _this13.getCoursePrefetchStatusInfo(status);\n    })();\n  }\n  /**\n   * Get a course status icon and the langkey to use as a title from status.\n   *\n   * @param status Course status.\n   * @returns Prefetch status info.\n   */\n  getCoursePrefetchStatusInfo(status) {\n    const prefetchStatus = {\n      status: status,\n      icon: this.getPrefetchStatusIcon(status, false),\n      statusTranslatable: '',\n      loading: false\n    };\n    if (status == CoreConstants.DOWNLOADED) {\n      // Always show refresh icon, we cannot know if there's anything new in course options.\n      prefetchStatus.statusTranslatable = 'core.course.refreshcourse';\n    } else if (status == CoreConstants.DOWNLOADING) {\n      prefetchStatus.statusTranslatable = 'core.downloading';\n      prefetchStatus.loading = true;\n    } else {\n      prefetchStatus.statusTranslatable = 'core.course.downloadcourse';\n    }\n    return prefetchStatus;\n  }\n  /**\n   * Get a courses status icon and the langkey to use as a title from status.\n   *\n   * @param status Courses status.\n   * @returns Prefetch status info.\n   */\n  getCoursesPrefetchStatusInfo(status) {\n    const prefetchStatus = {\n      status: status,\n      icon: this.getPrefetchStatusIcon(status, false),\n      statusTranslatable: '',\n      loading: false\n    };\n    if (status == CoreConstants.DOWNLOADED) {\n      // Always show refresh icon, we cannot know if there's anything new in course options.\n      prefetchStatus.statusTranslatable = 'core.courses.refreshcourses';\n    } else if (status == CoreConstants.DOWNLOADING) {\n      prefetchStatus.statusTranslatable = 'core.downloading';\n      prefetchStatus.loading = true;\n    } else {\n      prefetchStatus.statusTranslatable = 'core.courses.downloadcourses';\n    }\n    return prefetchStatus;\n  }\n  /**\n   * Get the icon given the status and if trust the download status.\n   *\n   * @param status Status constant.\n   * @param trustDownload True to show download success, false to show an outdated status when downloaded.\n   * @returns Icon name.\n   */\n  getPrefetchStatusIcon(status, trustDownload = false) {\n    if (status == CoreConstants.NOT_DOWNLOADED) {\n      return CoreConstants.ICON_NOT_DOWNLOADED;\n    }\n    if (status == CoreConstants.OUTDATED || status == CoreConstants.DOWNLOADED && !trustDownload) {\n      return CoreConstants.ICON_OUTDATED;\n    }\n    if (status == CoreConstants.DOWNLOADED && trustDownload) {\n      return CoreConstants.ICON_DOWNLOADED;\n    }\n    if (status == CoreConstants.DOWNLOADING) {\n      return CoreConstants.ICON_DOWNLOADING;\n    }\n    return CoreConstants.ICON_DOWNLOADING;\n  }\n  /**\n   * Get prefetch info for a module.\n   *\n   * @param module Module to get the info from.\n   * @param courseId Course ID the section belongs to.\n   * @param invalidateCache Invalidates the cache first.\n   * @param component Component of the module.\n   * @returns Promise resolved with the info.\n   */\n  getModulePrefetchInfo(module, courseId, invalidateCache = false, component = '') {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (invalidateCache) {\n        // Currently, some modules pass invalidateCache=false because they already invalidate data in downloadResourceIfNeeded.\n        // If this function is changed to do more actions if invalidateCache=true, please review those modules.\n        CoreCourseModulePrefetchDelegate.invalidateModuleStatusCache(module);\n        yield CoreUtils.ignoreErrors(CoreCourseModulePrefetchDelegate.invalidateCourseUpdates(courseId));\n      }\n      const results = yield Promise.all([CoreCourseModulePrefetchDelegate.getModuleStoredSize(module, courseId), CoreCourseModulePrefetchDelegate.getModuleStatus(module, courseId), _this14.getModulePackageLastDownloaded(module, component)]);\n      // Treat stored size.\n      const size = results[0];\n      const sizeReadable = CoreTextUtils.bytesToSize(results[0], 2);\n      // Treat module status.\n      const status = results[1];\n      let statusIcon;\n      switch (results[1]) {\n        case CoreConstants.NOT_DOWNLOADED:\n          statusIcon = CoreConstants.ICON_NOT_DOWNLOADED;\n          break;\n        case CoreConstants.DOWNLOADING:\n          statusIcon = CoreConstants.ICON_DOWNLOADING;\n          break;\n        case CoreConstants.OUTDATED:\n          statusIcon = CoreConstants.ICON_OUTDATED;\n          break;\n        case CoreConstants.DOWNLOADED:\n          break;\n        default:\n          statusIcon = '';\n          break;\n      }\n      const packageData = results[2];\n      return {\n        size,\n        sizeReadable,\n        status,\n        statusIcon,\n        downloadTime: packageData.downloadTime,\n        downloadTimeReadable: packageData.downloadTimeReadable\n      };\n    })();\n  }\n  /**\n   * Get prefetch info for a module.\n   *\n   * @param module Module to get the info from.\n   * @param component Component of the module.\n   * @returns Promise resolved with the info.\n   */\n  getModulePackageLastDownloaded(module, component = '') {\n    return _asyncToGenerator(function* () {\n      const siteId = CoreSites.getCurrentSiteId();\n      const packageData = yield CoreUtils.ignoreErrors(CoreFilepool.getPackageData(siteId, component, module.id));\n      // Treat download time.\n      if (!packageData || !packageData.downloadTime || !CoreFileHelper.isStateDownloaded(packageData.status || '')) {\n        // Not downloaded.\n        return {\n          downloadTime: 0,\n          downloadTimeReadable: ''\n        };\n      }\n      const now = CoreTimeUtils.timestamp();\n      const downloadTime = packageData.downloadTime;\n      let downloadTimeReadable = '';\n      if (now - downloadTime < 7 * 86400) {\n        downloadTimeReadable = moment(downloadTime * 1000).fromNow();\n      } else {\n        downloadTimeReadable = moment(downloadTime * 1000).calendar();\n      }\n      return {\n        downloadTime,\n        downloadTimeReadable\n      };\n    })();\n  }\n  /**\n   * Get the download ID of a section. It's used to interact with CoreCourseModulePrefetchDelegate.\n   *\n   * @param section Section.\n   * @returns Section download ID.\n   */\n  getSectionDownloadId(section) {\n    return 'Section-' + section.id;\n  }\n  /**\n   * Navigate to a module using instance ID and module name.\n   *\n   * @param instanceId Activity instance ID.\n   * @param modName Module name of the activity.\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  navigateToModuleByInstance(instanceId, modName, options = {}) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const modal = yield CoreDomUtils.showModalLoading();\n      try {\n        const module = yield CoreCourse.getModuleBasicInfoByInstance(instanceId, modName, {\n          siteId: options.siteId\n        });\n        _this15.navigateToModule(module.id, _objectSpread(_objectSpread({}, options), {}, {\n          courseId: module.course,\n          modName: options.useModNameToGetModule ? modName : undefined\n        }));\n      } catch (error) {\n        CoreDomUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);\n      } finally {\n        // Just in case. In fact we need to dismiss the modal before showing a toast or error message.\n        modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Navigate to a module.\n   *\n   * @param moduleId Module's ID.\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  navigateToModule(moduleId, options = {}) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const siteId = options.siteId || CoreSites.getCurrentSiteId();\n      let courseId = options.courseId;\n      let sectionId = options.sectionId;\n      const modal = yield CoreDomUtils.showModalLoading();\n      try {\n        if (!courseId || !sectionId) {\n          const module = yield CoreCourse.getModuleBasicInfo(moduleId, {\n            siteId,\n            readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */\n          });\n          courseId = module.course;\n          sectionId = module.section;\n        }\n        // Get the site.\n        const site = yield CoreSites.getSite(siteId);\n        // Get the module.\n        const module = yield CoreCourse.getModule(moduleId, courseId, sectionId, false, false, siteId, options.modName);\n        if (CoreSites.getCurrentSiteId() === site.getId()) {\n          var _module$handlerData;\n          // Try to use the module's handler to navigate cleanly.\n          module.handlerData = yield CoreCourseModuleDelegate.getModuleDataFor(module.modname, module, courseId, sectionId, false);\n          if ((_module$handlerData = module.handlerData) !== null && _module$handlerData !== void 0 && _module$handlerData.action) {\n            modal.dismiss();\n            return module.handlerData.action(new Event('click'), module, courseId, options.modNavOptions);\n          }\n        }\n        const params = {\n          course: {\n            id: courseId\n          },\n          module,\n          sectionId,\n          modNavOptions: options.modNavOptions\n        };\n        if (courseId == site.getSiteHomeId()) {\n          // Check if site home is available.\n          const isAvailable = yield CoreSiteHome.isAvailable();\n          if (isAvailable) {\n            yield CoreNavigator.navigateToSitePath(CoreSiteHomeHomeHandlerService.PAGE_NAME, {\n              params,\n              siteId\n            });\n            return;\n          }\n        }\n        modal.dismiss();\n        yield _this16.getAndOpenCourse(courseId, params, siteId);\n      } catch (error) {\n        CoreDomUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);\n      } finally {\n        modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Open a module.\n   *\n   * @param module The module to open.\n   * @param courseId The course ID of the module.\n   * @param options Other options.\n   * @returns True if module can be opened, false otherwise.\n   */\n  openModule(module, courseId, options = {}) {\n    return _asyncToGenerator(function* () {\n      var _module$handlerData2;\n      if (!module.handlerData) {\n        module.handlerData = yield CoreCourseModuleDelegate.getModuleDataFor(module.modname, module, courseId, options.sectionId, false);\n      }\n      if ((_module$handlerData2 = module.handlerData) !== null && _module$handlerData2 !== void 0 && _module$handlerData2.action) {\n        module.handlerData.action(new Event('click'), module, courseId, _objectSpread({\n          animated: false\n        }, options.modNavOptions));\n        return true;\n      }\n      return false;\n    })();\n  }\n  /**\n   * Prefetch all the activities in a course and also the course addons.\n   *\n   * @param course The course to prefetch.\n   * @param sections List of course sections.\n   * @param courseHandlers List of course options handlers.\n   * @param courseMenuHandlers List of course menu handlers.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the download finishes.\n   */\n  prefetchCourse(course, sections, courseHandlers, courseMenuHandlers, siteId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const requiredSiteId = siteId || CoreSites.getRequiredCurrentSite().getId();\n      if (_this17.courseDwnPromises[requiredSiteId] && _this17.courseDwnPromises[requiredSiteId][course.id] !== undefined) {\n        // There's already a download ongoing for this course, return the promise.\n        return _this17.courseDwnPromises[requiredSiteId][course.id];\n      } else if (!_this17.courseDwnPromises[requiredSiteId]) {\n        _this17.courseDwnPromises[requiredSiteId] = {};\n      }\n      // First of all, mark the course as being downloaded.\n      _this17.courseDwnPromises[requiredSiteId][course.id] = CoreCourse.setCourseStatus(course.id, CoreConstants.DOWNLOADING, requiredSiteId).then( /*#__PURE__*/_asyncToGenerator(function* () {\n        const promises = [];\n        // Prefetch all the sections. If the first section is \"All sections\", use it. Otherwise, use a fake \"All sections\".\n        let allSectionsSection = sections[0];\n        if (sections[0].id != CoreCourseProvider.ALL_SECTIONS_ID) {\n          allSectionsSection = _this17.createAllSectionsSection();\n        }\n        promises.push(_this17.prefetchSection(allSectionsSection, course.id, sections));\n        // Prefetch course options.\n        courseHandlers.forEach(handler => {\n          if (handler.prefetch) {\n            promises.push(handler.prefetch(course));\n          }\n        });\n        courseMenuHandlers.forEach(handler => {\n          if (handler.prefetch) {\n            promises.push(handler.prefetch(course));\n          }\n        });\n        // Prefetch other data needed to render the course.\n        promises.push(CoreCourses.getCoursesByField('id', course.id));\n        const sectionWithModules = sections.find(section => section.modules && section.modules.length > 0);\n        if (!sectionWithModules || sectionWithModules.modules[0].completion === undefined) {\n          promises.push(CoreCourse.getActivitiesCompletionStatus(course.id));\n        }\n        promises.push(CoreFilterHelper.getFilters('course', course.id));\n        yield CoreUtils.allPromises(promises);\n        // Download success, mark the course as downloaded.\n        return CoreCourse.setCourseStatus(course.id, CoreConstants.DOWNLOADED, requiredSiteId);\n      })).catch( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (error) {\n          // Error, restore previous status.\n          yield CoreCourse.setCoursePreviousStatus(course.id, requiredSiteId);\n          throw error;\n        });\n        return function (_x6) {\n          return _ref7.apply(this, arguments);\n        };\n      }()).finally(() => {\n        delete _this17.courseDwnPromises[requiredSiteId][course.id];\n      });\n      return _this17.courseDwnPromises[requiredSiteId][course.id];\n    })();\n  }\n  /**\n   * Helper function to prefetch a module, showing a confirmation modal if the size is big\n   * and invalidating contents if refreshing.\n   *\n   * @param handler Prefetch handler to use.\n   * @param module Module to download.\n   * @param size Size to download.\n   * @param courseId Course ID of the module.\n   * @param refresh True if refreshing, false otherwise.\n   * @returns Promise resolved when downloaded.\n   */\n  prefetchModule(handler, module, size, courseId, refresh) {\n    return _asyncToGenerator(function* () {\n      // Show confirmation if needed.\n      yield CoreDomUtils.confirmDownloadSize(size);\n      // Invalidate content if refreshing and download the data.\n      if (refresh) {\n        yield CoreUtils.ignoreErrors(handler.invalidateContent(module.id, courseId));\n      }\n      yield CoreCourseModulePrefetchDelegate.prefetchModule(module, courseId, true);\n    })();\n  }\n  /**\n   * Prefetch one section or all the sections.\n   * If the section is \"All sections\" it will prefetch all the sections.\n   *\n   * @param section Section.\n   * @param courseId Course ID the section belongs to.\n   * @param sections List of sections. Used when downloading all the sections.\n   * @returns Promise resolved when the prefetch is finished.\n   */\n  prefetchSection(section, courseId, sections) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (section.id != CoreCourseProvider.ALL_SECTIONS_ID) {\n        try {\n          // Download only this section.\n          yield _this18.prefetchSingleSectionIfNeeded(section, courseId);\n        } finally {\n          // Calculate the status of the section that finished.\n          yield _this18.calculateSectionStatus(section, courseId, false, false);\n        }\n        return;\n      }\n      if (!sections) {\n        throw new CoreError('List of sections is required when downloading all sections.');\n      }\n      // Download all the sections except \"All sections\".\n      let allSectionsStatus = CoreConstants.NOT_DOWNLOADABLE;\n      section.isDownloading = true;\n      const promises = sections.map( /*#__PURE__*/function () {\n        var _ref8 = _asyncToGenerator(function* (section) {\n          if (section.id == CoreCourseProvider.ALL_SECTIONS_ID) {\n            return;\n          }\n          try {\n            yield _this18.prefetchSingleSectionIfNeeded(section, courseId);\n          } finally {\n            // Calculate the status of the section that finished.\n            const result = yield _this18.calculateSectionStatus(section, courseId, false, false);\n            // Calculate \"All sections\" status.\n            allSectionsStatus = CoreFilepool.determinePackagesStatus(allSectionsStatus, result.statusData.status);\n          }\n        });\n        return function (_x7) {\n          return _ref8.apply(this, arguments);\n        };\n      }());\n      try {\n        yield CoreUtils.allPromises(promises);\n        // Set \"All sections\" data.\n        section.downloadStatus = allSectionsStatus;\n        section.isDownloading = allSectionsStatus === CoreConstants.DOWNLOADING;\n      } finally {\n        section.isDownloading = false;\n      }\n    })();\n  }\n  /**\n   * Prefetch a certain section if it needs to be prefetched.\n   * If the section is \"All sections\" it will be ignored.\n   *\n   * @param section Section to prefetch.\n   * @param courseId Course ID the section belongs to.\n   * @returns Promise resolved when the section is prefetched.\n   */\n  prefetchSingleSectionIfNeeded(section, courseId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      if (section.id == CoreCourseProvider.ALL_SECTIONS_ID || section.hiddenbynumsections) {\n        return;\n      }\n      const promises = [];\n      const siteId = CoreSites.getCurrentSiteId();\n      section.isDownloading = true;\n      // Download the modules.\n      promises.push(_this19.syncModulesAndPrefetchSection(section, courseId));\n      // Download the files in the section description.\n      const introFiles = CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(section.summary);\n      promises.push(CoreUtils.ignoreErrors(CoreFilepool.addFilesToQueue(siteId, introFiles, CoreCourseProvider.COMPONENT, courseId)));\n      try {\n        yield Promise.all(promises);\n      } finally {\n        section.isDownloading = false;\n      }\n    })();\n  }\n  /**\n   * Sync modules in a section and prefetch them.\n   *\n   * @param section Section to prefetch.\n   * @param courseId Course ID the section belongs to.\n   * @returns Promise resolved when the section is prefetched.\n   */\n  syncModulesAndPrefetchSection(section, courseId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      // Sync the modules first.\n      yield CoreCourseModulePrefetchDelegate.syncModules(section.modules, courseId);\n      // Validate the section needs to be downloaded and calculate amount of modules that need to be downloaded.\n      const result = yield CoreCourseModulePrefetchDelegate.getModulesStatus(section.modules, courseId, section.id);\n      if (result.status == CoreConstants.DOWNLOADED || result.status == CoreConstants.NOT_DOWNLOADABLE) {\n        // Section is downloaded or not downloadable, nothing to do.\n        return;\n      }\n      yield _this20.prefetchSingleSection(section, result, courseId);\n    })();\n  }\n  /**\n   * Start or restore the prefetch of a section.\n   * If the section is \"All sections\" it will be ignored.\n   *\n   * @param section Section to download.\n   * @param result Result of CoreCourseModulePrefetchDelegate.getModulesStatus for this section.\n   * @param courseId Course ID the section belongs to.\n   * @returns Promise resolved when the section has been prefetched.\n   */\n  prefetchSingleSection(section, result, courseId) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      if (section.id == CoreCourseProvider.ALL_SECTIONS_ID) {\n        return;\n      }\n      if (section.total && section.total > 0) {\n        // Already being downloaded.\n        return;\n      }\n      // We only download modules with status notdownloaded, downloading or outdated.\n      const modules = result[CoreConstants.OUTDATED].concat(result[CoreConstants.NOT_DOWNLOADED]).concat(result[CoreConstants.DOWNLOADING]);\n      const downloadId = _this21.getSectionDownloadId(section);\n      section.isDownloading = true;\n      // Prefetch all modules to prevent incoeherences in download count and to download stale data not marked as outdated.\n      yield CoreCourseModulePrefetchDelegate.prefetchModules(downloadId, modules, courseId, data => {\n        section.count = data.count;\n        section.total = data.total;\n      });\n    })();\n  }\n  /**\n   * Check if a section has content.\n   *\n   * @param section Section to check.\n   * @returns Whether the section has content.\n   */\n  sectionHasContent(section) {\n    if (!section.modules) {\n      return false;\n    }\n    if (section.hiddenbynumsections) {\n      return false;\n    }\n    return section.availabilityinfo !== undefined && section.availabilityinfo != '' || section.summary != '' || section.modules && section.modules.length > 0;\n  }\n  /**\n   * Wait for any course format plugin to load, and open the course page.\n   *\n   * If the plugin's promise is resolved, the course page will be opened. If it is rejected, they will see an error.\n   * If the promise for the plugin is still in progress when the user tries to open the course, a loader\n   * will be displayed until it is complete, before the course page is opened. If the promise is already complete,\n   * they will see the result immediately.\n   *\n   * @param course Course to open\n   * @param navOptions Navigation options that includes params to pass to the page.\n   * @returns Promise resolved when done.\n   */\n  openCourse(course, navOptions) {\n    return _asyncToGenerator(function* () {\n      var _navOptions;\n      const siteId = (_navOptions = navOptions) === null || _navOptions === void 0 ? void 0 : _navOptions.siteId;\n      if (!siteId || siteId == CoreSites.getCurrentSiteId()) {\n        // Current site, we can open the course.\n        return CoreCourse.openCourse(course, navOptions);\n      } else {\n        // We need to load the site first.\n        navOptions = navOptions || {};\n        navOptions.params = navOptions.params || {};\n        Object.assign(navOptions.params, {\n          course: course\n        });\n        yield CoreNavigator.navigateToSitePath(`course/${course.id}`, navOptions);\n      }\n    })();\n  }\n  /**\n   * Check if user can access the course.\n   *\n   * @param courseId Course ID.\n   * @returns Promise resolved with boolean: whether user can access the course.\n   */\n  userHasAccessToCourse(courseId) {\n    return _asyncToGenerator(function* () {\n      if (CoreNetwork.isOnline()) {\n        return CoreUtils.promiseWorks(CoreCourse.getSections(courseId, true, true, {\n          getFromCache: false,\n          emergencyCache: false\n        }, undefined, false));\n      } else {\n        return CoreUtils.promiseWorks(CoreCourse.getSections(courseId, true, true, {\n          getCacheUsingCacheKey: true\n        }, undefined, false));\n      }\n    })();\n  }\n  /**\n   * Delete course files.\n   *\n   * @param courseId Course id.\n   * @returns Promise to be resolved once the course files are deleted.\n   */\n  deleteCourseFiles(courseId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const sections = yield CoreCourse.getSections(courseId);\n      const modules = CoreArray.flatten(sections.map(section => section.modules));\n      yield Promise.all(modules.map(module => _this22.removeModuleStoredData(module, courseId)));\n      yield CoreCourse.setCourseStatus(courseId, CoreConstants.NOT_DOWNLOADED);\n    })();\n  }\n  /**\n   * Remove module stored data.\n   *\n   * @param module Module to remove the files.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when done.\n   */\n  removeModuleStoredData(module, courseId) {\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      promises.push(CoreCourseModulePrefetchDelegate.removeModuleFiles(module, courseId));\n      const handler = CoreCourseModulePrefetchDelegate.getPrefetchHandlerFor(module.modname);\n      const site = CoreSites.getCurrentSite();\n      if (handler && site) {\n        promises.push(site.deleteComponentFromCache(handler.component, module.id));\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Completion clicked.\n   *\n   * @param completion The completion.\n   * @returns Promise resolved with the result.\n   */\n  changeManualCompletion(completion) {\n    return _asyncToGenerator(function* () {\n      if (!completion) {\n        return;\n      }\n      if (completion.cmid === undefined || completion.tracking !== CoreCourseModuleCompletionTracking.COMPLETION_TRACKING_MANUAL) {\n        return;\n      }\n      const modal = yield CoreDomUtils.showModalLoading();\n      completion.state = completion.state === CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE ? CoreCourseModuleCompletionStatus.COMPLETION_INCOMPLETE : CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE;\n      try {\n        const response = yield CoreCourse.markCompletedManually(completion.cmid, completion.state === CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE, completion.courseId);\n        if (response.offline) {\n          completion.offline = true;\n        }\n        return response;\n      } catch (error) {\n        // Restore previous state.\n        completion.state = completion.state === CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE ? CoreCourseModuleCompletionStatus.COMPLETION_INCOMPLETE : CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE;\n        CoreDomUtils.showErrorModalDefault(error, 'core.errorchangecompletion', true);\n      } finally {\n        modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Retrieves course summary page module.\n   *\n   * @returns Course summary page module.\n   */\n  getCourseSummaryRouteModule() {\n    return _asyncToGenerator(function* () {\n      return import('../course-summary-lazy.module').then(m => m.CoreCourseSummaryLazyModule);\n    })();\n  }\n  /**\n   * Open course summary in side modal.\n   *\n   * @param course Course selected\n   */\n  openCourseSummary(course) {\n    CoreDomUtils.openSideModal({\n      component: CoreCourseSummaryPage,\n      componentProps: {\n        courseId: course.id,\n        course: course\n      }\n    });\n  }\n  /**\n   * Register click for reminder local notification.\n   *\n   * @param component Component to register.\n   */\n  registerModuleReminderClick(component) {\n    CoreLocalNotifications.registerClick(component, /*#__PURE__*/function () {\n      var _ref9 = _asyncToGenerator(function* (notification) {\n        yield ApplicationInit.donePromise;\n        CoreCourseHelper.navigateToModule(notification.instanceId, {\n          siteId: notification.siteId\n        });\n      });\n      return function (_x8) {\n        return _ref9.apply(this, arguments);\n      };\n    }());\n  }\n}\n_class = CoreCourseHelperProvider;\n_class.fac = function CoreCourseHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.prov = /*@__PURE__*/i0.defineInjectable({\n  token: _class,\n  factory: _class.fac,\n  providedIn: 'root'\n});\nexport const CoreCourseHelper = makeSingleton(CoreCourseHelperProvider);","map":{"version":3,"names":["moment","CoreSites","CoreCourse","CoreCourseProvider","CoreCourseModuleCompletionTracking","CoreCourseModuleCompletionStatus","CoreConstants","CoreLogger","ApplicationInit","makeSingleton","Translate","CoreFilepool","CoreDomUtils","CoreUtils","CoreCourses","CoreArray","CoreCourseOffline","CoreCourseOptionsDelegate","CoreCourseModuleDelegate","CoreError","CoreCourseModulePrefetchDelegate","CoreFileHelper","CoreNetwork","CoreFile","CoreUrlUtils","CoreTextUtils","CoreTimeUtils","CoreFilterHelper","CoreNetworkError","CoreSiteHome","CoreNavigator","CoreSiteHomeHomeHandlerService","CoreCourseSummaryPage","CoreLocalNotifications","CoreEnrol","CoreEnrolAction","CoreEnrolDelegate","CoreCourseHelperProvider","constructor","courseDwnPromises","logger","getInstance","addHandlerDataForModules","sections","courseId","completionStatus","courseName","forCoursePage","_this","_asyncToGenerator","hasContent","formattedSections","Promise","all","map","_ref","courseSection","section","_objectSpread","sectionHasContent","modules","_ref2","module","handlerData","getModuleDataFor","modname","id","completiondata","undefined","activityStatus","state","timecompleted","overrideby","valueused","tracking","cmid","isStealth","CoreCourseHelper","isModuleStealth","_x2","apply","arguments","_x","visible","visibleoncoursepage","canUserViewModule","uservisible","canUserViewSection","isSectionStealth","hiddenbynumsections","STEALTH_MODULES_SECTION_ID","calculateSectionStatus","refresh","checkUpdates","_this2","ALL_SECTIONS_ID","sectionWithStatus","result","getModulesStatus","downloadId","getSectionDownloadId","isBeingDownloaded","status","DOWNLOADING","downloadStatus","isDownloading","total","setOnProgress","data","count","statusData","calculateSectionsStatus","_this3","allSectionsSection","allSectionsStatus","NOT_DOWNLOADABLE","promises","_ref3","isCalculating","determinePackagesStatus","_x3","confirmAndPrefetchCourse","course","options","_this4","initialIcon","icon","initialStatus","initialStatusTranslatable","statusTranslatable","siteId","getCurrentSiteId","downloadSucceeded","ICON_DOWNLOADING","loading","getSections","confirmDownloadSizeSection","courseHandlers","getHandlersToDisplay","isGuest","menuHandlers","getMenuHandlersToDisplay","prefetchCourse","error","confirmAndPrefetchCourses","courses","_this5","showConfirm","instant","length","_ref4","subPromises","handlers","success","push","then","courseSections","cHandlers","mHandlers","catch","finally","onProgress","_x4","allPromises","alwaysConfirm","hasEmbeddedFiles","sizeSum","size","getDownloadSize","extractDownloadableFilesFromHtml","summary","_ref5","sectionSize","_x5","confirmDownloadSize","courseUsesGuestAccessInfo","accessData","guestAccess","getUserCourse","_unused","getCourse","_unused2","enrolmentMethods","getSupportedCourseEnrolmentMethods","action","GUEST","results","method","canAccess","forEach","requiresUserInput","_result$requiresUserI","passwordRequired","_unused3","createAllSectionsSection","name","summaryformat","determineCoursesStatus","getCourseStatus","statuses","filepool","instance","i","downloadModuleAndOpenFile","component","componentId","files","_this6","getModuleContents","mainFile","isOpenableInApp","showConfirmOpenUnsupportedFile","site","getSite","shouldOpenInBrowser","openModuleFileInBrowser","fileurl","downloadModuleWithMainFileIfNeeded","isLocalFileUrl","path","openFile","openOnlineFile","isAvailable","NOT_DOWNLOADED","downloadModule","getInternalUrlByUrl","fileUrl","_this7","isOnline","getId","_unused4","fixedUrl","checkAndFixPluginfileURL","replace","openInBrowser","_this8","getPackageStatus","DOWNLOADED","storePackageStatus","downloadModuleWithMainFile","OUTDATED","_unused5","_this9","timemodified","shouldDownloadFirst","shouldDownloadFileBeforeOpen","filesize","isWifi","isStateDownloaded","getUrlByUrl","prefetchHandler","getPrefetchHandlerFor","download","prefetch","contents","downloadOrPrefetchFiles","enrolled","_unused6","getCourseByField","getAndOpenCourse","params","_this10","modal","showModalLoading","_unused7","dismiss","openCourse","hasABlockNamed","blocks","getCourseBlocks","some","block","_unused8","initPrefetchCoursesIcons","_this11","getCoursesPrefetchStatusInfo","ICON_NOT_DOWNLOADED","loadOfflineCompletion","offlineCompletions","getCourseManualCompletions","totalOffline","loaded","offlineCompletionsMap","arrayToObject","j","offlineCompletion","completed","offline","loadModuleOfflineCompletion","find","completion","prefetchCourses","_this12","badge","prefetchOptions","progress","badgeA11yText","ICON_OUTDATED","getCourseDownloadPromise","getCourseStatusIconAndTitle","_this13","getCoursePrefetchStatusInfo","prefetchStatus","getPrefetchStatusIcon","trustDownload","ICON_DOWNLOADED","getModulePrefetchInfo","invalidateCache","_this14","invalidateModuleStatusCache","ignoreErrors","invalidateCourseUpdates","getModuleStoredSize","getModuleStatus","getModulePackageLastDownloaded","sizeReadable","bytesToSize","statusIcon","packageData","downloadTime","downloadTimeReadable","getPackageData","now","timestamp","fromNow","calendar","navigateToModuleByInstance","instanceId","modName","_this15","getModuleBasicInfoByInstance","navigateToModule","useModNameToGetModule","showErrorModalDefault","moduleId","_this16","sectionId","getModuleBasicInfo","readingStrategy","getModule","_module$handlerData","Event","modNavOptions","getSiteHomeId","navigateToSitePath","PAGE_NAME","openModule","_module$handlerData2","animated","courseMenuHandlers","_this17","requiredSiteId","getRequiredCurrentSite","setCourseStatus","prefetchSection","handler","getCoursesByField","sectionWithModules","getActivitiesCompletionStatus","getFilters","_ref7","setCoursePreviousStatus","_x6","prefetchModule","invalidateContent","_this18","prefetchSingleSectionIfNeeded","_ref8","_x7","_this19","syncModulesAndPrefetchSection","introFiles","extractDownloadableFilesFromHtmlAsFakeFileObjects","addFilesToQueue","COMPONENT","_this20","syncModules","prefetchSingleSection","_this21","concat","prefetchModules","availabilityinfo","navOptions","_navOptions","Object","assign","userHasAccessToCourse","promiseWorks","getFromCache","emergencyCache","getCacheUsingCacheKey","deleteCourseFiles","_this22","flatten","removeModuleStoredData","removeModuleFiles","getCurrentSite","deleteComponentFromCache","changeManualCompletion","COMPLETION_TRACKING_MANUAL","COMPLETION_COMPLETE","COMPLETION_INCOMPLETE","response","markCompletedManually","getCourseSummaryRouteModule","m","CoreCourseSummaryLazyModule","openCourseSummary","openSideModal","componentProps","registerModuleReminderClick","registerClick","_ref9","notification","donePromise","_x8","factory","fac","providedIn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/services/course-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { Params } from '@angular/router';\nimport moment from 'moment-timezone';\n\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport {\n    CoreCourse,\n    CoreCourseCompletionActivityStatus,\n    CoreCourseModuleWSCompletionData,\n    CoreCourseModuleContentFile,\n    CoreCourseProvider,\n    CoreCourseWSSection,\n    CoreCourseModuleCompletionTracking,\n    CoreCourseModuleCompletionStatus,\n    CoreCourseGetContentsWSModule,\n} from './course';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreLogger } from '@singletons/logger';\nimport { ApplicationInit, makeSingleton, Translate } from '@singletons';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils, CoreUtilsOpenFileOptions } from '@services/utils/utils';\nimport {\n    CoreCourseAnyCourseData,\n    CoreCourseBasicData,\n    CoreCourses,\n    CoreCourseSearchedData,\n    CoreEnrolledCourseData,\n} from '@features/courses/services/courses';\nimport { CoreArray } from '@singletons/array';\nimport { CoreCourseOffline } from './course-offline';\nimport {\n    CoreCourseOptionsDelegate,\n    CoreCourseOptionsHandlerToDisplay,\n    CoreCourseOptionsMenuHandlerToDisplay,\n} from './course-options-delegate';\nimport { CoreCourseModuleDelegate, CoreCourseModuleHandlerData } from './module-delegate';\nimport { CoreError } from '@classes/errors/error';\nimport {\n    CoreCourseModulePrefetchDelegate,\n    CoreCourseModulePrefetchHandler,\n    CoreCourseModulesStatus,\n} from './module-prefetch-delegate';\nimport { CoreFileSizeSum } from '@services/plugin-file-delegate';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreFile } from '@services/file';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreFilterHelper } from '@features/filter/services/filter-helper';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreSiteHome } from '@features/sitehome/services/sitehome';\nimport { CoreNavigationOptions, CoreNavigator } from '@services/navigator';\nimport { CoreSiteHomeHomeHandlerService } from '@features/sitehome/services/handlers/sitehome-home';\nimport { CoreStatusWithWarningsWSResponse } from '@services/ws';\nimport { CoreCourseWithImageAndColor } from '@features/courses/services/courses-helper';\nimport { CoreCourseSummaryPage } from '../pages/course-summary/course-summary.page';\nimport { CoreRemindersPushNotificationData } from '@features/reminders/services/reminders';\nimport { CoreLocalNotifications } from '@services/local-notifications';\nimport { CoreEnrol } from '@features/enrol/services/enrol';\nimport { CoreEnrolAction, CoreEnrolDelegate } from '@features/enrol/services/enrol-delegate';\nimport { LazyRoutesModule } from '@/app/app-routing.module';\n\n/**\n * Prefetch info of a module.\n */\nexport type CoreCourseModulePrefetchInfo = CoreCourseModulePackageLastDownloaded & {\n    size: number; // Downloaded size.\n    sizeReadable: string; // Downloadable size in a readable format.\n    status: string; // Module status.\n    statusIcon?: string; // Icon's name of the module status.\n};\n\n/**\n * Prefetch info of a module.\n */\nexport type CoreCourseModulePackageLastDownloaded = {\n    downloadTime: number; // Time when the module was last downloaded.\n    downloadTimeReadable: string; // Download time in a readable format.\n};\n\n/**\n * Progress of downloading a list of courses.\n */\nexport type CoreCourseCoursesProgress = {\n    /**\n     * Number of courses downloaded so far.\n     */\n    count: number;\n\n    /**\n     * Toal of courses to download.\n     */\n    total: number;\n\n    /**\n     * Whether the download has been successful so far.\n     */\n    success: boolean;\n\n    /**\n     * Last downloaded course.\n     */\n    courseId?: number;\n};\n\nexport type CorePrefetchStatusInfo = {\n    status: string; // Status of the prefetch.\n    statusTranslatable: string; // Status translatable string.\n    icon: string; // Icon based on the status.\n    loading: boolean; // If it's a loading status.\n    badge?: string; // Progress badge string if any.\n    badgeA11yText?: string; // Description of the badge if any.\n    count?: number; // Amount of already downloaded courses.\n    total?: number; // Total of courses.\n    downloadSucceeded?: boolean; // Whether download has succeeded (in case it's downloaded).\n};\n\n/**\n * Helper to gather some common course functions.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCourseHelperProvider {\n\n    protected courseDwnPromises: { [s: string]: { [id: number]: Promise<void> } } = {};\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreCourseHelperProvider');\n    }\n\n    /**\n     * This function treats every module on the sections provided to load the handler data, treat completion\n     * and navigate to a module page if required. It also returns if sections has content.\n     *\n     * @param sections List of sections to treat modules.\n     * @param courseId Course ID of the modules.\n     * @param completionStatus List of completion status.\n     * @param courseName Not used since 4.0\n     * @param forCoursePage Whether the data will be used to render the course page.\n     * @returns Whether the sections have content.\n     */\n    async addHandlerDataForModules(\n        sections: CoreCourseWSSection[],\n        courseId: number,\n        completionStatus?: Record<string, CoreCourseCompletionActivityStatus>,\n        courseName?: string,\n        forCoursePage = false,\n    ): Promise<{ hasContent: boolean; sections: CoreCourseSection[] }> {\n\n        let hasContent = false;\n\n        const formattedSections = await Promise.all(\n            sections.map<Promise<CoreCourseSection>>(async (courseSection) => {\n                const section = {\n                    ...courseSection,\n                    hasContent: this.sectionHasContent(courseSection),\n                };\n\n                if (!section.hasContent) {\n                    return section;\n                }\n\n                hasContent = true;\n\n                await Promise.all(section.modules.map(async (module) => {\n                    module.handlerData = await CoreCourseModuleDelegate.getModuleDataFor(\n                        module.modname,\n                        module,\n                        courseId,\n                        section.id,\n                        forCoursePage,\n                    );\n\n                    if (!module.completiondata && completionStatus && completionStatus[module.id] !== undefined) {\n                        // Should not happen on > 3.6. Check if activity has completions and if it's marked.\n                        const activityStatus = completionStatus[module.id];\n\n                        module.completiondata = {\n                            state: activityStatus.state,\n                            timecompleted: activityStatus.timecompleted,\n                            overrideby: activityStatus.overrideby || 0,\n                            valueused: activityStatus.valueused,\n                            tracking: activityStatus.tracking,\n                            courseId,\n                            cmid: module.id,\n                        };\n                    }\n\n                    // Check if the module is stealth.\n                    module.isStealth = CoreCourseHelper.isModuleStealth(module, section);\n                }));\n\n                return section;\n            }),\n        );\n\n        return { hasContent, sections: formattedSections };\n    }\n\n    /**\n     * Module is stealth.\n     *\n     * @param module Module to check.\n     * @param section Section to check.\n     * @returns Wether the module is stealth.\n     */\n    isModuleStealth(module: CoreCourseModuleData, section?: CoreCourseWSSection): boolean {\n        // visibleoncoursepage can be 1 for teachers when the section is hidden.\n        return !!module.visible && (!module.visibleoncoursepage || (!!section && !section.visible));\n    }\n\n    /**\n     * Module is visible by the user.\n     *\n     * @param module Module to check.\n     * @param section Section to check. Omitted if not defined.\n     * @returns Wether the section is visible by the user.\n     */\n    canUserViewModule(module: CoreCourseModuleData, section?: CoreCourseWSSection): boolean {\n        return module.uservisible !== false && (!section || CoreCourseHelper.canUserViewSection(section));\n    }\n\n    /**\n     * Section is stealth.\n     * This should not be true on Moodle 4.0 onwards.\n     *\n     * @param section Section to check.\n     * @returns Wether section is stealth (accessible but not visible to students).\n     */\n    isSectionStealth(section: CoreCourseWSSection): boolean {\n        return section.hiddenbynumsections === 1 || section.id === CoreCourseProvider.STEALTH_MODULES_SECTION_ID;\n    }\n\n    /**\n     * Section is visible by the user.\n     *\n     * @param section Section to check.\n     * @returns Wether the section is visible by the user.\n     */\n    canUserViewSection(section: CoreCourseWSSection): boolean {\n        return section.uservisible !== false;\n    }\n\n    /**\n     * Calculate the status of a section.\n     *\n     * @param section Section to calculate its status. It can't be \"All sections\".\n     * @param courseId Course ID the section belongs to.\n     * @param refresh True if it shouldn't use module status cache (slower).\n     * @param checkUpdates Whether to use the WS to check updates. Defaults to true.\n     * @returns Promise resolved when the status is calculated.\n     */\n    async calculateSectionStatus(\n        section: CoreCourseSection,\n        courseId: number,\n        refresh?: boolean,\n        checkUpdates: boolean = true,\n    ): Promise<{statusData: CoreCourseModulesStatus; section: CoreCourseSectionWithStatus}> {\n        if (section.id == CoreCourseProvider.ALL_SECTIONS_ID) {\n            throw new CoreError('Invalid section');\n        }\n\n        const sectionWithStatus = <CoreCourseSectionWithStatus> section;\n\n        // Get the status of this section.\n        const result = await CoreCourseModulePrefetchDelegate.getModulesStatus(\n            section.modules,\n            courseId,\n            section.id,\n            refresh,\n            true,\n            checkUpdates,\n        );\n\n        // Check if it's being downloaded.\n        const downloadId = this.getSectionDownloadId(section);\n        if (CoreCourseModulePrefetchDelegate.isBeingDownloaded(downloadId)) {\n            result.status = CoreConstants.DOWNLOADING;\n        }\n\n        sectionWithStatus.downloadStatus = result.status;\n\n        // Set this section data.\n        if (result.status !== CoreConstants.DOWNLOADING) {\n            sectionWithStatus.isDownloading = false;\n            sectionWithStatus.total = 0;\n        } else {\n            // Section is being downloaded.\n            sectionWithStatus.isDownloading = true;\n            CoreCourseModulePrefetchDelegate.setOnProgress(downloadId, (data) => {\n                sectionWithStatus.count = data.count;\n                sectionWithStatus.total = data.total;\n            });\n        }\n\n        return { statusData: result, section: sectionWithStatus };\n    }\n\n    /**\n     * Calculate the status of a list of sections, setting attributes to determine the icons/data to be shown.\n     *\n     * @param sections Sections to calculate their status.\n     * @param courseId Course ID the sections belong to.\n     * @param refresh True if it shouldn't use module status cache (slower).\n     * @param checkUpdates Whether to use the WS to check updates. Defaults to true.\n     * @returns Promise resolved when the states are calculated.\n     */\n    async calculateSectionsStatus(\n        sections: CoreCourseSection[],\n        courseId: number,\n        refresh?: boolean,\n        checkUpdates: boolean = true,\n    ): Promise<CoreCourseSectionWithStatus[]> {\n        let allSectionsSection: CoreCourseSectionWithStatus | undefined;\n        let allSectionsStatus = CoreConstants.NOT_DOWNLOADABLE;\n\n        const promises = sections.map(async (section: CoreCourseSectionWithStatus) => {\n            section.isCalculating = true;\n\n            if (section.id === CoreCourseProvider.ALL_SECTIONS_ID) {\n                // \"All sections\" section status is calculated using the status of the rest of sections.\n                allSectionsSection = section;\n\n                return;\n            }\n\n            try {\n                const result = await this.calculateSectionStatus(section, courseId, refresh, checkUpdates);\n\n                // Calculate \"All sections\" status.\n                allSectionsStatus = CoreFilepool.determinePackagesStatus(allSectionsStatus, result.statusData.status);\n            } finally {\n                section.isCalculating = false;\n            }\n        });\n\n        try {\n            await Promise.all(promises);\n\n            if (allSectionsSection) {\n                // Set \"All sections\" data.\n                allSectionsSection.downloadStatus = allSectionsStatus;\n                allSectionsSection.isDownloading = allSectionsStatus === CoreConstants.DOWNLOADING;\n            }\n\n            return sections;\n        } finally {\n            if (allSectionsSection) {\n                allSectionsSection.isCalculating = false;\n            }\n        }\n    }\n\n    /**\n     * Show a confirm and prefetch a course. It will retrieve the sections and the course options if not provided.\n     * This function will set the icon to \"spinner\" when starting and it will also set it back to the initial icon if the\n     * user cancels. All the other updates of the icon should be made when CoreEvents.COURSE_STATUS_CHANGED is received.\n     *\n     * @param data An object where to store the course icon and title: \"prefetchCourseIcon\", \"title\" and \"downloadSucceeded\".\n     * @param course Course to prefetch.\n     * @param options Other options.\n     * @returns Promise resolved when the download finishes, rejected if an error occurs or the user cancels.\n     */\n    async confirmAndPrefetchCourse(\n        data: CorePrefetchStatusInfo,\n        course: CoreCourseAnyCourseData,\n        options: CoreCoursePrefetchCourseOptions = {},\n    ): Promise<void> {\n        const initialIcon = data.icon;\n        const initialStatus = data.status;\n        const initialStatusTranslatable = data.statusTranslatable;\n        const siteId = CoreSites.getCurrentSiteId();\n\n        data.downloadSucceeded = false;\n        data.icon = CoreConstants.ICON_DOWNLOADING;\n        data.status = CoreConstants.DOWNLOADING;\n        data.loading = true;\n        data.statusTranslatable = 'core.downloading';\n\n        try {\n            // Get the sections first if needed.\n            if (!options.sections) {\n                options.sections = await CoreCourse.getSections(course.id, false, true);\n            }\n\n            // Confirm the download.\n            await this.confirmDownloadSizeSection(course.id, undefined, options.sections, true);\n\n            // User confirmed, get the course handlers if needed.\n            if (!options.courseHandlers) {\n                options.courseHandlers = await CoreCourseOptionsDelegate.getHandlersToDisplay(course, false, options.isGuest);\n            }\n            if (!options.menuHandlers) {\n                options.menuHandlers = await CoreCourseOptionsDelegate.getMenuHandlersToDisplay(course, false, options.isGuest);\n            }\n\n            // Now we have all the data, download the course.\n            await this.prefetchCourse(course, options.sections, options.courseHandlers, options.menuHandlers, siteId);\n\n            // Download successful.\n            data.downloadSucceeded = true;\n            data.loading = false;\n        } catch (error) {\n            // User cancelled or there was an error.\n            data.icon = initialIcon;\n            data.status = initialStatus;\n            data.statusTranslatable = initialStatusTranslatable;\n            data.loading = false;\n\n            throw error;\n        }\n    }\n\n    /**\n     * Confirm and prefetches a list of courses.\n     *\n     * @param courses List of courses to download.\n     * @param options Other options.\n     * @returns Resolved when downloaded, rejected if error or canceled.\n     */\n    async confirmAndPrefetchCourses(\n        courses: CoreCourseAnyCourseData[],\n        options: CoreCourseConfirmPrefetchCoursesOptions = {},\n    ): Promise<void> {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        // Confirm the download without checking size because it could take a while.\n        await CoreDomUtils.showConfirm(Translate.instant('core.areyousure'), Translate.instant('core.courses.downloadcourses'));\n\n        const total = courses.length;\n        let count = 0;\n\n        const promises = courses.map(async (course) => {\n            const subPromises: Promise<void>[] = [];\n            let sections: CoreCourseWSSection[];\n            let handlers: CoreCourseOptionsHandlerToDisplay[] = [];\n            let menuHandlers: CoreCourseOptionsMenuHandlerToDisplay[] = [];\n            let success = true;\n\n            // Get the sections and the handlers.\n            subPromises.push(CoreCourse.getSections(course.id, false, true).then((courseSections) => {\n                sections = courseSections;\n\n                return;\n            }));\n\n            subPromises.push(CoreCourseOptionsDelegate.getHandlersToDisplay(course, false).then((cHandlers) => {\n                handlers = cHandlers;\n\n                return;\n            }));\n            subPromises.push(CoreCourseOptionsDelegate.getMenuHandlersToDisplay(course, false).then((mHandlers) => {\n                menuHandlers = mHandlers;\n\n                return;\n            }));\n\n            return Promise.all(subPromises).then(() => this.prefetchCourse(course, sections, handlers, menuHandlers, siteId))\n                .catch((error) => {\n                    success = false;\n\n                    throw error;\n                }).finally(() => {\n                // Course downloaded or failed, notify the progress.\n                    count++;\n                    if (options.onProgress) {\n                        options.onProgress({ count: count, total: total, courseId: course.id, success: success });\n                    }\n                });\n        });\n\n        if (options.onProgress) {\n            // Notify the start of the download.\n            options.onProgress({ count: 0, total: total, success: true });\n        }\n\n        return CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Calculate the size to download a section and show a confirm modal if needed.\n     *\n     * @param courseId Course ID the section belongs to.\n     * @param section Section. If not provided, all sections.\n     * @param sections List of sections. Used when downloading all the sections.\n     * @param alwaysConfirm True to show a confirm even if the size isn't high, false otherwise.\n     * @returns Promise resolved if the user confirms or there's no need to confirm.\n     */\n    async confirmDownloadSizeSection(\n        courseId: number,\n        section?: CoreCourseWSSection,\n        sections?: CoreCourseWSSection[],\n        alwaysConfirm?: boolean,\n    ): Promise<void> {\n        let hasEmbeddedFiles = false;\n        let sizeSum: CoreFileSizeSum = {\n            size: 0,\n            total: true,\n        };\n\n        // Calculate the size of the download.\n        if (section && section.id != CoreCourseProvider.ALL_SECTIONS_ID) {\n            sizeSum = await CoreCourseModulePrefetchDelegate.getDownloadSize(section.modules, courseId);\n\n            // Check if the section has embedded files in the description.\n            hasEmbeddedFiles = CoreFilepool.extractDownloadableFilesFromHtml(section.summary).length > 0;\n        } else if (sections) {\n            await Promise.all(sections.map(async (section) => {\n                if (section.id == CoreCourseProvider.ALL_SECTIONS_ID) {\n                    return;\n                }\n\n                const sectionSize = await CoreCourseModulePrefetchDelegate.getDownloadSize(section.modules, courseId);\n\n                sizeSum.total = sizeSum.total && sectionSize.total;\n                sizeSum.size += sectionSize.size;\n\n                // Check if the section has embedded files in the description.\n                if (!hasEmbeddedFiles && CoreFilepool.extractDownloadableFilesFromHtml(section.summary).length > 0) {\n                    hasEmbeddedFiles = true;\n                }\n            }));\n        } else {\n            throw new CoreError('Either section or list of sections needs to be supplied.');\n        }\n\n        if (hasEmbeddedFiles) {\n            sizeSum.total = false;\n        }\n\n        // Show confirm modal if needed.\n        await CoreDomUtils.confirmDownloadSize(sizeSum, undefined, undefined, undefined, undefined, alwaysConfirm);\n    }\n\n    /**\n     * Check whether a course is accessed using guest access and if it requires user input to enter.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Data about guest access info.\n     */\n    async courseUsesGuestAccessInfo(\n        courseId: number,\n        siteId?: string,\n    ): Promise<CoreCourseGuestAccessInfo> {\n        const accessData: CoreCourseGuestAccessInfo = {\n            guestAccess: false,\n        };\n\n        try {\n            try {\n                // Check if user is enrolled. If enrolled, no guest access.\n                await CoreCourses.getUserCourse(courseId, false, siteId);\n\n                return accessData;\n            } catch {\n                // Ignore errors.\n            }\n\n            try {\n                // The user is not enrolled in the course. Use getCourses to see if it's an admin/manager and can see the course.\n                await CoreCourses.getCourse(courseId, siteId);\n\n                return accessData;\n            } catch {\n                // Ignore errors.\n            }\n\n            // Check if guest access is enabled.\n            const enrolmentMethods = await CoreEnrol.getSupportedCourseEnrolmentMethods(courseId, {\n                action: CoreEnrolAction.GUEST,\n                siteId,\n            });\n\n            if (!enrolmentMethods) {\n                return accessData;\n            }\n\n            const results = await Promise.all(enrolmentMethods.map(method => CoreEnrolDelegate.canAccess(method)));\n\n            results.forEach(result => {\n                accessData.guestAccess = accessData.guestAccess || result.canAccess;\n                if (accessData.requiresUserInput !== false && result.canAccess) {\n                    accessData.requiresUserInput = result.requiresUserInput ?? accessData.requiresUserInput;\n                }\n            });\n\n            // eslint-disable-next-line deprecation/deprecation\n            accessData.passwordRequired = accessData.requiresUserInput; // For backwards compatibility.\n\n            return accessData;\n        } catch {\n            return accessData;\n        }\n    }\n\n    /**\n     * Create and return a section for \"All sections\".\n     *\n     * @returns Created section.\n     */\n    createAllSectionsSection(): CoreCourseSection {\n        return {\n            id: CoreCourseProvider.ALL_SECTIONS_ID,\n            name: Translate.instant('core.course.allsections'),\n            hasContent: true,\n            summary: '',\n            summaryformat: 1,\n            modules: [],\n        };\n    }\n\n    /**\n     * Determine the status of a list of courses.\n     *\n     * @param courses Courses\n     * @returns Promise resolved with the status.\n     */\n    async determineCoursesStatus(courses: CoreCourseBasicData[]): Promise<string> {\n        // Get the status of each course.\n        const promises: Promise<string>[] = [];\n        const siteId = CoreSites.getCurrentSiteId();\n\n        courses.forEach((course) => {\n            promises.push(CoreCourse.getCourseStatus(course.id, siteId));\n        });\n\n        const statuses = await Promise.all(promises);\n\n        // Now determine the status of the whole list.\n        let status = statuses[0];\n        const filepool = CoreFilepool.instance;\n        for (let i = 1; i < statuses.length; i++) {\n            status = filepool.determinePackagesStatus(status, statuses[i]);\n        }\n\n        return status;\n    }\n\n    /**\n     * Convenience function to open a module main file, downloading the package if needed.\n     * This is meant for modules like mod_resource.\n     *\n     * @param module The module to download.\n     * @param courseId The course ID of the module.\n     * @param component The component to link the files to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param files List of files of the module. If not provided, use module.contents.\n     * @param siteId The site ID. If not defined, current site.\n     * @param options Options to open the file.\n     * @returns Resolved on success.\n     */\n    async downloadModuleAndOpenFile(\n        module: CoreCourseModuleData,\n        courseId: number,\n        component?: string,\n        componentId?: string | number,\n        files?: CoreCourseModuleContentFile[],\n        siteId?: string,\n        options: CoreUtilsOpenFileOptions = {},\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!files || !files.length) {\n            // Try to use module contents.\n            files = await CoreCourse.getModuleContents(module);\n        }\n\n        if (!files.length) {\n            throw new CoreError(Translate.instant('core.filenotfound'));\n        }\n\n        const mainFile = files[0];\n\n        if (!CoreFileHelper.isOpenableInApp(mainFile)) {\n            await CoreFileHelper.showConfirmOpenUnsupportedFile(false, mainFile);\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        // Check if the file should be opened in browser.\n        if (CoreFileHelper.shouldOpenInBrowser(mainFile)) {\n            return this.openModuleFileInBrowser(mainFile.fileurl, site, module, courseId, component, componentId, files, options);\n        }\n\n        // File shouldn't be opened in browser. Download the module if it needs to be downloaded.\n        const result = await this.downloadModuleWithMainFileIfNeeded(\n            module,\n            courseId,\n            component || '',\n            componentId,\n            files,\n            siteId,\n            options,\n        );\n\n        if (CoreUrlUtils.isLocalFileUrl(result.path)) {\n            return CoreUtils.openFile(result.path, options);\n        }\n\n        /* In iOS, if we use the same URL in embedded browser and background download then the download only\n        downloads a few bytes (cached ones). Add a hash to the URL so both URLs are different. */\n        result.path = result.path + '#moodlemobile-embedded';\n\n        try {\n            await CoreUtils.openOnlineFile(result.path);\n        } catch (error) {\n            // Error opening the file, some apps don't allow opening online files.\n            if (!CoreFile.isAvailable()) {\n                throw error;\n            } else if (result.status === CoreConstants.DOWNLOADING) {\n                throw new CoreError(Translate.instant('core.erroropenfiledownloading'));\n            }\n\n            let path: string | undefined;\n            if (result.status === CoreConstants.NOT_DOWNLOADED) {\n                // Not downloaded, download it now and return the local file.\n                await this.downloadModule(module, courseId, component, componentId, files, siteId);\n\n                path = await CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n            } else {\n                // File is outdated or stale and can't be opened in online, return the local URL.\n                path = await CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n            }\n\n            await CoreUtils.openFile(path, options);\n        }\n    }\n\n    /**\n     * Convenience function to open a module main file in case it needs to be opened in browser.\n     *\n     * @param fileUrl URL of the main file.\n     * @param site Site instance.\n     * @param module The module to download.\n     * @param courseId The course ID of the module.\n     * @param component The component to link the files to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param files List of files of the module. If not provided, use module.contents.\n     * @param options Options to open the file. Only used if not opened in browser.\n     * @returns Resolved on success.\n     */\n    protected async openModuleFileInBrowser(\n        fileUrl: string,\n        site: CoreSite,\n        module: CoreCourseModuleData,\n        courseId: number,\n        component?: string,\n        componentId?: string | number,\n        files?: CoreCourseModuleContentFile[],\n        options: CoreUtilsOpenFileOptions = {},\n    ): Promise<void> {\n        if (!CoreNetwork.isOnline()) {\n            // Not online, get the offline file. It will fail if not found.\n            let path: string | undefined;\n            try {\n                path = await CoreFilepool.getInternalUrlByUrl(site.getId(), fileUrl);\n            } catch {\n                throw new CoreNetworkError();\n            }\n\n            return CoreUtils.openFile(path, options);\n        }\n\n        // Open in browser.\n        let fixedUrl = await site.checkAndFixPluginfileURL(fileUrl);\n\n        fixedUrl = fixedUrl.replace('&offline=1', '');\n        // Remove forcedownload when followed by another param.\n        fixedUrl = fixedUrl.replace(/forcedownload=\\d+&/, '');\n        // Remove forcedownload when not followed by any param.\n        fixedUrl = fixedUrl.replace(/[?|&]forcedownload=\\d+/, '');\n\n        CoreUtils.openInBrowser(fixedUrl);\n\n        if (CoreFile.isAvailable()) {\n            // Download the file if needed (file outdated or not downloaded).\n            // Download will be in background, don't return the promise.\n            this.downloadModule(module, courseId, component, componentId, files, site.getId());\n        }\n    }\n\n    /**\n     * Convenience function to download a module that has a main file and return the local file's path and other info.\n     * This is meant for modules like mod_resource.\n     *\n     * @param module The module to download.\n     * @param courseId The course ID of the module.\n     * @param component The component to link the files to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param files List of files of the module. If not provided, use module.contents.\n     * @param siteId The site ID. If not defined, current site.\n     * @param options Options to open the file.\n     * @returns Promise resolved when done.\n     */\n    async downloadModuleWithMainFileIfNeeded(\n        module: CoreCourseModuleData,\n        courseId: number,\n        component: string,\n        componentId?: string | number,\n        files?: CoreCourseModuleContentFile[],\n        siteId?: string,\n        options: CoreUtilsOpenFileOptions = {},\n    ): Promise<{ fixedUrl: string; path: string; status?: string }> {\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!files || !files.length) {\n            // Module not valid, stop.\n            throw new CoreError('File list not supplied.');\n        }\n\n        const mainFile = files[0];\n        const site = await CoreSites.getSite(siteId);\n\n        const fixedUrl = await site.checkAndFixPluginfileURL(mainFile.fileurl);\n\n        if (!CoreFile.isAvailable()) {\n            return {\n                path: fixedUrl, // Use the online URL.\n                fixedUrl,\n            };\n        }\n\n        // The file system is available.\n        const status = await CoreFilepool.getPackageStatus(siteId, component, componentId);\n\n        let path = '';\n\n        if (status === CoreConstants.DOWNLOADING) {\n            // Use the online URL.\n            path = fixedUrl;\n        } else if (status === CoreConstants.DOWNLOADED) {\n            try {\n                // Get the local file URL.\n                path = await CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n            } catch (error){\n                // File not found, mark the module as not downloaded.\n                await CoreFilepool.storePackageStatus(siteId, CoreConstants.NOT_DOWNLOADED, component, componentId);\n            }\n        }\n\n        if (!path) {\n            try {\n                path = await this.downloadModuleWithMainFile(\n                    module,\n                    courseId,\n                    fixedUrl,\n                    files,\n                    status,\n                    component,\n                    componentId,\n                    siteId,\n                    options,\n                );\n            } catch (error) {\n                if (status !== CoreConstants.OUTDATED) {\n                    throw error;\n                }\n\n                // Use the local file even if it's outdated.\n                try {\n                    path = await CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n                } catch {\n                    throw error;\n                }\n            }\n        }\n\n        return {\n            path,\n            fixedUrl,\n            status,\n        };\n    }\n\n    /**\n     * Convenience function to download a module that has a main file and return the local file's path and other info.\n     * This is meant for modules like mod_resource.\n     *\n     * @param module The module to download.\n     * @param courseId The course ID of the module.\n     * @param fixedUrl Main file's fixed URL.\n     * @param files List of files of the module.\n     * @param status The package status.\n     * @param component The component to link the files to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param siteId The site ID. If not defined, current site.\n     * @param options Options to open the file.\n     * @returns Promise resolved when done.\n     */\n    protected async downloadModuleWithMainFile(\n        module: CoreCourseModuleData,\n        courseId: number,\n        fixedUrl: string,\n        files: CoreCourseModuleContentFile[],\n        status: string,\n        component?: string,\n        componentId?: string | number,\n        siteId?: string,\n        options: CoreUtilsOpenFileOptions = {},\n    ): Promise<string> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const isOnline = CoreNetwork.isOnline();\n        const mainFile = files[0];\n        const timemodified = mainFile.timemodified || 0;\n\n        if (!isOnline && status === CoreConstants.NOT_DOWNLOADED) {\n            // Not downloaded and we're offline, reject.\n            throw new CoreNetworkError();\n        }\n\n        const shouldDownloadFirst = await CoreFilepool.shouldDownloadFileBeforeOpen(fixedUrl, mainFile.filesize, options);\n\n        if (shouldDownloadFirst) {\n            // Download and then return the local URL.\n            await this.downloadModule(module, courseId, component, componentId, files, siteId);\n\n            return CoreFilepool.getInternalUrlByUrl(siteId, mainFile.fileurl);\n        }\n\n        // Start the download if in wifi, but return the URL right away so the file is opened.\n        if (CoreNetwork.isWifi()) {\n            this.downloadModule(module, courseId, component, componentId, files, siteId);\n        }\n\n        if (!CoreFileHelper.isStateDownloaded(status) || isOnline) {\n            // Not downloaded or online, return the online URL.\n            return fixedUrl;\n        } else {\n            // Outdated but offline, so we return the local URL. Use getUrlByUrl so it's added to the queue.\n            return CoreFilepool.getUrlByUrl(\n                siteId,\n                mainFile.fileurl,\n                component,\n                componentId,\n                timemodified,\n                false,\n                false,\n                mainFile,\n            );\n        }\n    }\n\n    /**\n     * Convenience function to download a module.\n     *\n     * @param module The module to download.\n     * @param courseId The course ID of the module.\n     * @param component The component to link the files to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param files List of files of the module. If not provided, use module.contents.\n     * @param siteId The site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async downloadModule(\n        module: CoreCourseModuleData,\n        courseId: number,\n        component?: string,\n        componentId?: string | number,\n        files?: CoreCourseModuleContentFile[],\n        siteId?: string,\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const prefetchHandler = CoreCourseModulePrefetchDelegate.getPrefetchHandlerFor(module.modname);\n\n        if (prefetchHandler) {\n            // Use the prefetch handler to download the module.\n            if (prefetchHandler.download) {\n                return prefetchHandler.download(module, courseId);\n            }\n\n            return prefetchHandler.prefetch(module, courseId, true);\n        }\n\n        // There's no prefetch handler for the module, just download the files.\n        files = files || module.contents || [];\n\n        await CoreFilepool.downloadOrPrefetchFiles(siteId, files, false, false, component, componentId);\n    }\n\n    /**\n     * Get a course. It will first check the user courses, and fallback to another WS if not enrolled.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the course.\n     */\n    async getCourse(\n        courseId: number,\n        siteId?: string,\n    ): Promise<{ enrolled: boolean; course: CoreEnrolledCourseData | CoreCourseSearchedData }> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Try with enrolled courses first.\n        try {\n            const course = await CoreCourses.getUserCourse(courseId, false, siteId);\n\n            return ({ enrolled: true, course: course });\n        } catch {\n            // Not enrolled or an error happened. Try to use another WebService.\n        }\n\n        const course = await CoreCourses.getCourseByField('id', courseId, siteId);\n\n        return ({ enrolled: false, course: course });\n    }\n\n    /**\n     * Get a course, wait for any course format plugin to load, and open the course page. It basically chains the functions\n     * getCourse and openCourse.\n     *\n     * @param courseId Course ID.\n     * @param params Other params to pass to the course page.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async getAndOpenCourse(courseId: number, params?: Params, siteId?: string): Promise<void> {\n        const modal = await CoreDomUtils.showModalLoading();\n\n        let course: CoreCourseAnyCourseData | { id: number };\n\n        try {\n            const data = await this.getCourse(courseId, siteId);\n\n            course = data.course;\n        } catch {\n            // Cannot get course, return a \"fake\".\n            course = { id: courseId };\n        }\n\n        modal?.dismiss();\n\n        return this.openCourse(course, { params , siteId });\n    }\n\n    /**\n     * Check if the course has a block with that name.\n     *\n     * @param courseId Course ID.\n     * @param name Block name to search.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if the block exists or false otherwise.\n     * @since 3.7\n     */\n    async hasABlockNamed(courseId: number, name: string, siteId?: string): Promise<boolean> {\n        try {\n            const blocks = await CoreCourse.getCourseBlocks(courseId, siteId);\n\n            return blocks.some((block) => block.name == name);\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Initialize the prefetch icon for selected courses.\n     *\n     * @param courses Courses array to get info from.\n     * @param prefetch Prefetch information.\n     * @returns Resolved with the prefetch information updated when done.\n     */\n    async initPrefetchCoursesIcons(\n        courses: CoreCourseBasicData[],\n        prefetch: CorePrefetchStatusInfo,\n    ): Promise<CorePrefetchStatusInfo> {\n        if (!courses || courses.length <= 0) {\n            // Not enough courses.\n            prefetch.icon = '';\n\n            return prefetch;\n        }\n\n        const status = await this.determineCoursesStatus(courses);\n\n        prefetch = this.getCoursesPrefetchStatusInfo(status);\n\n        if (prefetch.loading) {\n            // It seems all courses are being downloaded, show a download button instead.\n            prefetch.icon = CoreConstants.ICON_NOT_DOWNLOADED;\n        }\n\n        return prefetch;\n    }\n\n    /**\n     * Load offline completion into a list of sections.\n     * This should be used in 3.6 sites or higher, where the course contents already include the completion.\n     *\n     * @param courseId The course to get the completion.\n     * @param sections List of sections of the course.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async loadOfflineCompletion(courseId: number, sections: CoreCourseWSSection[], siteId?: string): Promise<void> {\n        const offlineCompletions = await CoreCourseOffline.getCourseManualCompletions(courseId, siteId);\n\n        if (!offlineCompletions || !offlineCompletions.length) {\n            // No offline completion.\n            return;\n        }\n\n        const totalOffline = offlineCompletions.length;\n        let loaded = 0;\n        const offlineCompletionsMap = CoreUtils.arrayToObject(offlineCompletions, 'cmid');\n        // Load the offline data in the modules.\n        for (let i = 0; i < sections.length; i++) {\n            const section = sections[i];\n            if (!section.modules || !section.modules.length) {\n                // Section has no modules, ignore it.\n                continue;\n            }\n\n            for (let j = 0; j < section.modules.length; j++) {\n                const module = section.modules[j];\n                const offlineCompletion = offlineCompletionsMap[module.id];\n\n                if (offlineCompletion && module.completiondata !== undefined &&\n                    offlineCompletion.timecompleted >= module.completiondata.timecompleted * 1000) {\n                    // The module has offline completion. Load it.\n                    module.completiondata.state = offlineCompletion.completed;\n                    module.completiondata.offline = true;\n\n                    // If all completions have been loaded, stop.\n                    loaded++;\n                    if (loaded == totalOffline) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Load offline completion for a certain module.\n     * This should be used in 3.6 sites or higher, where the course contents already include the completion.\n     *\n     * @param courseId The course to get the completion.\n     * @param module The module.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async loadModuleOfflineCompletion(courseId: number, module: CoreCourseModuleData, siteId?: string): Promise<void> {\n        if (!module.completiondata) {\n            return;\n        }\n\n        const offlineCompletions = await CoreCourseOffline.getCourseManualCompletions(courseId, siteId);\n\n        const offlineCompletion = offlineCompletions.find(completion => completion.cmid == module.id);\n\n        if (offlineCompletion && offlineCompletion.timecompleted >= module.completiondata.timecompleted * 1000) {\n            // The module has offline completion. Load it.\n            module.completiondata.state = offlineCompletion.completed;\n            module.completiondata.offline = true;\n        }\n    }\n\n    /**\n     * Prefetch all the courses in the array.\n     *\n     * @param courses Courses array to prefetch.\n     * @param prefetch Prefetch information to be updated.\n     * @returns Promise resolved when done.\n     */\n    async prefetchCourses(\n        courses: CoreCourseAnyCourseData[],\n        prefetch: CorePrefetchStatusInfo,\n    ): Promise<void> {\n        prefetch.loading = true;\n        prefetch.icon = CoreConstants.ICON_DOWNLOADING;\n        prefetch.badge = '';\n\n        const prefetchOptions = {\n            onProgress: (progress) => {\n                prefetch.badge = progress.count + ' / ' + progress.total;\n                prefetch.badgeA11yText = Translate.instant('core.course.downloadcoursesprogressdescription', progress);\n                prefetch.count = progress.count;\n                prefetch.total = progress.total;\n            },\n        };\n\n        try {\n            await this.confirmAndPrefetchCourses(courses, prefetchOptions);\n            prefetch.icon = CoreConstants.ICON_OUTDATED;\n        } finally {\n            prefetch.loading = false;\n            prefetch.badge = '';\n        }\n    }\n\n    /**\n     * Get a course download promise (if any).\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Download promise, undefined if not found.\n     */\n    getCourseDownloadPromise(courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        return this.courseDwnPromises[siteId] && this.courseDwnPromises[siteId][courseId];\n    }\n\n    /**\n     * Get a course status icon and the langkey to use as a title.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the icon name and the title key.\n     */\n    async getCourseStatusIconAndTitle(courseId: number, siteId?: string): Promise<CorePrefetchStatusInfo> {\n        const status = await CoreCourse.getCourseStatus(courseId, siteId);\n\n        return this.getCoursePrefetchStatusInfo(status);\n    }\n\n    /**\n     * Get a course status icon and the langkey to use as a title from status.\n     *\n     * @param status Course status.\n     * @returns Prefetch status info.\n     */\n    getCoursePrefetchStatusInfo(status: string): CorePrefetchStatusInfo {\n        const prefetchStatus: CorePrefetchStatusInfo = {\n            status: status,\n            icon: this.getPrefetchStatusIcon(status, false),\n            statusTranslatable: '',\n            loading: false,\n        };\n\n        if (status == CoreConstants.DOWNLOADED) {\n            // Always show refresh icon, we cannot know if there's anything new in course options.\n            prefetchStatus.statusTranslatable = 'core.course.refreshcourse';\n        } else if (status == CoreConstants.DOWNLOADING) {\n            prefetchStatus.statusTranslatable = 'core.downloading';\n            prefetchStatus.loading = true;\n        } else {\n            prefetchStatus.statusTranslatable = 'core.course.downloadcourse';\n        }\n\n        return prefetchStatus;\n    }\n\n    /**\n     * Get a courses status icon and the langkey to use as a title from status.\n     *\n     * @param status Courses status.\n     * @returns Prefetch status info.\n     */\n    getCoursesPrefetchStatusInfo(status: string): CorePrefetchStatusInfo {\n        const prefetchStatus: CorePrefetchStatusInfo = {\n            status: status,\n            icon: this.getPrefetchStatusIcon(status, false),\n            statusTranslatable: '',\n            loading: false,\n        };\n\n        if (status == CoreConstants.DOWNLOADED) {\n            // Always show refresh icon, we cannot know if there's anything new in course options.\n            prefetchStatus.statusTranslatable = 'core.courses.refreshcourses';\n        } else if (status == CoreConstants.DOWNLOADING) {\n            prefetchStatus.statusTranslatable = 'core.downloading';\n            prefetchStatus.loading = true;\n        } else {\n            prefetchStatus.statusTranslatable = 'core.courses.downloadcourses';\n        }\n\n        return prefetchStatus;\n    }\n\n    /**\n     * Get the icon given the status and if trust the download status.\n     *\n     * @param status Status constant.\n     * @param trustDownload True to show download success, false to show an outdated status when downloaded.\n     * @returns Icon name.\n     */\n    getPrefetchStatusIcon(status: string, trustDownload: boolean = false): string {\n        if (status == CoreConstants.NOT_DOWNLOADED) {\n            return CoreConstants.ICON_NOT_DOWNLOADED;\n        }\n        if (status == CoreConstants.OUTDATED || (status == CoreConstants.DOWNLOADED && !trustDownload)) {\n            return CoreConstants.ICON_OUTDATED;\n        }\n        if (status == CoreConstants.DOWNLOADED && trustDownload) {\n            return CoreConstants.ICON_DOWNLOADED;\n        }\n        if (status == CoreConstants.DOWNLOADING) {\n            return CoreConstants.ICON_DOWNLOADING;\n        }\n\n        return CoreConstants.ICON_DOWNLOADING;\n    }\n\n    /**\n     * Get prefetch info for a module.\n     *\n     * @param module Module to get the info from.\n     * @param courseId Course ID the section belongs to.\n     * @param invalidateCache Invalidates the cache first.\n     * @param component Component of the module.\n     * @returns Promise resolved with the info.\n     */\n    async getModulePrefetchInfo(\n        module: CoreCourseModuleData,\n        courseId: number,\n        invalidateCache = false,\n        component = '',\n    ): Promise<CoreCourseModulePrefetchInfo> {\n        if (invalidateCache) {\n            // Currently, some modules pass invalidateCache=false because they already invalidate data in downloadResourceIfNeeded.\n            // If this function is changed to do more actions if invalidateCache=true, please review those modules.\n            CoreCourseModulePrefetchDelegate.invalidateModuleStatusCache(module);\n\n            await CoreUtils.ignoreErrors(CoreCourseModulePrefetchDelegate.invalidateCourseUpdates(courseId));\n        }\n\n        const results = await Promise.all([\n            CoreCourseModulePrefetchDelegate.getModuleStoredSize(module, courseId),\n            CoreCourseModulePrefetchDelegate.getModuleStatus(module, courseId),\n            this.getModulePackageLastDownloaded(module, component),\n        ]);\n\n        // Treat stored size.\n        const size = results[0];\n        const sizeReadable = CoreTextUtils.bytesToSize(results[0], 2);\n\n        // Treat module status.\n        const status = results[1];\n        let statusIcon: string | undefined;\n        switch (results[1]) {\n            case CoreConstants.NOT_DOWNLOADED:\n                statusIcon = CoreConstants.ICON_NOT_DOWNLOADED;\n                break;\n            case CoreConstants.DOWNLOADING:\n                statusIcon = CoreConstants.ICON_DOWNLOADING;\n                break;\n            case CoreConstants.OUTDATED:\n                statusIcon = CoreConstants.ICON_OUTDATED;\n                break;\n            case CoreConstants.DOWNLOADED:\n                break;\n            default:\n                statusIcon = '';\n                break;\n        }\n\n        const packageData = results[2];\n\n        return {\n            size,\n            sizeReadable,\n            status,\n            statusIcon,\n            downloadTime: packageData.downloadTime,\n            downloadTimeReadable: packageData.downloadTimeReadable,\n        };\n    }\n\n    /**\n     * Get prefetch info for a module.\n     *\n     * @param module Module to get the info from.\n     * @param component Component of the module.\n     * @returns Promise resolved with the info.\n     */\n    async getModulePackageLastDownloaded(\n        module: CoreCourseModuleData,\n        component = '',\n    ): Promise<CoreCourseModulePackageLastDownloaded> {\n        const siteId = CoreSites.getCurrentSiteId();\n        const packageData = await CoreUtils.ignoreErrors(CoreFilepool.getPackageData(siteId, component, module.id));\n\n        // Treat download time.\n        if (!packageData || !packageData.downloadTime || !CoreFileHelper.isStateDownloaded(packageData.status || '')) {\n            // Not downloaded.\n            return {\n                downloadTime: 0,\n                downloadTimeReadable: '',\n            };\n        }\n\n        const now = CoreTimeUtils.timestamp();\n        const downloadTime = packageData.downloadTime;\n        let downloadTimeReadable = '';\n        if (now - downloadTime < 7 * 86400) {\n            downloadTimeReadable = moment(downloadTime * 1000).fromNow();\n        } else {\n            downloadTimeReadable = moment(downloadTime * 1000).calendar();\n        }\n\n        return {\n            downloadTime,\n            downloadTimeReadable,\n        };\n    }\n\n    /**\n     * Get the download ID of a section. It's used to interact with CoreCourseModulePrefetchDelegate.\n     *\n     * @param section Section.\n     * @returns Section download ID.\n     */\n    getSectionDownloadId(section: {id: number}): string {\n        return 'Section-' + section.id;\n    }\n\n    /**\n     * Navigate to a module using instance ID and module name.\n     *\n     * @param instanceId Activity instance ID.\n     * @param modName Module name of the activity.\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    async navigateToModuleByInstance(\n        instanceId: number,\n        modName: string,\n        options: CoreCourseNavigateToModuleByInstanceOptions = {},\n    ): Promise<void> {\n\n        const modal = await CoreDomUtils.showModalLoading();\n\n        try {\n            const module = await CoreCourse.getModuleBasicInfoByInstance(instanceId, modName, { siteId: options.siteId });\n\n            this.navigateToModule(\n                module.id,\n                {\n                    ...options,\n                    courseId: module.course,\n                    modName: options.useModNameToGetModule ? modName : undefined,\n                },\n            );\n        } catch (error) {\n            CoreDomUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);\n        } finally {\n            // Just in case. In fact we need to dismiss the modal before showing a toast or error message.\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Navigate to a module.\n     *\n     * @param moduleId Module's ID.\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    async navigateToModule(\n        moduleId: number,\n        options: CoreCourseNavigateToModuleOptions = {},\n    ): Promise<void> {\n        const siteId = options.siteId || CoreSites.getCurrentSiteId();\n        let courseId = options.courseId;\n        let sectionId = options.sectionId;\n\n        const modal = await CoreDomUtils.showModalLoading();\n\n        try {\n            if (!courseId || !sectionId) {\n                const module = await CoreCourse.getModuleBasicInfo(\n                    moduleId,\n                    { siteId, readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE },\n                );\n\n                courseId = module.course;\n                sectionId = module.section;\n            }\n\n            // Get the site.\n            const site = await CoreSites.getSite(siteId);\n\n            // Get the module.\n            const module = await CoreCourse.getModule(moduleId, courseId, sectionId, false, false, siteId, options.modName);\n\n            if (CoreSites.getCurrentSiteId() === site.getId()) {\n                // Try to use the module's handler to navigate cleanly.\n                module.handlerData = await CoreCourseModuleDelegate.getModuleDataFor(\n                    module.modname,\n                    module,\n                    courseId,\n                    sectionId,\n                    false,\n                );\n\n                if (module.handlerData?.action) {\n                    modal.dismiss();\n\n                    return module.handlerData.action(new Event('click'), module, courseId, options.modNavOptions);\n                }\n            }\n\n            const params: Params = {\n                course: { id: courseId },\n                module,\n                sectionId,\n                modNavOptions: options.modNavOptions,\n            };\n\n            if (courseId == site.getSiteHomeId()) {\n                // Check if site home is available.\n                const isAvailable = await CoreSiteHome.isAvailable();\n\n                if (isAvailable) {\n                    await CoreNavigator.navigateToSitePath(CoreSiteHomeHomeHandlerService.PAGE_NAME, { params, siteId });\n\n                    return;\n                }\n            }\n\n            modal.dismiss();\n\n            await this.getAndOpenCourse(courseId, params, siteId);\n        } catch (error) {\n            CoreDomUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Open a module.\n     *\n     * @param module The module to open.\n     * @param courseId The course ID of the module.\n     * @param options Other options.\n     * @returns True if module can be opened, false otherwise.\n     */\n    async openModule(module: CoreCourseModuleData, courseId: number, options: CoreCourseOpenModuleOptions = {}): Promise<boolean> {\n        if (!module.handlerData) {\n            module.handlerData = await CoreCourseModuleDelegate.getModuleDataFor(\n                module.modname,\n                module,\n                courseId,\n                options.sectionId,\n                false,\n            );\n        }\n\n        if (module.handlerData?.action) {\n            module.handlerData.action(new Event('click'), module, courseId, {\n                animated: false,\n                ...options.modNavOptions,\n            });\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Prefetch all the activities in a course and also the course addons.\n     *\n     * @param course The course to prefetch.\n     * @param sections List of course sections.\n     * @param courseHandlers List of course options handlers.\n     * @param courseMenuHandlers List of course menu handlers.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the download finishes.\n     */\n    async prefetchCourse(\n        course: CoreCourseAnyCourseData,\n        sections: CoreCourseWSSection[],\n        courseHandlers: CoreCourseOptionsHandlerToDisplay[],\n        courseMenuHandlers: CoreCourseOptionsMenuHandlerToDisplay[],\n        siteId?: string,\n    ): Promise<void> {\n        const requiredSiteId = siteId || CoreSites.getRequiredCurrentSite().getId();\n\n        if (this.courseDwnPromises[requiredSiteId] && this.courseDwnPromises[requiredSiteId][course.id] !== undefined) {\n            // There's already a download ongoing for this course, return the promise.\n            return this.courseDwnPromises[requiredSiteId][course.id];\n        } else if (!this.courseDwnPromises[requiredSiteId]) {\n            this.courseDwnPromises[requiredSiteId] = {};\n        }\n\n        // First of all, mark the course as being downloaded.\n        this.courseDwnPromises[requiredSiteId][course.id] = CoreCourse.setCourseStatus(\n            course.id,\n            CoreConstants.DOWNLOADING,\n            requiredSiteId,\n        ).then(async () => {\n\n            const promises: Promise<unknown>[] = [];\n\n            // Prefetch all the sections. If the first section is \"All sections\", use it. Otherwise, use a fake \"All sections\".\n            let allSectionsSection: CoreCourseWSSection = sections[0];\n            if (sections[0].id != CoreCourseProvider.ALL_SECTIONS_ID) {\n                allSectionsSection = this.createAllSectionsSection();\n            }\n            promises.push(this.prefetchSection(allSectionsSection, course.id, sections));\n\n            // Prefetch course options.\n            courseHandlers.forEach((handler) => {\n                if (handler.prefetch) {\n                    promises.push(handler.prefetch(course));\n                }\n            });\n            courseMenuHandlers.forEach((handler) => {\n                if (handler.prefetch) {\n                    promises.push(handler.prefetch(course));\n                }\n            });\n\n            // Prefetch other data needed to render the course.\n            promises.push(CoreCourses.getCoursesByField('id', course.id));\n\n            const sectionWithModules = sections.find((section) => section.modules && section.modules.length > 0);\n            if (!sectionWithModules || sectionWithModules.modules[0].completion === undefined) {\n                promises.push(CoreCourse.getActivitiesCompletionStatus(course.id));\n            }\n\n            promises.push(CoreFilterHelper.getFilters('course', course.id));\n\n            await CoreUtils.allPromises(promises);\n\n            // Download success, mark the course as downloaded.\n            return CoreCourse.setCourseStatus(course.id, CoreConstants.DOWNLOADED, requiredSiteId);\n        }).catch(async (error) => {\n            // Error, restore previous status.\n            await CoreCourse.setCoursePreviousStatus(course.id, requiredSiteId);\n\n            throw error;\n        }).finally(() => {\n            delete this.courseDwnPromises[requiredSiteId][course.id];\n        });\n\n        return this.courseDwnPromises[requiredSiteId][course.id];\n    }\n\n    /**\n     * Helper function to prefetch a module, showing a confirmation modal if the size is big\n     * and invalidating contents if refreshing.\n     *\n     * @param handler Prefetch handler to use.\n     * @param module Module to download.\n     * @param size Size to download.\n     * @param courseId Course ID of the module.\n     * @param refresh True if refreshing, false otherwise.\n     * @returns Promise resolved when downloaded.\n     */\n    async prefetchModule(\n        handler: CoreCourseModulePrefetchHandler,\n        module: CoreCourseModuleData,\n        size: CoreFileSizeSum,\n        courseId: number,\n        refresh?: boolean,\n    ): Promise<void> {\n        // Show confirmation if needed.\n        await CoreDomUtils.confirmDownloadSize(size);\n\n        // Invalidate content if refreshing and download the data.\n        if (refresh) {\n            await CoreUtils.ignoreErrors(handler.invalidateContent(module.id, courseId));\n        }\n\n        await CoreCourseModulePrefetchDelegate.prefetchModule(module, courseId, true);\n    }\n\n    /**\n     * Prefetch one section or all the sections.\n     * If the section is \"All sections\" it will prefetch all the sections.\n     *\n     * @param section Section.\n     * @param courseId Course ID the section belongs to.\n     * @param sections List of sections. Used when downloading all the sections.\n     * @returns Promise resolved when the prefetch is finished.\n     */\n    async prefetchSection(\n        section: CoreCourseSectionWithStatus,\n        courseId: number,\n        sections?: CoreCourseSectionWithStatus[],\n    ): Promise<void> {\n        if (section.id != CoreCourseProvider.ALL_SECTIONS_ID) {\n            try {\n                // Download only this section.\n                await this.prefetchSingleSectionIfNeeded(section, courseId);\n            } finally {\n                // Calculate the status of the section that finished.\n                await this.calculateSectionStatus(section, courseId, false, false);\n            }\n\n            return;\n        }\n\n        if (!sections) {\n            throw new CoreError('List of sections is required when downloading all sections.');\n        }\n\n        // Download all the sections except \"All sections\".\n        let allSectionsStatus = CoreConstants.NOT_DOWNLOADABLE;\n\n        section.isDownloading = true;\n        const promises = sections.map(async (section) => {\n            if (section.id == CoreCourseProvider.ALL_SECTIONS_ID) {\n                return;\n            }\n\n            try {\n                await this.prefetchSingleSectionIfNeeded(section, courseId);\n            } finally {\n                // Calculate the status of the section that finished.\n                const result = await this.calculateSectionStatus(section, courseId, false, false);\n\n                // Calculate \"All sections\" status.\n                allSectionsStatus = CoreFilepool.determinePackagesStatus(allSectionsStatus, result.statusData.status);\n            }\n        });\n\n        try {\n            await CoreUtils.allPromises(promises);\n\n            // Set \"All sections\" data.\n            section.downloadStatus = allSectionsStatus;\n            section.isDownloading = allSectionsStatus === CoreConstants.DOWNLOADING;\n        } finally {\n            section.isDownloading = false;\n        }\n    }\n\n    /**\n     * Prefetch a certain section if it needs to be prefetched.\n     * If the section is \"All sections\" it will be ignored.\n     *\n     * @param section Section to prefetch.\n     * @param courseId Course ID the section belongs to.\n     * @returns Promise resolved when the section is prefetched.\n     */\n    protected async prefetchSingleSectionIfNeeded(section: CoreCourseSectionWithStatus, courseId: number): Promise<void> {\n        if (section.id == CoreCourseProvider.ALL_SECTIONS_ID || section.hiddenbynumsections) {\n            return;\n        }\n\n        const promises: Promise<void>[] = [];\n        const siteId = CoreSites.getCurrentSiteId();\n\n        section.isDownloading = true;\n\n        // Download the modules.\n        promises.push(this.syncModulesAndPrefetchSection(section, courseId));\n\n        // Download the files in the section description.\n        const introFiles = CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(section.summary);\n        promises.push(CoreUtils.ignoreErrors(\n            CoreFilepool.addFilesToQueue(siteId, introFiles, CoreCourseProvider.COMPONENT, courseId),\n        ));\n\n        try {\n            await Promise.all(promises);\n        } finally {\n            section.isDownloading = false;\n        }\n    }\n\n    /**\n     * Sync modules in a section and prefetch them.\n     *\n     * @param section Section to prefetch.\n     * @param courseId Course ID the section belongs to.\n     * @returns Promise resolved when the section is prefetched.\n     */\n    protected async syncModulesAndPrefetchSection(section: CoreCourseSectionWithStatus, courseId: number): Promise<void> {\n        // Sync the modules first.\n        await CoreCourseModulePrefetchDelegate.syncModules(section.modules, courseId);\n\n        // Validate the section needs to be downloaded and calculate amount of modules that need to be downloaded.\n        const result = await CoreCourseModulePrefetchDelegate.getModulesStatus(section.modules, courseId, section.id);\n\n        if (result.status == CoreConstants.DOWNLOADED || result.status == CoreConstants.NOT_DOWNLOADABLE) {\n            // Section is downloaded or not downloadable, nothing to do.\n            return ;\n        }\n\n        await this.prefetchSingleSection(section, result, courseId);\n    }\n\n    /**\n     * Start or restore the prefetch of a section.\n     * If the section is \"All sections\" it will be ignored.\n     *\n     * @param section Section to download.\n     * @param result Result of CoreCourseModulePrefetchDelegate.getModulesStatus for this section.\n     * @param courseId Course ID the section belongs to.\n     * @returns Promise resolved when the section has been prefetched.\n     */\n    protected async prefetchSingleSection(\n        section: CoreCourseSectionWithStatus,\n        result: CoreCourseModulesStatus,\n        courseId: number,\n    ): Promise<void> {\n        if (section.id == CoreCourseProvider.ALL_SECTIONS_ID) {\n            return;\n        }\n\n        if (section.total && section.total > 0) {\n            // Already being downloaded.\n            return ;\n        }\n\n        // We only download modules with status notdownloaded, downloading or outdated.\n        const modules = result[CoreConstants.OUTDATED].concat(result[CoreConstants.NOT_DOWNLOADED])\n            .concat(result[CoreConstants.DOWNLOADING]);\n        const downloadId = this.getSectionDownloadId(section);\n\n        section.isDownloading = true;\n\n        // Prefetch all modules to prevent incoeherences in download count and to download stale data not marked as outdated.\n        await CoreCourseModulePrefetchDelegate.prefetchModules(downloadId, modules, courseId, (data) => {\n            section.count = data.count;\n            section.total = data.total;\n        });\n    }\n\n    /**\n     * Check if a section has content.\n     *\n     * @param section Section to check.\n     * @returns Whether the section has content.\n     */\n    sectionHasContent(section: CoreCourseWSSection): boolean {\n        if (!section.modules) {\n            return false;\n        }\n\n        if (section.hiddenbynumsections) {\n            return false;\n        }\n\n        return (section.availabilityinfo !== undefined && section.availabilityinfo != '') ||\n            section.summary != '' || (section.modules && section.modules.length > 0);\n    }\n\n    /**\n     * Wait for any course format plugin to load, and open the course page.\n     *\n     * If the plugin's promise is resolved, the course page will be opened. If it is rejected, they will see an error.\n     * If the promise for the plugin is still in progress when the user tries to open the course, a loader\n     * will be displayed until it is complete, before the course page is opened. If the promise is already complete,\n     * they will see the result immediately.\n     *\n     * @param course Course to open\n     * @param navOptions Navigation options that includes params to pass to the page.\n     * @returns Promise resolved when done.\n     */\n    async openCourse(\n        course: CoreCourseAnyCourseData | { id: number },\n        navOptions?: CoreNavigationOptions & { siteId?: string },\n    ): Promise<void> {\n        const siteId = navOptions?.siteId;\n        if (!siteId || siteId == CoreSites.getCurrentSiteId()) {\n            // Current site, we can open the course.\n            return CoreCourse.openCourse(course, navOptions);\n        } else {\n            // We need to load the site first.\n            navOptions = navOptions || {};\n\n            navOptions.params = navOptions.params || {};\n            Object.assign(navOptions.params, { course: course });\n\n            await CoreNavigator.navigateToSitePath(`course/${course.id}`, navOptions);\n        }\n    }\n\n    /**\n     * Check if user can access the course.\n     *\n     * @param courseId Course ID.\n     * @returns Promise resolved with boolean: whether user can access the course.\n     */\n    async userHasAccessToCourse(courseId: number): Promise<boolean> {\n        if (CoreNetwork.isOnline()) {\n            return CoreUtils.promiseWorks(\n                CoreCourse.getSections(courseId, true, true, { getFromCache: false, emergencyCache: false }, undefined, false),\n            );\n        } else {\n            return CoreUtils.promiseWorks(\n                CoreCourse.getSections(courseId, true, true, { getCacheUsingCacheKey: true }, undefined, false),\n            );\n        }\n    }\n\n    /**\n     * Delete course files.\n     *\n     * @param courseId Course id.\n     * @returns Promise to be resolved once the course files are deleted.\n     */\n    async deleteCourseFiles(courseId: number): Promise<void> {\n        const sections = await CoreCourse.getSections(courseId);\n        const modules = CoreArray.flatten(sections.map((section) => section.modules));\n\n        await Promise.all(\n            modules.map((module) => this.removeModuleStoredData(module, courseId)),\n        );\n\n        await CoreCourse.setCourseStatus(courseId, CoreConstants.NOT_DOWNLOADED);\n    }\n\n    /**\n     * Remove module stored data.\n     *\n     * @param module Module to remove the files.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when done.\n     */\n    async removeModuleStoredData(module: CoreCourseModuleData, courseId: number): Promise<void> {\n        const promises: Promise<void>[] = [];\n\n        promises.push(CoreCourseModulePrefetchDelegate.removeModuleFiles(module, courseId));\n\n        const handler = CoreCourseModulePrefetchDelegate.getPrefetchHandlerFor(module.modname);\n        const site = CoreSites.getCurrentSite();\n        if (handler && site) {\n            promises.push(site.deleteComponentFromCache(handler.component, module.id));\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Completion clicked.\n     *\n     * @param completion The completion.\n     * @returns Promise resolved with the result.\n     */\n    async changeManualCompletion(\n        completion: CoreCourseModuleCompletionData,\n    ): Promise<CoreStatusWithWarningsWSResponse | void> {\n        if (!completion) {\n            return;\n        }\n\n        if (completion.cmid === undefined ||\n            completion.tracking !== CoreCourseModuleCompletionTracking.COMPLETION_TRACKING_MANUAL) {\n            return;\n        }\n\n        const modal = await CoreDomUtils.showModalLoading();\n        completion.state = completion.state === CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE\n            ? CoreCourseModuleCompletionStatus.COMPLETION_INCOMPLETE\n            : CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE;\n\n        try {\n            const response = await CoreCourse.markCompletedManually(\n                completion.cmid,\n                completion.state === CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE,\n                completion.courseId,\n            );\n\n            if (response.offline) {\n                completion.offline = true;\n            }\n\n            return response;\n        } catch (error) {\n            // Restore previous state.\n            completion.state = completion.state === CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE\n                ? CoreCourseModuleCompletionStatus.COMPLETION_INCOMPLETE\n                : CoreCourseModuleCompletionStatus.COMPLETION_COMPLETE;\n\n            CoreDomUtils.showErrorModalDefault(error, 'core.errorchangecompletion', true);\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Retrieves course summary page module.\n     *\n     * @returns Course summary page module.\n     */\n    async getCourseSummaryRouteModule(): Promise<LazyRoutesModule> {\n        return import('../course-summary-lazy.module').then(m => m.CoreCourseSummaryLazyModule);\n    }\n\n    /**\n     * Open course summary in side modal.\n     *\n     * @param course Course selected\n     */\n    openCourseSummary(course: CoreCourseWithImageAndColor & CoreCourseAnyCourseData): void {\n        CoreDomUtils.openSideModal<void>({\n            component: CoreCourseSummaryPage,\n            componentProps: {\n                courseId: course.id,\n                course: course,\n            },\n        });\n    }\n\n    /**\n     * Register click for reminder local notification.\n     *\n     * @param component Component to register.\n     */\n    registerModuleReminderClick(component: string): void {\n        CoreLocalNotifications.registerClick<CoreRemindersPushNotificationData>(\n            component,\n            async (notification) => {\n                await ApplicationInit.donePromise;\n\n                CoreCourseHelper.navigateToModule(\n                    notification.instanceId,\n                    {\n                        siteId: notification.siteId,\n                    },\n                );\n            },\n        );\n    }\n\n}\n\nexport const CoreCourseHelper = makeSingleton(CoreCourseHelperProvider);\n\n/**\n * Section with calculated data.\n */\nexport type CoreCourseSection = CoreCourseWSSection & {\n    hasContent?: boolean;\n};\n\n/**\n * Section with data about prefetch.\n */\nexport type CoreCourseSectionWithStatus = CoreCourseSection & {\n    downloadStatus?: string; // Section status.\n    isDownloading?: boolean; // Whether section is being downloaded.\n    total?: number; // Total of modules being downloaded.\n    count?: number; // Number of downloaded modules.\n    isCalculating?: boolean; // Whether status is being calculated.\n};\n\n/**\n * Module with calculated data.\n */\nexport type CoreCourseModuleData = Omit<CoreCourseGetContentsWSModule, 'completiondata'> & {\n    course: number; // The course id.\n    isStealth?: boolean;\n    handlerData?: CoreCourseModuleHandlerData;\n    completiondata?: CoreCourseModuleCompletionData;\n    section: number;\n};\n\n/**\n * Module completion with calculated data.\n */\nexport type CoreCourseModuleCompletionData = CoreCourseModuleWSCompletionData & {\n    courseId: number;\n    tracking: CoreCourseModuleCompletionTracking;\n    cmid: number;\n    offline?: boolean;\n};\n\n/**\n * Options for prefetch course function.\n */\nexport type CoreCoursePrefetchCourseOptions = {\n    sections?: CoreCourseWSSection[]; // List of course sections.\n    courseHandlers?: CoreCourseOptionsHandlerToDisplay[]; // List of course handlers.\n    menuHandlers?: CoreCourseOptionsMenuHandlerToDisplay[]; // List of course menu handlers.\n    isGuest?: boolean; // Whether the user is using an ACCESS_GUEST enrolment method.\n};\n\n/**\n * Options for confirm and prefetch courses function.\n */\nexport type CoreCourseConfirmPrefetchCoursesOptions = {\n    onProgress?: (data: CoreCourseCoursesProgress) => void;\n};\n\n/**\n * Common options for navigate to module functions.\n */\ntype CoreCourseNavigateToModuleCommonOptions = {\n    courseId?: number; // Course ID. If not defined we'll try to retrieve it from the site.\n    sectionId?: number; // Section the module belongs to. If not defined we'll try to retrieve it from the site.\n    modNavOptions?: CoreNavigationOptions; // Navigation options to open the module, including params to pass to the module.\n    siteId?: string; // Site ID. If not defined, current site.\n};\n\n/**\n * Options for navigate to module by instance function.\n */\nexport type CoreCourseNavigateToModuleByInstanceOptions = CoreCourseNavigateToModuleCommonOptions & {\n    // True to retrieve all instances with a single WS call. Not recommended if can return a lot of contents.\n    useModNameToGetModule?: boolean;\n};\n\n/**\n * Options for navigate to module function.\n */\nexport type CoreCourseNavigateToModuleOptions = CoreCourseNavigateToModuleCommonOptions & {\n    modName?: string; // To retrieve all instances with a single WS call. Not recommended if can return a lot of contents.\n};\n\n/**\n * Options for open module function.\n */\nexport type CoreCourseOpenModuleOptions = {\n    sectionId?: number; // Section the module belongs to.\n    modNavOptions?: CoreNavigationOptions; // Navigation options to open the module, including params to pass to the module.\n};\n\n/**\n * Result of courseUsesGuestAccessInfo.\n */\nexport type CoreCourseGuestAccessInfo = {\n    guestAccess: boolean; // Whether guest access is enabled for a course.\n    requiresUserInput?: boolean; // Whether the first guest access enrolment method requires user input.\n    /**\n     * @deprecated since 4.3. Use requiresUserInput instead.\n     */\n    passwordRequired?: boolean;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}