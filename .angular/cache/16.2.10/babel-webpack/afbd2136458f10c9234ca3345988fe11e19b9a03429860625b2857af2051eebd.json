{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { AddonModAssign } from '@addons/mod/assign/services/assign';\nimport { AddonModAssignHelper } from '@addons/mod/assign/services/assign-helper';\nimport { AddonModAssignOffline } from '@addons/mod/assign/services/assign-offline';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModAssignSubmissionOnlineTextComponent } from '../component/onlinetext';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler for online text submission plugin.\n */\nexport class AddonModAssignSubmissionOnlineTextHandlerService {\n  constructor() {\n    this.name = 'AddonModAssignSubmissionOnlineTextHandler';\n    this.type = 'onlinetext';\n  }\n  /**\n   * Whether the plugin can be edited in offline for existing submissions. In general, this should return false if the\n   * plugin uses Moodle filters. The reason is that the app only prefetches filtered data, and the user should edit\n   * unfiltered data.\n   *\n   * @returns Boolean or promise resolved with boolean: whether it can be edited in offline.\n   */\n  canEditOffline() {\n    // This plugin uses Moodle filters, it cannot be edited in offline.\n    return false;\n  }\n  /**\n   * Check if a plugin has no data.\n   *\n   * @param assign The assignment.\n   * @param plugin The plugin object.\n   * @returns Whether the plugin is empty.\n   */\n  isEmpty(assign, plugin) {\n    const text = AddonModAssign.getSubmissionPluginText(plugin, true);\n    // If the text is empty, we can ignore files because they won't be visible anyways.\n    return text.trim().length === 0;\n  }\n  /**\n   * This function will be called when the user wants to create a new submission based on the previous one.\n   * It should add to pluginData the data to send to server based in the data in plugin (previous attempt).\n   *\n   * @param assign The assignment.\n   * @param plugin The plugin object.\n   * @param pluginData Object where to store the data to send.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns If the function is async, it should return a Promise resolved when done.\n   */\n  copySubmissionData(assign, plugin, pluginData, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const text = AddonModAssign.getSubmissionPluginText(plugin, true);\n      const files = AddonModAssign.getSubmissionPluginAttachments(plugin);\n      let itemId = 0;\n      if (files.length) {\n        // Re-upload the files.\n        itemId = yield AddonModAssignHelper.uploadFiles(assign.id, files, siteId);\n      }\n      pluginData.onlinetext_editor = {\n        text: text,\n        format: 1,\n        itemid: itemId\n      };\n    })();\n  }\n  /**\n   * Return the Component to use to display the plugin data, either in read or in edit mode.\n   * It's recommended to return the class of the component, but you can also return an instance of the component.\n   *\n   * @returns The component (or promise resolved with component) to use, undefined if not found.\n   */\n  getComponent() {\n    return AddonModAssignSubmissionOnlineTextComponent;\n  }\n  /**\n   * Get files used by this plugin.\n   * The files returned by this function will be prefetched when the user prefetches the assign.\n   *\n   * @param assign The assignment.\n   * @param submission The submission.\n   * @param plugin The plugin object.\n   * @returns The files (or promise resolved with the files).\n   */\n  getPluginFiles(assign, submission, plugin) {\n    return AddonModAssign.getSubmissionPluginAttachments(plugin);\n  }\n  /**\n   * Get the size of data (in bytes) this plugin will send to copy a previous submission.\n   *\n   * @param assign The assignment.\n   * @param plugin The plugin object.\n   * @returns The size (or promise resolved with size).\n   */\n  getSizeForCopy(assign, plugin) {\n    return _asyncToGenerator(function* () {\n      const text = AddonModAssign.getSubmissionPluginText(plugin, true);\n      const files = AddonModAssign.getSubmissionPluginAttachments(plugin);\n      const filesSize = yield CoreFileHelper.getTotalFilesSize(files);\n      return text.length + filesSize;\n    })();\n  }\n  /**\n   * Get the size of data (in bytes) this plugin will send to add or edit a submission.\n   *\n   * @param assign The assignment.\n   * @param submission The submission.\n   * @param plugin The plugin object.\n   * @returns The size (or promise resolved with size).\n   */\n  getSizeForEdit(assign, submission, plugin) {\n    const text = AddonModAssign.getSubmissionPluginText(plugin, true);\n    return text.length;\n  }\n  /**\n   * Get the text to submit.\n   *\n   * @param plugin The plugin object.\n   * @param inputData Data entered by the user for the submission.\n   * @returns Text to submit.\n   */\n  getTextToSubmit(plugin, inputData) {\n    const text = inputData.onlinetext_editor_text;\n    const files = plugin.fileareas && plugin.fileareas[0] && plugin.fileareas[0].files || [];\n    return CoreTextUtils.restorePluginfileUrls(text, files || []);\n  }\n  /**\n   * Check if the submission data has changed for this plugin.\n   *\n   * @param assign The assignment.\n   * @param submission The submission.\n   * @param plugin The plugin object.\n   * @param inputData Data entered by the user for the submission.\n   * @returns Boolean (or promise resolved with boolean): whether the data has changed.\n   */\n  hasDataChanged(assign, submission, plugin, inputData) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Get the original text from plugin or offline.\n      const offlineData = yield CoreUtils.ignoreErrors(AddonModAssignOffline.getSubmission(assign.id, submission.userid));\n      let initialText = '';\n      if (offlineData && offlineData.plugindata && offlineData.plugindata.onlinetext_editor) {\n        initialText = offlineData.plugindata.onlinetext_editor.text;\n      } else {\n        // No offline data found, get text from plugin.\n        initialText = plugin.editorfields && plugin.editorfields[0] ? plugin.editorfields[0].text : '';\n      }\n      // Check if text has changed.\n      return initialText != _this.getTextToSubmit(plugin, inputData);\n    })();\n  }\n  /**\n   * Whether or not the handler is enabled on a site level.\n   *\n   * @returns True or promise resolved with true if enabled.\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  /**\n   * Whether or not the handler is enabled for edit on a site level.\n   *\n   * @returns Whether or not the handler is enabled for edit on a site level.\n   */\n  isEnabledForEdit() {\n    return true;\n  }\n  /**\n   * Prepare and add to pluginData the data to send to the server based on the input data.\n   *\n   * @param assign The assignment.\n   * @param submission The submission.\n   * @param plugin The plugin object.\n   * @param inputData Data entered by the user for the submission.\n   * @param pluginData Object where to store the data to send.\n   */\n  prepareSubmissionData(assign, submission, plugin, inputData, pluginData) {\n    let text = this.getTextToSubmit(plugin, inputData);\n    // Check word limit.\n    const configs = AddonModAssignHelper.getPluginConfig(assign, 'assignsubmission', plugin.type);\n    if (parseInt(configs.wordlimitenabled, 10)) {\n      const words = CoreTextUtils.countWords(text);\n      const wordlimit = parseInt(configs.wordlimit, 10);\n      if (words > wordlimit) {\n        const params = {\n          $a: {\n            count: words,\n            limit: wordlimit\n          }\n        };\n        const message = Translate.instant('addon.mod_assign_submission_onlinetext.wordlimitexceeded', params);\n        throw new CoreError(message);\n      }\n    }\n    // Add some HTML to the text if needed.\n    text = CoreTextUtils.formatHtmlLines(text);\n    pluginData.onlinetext_editor = {\n      text: text,\n      format: 1,\n      itemid: 0 // Can't add new files yet, so we use a fake itemid.\n    };\n  }\n  /**\n   * Prepare and add to pluginData the data to send to the server based on the offline data stored.\n   * This will be used when performing a synchronization.\n   *\n   * @param assign The assignment.\n   * @param submission The submission.\n   * @param plugin The plugin object.\n   * @param offlineData Offline data stored.\n   * @param pluginData Object where to store the data to send.\n   */\n  prepareSyncData(assign, submission, plugin, offlineData, pluginData) {\n    const offlinePluginData = offlineData && offlineData.plugindata;\n    const textData = offlinePluginData.onlinetext_editor;\n    if (textData) {\n      // Has some data to sync.\n      pluginData.onlinetext_editor = textData;\n    }\n  }\n}\n_class = AddonModAssignSubmissionOnlineTextHandlerService;\n_class.ɵfac = function AddonModAssignSubmissionOnlineTextHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModAssignSubmissionOnlineTextHandler = makeSingleton(AddonModAssignSubmissionOnlineTextHandlerService);","map":{"version":3,"names":["AddonModAssign","AddonModAssignHelper","AddonModAssignOffline","CoreError","CoreFileHelper","CoreTextUtils","CoreUtils","makeSingleton","Translate","AddonModAssignSubmissionOnlineTextComponent","AddonModAssignSubmissionOnlineTextHandlerService","constructor","name","type","canEditOffline","isEmpty","assign","plugin","text","getSubmissionPluginText","trim","length","copySubmissionData","pluginData","userId","siteId","_asyncToGenerator","files","getSubmissionPluginAttachments","itemId","uploadFiles","id","onlinetext_editor","format","itemid","getComponent","getPluginFiles","submission","getSizeForCopy","filesSize","getTotalFilesSize","getSizeForEdit","getTextToSubmit","inputData","onlinetext_editor_text","fileareas","restorePluginfileUrls","hasDataChanged","_this","offlineData","ignoreErrors","getSubmission","userid","initialText","plugindata","editorfields","isEnabled","isEnabledForEdit","prepareSubmissionData","configs","getPluginConfig","parseInt","wordlimitenabled","words","countWords","wordlimit","params","$a","count","limit","message","instant","formatHtmlLines","prepareSyncData","offlinePluginData","textData","factory","ɵfac","providedIn","AddonModAssignSubmissionOnlineTextHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/assign/submission/onlinetext/services/handler.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type { AddonModAssignSubmissionPluginBaseComponent } from '@addons/mod/assign/classes/base-submission-plugin-component';\nimport {\n    AddonModAssignAssign,\n    AddonModAssignSubmission,\n    AddonModAssignPlugin,\n    AddonModAssign,\n} from '@addons/mod/assign/services/assign';\nimport { AddonModAssignHelper } from '@addons/mod/assign/services/assign-helper';\nimport { AddonModAssignOffline, AddonModAssignSubmissionsDBRecordFormatted } from '@addons/mod/assign/services/assign-offline';\nimport { AddonModAssignSubmissionHandler } from '@addons/mod/assign/services/submission-delegate';\nimport { Injectable, Type } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModAssignSubmissionOnlineTextComponent } from '../component/onlinetext';\n\n/**\n * Handler for online text submission plugin.\n */\n@Injectable( { providedIn: 'root' })\nexport class AddonModAssignSubmissionOnlineTextHandlerService implements AddonModAssignSubmissionHandler {\n\n    name = 'AddonModAssignSubmissionOnlineTextHandler';\n    type = 'onlinetext';\n\n    /**\n     * Whether the plugin can be edited in offline for existing submissions. In general, this should return false if the\n     * plugin uses Moodle filters. The reason is that the app only prefetches filtered data, and the user should edit\n     * unfiltered data.\n     *\n     * @returns Boolean or promise resolved with boolean: whether it can be edited in offline.\n     */\n    canEditOffline(): boolean {\n        // This plugin uses Moodle filters, it cannot be edited in offline.\n        return false;\n    }\n\n    /**\n     * Check if a plugin has no data.\n     *\n     * @param assign The assignment.\n     * @param plugin The plugin object.\n     * @returns Whether the plugin is empty.\n     */\n    isEmpty(assign: AddonModAssignAssign, plugin: AddonModAssignPlugin): boolean {\n        const text = AddonModAssign.getSubmissionPluginText(plugin, true);\n\n        // If the text is empty, we can ignore files because they won't be visible anyways.\n        return text.trim().length === 0;\n    }\n\n    /**\n     * This function will be called when the user wants to create a new submission based on the previous one.\n     * It should add to pluginData the data to send to server based in the data in plugin (previous attempt).\n     *\n     * @param assign The assignment.\n     * @param plugin The plugin object.\n     * @param pluginData Object where to store the data to send.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns If the function is async, it should return a Promise resolved when done.\n     */\n    async copySubmissionData(\n        assign: AddonModAssignAssign,\n        plugin: AddonModAssignPlugin,\n        pluginData: AddonModAssignSubmissionOnlineTextPluginData,\n        userId?: number,\n        siteId?: string,\n    ): Promise<void> {\n\n        const text = AddonModAssign.getSubmissionPluginText(plugin, true);\n        const files = AddonModAssign.getSubmissionPluginAttachments(plugin);\n        let itemId = 0;\n\n        if (files.length) {\n            // Re-upload the files.\n            itemId = await AddonModAssignHelper.uploadFiles(assign.id, files, siteId);\n        }\n\n        pluginData.onlinetext_editor = {\n            text: text,\n            format: 1,\n            itemid: itemId,\n        };\n    }\n\n    /**\n     * Return the Component to use to display the plugin data, either in read or in edit mode.\n     * It's recommended to return the class of the component, but you can also return an instance of the component.\n     *\n     * @returns The component (or promise resolved with component) to use, undefined if not found.\n     */\n    getComponent(): Type<AddonModAssignSubmissionPluginBaseComponent> {\n        return AddonModAssignSubmissionOnlineTextComponent;\n    }\n\n    /**\n     * Get files used by this plugin.\n     * The files returned by this function will be prefetched when the user prefetches the assign.\n     *\n     * @param assign The assignment.\n     * @param submission The submission.\n     * @param plugin The plugin object.\n     * @returns The files (or promise resolved with the files).\n     */\n    getPluginFiles(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission,\n        plugin: AddonModAssignPlugin,\n    ): CoreWSFile[] {\n        return AddonModAssign.getSubmissionPluginAttachments(plugin);\n    }\n\n    /**\n     * Get the size of data (in bytes) this plugin will send to copy a previous submission.\n     *\n     * @param assign The assignment.\n     * @param plugin The plugin object.\n     * @returns The size (or promise resolved with size).\n     */\n    async getSizeForCopy(assign: AddonModAssignAssign, plugin: AddonModAssignPlugin): Promise<number> {\n        const text = AddonModAssign.getSubmissionPluginText(plugin, true);\n        const files = AddonModAssign.getSubmissionPluginAttachments(plugin);\n\n        const filesSize = await CoreFileHelper.getTotalFilesSize(files);\n\n        return text.length + filesSize;\n    }\n\n    /**\n     * Get the size of data (in bytes) this plugin will send to add or edit a submission.\n     *\n     * @param assign The assignment.\n     * @param submission The submission.\n     * @param plugin The plugin object.\n     * @returns The size (or promise resolved with size).\n     */\n    getSizeForEdit(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission,\n        plugin: AddonModAssignPlugin,\n    ): number {\n        const text = AddonModAssign.getSubmissionPluginText(plugin, true);\n\n        return text.length;\n    }\n\n    /**\n     * Get the text to submit.\n     *\n     * @param plugin The plugin object.\n     * @param inputData Data entered by the user for the submission.\n     * @returns Text to submit.\n     */\n    protected getTextToSubmit(plugin: AddonModAssignPlugin, inputData: AddonModAssignSubmissionOnlineTextData): string {\n        const text = inputData.onlinetext_editor_text;\n        const files = plugin.fileareas && plugin.fileareas[0] && plugin.fileareas[0].files || [];\n\n        return CoreTextUtils.restorePluginfileUrls(text, files || []);\n    }\n\n    /**\n     * Check if the submission data has changed for this plugin.\n     *\n     * @param assign The assignment.\n     * @param submission The submission.\n     * @param plugin The plugin object.\n     * @param inputData Data entered by the user for the submission.\n     * @returns Boolean (or promise resolved with boolean): whether the data has changed.\n     */\n    async hasDataChanged(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission,\n        plugin: AddonModAssignPlugin,\n        inputData: AddonModAssignSubmissionOnlineTextData,\n    ): Promise<boolean> {\n\n        // Get the original text from plugin or offline.\n        const offlineData =\n            await CoreUtils.ignoreErrors(AddonModAssignOffline.getSubmission(assign.id, submission.userid));\n\n        let initialText = '';\n        if (offlineData && offlineData.plugindata && offlineData.plugindata.onlinetext_editor) {\n            initialText = (<AddonModAssignSubmissionOnlineTextPluginData>offlineData.plugindata).onlinetext_editor.text;\n        } else {\n            // No offline data found, get text from plugin.\n            initialText = plugin.editorfields && plugin.editorfields[0] ? plugin.editorfields[0].text : '';\n        }\n\n        // Check if text has changed.\n        return initialText != this.getTextToSubmit(plugin, inputData);\n    }\n\n    /**\n     * Whether or not the handler is enabled on a site level.\n     *\n     * @returns True or promise resolved with true if enabled.\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * Whether or not the handler is enabled for edit on a site level.\n     *\n     * @returns Whether or not the handler is enabled for edit on a site level.\n     */\n    isEnabledForEdit(): boolean {\n        return true;\n    }\n\n    /**\n     * Prepare and add to pluginData the data to send to the server based on the input data.\n     *\n     * @param assign The assignment.\n     * @param submission The submission.\n     * @param plugin The plugin object.\n     * @param inputData Data entered by the user for the submission.\n     * @param pluginData Object where to store the data to send.\n     */\n    prepareSubmissionData(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission,\n        plugin: AddonModAssignPlugin,\n        inputData: AddonModAssignSubmissionOnlineTextData,\n        pluginData: AddonModAssignSubmissionOnlineTextPluginData,\n    ): void {\n\n        let text = this.getTextToSubmit(plugin, inputData);\n\n        // Check word limit.\n        const configs = AddonModAssignHelper.getPluginConfig(assign, 'assignsubmission', plugin.type);\n        if (parseInt(configs.wordlimitenabled, 10)) {\n            const words = CoreTextUtils.countWords(text);\n            const wordlimit = parseInt(configs.wordlimit, 10);\n            if (words > wordlimit) {\n                const params = { $a: { count: words, limit: wordlimit } };\n                const message = Translate.instant('addon.mod_assign_submission_onlinetext.wordlimitexceeded', params);\n\n                throw new CoreError(message);\n            }\n        }\n\n        // Add some HTML to the text if needed.\n        text = CoreTextUtils.formatHtmlLines(text);\n\n        pluginData.onlinetext_editor = {\n            text: text,\n            format: 1,\n            itemid: 0, // Can't add new files yet, so we use a fake itemid.\n        };\n    }\n\n    /**\n     * Prepare and add to pluginData the data to send to the server based on the offline data stored.\n     * This will be used when performing a synchronization.\n     *\n     * @param assign The assignment.\n     * @param submission The submission.\n     * @param plugin The plugin object.\n     * @param offlineData Offline data stored.\n     * @param pluginData Object where to store the data to send.\n     */\n    prepareSyncData(\n        assign: AddonModAssignAssign,\n        submission: AddonModAssignSubmission,\n        plugin: AddonModAssignPlugin,\n        offlineData: AddonModAssignSubmissionsDBRecordFormatted,\n        pluginData: AddonModAssignSubmissionOnlineTextPluginData,\n    ): void {\n\n        const offlinePluginData = <AddonModAssignSubmissionOnlineTextPluginData>(offlineData && offlineData.plugindata);\n        const textData = offlinePluginData.onlinetext_editor;\n        if (textData) {\n            // Has some data to sync.\n            pluginData.onlinetext_editor = textData;\n        }\n    }\n\n}\nexport const AddonModAssignSubmissionOnlineTextHandler = makeSingleton(AddonModAssignSubmissionOnlineTextHandlerService);\n\nexport type AddonModAssignSubmissionOnlineTextData = {\n    // The text for this submission.\n    onlinetext_editor_text: string; // eslint-disable-line @typescript-eslint/naming-convention\n};\n\nexport type AddonModAssignSubmissionOnlineTextPluginData = {\n    // Editor structure.\n    onlinetext_editor: { // eslint-disable-line @typescript-eslint/naming-convention\n        text: string; // The text for this submission.\n        format: number; // The format for this submission.\n        itemid: number; // The draft area id for files attached to the submission.\n    };\n};\n"],"mappings":";;AAeA,SAIIA,cAAc,QACX,oCAAoC;AAC3C,SAASC,oBAAoB,QAAQ,2CAA2C;AAChF,SAASC,qBAAqB,QAAoD,4CAA4C;AAG9H,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,cAAc,QAAQ,uBAAuB;AACtD,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,SAAS,QAAQ,uBAAuB;AAEjD,SAASC,aAAa,EAAEC,SAAS,QAAQ,aAAa;AACtD,SAASC,2CAA2C,QAAQ,yBAAyB;;AAErF;;;AAIA,OAAM,MAAOC,gDAAgD;EAD7DC,YAAA;IAGI,KAAAC,IAAI,GAAG,2CAA2C;IAClD,KAAAC,IAAI,GAAG,YAAY;;EAEnB;;;;;;;EAOAC,cAAcA,CAAA;IACV;IACA,OAAO,KAAK;EAChB;EAEA;;;;;;;EAOAC,OAAOA,CAACC,MAA4B,EAAEC,MAA4B;IAC9D,MAAMC,IAAI,GAAGlB,cAAc,CAACmB,uBAAuB,CAACF,MAAM,EAAE,IAAI,CAAC;IAEjE;IACA,OAAOC,IAAI,CAACE,IAAI,EAAE,CAACC,MAAM,KAAK,CAAC;EACnC;EAEA;;;;;;;;;;;EAWMC,kBAAkBA,CACpBN,MAA4B,EAC5BC,MAA4B,EAC5BM,UAAwD,EACxDC,MAAe,EACfC,MAAe;IAAA,OAAAC,iBAAA;MAGf,MAAMR,IAAI,GAAGlB,cAAc,CAACmB,uBAAuB,CAACF,MAAM,EAAE,IAAI,CAAC;MACjE,MAAMU,KAAK,GAAG3B,cAAc,CAAC4B,8BAA8B,CAACX,MAAM,CAAC;MACnE,IAAIY,MAAM,GAAG,CAAC;MAEd,IAAIF,KAAK,CAACN,MAAM,EAAE;QACd;QACAQ,MAAM,SAAS5B,oBAAoB,CAAC6B,WAAW,CAACd,MAAM,CAACe,EAAE,EAAEJ,KAAK,EAAEF,MAAM,CAAC;;MAG7EF,UAAU,CAACS,iBAAiB,GAAG;QAC3Bd,IAAI,EAAEA,IAAI;QACVe,MAAM,EAAE,CAAC;QACTC,MAAM,EAAEL;OACX;IAAC;EACN;EAEA;;;;;;EAMAM,YAAYA,CAAA;IACR,OAAO1B,2CAA2C;EACtD;EAEA;;;;;;;;;EASA2B,cAAcA,CACVpB,MAA4B,EAC5BqB,UAAoC,EACpCpB,MAA4B;IAE5B,OAAOjB,cAAc,CAAC4B,8BAA8B,CAACX,MAAM,CAAC;EAChE;EAEA;;;;;;;EAOMqB,cAAcA,CAACtB,MAA4B,EAAEC,MAA4B;IAAA,OAAAS,iBAAA;MAC3E,MAAMR,IAAI,GAAGlB,cAAc,CAACmB,uBAAuB,CAACF,MAAM,EAAE,IAAI,CAAC;MACjE,MAAMU,KAAK,GAAG3B,cAAc,CAAC4B,8BAA8B,CAACX,MAAM,CAAC;MAEnE,MAAMsB,SAAS,SAASnC,cAAc,CAACoC,iBAAiB,CAACb,KAAK,CAAC;MAE/D,OAAOT,IAAI,CAACG,MAAM,GAAGkB,SAAS;IAAC;EACnC;EAEA;;;;;;;;EAQAE,cAAcA,CACVzB,MAA4B,EAC5BqB,UAAoC,EACpCpB,MAA4B;IAE5B,MAAMC,IAAI,GAAGlB,cAAc,CAACmB,uBAAuB,CAACF,MAAM,EAAE,IAAI,CAAC;IAEjE,OAAOC,IAAI,CAACG,MAAM;EACtB;EAEA;;;;;;;EAOUqB,eAAeA,CAACzB,MAA4B,EAAE0B,SAAiD;IACrG,MAAMzB,IAAI,GAAGyB,SAAS,CAACC,sBAAsB;IAC7C,MAAMjB,KAAK,GAAGV,MAAM,CAAC4B,SAAS,IAAI5B,MAAM,CAAC4B,SAAS,CAAC,CAAC,CAAC,IAAI5B,MAAM,CAAC4B,SAAS,CAAC,CAAC,CAAC,CAAClB,KAAK,IAAI,EAAE;IAExF,OAAOtB,aAAa,CAACyC,qBAAqB,CAAC5B,IAAI,EAAES,KAAK,IAAI,EAAE,CAAC;EACjE;EAEA;;;;;;;;;EASMoB,cAAcA,CAChB/B,MAA4B,EAC5BqB,UAAoC,EACpCpB,MAA4B,EAC5B0B,SAAiD;IAAA,IAAAK,KAAA;IAAA,OAAAtB,iBAAA;MAGjD;MACA,MAAMuB,WAAW,SACP3C,SAAS,CAAC4C,YAAY,CAAChD,qBAAqB,CAACiD,aAAa,CAACnC,MAAM,CAACe,EAAE,EAAEM,UAAU,CAACe,MAAM,CAAC,CAAC;MAEnG,IAAIC,WAAW,GAAG,EAAE;MACpB,IAAIJ,WAAW,IAAIA,WAAW,CAACK,UAAU,IAAIL,WAAW,CAACK,UAAU,CAACtB,iBAAiB,EAAE;QACnFqB,WAAW,GAAkDJ,WAAW,CAACK,UAAW,CAACtB,iBAAiB,CAACd,IAAI;OAC9G,MAAM;QACH;QACAmC,WAAW,GAAGpC,MAAM,CAACsC,YAAY,IAAItC,MAAM,CAACsC,YAAY,CAAC,CAAC,CAAC,GAAGtC,MAAM,CAACsC,YAAY,CAAC,CAAC,CAAC,CAACrC,IAAI,GAAG,EAAE;;MAGlG;MACA,OAAOmC,WAAW,IAAIL,KAAI,CAACN,eAAe,CAACzB,MAAM,EAAE0B,SAAS,CAAC;IAAC;EAClE;EAEA;;;;;EAKMa,SAASA,CAAA;IAAA,OAAA9B,iBAAA;MACX,OAAO,IAAI;IAAC;EAChB;EAEA;;;;;EAKA+B,gBAAgBA,CAAA;IACZ,OAAO,IAAI;EACf;EAEA;;;;;;;;;EASAC,qBAAqBA,CACjB1C,MAA4B,EAC5BqB,UAAoC,EACpCpB,MAA4B,EAC5B0B,SAAiD,EACjDpB,UAAwD;IAGxD,IAAIL,IAAI,GAAG,IAAI,CAACwB,eAAe,CAACzB,MAAM,EAAE0B,SAAS,CAAC;IAElD;IACA,MAAMgB,OAAO,GAAG1D,oBAAoB,CAAC2D,eAAe,CAAC5C,MAAM,EAAE,kBAAkB,EAAEC,MAAM,CAACJ,IAAI,CAAC;IAC7F,IAAIgD,QAAQ,CAACF,OAAO,CAACG,gBAAgB,EAAE,EAAE,CAAC,EAAE;MACxC,MAAMC,KAAK,GAAG1D,aAAa,CAAC2D,UAAU,CAAC9C,IAAI,CAAC;MAC5C,MAAM+C,SAAS,GAAGJ,QAAQ,CAACF,OAAO,CAACM,SAAS,EAAE,EAAE,CAAC;MACjD,IAAIF,KAAK,GAAGE,SAAS,EAAE;QACnB,MAAMC,MAAM,GAAG;UAAEC,EAAE,EAAE;YAAEC,KAAK,EAAEL,KAAK;YAAEM,KAAK,EAAEJ;UAAS;QAAE,CAAE;QACzD,MAAMK,OAAO,GAAG9D,SAAS,CAAC+D,OAAO,CAAC,0DAA0D,EAAEL,MAAM,CAAC;QAErG,MAAM,IAAI/D,SAAS,CAACmE,OAAO,CAAC;;;IAIpC;IACApD,IAAI,GAAGb,aAAa,CAACmE,eAAe,CAACtD,IAAI,CAAC;IAE1CK,UAAU,CAACS,iBAAiB,GAAG;MAC3Bd,IAAI,EAAEA,IAAI;MACVe,MAAM,EAAE,CAAC;MACTC,MAAM,EAAE,CAAC,CAAE;KACd;EACL;EAEA;;;;;;;;;;EAUAuC,eAAeA,CACXzD,MAA4B,EAC5BqB,UAAoC,EACpCpB,MAA4B,EAC5BgC,WAAuD,EACvD1B,UAAwD;IAGxD,MAAMmD,iBAAiB,GAAkDzB,WAAW,IAAIA,WAAW,CAACK,UAAW;IAC/G,MAAMqB,QAAQ,GAAGD,iBAAiB,CAAC1C,iBAAiB;IACpD,IAAI2C,QAAQ,EAAE;MACV;MACApD,UAAU,CAACS,iBAAiB,GAAG2C,QAAQ;;EAE/C;;SAjQSjE,gDAAgD;;mBAAhDA,MAAgD;AAAA;;SAAhDA,MAAgD;EAAAkE,OAAA,EAAhDlE,MAAgD,CAAAmE,IAAA;EAAAC,UAAA,EADlC;AAAM;AAqQjC,OAAO,MAAMC,yCAAyC,GAAGxE,aAAa,CAACG,gDAAgD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}