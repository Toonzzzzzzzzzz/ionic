{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBaseProvider } from '@classes/base-sync';\nimport { CoreComments, CoreCommentsProvider } from './comments';\nimport { CoreEvents } from '@singletons/events';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreCommentsOffline } from './comments-offline';\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync omments.\n */\nexport class CoreCommentsSyncProvider extends CoreSyncBaseProvider {\n  constructor() {\n    super('CoreCommentsSync');\n  }\n  /**\n   * Try to synchronize all the comments in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllComments(siteId, force) {\n    return this.syncOnSites('all comments', siteId => this.syncAllCommentsFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Synchronize all the comments in a certain site\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllCommentsFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const comments = yield CoreCommentsOffline.getAllComments(siteId);\n      const commentsUnique = {};\n      // Get Unique array.\n      comments.forEach(comment => {\n        const syncId = _this.getSyncId(comment.contextlevel, comment.instanceid, comment.component, comment.itemid, comment.area);\n        commentsUnique[syncId] = comment;\n      });\n      // Sync all courses.\n      const promises = Object.keys(commentsUnique).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (key) {\n          const comment = commentsUnique[key];\n          const result = yield force ? _this.syncComments(comment.contextlevel, comment.instanceid, comment.component, comment.itemid, comment.area, siteId) : _this.syncCommentsIfNeeded(comment.contextlevel, comment.instanceid, comment.component, comment.itemid, comment.area, siteId);\n          if (result !== undefined) {\n            // Sync successful, send event.\n            CoreEvents.trigger(CoreCommentsSyncProvider.AUTO_SYNCED, {\n              contextLevel: comment.contextlevel,\n              instanceId: comment.instanceid,\n              componentName: comment.component,\n              itemId: comment.itemid,\n              area: comment.area,\n              warnings: result.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Sync course comments only if a certain time has passed since the last time.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the comments are synced or if they don't need to be synced.\n   */\n  syncCommentsIfNeeded(contextLevel, instanceId, component, itemId, area = '', siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const syncId = _this2.getSyncId(contextLevel, instanceId, component, itemId, area);\n      const needed = yield _this2.isSyncNeeded(syncId, siteId);\n      if (needed) {\n        return _this2.syncComments(contextLevel, instanceId, component, itemId, area, siteId);\n      }\n    })();\n  }\n  /**\n   * Synchronize comments in a particular area.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncComments(contextLevel, instanceId, component, itemId, area = '', siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const syncId = this.getSyncId(contextLevel, instanceId, component, itemId, area);\n    const currentSyncPromise = this.getOngoingSync(syncId, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for comments, return the promise.\n      return currentSyncPromise;\n    }\n    this.logger.debug('Try to sync comments ' + syncId + ' in site ' + siteId);\n    const syncPromise = this.performSyncComments(contextLevel, instanceId, component, itemId, area, siteId);\n    return this.addOngoingSync(syncId, syncPromise, siteId);\n  }\n  /**\n   * Performs the syncronization of comments in a particular area.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  performSyncComments(contextLevel, instanceId, component, itemId, area = '', siteId) {\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Get offline comments to be sent.\n      const comments = yield CoreCommentsOffline.getComments(contextLevel, instanceId, component, itemId, area, siteId);\n      if (!comments.length) {\n        // Nothing to sync.\n        return result;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      const errors = [];\n      const promises = [];\n      const deleteCommentIds = [];\n      let countChange = 0;\n      comments.forEach(comment => {\n        if ('deleted' in comment) {\n          deleteCommentIds.push(comment.commentid);\n        } else {\n          promises.push(CoreComments.addCommentOnline(comment.content, contextLevel, instanceId, component, itemId, area, siteId).then(() => {\n            countChange++;\n            return CoreCommentsOffline.removeComment(contextLevel, instanceId, component, itemId, area, siteId);\n          }));\n        }\n      });\n      if (deleteCommentIds.length > 0) {\n        promises.push(CoreComments.deleteCommentsOnline(deleteCommentIds, contextLevel, instanceId, component, itemId, area, siteId).then(() => {\n          countChange--;\n          return CoreCommentsOffline.removeDeletedComments(contextLevel, instanceId, component, itemId, area, siteId);\n        }));\n      }\n      // Send the comments.\n      try {\n        yield Promise.all(promises);\n        result.updated = true;\n        CoreEvents.trigger(CoreCommentsProvider.COMMENTS_COUNT_CHANGED_EVENT, {\n          contextLevel: contextLevel,\n          instanceId: instanceId,\n          component,\n          itemId: itemId,\n          area: area,\n          countChange: countChange\n        }, CoreSites.getCurrentSiteId());\n        // Fetch the comments from server to be sure they're up to date.\n        yield CoreUtils.ignoreErrors(CoreComments.invalidateCommentsData(contextLevel, instanceId, component, itemId, area, siteId));\n        yield CoreUtils.ignoreErrors(CoreComments.getComments(contextLevel, instanceId, component, itemId, area, 0, siteId));\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, this means the user cannot send comments.\n          errors.push(error.message);\n        } else {\n          // Not a WebService error, reject the synchronization to try again.\n          throw error;\n        }\n      }\n      if (errors && errors.length) {\n        errors.forEach(error => {\n          result.warnings.push(Translate.instant('core.comments.warningcommentsnotsent', {\n            error: error\n          }));\n        });\n      }\n      // All done, return the warnings.\n      return result;\n    })();\n  }\n  /**\n   * Get the ID of a comments sync.\n   *\n   * @param contextLevel Contextlevel system, course, user...\n   * @param instanceId The Instance id of item associated with the context level.\n   * @param component Component name.\n   * @param itemId Associated id.\n   * @param area String comment area. Default empty.\n   * @returns Sync ID.\n   */\n  getSyncId(contextLevel, instanceId, component, itemId, area = '') {\n    return contextLevel + '#' + instanceId + '#' + component + '#' + itemId + '#' + area;\n  }\n}\n_class = CoreCommentsSyncProvider;\n_class.AUTO_SYNCED = 'core_comments_autom_synced';\n_class.ɵfac = function CoreCommentsSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCommentsSync = makeSingleton(CoreCommentsSyncProvider);","map":{"version":3,"names":["CoreSyncBaseProvider","CoreComments","CoreCommentsProvider","CoreEvents","makeSingleton","Translate","CoreCommentsOffline","CoreSites","CoreNetwork","CoreUtils","CoreNetworkError","CoreCommentsSyncProvider","constructor","syncAllComments","siteId","force","syncOnSites","syncAllCommentsFunc","_this","_asyncToGenerator","comments","getAllComments","commentsUnique","forEach","comment","syncId","getSyncId","contextlevel","instanceid","component","itemid","area","promises","Object","keys","map","_ref","key","result","syncComments","syncCommentsIfNeeded","undefined","trigger","AUTO_SYNCED","contextLevel","instanceId","componentName","itemId","warnings","_x","apply","arguments","Promise","all","_this2","needed","isSyncNeeded","getCurrentSiteId","currentSyncPromise","getOngoingSync","logger","debug","syncPromise","performSyncComments","addOngoingSync","updated","getComments","length","isOnline","errors","deleteCommentIds","countChange","push","commentid","addCommentOnline","content","then","removeComment","deleteCommentsOnline","removeDeletedComments","COMMENTS_COUNT_CHANGED_EVENT","ignoreErrors","invalidateCommentsData","error","isWebServiceError","message","instant","_class","factory","ɵfac","providedIn","CoreCommentsSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/comments/services/comments-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSyncBaseProvider } from '@classes/base-sync';\nimport { CoreComments, CoreCommentsProvider } from './comments';\nimport { CoreEvents } from '@singletons/events';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreCommentsOffline } from './comments-offline';\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCommentsDBRecord, CoreCommentsDeletedDBRecord } from './database/comments';\nimport { CoreSyncResult } from '@services/sync';\n\n/**\n * Service to sync omments.\n */\n@Injectable( { providedIn: 'root' })\nexport class CoreCommentsSyncProvider extends CoreSyncBaseProvider<CoreCommentsSyncResult> {\n\n    static readonly AUTO_SYNCED = 'core_comments_autom_synced';\n\n    constructor() {\n        super('CoreCommentsSync');\n    }\n\n    /**\n     * Try to synchronize all the comments in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllComments(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all comments', (siteId) => this.syncAllCommentsFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Synchronize all the comments in a certain site\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    private async syncAllCommentsFunc(force: boolean, siteId: string): Promise<void> {\n        const comments = await CoreCommentsOffline.getAllComments(siteId);\n\n        const commentsUnique: { [syncId: string]: (CoreCommentsDBRecord | CoreCommentsDeletedDBRecord) } = {};\n        // Get Unique array.\n        comments.forEach((comment) => {\n            const syncId = this.getSyncId(\n                comment.contextlevel,\n                comment.instanceid,\n                comment.component,\n                comment.itemid,\n                comment.area,\n            );\n            commentsUnique[syncId] = comment;\n        });\n\n        // Sync all courses.\n        const promises = Object.keys(commentsUnique).map(async (key) => {\n            const comment = commentsUnique[key];\n\n            const result = await (force\n                ? this.syncComments(\n                    comment.contextlevel,\n                    comment.instanceid,\n                    comment.component,\n                    comment.itemid,\n                    comment.area,\n                    siteId,\n                )\n                : this.syncCommentsIfNeeded(\n                    comment.contextlevel,\n                    comment.instanceid,\n                    comment.component,\n                    comment.itemid,\n                    comment.area,\n                    siteId,\n                ));\n\n            if (result !== undefined) {\n                // Sync successful, send event.\n                CoreEvents.trigger(CoreCommentsSyncProvider.AUTO_SYNCED, {\n                    contextLevel: comment.contextlevel,\n                    instanceId: comment.instanceid,\n                    componentName: comment.component,\n                    itemId: comment.itemid,\n                    area: comment.area,\n                    warnings: result.warnings,\n                }, siteId);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Sync course comments only if a certain time has passed since the last time.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the comments are synced or if they don't need to be synced.\n     */\n    private async syncCommentsIfNeeded(\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        siteId?: string,\n    ): Promise<CoreCommentsSyncResult | undefined> {\n        const syncId = this.getSyncId(contextLevel, instanceId, component, itemId, area);\n\n        const needed = await this.isSyncNeeded(syncId, siteId);\n\n        if (needed) {\n            return this.syncComments(contextLevel, instanceId, component, itemId, area, siteId);\n        }\n    }\n\n    /**\n     * Synchronize comments in a particular area.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    syncComments(\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        siteId?: string,\n    ): Promise<CoreCommentsSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const syncId = this.getSyncId(contextLevel, instanceId, component, itemId, area);\n        const currentSyncPromise = this.getOngoingSync(syncId, siteId);\n\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for comments, return the promise.\n            return currentSyncPromise;\n        }\n\n        this.logger.debug('Try to sync comments ' + syncId + ' in site ' + siteId);\n\n        const syncPromise = this.performSyncComments(contextLevel, instanceId, component, itemId, area, siteId);\n\n        return this.addOngoingSync(syncId, syncPromise, siteId);\n    }\n\n    /**\n     * Performs the syncronization of comments in a particular area.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    private async performSyncComments(\n        contextLevel: string,\n        instanceId: number,\n        component: string,\n        itemId: number,\n        area: string = '',\n        siteId: string,\n    ): Promise<CoreCommentsSyncResult> {\n\n        const result: CoreCommentsSyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Get offline comments to be sent.\n        const comments = await CoreCommentsOffline.getComments(contextLevel, instanceId, component, itemId, area, siteId);\n        if (!comments.length) {\n            // Nothing to sync.\n            return result;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        const errors: string[] = [];\n        const promises: Promise<void>[] = [];\n        const deleteCommentIds: number[] = [];\n        let countChange = 0;\n\n        comments.forEach((comment) => {\n            if ('deleted' in comment) {\n                deleteCommentIds.push(comment.commentid);\n            } else {\n                promises.push(CoreComments.addCommentOnline(\n                    comment.content,\n                    contextLevel,\n                    instanceId,\n                    component,\n                    itemId,\n                    area,\n                    siteId,\n                ).then(() => {\n                    countChange++;\n\n                    return CoreCommentsOffline.removeComment(contextLevel, instanceId, component, itemId, area, siteId);\n                }));\n            }\n        });\n\n        if (deleteCommentIds.length > 0) {\n            promises.push(CoreComments.deleteCommentsOnline(\n                deleteCommentIds,\n                contextLevel,\n                instanceId,\n                component,\n                itemId,\n                area,\n                siteId,\n            ).then(() => {\n                countChange--;\n\n                return CoreCommentsOffline.removeDeletedComments(\n                    contextLevel,\n                    instanceId,\n                    component,\n                    itemId,\n                    area,\n                    siteId,\n                );\n            }));\n        }\n\n        // Send the comments.\n        try {\n            await Promise.all(promises);\n\n            result.updated = true;\n\n            CoreEvents.trigger(CoreCommentsProvider.COMMENTS_COUNT_CHANGED_EVENT, {\n                contextLevel: contextLevel,\n                instanceId: instanceId,\n                component,\n                itemId: itemId,\n                area: area,\n                countChange: countChange,\n            }, CoreSites.getCurrentSiteId());\n\n            // Fetch the comments from server to be sure they're up to date.\n            await CoreUtils.ignoreErrors(\n                CoreComments.invalidateCommentsData(contextLevel, instanceId, component, itemId, area, siteId),\n            );\n            await CoreUtils.ignoreErrors(\n                CoreComments.getComments(contextLevel, instanceId, component, itemId, area, 0, siteId),\n            );\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n            // It's a WebService error, this means the user cannot send comments.\n                errors.push(error.message);\n            } else {\n                // Not a WebService error, reject the synchronization to try again.\n                throw error;\n            }\n        }\n\n        if (errors && errors.length) {\n            errors.forEach((error) => {\n                result.warnings.push(Translate.instant('core.comments.warningcommentsnotsent', {\n                    error: error,\n                }));\n            });\n        }\n\n        // All done, return the warnings.\n        return result;\n    }\n\n    /**\n     * Get the ID of a comments sync.\n     *\n     * @param contextLevel Contextlevel system, course, user...\n     * @param instanceId The Instance id of item associated with the context level.\n     * @param component Component name.\n     * @param itemId Associated id.\n     * @param area String comment area. Default empty.\n     * @returns Sync ID.\n     */\n    protected getSyncId(contextLevel: string, instanceId: number, component: string, itemId: number, area: string = ''): string {\n        return contextLevel + '#' + instanceId + '#' + component + '#' + itemId + '#' + area;\n    }\n\n}\nexport const CoreCommentsSync = makeSingleton(CoreCommentsSyncProvider);\n\nexport type CoreCommentsSyncResult = CoreSyncResult;\n\n/**\n * Data passed to AUTO_SYNCED event.\n */\nexport type CoreCommentsSyncAutoSyncData = {\n    contextLevel: string;\n    instanceId: number;\n    componentName: string;\n    itemId: number;\n    area: string;\n    warnings: string[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}