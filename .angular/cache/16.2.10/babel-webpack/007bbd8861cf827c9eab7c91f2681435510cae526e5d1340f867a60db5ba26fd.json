{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Mock for SecureStorage plugin. It will store the data without being encrypted.\n */\nexport class SecureStorageMock {\n  /**\n   * Get one or more values.\n   *\n   * @param names Names of the values to get.\n   * @param collection The collection where the values are stored.\n   * @returns Object with name -> value. If a name isn't found it won't be included in the result.\n   */\n  get(names, collection) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (typeof names === 'string') {\n        names = [names];\n      }\n      const result = {};\n      for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        if (!name) {\n          continue;\n        }\n        const storedValue = localStorage.getItem(_this.getPrefixedName(name, collection));\n        if (storedValue !== null) {\n          result[name] = storedValue;\n        }\n      }\n      return result;\n    })();\n  }\n  /**\n   * Get the prefix to add to a name, including the collection.\n   *\n   * @param collection Collection name.\n   * @returns Prefix.\n   */\n  getCollectionPrefix(collection) {\n    return `SecureStorage_${collection}_`;\n  }\n  /**\n   * Get the full name to retrieve, store or delete an item.\n   *\n   * @param name Name inside collection.\n   * @param collection Collection name.\n   * @returns Full name.\n   */\n  getPrefixedName(name, collection) {\n    return this.getCollectionPrefix(collection) + name;\n  }\n  /**\n   * Set one or more values.\n   *\n   * @param data Object with values to store, in format name -> value. Null or undefined valid values will be ignored.\n   * @param collection The collection where to store the values.\n   */\n  store(data, collection) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      for (const name in data) {\n        const value = data[name];\n        if (value === undefined || value === null) {\n          delete data[name];\n        } else if (typeof value !== 'string') {\n          throw new Error(`SecureStorage: Invalid value for ${name}. Expected string, received ${typeof value}`);\n        }\n      }\n      for (const name in data) {\n        if (!name) {\n          continue;\n        }\n        const value = data[name];\n        localStorage.setItem(_this2.getPrefixedName(name, collection), value);\n      }\n    })();\n  }\n  /**\n   * Delete one or more values.\n   *\n   * @param names Names to delete.\n   * @param collection The collection where to delete the values.\n   */\n  delete(names, collection) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof names === 'string') {\n        names = [names];\n      }\n      for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        if (!name) {\n          continue;\n        }\n        localStorage.removeItem(_this3.getPrefixedName(name, collection));\n      }\n    })();\n  }\n  /**\n   * Delete all values for a certain collection.\n   *\n   * @param collection The collection to delete.\n   */\n  deleteCollection(collection) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const names = Object.keys(localStorage);\n      for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        if (name.startsWith(_this4.getCollectionPrefix(collection))) {\n          localStorage.removeItem(name);\n        }\n      }\n    })();\n  }\n}","map":{"version":3,"names":["SecureStorageMock","get","names","collection","_this","_asyncToGenerator","result","i","length","name","storedValue","localStorage","getItem","getPrefixedName","getCollectionPrefix","store","data","_this2","value","undefined","Error","setItem","delete","_this3","removeItem","deleteCollection","_this4","Object","keys","startsWith"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/emulator/classes/SecureStorage.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { SecureStorage } from 'cordova-plugin-moodleapp';\n\n/**\n * Mock for SecureStorage plugin. It will store the data without being encrypted.\n */\nexport class SecureStorageMock implements SecureStorage {\n\n    /**\n     * Get one or more values.\n     *\n     * @param names Names of the values to get.\n     * @param collection The collection where the values are stored.\n     * @returns Object with name -> value. If a name isn't found it won't be included in the result.\n     */\n    async get(names: string | string[], collection: string): Promise<Record<string, string>> {\n        if (typeof names === 'string') {\n            names = [names];\n        }\n\n        const result: Record<string, string> = {};\n\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            if (!name) {\n                continue;\n            }\n\n            const storedValue = localStorage.getItem(this.getPrefixedName(name, collection));\n            if (storedValue !== null) {\n                result[name] = storedValue;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the prefix to add to a name, including the collection.\n     *\n     * @param collection Collection name.\n     * @returns Prefix.\n     */\n    private getCollectionPrefix(collection: string): string {\n        return `SecureStorage_${collection}_`;\n    }\n\n    /**\n     * Get the full name to retrieve, store or delete an item.\n     *\n     * @param name Name inside collection.\n     * @param collection Collection name.\n     * @returns Full name.\n     */\n    private getPrefixedName(name: string, collection: string): string {\n        return this.getCollectionPrefix(collection) + name;\n    }\n\n    /**\n     * Set one or more values.\n     *\n     * @param data Object with values to store, in format name -> value. Null or undefined valid values will be ignored.\n     * @param collection The collection where to store the values.\n     */\n    async store(data: Record<string, string>, collection: string): Promise<void> {\n        for (const name in data) {\n            const value = data[name];\n            if (value === undefined || value === null) {\n                delete data[name];\n            } else if (typeof value !== 'string') {\n                throw new Error(`SecureStorage: Invalid value for ${name}. Expected string, received ${typeof value}`);\n            }\n        }\n\n        for (const name in data) {\n            if (!name) {\n                continue;\n            }\n\n            const value = data[name];\n            localStorage.setItem(this.getPrefixedName(name, collection), value);\n        }\n    }\n\n    /**\n     * Delete one or more values.\n     *\n     * @param names Names to delete.\n     * @param collection The collection where to delete the values.\n     */\n    async delete(names: string | string[], collection: string): Promise<void> {\n        if (typeof names === 'string') {\n            names = [names];\n        }\n\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            if (!name) {\n                continue;\n            }\n\n            localStorage.removeItem(this.getPrefixedName(name, collection));\n        }\n    }\n\n    /**\n     * Delete all values for a certain collection.\n     *\n     * @param collection The collection to delete.\n     */\n    async deleteCollection(collection: string): Promise<void> {\n        const names = Object.keys(localStorage);\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            if (name.startsWith(this.getCollectionPrefix(collection))) {\n                localStorage.removeItem(name);\n            }\n        }\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}