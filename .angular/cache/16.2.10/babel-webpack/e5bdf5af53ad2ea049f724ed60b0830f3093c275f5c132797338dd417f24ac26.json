{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreError } from '@classes/errors/error';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmGroups:';\n/*\n * Service to handle groups.\n*/\nexport class CoreGroupsProvider {\n  /**\n   * Check if group mode of an activity is enabled.\n   *\n   * @param cmId Course module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved with true if the activity has groups, resolved with false otherwise.\n   */\n  activityHasGroups(cmId, siteId, ignoreCache) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const groupmode = yield _this.getActivityGroupMode(cmId, siteId, ignoreCache);\n        return groupmode === CoreGroupsProvider.SEPARATEGROUPS || groupmode === CoreGroupsProvider.VISIBLEGROUPS;\n      } catch (error) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Get the groups allowed in an activity.\n   *\n   * @param cmId Course module ID.\n   * @param userId User ID. If not defined, use current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved when the groups are retrieved.\n   */\n  getActivityAllowedGroups(cmId, userId, siteId, ignoreCache) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const params = {\n        cmid: cmId,\n        userid: userId\n      };\n      const preSets = {\n        cacheKey: _this2.getActivityAllowedGroupsCacheKey(cmId, userId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const response = yield site.read('core_group_get_activity_allowed_groups', params, preSets);\n      if (!response || !response.groups) {\n        throw new CoreError('Activity allowed groups not found.');\n      }\n      return response;\n    })();\n  }\n  /**\n   * Get cache key for group mode WS calls.\n   *\n   * @param cmId Course module ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getActivityAllowedGroupsCacheKey(cmId, userId) {\n    return ROOT_CACHE_KEY + 'allowedgroups:' + cmId + ':' + userId;\n  }\n  /**\n   * Get the groups allowed in an activity if they are allowed.\n   *\n   * @param cmId Course module ID.\n   * @param userId User ID. If not defined, use current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved when the groups are retrieved. If not allowed, empty array will be returned.\n   */\n  getActivityAllowedGroupsIfEnabled(cmId, userId, siteId, ignoreCache) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Get real groupmode, in case it's forced by the course.\n      const hasGroups = yield _this3.activityHasGroups(cmId, siteId, ignoreCache);\n      if (hasGroups) {\n        // Get the groups available for the user.\n        return _this3.getActivityAllowedGroups(cmId, userId, siteId, ignoreCache);\n      }\n      return {\n        groups: []\n      };\n    })();\n  }\n  /**\n   * Helper function to get activity group info (group mode and list of groups).\n   *\n   * @param cmId Course module ID.\n   * @param addAllParts Deprecated.\n   * @param userId User ID. If not defined, use current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved with the group info.\n   */\n  getActivityGroupInfo(cmId, addAllParts, userId, siteId, ignoreCache) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const groupInfo = {\n        groups: [],\n        defaultGroupId: 0,\n        canAccessAllGroups: false\n      };\n      const groupMode = yield _this4.getActivityGroupMode(cmId, siteId, ignoreCache);\n      groupInfo.separateGroups = groupMode === CoreGroupsProvider.SEPARATEGROUPS;\n      groupInfo.visibleGroups = groupMode === CoreGroupsProvider.VISIBLEGROUPS;\n      let result;\n      if (groupInfo.separateGroups || groupInfo.visibleGroups) {\n        result = yield _this4.getActivityAllowedGroups(cmId, userId, siteId, ignoreCache);\n        groupInfo.canAccessAllGroups = !!result.canaccessallgroups;\n      } else {\n        result = {\n          groups: []\n        };\n      }\n      if (!result.groups.length) {\n        groupInfo.defaultGroupId = 0;\n      } else {\n        if (result.canaccessallgroups || groupInfo.visibleGroups) {\n          groupInfo.groups.push({\n            id: 0,\n            name: Translate.instant('core.allparticipants')\n          });\n          groupInfo.defaultGroupId = 0;\n        } else {\n          groupInfo.defaultGroupId = result.groups[0].id;\n        }\n        groupInfo.groups = groupInfo.groups.concat(result.groups);\n      }\n      return groupInfo;\n    })();\n  }\n  /**\n   * Get the group mode of an activity.\n   *\n   * @param cmId Course module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved when the group mode is retrieved.\n   */\n  getActivityGroupMode(cmId, siteId, ignoreCache) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        cmid: cmId\n      };\n      const preSets = {\n        cacheKey: _this5.getActivityGroupModeCacheKey(cmId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const response = yield site.read('core_group_get_activity_groupmode', params, preSets);\n      if (!response || response.groupmode === undefined) {\n        throw new CoreError('Activity group mode not found.');\n      }\n      return response.groupmode;\n    })();\n  }\n  /**\n   * Get cache key for group mode WS calls.\n   *\n   * @param cmId Course module ID.\n   * @returns Cache key.\n   */\n  getActivityGroupModeCacheKey(cmId) {\n    return ROOT_CACHE_KEY + 'groupmode:' + cmId;\n  }\n  /**\n   * Get user groups in all the user enrolled courses.\n   *\n   * @param siteId Site to get the groups from. If not defined, use current site.\n   * @returns Promise resolved when the groups are retrieved.\n   */\n  getAllUserGroups(siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      siteId = siteId || site.getId();\n      if (site.isVersionGreaterEqualThan('3.6')) {\n        return _this6.getUserGroupsInCourse(0, siteId);\n      }\n      const courses = yield CoreCourses.getUserCourses(false, siteId);\n      courses.push({\n        id: site.getSiteHomeId()\n      }); // Add site home.\n      return _this6.getUserGroups(courses, siteId);\n    })();\n  }\n  /**\n   * Get user groups in all the supplied courses.\n   *\n   * @param courses List of courses or course ids to get the groups from.\n   * @param siteId Site to get the groups from. If not defined, use current site.\n   * @param userId ID of the user. If not defined, use the userId related to siteId.\n   * @returns Promise resolved when the groups are retrieved.\n   */\n  getUserGroups(courses, siteId, userId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      // Get all courses one by one.\n      const promises = _this7.getCourseIds(courses).map(courseId => _this7.getUserGroupsInCourse(courseId, siteId, userId));\n      const courseGroups = yield Promise.all(promises);\n      return [].concat(...courseGroups);\n    })();\n  }\n  /**\n   * Get user groups in a course.\n   *\n   * @param courseId ID of the course. 0 to get all enrolled courses groups (Moodle version > 3.6).\n   * @param siteId Site to get the groups from. If not defined, use current site.\n   * @param userId ID of the user. If not defined, use ID related to siteid.\n   * @returns Promise resolved when the groups are retrieved.\n   */\n  getUserGroupsInCourse(courseId, siteId, userId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const data = {\n        userid: userId,\n        courseid: courseId\n      };\n      const preSets = {\n        cacheKey: _this8.getUserGroupsInCourseCacheKey(courseId, userId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      const response = yield site.read('core_group_get_course_user_groups', data, preSets);\n      if (!response || !response.groups) {\n        throw new CoreError('User groups in course not found.');\n      }\n      return response.groups;\n    })();\n  }\n  /**\n   * Get prefix cache key for user groups in course WS calls.\n   *\n   * @returns Prefix Cache key.\n   */\n  getUserGroupsInCoursePrefixCacheKey() {\n    return ROOT_CACHE_KEY + 'courseGroups:';\n  }\n  /**\n   * Get cache key for user groups in course WS calls.\n   *\n   * @param courseId Course ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getUserGroupsInCourseCacheKey(courseId, userId) {\n    return this.getUserGroupsInCoursePrefixCacheKey() + courseId + ':' + userId;\n  }\n  /**\n   * Invalidates activity allowed groups.\n   *\n   * @param cmId Course module ID.\n   * @param userId User ID. If not defined, use current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateActivityAllowedGroups(cmId, userId, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this9.getActivityAllowedGroupsCacheKey(cmId, userId));\n    })();\n  }\n  /**\n   * Invalidates activity group mode.\n   *\n   * @param cmId Course module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateActivityGroupMode(cmId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this10.getActivityGroupModeCacheKey(cmId));\n    })();\n  }\n  /**\n   * Invalidates all activity group info: mode and allowed groups.\n   *\n   * @param cmId Course module ID.\n   * @param userId User ID. If not defined, use current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateActivityGroupInfo(cmId, userId, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      promises.push(_this11.invalidateActivityAllowedGroups(cmId, userId, siteId));\n      promises.push(_this11.invalidateActivityGroupMode(cmId, siteId));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidates user groups in all user enrolled courses.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllUserGroups(siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      if (site.isVersionGreaterEqualThan('3.6')) {\n        return _this12.invalidateUserGroupsInCourse(0, siteId);\n      }\n      yield site.invalidateWsCacheForKeyStartingWith(_this12.getUserGroupsInCoursePrefixCacheKey());\n    })();\n  }\n  /**\n   * Invalidates user groups in courses.\n   *\n   * @param courses List of courses or course ids.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, use current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserGroups(courses, siteId, userId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const promises = _this13.getCourseIds(courses).map(courseId => _this13.invalidateUserGroupsInCourse(courseId, site.id, userId));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidates user groups in course.\n   *\n   * @param courseId ID of the course. 0 to get all enrolled courses groups (Moodle version > 3.6).\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, use current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateUserGroupsInCourse(courseId, siteId, userId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this14.getUserGroupsInCourseCacheKey(courseId, userId));\n    })();\n  }\n  /**\n   * Validate a group ID. If the group is not visible by the user, it will return the first group ID.\n   *\n   * @param groupId Group ID to validate.\n   * @param groupInfo Group info.\n   * @returns Group ID to use.\n   */\n  validateGroupId(groupId = 0, groupInfo) {\n    if (groupId > 0 && groupInfo && groupInfo.groups && groupInfo.groups.length > 0) {\n      // Check if the group is in the list of groups.\n      if (groupInfo.groups.some(group => groupId == group.id)) {\n        return groupId;\n      }\n    }\n    return groupInfo.defaultGroupId;\n  }\n  getCourseIds(courses) {\n    return courses.length > 0 && typeof courses[0] === 'object' ? courses.map(course => course.id) : courses;\n  }\n}\n_class = CoreGroupsProvider;\n// Group mode constants.\n_class.NOGROUPS = 0;\n_class.SEPARATEGROUPS = 1;\n_class.VISIBLEGROUPS = 2;\n_class.ɵfac = function CoreGroupsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreGroups = makeSingleton(CoreGroupsProvider);","map":{"version":3,"names":["CoreSites","CoreSite","CoreError","makeSingleton","Translate","CoreCourses","ROOT_CACHE_KEY","CoreGroupsProvider","activityHasGroups","cmId","siteId","ignoreCache","_this","_asyncToGenerator","groupmode","getActivityGroupMode","SEPARATEGROUPS","VISIBLEGROUPS","error","getActivityAllowedGroups","userId","_this2","site","getSite","getUserId","params","cmid","userid","preSets","cacheKey","getActivityAllowedGroupsCacheKey","updateFrequency","FREQUENCY_RARELY","getFromCache","emergencyCache","response","read","groups","getActivityAllowedGroupsIfEnabled","_this3","getCurrentSiteId","hasGroups","getActivityGroupInfo","addAllParts","_this4","groupInfo","defaultGroupId","canAccessAllGroups","groupMode","separateGroups","visibleGroups","result","canaccessallgroups","length","push","id","name","instant","concat","_this5","getActivityGroupModeCacheKey","undefined","getAllUserGroups","_this6","getId","isVersionGreaterEqualThan","getUserGroupsInCourse","courses","getUserCourses","getSiteHomeId","getUserGroups","_this7","promises","getCourseIds","map","courseId","courseGroups","Promise","all","_this8","data","courseid","getUserGroupsInCourseCacheKey","getUserGroupsInCoursePrefixCacheKey","invalidateActivityAllowedGroups","_this9","invalidateWsCacheForKey","invalidateActivityGroupMode","_this10","invalidateActivityGroupInfo","_this11","invalidateAllUserGroups","_this12","invalidateUserGroupsInCourse","invalidateWsCacheForKeyStartingWith","invalidateUserGroups","_this13","_this14","validateGroupId","groupId","some","group","course","_class","NOGROUPS","factory","ɵfac","providedIn","CoreGroups"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/groups.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreError } from '@classes/errors/error';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmGroups:';\n\n/*\n * Service to handle groups.\n*/\n@Injectable({ providedIn: 'root' })\nexport class CoreGroupsProvider {\n\n    // Group mode constants.\n    static readonly NOGROUPS = 0;\n    static readonly SEPARATEGROUPS = 1;\n    static readonly VISIBLEGROUPS = 2;\n\n    /**\n     * Check if group mode of an activity is enabled.\n     *\n     * @param cmId Course module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved with true if the activity has groups, resolved with false otherwise.\n     */\n    async activityHasGroups(cmId: number, siteId?: string, ignoreCache?: boolean): Promise<boolean> {\n        try {\n            const groupmode = await this.getActivityGroupMode(cmId, siteId, ignoreCache);\n\n            return groupmode === CoreGroupsProvider.SEPARATEGROUPS || groupmode === CoreGroupsProvider.VISIBLEGROUPS;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Get the groups allowed in an activity.\n     *\n     * @param cmId Course module ID.\n     * @param userId User ID. If not defined, use current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved when the groups are retrieved.\n     */\n    async getActivityAllowedGroups(\n        cmId: number,\n        userId?: number,\n        siteId?: string,\n        ignoreCache?: boolean,\n    ): Promise<CoreGroupGetActivityAllowedGroupsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n\n        const params: CoreGroupGetActivityAllowedGroupsWSParams = {\n            cmid: cmId,\n            userid: userId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getActivityAllowedGroupsCacheKey(cmId, userId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n\n        if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        const response: CoreGroupGetActivityAllowedGroupsWSResponse =\n            await site.read('core_group_get_activity_allowed_groups', params, preSets);\n\n        if (!response || !response.groups) {\n            throw new CoreError('Activity allowed groups not found.');\n        }\n\n        return response;\n    }\n\n    /**\n     * Get cache key for group mode WS calls.\n     *\n     * @param cmId Course module ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getActivityAllowedGroupsCacheKey(cmId: number, userId: number): string {\n        return ROOT_CACHE_KEY + 'allowedgroups:' + cmId + ':' + userId;\n    }\n\n    /**\n     * Get the groups allowed in an activity if they are allowed.\n     *\n     * @param cmId Course module ID.\n     * @param userId User ID. If not defined, use current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved when the groups are retrieved. If not allowed, empty array will be returned.\n     */\n    async getActivityAllowedGroupsIfEnabled(cmId: number, userId?: number, siteId?: string, ignoreCache?: boolean):\n    Promise<CoreGroupGetActivityAllowedGroupsWSResponse> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Get real groupmode, in case it's forced by the course.\n        const hasGroups = await this.activityHasGroups(cmId, siteId, ignoreCache);\n        if (hasGroups) {\n            // Get the groups available for the user.\n            return this.getActivityAllowedGroups(cmId, userId, siteId, ignoreCache);\n        }\n\n        return {\n            groups: [],\n        };\n    }\n\n    /**\n     * Helper function to get activity group info (group mode and list of groups).\n     *\n     * @param cmId Course module ID.\n     * @param addAllParts Deprecated.\n     * @param userId User ID. If not defined, use current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved with the group info.\n     */\n    async getActivityGroupInfo(\n        cmId: number,\n        addAllParts?: boolean,\n        userId?: number,\n        siteId?: string,\n        ignoreCache?: boolean,\n    ): Promise<CoreGroupInfo> {\n        const groupInfo: CoreGroupInfo = {\n            groups: [],\n            defaultGroupId: 0,\n            canAccessAllGroups: false,\n        };\n\n        const groupMode = await this.getActivityGroupMode(cmId, siteId, ignoreCache);\n\n        groupInfo.separateGroups = groupMode === CoreGroupsProvider.SEPARATEGROUPS;\n        groupInfo.visibleGroups = groupMode === CoreGroupsProvider.VISIBLEGROUPS;\n\n        let result: CoreGroupGetActivityAllowedGroupsWSResponse;\n        if (groupInfo.separateGroups || groupInfo.visibleGroups) {\n            result = await this.getActivityAllowedGroups(cmId, userId, siteId, ignoreCache);\n\n            groupInfo.canAccessAllGroups = !!result.canaccessallgroups;\n        } else {\n            result = {\n                groups: [],\n            };\n        }\n\n        if (!result.groups.length) {\n            groupInfo.defaultGroupId = 0;\n        } else {\n            if (result.canaccessallgroups || groupInfo.visibleGroups) {\n                groupInfo.groups.push({ id: 0, name: Translate.instant('core.allparticipants') });\n                groupInfo.defaultGroupId = 0;\n            } else {\n                groupInfo.defaultGroupId = result.groups[0].id;\n            }\n\n            groupInfo.groups = groupInfo.groups.concat(result.groups);\n        }\n\n        return groupInfo;\n    }\n\n    /**\n     * Get the group mode of an activity.\n     *\n     * @param cmId Course module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved when the group mode is retrieved.\n     */\n    async getActivityGroupMode(cmId: number, siteId?: string, ignoreCache?: boolean): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n        const params: CoreGroupGetActivityGroupmodeWSParams = {\n            cmid: cmId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getActivityGroupModeCacheKey(cmId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n\n        if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        const response: CoreGroupGetActivityGroupModeWSResponse =\n            await site.read('core_group_get_activity_groupmode', params, preSets);\n\n        if (!response || response.groupmode === undefined) {\n            throw new CoreError('Activity group mode not found.');\n        }\n\n        return response.groupmode;\n    }\n\n    /**\n     * Get cache key for group mode WS calls.\n     *\n     * @param cmId Course module ID.\n     * @returns Cache key.\n     */\n    protected getActivityGroupModeCacheKey(cmId: number): string {\n        return ROOT_CACHE_KEY + 'groupmode:' + cmId;\n    }\n\n    /**\n     * Get user groups in all the user enrolled courses.\n     *\n     * @param siteId Site to get the groups from. If not defined, use current site.\n     * @returns Promise resolved when the groups are retrieved.\n     */\n    async getAllUserGroups(siteId?: string): Promise<CoreGroup[]> {\n        const site = await CoreSites.getSite(siteId);\n        siteId = siteId || site.getId();\n\n        if (site.isVersionGreaterEqualThan('3.6')) {\n            return this.getUserGroupsInCourse(0, siteId);\n        }\n\n        const courses = <CoreCourseBase[]> await CoreCourses.getUserCourses(false, siteId);\n\n        courses.push({ id: site.getSiteHomeId() }); // Add site home.\n\n        return this.getUserGroups(courses, siteId);\n    }\n\n    /**\n     * Get user groups in all the supplied courses.\n     *\n     * @param courses List of courses or course ids to get the groups from.\n     * @param siteId Site to get the groups from. If not defined, use current site.\n     * @param userId ID of the user. If not defined, use the userId related to siteId.\n     * @returns Promise resolved when the groups are retrieved.\n     */\n    async getUserGroups(courses: CoreCourseBase[] | number[], siteId?: string, userId?: number): Promise<CoreGroup[]> {\n        // Get all courses one by one.\n        const promises = this.getCourseIds(courses).map((courseId) => this.getUserGroupsInCourse(courseId, siteId, userId));\n\n        const courseGroups = await Promise.all(promises);\n\n        return (<CoreGroup[]>[]).concat(...courseGroups);\n    }\n\n    /**\n     * Get user groups in a course.\n     *\n     * @param courseId ID of the course. 0 to get all enrolled courses groups (Moodle version > 3.6).\n     * @param siteId Site to get the groups from. If not defined, use current site.\n     * @param userId ID of the user. If not defined, use ID related to siteid.\n     * @returns Promise resolved when the groups are retrieved.\n     */\n    async getUserGroupsInCourse(courseId: number, siteId?: string, userId?: number): Promise<CoreGroup[]> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n        const data: CoreGroupGetCourseUserGroupsWSParams = {\n            userid: userId,\n            courseid: courseId,\n        };\n        const preSets = {\n            cacheKey: this.getUserGroupsInCourseCacheKey(courseId, userId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n\n        const response: CoreGroupGetCourseUserGroupsWSResponse =\n            await site.read('core_group_get_course_user_groups', data, preSets);\n\n        if (!response || !response.groups) {\n            throw new CoreError('User groups in course not found.');\n        }\n\n        return response.groups;\n    }\n\n    /**\n     * Get prefix cache key for user groups in course WS calls.\n     *\n     * @returns Prefix Cache key.\n     */\n    protected getUserGroupsInCoursePrefixCacheKey(): string {\n        return ROOT_CACHE_KEY + 'courseGroups:';\n    }\n\n    /**\n     * Get cache key for user groups in course WS calls.\n     *\n     * @param courseId Course ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getUserGroupsInCourseCacheKey(courseId: number, userId: number): string {\n        return this.getUserGroupsInCoursePrefixCacheKey() + courseId + ':' + userId;\n    }\n\n    /**\n     * Invalidates activity allowed groups.\n     *\n     * @param cmId Course module ID.\n     * @param userId User ID. If not defined, use current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateActivityAllowedGroups(cmId: number, userId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getActivityAllowedGroupsCacheKey(cmId, userId));\n    }\n\n    /**\n     * Invalidates activity group mode.\n     *\n     * @param cmId Course module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateActivityGroupMode(cmId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getActivityGroupModeCacheKey(cmId));\n    }\n\n    /**\n     * Invalidates all activity group info: mode and allowed groups.\n     *\n     * @param cmId Course module ID.\n     * @param userId User ID. If not defined, use current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateActivityGroupInfo(cmId: number, userId?: number, siteId?: string): Promise<void> {\n        const promises = <Promise<void>[]>[];\n        promises.push(this.invalidateActivityAllowedGroups(cmId, userId, siteId));\n        promises.push(this.invalidateActivityGroupMode(cmId, siteId));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidates user groups in all user enrolled courses.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllUserGroups(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        if (site.isVersionGreaterEqualThan('3.6')) {\n            return this.invalidateUserGroupsInCourse(0, siteId);\n        }\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getUserGroupsInCoursePrefixCacheKey());\n    }\n\n    /**\n     * Invalidates user groups in courses.\n     *\n     * @param courses List of courses or course ids.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, use current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserGroups(courses: CoreCourseBase[] | number[], siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const promises = this.getCourseIds(courses).map((courseId) => this.invalidateUserGroupsInCourse(courseId, site.id, userId));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidates user groups in course.\n     *\n     * @param courseId ID of the course. 0 to get all enrolled courses groups (Moodle version > 3.6).\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, use current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateUserGroupsInCourse(courseId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getUserGroupsInCourseCacheKey(courseId, userId));\n    }\n\n    /**\n     * Validate a group ID. If the group is not visible by the user, it will return the first group ID.\n     *\n     * @param groupId Group ID to validate.\n     * @param groupInfo Group info.\n     * @returns Group ID to use.\n     */\n    validateGroupId(groupId = 0, groupInfo: CoreGroupInfo): number {\n        if (groupId > 0 && groupInfo && groupInfo.groups && groupInfo.groups.length > 0) {\n            // Check if the group is in the list of groups.\n            if (groupInfo.groups.some((group) => groupId == group.id)) {\n                return groupId;\n            }\n        }\n\n        return groupInfo.defaultGroupId;\n    }\n\n    protected getCourseIds(courses: CoreCourseBase[] | number[]): number[] {\n        return courses.length > 0 && typeof courses[0] === 'object'\n            ? (courses as CoreCourseBase[]).map((course) => course.id)\n            : courses as number[];\n    }\n\n}\n\nexport const CoreGroups = makeSingleton(CoreGroupsProvider);\n\n/**\n * Specific group info.\n */\nexport type CoreGroup = {\n    id: number; // Group ID.\n    name: string; // Multilang compatible name, course unique'.\n    description?: string; // Group description text.\n    descriptionformat?: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    idnumber?: string; // Id number.\n    courseid?: number; // Coure Id.\n};\n\n/**\n * Group info for an activity.\n */\nexport type CoreGroupInfo = {\n    /**\n     * List of groups.\n     */\n    groups: CoreGroup[];\n\n    /**\n     * Whether it's separate groups.\n     */\n    separateGroups?: boolean;\n\n    /**\n     * Whether it's visible groups.\n     */\n    visibleGroups?: boolean;\n\n    /**\n     * The group ID to use by default. If all participants is visible, 0 will be used. First group ID otherwise.\n     */\n    defaultGroupId: number;\n\n    /**\n     * Whether the user has the capability to access all groups in the context.\n     */\n    canAccessAllGroups: boolean;\n};\n\n/**\n * WS core_group_get_activity_allowed_groups response type.\n */\nexport type CoreGroupGetActivityAllowedGroupsWSResponse = {\n    groups: CoreGroup[]; // List of groups.\n    canaccessallgroups?: boolean; // Whether the user will be able to access all the activity groups.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_group_get_activity_groupmode WS.\n */\ntype CoreGroupGetActivityGroupmodeWSParams = {\n    cmid: number; // Course module id.\n};\n\n/**\n * Result of WS core_group_get_activity_groupmode.\n */\nexport type CoreGroupGetActivityGroupModeWSResponse = {\n    groupmode: number; // Group mode: 0 for no groups, 1 for separate groups, 2 for visible groups.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_group_get_activity_allowed_groups WS.\n */\ntype CoreGroupGetActivityAllowedGroupsWSParams = {\n    cmid: number; // Course module id.\n    userid?: number; // Id of user, empty for current user.\n};\n\n/**\n * Params of core_group_get_course_user_groups WS.\n */\ntype CoreGroupGetCourseUserGroupsWSParams = {\n    courseid?: number; // Id of course (empty or 0 for all the courses where the user is enrolled).\n    userid?: number; // Id of user (empty or 0 for current user).\n    groupingid?: number; // Returns only groups in the specified grouping.\n};\n\n/**\n * Result of WS core_group_get_course_user_groups.\n */\nexport type CoreGroupGetCourseUserGroupsWSResponse = {\n    groups: {\n        id: number; // Group record id.\n        name: string; // Multilang compatible name, course unique.\n        description: string; // Group description text.\n        descriptionformat: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n        idnumber: string; // Id number.\n        courseid?: number; // Course id.\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}