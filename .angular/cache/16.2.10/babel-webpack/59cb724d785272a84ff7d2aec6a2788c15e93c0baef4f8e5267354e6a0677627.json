{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModLabel:';\n/**\n * Service that provides some features for labels.\n */\nexport class AddonModLabelProvider {\n  /**\n   * Get cache key for label data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getLabelDataCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'label:' + courseId;\n  }\n  /**\n   * Get a label with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the label is retrieved.\n   */\n  getLabelByField(courseId, key, value, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this.getLabelDataCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModLabelProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_label_get_labels_by_courses', params, preSets);\n      const currentLabel = response.labels.find(label => label[key] == value);\n      if (currentLabel) {\n        return currentLabel;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get a label by course module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the label is retrieved.\n   */\n  getLabel(courseId, cmId, options = {}) {\n    return this.getLabelByField(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a label by ID.\n   *\n   * @param courseId Course ID.\n   * @param labelId Label ID.\n   * @param options Other options.\n   * @returns Promise resolved when the label is retrieved.\n   */\n  getLabelById(courseId, labelId, options = {}) {\n    return this.getLabelByField(courseId, 'id', labelId, options);\n  }\n  /**\n   * Invalidate label data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateLabelData(courseId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this2.getLabelDataCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const promises = [];\n      promises.push(_this3.invalidateLabelData(courseId, siteId));\n      promises.push(CoreFilepool.invalidateFilesByComponent(siteId, AddonModLabelProvider.COMPONENT, moduleId, true));\n      yield CoreUtils.allPromises(promises);\n    })();\n  }\n}\n_class = AddonModLabelProvider;\n_class.COMPONENT = 'mmaModLabel';\n_class.ɵfac = function AddonModLabelProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModLabel = makeSingleton(AddonModLabelProvider);","map":{"version":3,"names":["CoreError","CoreSite","CoreFilepool","CoreSites","CoreUtils","makeSingleton","Translate","ROOT_CACHE_KEY","AddonModLabelProvider","getLabelDataCacheKey","courseId","getLabelByField","key","value","options","_this","_asyncToGenerator","site","getSite","siteId","params","courseids","preSets","_objectSpread","cacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","response","read","currentLabel","labels","find","label","instant","getLabel","cmId","getLabelById","labelId","invalidateLabelData","_this2","invalidateWsCacheForKey","invalidateContent","moduleId","_this3","getCurrentSiteId","promises","push","invalidateFilesByComponent","allPromises","_class","factory","ɵfac","providedIn","AddonModLabel"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/label/services/label.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesCommonWSOptions } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\n\nconst ROOT_CACHE_KEY = 'mmaModLabel:';\n\n/**\n * Service that provides some features for labels.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModLabelProvider {\n\n    static readonly COMPONENT = 'mmaModLabel';\n\n    /**\n     * Get cache key for label data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getLabelDataCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'label:' + courseId;\n    }\n\n    /**\n     * Get a label with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the label is retrieved.\n     */\n    protected async getLabelByField(\n        courseId: number,\n        key: string,\n        value: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModLabelLabel> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModLabelGetLabelsByCoursesWSParams = {\n            courseids: [courseId],\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getLabelDataCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModLabelProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        const response =\n            await site.read<AddonModLabelGetLabelsByCoursesWSResponse>('mod_label_get_labels_by_courses', params, preSets);\n\n        const currentLabel = response.labels.find((label) => label[key] == value);\n        if (currentLabel) {\n            return currentLabel;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get a label by course module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the label is retrieved.\n     */\n    getLabel(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModLabelLabel> {\n        return this.getLabelByField(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a label by ID.\n     *\n     * @param courseId Course ID.\n     * @param labelId Label ID.\n     * @param options Other options.\n     * @returns Promise resolved when the label is retrieved.\n     */\n    getLabelById(courseId: number, labelId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModLabelLabel> {\n        return this.getLabelByField(courseId, 'id', labelId, options);\n    }\n\n    /**\n     * Invalidate label data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateLabelData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getLabelDataCacheKey(courseId));\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const promises: Promise<void>[] = [];\n\n        promises.push(this.invalidateLabelData(courseId, siteId));\n        promises.push(CoreFilepool.invalidateFilesByComponent(siteId, AddonModLabelProvider.COMPONENT, moduleId, true));\n\n        await CoreUtils.allPromises(promises);\n    }\n\n}\nexport const AddonModLabel = makeSingleton(AddonModLabelProvider);\n\n/**\n * Label returned by mod_label_get_labels_by_courses.\n */\nexport type AddonModLabelLabel = {\n    id: number; // Module id.\n    coursemodule: number; // Course module id.\n    course: number; // Course id.\n    name: string; // Label name.\n    intro: string; // Label contents.\n    introformat?: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles: CoreWSExternalFile[];\n    timemodified: number; // Last time the label was modified.\n    section: number; // Course section id.\n    visible: number; // Module visibility.\n    groupmode: number; // Group mode.\n    groupingid: number; // Grouping id.\n};\n\n/**\n * Params of mod_label_get_labels_by_courses WS.\n */\ntype AddonModLabelGetLabelsByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_label_get_labels_by_courses WS.\n */\ntype AddonModLabelGetLabelsByCoursesWSResponse = {\n    labels: AddonModLabelLabel[];\n    warnings?: CoreWSExternalWarning[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}