{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { TestingBehatDomUtils } from './behat-dom';\nimport { TestingBehatBlocking } from './behat-blocking';\nimport { CoreCustomURLSchemes } from '@services/urlschemes';\nimport { ONBOARDING_DONE } from '@features/login/constants';\nimport { CoreConfig } from '@services/config';\nimport { LocalNotifications, makeSingleton, NgZone } from '@singletons';\nimport { CoreNetwork } from '@services/network';\nimport { CorePushNotifications } from '@features/pushnotifications/services/pushnotifications';\nimport { CoreCronDelegate } from '@services/cron';\nimport { CoreLoadingComponent } from '@components/loading/loading';\nimport { CoreDirectivesRegistry } from '@singletons/directives-registry';\nimport { CoreDom } from '@singletons/dom';\nimport { CoreSites } from '@services/sites';\nimport { CoreNavigator } from '@services/navigator';\nimport * as i0 from \"@angular/core\";\n/**\n * Behat runtime servive with public API.\n */\nexport class TestingBehatRuntimeService {\n  constructor() {\n    this.initialized = false;\n  }\n  get cronDelegate() {\n    return CoreCronDelegate.instance;\n  }\n  get customUrlSchemes() {\n    return CoreCustomURLSchemes.instance;\n  }\n  get network() {\n    return CoreNetwork.instance;\n  }\n  get pushNotifications() {\n    return CorePushNotifications.instance;\n  }\n  get sites() {\n    return CoreSites.instance;\n  }\n  get navigator() {\n    return CoreNavigator.instance;\n  }\n  /**\n   * Init behat functions and set options like skipping onboarding.\n   *\n   * @param options Options to set on the app.\n   */\n  init(options = {}) {\n    if (this.initialized) {\n      return;\n    }\n    this.initialized = true;\n    TestingBehatBlocking.init();\n    if (options.skipOnBoarding) {\n      CoreConfig.set(ONBOARDING_DONE, 1);\n    }\n    if (options.configOverrides) {\n      // Set the cookie so it's maintained between reloads.\n      document.cookie = 'MoodleAppConfig=' + JSON.stringify(options.configOverrides);\n      CoreConfig.patchEnvironment(options.configOverrides, {\n        patchDefault: true\n      });\n    }\n  }\n  /**\n   * Check whether the service has been initialized or not.\n   *\n   * @returns Whether the service has been initialized or not.\n   */\n  hasInitialized() {\n    return this.initialized;\n  }\n  /**\n   * Run an operation inside the angular zone and return result.\n   *\n   * @param operation Operation callback.\n   * @returns OK if successful, or ERROR: followed by message.\n   */\n  runInZone(operation, blocking = false) {\n    return _asyncToGenerator(function* () {\n      const blockKey = blocking && TestingBehatBlocking.block();\n      try {\n        yield NgZone.run(operation);\n        return 'OK';\n      } catch (error) {\n        return 'ERROR: ' + error.message;\n      } finally {\n        blockKey && TestingBehatBlocking.unblock(blockKey);\n      }\n    })();\n  }\n  /**\n   * Wait all controlled components to be rendered.\n   *\n   * @returns Promise resolved when all components have been rendered.\n   */\n  waitLoadingToFinish() {\n    return _asyncToGenerator(function* () {\n      yield NgZone.run( /*#__PURE__*/_asyncToGenerator(function* () {\n        const elements = Array.from(document.body.querySelectorAll('core-loading')).filter(element => CoreDom.isElementVisible(element));\n        yield Promise.all(elements.map(element => CoreDirectivesRegistry.waitDirectiveReady(element, CoreLoadingComponent)));\n      }));\n    })();\n  }\n  /**\n   * Function to find and click an app standard button.\n   *\n   * @param button Type of button to press.\n   * @returns OK if successful, or ERROR: followed by message.\n   */\n  pressStandard(button) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.log('Action - Click standard button: ' + button);\n      // Find button\n      let foundButton;\n      const options = {\n        onlyClickable: true,\n        containerName: ''\n      };\n      switch (button) {\n        case 'back':\n          foundButton = TestingBehatDomUtils.findElementBasedOnText({\n            text: 'Back'\n          }, options);\n          break;\n        case 'main menu': // Deprecated name.\n        case 'more menu':\n          foundButton = TestingBehatDomUtils.findElementBasedOnText({\n            text: 'More',\n            selector: 'ion-tab-button'\n          }, options);\n          break;\n        case 'user menu':\n          foundButton = TestingBehatDomUtils.findElementBasedOnText({\n            text: 'User account'\n          }, options);\n          break;\n        case 'page menu':\n          foundButton = TestingBehatDomUtils.findElementBasedOnText({\n            text: 'Display options'\n          }, options);\n          break;\n        default:\n          return 'ERROR: Unsupported standard button type';\n      }\n      if (!foundButton) {\n        return `ERROR: Button '${button}' not found`;\n      }\n      // Click button\n      yield TestingBehatDomUtils.pressElement(foundButton);\n      return 'OK';\n    })();\n  }\n  /**\n   * When there is a popup, clicks on the backdrop.\n   *\n   * @returns OK if successful, or ERROR: followed by message\n   */\n  closePopup() {\n    this.log('Action - Close popup');\n    let backdrops = Array.from(document.querySelectorAll('ion-backdrop'));\n    backdrops = backdrops.filter(backdrop => !!backdrop.offsetParent);\n    if (!backdrops.length) {\n      return 'ERROR: Could not find backdrop';\n    }\n    if (backdrops.length > 1) {\n      return 'ERROR: Found too many backdrops (' + backdrops.length + ')';\n    }\n    const backdrop = backdrops[0];\n    backdrop.click();\n    // Mark busy until the click finishes processing.\n    TestingBehatBlocking.delay();\n    return 'OK';\n  }\n  /**\n   * Function to find an arbitrary element based on its text or aria label.\n   *\n   * @param locator Element locator.\n   * @param options Search options.\n   * @returns OK if successful, or ERROR: followed by message\n   */\n  find(locator, options = {}) {\n    this.log('Action - Find', _objectSpread({\n      locator\n    }, options));\n    try {\n      const element = TestingBehatDomUtils.findElementBasedOnText(locator, _objectSpread({\n        onlyClickable: false,\n        containerName: ''\n      }, options));\n      if (!element) {\n        return 'ERROR: No element matches locator to find.';\n      }\n      this.log('Action - Found', _objectSpread({\n        locator,\n        element\n      }, options));\n      return 'OK';\n    } catch (error) {\n      return 'ERROR: ' + error.message;\n    }\n  }\n  /**\n   * Scroll an element into view.\n   *\n   * @param locator Element locator.\n   * @returns OK if successful, or ERROR: followed by message\n   */\n  scrollTo(locator) {\n    this.log('Action - scrollTo', {\n      locator\n    });\n    try {\n      var _ref2, _element$closest;\n      let element = TestingBehatDomUtils.findElementBasedOnText(locator, {\n        onlyClickable: false,\n        containerName: ''\n      });\n      if (!element) {\n        return 'ERROR: No element matches element to scroll to.';\n      }\n      element = (_ref2 = (_element$closest = element.closest('ion-item')) !== null && _element$closest !== void 0 ? _element$closest : element.closest('button')) !== null && _ref2 !== void 0 ? _ref2 : element;\n      element.scrollIntoView();\n      this.log('Action - Scrolled to', {\n        locator,\n        element\n      });\n      return 'OK';\n    } catch (error) {\n      return 'ERROR: ' + error.message;\n    }\n  }\n  /**\n   * Load more items form an active list with infinite loader.\n   *\n   * @returns OK if successful, or ERROR: followed by message\n   */\n  loadMoreItems() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.log('Action - loadMoreItems');\n      try {\n        var _infiniteLoading$quer;\n        const infiniteLoading = Array.from(document.querySelectorAll('core-infinite-loading')).find(element => !element.closest('.ion-page-hidden'));\n        if (!infiniteLoading) {\n          return 'ERROR: There isn\\'t an infinite loader in the current page.';\n        }\n        const initialOffset = infiniteLoading.offsetTop;\n        const isLoading = () => !!infiniteLoading.querySelector('ion-spinner[aria-label]');\n        const isCompleted = () => !isLoading() && !infiniteLoading.querySelector('ion-button');\n        const hasMoved = () => infiniteLoading.offsetTop !== initialOffset;\n        if (isCompleted()) {\n          return 'ERROR: All items are already loaded.';\n        }\n        infiniteLoading.scrollIntoView({\n          behavior: 'smooth'\n        });\n        // Wait 100ms\n        yield new Promise(resolve => setTimeout(resolve, 100));\n        if (isLoading() || isCompleted() || hasMoved()) {\n          return 'OK';\n        }\n        (_infiniteLoading$quer = infiniteLoading.querySelector('ion-button')) === null || _infiniteLoading$quer === void 0 || _infiniteLoading$quer.click();\n        // Wait 100ms\n        yield new Promise(resolve => setTimeout(resolve, 100));\n        return isLoading() || isCompleted() || hasMoved() ? 'OK' : 'ERROR: Couldn\\'t load more items.';\n      } catch (error) {\n        return 'ERROR: ' + error.message;\n      }\n    })();\n  }\n  /**\n   * Check whether an item is selected or not.\n   *\n   * @param locator Element locator.\n   * @returns YES or NO if successful, or ERROR: followed by message\n   */\n  isSelected(locator) {\n    this.log('Action - Is Selected', locator);\n    try {\n      const element = TestingBehatDomUtils.findElementBasedOnText(locator, {\n        onlyClickable: false,\n        containerName: ''\n      });\n      if (!element) {\n        return 'ERROR: No element matches locator to find.';\n      }\n      return TestingBehatDomUtils.isElementSelected(element, document.body) ? 'YES' : 'NO';\n    } catch (error) {\n      return 'ERROR: ' + error.message;\n    }\n  }\n  press(locatorOrText, nearText) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const locator = typeof locatorOrText === 'string' ? {\n        text: locatorOrText\n      } : locatorOrText;\n      if (nearText) {\n        locator.near = {\n          text: nearText\n        };\n      }\n      _this3.log('Action - Press', locator);\n      try {\n        const found = TestingBehatDomUtils.findElementBasedOnText(locator, {\n          onlyClickable: true,\n          containerName: ''\n        });\n        if (!found) {\n          return 'ERROR: No element matches locator to press.';\n        }\n        yield TestingBehatDomUtils.pressElement(found);\n        return 'OK';\n      } catch (error) {\n        return 'ERROR: ' + error.message;\n      }\n    })();\n  }\n  /**\n   * Get a file input id, adding it if necessary.\n   *\n   * @param locator Input locator.\n   * @returns Input id if successful, or ERROR: followed by message\n   */\n  getFileInputId(locator) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.log('Action - Upload File', {\n        locator\n      });\n      try {\n        var _input$getAttribute;\n        const inputOrContainer = TestingBehatDomUtils.findElementBasedOnText(locator);\n        if (!inputOrContainer) {\n          return 'ERROR: No element matches input locator.';\n        }\n        const input = inputOrContainer.matches('input[type=\"file\"]') ? inputOrContainer : inputOrContainer.querySelector('input[type=\"file\"]');\n        if (!input) {\n          return 'ERROR: Input element does not contain a file input.';\n        }\n        if (!input.hasAttribute('id')) {\n          input.setAttribute('id', `file-${Date.now()}`);\n        }\n        return (_input$getAttribute = input.getAttribute('id')) !== null && _input$getAttribute !== void 0 ? _input$getAttribute : '';\n      } catch (error) {\n        return 'ERROR: ' + error.message;\n      }\n    })();\n  }\n  /**\n   * Trigger a pull to refresh gesture in the current page.\n   *\n   * @returns OK if successful, or ERROR: followed by message\n   */\n  pullToRefresh() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      _this5.log('Action - pullToRefresh');\n      try {\n        // 'el' is protected, but there's no other way to trigger refresh programatically.\n        const ionRefresher = _this5.getAngularInstance('ion-refresher', 'IonRefresher');\n        if (!ionRefresher) {\n          return 'ERROR: It\\'s not possible to pull to refresh the current page.';\n        }\n        ionRefresher.el.dispatchEvent(new CustomEvent('ionRefresh'));\n        return 'OK';\n      } catch (error) {\n        return 'ERROR: ' + error.message;\n      }\n    })();\n  }\n  /**\n   * Gets the currently displayed page header.\n   *\n   * @returns OK: followed by header text if successful, or ERROR: followed by message.\n   */\n  getHeader() {\n    this.log('Action - Get header');\n    let titles = Array.from(document.querySelectorAll('.ion-page:not(.ion-page-hidden) > ion-header h1'));\n    titles = titles.filter(title => TestingBehatDomUtils.isElementVisible(title, document.body));\n    if (titles.length > 1) {\n      return 'ERROR: Too many possible titles (' + titles.length + ').';\n    } else if (!titles.length) {\n      return 'ERROR: No title found.';\n    } else {\n      const title = titles[0].innerText.trim();\n      return 'OK:' + title;\n    }\n  }\n  /**\n   * Sets the text of a field to the specified value.\n   *\n   * This currently matches fields only based on the placeholder attribute.\n   *\n   * @param field Field name\n   * @param value New value\n   * @returns OK or ERROR: followed by message\n   */\n  setField(field, value) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      _this6.log('Action - Set field ' + field + ' to: ' + value);\n      const input = TestingBehatDomUtils.findField(field);\n      if (!input) {\n        return 'ERROR: No element matches field to set.';\n      }\n      if (input instanceof HTMLSelectElement) {\n        var _ref3, _ref4, _options$find$value, _options$find, _options$find2, _options$find3;\n        const options = Array.from(input.querySelectorAll('option'));\n        value = (_ref3 = (_ref4 = (_options$find$value = (_options$find = options.find(option => option.value === value)) === null || _options$find === void 0 ? void 0 : _options$find.value) !== null && _options$find$value !== void 0 ? _options$find$value : (_options$find2 = options.find(option => option.text === value)) === null || _options$find2 === void 0 ? void 0 : _options$find2.value) !== null && _ref4 !== void 0 ? _ref4 : (_options$find3 = options.find(option => option.text.includes(value))) === null || _options$find3 === void 0 ? void 0 : _options$find3.value) !== null && _ref3 !== void 0 ? _ref3 : value;\n      }\n      yield TestingBehatDomUtils.setElementValue(input, value);\n      return 'OK';\n    })();\n  }\n  /**\n   * Sets the text of a field to the specified value.\n   *\n   * This currently matches fields only based on the placeholder attribute.\n   *\n   * @param field Field name\n   * @param value New value\n   * @returns OK or ERROR: followed by message\n   */\n  fieldMatches(field, value) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      _this7.log('Action - Field ' + field + ' matches value: ' + value);\n      const found = TestingBehatDomUtils.findField(field);\n      if (!found) {\n        return 'ERROR: No element matches field to set.';\n      }\n      const foundValue = _this7.getFieldValue(found);\n      if (value !== foundValue) {\n        return `ERROR: Expecting value \"${value}\", found \"${foundValue}\" instead.`;\n      }\n      return 'OK';\n    })();\n  }\n  /**\n   * Get the value of a certain field.\n   *\n   * @param element Field to get the value.\n   * @returns Value.\n   */\n  getFieldValue(element) {\n    if (element.tagName === 'ION-DATETIME') {\n      var _element$shadowRoot;\n      // ion-datetime's value is a timestamp in ISO format. Use the text displayed to the user instead.\n      const dateTimeTextElement = (_element$shadowRoot = element.shadowRoot) === null || _element$shadowRoot === void 0 ? void 0 : _element$shadowRoot.querySelector('.datetime-text');\n      if (dateTimeTextElement) {\n        return dateTimeTextElement.innerText;\n      }\n    }\n    return 'value' in element ? element.value : element.innerText;\n  }\n  /**\n   * Get an Angular component instance.\n   *\n   * @param selector Element selector\n   * @param className Constructor class name\n   * @param referenceLocator The locator to the reference element to start looking for. If not specified, document body.\n   * @returns Component instance\n   */\n  getAngularInstance(selector, className, referenceLocator) {\n    var _Array$from$pop;\n    this.log('Action - Get Angular instance ' + selector + ', ' + className, referenceLocator);\n    let startingElement = document.body;\n    let queryPrefix = '';\n    if (referenceLocator) {\n      startingElement = TestingBehatDomUtils.findElementBasedOnText(referenceLocator, {\n        onlyClickable: false,\n        containerName: ''\n      });\n      if (!startingElement) {\n        return null;\n      }\n    } else {\n      // Searching the whole DOM, search only in visible pages.\n      queryPrefix = '.ion-page:not(.ion-page-hidden) ';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const activeElement = (_Array$from$pop = Array.from(startingElement.querySelectorAll(`${queryPrefix}${selector}`)).pop()) !== null && _Array$from$pop !== void 0 ? _Array$from$pop : startingElement.closest(selector);\n    if (!activeElement || !activeElement.__ngContext__) {\n      return null;\n    }\n    return activeElement.__ngContext__.find(node => {\n      var _node$constructor;\n      return (node === null || node === void 0 || (_node$constructor = node.constructor) === null || _node$constructor === void 0 ? void 0 : _node$constructor.name) === className;\n    });\n  }\n  /**\n   * Logs information from this Behat runtime JavaScript, including the time and the 'BEHAT'\n   * keyword so we can easily filter for it if needed.\n   */\n  log(...args) {\n    const now = new Date();\n    const nowFormatted = String(now.getHours()).padStart(2, '0') + ':' + String(now.getMinutes()).padStart(2, '0') + ':' + String(now.getSeconds()).padStart(2, '0') + '.' + String(now.getMilliseconds()).padStart(2, '0');\n    console.log('BEHAT: ' + nowFormatted, ...args); // eslint-disable-line no-console\n  }\n  /**\n   * Check a notification is present.\n   *\n   * @param title Title of the notification\n   * @returns YES or NO: depending on the result.\n   */\n  notificationIsPresentWithText(title) {\n    return _asyncToGenerator(function* () {\n      const notifications = yield LocalNotifications.getAllTriggered();\n      const notification = notifications.find(notification => {\n        var _notification$title;\n        return (_notification$title = notification.title) === null || _notification$title === void 0 ? void 0 : _notification$title.includes(title);\n      });\n      if (!notification) {\n        return 'NO';\n      }\n      if (!notification.id) {\n        // Cannot check but has been triggered.\n        return 'YES';\n      }\n      return (yield LocalNotifications.isPresent(notification.id)) ? 'YES' : 'NO';\n    })();\n  }\n  /**\n   * Close notification.\n   *\n   * @param title Title of the notification\n   * @returns OK or ERROR\n   */\n  closeNotification(title) {\n    return _asyncToGenerator(function* () {\n      const notifications = yield LocalNotifications.getAllTriggered();\n      const notification = notifications.find(notification => {\n        var _notification$title2;\n        return (_notification$title2 = notification.title) === null || _notification$title2 === void 0 ? void 0 : _notification$title2.includes(title);\n      });\n      if (!notification || !notification.id) {\n        return `ERROR: Notification with title ${title} cannot be closed`;\n      }\n      yield LocalNotifications.clear(notification.id);\n      return 'OK';\n    })();\n  }\n  /**\n   * Swipe in the app.\n   *\n   * @param direction Left or right.\n   * @param locator Element locator to swipe. If not specified, swipe in the first ion-content found.\n   * @returns OK if successful, or ERROR: followed by message\n   */\n  swipe(direction, locator) {\n    this.log('Action - Swipe', {\n      direction,\n      locator\n    });\n    if (locator) {\n      // Locator specified, try to find swiper-container first.\n      const instance = this.getAngularInstance('swiper-container', 'Swiper', locator);\n      if (instance) {\n        direction === 'left' ? instance.slideNext() : instance.slidePrev();\n        return 'OK';\n      }\n    }\n    // No locator specified or swiper-container not found, search swipe navigation now.\n    const instance = this.getAngularInstance('ion-content', 'CoreSwipeNavigationDirective', locator);\n    if (!instance) {\n      return 'ERROR: Element to swipe not found.';\n    }\n    direction === 'left' ? instance.swipeLeft() : instance.swipeRight();\n    return 'OK';\n  }\n}\n_class = TestingBehatRuntimeService;\n_class.ɵfac = function TestingBehatRuntimeService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const TestingBehatRuntime = makeSingleton(TestingBehatRuntimeService);","map":{"version":3,"names":["TestingBehatDomUtils","TestingBehatBlocking","CoreCustomURLSchemes","ONBOARDING_DONE","CoreConfig","LocalNotifications","makeSingleton","NgZone","CoreNetwork","CorePushNotifications","CoreCronDelegate","CoreLoadingComponent","CoreDirectivesRegistry","CoreDom","CoreSites","CoreNavigator","TestingBehatRuntimeService","constructor","initialized","cronDelegate","instance","customUrlSchemes","network","pushNotifications","sites","navigator","init","options","skipOnBoarding","set","configOverrides","document","cookie","JSON","stringify","patchEnvironment","patchDefault","hasInitialized","runInZone","operation","blocking","_asyncToGenerator","blockKey","block","run","error","message","unblock","waitLoadingToFinish","elements","Array","from","body","querySelectorAll","filter","element","isElementVisible","Promise","all","map","waitDirectiveReady","pressStandard","button","_this","log","foundButton","onlyClickable","containerName","findElementBasedOnText","text","selector","pressElement","closePopup","backdrops","backdrop","offsetParent","length","click","delay","find","locator","_objectSpread","scrollTo","_ref2","_element$closest","closest","scrollIntoView","loadMoreItems","_this2","_infiniteLoading$quer","infiniteLoading","initialOffset","offsetTop","isLoading","querySelector","isCompleted","hasMoved","behavior","resolve","setTimeout","isSelected","isElementSelected","press","locatorOrText","nearText","_this3","near","found","getFileInputId","_this4","_input$getAttribute","inputOrContainer","input","matches","hasAttribute","setAttribute","Date","now","getAttribute","pullToRefresh","_this5","ionRefresher","getAngularInstance","el","dispatchEvent","CustomEvent","getHeader","titles","title","innerText","trim","setField","field","value","_this6","findField","HTMLSelectElement","_ref3","_ref4","_options$find$value","_options$find","_options$find2","_options$find3","option","includes","setElementValue","fieldMatches","_this7","foundValue","getFieldValue","tagName","_element$shadowRoot","dateTimeTextElement","shadowRoot","className","referenceLocator","_Array$from$pop","startingElement","queryPrefix","activeElement","pop","__ngContext__","node","_node$constructor","name","args","nowFormatted","String","getHours","padStart","getMinutes","getSeconds","getMilliseconds","console","notificationIsPresentWithText","notifications","getAllTriggered","notification","_notification$title","id","isPresent","closeNotification","_notification$title2","clear","swipe","direction","slideNext","slidePrev","swipeLeft","swipeRight","factory","ɵfac","providedIn","TestingBehatRuntime"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/testing/services/behat-runtime.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { TestingBehatDomUtils } from './behat-dom';\nimport { TestingBehatBlocking } from './behat-blocking';\nimport { CoreCustomURLSchemes, CoreCustomURLSchemesProvider } from '@services/urlschemes';\nimport { ONBOARDING_DONE } from '@features/login/constants';\nimport { CoreConfig } from '@services/config';\nimport { EnvironmentConfig } from '@/types/config';\nimport { LocalNotifications, makeSingleton, NgZone } from '@singletons';\nimport { CoreNetwork, CoreNetworkService } from '@services/network';\nimport { CorePushNotifications, CorePushNotificationsProvider } from '@features/pushnotifications/services/pushnotifications';\nimport { CoreCronDelegate, CoreCronDelegateService } from '@services/cron';\nimport { CoreLoadingComponent } from '@components/loading/loading';\nimport { CoreDirectivesRegistry } from '@singletons/directives-registry';\nimport { CoreDom } from '@singletons/dom';\nimport { Injectable } from '@angular/core';\nimport { CoreSites, CoreSitesProvider } from '@services/sites';\nimport { CoreNavigator, CoreNavigatorService } from '@services/navigator';\nimport { CoreSwipeNavigationDirective } from '@directives/swipe-navigation';\nimport { Swiper } from 'swiper';\n\n/**\n * Behat runtime servive with public API.\n */\n@Injectable({ providedIn: 'root' })\nexport class TestingBehatRuntimeService {\n\n    protected initialized = false;\n\n    get cronDelegate(): CoreCronDelegateService {\n        return CoreCronDelegate.instance;\n    }\n\n    get customUrlSchemes(): CoreCustomURLSchemesProvider {\n        return CoreCustomURLSchemes.instance;\n    }\n\n    get network(): CoreNetworkService {\n        return CoreNetwork.instance;\n    }\n\n    get pushNotifications(): CorePushNotificationsProvider {\n        return CorePushNotifications.instance;\n    }\n\n    get sites(): CoreSitesProvider {\n        return CoreSites.instance;\n    }\n\n    get navigator(): CoreNavigatorService {\n        return CoreNavigator.instance;\n    }\n\n    /**\n     * Init behat functions and set options like skipping onboarding.\n     *\n     * @param options Options to set on the app.\n     */\n    init(options: TestingBehatInitOptions = {}): void {\n        if (this.initialized) {\n            return;\n        }\n\n        this.initialized = true;\n        TestingBehatBlocking.init();\n\n        if (options.skipOnBoarding) {\n            CoreConfig.set(ONBOARDING_DONE, 1);\n        }\n\n        if (options.configOverrides) {\n            // Set the cookie so it's maintained between reloads.\n            document.cookie = 'MoodleAppConfig=' + JSON.stringify(options.configOverrides);\n            CoreConfig.patchEnvironment(options.configOverrides, { patchDefault: true });\n        }\n    }\n\n    /**\n     * Check whether the service has been initialized or not.\n     *\n     * @returns Whether the service has been initialized or not.\n     */\n    hasInitialized(): boolean {\n        return this.initialized;\n    }\n\n    /**\n     * Run an operation inside the angular zone and return result.\n     *\n     * @param operation Operation callback.\n     * @returns OK if successful, or ERROR: followed by message.\n     */\n    async runInZone(operation: () => unknown, blocking: boolean = false): Promise<string> {\n        const blockKey = blocking && TestingBehatBlocking.block();\n\n        try {\n            await NgZone.run(operation);\n\n            return 'OK';\n        } catch (error) {\n            return 'ERROR: ' + error.message;\n        } finally {\n            blockKey && TestingBehatBlocking.unblock(blockKey);\n        }\n    }\n\n    /**\n     * Wait all controlled components to be rendered.\n     *\n     * @returns Promise resolved when all components have been rendered.\n     */\n    async waitLoadingToFinish(): Promise<void> {\n        await NgZone.run(async () => {\n            const elements = Array.from(document.body.querySelectorAll<HTMLElement>('core-loading'))\n                .filter((element) => CoreDom.isElementVisible(element));\n\n            await Promise.all(elements.map(element =>\n                CoreDirectivesRegistry.waitDirectiveReady(element, CoreLoadingComponent)));\n        });\n    }\n\n    /**\n     * Function to find and click an app standard button.\n     *\n     * @param button Type of button to press.\n     * @returns OK if successful, or ERROR: followed by message.\n     */\n    async pressStandard(button: string): Promise<string> {\n        this.log('Action - Click standard button: ' + button);\n\n        // Find button\n        let foundButton: HTMLElement | undefined;\n        const options: TestingBehatFindOptions = {\n            onlyClickable: true,\n            containerName: '',\n        };\n\n        switch (button) {\n            case 'back':\n                foundButton = TestingBehatDomUtils.findElementBasedOnText({ text: 'Back' }, options);\n                break;\n            case 'main menu': // Deprecated name.\n            case 'more menu':\n                foundButton = TestingBehatDomUtils.findElementBasedOnText({\n                    text: 'More',\n                    selector: 'ion-tab-button',\n                }, options);\n                break;\n            case 'user menu' :\n                foundButton = TestingBehatDomUtils.findElementBasedOnText({ text: 'User account' }, options);\n                break;\n            case 'page menu':\n                foundButton = TestingBehatDomUtils.findElementBasedOnText({ text: 'Display options' }, options);\n                break;\n            default:\n                return 'ERROR: Unsupported standard button type';\n        }\n\n        if (!foundButton) {\n            return `ERROR: Button '${button}' not found`;\n        }\n\n        // Click button\n        await TestingBehatDomUtils.pressElement(foundButton);\n\n        return 'OK';\n    }\n\n    /**\n     * When there is a popup, clicks on the backdrop.\n     *\n     * @returns OK if successful, or ERROR: followed by message\n     */\n    closePopup(): string {\n        this.log('Action - Close popup');\n\n        let backdrops = Array.from(document.querySelectorAll('ion-backdrop'));\n        backdrops = backdrops.filter((backdrop) => !!backdrop.offsetParent);\n\n        if (!backdrops.length) {\n            return 'ERROR: Could not find backdrop';\n        }\n        if (backdrops.length > 1) {\n            return 'ERROR: Found too many backdrops ('+backdrops.length+')';\n        }\n        const backdrop = backdrops[0];\n        backdrop.click();\n\n        // Mark busy until the click finishes processing.\n        TestingBehatBlocking.delay();\n\n        return 'OK';\n    }\n\n    /**\n     * Function to find an arbitrary element based on its text or aria label.\n     *\n     * @param locator Element locator.\n     * @param options Search options.\n     * @returns OK if successful, or ERROR: followed by message\n     */\n    find(locator: TestingBehatElementLocator, options: Partial<TestingBehatFindOptions> = {}): string {\n        this.log('Action - Find', { locator, ...options });\n\n        try {\n            const element = TestingBehatDomUtils.findElementBasedOnText(locator, {\n                onlyClickable: false,\n                containerName: '',\n                ...options,\n            });\n\n            if (!element) {\n                return 'ERROR: No element matches locator to find.';\n            }\n\n            this.log('Action - Found', { locator, element, ...options });\n\n            return 'OK';\n        } catch (error) {\n            return 'ERROR: ' + error.message;\n        }\n    }\n\n    /**\n     * Scroll an element into view.\n     *\n     * @param locator Element locator.\n     * @returns OK if successful, or ERROR: followed by message\n     */\n    scrollTo(locator: TestingBehatElementLocator): string {\n        this.log('Action - scrollTo', { locator });\n\n        try {\n            let element = TestingBehatDomUtils.findElementBasedOnText(locator, { onlyClickable: false, containerName: '' });\n\n            if (!element) {\n                return 'ERROR: No element matches element to scroll to.';\n            }\n\n            element = element.closest('ion-item') ?? element.closest('button') ?? element;\n\n            element.scrollIntoView();\n\n            this.log('Action - Scrolled to', { locator, element });\n\n            return 'OK';\n        } catch (error) {\n            return 'ERROR: ' + error.message;\n        }\n    }\n\n    /**\n     * Load more items form an active list with infinite loader.\n     *\n     * @returns OK if successful, or ERROR: followed by message\n     */\n    async loadMoreItems(): Promise<string> {\n        this.log('Action - loadMoreItems');\n\n        try {\n            const infiniteLoading = Array\n                .from(document.querySelectorAll<HTMLElement>('core-infinite-loading'))\n                .find(element => !element.closest('.ion-page-hidden'));\n\n            if (!infiniteLoading) {\n                return 'ERROR: There isn\\'t an infinite loader in the current page.';\n            }\n\n            const initialOffset = infiniteLoading.offsetTop;\n            const isLoading = () => !!infiniteLoading.querySelector('ion-spinner[aria-label]');\n            const isCompleted = () => !isLoading() && !infiniteLoading.querySelector('ion-button');\n            const hasMoved = () => infiniteLoading.offsetTop !== initialOffset;\n\n            if (isCompleted()) {\n                return 'ERROR: All items are already loaded.';\n            }\n\n            infiniteLoading.scrollIntoView({ behavior: 'smooth' });\n\n            // Wait 100ms\n            await new Promise(resolve => setTimeout(resolve, 100));\n\n            if (isLoading() || isCompleted() || hasMoved()) {\n                return 'OK';\n            }\n\n            infiniteLoading.querySelector<HTMLElement>('ion-button')?.click();\n\n            // Wait 100ms\n            await new Promise(resolve => setTimeout(resolve, 100));\n\n            return (isLoading() || isCompleted() || hasMoved()) ? 'OK' : 'ERROR: Couldn\\'t load more items.';\n        } catch (error) {\n            return 'ERROR: ' + error.message;\n        }\n    }\n\n    /**\n     * Check whether an item is selected or not.\n     *\n     * @param locator Element locator.\n     * @returns YES or NO if successful, or ERROR: followed by message\n     */\n    isSelected(locator: TestingBehatElementLocator): string {\n        this.log('Action - Is Selected', locator);\n\n        try {\n            const element = TestingBehatDomUtils.findElementBasedOnText(locator, { onlyClickable: false, containerName: '' });\n\n            if (!element) {\n                return 'ERROR: No element matches locator to find.';\n            }\n\n            return TestingBehatDomUtils.isElementSelected(element, document.body) ? 'YES' : 'NO';\n        } catch (error) {\n            return 'ERROR: ' + error.message;\n        }\n    }\n\n    /**\n     * Function to press arbitrary item based on its text or Aria label.\n     *\n     * @param locator Element locator.\n     * @returns OK if successful, or ERROR: followed by message\n     */\n    async press(locator: TestingBehatElementLocator): Promise<string>;\n    async press(text: string, nearText?: string): Promise<string>;\n    async press(locatorOrText: TestingBehatElementLocator | string, nearText?: string): Promise<string> {\n        const locator = typeof locatorOrText === 'string' ? { text: locatorOrText } : locatorOrText;\n\n        if (nearText) {\n            locator.near = { text: nearText };\n        }\n\n        this.log('Action - Press', locator);\n\n        try {\n            const found = TestingBehatDomUtils.findElementBasedOnText(locator, { onlyClickable: true, containerName: '' });\n\n            if (!found) {\n                return 'ERROR: No element matches locator to press.';\n            }\n\n            await TestingBehatDomUtils.pressElement(found);\n\n            return 'OK';\n        } catch (error) {\n            return 'ERROR: ' + error.message;\n        }\n    }\n\n    /**\n     * Get a file input id, adding it if necessary.\n     *\n     * @param locator Input locator.\n     * @returns Input id if successful, or ERROR: followed by message\n     */\n    async getFileInputId(locator: TestingBehatElementLocator): Promise<string> {\n        this.log('Action - Upload File', { locator });\n\n        try {\n            const inputOrContainer = TestingBehatDomUtils.findElementBasedOnText(locator);\n\n            if (!inputOrContainer) {\n                return 'ERROR: No element matches input locator.';\n            }\n\n            const input = inputOrContainer.matches('input[type=\"file\"]')\n                ? inputOrContainer\n                : inputOrContainer.querySelector('input[type=\"file\"]');\n\n            if (!input) {\n                return 'ERROR: Input element does not contain a file input.';\n            }\n\n            if (!input.hasAttribute('id')) {\n                input.setAttribute('id', `file-${Date.now()}`);\n            }\n\n            return input.getAttribute('id') ?? '';\n        } catch (error) {\n            return 'ERROR: ' + error.message;\n        }\n    }\n\n    /**\n     * Trigger a pull to refresh gesture in the current page.\n     *\n     * @returns OK if successful, or ERROR: followed by message\n     */\n    async pullToRefresh(): Promise<string> {\n        this.log('Action - pullToRefresh');\n\n        try {\n            // 'el' is protected, but there's no other way to trigger refresh programatically.\n            const ionRefresher = this.getAngularInstance<{ el: HTMLIonRefresherElement }>(\n                'ion-refresher',\n                'IonRefresher',\n            );\n\n            if (!ionRefresher) {\n                return 'ERROR: It\\'s not possible to pull to refresh the current page.';\n            }\n\n            ionRefresher.el.dispatchEvent(new CustomEvent('ionRefresh'));\n\n            return 'OK';\n        } catch (error) {\n            return 'ERROR: ' + error.message;\n        }\n    }\n\n    /**\n     * Gets the currently displayed page header.\n     *\n     * @returns OK: followed by header text if successful, or ERROR: followed by message.\n     */\n    getHeader(): string {\n        this.log('Action - Get header');\n\n        let titles = Array.from(document.querySelectorAll<HTMLElement>('.ion-page:not(.ion-page-hidden) > ion-header h1'));\n        titles = titles.filter((title) => TestingBehatDomUtils.isElementVisible(title, document.body));\n\n        if (titles.length > 1) {\n            return 'ERROR: Too many possible titles ('+titles.length+').';\n        } else if (!titles.length) {\n            return 'ERROR: No title found.';\n        } else {\n            const title = titles[0].innerText.trim();\n\n            return 'OK:' + title;\n        }\n    }\n\n    /**\n     * Sets the text of a field to the specified value.\n     *\n     * This currently matches fields only based on the placeholder attribute.\n     *\n     * @param field Field name\n     * @param value New value\n     * @returns OK or ERROR: followed by message\n     */\n    async setField(field: string, value: string): Promise<string> {\n        this.log('Action - Set field ' + field + ' to: ' + value);\n\n        const input = TestingBehatDomUtils.findField(field);\n\n        if (!input) {\n            return 'ERROR: No element matches field to set.';\n        }\n\n        if (input instanceof HTMLSelectElement) {\n            const options = Array.from(input.querySelectorAll('option'));\n\n            value = options.find(option => option.value === value)?.value\n                ?? options.find(option => option.text === value)?.value\n                ?? options.find(option => option.text.includes(value))?.value\n                ?? value;\n        }\n\n        await TestingBehatDomUtils.setElementValue(input, value);\n\n        return 'OK';\n    }\n\n    /**\n     * Sets the text of a field to the specified value.\n     *\n     * This currently matches fields only based on the placeholder attribute.\n     *\n     * @param field Field name\n     * @param value New value\n     * @returns OK or ERROR: followed by message\n     */\n    async fieldMatches(field: string, value: string): Promise<string> {\n        this.log('Action - Field ' + field + ' matches value: ' + value);\n\n        const found = TestingBehatDomUtils.findField(field);\n\n        if (!found) {\n            return 'ERROR: No element matches field to set.';\n        }\n\n        const foundValue = this.getFieldValue(found);\n        if (value !== foundValue) {\n            return `ERROR: Expecting value \"${value}\", found \"${foundValue}\" instead.`;\n        }\n\n        return 'OK';\n    }\n\n    /**\n     * Get the value of a certain field.\n     *\n     * @param element Field to get the value.\n     * @returns Value.\n     */\n    protected getFieldValue(element: HTMLElement | HTMLInputElement): string {\n        if (element.tagName === 'ION-DATETIME') {\n            // ion-datetime's value is a timestamp in ISO format. Use the text displayed to the user instead.\n            const dateTimeTextElement = element.shadowRoot?.querySelector<HTMLElement>('.datetime-text');\n            if (dateTimeTextElement) {\n                return dateTimeTextElement.innerText;\n            }\n        }\n\n        return 'value' in element ? element.value : element.innerText;\n    }\n\n    /**\n     * Get an Angular component instance.\n     *\n     * @param selector Element selector\n     * @param className Constructor class name\n     * @param referenceLocator The locator to the reference element to start looking for. If not specified, document body.\n     * @returns Component instance\n     */\n    getAngularInstance<T = unknown>(\n        selector: string,\n        className: string,\n        referenceLocator?: TestingBehatElementLocator,\n    ): T | null {\n        this.log('Action - Get Angular instance ' + selector + ', ' + className, referenceLocator);\n\n        let startingElement: HTMLElement | undefined = document.body;\n        let queryPrefix = '';\n\n        if (referenceLocator) {\n            startingElement = TestingBehatDomUtils.findElementBasedOnText(referenceLocator, {\n                onlyClickable: false,\n                containerName: '',\n            });\n\n            if (!startingElement) {\n                return null;\n            }\n        } else {\n            // Searching the whole DOM, search only in visible pages.\n            queryPrefix = '.ion-page:not(.ion-page-hidden) ';\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const activeElement = Array.from(startingElement.querySelectorAll<any>(`${queryPrefix}${selector}`)).pop() ??\n            startingElement.closest(selector);\n\n        if (!activeElement || !activeElement.__ngContext__) {\n            return null;\n        }\n\n        return activeElement.__ngContext__.find(node => node?.constructor?.name === className);\n    }\n\n    /**\n     * Logs information from this Behat runtime JavaScript, including the time and the 'BEHAT'\n     * keyword so we can easily filter for it if needed.\n     */\n    log(...args: unknown[]): void {\n        const now = new Date();\n        const nowFormatted = String(now.getHours()).padStart(2, '0') + ':' +\n                String(now.getMinutes()).padStart(2, '0') + ':' +\n                String(now.getSeconds()).padStart(2, '0') + '.' +\n                String(now.getMilliseconds()).padStart(2, '0');\n\n        console.log('BEHAT: ' + nowFormatted, ...args); // eslint-disable-line no-console\n    }\n\n    /**\n     * Check a notification is present.\n     *\n     * @param title Title of the notification\n     * @returns YES or NO: depending on the result.\n     */\n    async notificationIsPresentWithText(title: string): Promise<string> {\n        const notifications = await LocalNotifications.getAllTriggered();\n\n        const notification = notifications.find((notification) => notification.title?.includes(title));\n\n        if (!notification) {\n            return 'NO';\n        }\n\n        if (!notification.id) {\n            // Cannot check but has been triggered.\n            return 'YES';\n        }\n\n        return (await LocalNotifications.isPresent(notification.id)) ? 'YES' : 'NO';\n    }\n\n    /**\n     * Close notification.\n     *\n     * @param title Title of the notification\n     * @returns OK or ERROR\n     */\n    async closeNotification(title: string): Promise<string> {\n        const notifications = await LocalNotifications.getAllTriggered();\n\n        const notification = notifications.find((notification) => notification.title?.includes(title));\n\n        if (!notification || !notification.id) {\n            return `ERROR: Notification with title ${title} cannot be closed`;\n        }\n\n        await LocalNotifications.clear(notification.id);\n\n        return 'OK';\n    }\n\n    /**\n     * Swipe in the app.\n     *\n     * @param direction Left or right.\n     * @param locator Element locator to swipe. If not specified, swipe in the first ion-content found.\n     * @returns OK if successful, or ERROR: followed by message\n     */\n    swipe(direction: string, locator?: TestingBehatElementLocator): string {\n        this.log('Action - Swipe', { direction, locator });\n\n        if (locator) {\n            // Locator specified, try to find swiper-container first.\n            const instance = this.getAngularInstance<Swiper>('swiper-container', 'Swiper', locator);\n            if (instance) {\n                direction === 'left' ? instance.slideNext() : instance.slidePrev();\n\n                return 'OK';\n            }\n        }\n\n        // No locator specified or swiper-container not found, search swipe navigation now.\n        const instance = this.getAngularInstance<CoreSwipeNavigationDirective>(\n            'ion-content',\n            'CoreSwipeNavigationDirective',\n            locator,\n        );\n\n        if (!instance) {\n            return 'ERROR: Element to swipe not found.';\n        }\n\n        direction === 'left' ? instance.swipeLeft() : instance.swipeRight();\n\n        return 'OK';\n    }\n\n}\n\nexport const TestingBehatRuntime = makeSingleton(TestingBehatRuntimeService);\n\nexport type BehatTestsWindow = Window & {\n    M?: { // eslint-disable-line @typescript-eslint/naming-convention\n        util?: {\n            pending_js?: string[]; // eslint-disable-line @typescript-eslint/naming-convention\n        };\n    };\n};\n\nexport type TestingBehatFindOptions = {\n    containerName?: string;\n    onlyClickable?: boolean;\n};\n\nexport type TestingBehatElementLocator = {\n    text: string;\n    within?: TestingBehatElementLocator;\n    near?: TestingBehatElementLocator;\n    selector?: string;\n};\n\nexport type TestingBehatInitOptions = {\n    skipOnBoarding?: boolean;\n    configOverrides?: Partial<EnvironmentConfig>;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}