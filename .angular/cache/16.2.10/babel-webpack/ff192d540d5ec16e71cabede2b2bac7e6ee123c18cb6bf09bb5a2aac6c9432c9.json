{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreH5P } from '../h5p';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreH5PHelper } from '../../classes/helper';\nimport { CoreFileHelper } from '@services/file-helper';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to treat H5P files.\n */\nexport class CoreH5PPluginFileHandlerService {\n  constructor() {\n    this.name = 'CoreH5PPluginFileHandler';\n  }\n  /**\n   * React to a file being deleted.\n   *\n   * @param fileUrl The file URL used to download the file.\n   * @param path The path of the deleted file.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  fileDeleted(fileUrl, path, siteId) {\n    return _asyncToGenerator(function* () {\n      // If an h5p file is deleted, remove the contents folder.\n      yield CoreH5P.h5pPlayer.deleteContentByUrl(fileUrl, siteId);\n    })();\n  }\n  /**\n   * Check whether a file can be downloaded. If so, return the file to download.\n   *\n   * @param file The file data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the file to use. Rejected if cannot download.\n   */\n  getDownloadableFile(file, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const fileUrl = CoreFileHelper.getFileUrl(file);\n      if (site.containsUrl(fileUrl) && fileUrl.match(/pluginfile\\.php\\/[^/]+\\/core_h5p\\/export\\//i)) {\n        // It's already a deployed file, use it.\n        return file;\n      }\n      return CoreH5P.getTrustedH5PFile(fileUrl, {}, false, siteId);\n    })();\n  }\n  /**\n   * Given an HTML element, get the URLs of the files that should be downloaded and weren't treated by\n   * CoreFilepoolProvider.extractDownloadableFilesFromHtml.\n   *\n   * @param container Container where to get the URLs from.\n   * @returns List of URLs.\n   */\n  getDownloadableFilesFromHTML(container) {\n    const iframes = Array.from(container.querySelectorAll('iframe.h5p-iframe'));\n    const urls = [];\n    for (let i = 0; i < iframes.length; i++) {\n      const params = CoreUrlUtils.extractUrlParams(iframes[i].src);\n      if (params.url) {\n        urls.push(params.url);\n      }\n    }\n    return urls;\n  }\n  /**\n   * Get a file size.\n   *\n   * @param file The file data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the size.\n   */\n  getFileSize(file, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const trustedFile = yield _this.getDownloadableFile(file, siteId);\n        return trustedFile.filesize || 0;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // WS returned an error, it means it cannot be downloaded.\n          return 0;\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Whether or not the handler is enabled on a site level.\n   *\n   * @returns Whether or not the handler is enabled on a site level.\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return CoreH5P.canGetTrustedH5PFileInSite();\n    })();\n  }\n  /**\n   * Check if a file is downloadable.\n   *\n   * @param file The file data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with a boolean and a reason why it isn't downloadable if needed.\n   */\n  isFileDownloadable(file, siteId) {\n    return _asyncToGenerator(function* () {\n      const offlineDisabled = yield CoreH5P.isOfflineDisabled(siteId);\n      if (offlineDisabled) {\n        return {\n          downloadable: false,\n          reason: Translate.instant('core.h5p.offlinedisabled')\n        };\n      } else {\n        return {\n          downloadable: true\n        };\n      }\n    })();\n  }\n  /**\n   * Check whether the file should be treated by this handler. It is used in functions where the component isn't used.\n   *\n   * @param file The file data.\n   * @returns Whether the file should be treated by this handler.\n   */\n  shouldHandleFile(file) {\n    return CoreMimetypeUtils.guessExtensionFromUrl(CoreFileHelper.getFileUrl(file)) == 'h5p';\n  }\n  /**\n   * Treat a downloaded file.\n   *\n   * @param fileUrl The file URL used to download the file.\n   * @param file The file entry of the downloaded file.\n   * @param siteId Site ID. If not defined, current site.\n   * @param onProgress Function to call on progress.\n   * @returns Promise resolved when done.\n   */\n  treatDownloadedFile(fileUrl, file, siteId, onProgress) {\n    return CoreH5PHelper.saveH5P(fileUrl, file, siteId, onProgress);\n  }\n}\n_class = CoreH5PPluginFileHandlerService;\n_class.ɵfac = function CoreH5PPluginFileHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreH5PPluginFileHandler = makeSingleton(CoreH5PPluginFileHandlerService);","map":{"version":3,"names":["CoreSites","CoreMimetypeUtils","CoreUrlUtils","CoreUtils","CoreH5P","Translate","makeSingleton","CoreH5PHelper","CoreFileHelper","CoreH5PPluginFileHandlerService","constructor","name","fileDeleted","fileUrl","path","siteId","_asyncToGenerator","h5pPlayer","deleteContentByUrl","getDownloadableFile","file","site","getSite","getFileUrl","containsUrl","match","getTrustedH5PFile","getDownloadableFilesFromHTML","container","iframes","Array","from","querySelectorAll","urls","i","length","params","extractUrlParams","src","url","push","getFileSize","_this","trustedFile","filesize","error","isWebServiceError","isEnabled","canGetTrustedH5PFileInSite","isFileDownloadable","offlineDisabled","isOfflineDisabled","downloadable","reason","instant","shouldHandleFile","guessExtensionFromUrl","treatDownloadedFile","onProgress","saveH5P","factory","ɵfac","providedIn","CoreH5PPluginFileHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/h5p/services/handlers/pluginfile.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreFilepoolOnProgressCallback } from '@services/filepool';\nimport { CorePluginFileDownloadableResult, CorePluginFileHandler } from '@services/plugin-file-delegate';\nimport { CoreSites } from '@services/sites';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { CoreH5P } from '../h5p';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreH5PHelper } from '../../classes/helper';\nimport { CoreFileHelper } from '@services/file-helper';\n\n/**\n * Handler to treat H5P files.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreH5PPluginFileHandlerService implements CorePluginFileHandler {\n\n    name = 'CoreH5PPluginFileHandler';\n\n    /**\n     * React to a file being deleted.\n     *\n     * @param fileUrl The file URL used to download the file.\n     * @param path The path of the deleted file.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async fileDeleted(fileUrl: string, path: string, siteId?: string): Promise<void> {\n        // If an h5p file is deleted, remove the contents folder.\n        await CoreH5P.h5pPlayer.deleteContentByUrl(fileUrl, siteId);\n    }\n\n    /**\n     * Check whether a file can be downloaded. If so, return the file to download.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the file to use. Rejected if cannot download.\n     */\n    async getDownloadableFile(file: CoreWSFile, siteId?: string): Promise<CoreWSFile> {\n        const site = await CoreSites.getSite(siteId);\n\n        const fileUrl = CoreFileHelper.getFileUrl(file);\n\n        if (site.containsUrl(fileUrl) && fileUrl.match(/pluginfile\\.php\\/[^/]+\\/core_h5p\\/export\\//i)) {\n            // It's already a deployed file, use it.\n            return file;\n        }\n\n        return CoreH5P.getTrustedH5PFile(fileUrl, {}, false, siteId);\n    }\n\n    /**\n     * Given an HTML element, get the URLs of the files that should be downloaded and weren't treated by\n     * CoreFilepoolProvider.extractDownloadableFilesFromHtml.\n     *\n     * @param container Container where to get the URLs from.\n     * @returns List of URLs.\n     */\n    getDownloadableFilesFromHTML(container: HTMLElement): string[] {\n        const iframes = <HTMLIFrameElement[]> Array.from(container.querySelectorAll('iframe.h5p-iframe'));\n        const urls: string[] = [];\n\n        for (let i = 0; i < iframes.length; i++) {\n            const params = CoreUrlUtils.extractUrlParams(iframes[i].src);\n\n            if (params.url) {\n                urls.push(params.url);\n            }\n        }\n\n        return urls;\n    }\n\n    /**\n     * Get a file size.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the size.\n     */\n    async getFileSize(file: CoreWSFile, siteId?: string): Promise<number> {\n        try {\n            const trustedFile = await this.getDownloadableFile(file, siteId);\n\n            return trustedFile.filesize || 0;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // WS returned an error, it means it cannot be downloaded.\n                return 0;\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Whether or not the handler is enabled on a site level.\n     *\n     * @returns Whether or not the handler is enabled on a site level.\n     */\n    async isEnabled(): Promise<boolean> {\n        return CoreH5P.canGetTrustedH5PFileInSite();\n    }\n\n    /**\n     * Check if a file is downloadable.\n     *\n     * @param file The file data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with a boolean and a reason why it isn't downloadable if needed.\n     */\n    async isFileDownloadable(file: CoreWSFile, siteId?: string): Promise<CorePluginFileDownloadableResult> {\n        const offlineDisabled = await CoreH5P.isOfflineDisabled(siteId);\n\n        if (offlineDisabled) {\n            return {\n                downloadable: false,\n                reason: Translate.instant('core.h5p.offlinedisabled'),\n            };\n        } else {\n            return {\n                downloadable: true,\n            };\n        }\n    }\n\n    /**\n     * Check whether the file should be treated by this handler. It is used in functions where the component isn't used.\n     *\n     * @param file The file data.\n     * @returns Whether the file should be treated by this handler.\n     */\n    shouldHandleFile(file: CoreWSFile): boolean {\n        return CoreMimetypeUtils.guessExtensionFromUrl(CoreFileHelper.getFileUrl(file)) == 'h5p';\n    }\n\n    /**\n     * Treat a downloaded file.\n     *\n     * @param fileUrl The file URL used to download the file.\n     * @param file The file entry of the downloaded file.\n     * @param siteId Site ID. If not defined, current site.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when done.\n     */\n    treatDownloadedFile(\n        fileUrl: string,\n        file: FileEntry,\n        siteId?: string,\n        onProgress?: CoreFilepoolOnProgressCallback,\n    ): Promise<void> {\n        return CoreH5PHelper.saveH5P(fileUrl, file, siteId, onProgress);\n    }\n\n}\n\nexport const CoreH5PPluginFileHandler = makeSingleton(CoreH5PPluginFileHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}