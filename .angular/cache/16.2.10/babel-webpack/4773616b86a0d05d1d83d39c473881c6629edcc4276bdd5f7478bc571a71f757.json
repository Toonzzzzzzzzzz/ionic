{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { BehaviorSubject } from 'rxjs';\nimport { CoreDelegate } from '@classes/delegate';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreEvents } from '@singletons/events';\nimport { USER_PROFILE_REFRESHED } from './user';\nimport { makeSingleton } from '@singletons';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreSites } from '@services/sites';\nimport * as i0 from \"@angular/core\";\n/**\n * Delegate update handler event.\n */\nexport const USER_DELEGATE_UPDATE_HANDLER_EVENT = 'CoreUserDelegate_update_handler_event';\n/**\n * Service to interact with plugins to be shown in user profile. Provides functions to register a plugin\n * and notify an update in the data.\n */\nexport class CoreUserDelegateService extends CoreDelegate {\n  constructor() {\n    super('CoreUserDelegate', true);\n    /**\n     * Cache object that checks enabled for use.\n     */\n    this.enabledForUserCache = {};\n    this.featurePrefix = 'CoreUserDelegate_';\n    // Hold the handlers and the observable to notify them for each user.\n    this.userHandlers = {};\n    CoreEvents.on(USER_DELEGATE_UPDATE_HANDLER_EVENT, data => {\n      const handlersData = this.getHandlersData(data.userId, data.context, data.contextId);\n      // Search the handler.\n      const handler = handlersData.handlers.find(userHandler => userHandler.name == data.handler);\n      if (!handler) {\n        return;\n      }\n      // Update the data and notify.\n      Object.assign(handler.data, data.data);\n      handlersData.observable.next(handlersData.handlers);\n    });\n    CoreEvents.on(CoreEvents.LOGOUT, () => {\n      this.clearHandlerCache();\n    });\n    CoreEvents.on(USER_PROFILE_REFRESHED, data => {\n      const context = data.courseId ? CoreUserDelegateContext.COURSE : CoreUserDelegateContext.SITE;\n      this.clearHandlerCache(data.userId, context, data.courseId);\n    });\n  }\n  /**\n   * Check if handlers are loaded for a certain user and context.\n   *\n   * @param userId User ID.\n   * @param context Context.\n   * @param contextId Context ID.\n   * @returns True if handlers are loaded, false otherwise.\n   */\n  areHandlersLoaded(userId, context, contextId) {\n    return this.getHandlersData(userId, context, contextId).loaded;\n  }\n  /**\n   * Clear current user handlers.\n   *\n   * @param userId The user to clear. Undefined for all users.\n   * @param context Context.\n   * @param contextId Context ID.\n   */\n  clearUserHandlers(userId, context, contextId) {\n    if (!userId) {\n      this.userHandlers = {};\n    } else if (!context) {\n      delete this.userHandlers[userId];\n    } else {\n      const handlersData = this.getHandlersData(userId, context, contextId);\n      handlersData.handlers = [];\n      handlersData.observable.next([]);\n      handlersData.loaded = false;\n    }\n  }\n  /**\n   * Get the profile handlers for a user.\n   *\n   * @param user The user object.\n   * @param context Context.\n   * @param contextId Context ID.\n   * @returns Resolved with the handlers.\n   */\n  getProfileHandlersFor(user, context, contextId) {\n    this.calculateUserHandlers(user, context, contextId);\n    return this.getHandlersData(user.id, context, contextId).observable;\n  }\n  /**\n   * Get the profile handlers for a user.\n   *\n   * @param user The user object.\n   * @param context Context.\n   * @param contextId Context ID.\n   * @returns Promise resolved when done.\n   */\n  calculateUserHandlers(user, context, contextId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Get course options.\n      const courses = yield CoreCourses.getUserCourses(true);\n      const courseIds = courses.map(course => course.id);\n      const options = yield CoreCourses.getCoursesAdminAndNavOptions(courseIds);\n      const courseId = context === CoreUserDelegateContext.COURSE && contextId ? contextId : CoreSites.getCurrentSiteHomeId();\n      const navOptions = options.navOptions[courseId];\n      const admOptions = options.admOptions[courseId];\n      const handlersData = _this.getHandlersData(user.id, context, contextId);\n      handlersData.handlers = [];\n      yield CoreUtils.allPromises(Object.keys(_this.enabledHandlers).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (name) {\n          // Checks if the handler is enabled for the user.\n          const handler = _this.handlers[name];\n          try {\n            const enabled = yield _this.getAndCacheEnabledForUserFromHandler(handler, user, context, courseId, navOptions, admOptions);\n            if (enabled) {\n              handlersData.handlers.push({\n                name: name,\n                data: handler.getDisplayData(user, context, courseId),\n                priority: handler.priority || 0,\n                type: handler.type || CoreUserDelegateService.TYPE_NEW_PAGE\n              });\n            }\n          } catch (_unused) {\n            // Nothing to do here, it is not enabled for this user.\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      // Sort them by priority.\n      handlersData.handlers.sort((a, b) => {\n        var _b$priority, _a$priority;\n        return ((_b$priority = b.priority) !== null && _b$priority !== void 0 ? _b$priority : 0) - ((_a$priority = a.priority) !== null && _a$priority !== void 0 ? _a$priority : 0);\n      });\n      handlersData.loaded = true;\n      handlersData.observable.next(handlersData.handlers);\n    })();\n  }\n  /**\n   * Helper funtion to get enabled for user from the handler.\n   *\n   * @param handler Handler object.\n   * @param user User object.\n   * @param context Context.\n   * @param contextId Context ID.\n   * @param navOptions Navigation options for the course.\n   * @param admOptions Admin options for the course.\n   * @returns Whether or not the handler is enabled for a user.\n   */\n  getAndCacheEnabledForUserFromHandler(handler, user, context, contextId, navOptions = {}, admOptions = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (handler.isEnabledForContext) {\n        const enabledOnCourse = yield handler.isEnabledForContext(context, contextId, navOptions, admOptions);\n        if (!enabledOnCourse) {\n          // If is not enabled in the course, is not enabled for the user.\n          // Do not cache if this is false.\n          return false;\n        }\n      }\n      if (!handler.cacheEnabled) {\n        if (!handler.isEnabledForUser) {\n          // True by default.\n          return true;\n        }\n        return handler.isEnabledForUser(user, context, contextId);\n      }\n      if (_this2.enabledForUserCache[handler.name] === undefined) {\n        _this2.enabledForUserCache[handler.name] = {};\n      }\n      const cacheKey = _this2.getCacheKey(user.id, context, contextId);\n      const cache = _this2.enabledForUserCache[handler.name][cacheKey];\n      if (cache !== undefined) {\n        return cache;\n      }\n      let enabled = true; // Default value.\n      if (handler.isEnabledForUser) {\n        enabled = yield handler.isEnabledForUser(user, context, contextId);\n      }\n      _this2.enabledForUserCache[handler.name][cacheKey] = enabled;\n      return enabled;\n    })();\n  }\n  /**\n   * Clear handler enabled for user cache.\n   * If a userId and context are specified, it will only delete the entry for that user and context.\n   *\n   * @param userId User ID.\n   * @param context Context.\n   * @param contextId Context ID.\n   */\n  clearHandlerCache(userId, context, contextId) {\n    if (userId && context) {\n      const cacheKey = this.getCacheKey(userId, context, contextId);\n      Object.keys(this.enabledHandlers).forEach(name => {\n        const cache = this.enabledForUserCache[name];\n        if (cache) {\n          delete cache[cacheKey];\n        }\n      });\n    } else {\n      this.enabledForUserCache = {};\n    }\n  }\n  /**\n   * Get a cache key to identify a user and context.\n   *\n   * @param userId User ID.\n   * @param context Context.\n   * @param contextId Context ID.\n   * @returns Cache key.\n   */\n  getCacheKey(userId, context, contextId) {\n    return `${userId}#${this.getContextKey(context, contextId)}`;\n  }\n  /**\n   * Get a string to identify a context.\n   *\n   * @param context Context.\n   * @param contextId Context ID.\n   * @returns String to identify the context.\n   */\n  getContextKey(context, contextId) {\n    return `${context}#${contextId !== null && contextId !== void 0 ? contextId : 0}`;\n  }\n  /**\n   * Get handlers data for a user and context.\n   *\n   * @param userId User ID.\n   * @param context Context.\n   * @param contextId Context ID.\n   * @returns Handlers data.\n   */\n  getHandlersData(userId, context, contextId) {\n    // Initialize the data if it doesn't exist.\n    const contextKey = this.getContextKey(context, contextId);\n    this.userHandlers[userId] = this.userHandlers[userId] || {};\n    if (!this.userHandlers[userId][contextKey]) {\n      this.userHandlers[userId][contextKey] = {\n        loaded: false,\n        handlers: [],\n        observable: new BehaviorSubject([])\n      };\n    }\n    return this.userHandlers[userId][contextKey];\n  }\n}\n_class = CoreUserDelegateService;\n/**\n * User profile handler type for communication.\n */\n_class.TYPE_COMMUNICATION = 'communication';\n/**\n * User profile handler type for new page.\n */\n_class.TYPE_NEW_PAGE = 'newpage';\n/**\n * User profile handler type for actions.\n */\n_class.TYPE_ACTION = 'action';\n_class.ɵfac = function CoreUserDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreUserDelegate = makeSingleton(CoreUserDelegateService);\n/**\n * Context levels enumeration.\n */\nexport var CoreUserDelegateContext;\n(function (CoreUserDelegateContext) {\n  CoreUserDelegateContext[\"SITE\"] = \"site\";\n  CoreUserDelegateContext[\"COURSE\"] = \"course\";\n  CoreUserDelegateContext[\"USER_MENU\"] = \"user_menu\";\n})(CoreUserDelegateContext || (CoreUserDelegateContext = {}));","map":{"version":3,"names":["BehaviorSubject","CoreDelegate","CoreUtils","CoreEvents","USER_PROFILE_REFRESHED","makeSingleton","CoreCourses","CoreSites","USER_DELEGATE_UPDATE_HANDLER_EVENT","CoreUserDelegateService","constructor","enabledForUserCache","featurePrefix","userHandlers","on","data","handlersData","getHandlersData","userId","context","contextId","handler","handlers","find","userHandler","name","Object","assign","observable","next","LOGOUT","clearHandlerCache","courseId","CoreUserDelegateContext","COURSE","SITE","areHandlersLoaded","loaded","clearUserHandlers","getProfileHandlersFor","user","calculateUserHandlers","id","_this","_asyncToGenerator","courses","getUserCourses","courseIds","map","course","options","getCoursesAdminAndNavOptions","getCurrentSiteHomeId","navOptions","admOptions","allPromises","keys","enabledHandlers","_ref","enabled","getAndCacheEnabledForUserFromHandler","push","getDisplayData","priority","type","TYPE_NEW_PAGE","_unused","_x","apply","arguments","sort","a","b","_b$priority","_a$priority","_this2","isEnabledForContext","enabledOnCourse","cacheEnabled","isEnabledForUser","undefined","cacheKey","getCacheKey","cache","forEach","getContextKey","contextKey","_class","TYPE_COMMUNICATION","TYPE_ACTION","factory","ɵfac","providedIn","CoreUserDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/user/services/user-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { Subject, BehaviorSubject } from 'rxjs';\n\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreUserProfile, USER_PROFILE_REFRESHED } from './user';\nimport { makeSingleton } from '@singletons';\nimport { CoreCourses, CoreCourseUserAdminOrNavOptionIndexed } from '@features/courses/services/courses';\nimport { CoreSites } from '@services/sites';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [USER_DELEGATE_UPDATE_HANDLER_EVENT]: CoreUserUpdateHandlerData;\n    }\n\n}\n\n/**\n * Interface that all user profile handlers must implement.\n */\nexport interface CoreUserProfileHandler extends CoreDelegateHandler {\n    /**\n     * The highest priority is displayed first.\n     */\n    priority: number;\n\n    /**\n     * A type should be specified among these:\n     * - TYPE_COMMUNICATION: will be displayed under the user avatar. Should have icon. Spinner not used.\n     * - TYPE_NEW_PAGE: will be displayed as a list of items. Should have icon. Spinner not used.\n     *     Default value if none is specified.\n     * - TYPE_ACTION: will be displayed as a button and should not redirect to any state. Spinner use is recommended.\n     */\n    type: string;\n\n    /**\n     * If isEnabledForUser Cache should be enabled.\n     */\n    cacheEnabled?: boolean;\n\n    /**\n     * Whether or not the handler is enabled for a context.\n     *\n     * @param context Context.\n     * @param contextId Context ID.\n     * @param navOptions Navigation options for the course.\n     * @param admOptions Admin options for the course.\n     * @returns Whether or not the handler is enabled for a user.\n     */\n    isEnabledForContext?(\n        context: CoreUserDelegateContext,\n        contextId: number,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<boolean>;\n\n    /**\n     * Whether or not the handler is enabled for a user.\n     *\n     * @param user User object.\n     * @param context Context.\n     * @param contextId Context ID.\n     * @returns Whether or not the handler is enabled for a user.\n     */\n    isEnabledForUser?(user: CoreUserProfile, context: CoreUserDelegateContext, contextId: number): Promise<boolean>;\n\n    /**\n     * Returns the data needed to render the handler.\n     *\n     * @param user User object.\n     * @param context Context.\n     * @param contextId Context ID.\n     * @returns Data to be shown.\n     */\n    getDisplayData(user: CoreUserProfile, context: CoreUserDelegateContext, contextId: number): CoreUserProfileHandlerData;\n}\n\n/**\n * Data needed to render a user profile handler. It's returned by the handler.\n */\nexport interface CoreUserProfileHandlerData {\n    /**\n     * Title to display.\n     */\n    title: string;\n\n    /**\n     * Name of the icon to display. Mandatory for TYPE_COMMUNICATION.\n     */\n    icon?: string;\n\n    /**\n     * Additional class to add to the HTML.\n     */\n    class?: string;\n\n    /**\n     * If enabled, element will be hidden. Only for TYPE_NEW_PAGE and TYPE_ACTION.\n     */\n    hidden?: boolean;\n\n    /**\n     * If enabled will show an spinner. Only for TYPE_ACTION.\n     */\n    spinner?: boolean;\n\n    /**\n     * If the handler has badge to show or not. Only for TYPE_NEW_PAGE.\n     */\n    showBadge?: boolean;\n\n    /**\n     * Text to display on the badge. Only used if showBadge is true and only for TYPE_NEW_PAGE.\n     */\n    badge?: string;\n\n    /**\n     * Accessibility text to add on the badge. Only used if showBadge is true and only for TYPE_NEW_PAGE.\n     */\n    badgeA11yText?: string;\n\n    /**\n     * If true, the badge number is being loaded. Only used if showBadge is true and only for TYPE_NEW_PAGE.\n     */\n    loading?: boolean;\n\n    /**\n     * Action to do when clicked.\n     *\n     * @param event Click event.\n     * @param user User object.\n     * @param context Context.\n     * @param contextId Context ID.\n     */\n    action(event: Event, user: CoreUserProfile, context: CoreUserDelegateContext, contextId?: number): void;\n}\n\n/**\n * Data returned by the delegate for each handler.\n */\nexport interface CoreUserProfileHandlerToDisplay {\n    /**\n     * Name of the handler.\n     */\n    name?: string;\n\n    /**\n     * Data to display.\n     */\n    data: CoreUserProfileHandlerData;\n\n    /**\n     * The highest priority is displayed first.\n     */\n    priority?: number;\n\n    /**\n     * The type of the handler. See CoreUserProfileHandler.\n     */\n    type: string;\n}\n\n/**\n * Delegate update handler event.\n */\nexport const USER_DELEGATE_UPDATE_HANDLER_EVENT = 'CoreUserDelegate_update_handler_event';\n\n/**\n * Service to interact with plugins to be shown in user profile. Provides functions to register a plugin\n * and notify an update in the data.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreUserDelegateService extends CoreDelegate<CoreUserProfileHandler> {\n\n    /**\n     * User profile handler type for communication.\n     */\n    static readonly TYPE_COMMUNICATION = 'communication';\n    /**\n     * User profile handler type for new page.\n     */\n    static readonly TYPE_NEW_PAGE = 'newpage';\n    /**\n     * User profile handler type for actions.\n     */\n    static readonly TYPE_ACTION = 'action';\n\n    /**\n     * Cache object that checks enabled for use.\n     */\n    protected enabledForUserCache: Record<string, Record<string, boolean>> = {};\n\n    protected featurePrefix = 'CoreUserDelegate_';\n\n    // Hold the handlers and the observable to notify them for each user.\n    protected userHandlers: Record<number, Record<string, CoreUserDelegateHandlersData>> = {};\n\n    constructor() {\n        super('CoreUserDelegate', true);\n\n        CoreEvents.on(USER_DELEGATE_UPDATE_HANDLER_EVENT, (data) => {\n            const handlersData = this.getHandlersData(data.userId, data.context, data.contextId);\n\n            // Search the handler.\n            const handler = handlersData.handlers.find((userHandler) => userHandler.name == data.handler);\n\n            if (!handler) {\n                return;\n            }\n\n            // Update the data and notify.\n            Object.assign(handler.data, data.data);\n            handlersData.observable.next(handlersData.handlers);\n        });\n\n        CoreEvents.on(CoreEvents.LOGOUT, () => {\n            this.clearHandlerCache();\n        });\n\n        CoreEvents.on(USER_PROFILE_REFRESHED, (data) => {\n            const context = data.courseId ? CoreUserDelegateContext.COURSE : CoreUserDelegateContext.SITE;\n            this.clearHandlerCache(data.userId, context, data.courseId);\n        });\n    }\n\n    /**\n     * Check if handlers are loaded for a certain user and context.\n     *\n     * @param userId User ID.\n     * @param context Context.\n     * @param contextId Context ID.\n     * @returns True if handlers are loaded, false otherwise.\n     */\n    areHandlersLoaded(userId: number, context: CoreUserDelegateContext, contextId?: number): boolean {\n        return this.getHandlersData(userId, context, contextId).loaded;\n    }\n\n    /**\n     * Clear current user handlers.\n     *\n     * @param userId The user to clear. Undefined for all users.\n     * @param context Context.\n     * @param contextId Context ID.\n     */\n    clearUserHandlers(userId?: number, context?: CoreUserDelegateContext, contextId?: number): void {\n        if (!userId) {\n            this.userHandlers = {};\n        } else if (!context) {\n            delete this.userHandlers[userId];\n        } else {\n            const handlersData = this.getHandlersData(userId, context, contextId);\n\n            handlersData.handlers = [];\n            handlersData.observable.next([]);\n            handlersData.loaded = false;\n        }\n    }\n\n    /**\n     * Get the profile handlers for a user.\n     *\n     * @param user The user object.\n     * @param context Context.\n     * @param contextId Context ID.\n     * @returns Resolved with the handlers.\n     */\n    getProfileHandlersFor(\n        user: CoreUserProfile,\n        context: CoreUserDelegateContext,\n        contextId?: number,\n    ): Subject<CoreUserProfileHandlerToDisplay[]> {\n        this.calculateUserHandlers(user, context, contextId);\n\n        return this.getHandlersData(user.id, context, contextId).observable;\n    }\n\n    /**\n     * Get the profile handlers for a user.\n     *\n     * @param user The user object.\n     * @param context Context.\n     * @param contextId Context ID.\n     * @returns Promise resolved when done.\n     */\n    protected async calculateUserHandlers(\n        user: CoreUserProfile,\n        context: CoreUserDelegateContext,\n        contextId?: number,\n    ): Promise<void> {\n        // Get course options.\n        const courses = await CoreCourses.getUserCourses(true);\n        const courseIds = courses.map((course) => course.id);\n\n        const options = await CoreCourses.getCoursesAdminAndNavOptions(courseIds);\n\n        const courseId = context === CoreUserDelegateContext.COURSE && contextId ? contextId : CoreSites.getCurrentSiteHomeId();\n\n        const navOptions = options.navOptions[courseId];\n        const admOptions = options.admOptions[courseId];\n\n        const handlersData = this.getHandlersData(user.id, context, contextId);\n        handlersData.handlers = [];\n\n        await CoreUtils.allPromises(Object.keys(this.enabledHandlers).map(async (name) => {\n            // Checks if the handler is enabled for the user.\n            const handler = this.handlers[name];\n\n            try {\n                const enabled = await this.getAndCacheEnabledForUserFromHandler(\n                    handler,\n                    user,\n                    context,\n                    courseId,\n                    navOptions,\n                    admOptions,\n                );\n\n                if (enabled) {\n                    handlersData.handlers.push({\n                        name: name,\n                        data: handler.getDisplayData(user, context, courseId),\n                        priority: handler.priority || 0,\n                        type: handler.type || CoreUserDelegateService.TYPE_NEW_PAGE,\n                    });\n                }\n            } catch {\n                // Nothing to do here, it is not enabled for this user.\n            }\n        }));\n\n        // Sort them by priority.\n        handlersData.handlers.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));\n        handlersData.loaded = true;\n        handlersData.observable.next(handlersData.handlers);\n    }\n\n    /**\n     * Helper funtion to get enabled for user from the handler.\n     *\n     * @param handler Handler object.\n     * @param user User object.\n     * @param context Context.\n     * @param contextId Context ID.\n     * @param navOptions Navigation options for the course.\n     * @param admOptions Admin options for the course.\n     * @returns Whether or not the handler is enabled for a user.\n     */\n    protected async getAndCacheEnabledForUserFromHandler(\n        handler: CoreUserProfileHandler,\n        user: CoreUserProfile,\n        context: CoreUserDelegateContext,\n        contextId: number,\n        navOptions: CoreCourseUserAdminOrNavOptionIndexed = {},\n        admOptions: CoreCourseUserAdminOrNavOptionIndexed = {},\n    ): Promise<boolean> {\n        if (handler.isEnabledForContext) {\n            const enabledOnCourse = await handler.isEnabledForContext(context, contextId, navOptions, admOptions);\n\n            if (!enabledOnCourse) {\n                // If is not enabled in the course, is not enabled for the user.\n                // Do not cache if this is false.\n                return false;\n            }\n        }\n\n        if (!handler.cacheEnabled) {\n            if (!handler.isEnabledForUser) {\n                // True by default.\n                return true;\n            }\n\n            return handler.isEnabledForUser(user, context, contextId);\n        }\n\n        if (this.enabledForUserCache[handler.name] === undefined) {\n            this.enabledForUserCache[handler.name] = {};\n        }\n\n        const cacheKey = this.getCacheKey(user.id, context, contextId);\n        const cache = this.enabledForUserCache[handler.name][cacheKey];\n\n        if (cache !== undefined) {\n            return cache;\n        }\n\n        let enabled = true; // Default value.\n        if (handler.isEnabledForUser) {\n            enabled = await handler.isEnabledForUser(user, context, contextId);\n        }\n\n        this.enabledForUserCache[handler.name][cacheKey] = enabled;\n\n        return enabled;\n    }\n\n    /**\n     * Clear handler enabled for user cache.\n     * If a userId and context are specified, it will only delete the entry for that user and context.\n     *\n     * @param userId User ID.\n     * @param context Context.\n     * @param contextId Context ID.\n     */\n    protected clearHandlerCache(userId?: number, context?: CoreUserDelegateContext, contextId?: number): void {\n        if (userId && context) {\n            const cacheKey = this.getCacheKey(userId, context, contextId);\n\n            Object.keys(this.enabledHandlers).forEach((name) => {\n                const cache = this.enabledForUserCache[name];\n\n                if (cache) {\n                    delete cache[cacheKey];\n                }\n            });\n        } else {\n            this.enabledForUserCache = {};\n        }\n    }\n\n    /**\n     * Get a cache key to identify a user and context.\n     *\n     * @param userId User ID.\n     * @param context Context.\n     * @param contextId Context ID.\n     * @returns Cache key.\n     */\n    protected getCacheKey(userId: number, context: CoreUserDelegateContext, contextId?: number): string {\n        return `${userId}#${this.getContextKey(context, contextId)}`;\n    }\n\n    /**\n     * Get a string to identify a context.\n     *\n     * @param context Context.\n     * @param contextId Context ID.\n     * @returns String to identify the context.\n     */\n    protected getContextKey(context: CoreUserDelegateContext, contextId?: number): string {\n        return `${context}#${contextId ?? 0}`;\n    }\n\n    /**\n     * Get handlers data for a user and context.\n     *\n     * @param userId User ID.\n     * @param context Context.\n     * @param contextId Context ID.\n     * @returns Handlers data.\n     */\n    protected getHandlersData(userId: number, context: CoreUserDelegateContext, contextId?: number): CoreUserDelegateHandlersData {\n        // Initialize the data if it doesn't exist.\n        const contextKey = this.getContextKey(context, contextId);\n        this.userHandlers[userId] = this.userHandlers[userId] || {};\n\n        if (!this.userHandlers[userId][contextKey]) {\n            this.userHandlers[userId][contextKey] = {\n                loaded: false,\n                handlers: [],\n                observable: new BehaviorSubject<CoreUserProfileHandlerToDisplay[]>([]),\n            };\n        }\n\n        return this.userHandlers[userId][contextKey];\n    }\n\n}\n\nexport const CoreUserDelegate = makeSingleton(CoreUserDelegateService);\n\n/**\n * Handlers data for a user and context.\n */\ntype CoreUserDelegateHandlersData = {\n    loaded: boolean; // Whether the handlers are loaded.\n    handlers: CoreUserProfileHandlerToDisplay[]; // List of handlers.\n    observable: Subject<CoreUserProfileHandlerToDisplay[]>; // Observable to notify the handlers.\n};\n\n/**\n * Context levels enumeration.\n */\nexport enum CoreUserDelegateContext {\n    SITE = 'site',\n    COURSE = 'course',\n    USER_MENU = 'user_menu',\n}\n\n/**\n * Data passed to UPDATE_HANDLER_EVENT event.\n */\nexport type CoreUserUpdateHandlerData = {\n    handler: string; // Name of the handler.\n    userId: number; // User affected.\n    context: CoreUserDelegateContext; // Context affected.\n    contextId?: number; // ID related to the context.\n    data: Record<string, unknown>; // Data to set to the handler.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}