{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBaseProvider } from '@classes/base-sync';\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreCourseOffline } from './course-offline';\nimport { CoreCourse } from './course';\nimport { CoreCourseLogHelper } from './log-helper';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync course offline data. This only syncs the offline data of the course itself, not the offline data of\n * the activities in the course.\n */\nexport class CoreCourseSyncProvider extends CoreSyncBaseProvider {\n  constructor() {\n    super('CoreCourseSyncProvider');\n  }\n  /**\n   * Try to synchronize all the courses in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether the execution is forced (manual sync).\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllCourses(siteId, force) {\n    return this.syncOnSites('courses', siteId => this.syncAllCoursesFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all courses on a site.\n   *\n   * @param force Wether the execution is forced (manual sync).\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllCoursesFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all([CoreCourseLogHelper.syncSite(siteId), _this.syncCoursesCompletion(siteId, force)]);\n    })();\n  }\n  /**\n   * Sync courses offline completion.\n   *\n   * @param siteId Site ID to sync.\n   * @param force Wether the execution is forced (manual sync).\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncCoursesCompletion(siteId, force) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const completions = yield CoreCourseOffline.getAllManualCompletions(siteId);\n      const courseNames = {};\n      // Sync all courses.\n      yield Promise.all(completions.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (completion) {\n          if (courseNames[completion.courseid] === undefined) {\n            const course = yield CoreUtils.ignoreErrors(CoreCourses.getUserCourse(completion.courseid, true, siteId));\n            courseNames[completion.courseid] = (course === null || course === void 0 ? void 0 : course.displayname) || (course === null || course === void 0 ? void 0 : course.fullname);\n          }\n          const result = yield force ? _this2.syncCourse(completion.courseid, courseNames[completion.courseid], siteId) : _this2.syncCourseIfNeeded(completion.courseid, courseNames[completion.courseid], siteId);\n          if (!result || !result.updated) {\n            return;\n          }\n          // Sync successful, send event.\n          CoreEvents.trigger(CoreCourseSyncProvider.AUTO_SYNCED, {\n            courseId: completion.courseid,\n            warnings: result.warnings\n          }, siteId);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Sync a course if it's needed.\n   *\n   * @param courseId Course ID to be synced.\n   * @param courseName Course Name to be synced.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the course is synced or it doesn't need to be synced.\n   */\n  syncCourseIfNeeded(courseId, courseName, siteId) {\n    // Usually we call isSyncNeeded to check if a certain time has passed.\n    // However, since we barely send data for now just sync the course.\n    return this.syncCourse(courseId, courseName, siteId);\n  }\n  /**\n   * Synchronize a course.\n   *\n   * @param courseId Course ID to be synced.\n   * @param courseName Course Name to be synced.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncCourse(courseId, courseName, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const currentSyncPromise = _this3.getOngoingSync(courseId, siteId);\n      if (currentSyncPromise) {\n        // There's already a sync ongoing for this discussion, return the promise.\n        return currentSyncPromise;\n      }\n      _this3.logger.debug(`Try to sync course '${courseId}'`);\n      return _this3.addOngoingSync(courseId, _this3.syncCourseCompletion(courseId, courseName, siteId), siteId);\n    })();\n  }\n  /**\n   * Sync course offline completion.\n   *\n   * @param courseId Course ID to be synced.\n   * @param courseName Course Name to be synced.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncCourseCompletion(courseId, courseName, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Get offline responses to be sent.\n      const completions = yield CoreUtils.ignoreErrors(CoreCourseOffline.getCourseManualCompletions(courseId, siteId), []);\n      if (!completions || !completions.length) {\n        // Nothing to sync, set sync time.\n        yield _this4.setSyncTime(courseId, siteId);\n        // All done, return the data.\n        return result;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      // Get the current completion status to check if any completion was modified in web.\n      // This can be retrieved on core_course_get_contents since 3.6 but this is an easy way to get them.\n      const onlineCompletions = yield CoreCourse.getActivitiesCompletionStatus(courseId, siteId, undefined, false, true, false);\n      // Send all the completions.\n      yield Promise.all(completions.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (entry) {\n          const onlineComp = onlineCompletions[entry.cmid];\n          // Check if the completion was modified in online. If so, discard it.\n          if (onlineComp && onlineComp.timecompleted * 1000 > entry.timecompleted) {\n            yield CoreCourseOffline.deleteManualCompletion(entry.cmid, siteId);\n            // Completion deleted, add a warning if the completion status doesn't match.\n            if (onlineComp.state != entry.completed) {\n              result.warnings.push({\n                warningcode: 'apperror',\n                message: Translate.instant('core.course.warningofflinemanualcompletiondeleted', {\n                  name: courseName || courseId,\n                  error: Translate.instant('core.course.warningmanualcompletionmodified')\n                })\n              });\n            }\n            return;\n          }\n          try {\n            yield CoreCourse.markCompletedManuallyOnline(entry.cmid, !!entry.completed, siteId);\n            result.updated = true;\n            yield CoreCourseOffline.deleteManualCompletion(entry.cmid, siteId);\n          } catch (error) {\n            if (!CoreUtils.isWebServiceError(error)) {\n              // Couldn't connect to server, reject.\n              throw error;\n            }\n            // The WebService has thrown an error, this means that the completion cannot be submitted. Delete it.\n            result.updated = true;\n            yield CoreCourseOffline.deleteManualCompletion(entry.cmid, siteId);\n            // Completion deleted, add a warning.\n            result.warnings.push({\n              warningcode: 'apperror',\n              message: Translate.instant('core.course.warningofflinemanualcompletiondeleted', {\n                name: courseName || courseId,\n                error: CoreTextUtils.getErrorMessageFromError(error)\n              })\n            });\n          }\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      if (result.updated) {\n        try {\n          // Update data.\n          yield CoreCourse.invalidateSections(courseId, siteId);\n          const currentSite = CoreSites.getCurrentSite();\n          if (currentSite !== null && currentSite !== void 0 && currentSite.isVersionGreaterEqualThan('3.6')) {\n            yield CoreCourse.getSections(courseId, false, true, undefined, siteId);\n          } else {\n            yield CoreCourse.getActivitiesCompletionStatus(courseId, siteId);\n          }\n        } catch (_unused) {\n          // Ignore errors.\n        }\n      }\n      // Sync finished, set sync time.\n      yield _this4.setSyncTime(courseId, siteId);\n      // All done, return the data.\n      return result;\n    })();\n  }\n}\n_class = CoreCourseSyncProvider;\n_class.AUTO_SYNCED = 'core_course_autom_synced';\n_class.ɵfac = function CoreCourseSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCourseSync = makeSingleton(CoreCourseSyncProvider);","map":{"version":3,"names":["CoreSyncBaseProvider","CoreSites","CoreNetwork","CoreUtils","CoreTextUtils","CoreCourseOffline","CoreCourse","CoreCourseLogHelper","CoreNetworkError","makeSingleton","Translate","CoreEvents","CoreCourses","CoreCourseSyncProvider","constructor","syncAllCourses","siteId","force","syncOnSites","syncAllCoursesFunc","_this","_asyncToGenerator","Promise","all","syncSite","syncCoursesCompletion","_this2","completions","getAllManualCompletions","courseNames","map","_ref","completion","courseid","undefined","course","ignoreErrors","getUserCourse","displayname","fullname","result","syncCourse","syncCourseIfNeeded","updated","trigger","AUTO_SYNCED","courseId","warnings","_x","apply","arguments","courseName","_this3","getCurrentSiteId","currentSyncPromise","getOngoingSync","logger","debug","addOngoingSync","syncCourseCompletion","_this4","getCourseManualCompletions","length","setSyncTime","isOnline","onlineCompletions","getActivitiesCompletionStatus","_ref2","entry","onlineComp","cmid","timecompleted","deleteManualCompletion","state","completed","push","warningcode","message","instant","name","error","markCompletedManuallyOnline","isWebServiceError","getErrorMessageFromError","_x2","invalidateSections","currentSite","getCurrentSite","isVersionGreaterEqualThan","getSections","_unused","_class","factory","ɵfac","providedIn","CoreCourseSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/services/sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreSyncBaseProvider } from '@classes/base-sync';\n\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreCourseOffline } from './course-offline';\nimport { CoreCourse } from './course';\nimport { CoreCourseLogHelper } from './log-helper';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { CoreCourseManualCompletionDBRecord } from './database/course';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreCourses } from '@features/courses/services/courses';\n\n/**\n * Service to sync course offline data. This only syncs the offline data of the course itself, not the offline data of\n * the activities in the course.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCourseSyncProvider extends CoreSyncBaseProvider<CoreCourseSyncResult> {\n\n    static readonly AUTO_SYNCED = 'core_course_autom_synced';\n\n    constructor() {\n        super('CoreCourseSyncProvider');\n    }\n\n    /**\n     * Try to synchronize all the courses in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether the execution is forced (manual sync).\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllCourses(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('courses', (siteId) => this.syncAllCoursesFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all courses on a site.\n     *\n     * @param force Wether the execution is forced (manual sync).\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllCoursesFunc(force: boolean, siteId: string): Promise<void> {\n        await Promise.all([\n            CoreCourseLogHelper.syncSite(siteId),\n            this.syncCoursesCompletion(siteId, force),\n        ]);\n    }\n\n    /**\n     * Sync courses offline completion.\n     *\n     * @param siteId Site ID to sync.\n     * @param force Wether the execution is forced (manual sync).\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncCoursesCompletion(siteId: string, force: boolean): Promise<void> {\n        const completions = await CoreCourseOffline.getAllManualCompletions(siteId);\n\n        const courseNames: Record<number, string | undefined> = {};\n\n        // Sync all courses.\n        await Promise.all(completions.map(async (completion) => {\n            if (courseNames[completion.courseid] === undefined) {\n                const course = await CoreUtils.ignoreErrors(CoreCourses.getUserCourse(completion.courseid, true, siteId));\n\n                courseNames[completion.courseid] = course?.displayname || course?.fullname;\n            }\n\n            const result = await (force ? this.syncCourse(completion.courseid, courseNames[completion.courseid], siteId) :\n                this.syncCourseIfNeeded(completion.courseid, courseNames[completion.courseid], siteId));\n\n            if (!result || !result.updated) {\n                return;\n            }\n\n            // Sync successful, send event.\n            CoreEvents.trigger(CoreCourseSyncProvider.AUTO_SYNCED, {\n                courseId: completion.courseid,\n                warnings: result.warnings,\n            }, siteId);\n        }));\n    }\n\n    /**\n     * Sync a course if it's needed.\n     *\n     * @param courseId Course ID to be synced.\n     * @param courseName Course Name to be synced.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the course is synced or it doesn't need to be synced.\n     */\n    syncCourseIfNeeded(courseId: number, courseName?: string, siteId?: string): Promise<CoreCourseSyncResult> {\n        // Usually we call isSyncNeeded to check if a certain time has passed.\n        // However, since we barely send data for now just sync the course.\n        return this.syncCourse(courseId, courseName, siteId);\n    }\n\n    /**\n     * Synchronize a course.\n     *\n     * @param courseId Course ID to be synced.\n     * @param courseName Course Name to be synced.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    async syncCourse(courseId: number, courseName?: string, siteId?: string): Promise<CoreCourseSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(courseId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this discussion, return the promise.\n            return currentSyncPromise;\n        }\n\n        this.logger.debug(`Try to sync course '${courseId}'`);\n\n        return this.addOngoingSync(courseId, this.syncCourseCompletion(courseId, courseName, siteId), siteId);\n    }\n\n    /**\n     * Sync course offline completion.\n     *\n     * @param courseId Course ID to be synced.\n     * @param courseName Course Name to be synced.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    protected async syncCourseCompletion(courseId: number, courseName?: string, siteId?: string): Promise<CoreCourseSyncResult> {\n        const result: CoreCourseSyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Get offline responses to be sent.\n        const completions = await CoreUtils.ignoreErrors(\n            CoreCourseOffline.getCourseManualCompletions(courseId, siteId),\n            <CoreCourseManualCompletionDBRecord[]> [],\n        );\n\n        if (!completions || !completions.length) {\n            // Nothing to sync, set sync time.\n            await this.setSyncTime(courseId, siteId);\n\n            // All done, return the data.\n            return result;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        // Get the current completion status to check if any completion was modified in web.\n        // This can be retrieved on core_course_get_contents since 3.6 but this is an easy way to get them.\n        const onlineCompletions = await CoreCourse.getActivitiesCompletionStatus(\n            courseId,\n            siteId,\n            undefined,\n            false,\n            true,\n            false,\n        );\n\n        // Send all the completions.\n        await Promise.all(completions.map(async (entry) => {\n            const onlineComp = onlineCompletions[entry.cmid];\n\n            // Check if the completion was modified in online. If so, discard it.\n            if (onlineComp && onlineComp.timecompleted * 1000 > entry.timecompleted) {\n                await CoreCourseOffline.deleteManualCompletion(entry.cmid, siteId);\n\n                // Completion deleted, add a warning if the completion status doesn't match.\n                if (onlineComp.state != entry.completed) {\n                    result.warnings.push({\n                        warningcode: 'apperror',\n                        message: Translate.instant('core.course.warningofflinemanualcompletiondeleted', {\n                            name: courseName || courseId,\n                            error: Translate.instant('core.course.warningmanualcompletionmodified'),\n                        }),\n                    });\n                }\n\n                return;\n            }\n\n            try {\n                await CoreCourse.markCompletedManuallyOnline(entry.cmid, !!entry.completed, siteId);\n\n                result.updated = true;\n\n                await CoreCourseOffline.deleteManualCompletion(entry.cmid, siteId);\n            } catch (error) {\n                if (!CoreUtils.isWebServiceError(error)) {\n                    // Couldn't connect to server, reject.\n                    throw error;\n                }\n\n                // The WebService has thrown an error, this means that the completion cannot be submitted. Delete it.\n                result.updated = true;\n\n                await CoreCourseOffline.deleteManualCompletion(entry.cmid, siteId);\n\n                // Completion deleted, add a warning.\n                result.warnings.push({\n                    warningcode: 'apperror',\n                    message: Translate.instant('core.course.warningofflinemanualcompletiondeleted', {\n                        name: courseName || courseId,\n                        error: CoreTextUtils.getErrorMessageFromError(error),\n                    }),\n                });\n            }\n        }));\n\n        if (result.updated) {\n            try {\n                // Update data.\n                await CoreCourse.invalidateSections(courseId, siteId);\n\n                const currentSite = CoreSites.getCurrentSite();\n\n                if (currentSite?.isVersionGreaterEqualThan('3.6')) {\n                    await CoreCourse.getSections(courseId, false, true, undefined, siteId);\n                } else {\n                    await CoreCourse.getActivitiesCompletionStatus(courseId, siteId);\n                }\n            } catch {\n                // Ignore errors.\n            }\n        }\n\n        // Sync finished, set sync time.\n        await this.setSyncTime(courseId, siteId);\n\n        // All done, return the data.\n        return result;\n    }\n\n}\n\nexport const CoreCourseSync = makeSingleton(CoreCourseSyncProvider);\n\n/**\n * Result of course sync.\n */\nexport type CoreCourseSyncResult = {\n    updated: boolean;\n    warnings: CoreWSExternalWarning[];\n};\n\n/**\n * Data passed to AUTO_SYNCED event.\n */\nexport type CoreCourseAutoSyncData = {\n    courseId: number;\n    warnings: CoreWSExternalWarning[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}