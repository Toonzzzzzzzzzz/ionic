{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreContentLinksHelper } from '@features/contentlinks/services/contentlinks-helper';\nimport { AddonNotifications } from '../notifications';\nimport { AddonNotificationsMainMenuHandlerService } from './mainmenu';\nimport { AddonNotificationsHelper } from '../notifications-helper';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler for non-messaging push notifications clicks.\n */\nexport class AddonNotificationsPushClickHandlerService {\n  constructor() {\n    this.name = 'AddonNotificationsPushClickHandler';\n    this.priority = 0; // Low priority so it's used as a fallback if no other handler treats the notification.\n    this.featureName = 'CoreMainMenuDelegate_AddonNotifications';\n  }\n  /**\n   * Check if a notification click is handled by this handler.\n   *\n   * @param notification The notification to check.\n   * @returns Whether the notification click is handled by this handler\n   */\n  handles(notification) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!notification.moodlecomponent) {\n        // The notification doesn't come from Moodle. Handle it.\n        return true;\n      }\n      if (CoreUtils.isTrueOrOne(notification.notif)) {\n        // Notification clicked, mark as read. Don't block for this.\n        _this.markAsRead(notification);\n        return true;\n      }\n      return false;\n    })();\n  }\n  /**\n   * Mark the notification as read.\n   *\n   * @param notification Notification to mark.\n   * @returns Promise resolved when done.\n   */\n  markAsRead(notification) {\n    return _asyncToGenerator(function* () {\n      yield CoreUtils.ignoreErrors(AddonNotificationsHelper.markNotificationAsRead(notification));\n    })();\n  }\n  /**\n   * Handle the notification click.\n   *\n   * @param notification The notification to check.\n   * @returns Promise resolved when done.\n   */\n  handleClick(notification) {\n    return _asyncToGenerator(function* () {\n      var _notification$customd, _notification$customd2;\n      if ((_notification$customd = notification.customdata) !== null && _notification$customd !== void 0 && _notification$customd.extendedtext) {\n        // Display the text in a modal.\n        return CoreTextUtils.viewText(notification.title || '', notification.customdata.extendedtext, {\n          displayCopyButton: true,\n          modalOptions: {\n            cssClass: 'core-modal-fullscreen'\n          }\n        });\n      }\n      // Try to handle the appurl.\n      if ((_notification$customd2 = notification.customdata) !== null && _notification$customd2 !== void 0 && _notification$customd2.appurl) {\n        const url = notification.customdata.appurl;\n        switch (notification.customdata.appurlopenin) {\n          case 'inapp':\n            CoreUtils.openInApp(url);\n            return;\n          case 'browser':\n            return CoreUtils.openInBrowser(url);\n          default:\n            {\n              const treated = yield CoreContentLinksHelper.handleLink(url, undefined, undefined, true);\n              if (treated) {\n                // Link treated, stop.\n                return;\n              }\n            }\n        }\n      }\n      // No appurl or cannot be handled by the app. Try to handle the contexturl now.\n      if (notification.contexturl) {\n        const treated = yield CoreContentLinksHelper.handleLink(notification.contexturl);\n        if (treated) {\n          // Link treated, stop.\n          return;\n        }\n      }\n      // No contexturl or cannot be handled by the app. Open the notifications page.\n      yield CoreUtils.ignoreErrors(AddonNotifications.invalidateNotificationsList(notification.site));\n      yield CoreNavigator.navigateToSitePath(`${AddonNotificationsMainMenuHandlerService.PAGE_NAME}/list`, {\n        siteId: notification.site,\n        preferCurrentTab: false,\n        nextNavigation: {\n          path: '../notification',\n          options: {\n            params: {\n              notification\n            }\n          }\n        }\n      });\n    })();\n  }\n}\n_class = AddonNotificationsPushClickHandlerService;\n_class.ɵfac = function AddonNotificationsPushClickHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonNotificationsPushClickHandler = makeSingleton(AddonNotificationsPushClickHandlerService);","map":{"version":3,"names":["CoreNavigator","CoreTextUtils","CoreUtils","makeSingleton","CoreContentLinksHelper","AddonNotifications","AddonNotificationsMainMenuHandlerService","AddonNotificationsHelper","AddonNotificationsPushClickHandlerService","constructor","name","priority","featureName","handles","notification","_this","_asyncToGenerator","moodlecomponent","isTrueOrOne","notif","markAsRead","ignoreErrors","markNotificationAsRead","handleClick","_notification$customd","_notification$customd2","customdata","extendedtext","viewText","title","displayCopyButton","modalOptions","cssClass","appurl","url","appurlopenin","openInApp","openInBrowser","treated","handleLink","undefined","contexturl","invalidateNotificationsList","site","navigateToSitePath","PAGE_NAME","siteId","preferCurrentTab","nextNavigation","path","options","params","factory","ɵfac","providedIn","AddonNotificationsPushClickHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/notifications/services/handlers/push-click.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CorePushNotificationsClickHandler } from '@features/pushnotifications/services/push-delegate';\nimport { CorePushNotificationsNotificationBasicData } from '@features/pushnotifications/services/pushnotifications';\nimport { CoreContentLinksHelper } from '@features/contentlinks/services/contentlinks-helper';\nimport { AddonNotifications } from '../notifications';\nimport { AddonNotificationsMainMenuHandlerService } from './mainmenu';\nimport { AddonNotificationsHelper } from '../notifications-helper';\n\n/**\n * Handler for non-messaging push notifications clicks.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonNotificationsPushClickHandlerService implements CorePushNotificationsClickHandler {\n\n    name = 'AddonNotificationsPushClickHandler';\n    priority = 0; // Low priority so it's used as a fallback if no other handler treats the notification.\n    featureName = 'CoreMainMenuDelegate_AddonNotifications';\n\n    /**\n     * Check if a notification click is handled by this handler.\n     *\n     * @param notification The notification to check.\n     * @returns Whether the notification click is handled by this handler\n     */\n    async handles(notification: AddonNotificationsPushNotification): Promise<boolean> {\n        if (!notification.moodlecomponent) {\n            // The notification doesn't come from Moodle. Handle it.\n            return true;\n        }\n\n        if (CoreUtils.isTrueOrOne(notification.notif)) {\n            // Notification clicked, mark as read. Don't block for this.\n            this.markAsRead(notification);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Mark the notification as read.\n     *\n     * @param notification Notification to mark.\n     * @returns Promise resolved when done.\n     */\n    protected async markAsRead(notification: AddonNotificationsPushNotification): Promise<void> {\n        await CoreUtils.ignoreErrors(AddonNotificationsHelper.markNotificationAsRead(notification));\n    }\n\n    /**\n     * Handle the notification click.\n     *\n     * @param notification The notification to check.\n     * @returns Promise resolved when done.\n     */\n    async handleClick(notification: AddonNotificationsPushNotification): Promise<void> {\n\n        if (notification.customdata?.extendedtext) {\n            // Display the text in a modal.\n            return CoreTextUtils.viewText(notification.title || '', <string> notification.customdata.extendedtext, {\n                displayCopyButton: true,\n                modalOptions: { cssClass: 'core-modal-fullscreen' },\n            });\n        }\n\n        // Try to handle the appurl.\n        if (notification.customdata?.appurl) {\n            const url = <string> notification.customdata.appurl;\n\n            switch (notification.customdata.appurlopenin) {\n                case 'inapp':\n                    CoreUtils.openInApp(url);\n\n                    return;\n\n                case 'browser':\n                    return CoreUtils.openInBrowser(url);\n\n                default: {\n                    const treated = await CoreContentLinksHelper.handleLink(url, undefined, undefined, true);\n                    if (treated) {\n                        // Link treated, stop.\n                        return;\n                    }\n                }\n            }\n        }\n\n        // No appurl or cannot be handled by the app. Try to handle the contexturl now.\n        if (notification.contexturl) {\n            const treated = await CoreContentLinksHelper.handleLink(notification.contexturl);\n            if (treated) {\n                // Link treated, stop.\n                return;\n            }\n        }\n\n        // No contexturl or cannot be handled by the app. Open the notifications page.\n        await CoreUtils.ignoreErrors(AddonNotifications.invalidateNotificationsList(notification.site));\n\n        await CoreNavigator.navigateToSitePath(\n            `${AddonNotificationsMainMenuHandlerService.PAGE_NAME}/list`,\n            {\n                siteId: notification.site,\n                preferCurrentTab: false,\n                nextNavigation: {\n                    path: '../notification',\n                    options: {\n                        params: { notification },\n                    },\n                },\n            },\n        );\n    }\n\n}\n\nexport const AddonNotificationsPushClickHandler = makeSingleton(AddonNotificationsPushClickHandlerService);\n\nexport type AddonNotificationsPushNotification = CorePushNotificationsNotificationBasicData & {\n    contexturl?: string; // URL related to the notification.\n    savedmessageid?: number; // Notification ID (optional).\n    id?: number; // Notification ID (optional).\n    date?: string | number; // Notification date (timestamp). E.g. \"1669204700\".\n};\n"],"mappings":";;AAgBA,SAASA,aAAa,QAAQ,qBAAqB;AACnD,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,aAAa,QAAQ,aAAa;AAG3C,SAASC,sBAAsB,QAAQ,qDAAqD;AAC5F,SAASC,kBAAkB,QAAQ,kBAAkB;AACrD,SAASC,wCAAwC,QAAQ,YAAY;AACrE,SAASC,wBAAwB,QAAQ,yBAAyB;;AAElE;;;AAIA,OAAM,MAAOC,yCAAyC;EADtDC,YAAA;IAGI,KAAAC,IAAI,GAAG,oCAAoC;IAC3C,KAAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;IACd,KAAAC,WAAW,GAAG,yCAAyC;;EAEvD;;;;;;EAMMC,OAAOA,CAACC,YAAgD;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAC1D,IAAI,CAACF,YAAY,CAACG,eAAe,EAAE;QAC/B;QACA,OAAO,IAAI;;MAGf,IAAIf,SAAS,CAACgB,WAAW,CAACJ,YAAY,CAACK,KAAK,CAAC,EAAE;QAC3C;QACAJ,KAAI,CAACK,UAAU,CAACN,YAAY,CAAC;QAE7B,OAAO,IAAI;;MAGf,OAAO,KAAK;IAAC;EACjB;EAEA;;;;;;EAMgBM,UAAUA,CAACN,YAAgD;IAAA,OAAAE,iBAAA;MACvE,MAAMd,SAAS,CAACmB,YAAY,CAACd,wBAAwB,CAACe,sBAAsB,CAACR,YAAY,CAAC,CAAC;IAAC;EAChG;EAEA;;;;;;EAMMS,WAAWA,CAACT,YAAgD;IAAA,OAAAE,iBAAA;MAAA,IAAAQ,qBAAA,EAAAC,sBAAA;MAE9D,KAAAD,qBAAA,GAAIV,YAAY,CAACY,UAAU,cAAAF,qBAAA,eAAvBA,qBAAA,CAAyBG,YAAY,EAAE;QACvC;QACA,OAAO1B,aAAa,CAAC2B,QAAQ,CAACd,YAAY,CAACe,KAAK,IAAI,EAAE,EAAWf,YAAY,CAACY,UAAU,CAACC,YAAY,EAAE;UACnGG,iBAAiB,EAAE,IAAI;UACvBC,YAAY,EAAE;YAAEC,QAAQ,EAAE;UAAuB;SACpD,CAAC;;MAGN;MACA,KAAAP,sBAAA,GAAIX,YAAY,CAACY,UAAU,cAAAD,sBAAA,eAAvBA,sBAAA,CAAyBQ,MAAM,EAAE;QACjC,MAAMC,GAAG,GAAYpB,YAAY,CAACY,UAAU,CAACO,MAAM;QAEnD,QAAQnB,YAAY,CAACY,UAAU,CAACS,YAAY;UACxC,KAAK,OAAO;YACRjC,SAAS,CAACkC,SAAS,CAACF,GAAG,CAAC;YAExB;UAEJ,KAAK,SAAS;YACV,OAAOhC,SAAS,CAACmC,aAAa,CAACH,GAAG,CAAC;UAEvC;YAAS;cACL,MAAMI,OAAO,SAASlC,sBAAsB,CAACmC,UAAU,CAACL,GAAG,EAAEM,SAAS,EAAEA,SAAS,EAAE,IAAI,CAAC;cACxF,IAAIF,OAAO,EAAE;gBACT;gBACA;;;;;MAMhB;MACA,IAAIxB,YAAY,CAAC2B,UAAU,EAAE;QACzB,MAAMH,OAAO,SAASlC,sBAAsB,CAACmC,UAAU,CAACzB,YAAY,CAAC2B,UAAU,CAAC;QAChF,IAAIH,OAAO,EAAE;UACT;UACA;;;MAIR;MACA,MAAMpC,SAAS,CAACmB,YAAY,CAAChB,kBAAkB,CAACqC,2BAA2B,CAAC5B,YAAY,CAAC6B,IAAI,CAAC,CAAC;MAE/F,MAAM3C,aAAa,CAAC4C,kBAAkB,CAClC,GAAGtC,wCAAwC,CAACuC,SAAS,OAAO,EAC5D;QACIC,MAAM,EAAEhC,YAAY,CAAC6B,IAAI;QACzBI,gBAAgB,EAAE,KAAK;QACvBC,cAAc,EAAE;UACZC,IAAI,EAAE,iBAAiB;UACvBC,OAAO,EAAE;YACLC,MAAM,EAAE;cAAErC;YAAY;;;OAGjC,CACJ;IAAC;EACN;;SAtGSN,yCAAyC;;mBAAzCA,MAAyC;AAAA;;SAAzCA,MAAyC;EAAA4C,OAAA,EAAzC5C,MAAyC,CAAA6C,IAAA;EAAAC,UAAA,EAD5B;AAAM;AA2GhC,OAAO,MAAMC,kCAAkC,GAAGpD,aAAa,CAACK,yCAAyC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}