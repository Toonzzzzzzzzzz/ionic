{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile } from '@services/file';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils, OpenFileAction } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreConfig } from './config';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CorePlatform } from './platform';\nimport * as i0 from \"@angular/core\";\n/**\n * Provider to provide some helper functions regarding files and packages.\n */\nexport class CoreFileHelperProvider {\n  /**\n   * Check if the default behaviour of the app is open file with picker.\n   *\n   * @returns Boolean.\n   */\n  defaultIsOpenWithPicker() {\n    return CorePlatform.isIOS() && CoreConstants.CONFIG.iOSDefaultOpenFileAction === OpenFileAction.OPEN_WITH;\n  }\n  /**\n   * Convenience function to open a file, downloading it if needed.\n   *\n   * @param file The file to download.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param state The file's state. If not provided, it will be calculated.\n   * @param onProgress Function to call on progress.\n   * @param siteId The site ID. If not defined, current site.\n   * @param options Options to open the file.\n   * @returns Resolved on success.\n   */\n  downloadAndOpenFile(file, component, componentId, state, onProgress, siteId, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const fileUrl = CoreFileHelper.getFileUrl(file);\n      const timemodified = _this.getFileTimemodified(file);\n      if (!_this.isOpenableInApp(file)) {\n        yield _this.showConfirmOpenUnsupportedFile(false, file);\n      }\n      let url = yield _this.downloadFileIfNeeded(file, fileUrl, component, componentId, timemodified, state, onProgress, siteId, options);\n      if (!url) {\n        return;\n      }\n      if (!CoreUrlUtils.isLocalFileUrl(url)) {\n        /* In iOS, if we use the same URL in embedded browser and background download then the download only\n           downloads a few bytes (cached ones). Add a hash to the URL so both URLs are different. */\n        url = url + '#moodlemobile-embedded';\n        try {\n          yield CoreUtils.openOnlineFile(url);\n          return;\n        } catch (error) {\n          // Error opening the file, some apps don't allow opening online files.\n          if (!CoreFile.isAvailable()) {\n            throw error;\n          }\n          // Get the state.\n          if (!state) {\n            state = yield CoreFilepool.getFileStateByUrl(siteId, fileUrl, timemodified);\n          }\n          if (state == CoreConstants.DOWNLOADING) {\n            throw new CoreError(Translate.instant('core.erroropenfiledownloading'));\n          }\n          if (state === CoreConstants.NOT_DOWNLOADED) {\n            // File is not downloaded, download and then return the local URL.\n            url = yield _this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);\n          } else {\n            // File is outdated and can't be opened in online, return the local URL.\n            url = yield CoreFilepool.getInternalUrlByUrl(siteId, fileUrl);\n          }\n        }\n      }\n      return CoreUtils.openFile(url, options);\n    })();\n  }\n  /**\n   * Download a file if it needs to be downloaded.\n   *\n   * @param file The file to download.\n   * @param fileUrl The file URL.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param timemodified The time this file was modified.\n   * @param state The file's state. If not provided, it will be calculated.\n   * @param onProgress Function to call on progress.\n   * @param siteId The site ID. If not defined, current site.\n   * @param options Options to open the file.\n   * @returns Resolved with the URL to use on success.\n   */\n  downloadFileIfNeeded(file, fileUrl, component, componentId, timemodified, state, onProgress, siteId, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const site = yield CoreSites.getSite(siteId);\n      const fixedUrl = yield site.checkAndFixPluginfileURL(fileUrl);\n      if (!CoreFile.isAvailable()) {\n        // Use the online URL.\n        return fixedUrl;\n      }\n      if (!state) {\n        // Calculate the state.\n        state = yield CoreFilepool.getFileStateByUrl(siteId, fileUrl, timemodified);\n      }\n      // The file system is available.\n      const isWifi = CoreNetwork.isWifi();\n      const isOnline = CoreNetwork.isOnline();\n      if (state == CoreConstants.DOWNLOADED) {\n        // File is downloaded, get the local file URL.\n        return CoreFilepool.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, file);\n      } else {\n        if (!isOnline && !_this2.isStateDownloaded(state)) {\n          // Not downloaded and user is offline, reject.\n          throw new CoreNetworkError();\n        }\n        if (onProgress) {\n          // This call can take a while. Send a fake event to notify that we're doing some calculations.\n          onProgress({\n            calculating: true\n          });\n        }\n        const shouldDownloadFirst = yield CoreFilepool.shouldDownloadFileBeforeOpen(fixedUrl, file.filesize || 0, options);\n        if (shouldDownloadFirst) {\n          // Download the file first.\n          if (state == CoreConstants.DOWNLOADING) {\n            // It's already downloading, stop.\n            return fixedUrl;\n          }\n          // Download and then return the local URL.\n          return _this2.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);\n        }\n        // Start the download if in wifi, but return the URL right away so the file is opened.\n        if (isWifi) {\n          _this2.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);\n        }\n        if (!_this2.isStateDownloaded(state) || isOnline) {\n          // Not downloaded or online, return the online URL.\n          return fixedUrl;\n        } else {\n          // Outdated but offline, so we return the local URL.\n          return CoreFilepool.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, file);\n        }\n      }\n    })();\n  }\n  /**\n   * Download the file.\n   *\n   * @param fileUrl The file URL.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param timemodified The time this file was modified.\n   * @param onProgress Function to call on progress.\n   * @param file The file to download.\n   * @param siteId The site ID. If not defined, current site.\n   * @returns Resolved with internal URL on success, rejected otherwise.\n   */\n  downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Get the site and check if it can download files.\n      const site = yield CoreSites.getSite(siteId);\n      if (!site.canDownloadFiles()) {\n        throw new CoreError(Translate.instant('core.cannotdownloadfiles'));\n      }\n      try {\n        return yield CoreFilepool.downloadUrl(siteId, fileUrl, false, component, componentId, timemodified, onProgress, undefined, file);\n      } catch (error) {\n        // Download failed, check the state again to see if the file was downloaded before.\n        const state = yield CoreFilepool.getFileStateByUrl(siteId, fileUrl, timemodified);\n        if (_this3.isStateDownloaded(state)) {\n          return CoreFilepool.getInternalUrlByUrl(siteId, fileUrl);\n        } else {\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Get the file's URL.\n   *\n   * @param file The file.\n   * @returns File URL.\n   */\n  getFileUrl(file) {\n    return 'fileurl' in file ? file.fileurl : file.url;\n  }\n  /**\n   * Get the file's timemodified.\n   *\n   * @param file The file.\n   * @returns File modified timestamp, 0 if none.\n   */\n  getFileTimemodified(file) {\n    return file.timemodified || 0;\n  }\n  /**\n   * Check if a state is downloaded or outdated.\n   *\n   * @param state The state to check.\n   * @returns If file has been downloaded (or outdated).\n   */\n  isStateDownloaded(state) {\n    return state === CoreConstants.DOWNLOADED || state === CoreConstants.OUTDATED;\n  }\n  /**\n   * Whether the file has to be opened in browser.\n   *\n   * @param file The file to check.\n   * @returns Whether the file should be opened in browser.\n   */\n  shouldOpenInBrowser(file) {\n    if (!file.mimetype) {\n      return false;\n    }\n    const mimetype = file.mimetype;\n    if (!('isexternalfile' in file) || !file.isexternalfile) {\n      var _file$filename;\n      return mimetype === 'application/vnd.android.package-archive' || CoreMimetypeUtils.getFileExtension((_file$filename = file.filename) !== null && _file$filename !== void 0 ? _file$filename : '') === 'apk';\n    }\n    if (mimetype.indexOf('application/vnd.google-apps.') != -1) {\n      // Google Docs file, always open in browser.\n      return true;\n    }\n    if (file.repositorytype == 'onedrive') {\n      // In OneDrive, open in browser the office docs\n      return mimetype.indexOf('application/vnd.openxmlformats-officedocument') != -1 || mimetype == 'text/plain' || mimetype == 'document/unknown';\n    }\n    return false;\n  }\n  /**\n   * Calculate the total size of the given files.\n   *\n   * @param files The files to check.\n   * @returns Total files size.\n   */\n  getTotalFilesSize(files) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let totalSize = 0;\n      for (const file of files) {\n        totalSize += yield _this4.getFileSize(file);\n      }\n      return totalSize;\n    })();\n  }\n  /**\n   * Calculate the file size.\n   *\n   * @param file The file to check.\n   * @returns File size.\n   */\n  getFileSize(file) {\n    return _asyncToGenerator(function* () {\n      if ('filesize' in file && (file.filesize || file.filesize === 0)) {\n        return file.filesize;\n      }\n      // If it's a remote file. First check if we have the file downloaded since it's more reliable.\n      if ('filename' in file) {\n        const fileUrl = CoreFileHelper.getFileUrl(file);\n        try {\n          const siteId = CoreSites.getCurrentSiteId();\n          const path = yield CoreFilepool.getFilePathByUrl(siteId, fileUrl);\n          const fileEntry = yield CoreFile.getFile(path);\n          const fileObject = yield CoreFile.getFileObjectFromFileEntry(fileEntry);\n          return fileObject.size;\n        } catch (error) {\n          // Error getting the file, maybe it's not downloaded. Get remote size.\n          const size = yield CoreWS.getRemoteFileSize(fileUrl);\n          if (size === -1) {\n            throw new CoreError(`Couldn't determine file size: ${fileUrl}`);\n          }\n          return size;\n        }\n      }\n      // If it's a local file, get its size.\n      if ('name' in file) {\n        const fileObject = yield CoreFile.getFileObjectFromFileEntry(file);\n        return fileObject.size;\n      }\n      throw new CoreError('Couldn\\'t determine file size');\n    })();\n  }\n  /**\n   * Is the file openable in app.\n   *\n   * @param file The file to check.\n   * @returns bool.\n   */\n  isOpenableInApp(file) {\n    const regex = /(?:\\.([^.]+))?$/;\n    const regexResult = regex.exec(file.filename || file.name || '');\n    if (!regexResult || !regexResult[1]) {\n      // Couldn't find the extension. Assume it's openable.\n      return true;\n    }\n    return !this.isFileTypeExcludedInApp(regexResult[1]);\n  }\n  /**\n   * Show a confirm asking the user if we wants to open the file.\n   *\n   * @param onlyDownload Whether the user is only downloading the file, not opening it.\n   * @param file The file that will be opened.\n   * @returns Promise resolved if confirmed, rejected otherwise.\n   */\n  showConfirmOpenUnsupportedFile(onlyDownload = false, file) {\n    return _asyncToGenerator(function* () {\n      var _regexResult$;\n      file = file || {}; // Just in case some plugin doesn't pass it. This can be removed in the future, @since app 4.1.\n      // Check if the user decided not to see the warning.\n      const regex = /(?:\\.([^.]+))?$/;\n      const regexResult = regex.exec(file.filename || file.name || '');\n      const configKey = 'CoreFileUnsupportedWarningDisabled-' + ((_regexResult$ = regexResult === null || regexResult === void 0 ? void 0 : regexResult[1]) !== null && _regexResult$ !== void 0 ? _regexResult$ : 'unknown');\n      const dontShowWarning = yield CoreConfig.get(configKey, 0);\n      if (dontShowWarning) {\n        return;\n      }\n      const message = Translate.instant('core.cannotopeninapp' + (onlyDownload ? 'download' : ''));\n      const okButton = Translate.instant(onlyDownload ? 'core.downloadfile' : 'core.openfile');\n      try {\n        const dontShowAgain = yield CoreDomUtils.showPrompt(message, undefined, Translate.instant('core.dontshowagain'), 'checkbox', {\n          okText: okButton\n        }, {\n          cssClass: 'core-modal-force-on-top'\n        });\n        if (dontShowAgain) {\n          CoreConfig.set(configKey, 1);\n        }\n      } catch (_unused) {\n        // User canceled.\n        throw new CoreCanceledError('');\n      }\n    })();\n  }\n  /**\n   * Is the file type excluded to open in app.\n   *\n   * @param fileType The file to check.\n   * @returns If the file type is excluded in the app.\n   */\n  isFileTypeExcludedInApp(fileType) {\n    const currentSite = CoreSites.getCurrentSite();\n    const fileTypeExcludeList = currentSite === null || currentSite === void 0 ? void 0 : currentSite.getStoredConfig('tool_mobile_filetypeexclusionlist');\n    if (!fileTypeExcludeList) {\n      return false;\n    }\n    const regEx = new RegExp('(,|^)' + fileType + '(,|$)', 'g');\n    return !!fileTypeExcludeList.match(regEx);\n  }\n  /**\n   * Extract filename from the path.\n   *\n   * @param file The file.\n   * @returns The file name.\n   */\n  getFilenameFromPath(file) {\n    var _path$split$pop;\n    const path = CoreUtils.isFileEntry(file) ? file.fullPath : file.filepath;\n    if (path === undefined || path.length == 0) {\n      return;\n    }\n    return (_path$split$pop = path.split('\\\\').pop()) === null || _path$split$pop === void 0 ? void 0 : _path$split$pop.split('/').pop();\n  }\n}\n_class = CoreFileHelperProvider;\n_class.ɵfac = function CoreFileHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFileHelper = makeSingleton(CoreFileHelperProvider);","map":{"version":3,"names":["CoreNetwork","CoreFile","CoreFilepool","CoreSites","CoreWS","CoreDomUtils","CoreUrlUtils","CoreUtils","OpenFileAction","CoreConstants","CoreError","makeSingleton","Translate","CoreNetworkError","CoreConfig","CoreCanceledError","CoreMimetypeUtils","CorePlatform","CoreFileHelperProvider","defaultIsOpenWithPicker","isIOS","CONFIG","iOSDefaultOpenFileAction","OPEN_WITH","downloadAndOpenFile","file","component","componentId","state","onProgress","siteId","options","_this","_asyncToGenerator","getCurrentSiteId","fileUrl","CoreFileHelper","getFileUrl","timemodified","getFileTimemodified","isOpenableInApp","showConfirmOpenUnsupportedFile","url","downloadFileIfNeeded","isLocalFileUrl","openOnlineFile","error","isAvailable","getFileStateByUrl","DOWNLOADING","instant","NOT_DOWNLOADED","downloadFile","getInternalUrlByUrl","openFile","_this2","site","getSite","fixedUrl","checkAndFixPluginfileURL","isWifi","isOnline","DOWNLOADED","getUrlByUrl","isStateDownloaded","calculating","shouldDownloadFirst","shouldDownloadFileBeforeOpen","filesize","_this3","canDownloadFiles","downloadUrl","undefined","fileurl","OUTDATED","shouldOpenInBrowser","mimetype","isexternalfile","_file$filename","getFileExtension","filename","indexOf","repositorytype","getTotalFilesSize","files","_this4","totalSize","getFileSize","path","getFilePathByUrl","fileEntry","getFile","fileObject","getFileObjectFromFileEntry","size","getRemoteFileSize","regex","regexResult","exec","name","isFileTypeExcludedInApp","onlyDownload","_regexResult$","configKey","dontShowWarning","get","message","okButton","dontShowAgain","showPrompt","okText","cssClass","set","_unused","fileType","currentSite","getCurrentSite","fileTypeExcludeList","getStoredConfig","regEx","RegExp","match","getFilenameFromPath","_path$split$pop","isFileEntry","fullPath","filepath","length","split","pop","factory","ɵfac","providedIn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/file-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreFile } from '@services/file';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreWS, CoreWSFile } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils, CoreUtilsOpenFileOptions, OpenFileAction } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreConfig } from './config';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CorePlatform } from './platform';\n\n/**\n * Provider to provide some helper functions regarding files and packages.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFileHelperProvider {\n\n    /**\n     * Check if the default behaviour of the app is open file with picker.\n     *\n     * @returns Boolean.\n     */\n    defaultIsOpenWithPicker(): boolean {\n        return CorePlatform.isIOS() && CoreConstants.CONFIG.iOSDefaultOpenFileAction === OpenFileAction.OPEN_WITH;\n    }\n\n    /**\n     * Convenience function to open a file, downloading it if needed.\n     *\n     * @param file The file to download.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param state The file's state. If not provided, it will be calculated.\n     * @param onProgress Function to call on progress.\n     * @param siteId The site ID. If not defined, current site.\n     * @param options Options to open the file.\n     * @returns Resolved on success.\n     */\n    async downloadAndOpenFile(\n        file: CoreWSFile,\n        component?: string,\n        componentId?: string | number,\n        state?: string,\n        onProgress?: CoreFileHelperOnProgress,\n        siteId?: string,\n        options: CoreUtilsOpenFileOptions = {},\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const fileUrl = CoreFileHelper.getFileUrl(file);\n        const timemodified = this.getFileTimemodified(file);\n\n        if (!this.isOpenableInApp(file)) {\n            await this.showConfirmOpenUnsupportedFile(false, file);\n        }\n\n        let url = await this.downloadFileIfNeeded(\n            file,\n            fileUrl,\n            component,\n            componentId,\n            timemodified,\n            state,\n            onProgress,\n            siteId,\n            options,\n        );\n\n        if (!url) {\n            return;\n        }\n\n        if (!CoreUrlUtils.isLocalFileUrl(url)) {\n            /* In iOS, if we use the same URL in embedded browser and background download then the download only\n               downloads a few bytes (cached ones). Add a hash to the URL so both URLs are different. */\n            url = url + '#moodlemobile-embedded';\n\n            try {\n                await CoreUtils.openOnlineFile(url);\n\n                return;\n            } catch (error) {\n                // Error opening the file, some apps don't allow opening online files.\n                if (!CoreFile.isAvailable()) {\n                    throw error;\n                }\n\n                // Get the state.\n                if (!state) {\n                    state = await CoreFilepool.getFileStateByUrl(siteId, fileUrl, timemodified);\n                }\n\n                if (state == CoreConstants.DOWNLOADING) {\n                    throw new CoreError(Translate.instant('core.erroropenfiledownloading'));\n                }\n\n                if (state === CoreConstants.NOT_DOWNLOADED) {\n                    // File is not downloaded, download and then return the local URL.\n                    url = await this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);\n                } else {\n                    // File is outdated and can't be opened in online, return the local URL.\n                    url = await CoreFilepool.getInternalUrlByUrl(siteId, fileUrl);\n                }\n            }\n        }\n\n        return CoreUtils.openFile(url, options);\n    }\n\n    /**\n     * Download a file if it needs to be downloaded.\n     *\n     * @param file The file to download.\n     * @param fileUrl The file URL.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param timemodified The time this file was modified.\n     * @param state The file's state. If not provided, it will be calculated.\n     * @param onProgress Function to call on progress.\n     * @param siteId The site ID. If not defined, current site.\n     * @param options Options to open the file.\n     * @returns Resolved with the URL to use on success.\n     */\n    protected async downloadFileIfNeeded(\n        file: CoreWSFile,\n        fileUrl: string,\n        component?: string,\n        componentId?: string | number,\n        timemodified?: number,\n        state?: string,\n        onProgress?: CoreFileHelperOnProgress,\n        siteId?: string,\n        options: CoreUtilsOpenFileOptions = {},\n    ): Promise<string> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const site = await CoreSites.getSite(siteId);\n        const fixedUrl = await site.checkAndFixPluginfileURL(fileUrl);\n\n        if (!CoreFile.isAvailable()) {\n            // Use the online URL.\n            return fixedUrl;\n        }\n\n        if (!state) {\n            // Calculate the state.\n            state = await CoreFilepool.getFileStateByUrl(siteId, fileUrl, timemodified);\n        }\n\n        // The file system is available.\n        const isWifi = CoreNetwork.isWifi();\n        const isOnline = CoreNetwork.isOnline();\n\n        if (state == CoreConstants.DOWNLOADED) {\n            // File is downloaded, get the local file URL.\n            return CoreFilepool.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, file);\n        } else {\n            if (!isOnline && !this.isStateDownloaded(state)) {\n                // Not downloaded and user is offline, reject.\n                throw new CoreNetworkError();\n            }\n\n            if (onProgress) {\n                // This call can take a while. Send a fake event to notify that we're doing some calculations.\n                onProgress({ calculating: true });\n            }\n\n            const shouldDownloadFirst = await CoreFilepool.shouldDownloadFileBeforeOpen(fixedUrl, file.filesize || 0, options);\n            if (shouldDownloadFirst) {\n                // Download the file first.\n                if (state == CoreConstants.DOWNLOADING) {\n                    // It's already downloading, stop.\n                    return fixedUrl;\n                }\n\n                // Download and then return the local URL.\n                return this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);\n            }\n\n            // Start the download if in wifi, but return the URL right away so the file is opened.\n            if (isWifi) {\n                this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);\n            }\n\n            if (!this.isStateDownloaded(state) || isOnline) {\n                // Not downloaded or online, return the online URL.\n                return fixedUrl;\n            } else {\n                // Outdated but offline, so we return the local URL.\n                return CoreFilepool.getUrlByUrl(\n                    siteId,\n                    fileUrl,\n                    component,\n                    componentId,\n                    timemodified,\n                    false,\n                    false,\n                    file,\n                );\n            }\n        }\n    }\n\n    /**\n     * Download the file.\n     *\n     * @param fileUrl The file URL.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param timemodified The time this file was modified.\n     * @param onProgress Function to call on progress.\n     * @param file The file to download.\n     * @param siteId The site ID. If not defined, current site.\n     * @returns Resolved with internal URL on success, rejected otherwise.\n     */\n    async downloadFile(\n        fileUrl: string,\n        component?: string,\n        componentId?: string | number,\n        timemodified?: number,\n        onProgress?: (event: ProgressEvent) => void,\n        file?: CoreWSFile,\n        siteId?: string,\n    ): Promise<string> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Get the site and check if it can download files.\n        const site = await CoreSites.getSite(siteId);\n\n        if (!site.canDownloadFiles()) {\n            throw new CoreError(Translate.instant('core.cannotdownloadfiles'));\n        }\n\n        try {\n            return await CoreFilepool.downloadUrl(\n                siteId,\n                fileUrl,\n                false,\n                component,\n                componentId,\n                timemodified,\n                onProgress,\n                undefined,\n                file,\n            );\n        } catch (error) {\n            // Download failed, check the state again to see if the file was downloaded before.\n            const state = await CoreFilepool.getFileStateByUrl(siteId, fileUrl, timemodified);\n\n            if (this.isStateDownloaded(state)) {\n                return CoreFilepool.getInternalUrlByUrl(siteId, fileUrl);\n            } else {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Get the file's URL.\n     *\n     * @param file The file.\n     * @returns File URL.\n     */\n    getFileUrl(file: CoreWSFile): string {\n        return 'fileurl' in file ? file.fileurl : file.url;\n    }\n\n    /**\n     * Get the file's timemodified.\n     *\n     * @param file The file.\n     * @returns File modified timestamp, 0 if none.\n     */\n    getFileTimemodified(file: CoreWSFile): number {\n        return file.timemodified || 0;\n    }\n\n    /**\n     * Check if a state is downloaded or outdated.\n     *\n     * @param state The state to check.\n     * @returns If file has been downloaded (or outdated).\n     */\n    isStateDownloaded(state: string): boolean {\n        return state === CoreConstants.DOWNLOADED || state === CoreConstants.OUTDATED;\n    }\n\n    /**\n     * Whether the file has to be opened in browser.\n     *\n     * @param file The file to check.\n     * @returns Whether the file should be opened in browser.\n     */\n    shouldOpenInBrowser(file: CoreWSFile): boolean {\n        if (!file.mimetype) {\n            return false;\n        }\n\n        const mimetype = file.mimetype;\n\n        if (!('isexternalfile' in file) || !file.isexternalfile) {\n            return mimetype === 'application/vnd.android.package-archive'\n                || CoreMimetypeUtils.getFileExtension(file.filename ?? '') === 'apk';\n        }\n\n        if (mimetype.indexOf('application/vnd.google-apps.') != -1) {\n            // Google Docs file, always open in browser.\n            return true;\n        }\n\n        if (file.repositorytype == 'onedrive') {\n            // In OneDrive, open in browser the office docs\n            return mimetype.indexOf('application/vnd.openxmlformats-officedocument') != -1 ||\n                    mimetype == 'text/plain' || mimetype == 'document/unknown';\n        }\n\n        return false;\n    }\n\n    /**\n     * Calculate the total size of the given files.\n     *\n     * @param files The files to check.\n     * @returns Total files size.\n     */\n    async getTotalFilesSize(files: CoreFileEntry[]): Promise<number> {\n        let totalSize = 0;\n\n        for (const file of files) {\n            totalSize += await this.getFileSize(file);\n        }\n\n        return totalSize;\n    }\n\n    /**\n     * Calculate the file size.\n     *\n     * @param file The file to check.\n     * @returns File size.\n     */\n    async getFileSize(file: CoreFileEntry): Promise<number> {\n        if ('filesize' in file && (file.filesize || file.filesize === 0)) {\n            return file.filesize;\n        }\n\n        // If it's a remote file. First check if we have the file downloaded since it's more reliable.\n        if ('filename' in file) {\n            const fileUrl = CoreFileHelper.getFileUrl(file);\n\n            try {\n                const siteId = CoreSites.getCurrentSiteId();\n\n                const path = await CoreFilepool.getFilePathByUrl(siteId, fileUrl);\n                const fileEntry = await CoreFile.getFile(path);\n                const fileObject = await CoreFile.getFileObjectFromFileEntry(fileEntry);\n\n                return fileObject.size;\n            } catch (error) {\n                // Error getting the file, maybe it's not downloaded. Get remote size.\n                const size = await CoreWS.getRemoteFileSize(fileUrl);\n\n                if (size === -1) {\n                    throw new CoreError(`Couldn't determine file size: ${fileUrl}`);\n                }\n\n                return size;\n            }\n        }\n\n        // If it's a local file, get its size.\n        if ('name' in file) {\n            const fileObject = await CoreFile.getFileObjectFromFileEntry(file);\n\n            return fileObject.size;\n        }\n\n        throw new CoreError('Couldn\\'t determine file size');\n    }\n\n    /**\n     * Is the file openable in app.\n     *\n     * @param file The file to check.\n     * @returns bool.\n     */\n    isOpenableInApp(file: {filename?: string; name?: string}): boolean {\n        const regex = /(?:\\.([^.]+))?$/;\n        const regexResult = regex.exec(file.filename || file.name || '');\n\n        if (!regexResult || !regexResult[1]) {\n            // Couldn't find the extension. Assume it's openable.\n            return true;\n        }\n\n        return !this.isFileTypeExcludedInApp(regexResult[1]);\n    }\n\n    /**\n     * Show a confirm asking the user if we wants to open the file.\n     *\n     * @param onlyDownload Whether the user is only downloading the file, not opening it.\n     * @param file The file that will be opened.\n     * @returns Promise resolved if confirmed, rejected otherwise.\n     */\n    async showConfirmOpenUnsupportedFile(onlyDownload = false, file: {filename?: string; name?: string}): Promise<void> {\n        file = file || {}; // Just in case some plugin doesn't pass it. This can be removed in the future, @since app 4.1.\n\n        // Check if the user decided not to see the warning.\n        const regex = /(?:\\.([^.]+))?$/;\n        const regexResult = regex.exec(file.filename || file.name || '');\n\n        const configKey = 'CoreFileUnsupportedWarningDisabled-' + (regexResult?.[1] ?? 'unknown');\n        const dontShowWarning = await CoreConfig.get(configKey, 0);\n        if (dontShowWarning) {\n            return;\n        }\n\n        const message = Translate.instant('core.cannotopeninapp' + (onlyDownload ? 'download' : ''));\n        const okButton = Translate.instant(onlyDownload ? 'core.downloadfile' : 'core.openfile');\n\n        try {\n            const dontShowAgain = await CoreDomUtils.showPrompt(\n                message,\n                undefined,\n                Translate.instant('core.dontshowagain'),\n                'checkbox',\n                { okText: okButton },\n                { cssClass: 'core-modal-force-on-top' },\n            );\n\n            if (dontShowAgain) {\n                CoreConfig.set(configKey, 1);\n            }\n        } catch {\n            // User canceled.\n            throw new CoreCanceledError('');\n        }\n    }\n\n    /**\n     * Is the file type excluded to open in app.\n     *\n     * @param fileType The file to check.\n     * @returns If the file type is excluded in the app.\n     */\n    isFileTypeExcludedInApp(fileType: string): boolean {\n        const currentSite = CoreSites.getCurrentSite();\n        const fileTypeExcludeList = currentSite?.getStoredConfig('tool_mobile_filetypeexclusionlist');\n\n        if (!fileTypeExcludeList) {\n            return false;\n        }\n\n        const regEx = new RegExp('(,|^)' + fileType + '(,|$)', 'g');\n\n        return !!fileTypeExcludeList.match(regEx);\n    }\n\n    /**\n     * Extract filename from the path.\n     *\n     * @param file The file.\n     * @returns The file name.\n     */\n    getFilenameFromPath(file: CoreFileEntry): string | undefined {\n        const path = CoreUtils.isFileEntry(file) ? file.fullPath : file.filepath;\n\n        if (path === undefined || path.length == 0) {\n            return;\n        }\n\n        return path.split('\\\\').pop()?.split('/').pop();\n    }\n\n}\n\nexport const CoreFileHelper = makeSingleton(CoreFileHelperProvider);\n\nexport type CoreFileHelperOnProgress = (event?: ProgressEvent | { calculating: true }) => void;\n\nexport type CoreFileEntry = CoreWSFile | FileEntry;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}