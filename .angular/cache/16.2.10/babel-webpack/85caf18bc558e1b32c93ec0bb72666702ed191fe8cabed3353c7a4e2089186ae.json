{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreApp } from '@services/app';\nimport { CorePlatform } from '@services/platform';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreFileUploaderHelper } from '../fileuploader-helper';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to record a video to upload it.\n */\nexport class CoreFileUploaderVideoHandlerService {\n  constructor() {\n    this.name = 'CoreFileUploaderVideo';\n    this.priority = 1400;\n  }\n  /**\n   * Whether or not the handler is enabled on a site level.\n   *\n   * @returns Promise resolved with true if enabled.\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return CorePlatform.isMobile() || CoreApp.canGetUserMedia() && CoreApp.canRecordMedia();\n    })();\n  }\n  /**\n   * Given a list of mimetypes, return the ones that are supported by the handler.\n   *\n   * @param mimetypes List of mimetypes.\n   * @returns Supported mimetypes.\n   */\n  getSupportedMimetypes(mimetypes) {\n    if (CorePlatform.isIOS()) {\n      // In iOS it's recorded as MOV.\n      return CoreUtils.filterByRegexp(mimetypes, /^video\\/quicktime$/);\n    } else if (CorePlatform.isAndroid()) {\n      // In Android we don't know the format the video will be recorded, so accept any video mimetype.\n      return CoreUtils.filterByRegexp(mimetypes, /^video\\//);\n    } else {\n      // In browser, support video formats that are supported by MediaRecorder.\n      if (MediaRecorder) {\n        return mimetypes.filter(type => {\n          const matches = type.match(/^video\\//);\n          return (matches === null || matches === void 0 ? void 0 : matches.length) && MediaRecorder.isTypeSupported(type);\n        });\n      }\n    }\n    return [];\n  }\n  /**\n   * Get the data to display the handler.\n   *\n   * @returns Data.\n   */\n  getData() {\n    return {\n      title: 'core.fileuploader.video',\n      class: 'core-fileuploader-video-handler',\n      icon: 'videocam',\n      action: function () {\n        var _ref = _asyncToGenerator(function* (maxSize, upload, allowOffline, mimetypes) {\n          const result = yield CoreFileUploaderHelper.uploadAudioOrVideo(false, maxSize, upload, mimetypes);\n          return {\n            treated: true,\n            result: result\n          };\n        });\n        return function action(_x, _x2, _x3, _x4) {\n          return _ref.apply(this, arguments);\n        };\n      }()\n    };\n  }\n}\n_class = CoreFileUploaderVideoHandlerService;\n_class.ɵfac = function CoreFileUploaderVideoHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFileUploaderVideoHandler = makeSingleton(CoreFileUploaderVideoHandlerService);","map":{"version":3,"names":["CoreApp","CorePlatform","CoreUtils","makeSingleton","CoreFileUploaderHelper","CoreFileUploaderVideoHandlerService","constructor","name","priority","isEnabled","_asyncToGenerator","isMobile","canGetUserMedia","canRecordMedia","getSupportedMimetypes","mimetypes","isIOS","filterByRegexp","isAndroid","MediaRecorder","filter","type","matches","match","length","isTypeSupported","getData","title","class","icon","action","_ref","maxSize","upload","allowOffline","result","uploadAudioOrVideo","treated","_x","_x2","_x3","_x4","apply","arguments","factory","ɵfac","providedIn","CoreFileUploaderVideoHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/fileuploader/services/handlers/video.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreApp } from '@services/app';\nimport { CorePlatform } from '@services/platform';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreFileUploaderHandler, CoreFileUploaderHandlerData, CoreFileUploaderHandlerResult } from '../fileuploader-delegate';\nimport { CoreFileUploaderHelper } from '../fileuploader-helper';\n/**\n * Handler to record a video to upload it.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFileUploaderVideoHandlerService implements CoreFileUploaderHandler {\n\n    name = 'CoreFileUploaderVideo';\n    priority = 1400;\n\n    /**\n     * Whether or not the handler is enabled on a site level.\n     *\n     * @returns Promise resolved with true if enabled.\n     */\n    async isEnabled(): Promise<boolean> {\n        return CorePlatform.isMobile() || (CoreApp.canGetUserMedia() && CoreApp.canRecordMedia());\n    }\n\n    /**\n     * Given a list of mimetypes, return the ones that are supported by the handler.\n     *\n     * @param mimetypes List of mimetypes.\n     * @returns Supported mimetypes.\n     */\n    getSupportedMimetypes(mimetypes: string[]): string[] {\n        if (CorePlatform.isIOS()) {\n            // In iOS it's recorded as MOV.\n            return CoreUtils.filterByRegexp(mimetypes, /^video\\/quicktime$/);\n        } else if (CorePlatform.isAndroid()) {\n            // In Android we don't know the format the video will be recorded, so accept any video mimetype.\n            return CoreUtils.filterByRegexp(mimetypes, /^video\\//);\n        } else {\n            // In browser, support video formats that are supported by MediaRecorder.\n            if (MediaRecorder) {\n                return mimetypes.filter((type) => {\n                    const matches = type.match(/^video\\//);\n\n                    return matches?.length && MediaRecorder.isTypeSupported(type);\n                });\n            }\n        }\n\n        return [];\n    }\n\n    /**\n     * Get the data to display the handler.\n     *\n     * @returns Data.\n     */\n    getData(): CoreFileUploaderHandlerData {\n        return {\n            title: 'core.fileuploader.video',\n            class: 'core-fileuploader-video-handler',\n            icon: 'videocam', // Cannot use font-awesome in action sheet.\n            action: async (\n                maxSize?: number,\n                upload?: boolean,\n                allowOffline?: boolean,\n                mimetypes?: string[],\n            ): Promise<CoreFileUploaderHandlerResult> => {\n                const result = await CoreFileUploaderHelper.uploadAudioOrVideo(false, maxSize, upload, mimetypes);\n\n                return {\n                    treated: true,\n                    result: result,\n                };\n            },\n        };\n    }\n\n}\n\nexport const CoreFileUploaderVideoHandler = makeSingleton(CoreFileUploaderVideoHandlerService);\n"],"mappings":";;AAgBA,SAASA,OAAO,QAAQ,eAAe;AACvC,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,aAAa,QAAQ,aAAa;AAE3C,SAASC,sBAAsB,QAAQ,wBAAwB;;AAC/D;;;AAIA,OAAM,MAAOC,mCAAmC;EADhDC,YAAA;IAGI,KAAAC,IAAI,GAAG,uBAAuB;IAC9B,KAAAC,QAAQ,GAAG,IAAI;;EAEf;;;;;EAKMC,SAASA,CAAA;IAAA,OAAAC,iBAAA;MACX,OAAOT,YAAY,CAACU,QAAQ,EAAE,IAAKX,OAAO,CAACY,eAAe,EAAE,IAAIZ,OAAO,CAACa,cAAc,EAAG;IAAC;EAC9F;EAEA;;;;;;EAMAC,qBAAqBA,CAACC,SAAmB;IACrC,IAAId,YAAY,CAACe,KAAK,EAAE,EAAE;MACtB;MACA,OAAOd,SAAS,CAACe,cAAc,CAACF,SAAS,EAAE,oBAAoB,CAAC;KACnE,MAAM,IAAId,YAAY,CAACiB,SAAS,EAAE,EAAE;MACjC;MACA,OAAOhB,SAAS,CAACe,cAAc,CAACF,SAAS,EAAE,UAAU,CAAC;KACzD,MAAM;MACH;MACA,IAAII,aAAa,EAAE;QACf,OAAOJ,SAAS,CAACK,MAAM,CAAEC,IAAI,IAAI;UAC7B,MAAMC,OAAO,GAAGD,IAAI,CAACE,KAAK,CAAC,UAAU,CAAC;UAEtC,OAAO,CAAAD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEE,MAAM,KAAIL,aAAa,CAACM,eAAe,CAACJ,IAAI,CAAC;QACjE,CAAC,CAAC;;;IAIV,OAAO,EAAE;EACb;EAEA;;;;;EAKAK,OAAOA,CAAA;IACH,OAAO;MACHC,KAAK,EAAE,yBAAyB;MAChCC,KAAK,EAAE,iCAAiC;MACxCC,IAAI,EAAE,UAAU;MAChBC,MAAM;QAAA,IAAAC,IAAA,GAAArB,iBAAA,CAAE,WACJsB,OAAgB,EAChBC,MAAgB,EAChBC,YAAsB,EACtBnB,SAAoB,EACoB;UACxC,MAAMoB,MAAM,SAAS/B,sBAAsB,CAACgC,kBAAkB,CAAC,KAAK,EAAEJ,OAAO,EAAEC,MAAM,EAAElB,SAAS,CAAC;UAEjG,OAAO;YACHsB,OAAO,EAAE,IAAI;YACbF,MAAM,EAAEA;WACX;QACL,CAAC;QAAA,gBAAAL,OAAAQ,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;UAAA,OAAAV,IAAA,CAAAW,KAAA,OAAAC,SAAA;QAAA;MAAA;KACJ;EACL;;SAjEStC,mCAAmC;;mBAAnCA,MAAmC;AAAA;;SAAnCA,MAAmC;EAAAuC,OAAA,EAAnCvC,MAAmC,CAAAwC,IAAA;EAAAC,UAAA,EADtB;AAAM;AAsEhC,OAAO,MAAMC,4BAA4B,GAAG5C,aAAa,CAACE,mCAAmC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}