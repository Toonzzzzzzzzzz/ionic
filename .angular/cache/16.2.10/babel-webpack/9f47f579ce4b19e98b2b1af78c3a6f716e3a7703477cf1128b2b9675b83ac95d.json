{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreDelegate } from '@classes/delegate';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourses, CoreCoursesProvider } from '@features/courses/services/courses';\nimport { CoreCourseProvider } from './course';\nimport { makeSingleton } from '@singletons';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to interact with plugins to be shown in each course (participants, learning plans, ...).\n */\nexport class CoreCourseOptionsDelegateService extends CoreDelegate {\n  constructor() {\n    super('CoreCourseOptionsDelegate');\n    this.loaded = {};\n    this.lastUpdateHandlersForCoursesStart = {};\n    this.coursesHandlers = {};\n    this.featurePrefix = 'CoreCourseOptionsDelegate_';\n    CoreEvents.on(CoreEvents.LOGOUT, () => {\n      this.clearCoursesHandlers();\n    });\n  }\n  /**\n   * Check if handlers are loaded for a certain course.\n   *\n   * @param courseId The course ID to check.\n   * @returns True if handlers are loaded, false otherwise.\n   */\n  areHandlersLoaded(courseId) {\n    return !!this.loaded[courseId];\n  }\n  /**\n   * Clear all course options handlers.\n   *\n   * @param courseId The course ID. If not defined, all handlers will be cleared.\n   */\n  clearCoursesHandlers(courseId) {\n    if (courseId) {\n      if (!this.loaded[courseId]) {\n        // Don't clear if not loaded, it's probably an ongoing load and it could cause JS errors.\n        return;\n      }\n      this.loaded[courseId] = false;\n      delete this.coursesHandlers[courseId];\n    } else {\n      for (const courseId in this.coursesHandlers) {\n        this.clearCoursesHandlers(Number(courseId));\n      }\n    }\n  }\n  /**\n   * Clear all courses handlers and invalidate its options.\n   *\n   * @param courseId The course ID. If not defined, all handlers will be cleared.\n   * @returns Promise resolved when done.\n   */\n  clearAndInvalidateCoursesOptions(courseId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      CoreEvents.trigger(CoreCoursesProvider.EVENT_MY_COURSES_REFRESHED);\n      // Invalidate course enabled data for the handlers that are enabled at site level.\n      if (courseId) {\n        // Invalidate only options for this course.\n        promises.push(CoreCourses.invalidateCoursesAdminAndNavOptions([courseId]));\n        promises.push(_this.invalidateCourseHandlers(courseId));\n      } else {\n        // Invalidate all options.\n        promises.push(CoreCourses.invalidateUserNavigationOptions());\n        promises.push(CoreCourses.invalidateUserAdministrationOptions());\n        for (const cId in _this.coursesHandlers) {\n          promises.push(_this.invalidateCourseHandlers(parseInt(cId, 10)));\n        }\n      }\n      _this.clearCoursesHandlers(courseId);\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Get the handlers for a course using a certain access type.\n   *\n   * @param courseId The course ID.\n   * @param refresh True if it should refresh the list.\n   * @param accessData Access type and data. Default, guest, ...\n   * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n   * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n   * @returns Promise resolved with array of handlers.\n   */\n  getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // If the handlers aren't loaded, do not refresh.\n      if (!_this2.loaded[courseId]) {\n        refresh = false;\n      }\n      if (refresh || !_this2.coursesHandlers[courseId] || _this2.coursesHandlers[courseId].access.type != accessData.type) {\n        if (!_this2.coursesHandlers[courseId]) {\n          _this2.coursesHandlers[courseId] = {\n            access: accessData,\n            navOptions,\n            admOptions,\n            deferred: new CorePromisedValue(),\n            enabledHandlers: [],\n            enabledMenuHandlers: []\n          };\n        } else {\n          _this2.coursesHandlers[courseId].access = accessData;\n          _this2.coursesHandlers[courseId].navOptions = navOptions;\n          _this2.coursesHandlers[courseId].admOptions = admOptions;\n          _this2.coursesHandlers[courseId].deferred = new CorePromisedValue();\n        }\n        _this2.updateHandlersForCourse(courseId, accessData, navOptions, admOptions);\n      }\n      yield _this2.coursesHandlers[courseId].deferred;\n      return _this2.coursesHandlers[courseId].enabledHandlers;\n    })();\n  }\n  /**\n   * Get the list of handlers that should be displayed for a course.\n   * This function should be called only when the handlers need to be displayed, since it can call several WebServices.\n   *\n   * @param course The course object.\n   * @param refresh True if it should refresh the list.\n   * @param isGuest Whether user is using an ACCESS_GUEST enrolment method.\n   * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n   * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n   * @returns Promise resolved with array of handlers.\n   */\n  getHandlersToDisplay(course, refresh = false, isGuest = false, navOptions, admOptions) {\n    return this.getHandlersToDisplayInternal(false, course, refresh, isGuest, navOptions, admOptions);\n  }\n  /**\n   * Get the list of menu handlers that should be displayed for a course.\n   * This function should be called only when the handlers need to be displayed, since it can call several WebServices.\n   *\n   * @param course The course object.\n   * @param refresh True if it should refresh the list.\n   * @param isGuest Whether user is using an ACCESS_GUEST enrolment method.\n   * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n   * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n   * @returns Promise resolved with array of handlers.\n   */\n  getMenuHandlersToDisplay(course, refresh = false, isGuest = false, navOptions, admOptions) {\n    return this.getHandlersToDisplayInternal(true, course, refresh, isGuest, navOptions, admOptions);\n  }\n  /**\n   * Get the list of menu handlers that should be displayed for a course.\n   * This function should be called only when the handlers need to be displayed, since it can call several WebServices.\n   *\n   * @param menu If true, gets menu handlers; false, gets tab handlers\n   * @param course The course object.\n   * @param refresh True if it should refresh the list.\n   * @param isGuest Whether user is using an ACCESS_GUEST enrolment method.\n   * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n   * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n   * @returns Promise resolved with array of handlers.\n   */\n  getHandlersToDisplayInternal(menu, course, refresh = false, isGuest = false, navOptions, admOptions) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const courseWithOptions = course;\n      const accessData = {\n        type: isGuest ? CoreCourseProvider.ACCESS_GUEST : CoreCourseProvider.ACCESS_DEFAULT\n      };\n      const handlersToDisplay = [];\n      if (navOptions) {\n        courseWithOptions.navOptions = navOptions;\n      }\n      if (admOptions) {\n        courseWithOptions.admOptions = admOptions;\n      }\n      yield _this3.loadCourseOptions(courseWithOptions, refresh);\n      // Call getHandlersForAccess to make sure the handlers have been loaded.\n      yield _this3.getHandlersForAccess(course.id, refresh, accessData, courseWithOptions.navOptions, courseWithOptions.admOptions);\n      const promises = [];\n      let handlerList;\n      if (menu) {\n        handlerList = _this3.coursesHandlers[course.id].enabledMenuHandlers;\n      } else {\n        handlerList = _this3.coursesHandlers[course.id].enabledHandlers;\n      }\n      handlerList.forEach(handler => {\n        const getFunction = menu ? handler.getMenuDisplayData : handler.getDisplayData;\n        if (!getFunction) {\n          return;\n        }\n        promises.push(Promise.resolve(getFunction.call(handler, courseWithOptions)).then(data => {\n          handlersToDisplay.push({\n            data: data,\n            priority: handler.priority || 0,\n            prefetch: function () {\n              var _ref = _asyncToGenerator(function* (course) {\n                var _handler$prefetch;\n                return yield (_handler$prefetch = handler.prefetch) === null || _handler$prefetch === void 0 ? void 0 : _handler$prefetch.call(handler, course);\n              });\n              return function prefetch(_x) {\n                return _ref.apply(this, arguments);\n              };\n            }(),\n            name: handler.name\n          });\n          return;\n        }).catch(err => {\n          _this3.logger.error('Error getting data for handler', handler.name, err);\n        }));\n      });\n      yield Promise.all(promises);\n      // Sort them by priority.\n      handlersToDisplay.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n      return handlersToDisplay;\n    })();\n  }\n  /**\n   * Check if a course has any handler enabled for default access, using course object.\n   *\n   * @param course The course object.\n   * @param refresh True if it should refresh the list.\n   * @returns Promise resolved with boolean: true if it has handlers, false otherwise.\n   */\n  hasHandlersForCourse(course, refresh = false) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Load course options if missing.\n      yield _this4.loadCourseOptions(course, refresh);\n      return _this4.hasHandlersForDefault(course.id, refresh, course.navOptions, course.admOptions);\n    })();\n  }\n  /**\n   * Check if a course has any handler enabled for default access.\n   *\n   * @param courseId The course ID.\n   * @param refresh True if it should refresh the list.\n   * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n   * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n   * @returns Promise resolved with boolean: true if it has handlers, false otherwise.\n   */\n  hasHandlersForDefault(courseId, refresh = false, navOptions, admOptions) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      // Default access.\n      const accessData = {\n        type: CoreCourseProvider.ACCESS_DEFAULT\n      };\n      const handlers = yield _this5.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions);\n      return !!(handlers && handlers.length);\n    })();\n  }\n  /**\n   * Check if a course has any handler enabled for guest access.\n   *\n   * @param courseId The course ID.\n   * @param refresh True if it should refresh the list.\n   * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n   * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n   * @returns Promise resolved with boolean: true if it has handlers, false otherwise.\n   */\n  hasHandlersForGuest(courseId, refresh = false, navOptions, admOptions) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // Guest access.\n      const accessData = {\n        type: CoreCourseProvider.ACCESS_GUEST\n      };\n      const handlers = yield _this6.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions);\n      return !!(handlers && handlers.length);\n    })();\n  }\n  /**\n   * Invalidate the data to be able to determine if handlers are enabled for a certain course.\n   *\n   * @param courseId Course ID.\n   * @returns Promise resolved when done.\n   */\n  invalidateCourseHandlers(courseId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      const courseData = _this7.coursesHandlers[courseId];\n      if (!courseData || !courseData.enabledHandlers) {\n        return;\n      }\n      courseData.enabledHandlers.forEach(handler => {\n        if (handler !== null && handler !== void 0 && handler.invalidateEnabledForCourse) {\n          promises.push(handler.invalidateEnabledForCourse(courseId, courseData.navOptions, courseData.admOptions));\n        }\n      });\n      yield CoreUtils.allPromises(promises);\n    })();\n  }\n  /**\n   * Check if a time belongs to the last update handlers for course call.\n   * This is to handle the cases where updateHandlersForCourse don't finish in the same order as they're called.\n   *\n   * @param courseId Course ID.\n   * @param time Time to check.\n   * @returns Whether it's the last call.\n   */\n  isLastUpdateCourseCall(courseId, time) {\n    if (!this.lastUpdateHandlersForCoursesStart[courseId]) {\n      return true;\n    }\n    return time == this.lastUpdateHandlersForCoursesStart[courseId];\n  }\n  /**\n   * Load course options if missing.\n   *\n   * @param course The course object.\n   * @param refresh True if it should refresh the list.\n   * @returns Promise resolved when done.\n   */\n  loadCourseOptions(course, refresh = false) {\n    return _asyncToGenerator(function* () {\n      if (course.navOptions === undefined || course.admOptions === undefined || refresh) {\n        const options = yield CoreCourses.getCoursesAdminAndNavOptions([course.id]);\n        course.navOptions = options.navOptions[course.id];\n        course.admOptions = options.admOptions[course.id];\n      }\n    })();\n  }\n  /**\n   * Update handlers for each course.\n   */\n  updateData() {\n    // Update handlers for all courses.\n    for (const courseId in this.coursesHandlers) {\n      const handler = this.coursesHandlers[courseId];\n      this.updateHandlersForCourse(parseInt(courseId, 10), handler.access, handler.navOptions, handler.admOptions);\n    }\n  }\n  /**\n   * Update the handlers for a certain course.\n   *\n   * @param courseId The course ID.\n   * @param accessData Access type and data. Default, guest, ...\n   * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n   * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n   * @returns Resolved when updated.\n   */\n  updateHandlersForCourse(courseId, accessData, navOptions, admOptions) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      const enabledForCourse = [];\n      const enabledForCourseMenu = [];\n      const siteId = CoreSites.getCurrentSiteId();\n      const now = Date.now();\n      _this8.lastUpdateHandlersForCoursesStart[courseId] = now;\n      for (const name in _this8.enabledHandlers) {\n        const handler = _this8.enabledHandlers[name];\n        // Checks if the handler is enabled for the user.\n        promises.push(Promise.resolve(handler.isEnabledForCourse(courseId, accessData, navOptions, admOptions)).then(enabled => {\n          if (enabled) {\n            if (handler.isMenuHandler) {\n              enabledForCourseMenu.push(handler);\n            } else {\n              enabledForCourse.push(handler);\n            }\n          }\n          return;\n        }).catch(() => {\n          // Nothing to do here, it is not enabled for this user.\n        }));\n      }\n      try {\n        yield Promise.all(promises);\n      } catch (_unused) {\n        // Never fails.\n      }\n      // Verify that this call is the last one that was started.\n      // Check that site hasn't changed since the check started.\n      if (_this8.isLastUpdateCourseCall(courseId, now) && CoreSites.getCurrentSiteId() === siteId) {\n        // Update the coursesHandlers array with the new enabled addons.\n        _this8.coursesHandlers[courseId].enabledHandlers = enabledForCourse;\n        _this8.coursesHandlers[courseId].enabledMenuHandlers = enabledForCourseMenu;\n        _this8.loaded[courseId] = true;\n        // Resolve the promise.\n        _this8.coursesHandlers[courseId].deferred.resolve();\n      }\n    })();\n  }\n}\n_class = CoreCourseOptionsDelegateService;\n_class.ɵfac = function CoreCourseOptionsDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCourseOptionsDelegate = makeSingleton(CoreCourseOptionsDelegateService);","map":{"version":3,"names":["CoreDelegate","CoreEvents","CoreSites","CoreUtils","CoreCourses","CoreCoursesProvider","CoreCourseProvider","makeSingleton","CorePromisedValue","CoreCourseOptionsDelegateService","constructor","loaded","lastUpdateHandlersForCoursesStart","coursesHandlers","featurePrefix","on","LOGOUT","clearCoursesHandlers","areHandlersLoaded","courseId","Number","clearAndInvalidateCoursesOptions","_this","_asyncToGenerator","promises","trigger","EVENT_MY_COURSES_REFRESHED","push","invalidateCoursesAdminAndNavOptions","invalidateCourseHandlers","invalidateUserNavigationOptions","invalidateUserAdministrationOptions","cId","parseInt","Promise","all","getHandlersForAccess","refresh","accessData","navOptions","admOptions","_this2","access","type","deferred","enabledHandlers","enabledMenuHandlers","updateHandlersForCourse","getHandlersToDisplay","course","isGuest","getHandlersToDisplayInternal","getMenuHandlersToDisplay","menu","_this3","courseWithOptions","ACCESS_GUEST","ACCESS_DEFAULT","handlersToDisplay","loadCourseOptions","id","handlerList","forEach","handler","getFunction","getMenuDisplayData","getDisplayData","resolve","call","then","data","priority","prefetch","_ref","_handler$prefetch","_x","apply","arguments","name","catch","err","logger","error","sort","a","b","hasHandlersForCourse","_this4","hasHandlersForDefault","_this5","handlers","length","hasHandlersForGuest","_this6","_this7","courseData","invalidateEnabledForCourse","allPromises","isLastUpdateCourseCall","time","undefined","options","getCoursesAdminAndNavOptions","updateData","_this8","enabledForCourse","enabledForCourseMenu","siteId","getCurrentSiteId","now","Date","isEnabledForCourse","enabled","isMenuHandler","_unused","factory","ɵfac","providedIn","CoreCourseOptionsDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/services/course-options-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreDelegate, CoreDelegateHandler, CoreDelegateToDisplay } from '@classes/delegate';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport {\n    CoreCourseAnyCourseData,\n    CoreCourseAnyCourseDataWithOptions,\n    CoreCourses,\n    CoreCoursesProvider,\n    CoreCourseUserAdminOrNavOptionIndexed,\n} from '@features/courses/services/courses';\nimport { CoreCourseProvider } from './course';\nimport { Params } from '@angular/router';\nimport { makeSingleton } from '@singletons';\nimport { CoreEnrolledCourseDataWithExtraInfoAndOptions } from '@features/courses/services/courses-helper';\nimport { CorePromisedValue } from '@classes/promised-value';\n\n/**\n * Interface that all course options handlers must implement.\n */\nexport interface CoreCourseOptionsHandler extends CoreDelegateHandler {\n    /**\n     * The highest priority is displayed first.\n     */\n    priority: number;\n\n    /**\n     * True if this handler should appear in menu rather than as a tab.\n     */\n    isMenuHandler?: boolean;\n\n    /**\n     * Whether or not the handler is enabled for a certain course.\n     *\n     * @param courseId The course ID.\n     * @param accessData Access type and data. Default, guest, ...\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns True or promise resolved with true if enabled.\n     */\n    isEnabledForCourse(\n        courseId: number,\n        accessData: CoreCourseAccess,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): boolean | Promise<boolean>;\n\n    /**\n     * Returns the data needed to render the handler.\n     *\n     * @param course The course.\n     * @returns Data or promise resolved with the data.\n     */\n    getDisplayData?(\n        course: CoreCourseAnyCourseDataWithOptions,\n    ): CoreCourseOptionsHandlerData | Promise<CoreCourseOptionsHandlerData>;\n\n    /**\n     * Should invalidate the data to determine if the handler is enabled for a certain course.\n     *\n     * @param courseId The course ID.\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns Promise resolved when done.\n     */\n    invalidateEnabledForCourse?(\n        courseId: number,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<void>;\n\n    /**\n     * Called when a course is downloaded. It should prefetch all the data to be able to see the addon in offline.\n     *\n     * @param course The course.\n     * @returns Promise resolved when done.\n     */\n    prefetch?(course: CoreCourseAnyCourseData): Promise<void>;\n}\n\n/**\n * Interface that course options handlers implement if they appear in the menu rather than as a tab.\n */\nexport interface CoreCourseOptionsMenuHandler extends CoreCourseOptionsHandler {\n    /**\n     * Returns the data needed to render the handler.\n     *\n     * @param course The course.\n     * @returns Data or promise resolved with data.\n     */\n    getMenuDisplayData(\n        course: CoreCourseAnyCourseDataWithOptions,\n    ): CoreCourseOptionsMenuHandlerData | Promise<CoreCourseOptionsMenuHandlerData>;\n}\n\n/**\n * Data needed to render a course handler. It's returned by the handler.\n */\nexport interface CoreCourseOptionsHandlerData {\n    /**\n     * Title to display for the handler.\n     */\n    title: string;\n\n    /**\n     * Class to add to the displayed handler.\n     */\n    class?: string;\n\n    /**\n     * Path of the page to load for the handler.\n     */\n    page: string;\n\n    /**\n     * Params to pass to the page (other than 'courseId' which is always sent).\n     */\n    pageParams?: Params;\n}\n\n/**\n * Data needed to render a course menu handler. It's returned by the handler.\n */\nexport interface CoreCourseOptionsMenuHandlerData {\n    /**\n     * Title to display for the handler.\n     */\n    title: string;\n\n    /**\n     * Class to add to the displayed handler.\n     */\n    class?: string;\n\n    /**\n     * Path of the page to load for the handler.\n     */\n    page: string;\n\n    /**\n     * Params to pass to the page (other than 'course' which is always sent).\n     */\n    pageParams?: Params;\n\n    /**\n     * Name of the icon to display for the handler.\n     */\n    icon: string; // Name of the icon to display in the tab.\n}\n\n/**\n * Data returned by the delegate for each handler.\n */\nexport interface CoreCourseOptionsHandlerToDisplay extends CoreDelegateToDisplay {\n    /**\n     * Data to display.\n     */\n    data: CoreCourseOptionsHandlerData;\n\n    /**\n     * Called when a course is downloaded. It should prefetch all the data to be able to see the addon in offline.\n     *\n     * @param course The course.\n     * @returns Promise resolved when done.\n     */\n    prefetch?(course: CoreCourseAnyCourseData): Promise<void>;\n}\n\n/**\n * Additional data returned if it is a menu item.\n */\nexport interface CoreCourseOptionsMenuHandlerToDisplay {\n    /**\n     * Data to display.\n     */\n    data: CoreCourseOptionsMenuHandlerData;\n\n    /**\n     * Name of the handler, or name and sub context (AddonMessages, AddonMessages:blockContact, ...).\n     */\n    name: string;\n\n    /**\n     * The highest priority is displayed first.\n     */\n    priority?: number;\n\n    /**\n     * Called when a course is downloaded. It should prefetch all the data to be able to see the addon in offline.\n     *\n     * @param course The course.\n     * @returns Promise resolved when done.\n     */\n    prefetch?(course: CoreCourseAnyCourseData): Promise<void>;\n}\n\n/**\n * Service to interact with plugins to be shown in each course (participants, learning plans, ...).\n */\n@Injectable( { providedIn: 'root' })\nexport class CoreCourseOptionsDelegateService extends CoreDelegate<CoreCourseOptionsHandler> {\n\n    protected loaded: { [courseId: number]: boolean } = {};\n    protected lastUpdateHandlersForCoursesStart: {\n        [courseId: number]: number;\n    } = {};\n\n    protected coursesHandlers: {\n        [courseId: number]: {\n            access: CoreCourseAccess;\n            navOptions?: CoreCourseUserAdminOrNavOptionIndexed;\n            admOptions?: CoreCourseUserAdminOrNavOptionIndexed;\n            deferred: CorePromisedValue<void>;\n            enabledHandlers: CoreCourseOptionsHandler[];\n            enabledMenuHandlers: CoreCourseOptionsMenuHandler[];\n        };\n    } = {};\n\n    protected featurePrefix = 'CoreCourseOptionsDelegate_';\n\n    constructor() {\n        super('CoreCourseOptionsDelegate');\n\n        CoreEvents.on(CoreEvents.LOGOUT, () => {\n            this.clearCoursesHandlers();\n        });\n    }\n\n    /**\n     * Check if handlers are loaded for a certain course.\n     *\n     * @param courseId The course ID to check.\n     * @returns True if handlers are loaded, false otherwise.\n     */\n    areHandlersLoaded(courseId: number): boolean {\n        return !!this.loaded[courseId];\n    }\n\n    /**\n     * Clear all course options handlers.\n     *\n     * @param courseId The course ID. If not defined, all handlers will be cleared.\n     */\n    protected clearCoursesHandlers(courseId?: number): void {\n        if (courseId) {\n            if (!this.loaded[courseId]) {\n                // Don't clear if not loaded, it's probably an ongoing load and it could cause JS errors.\n                return;\n            }\n\n            this.loaded[courseId] = false;\n            delete this.coursesHandlers[courseId];\n        } else {\n            for (const courseId in this.coursesHandlers) {\n                this.clearCoursesHandlers(Number(courseId));\n            }\n        }\n    }\n\n    /**\n     * Clear all courses handlers and invalidate its options.\n     *\n     * @param courseId The course ID. If not defined, all handlers will be cleared.\n     * @returns Promise resolved when done.\n     */\n    async clearAndInvalidateCoursesOptions(courseId?: number): Promise<void> {\n        const promises: Promise<void>[] = [];\n\n        CoreEvents.trigger(CoreCoursesProvider.EVENT_MY_COURSES_REFRESHED);\n\n        // Invalidate course enabled data for the handlers that are enabled at site level.\n        if (courseId) {\n            // Invalidate only options for this course.\n            promises.push(CoreCourses.invalidateCoursesAdminAndNavOptions([courseId]));\n            promises.push(this.invalidateCourseHandlers(courseId));\n        } else {\n            // Invalidate all options.\n            promises.push(CoreCourses.invalidateUserNavigationOptions());\n            promises.push(CoreCourses.invalidateUserAdministrationOptions());\n\n            for (const cId in this.coursesHandlers) {\n                promises.push(this.invalidateCourseHandlers(parseInt(cId, 10)));\n            }\n        }\n\n        this.clearCoursesHandlers(courseId);\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Get the handlers for a course using a certain access type.\n     *\n     * @param courseId The course ID.\n     * @param refresh True if it should refresh the list.\n     * @param accessData Access type and data. Default, guest, ...\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns Promise resolved with array of handlers.\n     */\n    protected async getHandlersForAccess(\n        courseId: number,\n        refresh: boolean,\n        accessData: CoreCourseAccess,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<CoreCourseOptionsHandler[]> {\n\n        // If the handlers aren't loaded, do not refresh.\n        if (!this.loaded[courseId]) {\n            refresh = false;\n        }\n\n        if (refresh || !this.coursesHandlers[courseId] || this.coursesHandlers[courseId].access.type != accessData.type) {\n            if (!this.coursesHandlers[courseId]) {\n                this.coursesHandlers[courseId] = {\n                    access: accessData,\n                    navOptions,\n                    admOptions,\n                    deferred: new CorePromisedValue(),\n                    enabledHandlers: [],\n                    enabledMenuHandlers: [],\n                };\n            } else {\n                this.coursesHandlers[courseId].access = accessData;\n                this.coursesHandlers[courseId].navOptions = navOptions;\n                this.coursesHandlers[courseId].admOptions = admOptions;\n                this.coursesHandlers[courseId].deferred = new CorePromisedValue();\n            }\n\n            this.updateHandlersForCourse(courseId, accessData, navOptions, admOptions);\n        }\n\n        await this.coursesHandlers[courseId].deferred;\n\n        return this.coursesHandlers[courseId].enabledHandlers;\n    }\n\n    /**\n     * Get the list of handlers that should be displayed for a course.\n     * This function should be called only when the handlers need to be displayed, since it can call several WebServices.\n     *\n     * @param course The course object.\n     * @param refresh True if it should refresh the list.\n     * @param isGuest Whether user is using an ACCESS_GUEST enrolment method.\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns Promise resolved with array of handlers.\n     */\n    getHandlersToDisplay(\n        course: CoreCourseAnyCourseData,\n        refresh = false,\n        isGuest = false,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<CoreCourseOptionsHandlerToDisplay[]> {\n        return this.getHandlersToDisplayInternal(false, course, refresh, isGuest, navOptions, admOptions) as\n            Promise<CoreCourseOptionsHandlerToDisplay[]>;\n    }\n\n    /**\n     * Get the list of menu handlers that should be displayed for a course.\n     * This function should be called only when the handlers need to be displayed, since it can call several WebServices.\n     *\n     * @param course The course object.\n     * @param refresh True if it should refresh the list.\n     * @param isGuest Whether user is using an ACCESS_GUEST enrolment method.\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns Promise resolved with array of handlers.\n     */\n    getMenuHandlersToDisplay(\n        course: CoreCourseAnyCourseData,\n        refresh = false,\n        isGuest = false,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<CoreCourseOptionsMenuHandlerToDisplay[]> {\n        return this.getHandlersToDisplayInternal(true, course, refresh, isGuest, navOptions, admOptions) as\n            Promise<CoreCourseOptionsMenuHandlerToDisplay[]>;\n    }\n\n    /**\n     * Get the list of menu handlers that should be displayed for a course.\n     * This function should be called only when the handlers need to be displayed, since it can call several WebServices.\n     *\n     * @param menu If true, gets menu handlers; false, gets tab handlers\n     * @param course The course object.\n     * @param refresh True if it should refresh the list.\n     * @param isGuest Whether user is using an ACCESS_GUEST enrolment method.\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns Promise resolved with array of handlers.\n     */\n    protected async getHandlersToDisplayInternal(\n        menu: boolean,\n        course: CoreCourseAnyCourseData,\n        refresh = false,\n        isGuest = false,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<CoreCourseOptionsHandlerToDisplay[] | CoreCourseOptionsMenuHandlerToDisplay[]> {\n\n        const courseWithOptions: CoreCourseAnyCourseDataWithOptions = course;\n        const accessData = {\n            type: isGuest ? CoreCourseProvider.ACCESS_GUEST : CoreCourseProvider.ACCESS_DEFAULT,\n        };\n        const handlersToDisplay: CoreCourseOptionsHandlerToDisplay[] | CoreCourseOptionsMenuHandlerToDisplay[] = [];\n\n        if (navOptions) {\n            courseWithOptions.navOptions = navOptions;\n        }\n        if (admOptions) {\n            courseWithOptions.admOptions = admOptions;\n        }\n\n        await this.loadCourseOptions(courseWithOptions, refresh);\n\n        // Call getHandlersForAccess to make sure the handlers have been loaded.\n        await this.getHandlersForAccess(course.id, refresh, accessData, courseWithOptions.navOptions, courseWithOptions.admOptions);\n\n        const promises: Promise<void>[] = [];\n\n        let handlerList: CoreCourseOptionsMenuHandler[] | CoreCourseOptionsHandler[];\n        if (menu) {\n            handlerList = this.coursesHandlers[course.id].enabledMenuHandlers;\n        } else {\n            handlerList = this.coursesHandlers[course.id].enabledHandlers;\n        }\n\n        handlerList.forEach((handler: CoreCourseOptionsMenuHandler | CoreCourseOptionsHandler) => {\n            const getFunction = menu\n                ? (handler as CoreCourseOptionsMenuHandler).getMenuDisplayData\n                : (handler as CoreCourseOptionsHandler).getDisplayData;\n\n            if (!getFunction) {\n                return;\n            }\n\n            promises.push(Promise.resolve(getFunction.call(handler, courseWithOptions)).then((data) => {\n                handlersToDisplay.push({\n                    data: data,\n                    priority: handler.priority || 0,\n                    prefetch: async (course) => await handler.prefetch?.(course),\n                    name: handler.name,\n                });\n\n                return;\n            }).catch((err) => {\n                this.logger.error('Error getting data for handler', handler.name, err);\n            }));\n        });\n\n        await Promise.all(promises);\n\n        // Sort them by priority.\n        handlersToDisplay.sort((\n            a: CoreCourseOptionsHandlerToDisplay | CoreCourseOptionsMenuHandlerToDisplay,\n            b: CoreCourseOptionsHandlerToDisplay | CoreCourseOptionsMenuHandlerToDisplay,\n        ) => (b.priority || 0) - (a.priority || 0));\n\n        return handlersToDisplay;\n    }\n\n    /**\n     * Check if a course has any handler enabled for default access, using course object.\n     *\n     * @param course The course object.\n     * @param refresh True if it should refresh the list.\n     * @returns Promise resolved with boolean: true if it has handlers, false otherwise.\n     */\n    async hasHandlersForCourse(course: CoreEnrolledCourseDataWithExtraInfoAndOptions, refresh = false): Promise<boolean> {\n        // Load course options if missing.\n        await this.loadCourseOptions(course, refresh);\n\n        return this.hasHandlersForDefault(course.id, refresh, course.navOptions, course.admOptions);\n    }\n\n    /**\n     * Check if a course has any handler enabled for default access.\n     *\n     * @param courseId The course ID.\n     * @param refresh True if it should refresh the list.\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns Promise resolved with boolean: true if it has handlers, false otherwise.\n     */\n    async hasHandlersForDefault(\n        courseId: number,\n        refresh = false,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<boolean> {\n        // Default access.\n        const accessData = {\n            type: CoreCourseProvider.ACCESS_DEFAULT,\n        };\n\n        const handlers = await this.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions);\n\n        return !!(handlers && handlers.length);\n    }\n\n    /**\n     * Check if a course has any handler enabled for guest access.\n     *\n     * @param courseId The course ID.\n     * @param refresh True if it should refresh the list.\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns Promise resolved with boolean: true if it has handlers, false otherwise.\n     */\n    async hasHandlersForGuest(\n        courseId: number,\n        refresh = false,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<boolean> {\n        // Guest access.\n        const accessData = {\n            type: CoreCourseProvider.ACCESS_GUEST,\n        };\n\n        const handlers = await this.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions);\n\n        return !!(handlers && handlers.length);\n    }\n\n    /**\n     * Invalidate the data to be able to determine if handlers are enabled for a certain course.\n     *\n     * @param courseId Course ID.\n     * @returns Promise resolved when done.\n     */\n    async invalidateCourseHandlers(courseId: number): Promise<void> {\n        const promises: Promise<void>[] = [];\n        const courseData = this.coursesHandlers[courseId];\n\n        if (!courseData || !courseData.enabledHandlers) {\n            return;\n        }\n\n        courseData.enabledHandlers.forEach((handler) => {\n            if (handler?.invalidateEnabledForCourse) {\n                promises.push(\n                    handler.invalidateEnabledForCourse(courseId, courseData.navOptions, courseData.admOptions),\n                );\n            }\n        });\n\n        await CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Check if a time belongs to the last update handlers for course call.\n     * This is to handle the cases where updateHandlersForCourse don't finish in the same order as they're called.\n     *\n     * @param courseId Course ID.\n     * @param time Time to check.\n     * @returns Whether it's the last call.\n     */\n    isLastUpdateCourseCall(courseId: number, time: number): boolean {\n        if (!this.lastUpdateHandlersForCoursesStart[courseId]) {\n            return true;\n        }\n\n        return time == this.lastUpdateHandlersForCoursesStart[courseId];\n    }\n\n    /**\n     * Load course options if missing.\n     *\n     * @param course The course object.\n     * @param refresh True if it should refresh the list.\n     * @returns Promise resolved when done.\n     */\n    protected async loadCourseOptions(course: CoreCourseAnyCourseDataWithOptions, refresh = false): Promise<void> {\n        if (course.navOptions === undefined || course.admOptions === undefined || refresh) {\n\n            const options = await CoreCourses.getCoursesAdminAndNavOptions([course.id]);\n            course.navOptions = options.navOptions[course.id];\n            course.admOptions = options.admOptions[course.id];\n        }\n    }\n\n    /**\n     * Update handlers for each course.\n     */\n    updateData(): void {\n        // Update handlers for all courses.\n        for (const courseId in this.coursesHandlers) {\n            const handler = this.coursesHandlers[courseId];\n            this.updateHandlersForCourse(parseInt(courseId, 10), handler.access, handler.navOptions, handler.admOptions);\n        }\n    }\n\n    /**\n     * Update the handlers for a certain course.\n     *\n     * @param courseId The course ID.\n     * @param accessData Access type and data. Default, guest, ...\n     * @param navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.\n     * @param admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.\n     * @returns Resolved when updated.\n     */\n    async updateHandlersForCourse(\n        courseId: number,\n        accessData: CoreCourseAccess,\n        navOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n        admOptions?: CoreCourseUserAdminOrNavOptionIndexed,\n    ): Promise<void> {\n        const promises: Promise<void>[] = [];\n        const enabledForCourse: CoreCourseOptionsHandler[] = [];\n        const enabledForCourseMenu: CoreCourseOptionsMenuHandler[] = [];\n        const siteId = CoreSites.getCurrentSiteId();\n        const now = Date.now();\n\n        this.lastUpdateHandlersForCoursesStart[courseId] = now;\n\n        for (const name in this.enabledHandlers) {\n            const handler = this.enabledHandlers[name];\n\n            // Checks if the handler is enabled for the user.\n            promises.push(Promise.resolve(handler.isEnabledForCourse(courseId, accessData, navOptions, admOptions))\n                .then((enabled) => {\n                    if (enabled) {\n                        if (handler.isMenuHandler) {\n                            enabledForCourseMenu.push(<CoreCourseOptionsMenuHandler> handler);\n                        } else {\n                            enabledForCourse.push(handler);\n                        }\n                    }\n\n                    return;\n                }).catch(() => {\n                    // Nothing to do here, it is not enabled for this user.\n                }));\n        }\n\n        try {\n            await Promise.all(promises);\n        } catch {\n            // Never fails.\n        }\n\n        // Verify that this call is the last one that was started.\n        // Check that site hasn't changed since the check started.\n        if (this.isLastUpdateCourseCall(courseId, now) && CoreSites.getCurrentSiteId() === siteId) {\n            // Update the coursesHandlers array with the new enabled addons.\n            this.coursesHandlers[courseId].enabledHandlers = enabledForCourse;\n            this.coursesHandlers[courseId].enabledMenuHandlers = enabledForCourseMenu;\n            this.loaded[courseId] = true;\n\n            // Resolve the promise.\n            this.coursesHandlers[courseId].deferred.resolve();\n        }\n    }\n\n}\n\nexport const CoreCourseOptionsDelegate = makeSingleton(CoreCourseOptionsDelegateService);\n\nexport type CoreCourseAccess = {\n    type: string; // Either CoreCourseProvider.ACCESS_GUEST or CoreCourseProvider.ACCESS_DEFAULT.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}