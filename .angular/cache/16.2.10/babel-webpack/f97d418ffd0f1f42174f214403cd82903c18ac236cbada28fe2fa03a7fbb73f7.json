{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class, _class2;\nimport { File } from '@awesome-cordova-plugins/file/ngx';\nimport { CorePath } from '@singletons/path';\nimport * as i0 from \"@angular/core\";\n/**\n * Implement the File Error because the ionic-native plugin doesn't implement it.\n */\nclass FileError {\n  constructor(code) {\n    this.code = code;\n  }\n}\n/**\n * Emulates the Cordova File plugin in browser.\n * Most of the code is extracted from the File class of Ionic Native.\n */\n_class = FileError;\n_class.NOT_FOUND_ERR = 1;\n_class.SECURITY_ERR = 2;\n_class.ABORT_ERR = 3;\n_class.NOT_READABLE_ERR = 4;\n_class.ENCODING_ERR = 5;\n_class.NO_MODIFICATION_ALLOWED_ERR = 6;\n_class.INVALID_STATE_ERR = 7;\n_class.SYNTAX_ERR = 8;\n_class.INVALID_MODIFICATION_ERR = 9;\n_class.QUOTA_EXCEEDED_ERR = 10;\n_class.TYPE_MISMATCH_ERR = 11;\n_class.PATH_EXISTS_ERR = 12;\nexport class FileMock extends File {\n  /**\n   * Check if a directory exists in a certain path, directory.\n   *\n   * @param path Base FileSystem.\n   * @param dir Name of directory to check\n   * @returns Returns a Promise that resolves to true if the directory exists or rejects with an error.\n   */\n  checkDir(path, dir) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const fullPath = CorePath.concatenatePaths(path, dir);\n      yield _this.resolveDirectoryUrl(fullPath);\n      return true;\n    })();\n  }\n  /**\n   * Check if a file exists in a certain path, directory.\n   *\n   * @param path Base FileSystem.\n   * @param file Name of file to check.\n   * @returns Returns a Promise that resolves with a boolean or rejects with an error.\n   */\n  checkFile(path, file) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const entry = yield _this2.resolveLocalFilesystemUrl(CorePath.concatenatePaths(path, file));\n      if (entry.isFile) {\n        return true;\n      } else {\n        const error = new FileError(13);\n        error.message = 'input is not a file';\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Copy a file or directory.\n   *\n   * @param srce The Entry to copy.\n   * @param destDir The directory where to put the copy.\n   * @param newName New name of the file/dir.\n   * @returns Returns a Promise that resolves to the new Entry object or rejects with an error.\n   */\n  copyMock(srce, destDir, newName) {\n    return new Promise((resolve, reject) => {\n      newName = newName.replace(/%20/g, ' '); // Replace all %20 with spaces.\n      srce.copyTo(destDir, newName, deste => {\n        resolve(deste);\n      }, err => {\n        this.fillErrorMessageMock(err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Copy a directory in various methods. If destination directory exists, will fail to copy.\n   *\n   * @param path Base FileSystem. Please refer to the iOS and Android filesystems above.\n   * @param dirName Name of directory to copy.\n   * @param newPath Base FileSystem of new location.\n   * @param newDirName New name of directory to copy to (leave blank to remain the same).\n   * @returns Returns a Promise that resolves to the new Entry object or rejects with an error.\n   */\n  copyDir(path, dirName, newPath, newDirName) {\n    return this.copyFileOrDir(path, dirName, newPath, newDirName);\n  }\n  /**\n   * Copy a file in various methods. If file exists, will fail to copy.\n   *\n   * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n   * @param fileName Name of file to copy\n   * @param newPath Base FileSystem of new location\n   * @param newFileName New name of file to copy to (leave blank to remain the same)\n   * @returns Returns a Promise that resolves to an Entry or rejects with an error.\n   */\n  copyFile(path, fileName, newPath, newFileName) {\n    return this.copyFileOrDir(path, fileName, newPath, newFileName || fileName);\n  }\n  /**\n   * Copy a file or dir to a given path.\n   *\n   * @param sourcePath Path of the file/dir to copy.\n   * @param sourceName Name of file/dir to copy\n   * @param destPath Path where to copy.\n   * @param destName New name of file/dir.\n   * @returns Returns a Promise that resolves to the new Entry or rejects with an error.\n   */\n  copyFileOrDir(sourcePath, sourceName, destPath, destName) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const destFixed = _this3.fixPathAndName(destPath, destName);\n      const source = yield _this3.resolveLocalFilesystemUrl(CorePath.concatenatePaths(sourcePath, sourceName));\n      const destParentDir = yield _this3.resolveDirectoryUrl(destFixed.path);\n      return _this3.copyMock(source, destParentDir, destFixed.name);\n    })();\n  }\n  /**\n   * Creates a new directory in the specific path.\n   * The replace boolean value determines whether to replace an existing directory with the same name.\n   * If an existing directory exists and the replace value is false, the promise will fail and return an error.\n   *\n   * @param path Base FileSystem.\n   * @param dirName Name of directory to create\n   * @param replace If true, replaces file with same name. If false returns error\n   * @returns Returns a Promise that resolves with a DirectoryEntry or rejects with an error.\n   */\n  createDir(path, dirName, replace) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const options = {\n        create: true\n      };\n      if (!replace) {\n        options.exclusive = true;\n      }\n      const parentDir = yield _this4.resolveDirectoryUrl(path);\n      return _this4.getDirectory(parentDir, dirName, options);\n    })();\n  }\n  /**\n   * Creates a new file in the specific path.\n   * The replace boolean value determines whether to replace an existing file with the same name.\n   * If an existing file exists and the replace value is false, the promise will fail and return an error.\n   *\n   * @param path Base FileSystem.\n   * @param fileName Name of file to create.\n   * @param replace If true, replaces file with same name. If false returns error.\n   * @returns Returns a Promise that resolves to a FileEntry or rejects with an error.\n   */\n  createFile(path, fileName, replace) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const options = {\n        create: true\n      };\n      if (!replace) {\n        options.exclusive = true;\n      }\n      const parentDir = yield _this5.resolveDirectoryUrl(path);\n      return _this5.getFile(parentDir, fileName, options);\n    })();\n  }\n  /**\n   * Create a file writer for a certain file.\n   *\n   * @param fe File entry object.\n   * @returns Promise resolved with the FileWriter.\n   */\n  createWriterMock(fe) {\n    return new Promise((resolve, reject) => {\n      fe.createWriter(writer => {\n        resolve(writer);\n      }, err => {\n        this.fillErrorMessageMock(err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Fill the message for an error.\n   *\n   * @param error Error.\n   */\n  fillErrorMessageMock(error) {\n    try {\n      error.message = this.cordovaFileError[error.code];\n    } catch (e) {\n      // Ignore errors.\n    }\n  }\n  /**\n   * Get a directory.\n   *\n   * @param directoryEntry Directory entry, obtained by resolveDirectoryUrl method\n   * @param directoryName Directory name\n   * @param flags Options\n   * @returns Promise resolved with the directory entry.\n   */\n  getDirectory(directoryEntry, directoryName, flags) {\n    return new Promise((resolve, reject) => {\n      try {\n        directoryName = directoryName.replace(/%20/g, ' '); // Replace all %20 with spaces.\n        directoryEntry.getDirectory(directoryName, flags, de => {\n          resolve(de);\n        }, err => {\n          this.fillErrorMessageMock(err);\n          reject(err);\n        });\n      } catch (xc) {\n        this.fillErrorMessageMock(xc);\n        reject(xc);\n      }\n    });\n  }\n  /**\n   * Get a file.\n   *\n   * @param directoryEntry Directory entry, obtained by resolveDirectoryUrl method\n   * @param fileName File name\n   * @param flags Options\n   * @returns Promise resolved with the file entry.\n   */\n  getFile(directoryEntry, fileName, flags) {\n    return new Promise((resolve, reject) => {\n      try {\n        fileName = fileName.replace(/%20/g, ' '); // Replace all %20 with spaces.\n        directoryEntry.getFile(fileName, flags, resolve, err => {\n          this.fillErrorMessageMock(err);\n          reject(err);\n        });\n      } catch (xc) {\n        this.fillErrorMessageMock(xc);\n        reject(xc);\n      }\n    });\n  }\n  /**\n   * Get free disk space.\n   *\n   * @returns Promise resolved with the free space.\n   */\n  getFreeDiskSpace() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // Request a file system instance with a minimum size until we get an error.\n      const window = _this6.getEmulatorWindow();\n      if (!window.requestFileSystem) {\n        throw new Error('File system not available.');\n      }\n      let iterations = 0;\n      let maxIterations = 50;\n      const calculateByRequest = (size, ratio) => new Promise(resolve => {\n        window.requestFileSystem(LocalFileSystem.PERSISTENT, size, () => {\n          iterations++;\n          if (iterations > maxIterations) {\n            resolve(size);\n            return;\n          }\n          // eslint-disable-next-line promise/catch-or-return\n          calculateByRequest(size * ratio, ratio).then(resolve);\n        }, () => {\n          resolve(size / ratio);\n        });\n      });\n      // General calculation, base 1MB and increasing factor 1.3.\n      let size = yield calculateByRequest(1048576, 1.3);\n      // More accurate. Factor is 1.1.\n      iterations = 0;\n      maxIterations = 10;\n      size = yield calculateByRequest(size, 1.1);\n      return size / 1024; // Return size in KB.\n    })();\n  }\n  /**\n   * List files and directory from a given path.\n   *\n   * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n   * @param dirName Name of directory\n   * @returns Returns a Promise that resolves to an array of Entry objects or rejects with an error.\n   */\n  listDir(path, dirName) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const parentDir = yield _this7.resolveDirectoryUrl(path);\n      const dirEntry = yield _this7.getDirectory(parentDir, dirName, {\n        create: false,\n        exclusive: false\n      });\n      return _this7.readEntriesMock(dirEntry.createReader());\n    })();\n  }\n  /**\n   * Loads an initialize the API for browser.\n   *\n   * @returns Promise resolved when loaded.\n   */\n  load() {\n    return new Promise((resolve, reject) => {\n      const window = this.getEmulatorWindow();\n      if (window.requestFileSystem === undefined) {\n        window.requestFileSystem = window.webkitRequestFileSystem;\n      }\n      if (window.resolveLocalFileSystemURL === undefined) {\n        window.resolveLocalFileSystemURL = window.webkitResolveLocalFileSystemURL;\n      }\n      window.LocalFileSystem = {\n        TEMPORARY: 0,\n        PERSISTENT: 1 // eslint-disable-line @typescript-eslint/naming-convention\n      };\n      // Request a quota to use. Request 500MB.\n      this.getEmulatorNavigator().webkitPersistentStorage.requestQuota(500 * 1024 * 1024, granted => {\n        window.requestFileSystem(LocalFileSystem.PERSISTENT, granted, fileSystem => {\n          resolve(fileSystem.root.toURL());\n        }, reject);\n      }, reject);\n    });\n  }\n  /**\n   * Move a file or directory.\n   *\n   * @param srce The Entry to copy.\n   * @param destDir The directory where to move the file/dir.\n   * @param newName New name of the file/dir.\n   * @returns Returns a Promise that resolves to the new Entry object or rejects with an error.\n   */\n  moveMock(srce, destDir, newName) {\n    return new Promise((resolve, reject) => {\n      newName = newName.replace(/%20/g, ' '); // Replace all %20 with spaces.\n      srce.moveTo(destDir, newName, deste => {\n        resolve(deste);\n      }, err => {\n        this.fillErrorMessageMock(err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Move a directory to a given path.\n   *\n   * @param path The source path to the directory.\n   * @param dirName The source directory name.\n   * @param newPath The destionation path to the directory.\n   * @param newDirName The destination directory name.\n   * @returns Returns a Promise that resolves to the new DirectoryEntry object or rejects with\n   *         an error.\n   */\n  moveDir(path, dirName, newPath, newDirName) {\n    return this.moveFileOrDir(path, dirName, newPath, newDirName);\n  }\n  /**\n   * Move a file to a given path.\n   *\n   * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n   * @param fileName Name of file to move\n   * @param newPath Base FileSystem of new location\n   * @param newFileName New name of file to move to (leave blank to remain the same)\n   * @returns Returns a Promise that resolves to the new Entry or rejects with an error.\n   */\n  moveFile(path, fileName, newPath, newFileName) {\n    return this.moveFileOrDir(path, fileName, newPath, newFileName || fileName);\n  }\n  /**\n   * Move a file or dir to a given path.\n   *\n   * @param sourcePath Path of the file/dir to copy.\n   * @param sourceName Name of file/dir to copy\n   * @param destPath Path where to copy.\n   * @param destName New name of file/dir.\n   * @returns Returns a Promise that resolves to the new Entry or rejects with an error.\n   */\n  moveFileOrDir(sourcePath, sourceName, destPath, destName) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const destFixed = _this8.fixPathAndName(destPath, destName);\n      const source = yield _this8.resolveLocalFilesystemUrl(CorePath.concatenatePaths(sourcePath, sourceName));\n      const destParentDir = yield _this8.resolveDirectoryUrl(destFixed.path);\n      return _this8.moveMock(source, destParentDir, destFixed.name);\n    })();\n  }\n  /**\n   * Fix a path and name, making sure the name doesn't contain any folder. If it does, the folder will be moved to the path.\n   *\n   * @param path Path to fix.\n   * @param name Name to fix.\n   * @returns Fixed values.\n   */\n  fixPathAndName(path, name) {\n    const fullPath = CorePath.concatenatePaths(path, name);\n    return {\n      path: fullPath.substring(0, fullPath.lastIndexOf('/')),\n      name: fullPath.substring(fullPath.lastIndexOf('/') + 1)\n    };\n  }\n  /**\n   * Read file and return data as an ArrayBuffer.\n   *\n   * @param path Base FileSystem.\n   * @param file Name of file, relative to path.\n   * @returns Returns a Promise that resolves with the contents of the file as ArrayBuffer or rejects\n   *         with an error.\n   */\n  readAsArrayBuffer(path, file) {\n    return this.readFileMock(path, file, 'ArrayBuffer');\n  }\n  /**\n   * Read file and return data as a binary data.\n   *\n   * @param path Base FileSystem.\n   * @param file Name of file, relative to path.\n   * @returns Returns a Promise that resolves with the contents of the file as string rejects with an error.\n   */\n  readAsBinaryString(path, file) {\n    return this.readFileMock(path, file, 'BinaryString');\n  }\n  /**\n   * Read file and return data as a base64 encoded data url.\n   * A data url is of the form:\n   *      data: [<mediatype>][;base64],<data>\n   *\n   * @param path Base FileSystem.\n   * @param file Name of file, relative to path.\n   * @returns Returns a Promise that resolves with the contents of the file as data URL or rejects\n   *         with an error.\n   */\n  readAsDataURL(path, file) {\n    return this.readFileMock(path, file, 'DataURL');\n  }\n  /**\n   * Read the contents of a file as text.\n   *\n   * @param path Base FileSystem.\n   * @param file Name of file, relative to path.\n   * @returns Returns a Promise that resolves with the contents of the file as string or rejects with an error.\n   */\n  readAsText(path, file) {\n    return this.readFileMock(path, file, 'Text');\n  }\n  /**\n   * Read all the files and directories inside a directory.\n   *\n   * @param directoryReader The directory reader.\n   * @returns Promise resolved with the list of files/dirs.\n   */\n  readEntriesMock(directoryReader) {\n    return new Promise((resolve, reject) => {\n      directoryReader.readEntries(entries => {\n        resolve(entries);\n      }, error => {\n        this.fillErrorMessageMock(error);\n        reject(error);\n      });\n    });\n  }\n  /**\n   * Read the contents of a file.\n   *\n   * @param path Base FileSystem.\n   * @param file Name of file, relative to path.\n   * @param readAs Format to read as.\n   * @returns Returns a Promise that resolves with the contents of the file or rejects with an error.\n   */\n  readFileMock(path, file, readAs) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const directoryEntry = yield _this9.resolveDirectoryUrl(path);\n      const fileEntry = yield _this9.getFile(directoryEntry, file, {\n        create: false\n      });\n      const reader = new FileReader();\n      return new Promise((resolve, reject) => {\n        reader.onloadend = () => {\n          if (reader.result !== undefined || reader.result !== null) {\n            resolve(reader.result);\n          } else if (reader.error !== undefined || reader.error !== null) {\n            reject(reader.error);\n          } else {\n            reject({\n              code: null,\n              message: 'READER_ONLOADEND_ERR'\n            });\n          }\n        };\n        fileEntry.file(file => {\n          reader[`readAs${readAs}`].call(reader, file);\n        }, error => {\n          reject(error);\n        });\n      });\n    })();\n  }\n  /**\n   * Delete a file.\n   *\n   * @param entry The file to remove.\n   * @returns Promise resolved when done.\n   */\n  removeMock(entry) {\n    return new Promise((resolve, reject) => {\n      entry.remove(() => {\n        resolve({\n          success: true,\n          fileRemoved: entry\n        });\n      }, err => {\n        this.fillErrorMessageMock(err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Remove a directory at a given path.\n   *\n   * @param path The path to the directory.\n   * @param dirName The directory name.\n   * @returns Returns a Promise that resolves to a RemoveResult or rejects with an error.\n   */\n  removeDir(path, dirName) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const parentDir = yield _this10.resolveDirectoryUrl(path);\n      const dirEntry = yield _this10.getDirectory(parentDir, dirName, {\n        create: false\n      });\n      return _this10.removeMock(dirEntry);\n    })();\n  }\n  /**\n   * Removes a file from a desired location.\n   *\n   * @param path Base FileSystem.\n   * @param fileName Name of file to remove.\n   * @returns Returns a Promise that resolves to a RemoveResult or rejects with an error.\n   */\n  removeFile(path, fileName) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const parentDir = yield _this11.resolveDirectoryUrl(path);\n      const fileEntry = yield _this11.getFile(parentDir, fileName, {\n        create: false\n      });\n      return _this11.removeMock(fileEntry);\n    })();\n  }\n  /**\n   * Removes all files and the directory from a desired location.\n   *\n   * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n   * @param dirName Name of directory\n   * @returns Returns a Promise that resolves with a RemoveResult or rejects with an error.\n   */\n  removeRecursively(path, dirName) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const parentDir = yield _this12.resolveDirectoryUrl(path);\n      const dirEntry = yield _this12.getDirectory(parentDir, dirName, {\n        create: false\n      });\n      return _this12.rimrafMock(dirEntry);\n    })();\n  }\n  /**\n   * Resolves a local directory url.\n   *\n   * @param directoryUrl Directory system url.\n   * @returns Promise resolved with the file system Entry referred to by local URL\n   */\n  resolveDirectoryUrl(directoryUrl) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const dirEntry = yield _this13.resolveLocalFilesystemUrl(directoryUrl);\n      if (dirEntry.isDirectory) {\n        return dirEntry;\n      } else {\n        const error = new FileError(13);\n        error.message = 'input is not a directory';\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Resolves a local file system URL.\n   *\n   * @param fileUrl file system url.\n   * @returns Promise resolved with the file system Entry referred to by local URL\n   */\n  resolveLocalFilesystemUrl(fileUrl) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.getEmulatorWindow().resolveLocalFileSystemURL(fileUrl, entry => {\n          resolve(entry);\n        }, error => {\n          this.fillErrorMessageMock(error);\n          reject(error);\n        });\n      } catch (error) {\n        this.fillErrorMessageMock(error);\n        reject(error);\n      }\n    });\n  }\n  /**\n   * Remove a directory and all its contents.\n   *\n   * @param de Directory to remove.\n   * @returns Promise resolved when done.\n   */\n  rimrafMock(de) {\n    return new Promise((resolve, reject) => {\n      de.removeRecursively(() => {\n        resolve({\n          success: true,\n          fileRemoved: de\n        });\n      }, err => {\n        this.fillErrorMessageMock(err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Write some data in a file.\n   *\n   * @param writer File writer.\n   * @param data The data to write.\n   * @returns Promise resolved when done.\n   */\n  writeMock(writer, data) {\n    if (data instanceof Blob) {\n      return this.writeFileInChunksMock(writer, data);\n    }\n    if (data instanceof ArrayBuffer) {\n      // Convert to string.\n      data = String.fromCharCode.apply(null, new Uint8Array(data));\n    }\n    return new Promise((resolve, reject) => {\n      writer.onwriteend = () => {\n        if (writer.error) {\n          reject(writer.error);\n        } else {\n          resolve();\n        }\n      };\n      writer.write(data);\n    });\n  }\n  /**\n   * Write to an existing file.\n   *\n   * @param path Base FileSystem.\n   * @param fileName path relative to base path.\n   * @param text content or blob to write.\n   * @returns Returns a Promise that resolves or rejects with an error.\n   */\n  writeExistingFile(path, fileName, text) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      yield _this14.writeFile(path, fileName, text, {\n        replace: true\n      });\n    })();\n  }\n  /**\n   * Write a new file to the desired location.\n   *\n   * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n   * @param fileName path relative to base path\n   * @param text content or blob to write\n   * @param options replace file if set to true. See WriteOptions for more information.\n   * @returns Returns a Promise that resolves to updated file entry or rejects with an error.\n   */\n  writeFile(path, fileName, text, options = {}) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const getFileOpts = {\n        create: !options.append,\n        exclusive: !options.replace\n      };\n      const parentDir = yield _this15.resolveDirectoryUrl(path);\n      const fileEntry = yield _this15.getFile(parentDir, fileName, getFileOpts);\n      return _this15.writeFileEntryMock(fileEntry, text, options);\n    })();\n  }\n  /**\n   * Write content to FileEntry.\n   *\n   * @param fileEntry File entry object.\n   * @param text Content or blob to write.\n   * @param options replace file if set to true. See WriteOptions for more information.\n   * @returns Returns a Promise that resolves to updated file entry or rejects with an error.\n   */\n  writeFileEntryMock(fileEntry, text, options) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const writer = yield _this16.createWriterMock(fileEntry);\n      if (options.append) {\n        writer.seek(writer.length);\n      }\n      if (options.truncate) {\n        writer.truncate(options.truncate);\n      }\n      yield _this16.writeMock(writer, text);\n      return fileEntry;\n    })();\n  }\n  /**\n   * Write a file in chunks.\n   *\n   * @param writer File writer.\n   * @param data Data to write.\n   * @returns Promise resolved when done.\n   */\n  writeFileInChunksMock(writer, data) {\n    let writtenSize = 0;\n    const BLOCK_SIZE = 1024 * 1024;\n    const writeNextChunk = () => {\n      const size = Math.min(BLOCK_SIZE, data.size - writtenSize);\n      const chunk = data.slice(writtenSize, writtenSize + size);\n      writtenSize += size;\n      writer.write(chunk);\n    };\n    return new Promise((resolve, reject) => {\n      writer.onerror = reject;\n      writer.onwriteend = () => {\n        if (writtenSize < data.size) {\n          writeNextChunk();\n        } else {\n          resolve();\n        }\n      };\n      writeNextChunk();\n    });\n  }\n  /**\n   * Get emulator window.\n   *\n   * @returns Emulator window.\n   */\n  getEmulatorWindow() {\n    return window;\n  }\n  /**\n   * Get emulator navigator.\n   *\n   * @returns Emulator navigator.\n   */\n  getEmulatorNavigator() {\n    return navigator;\n  }\n}\n_class2 = FileMock;\n_class2.ɵfac = /*@__PURE__*/function () {\n  let ɵFileMock_BaseFactory;\n  return function FileMock_Factory(t) {\n    return (ɵFileMock_BaseFactory || (ɵFileMock_BaseFactory = i0.ɵɵgetInheritedFactory(_class2)))(t || _class2);\n  };\n}();\n_class2.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class2,\n  factory: _class2.ɵfac\n});","map":{"version":3,"names":["File","CorePath","FileError","constructor","code","_class","NOT_FOUND_ERR","SECURITY_ERR","ABORT_ERR","NOT_READABLE_ERR","ENCODING_ERR","NO_MODIFICATION_ALLOWED_ERR","INVALID_STATE_ERR","SYNTAX_ERR","INVALID_MODIFICATION_ERR","QUOTA_EXCEEDED_ERR","TYPE_MISMATCH_ERR","PATH_EXISTS_ERR","FileMock","checkDir","path","dir","_this","_asyncToGenerator","fullPath","concatenatePaths","resolveDirectoryUrl","checkFile","file","_this2","entry","resolveLocalFilesystemUrl","isFile","error","message","copyMock","srce","destDir","newName","Promise","resolve","reject","replace","copyTo","deste","err","fillErrorMessageMock","copyDir","dirName","newPath","newDirName","copyFileOrDir","copyFile","fileName","newFileName","sourcePath","sourceName","destPath","destName","_this3","destFixed","fixPathAndName","source","destParentDir","name","createDir","_this4","options","create","exclusive","parentDir","getDirectory","createFile","_this5","getFile","createWriterMock","fe","createWriter","writer","cordovaFileError","e","directoryEntry","directoryName","flags","de","xc","getFreeDiskSpace","_this6","window","getEmulatorWindow","requestFileSystem","Error","iterations","maxIterations","calculateByRequest","size","ratio","LocalFileSystem","PERSISTENT","then","listDir","_this7","dirEntry","readEntriesMock","createReader","load","undefined","webkitRequestFileSystem","resolveLocalFileSystemURL","webkitResolveLocalFileSystemURL","TEMPORARY","getEmulatorNavigator","webkitPersistentStorage","requestQuota","granted","fileSystem","root","toURL","moveMock","moveTo","moveDir","moveFileOrDir","moveFile","_this8","substring","lastIndexOf","readAsArrayBuffer","readFileMock","readAsBinaryString","readAsDataURL","readAsText","directoryReader","readEntries","entries","readAs","_this9","fileEntry","reader","FileReader","onloadend","result","call","removeMock","remove","success","fileRemoved","removeDir","_this10","removeFile","_this11","removeRecursively","_this12","rimrafMock","directoryUrl","_this13","isDirectory","fileUrl","writeMock","data","Blob","writeFileInChunksMock","ArrayBuffer","String","fromCharCode","apply","Uint8Array","onwriteend","write","writeExistingFile","text","_this14","writeFile","_this15","getFileOpts","append","writeFileEntryMock","_this16","seek","length","truncate","writtenSize","BLOCK_SIZE","writeNextChunk","Math","min","chunk","slice","onerror","navigator","t","factory","ɵfac"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/emulator/services/file.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* eslint-disable deprecation/deprecation */\n\nimport { Injectable } from '@angular/core';\nimport {\n    File,\n    Entry,\n    FileEntry,\n    FileSystem,\n    IWriteOptions,\n    RemoveResult,\n    DirectoryEntry,\n    DirectoryReader,\n} from '@awesome-cordova-plugins/file/ngx';\nimport { CorePath } from '@singletons/path';\n\n/**\n * Implement the File Error because the ionic-native plugin doesn't implement it.\n */\nclass FileError {\n\n    static readonly NOT_FOUND_ERR = 1;\n    static readonly SECURITY_ERR = 2;\n    static readonly ABORT_ERR = 3;\n    static readonly NOT_READABLE_ERR = 4;\n    static readonly ENCODING_ERR = 5;\n    static readonly NO_MODIFICATION_ALLOWED_ERR = 6;\n    static readonly INVALID_STATE_ERR = 7;\n    static readonly SYNTAX_ERR = 8;\n    static readonly INVALID_MODIFICATION_ERR = 9;\n    static readonly QUOTA_EXCEEDED_ERR = 10;\n    static readonly TYPE_MISMATCH_ERR = 11;\n    static readonly PATH_EXISTS_ERR = 12;\n\n    message?: string;\n\n    constructor(\n        public code: number,\n    ) { }\n\n}\n\n/**\n * Native APIs used in webkit window.\n */\ninterface WebkitWindow {\n\n    /**\n     * @deprecated\n     * @see https://www.w3.org/TR/2012/WD-file-system-api-20120417/\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LocalFileSystem: {\n        readonly TEMPORARY: number;\n        readonly PERSISTENT: number;\n    };\n\n    /**\n     * @deprecated\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/requestFileSystem\n     */\n    requestFileSystem(\n        type: LocalFileSystem,\n        size: number,\n        successCallback: (fileSystem: FileSystem) => void,\n        errorCallback?: (fileError: FileError) => void,\n    ): void;\n\n    /**\n     * @deprecated\n     */\n    webkitRequestFileSystem(\n        type: LocalFileSystem,\n        size: number,\n        successCallback: (fileSystem: FileSystem) => void,\n        errorCallback?: (fileError: FileError) => void,\n    ): void;\n\n    /**\n     * @deprecated\n     * @see https://www.w3.org/TR/2012/WD-file-system-api-20120417/\n     */\n    resolveLocalFileSystemURL(\n        url: string,\n        successCallback: (entry: Entry) => void,\n        errorCallback?: (fileError: FileError) => void,\n    ): void;\n\n    /**\n     * @deprecated\n     */\n    webkitResolveLocalFileSystemURL(\n        url: string,\n        successCallback: (entry: Entry) => void,\n        errorCallback?: (fileError: FileError) => void,\n    ): void;\n\n}\n\n/**\n * Native APIs used in webkit navigator.\n */\ninterface WebkitNavigator {\n\n    /**\n     * @deprecated\n     * @see https://developer.chrome.com/docs/apps/offline_storage/\n     */\n    webkitPersistentStorage: {\n        requestQuota(\n            newQuotaInBytes: number,\n            successCallback?: (bytesGranted: number) => void,\n            errorCallback?: (error: Error) => void,\n        ): void;\n    };\n\n}\n\n/**\n * Emulates the Cordova File plugin in browser.\n * Most of the code is extracted from the File class of Ionic Native.\n */\n@Injectable()\nexport class FileMock extends File {\n\n    /**\n     * Check if a directory exists in a certain path, directory.\n     *\n     * @param path Base FileSystem.\n     * @param dir Name of directory to check\n     * @returns Returns a Promise that resolves to true if the directory exists or rejects with an error.\n     */\n    async checkDir(path: string, dir: string): Promise<boolean> {\n        const fullPath = CorePath.concatenatePaths(path, dir);\n\n        await this.resolveDirectoryUrl(fullPath);\n\n        return true;\n    }\n\n    /**\n     * Check if a file exists in a certain path, directory.\n     *\n     * @param path Base FileSystem.\n     * @param file Name of file to check.\n     * @returns Returns a Promise that resolves with a boolean or rejects with an error.\n     */\n    async checkFile(path: string, file: string): Promise<boolean> {\n        const entry = await this.resolveLocalFilesystemUrl(CorePath.concatenatePaths(path, file));\n\n        if (entry.isFile) {\n            return true;\n        } else {\n            const error = new FileError(13);\n            error.message = 'input is not a file';\n\n            throw error;\n        }\n    }\n\n    /**\n     * Copy a file or directory.\n     *\n     * @param srce The Entry to copy.\n     * @param destDir The directory where to put the copy.\n     * @param newName New name of the file/dir.\n     * @returns Returns a Promise that resolves to the new Entry object or rejects with an error.\n     */\n    private copyMock(srce: Entry, destDir: DirectoryEntry, newName: string): Promise<Entry> {\n        return new Promise<Entry>((resolve, reject): void => {\n            newName = newName.replace(/%20/g, ' '); // Replace all %20 with spaces.\n\n            srce.copyTo(destDir, newName, (deste) => {\n                resolve(deste);\n            }, (err) => {\n                this.fillErrorMessageMock(err);\n                reject(err);\n            });\n        });\n    }\n\n    /**\n     * Copy a directory in various methods. If destination directory exists, will fail to copy.\n     *\n     * @param path Base FileSystem. Please refer to the iOS and Android filesystems above.\n     * @param dirName Name of directory to copy.\n     * @param newPath Base FileSystem of new location.\n     * @param newDirName New name of directory to copy to (leave blank to remain the same).\n     * @returns Returns a Promise that resolves to the new Entry object or rejects with an error.\n     */\n    copyDir(path: string, dirName: string, newPath: string, newDirName: string): Promise<Entry> {\n        return this.copyFileOrDir(path, dirName, newPath, newDirName);\n    }\n\n    /**\n     * Copy a file in various methods. If file exists, will fail to copy.\n     *\n     * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n     * @param fileName Name of file to copy\n     * @param newPath Base FileSystem of new location\n     * @param newFileName New name of file to copy to (leave blank to remain the same)\n     * @returns Returns a Promise that resolves to an Entry or rejects with an error.\n     */\n    copyFile(path: string, fileName: string, newPath: string, newFileName: string): Promise<Entry> {\n        return this.copyFileOrDir(path, fileName, newPath, newFileName || fileName);\n    }\n\n    /**\n     * Copy a file or dir to a given path.\n     *\n     * @param sourcePath Path of the file/dir to copy.\n     * @param sourceName Name of file/dir to copy\n     * @param destPath Path where to copy.\n     * @param destName New name of file/dir.\n     * @returns Returns a Promise that resolves to the new Entry or rejects with an error.\n     */\n    async copyFileOrDir(sourcePath: string, sourceName: string, destPath: string, destName: string): Promise<Entry> {\n        const destFixed = this.fixPathAndName(destPath, destName);\n\n        const source = await this.resolveLocalFilesystemUrl(CorePath.concatenatePaths(sourcePath, sourceName));\n\n        const destParentDir = await this.resolveDirectoryUrl(destFixed.path);\n\n        return this.copyMock(source, destParentDir, destFixed.name);\n    }\n\n    /**\n     * Creates a new directory in the specific path.\n     * The replace boolean value determines whether to replace an existing directory with the same name.\n     * If an existing directory exists and the replace value is false, the promise will fail and return an error.\n     *\n     * @param path Base FileSystem.\n     * @param dirName Name of directory to create\n     * @param replace If true, replaces file with same name. If false returns error\n     * @returns Returns a Promise that resolves with a DirectoryEntry or rejects with an error.\n     */\n    async createDir(path: string, dirName: string, replace: boolean): Promise<DirectoryEntry> {\n        const options: Flags = {\n            create: true,\n        };\n\n        if (!replace) {\n            options.exclusive = true;\n        }\n\n        const parentDir = await this.resolveDirectoryUrl(path);\n\n        return this.getDirectory(parentDir, dirName, options);\n    }\n\n    /**\n     * Creates a new file in the specific path.\n     * The replace boolean value determines whether to replace an existing file with the same name.\n     * If an existing file exists and the replace value is false, the promise will fail and return an error.\n     *\n     * @param path Base FileSystem.\n     * @param fileName Name of file to create.\n     * @param replace If true, replaces file with same name. If false returns error.\n     * @returns Returns a Promise that resolves to a FileEntry or rejects with an error.\n     */\n    async createFile(path: string, fileName: string, replace: boolean): Promise<FileEntry> {\n        const options: Flags = {\n            create: true,\n        };\n\n        if (!replace) {\n            options.exclusive = true;\n        }\n\n        const parentDir = await this.resolveDirectoryUrl(path);\n\n        return this.getFile(parentDir, fileName, options);\n    }\n\n    /**\n     * Create a file writer for a certain file.\n     *\n     * @param fe File entry object.\n     * @returns Promise resolved with the FileWriter.\n     */\n    private createWriterMock(fe: FileEntry): Promise<FileWriter> {\n        return new Promise<FileWriter>((resolve, reject): void => {\n            fe.createWriter((writer) => {\n                resolve(writer);\n            }, (err) => {\n                this.fillErrorMessageMock(err);\n                reject(err);\n            });\n        });\n    }\n\n    /**\n     * Fill the message for an error.\n     *\n     * @param error Error.\n     */\n    private fillErrorMessageMock(error: FileError): void {\n        try {\n            error.message = this.cordovaFileError[error.code];\n        } catch (e) {\n            // Ignore errors.\n        }\n    }\n\n    /**\n     * Get a directory.\n     *\n     * @param directoryEntry Directory entry, obtained by resolveDirectoryUrl method\n     * @param directoryName Directory name\n     * @param flags Options\n     * @returns Promise resolved with the directory entry.\n     */\n    getDirectory(directoryEntry: DirectoryEntry, directoryName: string, flags: Flags): Promise<DirectoryEntry> {\n        return new Promise<DirectoryEntry>((resolve, reject): void => {\n            try {\n                directoryName = directoryName.replace(/%20/g, ' '); // Replace all %20 with spaces.\n\n                directoryEntry.getDirectory(directoryName, flags, (de) => {\n                    resolve(de);\n                }, (err) => {\n                    this.fillErrorMessageMock(err);\n                    reject(err);\n                });\n            } catch (xc) {\n                this.fillErrorMessageMock(xc);\n                reject(xc);\n            }\n        });\n    }\n\n    /**\n     * Get a file.\n     *\n     * @param directoryEntry Directory entry, obtained by resolveDirectoryUrl method\n     * @param fileName File name\n     * @param flags Options\n     * @returns Promise resolved with the file entry.\n     */\n    getFile(directoryEntry: DirectoryEntry, fileName: string, flags: Flags): Promise<FileEntry> {\n        return new Promise<FileEntry>((resolve, reject): void => {\n            try {\n                fileName = fileName.replace(/%20/g, ' '); // Replace all %20 with spaces.\n\n                directoryEntry.getFile(fileName, flags, resolve, (err) => {\n                    this.fillErrorMessageMock(err);\n                    reject(err);\n                });\n            } catch (xc) {\n                this.fillErrorMessageMock(xc);\n                reject(xc);\n            }\n        });\n    }\n\n    /**\n     * Get free disk space.\n     *\n     * @returns Promise resolved with the free space.\n     */\n    async getFreeDiskSpace(): Promise<number> {\n        // Request a file system instance with a minimum size until we get an error.\n        const window = this.getEmulatorWindow();\n\n        if (!window.requestFileSystem) {\n            throw new Error('File system not available.');\n        }\n\n        let iterations = 0;\n        let maxIterations = 50;\n        const calculateByRequest = (size: number, ratio: number): Promise<number> =>\n            new Promise((resolve): void => {\n                window.requestFileSystem(LocalFileSystem.PERSISTENT, size, () => {\n                    iterations++;\n                    if (iterations > maxIterations) {\n                        resolve(size);\n\n                        return;\n                    }\n                    // eslint-disable-next-line promise/catch-or-return\n                    calculateByRequest(size * ratio, ratio).then(resolve);\n                }, () => {\n                    resolve(size / ratio);\n                });\n            });\n\n        // General calculation, base 1MB and increasing factor 1.3.\n        let size = await calculateByRequest(1048576, 1.3);\n\n        // More accurate. Factor is 1.1.\n        iterations = 0;\n        maxIterations = 10;\n\n        size = await calculateByRequest(size, 1.1);\n\n        return size / 1024; // Return size in KB.\n    }\n\n    /**\n     * List files and directory from a given path.\n     *\n     * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n     * @param dirName Name of directory\n     * @returns Returns a Promise that resolves to an array of Entry objects or rejects with an error.\n     */\n    async listDir(path: string, dirName: string): Promise<Entry[]> {\n        const parentDir = await this.resolveDirectoryUrl(path);\n\n        const dirEntry = await this.getDirectory(parentDir, dirName, { create: false, exclusive: false });\n\n        return this.readEntriesMock(dirEntry.createReader());\n    }\n\n    /**\n     * Loads an initialize the API for browser.\n     *\n     * @returns Promise resolved when loaded.\n     */\n    load(): Promise<string> {\n        return new Promise((resolve, reject): void => {\n            const window = this.getEmulatorWindow();\n\n            if (window.requestFileSystem === undefined) {\n                window.requestFileSystem = window.webkitRequestFileSystem;\n            }\n            if (window.resolveLocalFileSystemURL === undefined) {\n                window.resolveLocalFileSystemURL = window.webkitResolveLocalFileSystemURL;\n            }\n            window.LocalFileSystem = {\n                TEMPORARY: 0, // eslint-disable-line @typescript-eslint/naming-convention\n                PERSISTENT: 1, // eslint-disable-line @typescript-eslint/naming-convention\n            };\n\n            // Request a quota to use. Request 500MB.\n            this.getEmulatorNavigator().webkitPersistentStorage.requestQuota(500 * 1024 * 1024, (granted) => {\n                window.requestFileSystem(LocalFileSystem.PERSISTENT, granted, (fileSystem: FileSystem) => {\n                    resolve(fileSystem.root.toURL());\n                }, reject);\n            }, reject);\n        });\n    }\n\n    /**\n     * Move a file or directory.\n     *\n     * @param srce The Entry to copy.\n     * @param destDir The directory where to move the file/dir.\n     * @param newName New name of the file/dir.\n     * @returns Returns a Promise that resolves to the new Entry object or rejects with an error.\n     */\n    private moveMock(srce: Entry, destDir: DirectoryEntry, newName: string): Promise<Entry> {\n        return new Promise<Entry>((resolve, reject): void => {\n            newName = newName.replace(/%20/g, ' '); // Replace all %20 with spaces.\n\n            srce.moveTo(destDir, newName, (deste) => {\n                resolve(deste);\n            }, (err) => {\n                this.fillErrorMessageMock(err);\n                reject(err);\n            });\n        });\n    }\n\n    /**\n     * Move a directory to a given path.\n     *\n     * @param path The source path to the directory.\n     * @param dirName The source directory name.\n     * @param newPath The destionation path to the directory.\n     * @param newDirName The destination directory name.\n     * @returns Returns a Promise that resolves to the new DirectoryEntry object or rejects with\n     *         an error.\n     */\n    moveDir(path: string, dirName: string, newPath: string, newDirName: string): Promise<DirectoryEntry | Entry> {\n        return this.moveFileOrDir(path, dirName, newPath, newDirName);\n    }\n\n    /**\n     * Move a file to a given path.\n     *\n     * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n     * @param fileName Name of file to move\n     * @param newPath Base FileSystem of new location\n     * @param newFileName New name of file to move to (leave blank to remain the same)\n     * @returns Returns a Promise that resolves to the new Entry or rejects with an error.\n     */\n    moveFile(path: string, fileName: string, newPath: string, newFileName: string): Promise<Entry> {\n        return this.moveFileOrDir(path, fileName, newPath, newFileName || fileName);\n    }\n\n    /**\n     * Move a file or dir to a given path.\n     *\n     * @param sourcePath Path of the file/dir to copy.\n     * @param sourceName Name of file/dir to copy\n     * @param destPath Path where to copy.\n     * @param destName New name of file/dir.\n     * @returns Returns a Promise that resolves to the new Entry or rejects with an error.\n     */\n    async moveFileOrDir(sourcePath: string, sourceName: string, destPath: string, destName: string): Promise<Entry> {\n        const destFixed = this.fixPathAndName(destPath, destName);\n\n        const source = await this.resolveLocalFilesystemUrl(CorePath.concatenatePaths(sourcePath, sourceName));\n\n        const destParentDir = await this.resolveDirectoryUrl(destFixed.path);\n\n        return this.moveMock(source, destParentDir, destFixed.name);\n    }\n\n    /**\n     * Fix a path and name, making sure the name doesn't contain any folder. If it does, the folder will be moved to the path.\n     *\n     * @param path Path to fix.\n     * @param name Name to fix.\n     * @returns Fixed values.\n     */\n    protected fixPathAndName(path: string, name: string): {path: string; name: string} {\n\n        const fullPath = CorePath.concatenatePaths(path, name);\n\n        return {\n            path: fullPath.substring(0, fullPath.lastIndexOf('/')),\n            name: fullPath.substring(fullPath.lastIndexOf('/') + 1),\n        };\n    }\n\n    /**\n     * Read file and return data as an ArrayBuffer.\n     *\n     * @param path Base FileSystem.\n     * @param file Name of file, relative to path.\n     * @returns Returns a Promise that resolves with the contents of the file as ArrayBuffer or rejects\n     *         with an error.\n     */\n    readAsArrayBuffer(path: string, file: string): Promise<ArrayBuffer> {\n        return this.readFileMock<ArrayBuffer>(path, file, 'ArrayBuffer');\n    }\n\n    /**\n     * Read file and return data as a binary data.\n     *\n     * @param path Base FileSystem.\n     * @param file Name of file, relative to path.\n     * @returns Returns a Promise that resolves with the contents of the file as string rejects with an error.\n     */\n    readAsBinaryString(path: string, file: string): Promise<string> {\n        return this.readFileMock<string>(path, file, 'BinaryString');\n    }\n\n    /**\n     * Read file and return data as a base64 encoded data url.\n     * A data url is of the form:\n     *      data: [<mediatype>][;base64],<data>\n     *\n     * @param path Base FileSystem.\n     * @param file Name of file, relative to path.\n     * @returns Returns a Promise that resolves with the contents of the file as data URL or rejects\n     *         with an error.\n     */\n    readAsDataURL(path: string, file: string): Promise<string> {\n        return this.readFileMock<string>(path, file, 'DataURL');\n    }\n\n    /**\n     * Read the contents of a file as text.\n     *\n     * @param path Base FileSystem.\n     * @param file Name of file, relative to path.\n     * @returns Returns a Promise that resolves with the contents of the file as string or rejects with an error.\n     */\n    readAsText(path: string, file: string): Promise<string> {\n        return this.readFileMock<string>(path, file, 'Text');\n    }\n\n    /**\n     * Read all the files and directories inside a directory.\n     *\n     * @param directoryReader The directory reader.\n     * @returns Promise resolved with the list of files/dirs.\n     */\n    private readEntriesMock(directoryReader: DirectoryReader): Promise<Entry[]> {\n        return new Promise<Entry[]>((resolve, reject): void => {\n            directoryReader.readEntries((entries: Entry[]) => {\n                resolve(entries);\n            }, (error: FileError) => {\n                this.fillErrorMessageMock(error);\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * Read the contents of a file.\n     *\n     * @param path Base FileSystem.\n     * @param file Name of file, relative to path.\n     * @param readAs Format to read as.\n     * @returns Returns a Promise that resolves with the contents of the file or rejects with an error.\n     */\n    private async readFileMock<T>(\n        path: string,\n        file: string,\n        readAs: 'ArrayBuffer' | 'BinaryString' | 'DataURL' | 'Text',\n    ): Promise<T> {\n        const directoryEntry = await this.resolveDirectoryUrl(path);\n\n        const fileEntry = await this.getFile(directoryEntry, file, { create: false });\n\n        const reader = new FileReader();\n\n        return new Promise<T>((resolve, reject): void => {\n            reader.onloadend = (): void => {\n                if (reader.result !== undefined || reader.result !== null) {\n                    resolve(<T> <unknown> reader.result);\n                } else if (reader.error !== undefined || reader.error !== null) {\n                    reject(reader.error);\n                } else {\n                    reject({ code: null, message: 'READER_ONLOADEND_ERR' });\n                }\n            };\n\n            fileEntry.file((file) => {\n                reader[`readAs${readAs}`].call(reader, file);\n            }, (error) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * Delete a file.\n     *\n     * @param entry The file to remove.\n     * @returns Promise resolved when done.\n     */\n    private removeMock(entry: Entry): Promise<RemoveResult> {\n        return new Promise<RemoveResult>((resolve, reject): void => {\n            entry.remove(() => {\n                resolve({ success: true, fileRemoved: entry });\n            }, (err) => {\n                this.fillErrorMessageMock(err);\n                reject(err);\n            });\n        });\n    }\n\n    /**\n     * Remove a directory at a given path.\n     *\n     * @param path The path to the directory.\n     * @param dirName The directory name.\n     * @returns Returns a Promise that resolves to a RemoveResult or rejects with an error.\n     */\n    async removeDir(path: string, dirName: string): Promise<RemoveResult> {\n        const parentDir = await this.resolveDirectoryUrl(path);\n\n        const dirEntry = await this.getDirectory(parentDir, dirName, { create: false });\n\n        return this.removeMock(dirEntry);\n    }\n\n    /**\n     * Removes a file from a desired location.\n     *\n     * @param path Base FileSystem.\n     * @param fileName Name of file to remove.\n     * @returns Returns a Promise that resolves to a RemoveResult or rejects with an error.\n     */\n    async removeFile(path: string, fileName: string): Promise<RemoveResult> {\n        const parentDir = await this.resolveDirectoryUrl(path);\n\n        const fileEntry = await this.getFile(parentDir, fileName, { create: false });\n\n        return this.removeMock(fileEntry);\n    }\n\n    /**\n     * Removes all files and the directory from a desired location.\n     *\n     * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n     * @param dirName Name of directory\n     * @returns Returns a Promise that resolves with a RemoveResult or rejects with an error.\n     */\n    async removeRecursively(path: string, dirName: string): Promise<RemoveResult> {\n        const parentDir = await this.resolveDirectoryUrl(path);\n\n        const dirEntry = await this.getDirectory(parentDir, dirName, { create: false });\n\n        return this.rimrafMock(dirEntry);\n    }\n\n    /**\n     * Resolves a local directory url.\n     *\n     * @param directoryUrl Directory system url.\n     * @returns Promise resolved with the file system Entry referred to by local URL\n     */\n    async resolveDirectoryUrl(directoryUrl: string): Promise<DirectoryEntry> {\n        const dirEntry = await this.resolveLocalFilesystemUrl(directoryUrl);\n\n        if (dirEntry.isDirectory) {\n            return <DirectoryEntry> dirEntry;\n        } else {\n            const error = new FileError(13);\n            error.message = 'input is not a directory';\n\n            throw error;\n        }\n    }\n\n    /**\n     * Resolves a local file system URL.\n     *\n     * @param fileUrl file system url.\n     * @returns Promise resolved with the file system Entry referred to by local URL\n     */\n    resolveLocalFilesystemUrl(fileUrl: string): Promise<Entry> {\n        return new Promise<Entry>((resolve, reject): void => {\n            try {\n                this.getEmulatorWindow().resolveLocalFileSystemURL(fileUrl, (entry: Entry) => {\n                    resolve(entry);\n                }, (error: FileError) => {\n                    this.fillErrorMessageMock(error);\n                    reject(error);\n                });\n            } catch (error) {\n                this.fillErrorMessageMock(error);\n                reject(error);\n            }\n        });\n    }\n\n    /**\n     * Remove a directory and all its contents.\n     *\n     * @param de Directory to remove.\n     * @returns Promise resolved when done.\n     */\n    private rimrafMock(de: DirectoryEntry): Promise<RemoveResult> {\n        return new Promise<RemoveResult>((resolve, reject): void => {\n            de.removeRecursively(() => {\n                resolve({ success: true, fileRemoved: de });\n            }, (err) => {\n                this.fillErrorMessageMock(err);\n                reject(err);\n            });\n        });\n    }\n\n    /**\n     * Write some data in a file.\n     *\n     * @param writer File writer.\n     * @param data The data to write.\n     * @returns Promise resolved when done.\n     */\n    protected writeMock(writer: FileWriter, data: string | Blob | ArrayBuffer): Promise<void> {\n        if (data instanceof Blob) {\n            return this.writeFileInChunksMock(writer, data);\n        }\n\n        if (data instanceof ArrayBuffer) {\n            // Convert to string.\n            data = String.fromCharCode.apply(null, new Uint8Array(data));\n        }\n\n        return new Promise<void>((resolve, reject) => {\n            writer.onwriteend = (): void => {\n                if (writer.error) {\n                    reject(writer.error);\n                } else {\n                    resolve();\n                }\n            };\n            writer.write(<string> data);\n        });\n    }\n\n    /**\n     * Write to an existing file.\n     *\n     * @param path Base FileSystem.\n     * @param fileName path relative to base path.\n     * @param text content or blob to write.\n     * @returns Returns a Promise that resolves or rejects with an error.\n     */\n    async writeExistingFile(path: string, fileName: string, text: string | Blob): Promise<void> {\n        await this.writeFile(path, fileName, text, { replace: true });\n    }\n\n    /**\n     * Write a new file to the desired location.\n     *\n     * @param path Base FileSystem. Please refer to the iOS and Android filesystems above\n     * @param fileName path relative to base path\n     * @param text content or blob to write\n     * @param options replace file if set to true. See WriteOptions for more information.\n     * @returns Returns a Promise that resolves to updated file entry or rejects with an error.\n     */\n    async writeFile(\n        path: string,\n        fileName: string,\n        text: string | Blob | ArrayBuffer,\n        options: IWriteOptions = {},\n    ): Promise<FileEntry> {\n        const getFileOpts: Flags = {\n            create: !options.append,\n            exclusive: !options.replace,\n        };\n\n        const parentDir = await this.resolveDirectoryUrl(path);\n\n        const fileEntry = await this.getFile(parentDir, fileName, getFileOpts);\n\n        return this.writeFileEntryMock(fileEntry, text, options);\n    }\n\n    /**\n     * Write content to FileEntry.\n     *\n     * @param fileEntry File entry object.\n     * @param text Content or blob to write.\n     * @param options replace file if set to true. See WriteOptions for more information.\n     * @returns Returns a Promise that resolves to updated file entry or rejects with an error.\n     */\n    private async writeFileEntryMock(\n        fileEntry: FileEntry,\n        text: string | Blob | ArrayBuffer,\n        options: IWriteOptions,\n    ): Promise<FileEntry> {\n        const writer = await this.createWriterMock(fileEntry);\n\n        if (options.append) {\n            writer.seek(writer.length);\n        }\n\n        if (options.truncate) {\n            writer.truncate(options.truncate);\n        }\n\n        await this.writeMock(writer, text);\n\n        return fileEntry;\n    }\n\n    /**\n     * Write a file in chunks.\n     *\n     * @param writer File writer.\n     * @param data Data to write.\n     * @returns Promise resolved when done.\n     */\n    private writeFileInChunksMock(writer: FileWriter, data: Blob): Promise<void> {\n        let writtenSize = 0;\n        const BLOCK_SIZE = 1024 * 1024;\n        const writeNextChunk = () => {\n            const size = Math.min(BLOCK_SIZE, data.size - writtenSize);\n            const chunk = data.slice(writtenSize, writtenSize + size);\n\n            writtenSize += size;\n            writer.write(chunk);\n        };\n\n        return new Promise<void>((resolve, reject): void => {\n            writer.onerror = reject;\n            writer.onwriteend = (): void => {\n                if (writtenSize < data.size) {\n                    writeNextChunk();\n                } else {\n                    resolve();\n                }\n            };\n            writeNextChunk();\n        });\n    }\n\n    /**\n     * Get emulator window.\n     *\n     * @returns Emulator window.\n     */\n    private getEmulatorWindow(): WebkitWindow {\n        return window as unknown as WebkitWindow;\n    }\n\n    /**\n     * Get emulator navigator.\n     *\n     * @returns Emulator navigator.\n     */\n    private getEmulatorNavigator(): WebkitNavigator {\n        return navigator as unknown as WebkitNavigator;\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}