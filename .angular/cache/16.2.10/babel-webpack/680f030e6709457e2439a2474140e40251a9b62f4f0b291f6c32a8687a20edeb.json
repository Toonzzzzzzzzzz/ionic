{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CaptureImageOptions, CaptureVideoOptions } from '@awesome-cordova-plugins/media-capture/ngx';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { makeSingleton, ModalController } from '@singletons';\nimport { CoreEmulatorCaptureMediaComponent } from '../components/capture-media/capture-media';\nimport * as i0 from \"@angular/core\";\n/**\n * Helper service with some features to capture media (image, video).\n */\nexport class CoreEmulatorCaptureHelperProvider {\n  constructor() {\n    this.possibleVideoMimeTypes = {\n      'video/webm;codecs=vp9': 'webm',\n      'video/webm;codecs=vp8': 'webm',\n      'video/ogg': 'ogv'\n    };\n  }\n  captureMedia(type, options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      options = options || {};\n      // Build the params to send to the modal.\n      const params = {\n        type: type\n      };\n      // Initialize some data based on the type of media to capture.\n      if (type == 'video') {\n        const mimeAndExt = _this.getMimeTypeAndExtension(type, options.mimetypes);\n        params.mimetype = mimeAndExt.mimetype;\n        params.extension = mimeAndExt.extension;\n      } else if (type == 'image') {\n        if ('sourceType' in options && options.sourceType !== undefined && options.sourceType != 1) {\n          return Promise.reject('This source type is not supported in browser.');\n        }\n        if ('cameraDirection' in options && options.cameraDirection == 1) {\n          params.facingMode = 'user';\n        }\n        if ('encodingType' in options && options.encodingType == 1) {\n          params.mimetype = 'image/png';\n          params.extension = 'png';\n        } else {\n          params.mimetype = 'image/jpeg';\n          params.extension = 'jpeg';\n        }\n        if ('quality' in options && options.quality !== undefined && options.quality >= 0 && options.quality <= 100) {\n          params.quality = options.quality / 100;\n        }\n        if ('destinationType' in options && options.destinationType == 0) {\n          params.returnDataUrl = true;\n        }\n      }\n      if ('duration' in options && options.duration) {\n        params.maxTime = options.duration * 1000;\n      }\n      const modal = yield ModalController.create({\n        component: CoreEmulatorCaptureMediaComponent,\n        cssClass: 'core-modal-fullscreen',\n        componentProps: params\n      });\n      yield modal.present();\n      const result = yield modal.onDidDismiss();\n      if (result.role == 'success') {\n        return result.data;\n      } else {\n        throw result.data;\n      }\n    })();\n  }\n  /**\n   * Get the mimetype and extension to capture media.\n   *\n   * @param type Type of media: image, video.\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @returns An object with mimetype and extension to use.\n   */\n  getMimeTypeAndExtension(type, mimetypes) {\n    const result = {};\n    if (mimetypes !== null && mimetypes !== void 0 && mimetypes.length) {\n      // Search for a supported mimetype.\n      result.mimetype = mimetypes.find(mimetype => {\n        const matches = mimetype.match(new RegExp('^' + type + '/'));\n        return (matches === null || matches === void 0 ? void 0 : matches.length) && window.MediaRecorder.isTypeSupported(mimetype);\n      });\n    }\n    if (result.mimetype) {\n      // Found a supported mimetype in the mimetypes array, get the extension.\n      result.extension = CoreMimetypeUtils.getExtension(result.mimetype);\n    } else if (type === 'video' && this.videoMimeType) {\n      // No mimetype found, use default extension.\n      result.mimetype = this.videoMimeType;\n      result.extension = this.possibleVideoMimeTypes[result.mimetype];\n    }\n    return result;\n  }\n  /**\n   * Init the getUserMedia function, using a deprecated function as fallback if the new one doesn't exist.\n   *\n   * @returns Whether the function is supported.\n   */\n  initGetUserMedia() {\n    return !!navigator.mediaDevices.getUserMedia;\n  }\n  /**\n   * Initialize the mimetypes to use when capturing.\n   */\n  initMimeTypes() {\n    for (const mimeType in this.possibleVideoMimeTypes) {\n      if (window.MediaRecorder.isTypeSupported(mimeType)) {\n        this.videoMimeType = mimeType;\n        break;\n      }\n    }\n  }\n  /**\n   * Load the Mocks that need it.\n   *\n   * @returns Promise resolved when loaded.\n   */\n  load() {\n    if (window.MediaRecorder !== undefined && this.initGetUserMedia()) {\n      this.initMimeTypes();\n    }\n    return Promise.resolve();\n  }\n}\n_class = CoreEmulatorCaptureHelperProvider;\n_class.ɵfac = function CoreEmulatorCaptureHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreEmulatorCaptureHelper = makeSingleton(CoreEmulatorCaptureHelperProvider);","map":{"version":3,"names":["CaptureImageOptions","CaptureVideoOptions","CoreMimetypeUtils","makeSingleton","ModalController","CoreEmulatorCaptureMediaComponent","CoreEmulatorCaptureHelperProvider","constructor","possibleVideoMimeTypes","captureMedia","type","options","_this","_asyncToGenerator","params","mimeAndExt","getMimeTypeAndExtension","mimetypes","mimetype","extension","sourceType","undefined","Promise","reject","cameraDirection","facingMode","encodingType","quality","destinationType","returnDataUrl","duration","maxTime","modal","create","component","cssClass","componentProps","present","result","onDidDismiss","role","data","length","find","matches","match","RegExp","window","MediaRecorder","isTypeSupported","getExtension","videoMimeType","initGetUserMedia","navigator","mediaDevices","getUserMedia","initMimeTypes","mimeType","load","resolve","factory","ɵfac","providedIn","CoreEmulatorCaptureHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/emulator/services/capture-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CameraOptions } from '@awesome-cordova-plugins/camera/ngx';\nimport { CaptureImageOptions, CaptureVideoOptions, MediaFile } from '@awesome-cordova-plugins/media-capture/ngx';\n\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { makeSingleton, ModalController } from '@singletons';\nimport { CaptureMediaComponentInputs, CoreEmulatorCaptureMediaComponent } from '../components/capture-media/capture-media';\n\n/**\n * Helper service with some features to capture media (image, video).\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreEmulatorCaptureHelperProvider {\n\n    protected possibleVideoMimeTypes = {\n        'video/webm;codecs=vp9': 'webm',\n        'video/webm;codecs=vp8': 'webm',\n        'video/ogg': 'ogv',\n    };\n\n    videoMimeType?: string;\n\n    /**\n     * Capture media (image, video).\n     *\n     * @param type Type of media: image, video.\n     * @param options Optional options.\n     * @returns Promise resolved when captured, rejected if error.\n     */\n    captureMedia(type: 'image', options?: MockCameraOptions): Promise<string>;\n    captureMedia(type: 'captureimage', options?: MockCaptureImageOptions): Promise<MediaFile[]>;\n    captureMedia(type: 'video', options?: MockCaptureVideoOptions): Promise<MediaFile[]>;\n    async captureMedia(\n        type: 'image' | 'captureimage' | 'video',\n        options?: MockCameraOptions | MockCaptureImageOptions | MockCaptureVideoOptions,\n    ): Promise<MediaFile[] | string> {\n        options = options || {};\n\n        // Build the params to send to the modal.\n        const params: CaptureMediaComponentInputs = {\n            type: type,\n        };\n\n        // Initialize some data based on the type of media to capture.\n        if (type == 'video') {\n            const mimeAndExt = this.getMimeTypeAndExtension(type, options.mimetypes);\n            params.mimetype = mimeAndExt.mimetype;\n            params.extension = mimeAndExt.extension;\n        } else if (type == 'image') {\n            if ('sourceType' in options && options.sourceType !== undefined && options.sourceType != 1) {\n                return Promise.reject('This source type is not supported in browser.');\n            }\n\n            if ('cameraDirection' in options && options.cameraDirection == 1) {\n                params.facingMode = 'user';\n            }\n\n            if ('encodingType' in options && options.encodingType == 1) {\n                params.mimetype = 'image/png';\n                params.extension = 'png';\n            } else {\n                params.mimetype = 'image/jpeg';\n                params.extension = 'jpeg';\n            }\n\n            if ('quality' in options && options.quality !== undefined && options.quality >= 0 && options.quality <= 100) {\n                params.quality = options.quality / 100;\n            }\n\n            if ('destinationType' in options && options.destinationType == 0) {\n                params.returnDataUrl = true;\n            }\n        }\n\n        if ('duration' in options && options.duration) {\n            params.maxTime = options.duration * 1000;\n        }\n\n        const modal = await ModalController.create({\n            component: CoreEmulatorCaptureMediaComponent,\n            cssClass: 'core-modal-fullscreen',\n            componentProps: params,\n        });\n\n        await modal.present();\n\n        const result = await modal.onDidDismiss();\n\n        if (result.role == 'success') {\n            return result.data;\n        } else {\n            throw result.data;\n        }\n    }\n\n    /**\n     * Get the mimetype and extension to capture media.\n     *\n     * @param type Type of media: image, video.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns An object with mimetype and extension to use.\n     */\n    protected getMimeTypeAndExtension(type: string, mimetypes?: string[]): { extension?: string; mimetype?: string } {\n        const result: { extension?: string; mimetype?: string } = {};\n\n        if (mimetypes?.length) {\n            // Search for a supported mimetype.\n            result.mimetype = mimetypes.find((mimetype) => {\n                const matches = mimetype.match(new RegExp('^' + type + '/'));\n\n                return matches?.length && window.MediaRecorder.isTypeSupported(mimetype);\n            });\n        }\n\n        if (result.mimetype) {\n            // Found a supported mimetype in the mimetypes array, get the extension.\n            result.extension = CoreMimetypeUtils.getExtension(result.mimetype);\n        } else if (type === 'video' && this.videoMimeType) {\n            // No mimetype found, use default extension.\n            result.mimetype = this.videoMimeType;\n            result.extension = this.possibleVideoMimeTypes[result.mimetype];\n        }\n\n        return result;\n    }\n\n    /**\n     * Init the getUserMedia function, using a deprecated function as fallback if the new one doesn't exist.\n     *\n     * @returns Whether the function is supported.\n     */\n    protected initGetUserMedia(): boolean {\n        return !!navigator.mediaDevices.getUserMedia;\n    }\n\n    /**\n     * Initialize the mimetypes to use when capturing.\n     */\n    protected initMimeTypes(): void {\n        for (const mimeType in this.possibleVideoMimeTypes) {\n            if (window.MediaRecorder.isTypeSupported(mimeType)) {\n                this.videoMimeType = mimeType;\n                break;\n            }\n        }\n    }\n\n    /**\n     * Load the Mocks that need it.\n     *\n     * @returns Promise resolved when loaded.\n     */\n    load(): Promise<void> {\n        if (window.MediaRecorder !== undefined && this.initGetUserMedia()) {\n            this.initMimeTypes();\n        }\n\n        return Promise.resolve();\n    }\n\n}\n\nexport const CoreEmulatorCaptureHelper = makeSingleton(CoreEmulatorCaptureHelperProvider);\n\nexport interface MockCameraOptions extends CameraOptions {\n    mimetypes?: string[]; // Allowed mimetypes.\n}\nexport interface MockCaptureImageOptions extends CaptureImageOptions {\n    mimetypes?: string[]; // Allowed mimetypes.\n}\nexport interface MockCaptureVideoOptions extends CaptureVideoOptions {\n    mimetypes?: string[]; // Allowed mimetypes.\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}