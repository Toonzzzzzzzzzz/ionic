{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { makeSingleton } from '@singletons';\nimport { AddonModAssign, AddonModAssignProvider } from '../assign';\nimport { AddonModAssignSubmissionDelegate } from '../submission-delegate';\nimport { AddonModAssignFeedbackDelegate } from '../feedback-delegate';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourse } from '@features/course/services/course';\nimport { AddonModAssignHelper } from '../assign-helper';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreGroups } from '@services/groups';\nimport { AddonModAssignSync } from '../assign-sync';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreGradesHelper } from '@features/grades/services/grades-helper';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to prefetch assigns.\n */\nexport class AddonModAssignPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n  constructor() {\n    super(...arguments);\n    this.name = 'AddonModAssign';\n    this.modName = 'assign';\n    this.component = AddonModAssignProvider.COMPONENT;\n    this.updatesNames = /^configuration$|^.*files$|^submissions$|^grades$|^gradeitems$|^outcomes$|^comments$/;\n  }\n  /**\n   * Check if a certain module can use core_course_check_updates to check if it has updates.\n   * If not defined, it will assume all modules can be checked.\n   * The modules that return false will always be shown as outdated when they're downloaded.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Whether the module can use check_updates. The promise should never be rejected.\n   */\n  canUseCheckUpdates(module, courseId) {\n    return _asyncToGenerator(function* () {\n      // Teachers cannot use the WS because it doesn't check student submissions.\n      try {\n        const assign = yield AddonModAssign.getAssignment(courseId, module.id);\n        const data = yield AddonModAssign.getSubmissions(assign.id, {\n          cmId: module.id\n        });\n        if (data.canviewsubmissions) {\n          return false;\n        }\n        // Check if the user can view their own submission.\n        yield AddonModAssign.getSubmissionStatus(assign.id, {\n          cmId: module.id\n        });\n        return true;\n      } catch (_unused) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Get list of files. If not defined, we'll assume they're in module.contents.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved with the list of files.\n   */\n  getFiles(module, courseId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const siteId = CoreSites.getCurrentSiteId();\n      try {\n        const assign = yield AddonModAssign.getAssignment(courseId, module.id, {\n          siteId\n        });\n        // Get intro files, attachments and activity files.\n        let files = assign.introattachments || [];\n        files = files.concat(_this.getIntroFilesFromInstance(module, assign));\n        files = files.concat(assign.activityattachments || []);\n        // Now get the files in the submissions.\n        const submissionData = yield AddonModAssign.getSubmissions(assign.id, {\n          cmId: module.id,\n          siteId\n        });\n        if (submissionData.canviewsubmissions) {\n          // Teacher, get all submissions.\n          const submissions = yield AddonModAssignHelper.getSubmissionsUserData(assign, submissionData.submissions, 0, {\n            siteId\n          });\n          // Get all the files in the submissions.\n          const promises = submissions.map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (submission) {\n              try {\n                const submissionFiles = yield _this.getSubmissionFiles(assign, submission.submitid, !!submission.blindid, true, siteId);\n                files = files.concat(submissionFiles);\n              } catch (error) {\n                if (error && error.errorcode == 'nopermission') {\n                  // The user does not have persmission to view this submission, ignore it.\n                  return;\n                }\n                throw error;\n              }\n            });\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n          yield Promise.all(promises);\n        } else {\n          // Student, get only his/her submissions.\n          const userId = CoreSites.getCurrentSiteUserId();\n          const blindMarking = !!assign.blindmarking && !assign.revealidentities;\n          const submissionFiles = yield _this.getSubmissionFiles(assign, userId, blindMarking, false, siteId);\n          files = files.concat(submissionFiles);\n        }\n        return files;\n      } catch (_unused2) {\n        // Error getting data, return empty list.\n        return [];\n      }\n    })();\n  }\n  /**\n   * Get submission files.\n   *\n   * @param assign Assign.\n   * @param submitId User ID of the submission to get.\n   * @param blindMarking True if blind marking, false otherwise.\n   * @param canViewAllSubmissions Whether the user can view all submissions.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with array of files.\n   */\n  getSubmissionFiles(assign, submitId, blindMarking, canViewAllSubmissions, siteId) {\n    return _asyncToGenerator(function* () {\n      var _submissionStatus$ass, _submissionStatus$ass2;\n      const submissionStatus = yield AddonModAssign.getSubmissionStatusWithRetry(assign, {\n        userId: submitId,\n        isBlind: blindMarking,\n        siteId\n      });\n      const userSubmission = AddonModAssign.getSubmissionObjectFromAttempt(assign, submissionStatus.lastattempt);\n      // Get intro and activity files from the submission status if it's a student.\n      // It's ok if they were already obtained from the assignment instance, they won't be downloaded twice.\n      const files = canViewAllSubmissions ? [] : (((_submissionStatus$ass = submissionStatus.assignmentdata) === null || _submissionStatus$ass === void 0 || (_submissionStatus$ass = _submissionStatus$ass.attachments) === null || _submissionStatus$ass === void 0 ? void 0 : _submissionStatus$ass.intro) || []).concat(((_submissionStatus$ass2 = submissionStatus.assignmentdata) === null || _submissionStatus$ass2 === void 0 || (_submissionStatus$ass2 = _submissionStatus$ass2.attachments) === null || _submissionStatus$ass2 === void 0 ? void 0 : _submissionStatus$ass2.activity) || []);\n      if (!submissionStatus.lastattempt || !userSubmission) {\n        return files;\n      }\n      const promises = [];\n      if (userSubmission.plugins) {\n        // Add submission plugin files.\n        userSubmission.plugins.forEach(plugin => {\n          promises.push(AddonModAssignSubmissionDelegate.getPluginFiles(assign, userSubmission, plugin, siteId));\n        });\n      }\n      if (submissionStatus.feedback && submissionStatus.feedback.plugins) {\n        // Add feedback plugin files.\n        submissionStatus.feedback.plugins.forEach(plugin => {\n          promises.push(AddonModAssignFeedbackDelegate.getPluginFiles(assign, userSubmission, plugin, siteId));\n        });\n      }\n      const filesLists = yield Promise.all(promises);\n      return files.concat.apply(files, filesLists);\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId The course ID the module belongs to.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId) {\n    return _asyncToGenerator(function* () {\n      yield AddonModAssign.invalidateContent(moduleId, courseId);\n    })();\n  }\n  /**\n   * Invalidate WS calls needed to determine module status.\n   *\n   * @param module Module.\n   * @returns Promise resolved when invalidated.\n   */\n  invalidateModule(module) {\n    return _asyncToGenerator(function* () {\n      return CoreCourse.invalidateModule(module.id);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  prefetch(module, courseId) {\n    return this.prefetchPackage(module, courseId, siteId => this.prefetchAssign(module, courseId, siteId));\n  }\n  /**\n   * Prefetch an assignment.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  prefetchAssign(module, courseId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const userId = CoreSites.getCurrentSiteUserId();\n      const options = {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      const modOptions = _objectSpread({\n        cmId: module.id\n      }, options);\n      // Get assignment to retrieve all its submissions.\n      const assign = yield AddonModAssign.getAssignment(courseId, module.id, options);\n      const promises = [];\n      const blindMarking = assign.blindmarking && !assign.revealidentities;\n      if (blindMarking) {\n        promises.push(CoreUtils.ignoreErrors(AddonModAssign.getAssignmentUserMappings(assign.id, -1, modOptions)));\n      }\n      promises.push(_this2.prefetchSubmissions(assign, courseId, module.id, userId, siteId));\n      promises.push(CoreCourse.getModuleBasicInfoByInstance(assign.id, 'assign', {\n        siteId\n      }));\n      // Get course data, needed to determine upload max size if it's configured to be course limit.\n      promises.push(CoreUtils.ignoreErrors(CoreCourses.getCourseByField('id', courseId, siteId)));\n      // Download intro files and attachments. Do not call getFiles because it'd call some WS twice.\n      let files = assign.introattachments || [];\n      files = files.concat(_this2.getIntroFilesFromInstance(module, assign));\n      promises.push(CoreFilepool.addFilesToQueue(siteId, files, _this2.component, module.id));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Prefetch assign submissions.\n   *\n   * @param assign Assign.\n   * @param courseId Course ID.\n   * @param moduleId Module ID.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when prefetched, rejected otherwise.\n   */\n  prefetchSubmissions(assign, courseId, moduleId, userId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const modOptions = {\n        cmId: moduleId,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      // Get submissions.\n      const submissions = yield AddonModAssign.getSubmissions(assign.id, modOptions);\n      const promises = [];\n      promises.push(_this3.prefetchParticipantSubmissions(assign, submissions.canviewsubmissions, submissions.submissions, moduleId, courseId, userId, siteId));\n      // Prefetch own submission, we need to do this for teachers too so the response with error is cached.\n      promises.push(_this3.prefetchSubmission(assign, courseId, moduleId, {\n        userId,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      }, true));\n      yield Promise.all(promises);\n    })();\n  }\n  prefetchParticipantSubmissions(assign, canviewsubmissions, submissions = [], moduleId, courseId, userId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const options = {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      const modOptions = _objectSpread({\n        cmId: moduleId\n      }, options);\n      // Always prefetch groupInfo.\n      const groupInfo = yield CoreGroups.getActivityGroupInfo(assign.cmid, false, undefined, siteId);\n      if (!canviewsubmissions) {\n        return;\n      }\n      // Teacher, prefetch all submissions.\n      if (!groupInfo.groups || groupInfo.groups.length == 0) {\n        groupInfo.groups = [{\n          id: 0,\n          name: ''\n        }];\n      }\n      const promises = groupInfo.groups.map(group => AddonModAssignHelper.getSubmissionsUserData(assign, submissions, group.id, options).then(submissions => {\n        const subPromises = submissions.map(submission => {\n          const submissionOptions = {\n            userId: submission.submitid,\n            groupId: group.id,\n            isBlind: !!submission.blindid,\n            readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n            siteId\n          };\n          return _this4.prefetchSubmission(assign, courseId, moduleId, submissionOptions, true);\n        });\n        subPromises.push(AddonModAssign.getAssignmentGrades(assign.id, modOptions));\n        // Prefetch the submission of the current user even if it does not exist, this will be create it.\n        if (!submissions || !submissions.find(subm => subm.submitid == userId)) {\n          const submissionOptions = {\n            userId,\n            groupId: group.id,\n            readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n            siteId\n          };\n          subPromises.push(_this4.prefetchSubmission(assign, courseId, moduleId, submissionOptions));\n        }\n        return Promise.all(subPromises);\n      }).then( /*#__PURE__*/_asyncToGenerator(function* () {\n        // Participiants already fetched, we don't need to ignore cache now.\n        const participants = yield AddonModAssignHelper.getParticipants(assign, group.id, {\n          siteId\n        });\n        yield CoreUser.prefetchUserAvatars(participants, 'profileimageurl', siteId);\n        return;\n      })));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Prefetch a submission.\n   *\n   * @param assign Assign.\n   * @param courseId Course ID.\n   * @param moduleId Module ID.\n   * @param options Other options, see getSubmissionStatusWithRetry.\n   * @param resolveOnNoPermission If true, will avoid throwing if a nopermission error is raised.\n   * @returns Promise resolved when prefetched, rejected otherwise.\n   */\n  prefetchSubmission(assign, courseId, moduleId, options = {}, resolveOnNoPermission = false) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const submission = yield AddonModAssign.getSubmissionStatusWithRetry(assign, options);\n      const siteId = options.siteId;\n      const userId = options.userId;\n      try {\n        const promises = [];\n        const blindMarking = !!assign.blindmarking && !assign.revealidentities;\n        let userIds = [];\n        const userSubmission = AddonModAssign.getSubmissionObjectFromAttempt(assign, submission.lastattempt);\n        if (submission.lastattempt) {\n          // Get IDs of the members who need to submit.\n          if (!blindMarking && submission.lastattempt.submissiongroupmemberswhoneedtosubmit) {\n            userIds = userIds.concat(submission.lastattempt.submissiongroupmemberswhoneedtosubmit);\n          }\n          if (userSubmission && userSubmission.id) {\n            // Prefetch submission plugins data.\n            if (userSubmission.plugins) {\n              userSubmission.plugins.forEach(plugin => {\n                // Prefetch the plugin WS data.\n                promises.push(AddonModAssignSubmissionDelegate.prefetch(assign, userSubmission, plugin, siteId));\n                // Prefetch the plugin files.\n                promises.push(AddonModAssignSubmissionDelegate.getPluginFiles(assign, userSubmission, plugin, siteId).then(files => CoreFilepool.addFilesToQueue(siteId, files, _this5.component, module.id)).catch(() => {\n                  // Ignore errors.\n                }));\n              });\n            }\n            // Get ID of the user who did the submission.\n            if (userSubmission.userid) {\n              userIds.push(userSubmission.userid);\n            }\n          }\n          if (assign.teamsubmission && submission.lastattempt.submissiongroup) {\n            // Prefetch group info.\n            promises.push(CoreGroups.getActivityAllowedGroups(assign.cmid));\n          }\n        }\n        // Prefetch grade items.\n        if (userId) {\n          promises.push(CoreCourse.getModuleBasicGradeInfo(moduleId, siteId).then(gradeInfo => {\n            if (gradeInfo) {\n              promises.push(CoreGradesHelper.getGradeModuleItems(courseId, moduleId, userId, undefined, siteId, true));\n            }\n            return;\n          }));\n        }\n        // Prefetch feedback.\n        if (submission.feedback) {\n          // Get profile and image of the grader.\n          if (submission.feedback.grade && submission.feedback.grade.grader > 0) {\n            userIds.push(submission.feedback.grade.grader);\n          }\n          // Prefetch feedback plugins data.\n          if (submission.feedback.plugins && userSubmission && userSubmission.id) {\n            submission.feedback.plugins.forEach(plugin => {\n              // Prefetch the plugin WS data.\n              promises.push(AddonModAssignFeedbackDelegate.prefetch(assign, userSubmission, plugin, siteId));\n              // Prefetch the plugin files.\n              promises.push(AddonModAssignFeedbackDelegate.getPluginFiles(assign, userSubmission, plugin, siteId).then(files => CoreFilepool.addFilesToQueue(siteId, files, _this5.component, module.id)).catch(() => {\n                // Ignore errors.\n              }));\n            });\n          }\n        }\n        // Prefetch user profiles.\n        promises.push(CoreUser.prefetchProfiles(userIds, courseId, siteId));\n        yield Promise.all(promises);\n      } catch (error) {\n        // Ignore if the user can't view their own submission.\n        if (resolveOnNoPermission && error.errorcode != 'nopermission') {\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Sync a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  sync(module, courseId, siteId) {\n    return AddonModAssignSync.syncAssign(module.instance, siteId);\n  }\n}\n_class = AddonModAssignPrefetchHandlerService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵAddonModAssignPrefetchHandlerService_BaseFactory;\n  return function AddonModAssignPrefetchHandlerService_Factory(t) {\n    return (ɵAddonModAssignPrefetchHandlerService_BaseFactory || (ɵAddonModAssignPrefetchHandlerService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModAssignPrefetchHandler = makeSingleton(AddonModAssignPrefetchHandlerService);","map":{"version":3,"names":["CoreSites","CoreSitesReadingStrategy","makeSingleton","AddonModAssign","AddonModAssignProvider","AddonModAssignSubmissionDelegate","AddonModAssignFeedbackDelegate","CoreCourseActivityPrefetchHandlerBase","CoreCourse","AddonModAssignHelper","CoreUtils","CoreFilepool","CoreGroups","AddonModAssignSync","CoreUser","CoreGradesHelper","CoreCourses","AddonModAssignPrefetchHandlerService","constructor","name","modName","component","COMPONENT","updatesNames","canUseCheckUpdates","module","courseId","_asyncToGenerator","assign","getAssignment","id","data","getSubmissions","cmId","canviewsubmissions","getSubmissionStatus","_unused","getFiles","_this","siteId","getCurrentSiteId","files","introattachments","concat","getIntroFilesFromInstance","activityattachments","submissionData","submissions","getSubmissionsUserData","promises","map","_ref","submission","submissionFiles","getSubmissionFiles","submitid","blindid","error","errorcode","_x","apply","arguments","Promise","all","userId","getCurrentSiteUserId","blindMarking","blindmarking","revealidentities","_unused2","submitId","canViewAllSubmissions","_submissionStatus$ass","_submissionStatus$ass2","submissionStatus","getSubmissionStatusWithRetry","isBlind","userSubmission","getSubmissionObjectFromAttempt","lastattempt","assignmentdata","attachments","intro","activity","plugins","forEach","plugin","push","getPluginFiles","feedback","filesLists","invalidateContent","moduleId","invalidateModule","prefetch","prefetchPackage","prefetchAssign","_this2","options","readingStrategy","modOptions","_objectSpread","ignoreErrors","getAssignmentUserMappings","prefetchSubmissions","getModuleBasicInfoByInstance","getCourseByField","addFilesToQueue","_this3","prefetchParticipantSubmissions","prefetchSubmission","_this4","groupInfo","getActivityGroupInfo","cmid","undefined","groups","length","group","then","subPromises","submissionOptions","groupId","getAssignmentGrades","find","subm","participants","getParticipants","prefetchUserAvatars","resolveOnNoPermission","_this5","userIds","submissiongroupmemberswhoneedtosubmit","catch","userid","teamsubmission","submissiongroup","getActivityAllowedGroups","getModuleBasicGradeInfo","gradeInfo","getGradeModuleItems","grade","grader","prefetchProfiles","sync","syncAssign","instance","t","factory","ɵfac","providedIn","AddonModAssignPrefetchHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/assign/services/handlers/prefetch.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { makeSingleton } from '@singletons';\nimport {\n    AddonModAssign,\n    AddonModAssignAssign,\n    AddonModAssignProvider,\n    AddonModAssignSubmission,\n    AddonModAssignSubmissionStatusOptions,\n} from '../assign';\nimport { AddonModAssignSubmissionDelegate } from '../submission-delegate';\nimport { AddonModAssignFeedbackDelegate } from '../feedback-delegate';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourse, CoreCourseAnyModuleData, CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreWSFile } from '@services/ws';\nimport { AddonModAssignHelper, AddonModAssignSubmissionFormatted } from '../assign-helper';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreGroups } from '@services/groups';\nimport { AddonModAssignSync, AddonModAssignSyncResult } from '../assign-sync';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreGradesHelper } from '@features/grades/services/grades-helper';\nimport { CoreCourses } from '@features/courses/services/courses';\n\n/**\n * Handler to prefetch assigns.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModAssignPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n\n    name = 'AddonModAssign';\n    modName = 'assign';\n    component = AddonModAssignProvider.COMPONENT;\n    updatesNames = /^configuration$|^.*files$|^submissions$|^grades$|^gradeitems$|^outcomes$|^comments$/;\n\n    /**\n     * Check if a certain module can use core_course_check_updates to check if it has updates.\n     * If not defined, it will assume all modules can be checked.\n     * The modules that return false will always be shown as outdated when they're downloaded.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Whether the module can use check_updates. The promise should never be rejected.\n     */\n    async canUseCheckUpdates(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        // Teachers cannot use the WS because it doesn't check student submissions.\n        try {\n            const assign = await AddonModAssign.getAssignment(courseId, module.id);\n\n            const data = await AddonModAssign.getSubmissions(assign.id, { cmId: module.id });\n            if (data.canviewsubmissions) {\n                return false;\n            }\n\n            // Check if the user can view their own submission.\n            await AddonModAssign.getSubmissionStatus(assign.id, { cmId: module.id });\n\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Get list of files. If not defined, we'll assume they're in module.contents.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved with the list of files.\n     */\n    async getFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<CoreWSFile[]> {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        try {\n            const assign = await AddonModAssign.getAssignment(courseId, module.id, { siteId });\n            // Get intro files, attachments and activity files.\n            let files: CoreWSFile[] = assign.introattachments || [];\n            files = files.concat(this.getIntroFilesFromInstance(module, assign));\n            files = files.concat(assign.activityattachments || []);\n\n            // Now get the files in the submissions.\n            const submissionData = await AddonModAssign.getSubmissions(assign.id, { cmId: module.id, siteId });\n\n            if (submissionData.canviewsubmissions) {\n                // Teacher, get all submissions.\n                const submissions =\n                    await AddonModAssignHelper.getSubmissionsUserData(assign, submissionData.submissions, 0, { siteId });\n\n                // Get all the files in the submissions.\n                const promises = submissions.map(async (submission) => {\n                    try {\n                        const submissionFiles = await this.getSubmissionFiles(\n                            assign,\n                            submission.submitid!,\n                            !!submission.blindid,\n                            true,\n                            siteId,\n                        );\n\n                        files = files.concat(submissionFiles);\n                    } catch (error) {\n                        if (error && error.errorcode == 'nopermission') {\n                            // The user does not have persmission to view this submission, ignore it.\n                            return;\n                        }\n\n                        throw error;\n                    }\n                });\n\n                await Promise.all(promises);\n            } else {\n                // Student, get only his/her submissions.\n                const userId = CoreSites.getCurrentSiteUserId();\n                const blindMarking = !!assign.blindmarking && !assign.revealidentities;\n\n                const submissionFiles = await this.getSubmissionFiles(assign, userId, blindMarking, false, siteId);\n                files = files.concat(submissionFiles);\n            }\n\n            return files;\n        } catch {\n            // Error getting data, return empty list.\n            return [];\n        }\n    }\n\n    /**\n     * Get submission files.\n     *\n     * @param assign Assign.\n     * @param submitId User ID of the submission to get.\n     * @param blindMarking True if blind marking, false otherwise.\n     * @param canViewAllSubmissions Whether the user can view all submissions.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with array of files.\n     */\n    protected async getSubmissionFiles(\n        assign: AddonModAssignAssign,\n        submitId: number,\n        blindMarking: boolean,\n        canViewAllSubmissions: boolean,\n        siteId?: string,\n    ): Promise<CoreWSFile[]> {\n\n        const submissionStatus = await AddonModAssign.getSubmissionStatusWithRetry(assign, {\n            userId: submitId,\n            isBlind: blindMarking,\n            siteId,\n        });\n        const userSubmission = AddonModAssign.getSubmissionObjectFromAttempt(assign, submissionStatus.lastattempt);\n\n        // Get intro and activity files from the submission status if it's a student.\n        // It's ok if they were already obtained from the assignment instance, they won't be downloaded twice.\n        const files: CoreWSFile[] = canViewAllSubmissions ?\n            [] :\n            (submissionStatus.assignmentdata?.attachments?.intro || [])\n                .concat(submissionStatus.assignmentdata?.attachments?.activity || []);\n\n        if (!submissionStatus.lastattempt || !userSubmission) {\n            return files;\n        }\n\n        const promises: Promise<CoreWSFile[]>[] = [];\n\n        if (userSubmission.plugins) {\n            // Add submission plugin files.\n            userSubmission.plugins.forEach((plugin) => {\n                promises.push(AddonModAssignSubmissionDelegate.getPluginFiles(assign, userSubmission, plugin, siteId));\n            });\n        }\n\n        if (submissionStatus.feedback && submissionStatus.feedback.plugins) {\n            // Add feedback plugin files.\n            submissionStatus.feedback.plugins.forEach((plugin) => {\n                promises.push(AddonModAssignFeedbackDelegate.getPluginFiles(assign, userSubmission, plugin, siteId));\n            });\n        }\n\n        const filesLists = await Promise.all(promises);\n\n        return files.concat.apply(files, filesLists);\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId The course ID the module belongs to.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        await AddonModAssign.invalidateContent(moduleId, courseId);\n    }\n\n    /**\n     * Invalidate WS calls needed to determine module status.\n     *\n     * @param module Module.\n     * @returns Promise resolved when invalidated.\n     */\n    async invalidateModule(module: CoreCourseAnyModuleData): Promise<void> {\n        return CoreCourse.invalidateModule(module.id);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    prefetch(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        return this.prefetchPackage(module, courseId, (siteId) => this.prefetchAssign(module, courseId, siteId));\n    }\n\n    /**\n     * Prefetch an assignment.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchAssign(module: CoreCourseAnyModuleData, courseId: number, siteId: string): Promise<void> {\n        const userId = CoreSites.getCurrentSiteUserId();\n\n        const options: CoreSitesCommonWSOptions = {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        const modOptions: CoreCourseCommonModWSOptions = {\n            cmId: module.id,\n            ...options,\n        };\n\n        // Get assignment to retrieve all its submissions.\n        const assign = await AddonModAssign.getAssignment(courseId, module.id, options);\n        const promises: Promise<unknown>[] = [];\n        const blindMarking = assign.blindmarking && !assign.revealidentities;\n\n        if (blindMarking) {\n            promises.push(\n                CoreUtils.ignoreErrors(AddonModAssign.getAssignmentUserMappings(assign.id, -1, modOptions)),\n            );\n        }\n\n        promises.push(this.prefetchSubmissions(assign, courseId, module.id, userId, siteId));\n\n        promises.push(CoreCourse.getModuleBasicInfoByInstance(assign.id, 'assign', { siteId }));\n        // Get course data, needed to determine upload max size if it's configured to be course limit.\n        promises.push(CoreUtils.ignoreErrors(CoreCourses.getCourseByField('id', courseId, siteId)));\n\n        // Download intro files and attachments. Do not call getFiles because it'd call some WS twice.\n        let files: CoreWSFile[] = assign.introattachments || [];\n        files = files.concat(this.getIntroFilesFromInstance(module, assign));\n\n        promises.push(CoreFilepool.addFilesToQueue(siteId, files, this.component, module.id));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Prefetch assign submissions.\n     *\n     * @param assign Assign.\n     * @param courseId Course ID.\n     * @param moduleId Module ID.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when prefetched, rejected otherwise.\n     */\n    protected async prefetchSubmissions(\n        assign: AddonModAssignAssign,\n        courseId: number,\n        moduleId: number,\n        userId: number,\n        siteId: string,\n    ): Promise<void> {\n        const modOptions: CoreCourseCommonModWSOptions = {\n            cmId: moduleId,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        // Get submissions.\n        const submissions = await AddonModAssign.getSubmissions(assign.id, modOptions);\n        const promises: Promise<unknown>[] = [];\n\n        promises.push(this.prefetchParticipantSubmissions(\n            assign,\n            submissions.canviewsubmissions,\n            submissions.submissions,\n            moduleId,\n            courseId,\n            userId,\n            siteId,\n        ));\n\n        // Prefetch own submission, we need to do this for teachers too so the response with error is cached.\n        promises.push(\n            this.prefetchSubmission(\n                assign,\n                courseId,\n                moduleId,\n                {\n                    userId,\n                    readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n                    siteId,\n                },\n                true,\n            ),\n        );\n\n        await Promise.all(promises);\n    }\n\n    protected async prefetchParticipantSubmissions(\n        assign: AddonModAssignAssign,\n        canviewsubmissions: boolean,\n        submissions: AddonModAssignSubmission[] = [],\n        moduleId: number,\n        courseId: number,\n        userId: number,\n        siteId: string,\n    ): Promise<void> {\n\n        const options: CoreSitesCommonWSOptions = {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        const modOptions: CoreCourseCommonModWSOptions = {\n            cmId: moduleId,\n            ...options,\n        };\n\n        // Always prefetch groupInfo.\n        const groupInfo = await CoreGroups.getActivityGroupInfo(assign.cmid, false, undefined, siteId);\n        if (!canviewsubmissions) {\n\n            return;\n        }\n\n        // Teacher, prefetch all submissions.\n        if (!groupInfo.groups || groupInfo.groups.length == 0) {\n            groupInfo.groups = [{ id: 0, name: '' }];\n        }\n\n        const promises = groupInfo.groups.map((group) =>\n            AddonModAssignHelper.getSubmissionsUserData(assign, submissions, group.id, options)\n                .then((submissions: AddonModAssignSubmissionFormatted[]) => {\n\n                    const subPromises: Promise<unknown>[] = submissions.map((submission) => {\n                        const submissionOptions = {\n                            userId: submission.submitid,\n                            groupId: group.id,\n                            isBlind: !!submission.blindid,\n                            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n                            siteId,\n                        };\n\n                        return this.prefetchSubmission(assign, courseId, moduleId, submissionOptions, true);\n                    });\n\n                    subPromises.push(AddonModAssign.getAssignmentGrades(assign.id, modOptions));\n\n                    // Prefetch the submission of the current user even if it does not exist, this will be create it.\n                    if (!submissions || !submissions.find((subm: AddonModAssignSubmissionFormatted) => subm.submitid == userId)) {\n                        const submissionOptions = {\n                            userId,\n                            groupId: group.id,\n                            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n                            siteId,\n                        };\n\n                        subPromises.push(this.prefetchSubmission(assign, courseId, moduleId, submissionOptions));\n                    }\n\n                    return Promise.all(subPromises);\n                }).then(async () => {\n                    // Participiants already fetched, we don't need to ignore cache now.\n                    const participants = await AddonModAssignHelper.getParticipants(assign, group.id, { siteId });\n\n                    await CoreUser.prefetchUserAvatars(participants, 'profileimageurl', siteId);\n\n                    return;\n                }));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Prefetch a submission.\n     *\n     * @param assign Assign.\n     * @param courseId Course ID.\n     * @param moduleId Module ID.\n     * @param options Other options, see getSubmissionStatusWithRetry.\n     * @param resolveOnNoPermission If true, will avoid throwing if a nopermission error is raised.\n     * @returns Promise resolved when prefetched, rejected otherwise.\n     */\n    protected async prefetchSubmission(\n        assign: AddonModAssignAssign,\n        courseId: number,\n        moduleId: number,\n        options: AddonModAssignSubmissionStatusOptions = {},\n        resolveOnNoPermission = false,\n    ): Promise<void> {\n        const submission = await AddonModAssign.getSubmissionStatusWithRetry(assign, options);\n        const siteId = options.siteId!;\n        const userId = options.userId;\n\n        try {\n            const promises: Promise<unknown>[] = [];\n            const blindMarking = !!assign.blindmarking && !assign.revealidentities;\n            let userIds: number[] = [];\n            const userSubmission = AddonModAssign.getSubmissionObjectFromAttempt(assign, submission.lastattempt);\n\n            if (submission.lastattempt) {\n                // Get IDs of the members who need to submit.\n                if (!blindMarking && submission.lastattempt.submissiongroupmemberswhoneedtosubmit) {\n                    userIds = userIds.concat(submission.lastattempt.submissiongroupmemberswhoneedtosubmit);\n                }\n\n                if (userSubmission && userSubmission.id) {\n                    // Prefetch submission plugins data.\n                    if (userSubmission.plugins) {\n                        userSubmission.plugins.forEach((plugin) => {\n                            // Prefetch the plugin WS data.\n                            promises.push(\n                                AddonModAssignSubmissionDelegate.prefetch(assign, userSubmission, plugin, siteId),\n                            );\n\n                            // Prefetch the plugin files.\n                            promises.push(\n                                AddonModAssignSubmissionDelegate.getPluginFiles(assign, userSubmission, plugin, siteId)\n                                    .then((files) =>\n                                        CoreFilepool.addFilesToQueue(siteId, files, this.component, module.id))\n                                    .catch(() => {\n                                        // Ignore errors.\n                                    }),\n                            );\n                        });\n                    }\n\n                    // Get ID of the user who did the submission.\n                    if (userSubmission.userid) {\n                        userIds.push(userSubmission.userid);\n                    }\n                }\n\n                if (assign.teamsubmission && submission.lastattempt.submissiongroup) {\n                    // Prefetch group info.\n                    promises.push(CoreGroups.getActivityAllowedGroups(assign.cmid));\n                }\n            }\n\n            // Prefetch grade items.\n            if (userId) {\n                promises.push(CoreCourse.getModuleBasicGradeInfo(moduleId, siteId).then((gradeInfo) => {\n                    if (gradeInfo) {\n                        promises.push(\n                            CoreGradesHelper.getGradeModuleItems(courseId, moduleId, userId, undefined, siteId, true),\n                        );\n                    }\n\n                    return;\n                }));\n            }\n\n            // Prefetch feedback.\n            if (submission.feedback) {\n                // Get profile and image of the grader.\n                if (submission.feedback.grade && submission.feedback.grade.grader > 0) {\n                    userIds.push(submission.feedback.grade.grader);\n                }\n\n                // Prefetch feedback plugins data.\n                if (submission.feedback.plugins && userSubmission && userSubmission.id) {\n                    submission.feedback.plugins.forEach((plugin) => {\n                        // Prefetch the plugin WS data.\n                        promises.push(AddonModAssignFeedbackDelegate.prefetch(assign, userSubmission, plugin, siteId));\n\n                        // Prefetch the plugin files.\n                        promises.push(\n                            AddonModAssignFeedbackDelegate.getPluginFiles(assign, userSubmission, plugin, siteId)\n                                .then((files) => CoreFilepool.addFilesToQueue(siteId, files, this.component, module.id))\n                                .catch(() => {\n                                    // Ignore errors.\n                                }),\n                        );\n                    });\n                }\n            }\n\n            // Prefetch user profiles.\n            promises.push(CoreUser.prefetchProfiles(userIds, courseId, siteId));\n\n            await Promise.all(promises);\n        } catch (error) {\n            // Ignore if the user can't view their own submission.\n            if (resolveOnNoPermission && error.errorcode != 'nopermission') {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Sync a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    sync(module: CoreCourseAnyModuleData, courseId: number, siteId?: string): Promise<AddonModAssignSyncResult> {\n        return AddonModAssignSync.syncAssign(module.instance, siteId);\n    }\n\n}\nexport const AddonModAssignPrefetchHandler = makeSingleton(AddonModAssignPrefetchHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}