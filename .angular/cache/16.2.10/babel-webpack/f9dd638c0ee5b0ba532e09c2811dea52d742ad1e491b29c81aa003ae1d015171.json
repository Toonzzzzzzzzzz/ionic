{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreConstants } from '@/core/constants';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreApp } from '@services/app';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreLang } from '@services/lang';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'CoreSitePlugins:';\n/**\n * Service to provide functionalities regarding site plugins.\n */\nexport class CoreSitePluginsProvider {\n  constructor() {\n    this.sitePlugins = {}; // Site plugins registered.\n    this.sitePluginPromises = {}; // Promises of loading plugins.\n    this.moduleHandlerInstances = {};\n    this.hasSitePluginsLoaded = false;\n    this.sitePluginsFinishedLoading = false;\n    this.logger = CoreLogger.getInstance('CoreSitePluginsProvider');\n    const observer = CoreEvents.on(CoreEvents.SITE_PLUGINS_LOADED, () => {\n      this.sitePluginsFinishedLoading = true;\n      observer === null || observer === void 0 || observer.off();\n    });\n    // Initialize deferred at start and on logout.\n    this.fetchPluginsDeferred = new CorePromisedValue();\n    CoreEvents.on(CoreEvents.LOGOUT, () => {\n      this.fetchPluginsDeferred = new CorePromisedValue();\n    });\n  }\n  /**\n   * Add some params that will always be sent for get content.\n   *\n   * @param args Original params.\n   * @param site Site. If not defined, current site.\n   * @returns Promise resolved with the new params.\n   */\n  addDefaultArgs(args, site) {\n    return _asyncToGenerator(function* () {\n      var _args$userid, _site;\n      args = args || {};\n      site = site || CoreSites.getCurrentSite();\n      const lang = yield CoreLang.getCurrentLanguage(\"lms\" /* CoreLangFormat.LMS */);\n      const defaultArgs = {\n        userid: (_args$userid = args.userid) !== null && _args$userid !== void 0 ? _args$userid : (_site = site) === null || _site === void 0 ? void 0 : _site.getUserId(),\n        appid: CoreConstants.CONFIG.app_id,\n        appversioncode: CoreConstants.CONFIG.versioncode,\n        appversionname: CoreConstants.CONFIG.versionname,\n        applang: lang,\n        appcustomurlscheme: CoreConstants.CONFIG.customurlscheme,\n        appisdesktop: false,\n        appismobile: CorePlatform.isMobile(),\n        appiswide: CoreApp.isWide(),\n        appplatform: 'browser'\n      };\n      if (args.appismobile) {\n        defaultArgs.appplatform = CorePlatform.isIOS() ? 'ios' : 'android';\n      }\n      return _objectSpread(_objectSpread({}, args), defaultArgs);\n    })();\n  }\n  /**\n   * Call a WS for a site plugin.\n   *\n   * @param method WS method to use.\n   * @param data Data to send to the WS.\n   * @param preSets Extra options.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the response.\n   */\n  callWS(method, data, preSets, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      preSets = preSets || {};\n      preSets.cacheKey = preSets.cacheKey || _this.getCallWSCacheKey(method, data);\n      return site.read(method, data, preSets);\n    })();\n  }\n  /**\n   * Given the result of a init get_content and, optionally, the result of another get_content,\n   * build an object with the data to pass to the JS of the get_content.\n   *\n   * @param initResult Result of the init WS call.\n   * @param contentResult Result of the content WS call (if any).\n   * @returns An object with the data to pass to the JS.\n   */\n  createDataForJS(initResult, contentResult) {\n    let data = {};\n    if (initResult) {\n      // First of all, add the data returned by the init JS (if any).\n      data = Object.assign(data, initResult.jsResult || {});\n      // Now add some data returned by the init WS call.\n      data.INIT_TEMPLATES = CoreUtils.objectToKeyValueMap(initResult.templates, 'id', 'html');\n      data.INIT_OTHERDATA = initResult.otherdata;\n    }\n    if (contentResult) {\n      // Now add the data returned by the content WS call.\n      data.CONTENT_TEMPLATES = CoreUtils.objectToKeyValueMap(contentResult.templates, 'id', 'html');\n      data.CONTENT_OTHERDATA = contentResult.otherdata;\n    }\n    return data;\n  }\n  /**\n   * Get cache key for a WS call.\n   *\n   * @param method Name of the method.\n   * @param data Data to identify the WS call.\n   * @returns Cache key.\n   */\n  getCallWSCacheKey(method, data) {\n    return this.getCallWSCommonCacheKey(method) + ':' + CoreUtils.sortAndStringify(data);\n  }\n  /**\n   * Get common cache key for a WS call.\n   *\n   * @param method Name of the method.\n   * @returns Cache key.\n   */\n  getCallWSCommonCacheKey(method) {\n    return ROOT_CACHE_KEY + 'ws:' + method;\n  }\n  /**\n   * Get a certain content for a site plugin.\n   *\n   * @param component Component where the class is. E.g. mod_assign.\n   * @param method Method to execute in the class.\n   * @param args The params for the method.\n   * @param preSets Extra options.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the result.\n   */\n  getContent(component, method, args, preSets, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _preSets$updateFreque;\n      _this2.logger.debug(`Get content for component '${component}' and method '${method}'`);\n      const site = yield CoreSites.getSite(siteId);\n      // Add some params that will always be sent.\n      args = args || {};\n      const argsToSend = yield _this2.addDefaultArgs(args, site);\n      // Now call the WS.\n      const data = {\n        component: component,\n        method: method,\n        args: CoreUtils.objectToArrayOfObjects(argsToSend, 'name', 'value', true)\n      };\n      preSets = preSets || {};\n      preSets.cacheKey = _this2.getContentCacheKey(component, method, args);\n      preSets.updateFrequency = (_preSets$updateFreque = preSets.updateFrequency) !== null && _preSets$updateFreque !== void 0 ? _preSets$updateFreque : CoreSite.FREQUENCY_OFTEN;\n      const result = yield site.read('tool_mobile_get_content', data, preSets);\n      let otherData = {};\n      if (result.otherdata) {\n        otherData = CoreUtils.objectToKeyValueMap(result.otherdata, 'name', 'value');\n        // Try to parse all properties that could be JSON encoded strings.\n        for (const name in otherData) {\n          const value = otherData[name];\n          if (typeof value == 'string' && (value[0] == '{' || value[0] == '[')) {\n            otherData[name] = CoreTextUtils.parseJSON(value);\n          }\n        }\n      }\n      return Object.assign(result, {\n        otherdata: otherData\n      });\n    })();\n  }\n  /**\n   * Get cache key for get content WS calls.\n   *\n   * @param component Component where the class is. E.g. mod_assign.\n   * @param method Method to execute in the class.\n   * @param args The params for the method.\n   * @returns Cache key.\n   */\n  getContentCacheKey(component, method, args) {\n    return ROOT_CACHE_KEY + 'content:' + component + ':' + method + ':' + CoreUtils.sortAndStringify(args);\n  }\n  /**\n   * Get the value of a WS param for prefetch.\n   *\n   * @param component The component of the handler.\n   * @param paramName Name of the param as defined by the handler.\n   * @param courseId Course ID (if prefetching a course).\n   * @param module The module object returned by WS (if prefetching a module).\n   * @returns The value.\n   */\n  getDownloadParam(component, paramName, courseId, module) {\n    switch (paramName) {\n      case 'courseids':\n        // The WS needs the list of course IDs. Create the list.\n        return [courseId || 0];\n      case component + 'id':\n        // The WS needs the instance id.\n        return module && module.instance;\n      default:\n      // No more params supported for now.\n    }\n  }\n  /**\n   * Get the unique name of a handler (plugin + handler).\n   *\n   * @param plugin Data of the plugin.\n   * @param handlerName Name of the handler inside the plugin.\n   * @returns Unique name.\n   */\n  getHandlerUniqueName(plugin, handlerName) {\n    return plugin.addon + '_' + handlerName;\n  }\n  /**\n   * Get site plugins for site.\n   *\n   * @param siteId Site ID.\n   * @returns Promise resolved with the plugins.\n   */\n  getPlugins(siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // Get the list of plugins. Try not to use cache.\n      const data = yield site.read('tool_mobile_get_plugins_supporting_mobile', {}, {\n        getFromCache: false,\n        cacheKey: _this3.getPluginsCacheKey()\n      });\n      // Return enabled plugins.\n      return data.plugins.filter(plugin => _this3.isSitePluginEnabled(plugin, site));\n    })();\n  }\n  /**\n   * Get cache key for get plugins WS call.\n   *\n   * @returns Cache key.\n   */\n  getPluginsCacheKey() {\n    return ROOT_CACHE_KEY + 'plugins';\n  }\n  /**\n   * Get a site plugin handler.\n   *\n   * @param name Unique name of the handler.\n   * @returns Handler.\n   */\n  getSitePluginHandler(name) {\n    return this.sitePlugins[name];\n  }\n  /**\n   * Get the current site plugin list.\n   *\n   * @returns Plugin list ws info.\n   */\n  getCurrentSitePluginList() {\n    return CoreUtils.objectToArray(this.sitePlugins).map(plugin => plugin.plugin);\n  }\n  /**\n   * Invalidate all WS call to a certain method.\n   *\n   * @param method WS method to use.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllCallWSForMethod(method, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this4.getCallWSCommonCacheKey(method));\n    })();\n  }\n  /**\n   * Invalidate a WS call.\n   *\n   * @param method WS method to use.\n   * @param data Data to send to the WS.\n   * @param preSets Extra options.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCallWS(method, data, preSets, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      preSets = preSets || {};\n      yield site.invalidateWsCacheForKey(preSets.cacheKey || _this5.getCallWSCacheKey(method, data));\n    })();\n  }\n  /**\n   * Invalidate a page content.\n   *\n   * @param component Component where the class is. E.g. mod_assign.\n   * @param callback Method to execute in the class.\n   * @param args The params for the method.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(component, callback, args, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this6.getContentCacheKey(component, callback, args || {}));\n    })();\n  }\n  /**\n   * Check if a handler is enabled for a certain course.\n   *\n   * @param courseId Course ID to check.\n   * @param restrictEnrolled If true or undefined, handler is only enabled for courses the user is enrolled in.\n   * @param restrict Users and courses the handler is restricted to.\n   * @returns Whether the handler is enabled.\n   */\n  isHandlerEnabledForCourse(courseId, restrictEnrolled, restrict) {\n    return _asyncToGenerator(function* () {\n      var _restrict$courses;\n      if ((restrict === null || restrict === void 0 || (_restrict$courses = restrict.courses) === null || _restrict$courses === void 0 ? void 0 : _restrict$courses.indexOf(courseId)) == -1) {\n        // Course is not in the list of restricted courses.\n        return false;\n      }\n      if (restrictEnrolled || restrictEnrolled === undefined) {\n        // Only enabled for courses the user is enrolled to. Check if the user is enrolled in the course.\n        try {\n          yield CoreCourses.getUserCourse(courseId, true);\n        } catch (_unused) {\n          return false;\n        }\n      }\n      return true;\n    })();\n  }\n  /**\n   * Check if a handler is enabled for a certain user.\n   *\n   * @param userId User ID to check.\n   * @param restrictCurrent Whether handler is only enabled for current user.\n   * @param restrict Users and courses the handler is restricted to.\n   * @returns Whether the handler is enabled.\n   */\n  isHandlerEnabledForUser(userId, restrictCurrent, restrict) {\n    var _CoreSites$getCurrent, _restrict$users;\n    if (restrictCurrent && userId != ((_CoreSites$getCurrent = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent === void 0 ? void 0 : _CoreSites$getCurrent.getUserId())) {\n      // Only enabled for current user.\n      return false;\n    }\n    if ((restrict === null || restrict === void 0 || (_restrict$users = restrict.users) === null || _restrict$users === void 0 ? void 0 : _restrict$users.indexOf(userId)) == -1) {\n      // User is not in the list of restricted users.\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if a certain plugin is a site plugin and it's enabled in a certain site.\n   *\n   * @param plugin Data of the plugin.\n   * @param site Site affected.\n   * @returns Whether it's a site plugin and it's enabled.\n   */\n  isSitePluginEnabled(plugin, site) {\n    if (site.isFeatureDisabled('sitePlugin_' + plugin.component + '_' + plugin.addon) || !plugin.handlers) {\n      return false;\n    }\n    // Site plugin not disabled. Check if it has handlers.\n    if (!plugin.parsedHandlers) {\n      plugin.parsedHandlers = CoreTextUtils.parseJSON(plugin.handlers, null, error => this.logger.error('Error parsing site plugin handlers', error));\n    }\n    return !!(plugin.parsedHandlers && Object.keys(plugin.parsedHandlers).length);\n  }\n  /**\n   * Load other data into args as determined by useOtherData list.\n   * If useOtherData is undefined, it won't add any data.\n   * If useOtherData is an array, it will only copy the properties whose names are in the array.\n   * If useOtherData is any other value, it will copy all the data from otherData to args.\n   *\n   * @param args The current args.\n   * @param otherData All the other data.\n   * @param useOtherData Names of the attributes to include.\n   * @returns New args.\n   */\n  loadOtherDataInArgs(args, otherData, useOtherData) {\n    if (!args) {\n      args = {};\n    } else {\n      args = CoreUtils.clone(args);\n    }\n    otherData = otherData || {};\n    if (useOtherData === undefined) {\n      // No need to add other data, return args as they are.\n      return args;\n    } else if (Array.isArray(useOtherData)) {\n      // Include only the properties specified in the array.\n      for (const i in useOtherData) {\n        const name = useOtherData[i];\n        if (typeof otherData[name] == 'object' && otherData[name] !== null) {\n          // Stringify objects.\n          args[name] = JSON.stringify(otherData[name]);\n        } else {\n          args[name] = otherData[name];\n        }\n      }\n    } else {\n      // Add all the data to args.\n      for (const name in otherData) {\n        if (typeof otherData[name] == 'object' && otherData[name] !== null) {\n          // Stringify objects.\n          args[name] = JSON.stringify(otherData[name]);\n        } else {\n          args[name] = otherData[name];\n        }\n      }\n    }\n    return args;\n  }\n  /**\n   * Prefetch offline functions for a site plugin handler.\n   *\n   * @param component The component of the handler.\n   * @param args Params to send to the get_content calls.\n   * @param handlerSchema The handler schema.\n   * @param courseId Course ID (if prefetching a course).\n   * @param module The module object returned by WS (if prefetching a module).\n   * @param prefetch True to prefetch, false to download right away.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @param site Site. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  prefetchFunctions(component, args, handlerSchema, courseId, module, prefetch, dirPath, site) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      site = site || CoreSites.getCurrentSite();\n      if (!site || !handlerSchema.offlinefunctions) {\n        return;\n      }\n      const siteInstance = site;\n      const offlineFunctions = handlerSchema.offlinefunctions;\n      yield Promise.all(Object.keys(handlerSchema.offlinefunctions).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (method) {\n          if (siteInstance.wsAvailable(method)) {\n            // The method is a WS.\n            const paramsList = offlineFunctions[method];\n            const cacheKey = _this7.getCallWSCacheKey(method, args);\n            let params = {};\n            if (!paramsList.length) {\n              // No params defined, send the default ones.\n              params = args;\n            } else {\n              for (const i in paramsList) {\n                const paramName = paramsList[i];\n                if (args[paramName] !== undefined) {\n                  params[paramName] = args[paramName];\n                } else {\n                  // The param is not one of the default ones. Try to calculate the param to use.\n                  const value = _this7.getDownloadParam(component, paramName, courseId, module);\n                  if (value !== undefined) {\n                    params[paramName] = value;\n                  }\n                }\n              }\n            }\n            yield _this7.callWS(method, params, {\n              cacheKey\n            });\n            return;\n          }\n          // It's a method to get content.\n          const preSets = {\n            component: component\n          };\n          if (module) {\n            preSets.componentId = module.id;\n          }\n          const result = yield _this7.getContent(component, method, args, preSets);\n          // Prefetch the files in the content.\n          if (result.files.length) {\n            yield CoreFilepool.downloadOrPrefetchFiles(siteInstance.getId(), result.files, !!prefetch, false, component, module === null || module === void 0 ? void 0 : module.id, dirPath);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Store a site plugin handler.\n   *\n   * @param name A unique name to identify the handler.\n   * @param handler Handler to set.\n   */\n  setSitePluginHandler(name, handler) {\n    this.sitePlugins[name] = handler;\n  }\n  /**\n   * Store the promise for a plugin that is being initialised.\n   *\n   * @param component Component name.\n   * @param promise Promise to register.\n   */\n  registerSitePluginPromise(component, promise) {\n    this.sitePluginPromises[component] = promise;\n  }\n  /**\n   * Set plugins fetched.\n   */\n  setPluginsFetched() {\n    this.fetchPluginsDeferred.resolve();\n  }\n  /**\n   * Set plugins fetched.\n   */\n  setPluginsLoaded(loaded) {\n    this.hasSitePluginsLoaded = !!loaded;\n  }\n  /**\n   * Is a plugin being initialised for the specified component?\n   *\n   * @param component Component name.\n   * @returns If site plugin promise has been set.\n   */\n  sitePluginPromiseExists(component) {\n    return !!this.sitePluginPromises[component];\n  }\n  /**\n   * Get the promise for a plugin that is being initialised.\n   *\n   * @param component Component name.\n   * @returns Plugin loaded promise.\n   */\n  sitePluginLoaded(component) {\n    return this.sitePluginPromises[component];\n  }\n  /**\n   * Wait for fetch plugins to be done.\n   *\n   * @returns Promise resolved when site plugins have been fetched.\n   */\n  waitFetchPlugins() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      yield _this8.fetchPluginsDeferred;\n    })();\n  }\n  /**\n   * Get a module hander instance, if present.\n   *\n   * @param modName Mod name without \"mod_\".\n   * @returns Handler instance, undefined if not found.\n   */\n  getModuleHandlerInstance(modName) {\n    return this.moduleHandlerInstances[modName];\n  }\n  /**\n   * Set a module hander instance.\n   *\n   * @param modName Mod name.\n   * @param handler Handler instance.\n   */\n  setModuleHandlerInstance(modName, handler) {\n    this.moduleHandlerInstances[modName] = handler;\n  }\n}\n_class = CoreSitePluginsProvider;\n_class.COMPONENT = 'CoreSitePlugins';\n_class.UPDATE_COURSE_CONTENT = 'siteplugins_update_course_content';\n_class.ɵfac = function CoreSitePluginsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreSitePlugins = makeSingleton(CoreSitePluginsProvider);","map":{"version":3,"names":["CoreConstants","CoreSite","CoreCourses","CoreApp","CoreFilepool","CoreLang","CoreSites","CoreTextUtils","CoreUtils","makeSingleton","CoreEvents","CoreLogger","CorePromisedValue","CorePlatform","ROOT_CACHE_KEY","CoreSitePluginsProvider","constructor","sitePlugins","sitePluginPromises","moduleHandlerInstances","hasSitePluginsLoaded","sitePluginsFinishedLoading","logger","getInstance","observer","on","SITE_PLUGINS_LOADED","off","fetchPluginsDeferred","LOGOUT","addDefaultArgs","args","site","_asyncToGenerator","_args$userid","_site","getCurrentSite","lang","getCurrentLanguage","defaultArgs","userid","getUserId","appid","CONFIG","app_id","appversioncode","versioncode","appversionname","versionname","applang","appcustomurlscheme","customurlscheme","appisdesktop","appismobile","isMobile","appiswide","isWide","appplatform","isIOS","_objectSpread","callWS","method","data","preSets","siteId","_this","getSite","cacheKey","getCallWSCacheKey","read","createDataForJS","initResult","contentResult","Object","assign","jsResult","INIT_TEMPLATES","objectToKeyValueMap","templates","INIT_OTHERDATA","otherdata","CONTENT_TEMPLATES","CONTENT_OTHERDATA","getCallWSCommonCacheKey","sortAndStringify","getContent","component","_this2","_preSets$updateFreque","debug","argsToSend","objectToArrayOfObjects","getContentCacheKey","updateFrequency","FREQUENCY_OFTEN","result","otherData","name","value","parseJSON","getDownloadParam","paramName","courseId","module","instance","getHandlerUniqueName","plugin","handlerName","addon","getPlugins","_this3","getFromCache","getPluginsCacheKey","plugins","filter","isSitePluginEnabled","getSitePluginHandler","getCurrentSitePluginList","objectToArray","map","invalidateAllCallWSForMethod","_this4","invalidateWsCacheForKeyStartingWith","invalidateCallWS","_this5","invalidateWsCacheForKey","invalidateContent","callback","_this6","isHandlerEnabledForCourse","restrictEnrolled","restrict","_restrict$courses","courses","indexOf","undefined","getUserCourse","_unused","isHandlerEnabledForUser","userId","restrictCurrent","_CoreSites$getCurrent","_restrict$users","users","isFeatureDisabled","handlers","parsedHandlers","error","keys","length","loadOtherDataInArgs","useOtherData","clone","Array","isArray","i","JSON","stringify","prefetchFunctions","handlerSchema","prefetch","dirPath","_this7","offlinefunctions","siteInstance","offlineFunctions","Promise","all","_ref","wsAvailable","paramsList","params","componentId","id","files","downloadOrPrefetchFiles","getId","_x","apply","arguments","setSitePluginHandler","handler","registerSitePluginPromise","promise","setPluginsFetched","resolve","setPluginsLoaded","loaded","sitePluginPromiseExists","sitePluginLoaded","waitFetchPlugins","_this8","getModuleHandlerInstance","modName","setModuleHandlerInstance","_class","COMPONENT","UPDATE_COURSE_CONTENT","factory","ɵfac","providedIn","CoreSitePlugins"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/siteplugins/services/siteplugins.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreConstants } from '@/core/constants';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseAnyModuleData } from '@features/course/services/course';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreApp } from '@services/app';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreLang, CoreLangFormat } from '@services/lang';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSitePluginsModuleHandler } from '../classes/handlers/module-handler';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { CoreEnrolAction, CoreEnrolInfoIcon } from '@features/enrol/services/enrol-delegate';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'CoreSitePlugins:';\n\n/**\n * Service to provide functionalities regarding site plugins.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreSitePluginsProvider {\n\n    static readonly COMPONENT = 'CoreSitePlugins';\n    static readonly UPDATE_COURSE_CONTENT = 'siteplugins_update_course_content';\n\n    protected logger: CoreLogger;\n    protected sitePlugins: {[name: string]: CoreSitePluginsHandler} = {}; // Site plugins registered.\n    protected sitePluginPromises: {[name: string]: Promise<void>} = {}; // Promises of loading plugins.\n    protected fetchPluginsDeferred: CorePromisedValue<void>;\n    protected moduleHandlerInstances: Record<string, CoreSitePluginsModuleHandler> = {};\n\n    hasSitePluginsLoaded = false;\n    sitePluginsFinishedLoading = false;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreSitePluginsProvider');\n\n        const observer = CoreEvents.on(CoreEvents.SITE_PLUGINS_LOADED, () => {\n            this.sitePluginsFinishedLoading = true;\n            observer?.off();\n        });\n\n        // Initialize deferred at start and on logout.\n        this.fetchPluginsDeferred = new CorePromisedValue();\n        CoreEvents.on(CoreEvents.LOGOUT, () => {\n            this.fetchPluginsDeferred = new CorePromisedValue();\n        });\n    }\n\n    /**\n     * Add some params that will always be sent for get content.\n     *\n     * @param args Original params.\n     * @param site Site. If not defined, current site.\n     * @returns Promise resolved with the new params.\n     */\n    protected async addDefaultArgs<T extends Record<string, unknown> = Record<string, unknown>>(\n        args: T,\n        site?: CoreSite,\n    ): Promise<T & CoreSitePluginsDefaultArgs> {\n        args = args || {};\n        site = site || CoreSites.getCurrentSite();\n\n        const lang = await CoreLang.getCurrentLanguage(CoreLangFormat.LMS);\n\n        const defaultArgs: CoreSitePluginsDefaultArgs = {\n            userid: <number> args.userid ?? site?.getUserId(),\n            appid: CoreConstants.CONFIG.app_id,\n            appversioncode: CoreConstants.CONFIG.versioncode,\n            appversionname: CoreConstants.CONFIG.versionname,\n            applang: lang,\n            appcustomurlscheme: CoreConstants.CONFIG.customurlscheme,\n            appisdesktop: false,\n            appismobile: CorePlatform.isMobile(),\n            appiswide: CoreApp.isWide(),\n            appplatform: 'browser',\n        };\n\n        if (args.appismobile) {\n            defaultArgs.appplatform = CorePlatform.isIOS() ? 'ios' : 'android';\n        }\n\n        return {\n            ...args,\n            ...defaultArgs,\n        };\n    }\n\n    /**\n     * Call a WS for a site plugin.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the response.\n     */\n    async callWS<T = unknown>(\n        method: string,\n        data: Record<string, unknown>,\n        preSets?: CoreSiteWSPreSets,\n        siteId?: string,\n    ): Promise<T> {\n        const site = await CoreSites.getSite(siteId);\n\n        preSets = preSets || {};\n        preSets.cacheKey = preSets.cacheKey || this.getCallWSCacheKey(method, data);\n\n        return site.read<T>(method, data, preSets);\n    }\n\n    /**\n     * Given the result of a init get_content and, optionally, the result of another get_content,\n     * build an object with the data to pass to the JS of the get_content.\n     *\n     * @param initResult Result of the init WS call.\n     * @param contentResult Result of the content WS call (if any).\n     * @returns An object with the data to pass to the JS.\n     */\n    createDataForJS(\n        initResult?: CoreSitePluginsContent | null,\n        contentResult?: CoreSitePluginsContent | null,\n    ): Record<string, unknown> {\n        let data: Record<string, unknown> = {};\n\n        if (initResult) {\n            // First of all, add the data returned by the init JS (if any).\n            data = Object.assign(data, initResult.jsResult || {});\n\n            // Now add some data returned by the init WS call.\n            data.INIT_TEMPLATES = CoreUtils.objectToKeyValueMap(initResult.templates, 'id', 'html');\n            data.INIT_OTHERDATA = initResult.otherdata;\n        }\n\n        if (contentResult) {\n            // Now add the data returned by the content WS call.\n            data.CONTENT_TEMPLATES = CoreUtils.objectToKeyValueMap(contentResult.templates, 'id', 'html');\n            data.CONTENT_OTHERDATA = contentResult.otherdata;\n        }\n\n        return data;\n    }\n\n    /**\n     * Get cache key for a WS call.\n     *\n     * @param method Name of the method.\n     * @param data Data to identify the WS call.\n     * @returns Cache key.\n     */\n    getCallWSCacheKey(method: string, data: Record<string, unknown>): string {\n        return this.getCallWSCommonCacheKey(method) + ':' + CoreUtils.sortAndStringify(data);\n    }\n\n    /**\n     * Get common cache key for a WS call.\n     *\n     * @param method Name of the method.\n     * @returns Cache key.\n     */\n    protected getCallWSCommonCacheKey(method: string): string {\n        return ROOT_CACHE_KEY + 'ws:' + method;\n    }\n\n    /**\n     * Get a certain content for a site plugin.\n     *\n     * @param component Component where the class is. E.g. mod_assign.\n     * @param method Method to execute in the class.\n     * @param args The params for the method.\n     * @param preSets Extra options.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the result.\n     */\n    async getContent(\n        component: string,\n        method: string,\n        args?: Record<string, unknown>,\n        preSets?: CoreSiteWSPreSets,\n        siteId?: string,\n    ): Promise<CoreSitePluginsContentParsed> {\n        this.logger.debug(`Get content for component '${component}' and method '${method}'`);\n\n        const site = await CoreSites.getSite(siteId);\n\n        // Add some params that will always be sent.\n        args = args || {};\n        const argsToSend = await this.addDefaultArgs(args, site);\n\n        // Now call the WS.\n        const data: CoreSitePluginsGetContentWSParams = {\n            component: component,\n            method: method,\n            args: CoreUtils.objectToArrayOfObjects(argsToSend, 'name', 'value', true),\n        };\n\n        preSets = preSets || {};\n        preSets.cacheKey = this.getContentCacheKey(component, method, args);\n        preSets.updateFrequency = preSets.updateFrequency ?? CoreSite.FREQUENCY_OFTEN;\n\n        const result = await site.read<CoreSitePluginsGetContentWSResponse>('tool_mobile_get_content', data, preSets);\n\n        let otherData: Record<string, unknown> = {};\n        if (result.otherdata) {\n            otherData = <Record<string, unknown>> CoreUtils.objectToKeyValueMap(result.otherdata, 'name', 'value');\n\n            // Try to parse all properties that could be JSON encoded strings.\n            for (const name in otherData) {\n                const value = otherData[name];\n\n                if (typeof value == 'string' && (value[0] == '{' || value[0] == '[')) {\n                    otherData[name] = CoreTextUtils.parseJSON(value);\n                }\n            }\n        }\n\n        return Object.assign(result, { otherdata: otherData });\n    }\n\n    /**\n     * Get cache key for get content WS calls.\n     *\n     * @param component Component where the class is. E.g. mod_assign.\n     * @param method Method to execute in the class.\n     * @param args The params for the method.\n     * @returns Cache key.\n     */\n    protected getContentCacheKey(component: string, method: string, args: Record<string, unknown>): string {\n        return ROOT_CACHE_KEY + 'content:' + component + ':' + method + ':' + CoreUtils.sortAndStringify(args);\n    }\n\n    /**\n     * Get the value of a WS param for prefetch.\n     *\n     * @param component The component of the handler.\n     * @param paramName Name of the param as defined by the handler.\n     * @param courseId Course ID (if prefetching a course).\n     * @param module The module object returned by WS (if prefetching a module).\n     * @returns The value.\n     */\n    protected getDownloadParam(\n        component: string,\n        paramName: string,\n        courseId?: number,\n        module?: CoreCourseAnyModuleData,\n    ): [number] | number | undefined {\n        switch (paramName) {\n            case 'courseids':\n                // The WS needs the list of course IDs. Create the list.\n                return [courseId || 0];\n\n            case component + 'id':\n                // The WS needs the instance id.\n                return module && module.instance;\n\n            default:\n                // No more params supported for now.\n        }\n    }\n\n    /**\n     * Get the unique name of a handler (plugin + handler).\n     *\n     * @param plugin Data of the plugin.\n     * @param handlerName Name of the handler inside the plugin.\n     * @returns Unique name.\n     */\n    getHandlerUniqueName(plugin: CoreSitePluginsPlugin, handlerName: string): string {\n        return plugin.addon + '_' + handlerName;\n    }\n\n    /**\n     * Get site plugins for site.\n     *\n     * @param siteId Site ID.\n     * @returns Promise resolved with the plugins.\n     */\n    async getPlugins(siteId?: string): Promise<CoreSitePluginsPlugin[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        // Get the list of plugins. Try not to use cache.\n        const data = await site.read<CoreSitePluginsGetPluginsSupportingMobileWSResponse>(\n            'tool_mobile_get_plugins_supporting_mobile',\n            {},\n            {\n                getFromCache: false,\n                cacheKey: this.getPluginsCacheKey(),\n            },\n        );\n\n        // Return enabled plugins.\n        return data.plugins.filter((plugin) => this.isSitePluginEnabled(plugin, site));\n    }\n\n    /**\n     * Get cache key for get plugins WS call.\n     *\n     * @returns Cache key.\n     */\n    protected getPluginsCacheKey(): string {\n        return ROOT_CACHE_KEY + 'plugins';\n    }\n\n    /**\n     * Get a site plugin handler.\n     *\n     * @param name Unique name of the handler.\n     * @returns Handler.\n     */\n    getSitePluginHandler(name: string): CoreSitePluginsHandler | undefined {\n        return this.sitePlugins[name];\n    }\n\n    /**\n     * Get the current site plugin list.\n     *\n     * @returns Plugin list ws info.\n     */\n    getCurrentSitePluginList(): CoreSitePluginsWSPlugin[] {\n        return CoreUtils.objectToArray(this.sitePlugins).map((plugin) => plugin.plugin);\n    }\n\n    /**\n     * Invalidate all WS call to a certain method.\n     *\n     * @param method WS method to use.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllCallWSForMethod(method: string, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getCallWSCommonCacheKey(method));\n    }\n\n    /**\n     * Invalidate a WS call.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCallWS(\n        method: string,\n        data: Record<string, unknown>,\n        preSets?: CoreSiteWSPreSets,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        preSets = preSets || {};\n\n        await site.invalidateWsCacheForKey(preSets.cacheKey || this.getCallWSCacheKey(method, data));\n    }\n\n    /**\n     * Invalidate a page content.\n     *\n     * @param component Component where the class is. E.g. mod_assign.\n     * @param callback Method to execute in the class.\n     * @param args The params for the method.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateContent(component: string, callback: string, args?: Record<string, unknown>, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getContentCacheKey(component, callback, args || {}));\n    }\n\n    /**\n     * Check if a handler is enabled for a certain course.\n     *\n     * @param courseId Course ID to check.\n     * @param restrictEnrolled If true or undefined, handler is only enabled for courses the user is enrolled in.\n     * @param restrict Users and courses the handler is restricted to.\n     * @returns Whether the handler is enabled.\n     */\n    async isHandlerEnabledForCourse(\n        courseId: number,\n        restrictEnrolled?: boolean,\n        restrict?: CoreSitePluginsContentRestrict,\n    ): Promise<boolean> {\n        if (restrict?.courses?.indexOf(courseId) == -1) {\n            // Course is not in the list of restricted courses.\n            return false;\n        }\n\n        if (restrictEnrolled || restrictEnrolled === undefined) {\n            // Only enabled for courses the user is enrolled to. Check if the user is enrolled in the course.\n            try {\n                await CoreCourses.getUserCourse(courseId, true);\n            } catch {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if a handler is enabled for a certain user.\n     *\n     * @param userId User ID to check.\n     * @param restrictCurrent Whether handler is only enabled for current user.\n     * @param restrict Users and courses the handler is restricted to.\n     * @returns Whether the handler is enabled.\n     */\n    isHandlerEnabledForUser(userId: number, restrictCurrent?: boolean, restrict?: CoreSitePluginsContentRestrict): boolean {\n        if (restrictCurrent && userId != CoreSites.getCurrentSite()?.getUserId()) {\n            // Only enabled for current user.\n            return false;\n        }\n\n        if (restrict?.users?.indexOf(userId) == -1) {\n            // User is not in the list of restricted users.\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if a certain plugin is a site plugin and it's enabled in a certain site.\n     *\n     * @param plugin Data of the plugin.\n     * @param site Site affected.\n     * @returns Whether it's a site plugin and it's enabled.\n     */\n    isSitePluginEnabled(plugin: CoreSitePluginsPlugin, site: CoreSite): boolean {\n        if (site.isFeatureDisabled('sitePlugin_' + plugin.component + '_' + plugin.addon) || !plugin.handlers) {\n            return false;\n        }\n\n        // Site plugin not disabled. Check if it has handlers.\n        if (!plugin.parsedHandlers) {\n            plugin.parsedHandlers = CoreTextUtils.parseJSON(\n                plugin.handlers,\n                null,\n                error => this.logger.error('Error parsing site plugin handlers', error),\n            );\n        }\n\n        return !!(plugin.parsedHandlers && Object.keys(plugin.parsedHandlers).length);\n    }\n\n    /**\n     * Load other data into args as determined by useOtherData list.\n     * If useOtherData is undefined, it won't add any data.\n     * If useOtherData is an array, it will only copy the properties whose names are in the array.\n     * If useOtherData is any other value, it will copy all the data from otherData to args.\n     *\n     * @param args The current args.\n     * @param otherData All the other data.\n     * @param useOtherData Names of the attributes to include.\n     * @returns New args.\n     */\n    loadOtherDataInArgs(\n        args: Record<string, unknown> | undefined,\n        otherData?: Record<string, unknown>,\n        useOtherData?: string[] | unknown,\n    ): Record<string, unknown> {\n        if (!args) {\n            args = {};\n        } else {\n            args = CoreUtils.clone(args);\n        }\n\n        otherData = otherData || {};\n\n        if (useOtherData === undefined) {\n            // No need to add other data, return args as they are.\n            return args;\n        } else if (Array.isArray(useOtherData)) {\n            // Include only the properties specified in the array.\n            for (const i in useOtherData) {\n                const name = useOtherData[i];\n\n                if (typeof otherData[name] == 'object' && otherData[name] !== null) {\n                    // Stringify objects.\n                    args[name] = JSON.stringify(otherData[name]);\n                } else {\n                    args[name] = otherData[name];\n                }\n            }\n        } else {\n            // Add all the data to args.\n            for (const name in otherData) {\n                if (typeof otherData[name] == 'object' && otherData[name] !== null) {\n                    // Stringify objects.\n                    args[name] = JSON.stringify(otherData[name]);\n                } else {\n                    args[name] = otherData[name];\n                }\n            }\n        }\n\n        return args;\n    }\n\n    /**\n     * Prefetch offline functions for a site plugin handler.\n     *\n     * @param component The component of the handler.\n     * @param args Params to send to the get_content calls.\n     * @param handlerSchema The handler schema.\n     * @param courseId Course ID (if prefetching a course).\n     * @param module The module object returned by WS (if prefetching a module).\n     * @param prefetch True to prefetch, false to download right away.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @param site Site. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async prefetchFunctions(\n        component: string,\n        args: Record<string, unknown>,\n        handlerSchema: CoreSitePluginsCourseModuleHandlerData,\n        courseId?: number,\n        module?: CoreCourseAnyModuleData,\n        prefetch?: boolean,\n        dirPath?: string,\n        site?: CoreSite,\n    ): Promise<void> {\n        site = site || CoreSites.getCurrentSite();\n        if (!site || !handlerSchema.offlinefunctions) {\n            return;\n        }\n\n        const siteInstance = site;\n        const offlineFunctions = handlerSchema.offlinefunctions;\n\n        await Promise.all(Object.keys(handlerSchema.offlinefunctions).map(async(method) => {\n            if (siteInstance.wsAvailable(method)) {\n                // The method is a WS.\n                const paramsList = offlineFunctions[method];\n                const cacheKey = this.getCallWSCacheKey(method, args);\n                let params: Record<string, unknown> = {};\n\n                if (!paramsList.length) {\n                    // No params defined, send the default ones.\n                    params = args;\n                } else {\n                    for (const i in paramsList) {\n                        const paramName = paramsList[i];\n\n                        if (args[paramName] !== undefined) {\n                            params[paramName] = args[paramName];\n                        } else {\n                            // The param is not one of the default ones. Try to calculate the param to use.\n                            const value = this.getDownloadParam(component, paramName, courseId, module);\n                            if (value !== undefined) {\n                                params[paramName] = value;\n                            }\n                        }\n                    }\n                }\n\n                await this.callWS(method, params, { cacheKey });\n\n                return;\n            }\n\n            // It's a method to get content.\n            const preSets: CoreSiteWSPreSets = {\n                component: component,\n            };\n            if (module) {\n                preSets.componentId = module.id;\n            }\n\n            const result = await this.getContent(component, method, args, preSets);\n\n            // Prefetch the files in the content.\n            if (result.files.length) {\n                await CoreFilepool.downloadOrPrefetchFiles(\n                    siteInstance.getId(),\n                    result.files,\n                    !!prefetch,\n                    false,\n                    component,\n                    module?.id,\n                    dirPath,\n                );\n            }\n        }));\n    }\n\n    /**\n     * Store a site plugin handler.\n     *\n     * @param name A unique name to identify the handler.\n     * @param handler Handler to set.\n     */\n    setSitePluginHandler(name: string, handler: CoreSitePluginsHandler): void {\n        this.sitePlugins[name] = handler;\n    }\n\n    /**\n     * Store the promise for a plugin that is being initialised.\n     *\n     * @param component Component name.\n     * @param promise Promise to register.\n     */\n    registerSitePluginPromise(component: string, promise: Promise<void>): void {\n        this.sitePluginPromises[component] = promise;\n    }\n\n    /**\n     * Set plugins fetched.\n     */\n    setPluginsFetched(): void {\n        this.fetchPluginsDeferred.resolve();\n    }\n\n    /**\n     * Set plugins fetched.\n     */\n    setPluginsLoaded(loaded?: boolean): void {\n        this.hasSitePluginsLoaded = !!loaded;\n    }\n\n    /**\n     * Is a plugin being initialised for the specified component?\n     *\n     * @param component Component name.\n     * @returns If site plugin promise has been set.\n     */\n    sitePluginPromiseExists(component: string): boolean {\n        return !!this.sitePluginPromises[component];\n    }\n\n    /**\n     * Get the promise for a plugin that is being initialised.\n     *\n     * @param component Component name.\n     * @returns Plugin loaded promise.\n     */\n    sitePluginLoaded(component: string): Promise<void> | undefined {\n        return this.sitePluginPromises[component];\n    }\n\n    /**\n     * Wait for fetch plugins to be done.\n     *\n     * @returns Promise resolved when site plugins have been fetched.\n     */\n    async waitFetchPlugins(): Promise<void> {\n        await this.fetchPluginsDeferred;\n    }\n\n    /**\n     * Get a module hander instance, if present.\n     *\n     * @param modName Mod name without \"mod_\".\n     * @returns Handler instance, undefined if not found.\n     */\n    getModuleHandlerInstance(modName: string): CoreSitePluginsModuleHandler | undefined {\n        return this.moduleHandlerInstances[modName];\n    }\n\n    /**\n     * Set a module hander instance.\n     *\n     * @param modName Mod name.\n     * @param handler Handler instance.\n     */\n    setModuleHandlerInstance(modName: string, handler: CoreSitePluginsModuleHandler): void {\n        this.moduleHandlerInstances[modName] = handler;\n    }\n\n}\n\nexport const CoreSitePlugins = makeSingleton(CoreSitePluginsProvider);\n\n/**\n * Handler of a site plugin.\n */\nexport type CoreSitePluginsHandler = {\n    plugin: CoreSitePluginsPlugin; // Site plugin data.\n    handlerName: string; // Name of the handler.\n    handlerSchema: CoreSitePluginsHandlerData; // Handler's data.\n    initResult?: CoreSitePluginsContent | null; // Result of the init WS call (if any).\n};\n\n/**\n * Default args added to site plugins calls.\n */\nexport type CoreSitePluginsDefaultArgs = {\n    userid?: number;\n    appid: string;\n    appversioncode: number;\n    appversionname: string;\n    applang: string;\n    appcustomurlscheme: string;\n    appisdesktop: boolean;\n    appismobile: boolean;\n    appiswide: boolean;\n    appplatform: string;\n};\n\n/**\n * Params of tool_mobile_get_content WS.\n */\nexport type CoreSitePluginsGetContentWSParams = {\n    component: string; // Component where the class is e.g. mod_assign.\n    method: string; // Method to execute in class \\$component\\output\\mobile.\n    args?: { // Args for the method are optional.\n        name: string; // Param name.\n        value: string; // Param value.\n    }[];\n};\n\n/**\n * Data returned by tool_mobile_get_content WS.\n */\nexport type CoreSitePluginsGetContentWSResponse = {\n    templates: CoreSitePluginsContentTemplate[]; // Templates required by the generated content.\n    javascript: string; // JavaScript code.\n    otherdata: { // Other data that can be used or manipulated by the template via 2-way data-binding.\n        name: string; // Field name.\n        value: string; // Field value.\n    }[];\n    files: CoreWSExternalFile[];\n    restrict: CoreSitePluginsContentRestrict; // Restrict this content to certain users or courses.\n    disabled?: boolean; // Whether we consider this disabled or not.\n};\n\n/**\n * Template data returned by tool_mobile_get_content WS.\n */\nexport type CoreSitePluginsContentTemplate = {\n    id: string; // ID of the template.\n    html: string; // HTML code.\n};\n\n/**\n * Template data returned by tool_mobile_get_content WS.\n */\nexport type CoreSitePluginsContentRestrict = {\n    users?: number[]; // List of allowed users.\n    courses?: number[]; // List of allowed courses.\n};\n\n/**\n * Data returned by tool_mobile_get_content WS with calculated data.\n */\nexport type CoreSitePluginsContentParsed = Omit<CoreSitePluginsGetContentWSResponse, 'otherdata'> & {\n    otherdata: Record<string, unknown>; // Other data that can be used or manipulated by the template via 2-way data-binding.\n};\n\n/**\n * Data returned by tool_mobile_get_content WS with calculated data.\n */\nexport type CoreSitePluginsContent = CoreSitePluginsContentParsed & {\n    disabled?: boolean;\n    jsResult?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n};\n\n/**\n * Data returned by tool_mobile_get_plugins_supporting_mobile WS.\n */\nexport type CoreSitePluginsGetPluginsSupportingMobileWSResponse = {\n    plugins: CoreSitePluginsWSPlugin[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Plugin data returned by tool_mobile_get_plugins_supporting_mobile WS.\n */\nexport type CoreSitePluginsWSPlugin = {\n    component: string; // The plugin component name.\n    version: string; // The plugin version number.\n    addon: string; // The Mobile addon (package) name.\n    dependencies: string[]; // The list of Mobile addons this addon depends on.\n    fileurl: string; // The addon package url for download or empty if it doesn't exist.\n    filehash: string; // The addon package hash or empty if it doesn't exist.\n    filesize: number; // The addon package size or empty if it doesn't exist.\n    handlers?: string; // Handlers definition (JSON).\n    lang?: string; // Language strings used by the handlers (JSON).\n};\n\n/**\n * Plugin data with some calculated data.\n */\nexport type CoreSitePluginsPlugin = CoreSitePluginsWSPlugin & {\n    parsedHandlers?: Record<string, CoreSitePluginsHandlerData> | null;\n    parsedLang?: Record<string, string[]> | null;\n};\n\n/**\n * Plugin handler data.\n */\nexport type CoreSitePluginsHandlerData = CoreSitePluginsInitHandlerData | CoreSitePluginsCourseOptionHandlerData |\nCoreSitePluginsMainMenuHandlerData | CoreSitePluginsCourseModuleHandlerData | CoreSitePluginsCourseFormatHandlerData |\nCoreSitePluginsUserHandlerData | CoreSitePluginsSettingsHandlerData | CoreSitePluginsMessageOutputHandlerData |\nCoreSitePluginsBlockHandlerData | CoreSitePluginsMainMenuHomeHandlerData | CoreSitePluginsEnrolHandlerData;\n\n/**\n * Plugin handler data common to all delegates.\n */\nexport type CoreSitePluginsHandlerCommonData = {\n    delegate?: string;\n    method?: string;\n    init?: string;\n    restricttocurrentuser?: boolean;\n    restricttoenrolledcourses?: boolean;\n    styles?: {\n        url?: string;\n        version?: number;\n    };\n    moodlecomponent?: string;\n};\n\n/**\n * Course option handler specific data.\n */\nexport type CoreSitePluginsCourseOptionHandlerData = CoreSitePluginsHandlerCommonData & {\n    displaydata?: {\n        title?: string;\n        class?: string;\n        icon?: string;\n    };\n    priority?: number;\n    ismenuhandler?: boolean;\n    ptrenabled?: boolean;\n};\n\n/**\n * Main menu handler specific data.\n */\nexport type CoreSitePluginsMainMenuHandlerData = CoreSitePluginsHandlerCommonData & {\n    displaydata?: {\n        title?: string;\n        icon?: string;\n        class?: string;\n    };\n    priority?: number;\n    ptrenabled?: boolean;\n};\n\n/**\n * Course module handler specific data.\n */\nexport type CoreSitePluginsCourseModuleHandlerData = CoreSitePluginsHandlerCommonData & {\n    displaydata?: {\n        icon?: string;\n        class?: string;\n    };\n    method?: string;\n    offlinefunctions?: Record<string, string[]>;\n    downloadbutton?: boolean;\n    isresource?: boolean;\n    updatesnames?: string;\n    displayopeninbrowser?: boolean;\n    displaydescription?: boolean;\n    displayrefresh?: boolean;\n    displayprefetch?: boolean;\n    displaysize?: boolean;\n    displaygrades?: boolean;\n    coursepagemethod?: string;\n    ptrenabled?: boolean;\n    supportedfeatures?: Record<string, unknown>;\n    manualcompletionalwaysshown?: boolean;\n    nolinkhandlers?: boolean;\n    hascustomcmlistitem?: boolean;\n};\n\n/**\n * Course format handler specific data.\n */\nexport type CoreSitePluginsCourseFormatHandlerData = CoreSitePluginsHandlerCommonData & {\n    canviewallsections?: boolean;\n    displayenabledownload?: boolean;\n    displaycourseindex?: boolean;\n};\n\n/**\n * User handler specific data.\n */\nexport type CoreSitePluginsUserHandlerData = CoreSitePluginsHandlerCommonData & {\n    displaydata?: {\n        title?: string;\n        icon?: string;\n        class?: string;\n    };\n    type?: string;\n    priority?: number;\n    ptrenabled?: boolean;\n};\n\n/**\n * Settings handler specific data.\n */\nexport type CoreSitePluginsSettingsHandlerData = CoreSitePluginsHandlerCommonData & {\n    displaydata?: {\n        title?: string;\n        icon?: string;\n        class?: string;\n    };\n    priority?: number;\n    ptrenabled?: boolean;\n};\n\n/**\n * Message output handler specific data.\n */\nexport type CoreSitePluginsMessageOutputHandlerData = CoreSitePluginsHandlerCommonData & {\n    displaydata?: {\n        title?: string;\n        icon?: string;\n    };\n    priority?: number;\n    ptrenabled?: boolean;\n};\n\n/**\n * Block handler specific data.\n */\nexport type CoreSitePluginsBlockHandlerData = CoreSitePluginsHandlerCommonData & {\n    displaydata?: {\n        title?: string;\n        class?: string;\n        type?: string;\n    };\n    fallback?: string;\n};\n\n/**\n * Enrol handler specific data.\n */\nexport type CoreSitePluginsEnrolHandlerData = CoreSitePluginsHandlerCommonData & {\n    enrolmentAction?: CoreEnrolAction;\n    infoIcons?: CoreEnrolInfoIcon[];\n};\n\n/**\n * Common handler data with some data from the init method.\n */\nexport type CoreSitePluginsInitHandlerData = CoreSitePluginsHandlerCommonData & {\n    methodTemplates?: CoreSitePluginsContentTemplate[];\n    methodJSResult?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n    methodOtherdata?: Record<string, unknown>;\n};\n\n/**\n * Main menu home handler specific data.\n */\nexport type CoreSitePluginsMainMenuHomeHandlerData = CoreSitePluginsHandlerCommonData & {\n    displaydata?: {\n        title?: string;\n        class?: string;\n    };\n    priority?: number;\n    ptrenabled?: boolean;\n};\n\n/**\n * Event to update course content data for plugins using coursepagemethod.\n */\nexport type CoreSitePluginsUpdateCourseContentEvent = {\n    cmId: number; // Module ID to update.\n    alreadyFetched?: boolean; // Whether course data has already been fetched (no need to fetch it again).\n};\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [CoreSitePluginsProvider.UPDATE_COURSE_CONTENT]: CoreSitePluginsUpdateCourseContentEvent;\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}