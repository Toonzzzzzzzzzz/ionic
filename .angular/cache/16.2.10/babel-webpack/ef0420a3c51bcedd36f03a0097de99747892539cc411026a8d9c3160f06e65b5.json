{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _class;\nconst _excluded = [\"path\", \"matcher\"];\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { InjectionToken, Injector } from '@angular/core';\nimport { PreloadAllModules, RouterModule, ROUTES } from '@angular/router';\nimport { CoreArray } from '@singletons/array';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\n/**\n * Build app routes.\n *\n * @param injector Module injector.\n * @returns App routes.\n */\nfunction buildAppRoutes(injector) {\n  return CoreArray.flatten(injector.get(APP_ROUTES, []));\n}\n/**\n * Create a url matcher that will only match when a given condition is met.\n *\n * @param pathOrMatcher Original path or matcher configured in the route.\n * @param condition Condition.\n * @returns Conditional url matcher.\n */\nfunction buildConditionalUrlMatcher(pathOrMatcher, condition) {\n  // Create a matcher based on Angular's default matcher.\n  // see https://github.com/angular/angular/blob/10.0.x/packages/router/src/shared.ts#L127\n  return (segments, segmentGroup, route) => {\n    // If the condition isn't met, the route will never match.\n    if (!condition()) {\n      return null;\n    }\n    // Use existing matcher if any.\n    if (typeof pathOrMatcher === 'function') {\n      return pathOrMatcher(segments, segmentGroup, route);\n    }\n    const path = pathOrMatcher;\n    const parts = path.split('/');\n    const isFullMatch = route.pathMatch === 'full';\n    const posParams = {};\n    // The path matches anything.\n    if (path === '') {\n      return !isFullMatch || segments.length === 0 ? {\n        consumed: []\n      } : null;\n    }\n    // The actual URL is shorter than the config, no match.\n    if (parts.length > segments.length) {\n      return null;\n    }\n    // The config is longer than the actual URL but we are looking for a full match, return null.\n    if (isFullMatch && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n      return null;\n    }\n    // Check each config part against the actual URL.\n    for (let index = 0; index < parts.length; index++) {\n      const part = parts[index];\n      const segment = segments[index];\n      const isParameter = part.startsWith(':');\n      if (isParameter) {\n        posParams[part.substring(1)] = segment;\n      } else if (part !== segment.path) {\n        // The actual URL part does not match the config, no match.\n        return null;\n      }\n    }\n    // Return consumed segments with params.\n    return {\n      consumed: segments.slice(0, parts.length),\n      posParams\n    };\n  };\n}\n/**\n * Build url matcher using a regular expression.\n *\n * @param regexp Regular expression.\n * @returns Url matcher.\n */\nexport function buildRegExpUrlMatcher(regexp) {\n  return segments => {\n    var _regexp$exec;\n    // Ignore empty paths.\n    if (segments.length === 0) {\n      return null;\n    }\n    const path = segments.map(segment => segment.path).join('/');\n    const match = (_regexp$exec = regexp.exec(path)) === null || _regexp$exec === void 0 ? void 0 : _regexp$exec[0];\n    // Ignore paths that don't match the start of the url.\n    if (!match || !path.startsWith(match)) {\n      return null;\n    }\n    // Consume segments that match.\n    const [consumedSegments, consumedPath] = segments.slice(1).reduce(([segments, path], segment) => path === match ? [segments, path] : [segments.concat(segment), `${path}/${segment.path}`], [[segments[0]], segments[0].path]);\n    if (consumedPath !== match) {\n      return null;\n    }\n    return {\n      consumed: consumedSegments\n    };\n  };\n}\n/**\n * Configure routes so that they'll only match when a given condition is met.\n *\n * @param routes Routes.\n * @param condition Condition to determine if routes should be activated or not.\n * @returns Conditional routes.\n */\nexport function conditionalRoutes(routes, condition) {\n  return routes.map(route => {\n    // We need to remove the path from the route because Angular doesn't call the matcher for empty paths.\n    const {\n        path,\n        matcher\n      } = route,\n      newRoute = _objectWithoutProperties(route, _excluded);\n    const matcherOrPath = matcher !== null && matcher !== void 0 ? matcher : path;\n    if (matcherOrPath === undefined) {\n      throw new Error('Route defined without matcher nor path');\n    }\n    return _objectSpread(_objectSpread({}, newRoute), {}, {\n      matcher: buildConditionalUrlMatcher(matcherOrPath, condition)\n    });\n  });\n}\n/**\n * Resolve module routes.\n *\n * @param injector Module injector.\n * @param token Routes injection token.\n * @returns Routes.\n */\nexport function resolveModuleRoutes(injector, token) {\n  const configs = injector.get(token, []);\n  const routes = configs.map(config => {\n    if (Array.isArray(config)) {\n      return {\n        children: [],\n        siblings: config\n      };\n    }\n    return {\n      children: config.children || [],\n      siblings: config.siblings || []\n    };\n  });\n  return {\n    children: CoreArray.flatten(routes.map(r => r.children)),\n    siblings: CoreArray.flatten(routes.map(r => r.siblings))\n  };\n}\nexport const APP_ROUTES = new InjectionToken('APP_ROUTES');\nexport class AppRoutingModule {\n  static forChild(routes) {\n    return {\n      ngModule: AppRoutingModule,\n      providers: [{\n        provide: APP_ROUTES,\n        multi: true,\n        useValue: routes\n      }]\n    };\n  }\n}\n_class = AppRoutingModule;\n_class.ɵfac = function AppRoutingModule_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵmod = /*@__PURE__*/i0.ɵɵdefineNgModule({\n  type: _class\n});\n_class.ɵinj = /*@__PURE__*/i0.ɵɵdefineInjector({\n  providers: [{\n    provide: ROUTES,\n    multi: true,\n    useFactory: buildAppRoutes,\n    deps: [Injector]\n  }],\n  imports: [RouterModule.forRoot([], {\n    preloadingStrategy: PreloadAllModules\n  }), RouterModule]\n});\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(AppRoutingModule, {\n    imports: [i1.RouterModule],\n    exports: [RouterModule]\n  });\n})();","map":{"version":3,"names":["InjectionToken","Injector","PreloadAllModules","RouterModule","ROUTES","CoreArray","buildAppRoutes","injector","flatten","get","APP_ROUTES","buildConditionalUrlMatcher","pathOrMatcher","condition","segments","segmentGroup","route","path","parts","split","isFullMatch","pathMatch","posParams","length","consumed","hasChildren","index","part","segment","isParameter","startsWith","substring","slice","buildRegExpUrlMatcher","regexp","_regexp$exec","map","join","match","exec","consumedSegments","consumedPath","reduce","concat","conditionalRoutes","routes","matcher","newRoute","_objectWithoutProperties","_excluded","matcherOrPath","undefined","Error","_objectSpread","resolveModuleRoutes","token","configs","config","Array","isArray","children","siblings","r","AppRoutingModule","forChild","ngModule","providers","provide","multi","useValue","useFactory","deps","imports","forRoot","preloadingStrategy","i1","exports"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/app/app-routing.module.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { InjectionToken, Injector, ModuleWithProviders, NgModule, Type } from '@angular/core';\nimport {\n    PreloadAllModules,\n    RouterModule,\n    Route,\n    Routes,\n    ROUTES,\n    UrlMatcher,\n    UrlMatchResult,\n    UrlSegment,\n    UrlSegmentGroup,\n} from '@angular/router';\n\nimport { CoreArray } from '@singletons/array';\n\n/**\n * Build app routes.\n *\n * @param injector Module injector.\n * @returns App routes.\n */\nfunction buildAppRoutes(injector: Injector): Routes {\n    return CoreArray.flatten(injector.get<Routes[]>(APP_ROUTES, []));\n}\n\n/**\n * Create a url matcher that will only match when a given condition is met.\n *\n * @param pathOrMatcher Original path or matcher configured in the route.\n * @param condition Condition.\n * @returns Conditional url matcher.\n */\nfunction buildConditionalUrlMatcher(pathOrMatcher: string | UrlMatcher, condition: () => boolean): UrlMatcher {\n    // Create a matcher based on Angular's default matcher.\n    // see https://github.com/angular/angular/blob/10.0.x/packages/router/src/shared.ts#L127\n    return (segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult | null => {\n        // If the condition isn't met, the route will never match.\n        if (!condition()) {\n            return null;\n        }\n\n        // Use existing matcher if any.\n        if (typeof pathOrMatcher === 'function') {\n            return pathOrMatcher(segments, segmentGroup, route);\n        }\n\n        const path = pathOrMatcher;\n        const parts = path.split('/');\n        const isFullMatch = route.pathMatch === 'full';\n        const posParams: Record<string, UrlSegment> = {};\n\n        // The path matches anything.\n        if (path === '') {\n            return (!isFullMatch || segments.length === 0) ? { consumed: [] } : null;\n        }\n\n        // The actual URL is shorter than the config, no match.\n        if (parts.length > segments.length) {\n            return null;\n        }\n\n        // The config is longer than the actual URL but we are looking for a full match, return null.\n        if (isFullMatch && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n            return null;\n        }\n\n        // Check each config part against the actual URL.\n        for (let index = 0; index < parts.length; index++) {\n            const part = parts[index];\n            const segment = segments[index];\n            const isParameter = part.startsWith(':');\n\n            if (isParameter) {\n                posParams[part.substring(1)] = segment;\n            } else if (part !== segment.path) {\n                // The actual URL part does not match the config, no match.\n                return null;\n            }\n        }\n\n        // Return consumed segments with params.\n        return { consumed: segments.slice(0, parts.length), posParams };\n    };\n}\n\n/**\n * Type to declare lazy route modules.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type LazyRoutesModule = Type<any>;\n\n/**\n * Build url matcher using a regular expression.\n *\n * @param regexp Regular expression.\n * @returns Url matcher.\n */\nexport function buildRegExpUrlMatcher(regexp: RegExp): UrlMatcher {\n    return (segments: UrlSegment[]): UrlMatchResult | null => {\n        // Ignore empty paths.\n        if (segments.length === 0) {\n            return null;\n        }\n\n        const path = segments.map(segment => segment.path).join('/');\n        const match = regexp.exec(path)?.[0];\n\n        // Ignore paths that don't match the start of the url.\n        if (!match || !path.startsWith(match)) {\n            return null;\n        }\n\n        // Consume segments that match.\n        const [consumedSegments, consumedPath] = segments.slice(1).reduce(([segments, path], segment) => path === match\n            ? [segments, path]\n            : [\n                segments.concat(segment),\n                `${path}/${segment.path}`,\n            ], [[segments[0]] as UrlSegment[], segments[0].path]);\n\n        if (consumedPath !== match) {\n            return null;\n        }\n\n        return { consumed: consumedSegments };\n    };\n}\n\nexport type ModuleRoutes = { children: Routes; siblings: Routes };\nexport type ModuleRoutesConfig = Routes | Partial<ModuleRoutes>;\n\n/**\n * Configure routes so that they'll only match when a given condition is met.\n *\n * @param routes Routes.\n * @param condition Condition to determine if routes should be activated or not.\n * @returns Conditional routes.\n */\nexport function conditionalRoutes(routes: Routes, condition: () => boolean): Routes {\n    return routes.map(route => {\n        // We need to remove the path from the route because Angular doesn't call the matcher for empty paths.\n        const { path, matcher, ...newRoute } = route;\n        const matcherOrPath = matcher ?? path;\n\n        if (matcherOrPath === undefined) {\n            throw new Error('Route defined without matcher nor path');\n        }\n\n        return {\n            ...newRoute,\n            matcher: buildConditionalUrlMatcher(matcherOrPath, condition),\n        };\n    });\n}\n\n/**\n * Resolve module routes.\n *\n * @param injector Module injector.\n * @param token Routes injection token.\n * @returns Routes.\n */\nexport function resolveModuleRoutes(injector: Injector, token: InjectionToken<ModuleRoutesConfig[]>): ModuleRoutes {\n    const configs = injector.get(token, []);\n    const routes = configs.map(config => {\n        if (Array.isArray(config)) {\n            return {\n                children: [],\n                siblings: config,\n            };\n        }\n\n        return {\n            children: config.children || [],\n            siblings: config.siblings || [],\n        };\n    });\n\n    return {\n        children: CoreArray.flatten(routes.map(r => r.children)),\n        siblings: CoreArray.flatten(routes.map(r => r.siblings)),\n    };\n}\n\nexport const APP_ROUTES = new InjectionToken('APP_ROUTES');\n\n@NgModule({\n    imports: [\n        RouterModule.forRoot([], { preloadingStrategy: PreloadAllModules }),\n    ],\n    providers: [\n        { provide: ROUTES, multi: true, useFactory: buildAppRoutes, deps: [Injector] },\n    ],\n    exports: [RouterModule],\n})\nexport class AppRoutingModule {\n\n    static forChild(routes: Routes): ModuleWithProviders<AppRoutingModule> {\n        return {\n            ngModule: AppRoutingModule,\n            providers: [\n                { provide: APP_ROUTES, multi: true, useValue: routes },\n            ],\n        };\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}