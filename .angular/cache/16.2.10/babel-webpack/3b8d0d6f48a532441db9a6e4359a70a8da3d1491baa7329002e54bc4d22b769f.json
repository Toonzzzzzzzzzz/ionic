{"ast":null,"code":"var _class;\nimport { CoreDelegate } from '@classes/delegate';\nimport { CoreEvents } from '@singletons/events';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\n/**\n * Delegate to register handlers to be shown in the file picker.\n */\nexport class CoreFileUploaderDelegateService extends CoreDelegate {\n  constructor() {\n    super('CoreFileUploaderDelegate', true);\n    CoreEvents.on(CoreEvents.LOGOUT, () => this.clearSiteHandlers());\n  }\n  /**\n   * Clear current site handlers. Reserved for core use.\n   */\n  clearSiteHandlers() {\n    this.enabledHandlers = {};\n  }\n  /**\n   * Get the handlers for the current site.\n   *\n   * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n   * @returns List of handlers data.\n   */\n  getHandlers(mimetypes) {\n    const handlers = [];\n    for (const name in this.enabledHandlers) {\n      const handler = this.enabledHandlers[name];\n      let supportedMimetypes;\n      if (mimetypes) {\n        if (!handler.getSupportedMimetypes) {\n          // Handler doesn't implement a required function, don't add it.\n          continue;\n        }\n        supportedMimetypes = handler.getSupportedMimetypes(mimetypes);\n        if (!supportedMimetypes.length) {\n          // Handler doesn't support any mimetype, don't add it.\n          continue;\n        }\n      }\n      const data = handler.getData();\n      data.priority = handler.priority || 0;\n      data.mimetypes = supportedMimetypes;\n      handlers.push(data);\n    }\n    // Sort them by priority.\n    handlers.sort((a, b) => (a.priority || 0) <= (b.priority || 0) ? 1 : -1);\n    return handlers;\n  }\n}\n_class = CoreFileUploaderDelegateService;\n_class.ɵfac = function CoreFileUploaderDelegateService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFileUploaderDelegate = makeSingleton(CoreFileUploaderDelegateService);","map":{"version":3,"names":["CoreDelegate","CoreEvents","makeSingleton","CoreFileUploaderDelegateService","constructor","on","LOGOUT","clearSiteHandlers","enabledHandlers","getHandlers","mimetypes","handlers","name","handler","supportedMimetypes","getSupportedMimetypes","length","data","getData","priority","push","sort","a","b","factory","ɵfac","providedIn","CoreFileUploaderDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/fileuploader/services/fileuploader-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreWSUploadFileResult } from '@services/ws';\nimport { makeSingleton } from '@singletons';\n\n/**\n * Interface that all handlers must implement.\n */\nexport interface CoreFileUploaderHandler extends CoreDelegateHandler {\n    /**\n     * Handler's priority. The highest priority, the highest position.\n     */\n    priority?: number;\n\n    /**\n     * Given a list of mimetypes, return the ones that are supported by the handler.\n     *\n     * @param mimetypes List of mimetypes.\n     * @returns Supported mimetypes.\n     */\n    getSupportedMimetypes(mimetypes: string[]): string[];\n\n    /**\n     * Get the data to display the handler.\n     *\n     * @returns Data.\n     */\n    getData(): CoreFileUploaderHandlerData;\n}\n\n/**\n * Data needed to render the handler in the file picker. It must be returned by the handler.\n */\nexport interface CoreFileUploaderHandlerData {\n    /**\n     * The title to display in the handler.\n     */\n    title: string;\n\n    /**\n     * The icon to display in the handler.\n     */\n    icon?: string;\n\n    /**\n     * The class to assign to the handler item.\n     */\n    class?: string;\n\n    /**\n     * Action to perform when the handler is clicked.\n     *\n     * @param maxSize Max size of the file. If not defined or -1, no max size.\n     * @param upload Whether the file should be uploaded.\n     * @param allowOffline True to allow selecting in offline, false to require connection.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns Promise resolved with the result of picking/uploading the file.\n     */\n    action?(\n        maxSize?: number,\n        upload?: boolean,\n        allowOffline?: boolean,\n        mimetypes?: string[],\n    ): Promise<CoreFileUploaderHandlerResult>;\n\n    /**\n     * Function called after the handler is rendered.\n     *\n     * @param maxSize Max size of the file. If not defined or -1, no max size.\n     * @param upload Whether the file should be uploaded.\n     * @param allowOffline True to allow selecting in offline, false to require connection.\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     */\n    afterRender?(maxSize?: number, upload?: boolean, allowOffline?: boolean, mimetypes?: string[]): void;\n}\n\n/**\n * The result of clicking a handler.\n */\nexport interface CoreFileUploaderHandlerResult {\n    /**\n     * Whether the file was treated (uploaded or copied to tmp folder).\n     */\n    treated: boolean;\n\n    /**\n     * The path of the file picked. Required if treated=false and fileEntry is not set.\n     */\n    path?: string;\n\n    /**\n     * The fileEntry of the file picked. Required if treated=false and path is not set.\n     */\n    fileEntry?: FileEntry;\n\n    /**\n     * Whether the file should be deleted after the upload. Ignored if treated=true.\n     */\n    delete?: boolean;\n\n    /**\n     * The result of picking/uploading the file. Ignored if treated=false.\n     */\n    result?: CoreWSUploadFileResult | FileEntry;\n}\n\n/**\n * Data returned by the delegate for each handler.\n */\nexport interface CoreFileUploaderHandlerDataToReturn extends CoreFileUploaderHandlerData {\n    /**\n     * Handler's priority.\n     */\n    priority?: number;\n\n    /**\n     * Supported mimetypes.\n     */\n    mimetypes?: string[];\n}\n\n/**\n * Delegate to register handlers to be shown in the file picker.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFileUploaderDelegateService extends CoreDelegate<CoreFileUploaderHandler> {\n\n    constructor() {\n        super('CoreFileUploaderDelegate', true);\n\n        CoreEvents.on(CoreEvents.LOGOUT, () => this.clearSiteHandlers());\n    }\n\n    /**\n     * Clear current site handlers. Reserved for core use.\n     */\n    protected clearSiteHandlers(): void {\n        this.enabledHandlers = {};\n    }\n\n    /**\n     * Get the handlers for the current site.\n     *\n     * @param mimetypes List of supported mimetypes. If undefined, all mimetypes supported.\n     * @returns List of handlers data.\n     */\n    getHandlers(mimetypes?: string[]): CoreFileUploaderHandlerDataToReturn[] {\n        const handlers: CoreFileUploaderHandlerDataToReturn[] = [];\n\n        for (const name in this.enabledHandlers) {\n            const handler = this.enabledHandlers[name];\n            let supportedMimetypes: string[] | undefined;\n\n            if (mimetypes) {\n                if (!handler.getSupportedMimetypes) {\n                    // Handler doesn't implement a required function, don't add it.\n                    continue;\n                }\n\n                supportedMimetypes = handler.getSupportedMimetypes(mimetypes);\n\n                if (!supportedMimetypes.length) {\n                    // Handler doesn't support any mimetype, don't add it.\n                    continue;\n                }\n            }\n\n            const data: CoreFileUploaderHandlerDataToReturn = handler.getData();\n            data.priority = handler.priority || 0;\n            data.mimetypes = supportedMimetypes;\n            handlers.push(data);\n        }\n\n        // Sort them by priority.\n        handlers.sort((a, b) => (a.priority || 0) <= (b.priority || 0) ? 1 : -1);\n\n        return handlers;\n    }\n\n}\n\nexport const CoreFileUploaderDelegate = makeSingleton(CoreFileUploaderDelegateService);\n"],"mappings":";AAiBA,SAASA,YAAY,QAA6B,mBAAmB;AACrE,SAASC,UAAU,QAAQ,oBAAoB;AAE/C,SAASC,aAAa,QAAQ,aAAa;;AAsH3C;;;AAIA,OAAM,MAAOC,+BAAgC,SAAQH,YAAqC;EAEtFI,YAAA;IACI,KAAK,CAAC,0BAA0B,EAAE,IAAI,CAAC;IAEvCH,UAAU,CAACI,EAAE,CAACJ,UAAU,CAACK,MAAM,EAAE,MAAM,IAAI,CAACC,iBAAiB,EAAE,CAAC;EACpE;EAEA;;;EAGUA,iBAAiBA,CAAA;IACvB,IAAI,CAACC,eAAe,GAAG,EAAE;EAC7B;EAEA;;;;;;EAMAC,WAAWA,CAACC,SAAoB;IAC5B,MAAMC,QAAQ,GAA0C,EAAE;IAE1D,KAAK,MAAMC,IAAI,IAAI,IAAI,CAACJ,eAAe,EAAE;MACrC,MAAMK,OAAO,GAAG,IAAI,CAACL,eAAe,CAACI,IAAI,CAAC;MAC1C,IAAIE,kBAAwC;MAE5C,IAAIJ,SAAS,EAAE;QACX,IAAI,CAACG,OAAO,CAACE,qBAAqB,EAAE;UAChC;UACA;;QAGJD,kBAAkB,GAAGD,OAAO,CAACE,qBAAqB,CAACL,SAAS,CAAC;QAE7D,IAAI,CAACI,kBAAkB,CAACE,MAAM,EAAE;UAC5B;UACA;;;MAIR,MAAMC,IAAI,GAAwCJ,OAAO,CAACK,OAAO,EAAE;MACnED,IAAI,CAACE,QAAQ,GAAGN,OAAO,CAACM,QAAQ,IAAI,CAAC;MACrCF,IAAI,CAACP,SAAS,GAAGI,kBAAkB;MACnCH,QAAQ,CAACS,IAAI,CAACH,IAAI,CAAC;;IAGvB;IACAN,QAAQ,CAACU,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,CAACD,CAAC,CAACH,QAAQ,IAAI,CAAC,MAAMI,CAAC,CAACJ,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAExE,OAAOR,QAAQ;EACnB;;SApDSR,+BAAgC;;mBAAhCA,MAA+B;AAAA;;SAA/BA,MAA+B;EAAAqB,OAAA,EAA/BrB,MAA+B,CAAAsB,IAAA;EAAAC,UAAA,EADlB;AAAM;AAyDhC,OAAO,MAAMC,wBAAwB,GAAGzB,aAAa,CAACC,+BAA+B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}