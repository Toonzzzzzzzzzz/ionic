{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModChoiceOffline } from './choice-offline';\nimport { AddonModChoiceSyncProvider } from './choice-sync';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModChoice:';\n/**\n * Service that provides some features for choices.\n */\nexport class AddonModChoiceProvider {\n  /**\n   * Check if results can be seen by a student. The student can see the results if:\n   *     - they're always published, OR\n   *     - they're published after the choice is closed and it's closed, OR\n   *     - they're published after answering and the user has answered.\n   *\n   * @param choice Choice to check.\n   * @param hasAnswered True if user has answered the choice, false otherwise.\n   * @returns True if the students can see the results.\n   */\n  canStudentSeeResults(choice, hasAnswered) {\n    const now = Date.now();\n    return choice.showresults === AddonModChoiceProvider.RESULTS_ALWAYS || choice.showresults === AddonModChoiceProvider.RESULTS_AFTER_CLOSE && choice.timeclose && choice.timeclose <= now || choice.showresults === AddonModChoiceProvider.RESULTS_AFTER_ANSWER && hasAnswered;\n  }\n  /**\n   * Delete responses from a choice.\n   *\n   * @param choiceId Choice ID.\n   * @param name Choice name.\n   * @param courseId Course ID the choice belongs to.\n   * @param responses IDs of the answers. If not defined, delete all the answers of the current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if response was sent to server, false if stored in device.\n   */\n  deleteResponses(choiceId, name, courseId, responses = [], siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a message to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          yield AddonModChoiceOffline.saveResponse(choiceId, name, courseId, responses, true, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      // If there's already a response to be sent to the server, discard it first.\n      yield AddonModChoiceOffline.deleteResponse(choiceId, siteId);\n      try {\n        yield _this.deleteResponsesOnline(choiceId, responses, siteId);\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that responses cannot be submitted.\n          throw error;\n        }\n        // Couldn't connect to server, store in offline.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Delete responses from a choice. It will fail if offline or cannot connect.\n   *\n   * @param choiceId Choice ID.\n   * @param responses IDs of the answers. If not defined, delete all the answers of the current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when responses are successfully deleted.\n   */\n  deleteResponsesOnline(choiceId, responses, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        choiceid: choiceId,\n        responses: responses\n      };\n      const response = yield site.write('mod_choice_delete_choice_responses', params);\n      // Other errors ocurring.\n      if (response.status === false) {\n        var _response$warnings;\n        if ((_response$warnings = response.warnings) !== null && _response$warnings !== void 0 && _response$warnings[0]) {\n          throw new CoreWSError(response.warnings[0]);\n        }\n        throw new CoreError('Cannot delete responses.');\n      }\n      // Invalidate related data.\n      yield CoreUtils.ignoreErrors(Promise.all([_this2.invalidateOptions(choiceId, site.id), _this2.invalidateResults(choiceId, site.id)]));\n    })();\n  }\n  /**\n   * Get cache key for choice data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getChoiceDataCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'choice:' + courseId;\n  }\n  /**\n   * Get cache key for choice options WS calls.\n   *\n   * @param choiceId Choice ID.\n   * @returns Cache key.\n   */\n  getChoiceOptionsCacheKey(choiceId) {\n    return ROOT_CACHE_KEY + 'options:' + choiceId;\n  }\n  /**\n   * Get cache key for choice results WS calls.\n   *\n   * @param choiceId Choice ID.\n   * @returns Cache key.\n   */\n  getChoiceResultsCacheKey(choiceId) {\n    return ROOT_CACHE_KEY + 'results:' + choiceId;\n  }\n  /**\n   * Get a choice with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the choice is retrieved.\n   */\n  getChoiceByDataKey(courseId, key, value, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this3.getChoiceDataCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModChoiceProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_choice_get_choices_by_courses', params, preSets);\n      const currentChoice = response.choices.find(choice => choice[key] == value);\n      if (currentChoice) {\n        return currentChoice;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get a choice by course module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the choice is retrieved.\n   */\n  getChoice(courseId, cmId, options = {}) {\n    return this.getChoiceByDataKey(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a choice by ID.\n   *\n   * @param courseId Course ID.\n   * @param choiceId Choice ID.\n   * @param options Other options.\n   * @returns Promise resolved when the choice is retrieved.\n   */\n  getChoiceById(courseId, choiceId, options = {}) {\n    return this.getChoiceByDataKey(courseId, 'id', choiceId, options);\n  }\n  /**\n   * Get choice options.\n   *\n   * @param choiceId Choice ID.\n   * @param options Other options.\n   * @returns Promise resolved with choice options.\n   */\n  getOptions(choiceId, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        choiceid: choiceId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this4.getChoiceOptionsCacheKey(choiceId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModChoiceProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_choice_get_choice_options', params, preSets);\n      return response.options;\n    })();\n  }\n  /**\n   * Get choice results.\n   *\n   * @param choiceId Choice ID.\n   * @param options Other options.\n   * @returns Promise resolved with choice results.\n   */\n  getResults(choiceId, options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        choiceid: choiceId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this5.getChoiceOptionsCacheKey(choiceId),\n        component: AddonModChoiceProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_choice_get_choice_results', params, preSets);\n      return response.options;\n    })();\n  }\n  /**\n   * Invalidate choice data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateChoiceData(courseId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this6.getChoiceDataCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const choice = yield _this7.getChoice(courseId, moduleId);\n      yield Promise.all([_this7.invalidateChoiceData(courseId), _this7.invalidateOptions(choice.id), _this7.invalidateResults(choice.id), CoreFilepool.invalidateFilesByComponent(siteId, AddonModChoiceProvider.COMPONENT, moduleId)]);\n    })();\n  }\n  /**\n   * Invalidate choice options.\n   *\n   * @param choiceId Choice ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateOptions(choiceId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this8.getChoiceOptionsCacheKey(choiceId));\n    })();\n  }\n  /**\n   * Invalidate choice results.\n   *\n   * @param choiceId Choice ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateResults(choiceId, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this9.getChoiceResultsCacheKey(choiceId));\n    })();\n  }\n  /**\n   * Report the choice as being viewed.\n   *\n   * @param id Choice ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(id, siteId) {\n    const params = {\n      choiceid: id\n    };\n    return CoreCourseLogHelper.log('mod_choice_view_choice', params, AddonModChoiceProvider.COMPONENT, id, siteId);\n  }\n  /**\n   * Send a response to a choice to Moodle.\n   *\n   * @param choiceId Choice ID.\n   * @param name Choice name.\n   * @param courseId Course ID the choice belongs to.\n   * @param responses IDs of selected options.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if response was sent to server, false if stored in device.\n   */\n  submitResponse(choiceId, name, courseId, responses, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a message to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          yield AddonModChoiceOffline.saveResponse(choiceId, name, courseId, responses, false, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      // If there's already a response to be sent to the server, discard it first.\n      yield AddonModChoiceOffline.deleteResponse(choiceId, siteId);\n      try {\n        yield _this10.submitResponseOnline(choiceId, responses, siteId);\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that responses cannot be submitted.\n          throw error;\n        }\n        // Couldn't connect to server, store it offline.\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Send a response to a choice to Moodle. It will fail if offline or cannot connect.\n   *\n   * @param choiceId Choice ID.\n   * @param responses IDs of selected options.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when responses are successfully submitted.\n   */\n  submitResponseOnline(choiceId, responses, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        choiceid: choiceId,\n        responses: responses\n      };\n      yield site.write('mod_choice_submit_choice_response', params);\n      // Invalidate related data.\n      yield CoreUtils.ignoreErrors(Promise.all([_this11.invalidateOptions(choiceId, siteId), _this11.invalidateResults(choiceId, siteId)]));\n    })();\n  }\n}\n_class = AddonModChoiceProvider;\n_class.COMPONENT = 'mmaModChoice';\n_class.RESULTS_NOT = 0;\n_class.RESULTS_AFTER_ANSWER = 1;\n_class.RESULTS_AFTER_CLOSE = 2;\n_class.RESULTS_ALWAYS = 3;\n_class.PUBLISH_ANONYMOUS = false;\n_class.PUBLISH_NAMES = true;\n_class.ɵfac = function AddonModChoiceProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModChoice = makeSingleton(AddonModChoiceProvider);","map":{"version":3,"names":["CoreError","CoreWSError","CoreSite","CoreCourseLogHelper","CoreNetwork","CoreFilepool","CoreSites","CoreUtils","makeSingleton","Translate","AddonModChoiceOffline","AddonModChoiceSyncProvider","ROOT_CACHE_KEY","AddonModChoiceProvider","canStudentSeeResults","choice","hasAnswered","now","Date","showresults","RESULTS_ALWAYS","RESULTS_AFTER_CLOSE","timeclose","RESULTS_AFTER_ANSWER","deleteResponses","choiceId","name","courseId","responses","siteId","_this","_asyncToGenerator","getCurrentSiteId","storeOffline","_ref","saveResponse","apply","arguments","isOnline","deleteResponse","deleteResponsesOnline","error","isWebServiceError","_this2","site","getSite","params","choiceid","response","write","status","_response$warnings","warnings","ignoreErrors","Promise","all","invalidateOptions","id","invalidateResults","getChoiceDataCacheKey","getChoiceOptionsCacheKey","getChoiceResultsCacheKey","getChoiceByDataKey","key","value","options","_this3","courseids","preSets","_objectSpread","cacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","read","currentChoice","choices","find","instant","getChoice","cmId","getChoiceById","getOptions","_this4","componentId","getResults","_this5","invalidateChoiceData","_this6","invalidateWsCacheForKey","invalidateContent","moduleId","_this7","invalidateFilesByComponent","_this8","_this9","logView","log","submitResponse","_this10","_ref2","submitResponseOnline","_this11","_class","RESULTS_NOT","PUBLISH_ANONYMOUS","PUBLISH_NAMES","factory","ɵfac","providedIn","AddonModChoice"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/choice/services/choice.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesCommonWSOptions } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreStatusWithWarningsWSResponse, CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModChoiceOffline } from './choice-offline';\nimport { AddonModChoiceAutoSyncData, AddonModChoiceSyncProvider } from './choice-sync';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaModChoice:';\n\n/**\n * Service that provides some features for choices.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModChoiceProvider {\n\n    static readonly COMPONENT = 'mmaModChoice';\n\n    static readonly RESULTS_NOT = 0;\n    static readonly RESULTS_AFTER_ANSWER = 1;\n    static readonly RESULTS_AFTER_CLOSE = 2;\n    static readonly RESULTS_ALWAYS = 3;\n\n    static readonly PUBLISH_ANONYMOUS = false;\n    static readonly PUBLISH_NAMES = true;\n\n    /**\n     * Check if results can be seen by a student. The student can see the results if:\n     *     - they're always published, OR\n     *     - they're published after the choice is closed and it's closed, OR\n     *     - they're published after answering and the user has answered.\n     *\n     * @param choice Choice to check.\n     * @param hasAnswered True if user has answered the choice, false otherwise.\n     * @returns True if the students can see the results.\n     */\n    canStudentSeeResults(choice: AddonModChoiceChoice, hasAnswered: boolean): boolean {\n        const now = Date.now();\n\n        return choice.showresults === AddonModChoiceProvider.RESULTS_ALWAYS ||\n            choice.showresults === AddonModChoiceProvider.RESULTS_AFTER_CLOSE && choice.timeclose && choice.timeclose <= now ||\n            choice.showresults === AddonModChoiceProvider.RESULTS_AFTER_ANSWER && hasAnswered;\n    }\n\n    /**\n     * Delete responses from a choice.\n     *\n     * @param choiceId Choice ID.\n     * @param name Choice name.\n     * @param courseId Course ID the choice belongs to.\n     * @param responses IDs of the answers. If not defined, delete all the answers of the current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if response was sent to server, false if stored in device.\n     */\n    async deleteResponses(\n        choiceId: number,\n        name: string,\n        courseId: number,\n        responses: number[] = [],\n        siteId?: string,\n    ): Promise<boolean> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a message to be synchronized later.\n        const storeOffline = async (): Promise<boolean> => {\n            await AddonModChoiceOffline.saveResponse(choiceId, name, courseId, responses, true, siteId);\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        // If there's already a response to be sent to the server, discard it first.\n        await AddonModChoiceOffline.deleteResponse(choiceId, siteId);\n\n        try {\n            await this.deleteResponsesOnline(choiceId, responses, siteId);\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that responses cannot be submitted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store in offline.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Delete responses from a choice. It will fail if offline or cannot connect.\n     *\n     * @param choiceId Choice ID.\n     * @param responses IDs of the answers. If not defined, delete all the answers of the current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when responses are successfully deleted.\n     */\n    async deleteResponsesOnline(choiceId: number, responses?: number[], siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModChoiceDeleteChoiceResponsesWSParams = {\n            choiceid: choiceId,\n            responses: responses,\n        };\n\n        const response = await site.write<CoreStatusWithWarningsWSResponse>('mod_choice_delete_choice_responses', params);\n\n        // Other errors ocurring.\n        if (response.status === false) {\n            if (response.warnings?.[0]) {\n                throw new CoreWSError(response.warnings[0]);\n            }\n\n            throw new CoreError('Cannot delete responses.');\n        }\n\n        // Invalidate related data.\n        await CoreUtils.ignoreErrors(Promise.all([\n            this.invalidateOptions(choiceId, site.id),\n            this.invalidateResults(choiceId, site.id),\n        ]));\n    }\n\n    /**\n     * Get cache key for choice data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getChoiceDataCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'choice:' + courseId;\n    }\n\n    /**\n     * Get cache key for choice options WS calls.\n     *\n     * @param choiceId Choice ID.\n     * @returns Cache key.\n     */\n    protected getChoiceOptionsCacheKey(choiceId: number): string {\n        return ROOT_CACHE_KEY + 'options:' + choiceId;\n    }\n\n    /**\n     * Get cache key for choice results WS calls.\n     *\n     * @param choiceId Choice ID.\n     * @returns Cache key.\n     */\n    protected getChoiceResultsCacheKey(choiceId: number): string {\n        return ROOT_CACHE_KEY + 'results:' + choiceId;\n    }\n\n    /**\n     * Get a choice with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the choice is retrieved.\n     */\n    protected async getChoiceByDataKey(\n        courseId: number,\n        key: string,\n        value: unknown,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModChoiceChoice> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModChoiceGetChoicesByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getChoiceDataCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModChoiceProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModChoiceGetChoicesByCoursesWSResponse>(\n            'mod_choice_get_choices_by_courses',\n            params,\n            preSets,\n        );\n\n        const currentChoice = response.choices.find((choice) => choice[key] == value);\n        if (currentChoice) {\n            return currentChoice;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get a choice by course module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the choice is retrieved.\n     */\n    getChoice(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModChoiceChoice> {\n        return this.getChoiceByDataKey(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a choice by ID.\n     *\n     * @param courseId Course ID.\n     * @param choiceId Choice ID.\n     * @param options Other options.\n     * @returns Promise resolved when the choice is retrieved.\n     */\n    getChoiceById(courseId: number, choiceId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModChoiceChoice> {\n        return this.getChoiceByDataKey(courseId, 'id', choiceId, options);\n    }\n\n    /**\n     * Get choice options.\n     *\n     * @param choiceId Choice ID.\n     * @param options Other options.\n     * @returns Promise resolved with choice options.\n     */\n    async getOptions(choiceId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModChoiceOption[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModChoiceGetChoiceOptionsWSParams = {\n            choiceid: choiceId,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getChoiceOptionsCacheKey(choiceId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModChoiceProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModChoiceGetChoiceOptionsWSResponse>(\n            'mod_choice_get_choice_options',\n            params,\n            preSets,\n        );\n\n        return response.options;\n    }\n\n    /**\n     * Get choice results.\n     *\n     * @param choiceId Choice ID.\n     * @param options Other options.\n     * @returns Promise resolved with choice results.\n     */\n    async getResults(choiceId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModChoiceResult[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModChoiceGetChoiceResultsWSParams = {\n            choiceid: choiceId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getChoiceOptionsCacheKey(choiceId),\n            component: AddonModChoiceProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModChoiceGetChoiceResultsWSResponse>(\n            'mod_choice_get_choice_results',\n            params,\n            preSets,\n        );\n\n        return response.options;\n    }\n\n    /**\n     * Invalidate choice data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateChoiceData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getChoiceDataCacheKey(courseId));\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const choice = await this.getChoice(courseId, moduleId);\n\n        await Promise.all([\n            this.invalidateChoiceData(courseId),\n            this.invalidateOptions(choice.id),\n            this.invalidateResults(choice.id),\n            CoreFilepool.invalidateFilesByComponent(siteId, AddonModChoiceProvider.COMPONENT, moduleId),\n        ]);\n    }\n\n    /**\n     * Invalidate choice options.\n     *\n     * @param choiceId Choice ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateOptions(choiceId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getChoiceOptionsCacheKey(choiceId));\n    }\n\n    /**\n     * Invalidate choice results.\n     *\n     * @param choiceId Choice ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateResults(choiceId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getChoiceResultsCacheKey(choiceId));\n    }\n\n    /**\n     * Report the choice as being viewed.\n     *\n     * @param id Choice ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logView(id: number, siteId?: string): Promise<void> {\n        const params: AddonModChoiceViewChoiceWSParams = {\n            choiceid: id,\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_choice_view_choice',\n            params,\n            AddonModChoiceProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Send a response to a choice to Moodle.\n     *\n     * @param choiceId Choice ID.\n     * @param name Choice name.\n     * @param courseId Course ID the choice belongs to.\n     * @param responses IDs of selected options.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if response was sent to server, false if stored in device.\n     */\n    async submitResponse(choiceId: number, name: string, courseId: number, responses: number[], siteId?: string): Promise<boolean> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a message to be synchronized later.\n        const storeOffline = async (): Promise<boolean> => {\n            await AddonModChoiceOffline.saveResponse(choiceId, name, courseId, responses, false, siteId);\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        // If there's already a response to be sent to the server, discard it first.\n        await AddonModChoiceOffline.deleteResponse(choiceId, siteId);\n\n        try {\n            await this.submitResponseOnline(choiceId, responses, siteId);\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that responses cannot be submitted.\n                throw error;\n            }\n\n            // Couldn't connect to server, store it offline.\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Send a response to a choice to Moodle. It will fail if offline or cannot connect.\n     *\n     * @param choiceId Choice ID.\n     * @param responses IDs of selected options.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when responses are successfully submitted.\n     */\n    async submitResponseOnline(choiceId: number, responses: number[], siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModChoiceSubmitChoiceResponseWSParams = {\n            choiceid: choiceId,\n            responses: responses,\n        };\n\n        await site.write('mod_choice_submit_choice_response', params);\n\n        // Invalidate related data.\n        await CoreUtils.ignoreErrors(Promise.all([\n            this.invalidateOptions(choiceId, siteId),\n            this.invalidateResults(choiceId, siteId),\n        ]));\n    }\n\n}\n\nexport const AddonModChoice = makeSingleton(AddonModChoiceProvider);\n\n/**\n * Params of mod_choice_get_choices_by_courses WS.\n */\nexport type AddonModChoiceGetChoicesByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_choice_get_choices_by_courses WS.\n */\nexport type AddonModChoiceGetChoicesByCoursesWSResponse = {\n    choices: AddonModChoiceChoice[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Choice returned by mod_choice_get_choices_by_courses.\n */\nexport type AddonModChoiceChoice = {\n    id: number; // Choice instance id.\n    coursemodule: number; // Course module id.\n    course: number; // Course id.\n    name: string; // Choice name.\n    intro: string; // The choice intro.\n    introformat: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    publish?: boolean; // If choice is published.\n    showresults?: number; // 0 never, 1 after answer, 2 after close, 3 always.\n    display?: number; // Display mode (vertical, horizontal).\n    allowupdate?: boolean; // Allow update.\n    allowmultiple?: boolean; // Allow multiple choices.\n    showunanswered?: boolean; // Show users who not answered yet.\n    includeinactive?: boolean; // Include inactive users.\n    limitanswers?: boolean; // Limit unswers.\n    timeopen?: number; // Date of opening validity.\n    timeclose?: number; // Date of closing validity.\n    showpreview?: boolean; // Show preview before timeopen.\n    timemodified?: number; // Time of last modification.\n    completionsubmit?: boolean; // Completion on user submission.\n    showavailable?: boolean; // Show available spaces. @since 3.10\n    section?: number; // Course section id.\n    visible?: boolean; // Visible.\n    groupmode?: number; // Group mode.\n    groupingid?: number; // Group id.\n};\n\n/**\n * Params of mod_choice_delete_choice_responses WS.\n */\nexport type AddonModChoiceDeleteChoiceResponsesWSParams = {\n    choiceid: number; // Choice instance id.\n    responses?: number[]; // Array of response ids, empty for deleting all the current user responses.\n};\n\n/**\n * Params of mod_choice_get_choice_options WS.\n */\nexport type AddonModChoiceGetChoiceOptionsWSParams = {\n    choiceid: number; // Choice instance id.\n};\n\n/**\n * Data returned by mod_choice_get_choice_options WS.\n */\nexport type AddonModChoiceGetChoiceOptionsWSResponse = {\n    options: AddonModChoiceOption[]; // Options.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Option returned by mod_choice_get_choice_options.\n */\nexport type AddonModChoiceOption = {\n    id: number; // Option id.\n    text: string; // Text of the choice.\n    maxanswers: number; // Maximum number of answers.\n    displaylayout: boolean; // True for orizontal, otherwise vertical.\n    countanswers: number; // Number of answers.\n    checked: boolean; // We already answered.\n    disabled: boolean; // Option disabled.\n};\n\n/**\n * Params of mod_choice_get_choice_results WS.\n */\nexport type AddonModChoiceGetChoiceResultsWSParams = {\n    choiceid: number; // Choice instance id.\n};\n\n/**\n * Data returned by mod_choice_get_choice_results WS.\n */\nexport type AddonModChoiceGetChoiceResultsWSResponse = {\n    options: AddonModChoiceResult[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result returned by mod_choice_get_choice_results.\n */\nexport type AddonModChoiceResult = {\n    id: number; // Choice instance id.\n    text: string; // Text of the choice.\n    maxanswer: number; // Maximum number of answers.\n    userresponses: {\n        userid: number; // User id.\n        fullname: string; // User full name.\n        profileimageurl: string; // Profile user image url.\n        answerid?: number; // Answer id.\n        timemodified?: number; // Time of modification.\n    }[];\n    numberofuser: number; // Number of users answers.\n    percentageamount: number; // Percentage of users answers.\n};\n\n/**\n * Params of mod_choice_view_choice WS.\n */\nexport type AddonModChoiceViewChoiceWSParams = {\n    choiceid: number; // Choice instance id.\n};\n\n/**\n * Params of mod_choice_submit_choice_response WS.\n */\nexport type AddonModChoiceSubmitChoiceResponseWSParams = {\n    choiceid: number; // Choice instance id.\n    responses: number[]; // Array of response ids.\n};\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonModChoiceSyncProvider.AUTO_SYNCED]: AddonModChoiceAutoSyncData;\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}