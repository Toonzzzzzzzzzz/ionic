{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CorePushNotifications } from '@features/pushnotifications/services/pushnotifications';\nimport { CorePushNotificationsDelegate } from '@features/pushnotifications/services/push-delegate';\nimport { AddonNotifications, AddonNotificationsProvider } from '../notifications';\nimport { CoreMainMenuProvider } from '@features/mainmenu/services/mainmenu';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to inject an option into main menu.\n */\nexport class AddonNotificationsMainMenuHandlerService {\n  constructor() {\n    this.name = 'AddonNotifications';\n    this.priority = 600;\n    this.handlerData = {\n      icon: 'fas-bell',\n      title: 'addon.notifications.notifications',\n      page: AddonNotificationsMainMenuHandlerService.PAGE_NAME,\n      class: 'addon-notifications-handler',\n      showBadge: true,\n      badge: '',\n      badgeA11yText: 'addon.notifications.unreadnotification',\n      loading: true\n    };\n  }\n  /**\n   * Initialize the handler.\n   */\n  initialize() {\n    CoreEvents.on(AddonNotificationsProvider.READ_CHANGED_EVENT, data => {\n      this.updateBadge(data.siteId);\n    });\n    CoreEvents.on(AddonNotificationsProvider.READ_CRON_EVENT, data => {\n      this.updateBadge(data.siteId);\n    });\n    // Reset info on logout.\n    CoreEvents.on(CoreEvents.LOGOUT, () => {\n      this.handlerData.badge = '';\n      this.handlerData.loading = true;\n    });\n    // If a push notification is received, refresh the count.\n    CorePushNotificationsDelegate.on('receive').subscribe(notification => {\n      // New notification received. If it's from current site, refresh the data.\n      if (CoreUtils.isTrueOrOne(notification.notif) && CoreSites.isCurrentSite(notification.site)) {\n        this.updateBadge(notification.site);\n      }\n    });\n    // Register Badge counter.\n    CorePushNotificationsDelegate.registerCounterHandler(AddonNotificationsMainMenuHandlerService.name);\n  }\n  /**\n   * Check if the handler is enabled on a site level.\n   *\n   * @returns Whether or not the handler is enabled on a site level.\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  /**\n   * Returns the data needed to render the handler.\n   *\n   * @returns Data needed to render the handler.\n   */\n  getDisplayData() {\n    if (this.handlerData.loading) {\n      this.updateBadge();\n    }\n    return this.handlerData;\n  }\n  /**\n   * Triggers an update for the badge number and loading status. Mandatory if showBadge is enabled.\n   *\n   * @param siteId Site ID or current Site if undefined.\n   * @returns Promise resolved when done.\n   */\n  updateBadge(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!siteId) {\n        return;\n      }\n      try {\n        const unreadCountData = yield AddonNotifications.getUnreadNotificationsCount(undefined, siteId);\n        _this.handlerData.badge = unreadCountData.count > 0 ? unreadCountData.count + (unreadCountData.hasMore ? '+' : '') : '';\n        CorePushNotifications.updateAddonCounter(AddonNotificationsMainMenuHandlerService.name, unreadCountData.count, siteId);\n        CoreEvents.trigger(CoreMainMenuProvider.MAIN_MENU_HANDLER_BADGE_UPDATED, {\n          handler: AddonNotificationsMainMenuHandlerService.name,\n          value: unreadCountData.count\n        }, siteId);\n      } catch (_unused) {\n        _this.handlerData.badge = '';\n      } finally {\n        _this.handlerData.loading = false;\n      }\n    })();\n  }\n}\n_class = AddonNotificationsMainMenuHandlerService;\n_class.PAGE_NAME = 'notifications';\n_class.ɵfac = function AddonNotificationsMainMenuHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonNotificationsMainMenuHandler = makeSingleton(AddonNotificationsMainMenuHandlerService);","map":{"version":3,"names":["CoreSites","CoreUtils","makeSingleton","CoreEvents","CorePushNotifications","CorePushNotificationsDelegate","AddonNotifications","AddonNotificationsProvider","CoreMainMenuProvider","AddonNotificationsMainMenuHandlerService","constructor","name","priority","handlerData","icon","title","page","PAGE_NAME","class","showBadge","badge","badgeA11yText","loading","initialize","on","READ_CHANGED_EVENT","data","updateBadge","siteId","READ_CRON_EVENT","LOGOUT","subscribe","notification","isTrueOrOne","notif","isCurrentSite","site","registerCounterHandler","isEnabled","_asyncToGenerator","getDisplayData","_this","getCurrentSiteId","unreadCountData","getUnreadNotificationsCount","undefined","count","hasMore","updateAddonCounter","trigger","MAIN_MENU_HANDLER_BADGE_UPDATED","handler","value","_unused","_class","factory","ɵfac","providedIn","AddonNotificationsMainMenuHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/notifications/services/handlers/mainmenu.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreMainMenuHandler, CoreMainMenuHandlerData } from '@features/mainmenu/services/mainmenu-delegate';\nimport { CorePushNotifications } from '@features/pushnotifications/services/pushnotifications';\nimport { CorePushNotificationsDelegate } from '@features/pushnotifications/services/push-delegate';\nimport { AddonNotifications, AddonNotificationsProvider } from '../notifications';\nimport { CoreMainMenuProvider } from '@features/mainmenu/services/mainmenu';\n\n/**\n * Handler to inject an option into main menu.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonNotificationsMainMenuHandlerService implements CoreMainMenuHandler {\n\n    static readonly PAGE_NAME = 'notifications';\n\n    name = 'AddonNotifications';\n    priority = 600;\n\n    protected handlerData: CoreMainMenuHandlerData = {\n        icon: 'fas-bell',\n        title: 'addon.notifications.notifications',\n        page: AddonNotificationsMainMenuHandlerService.PAGE_NAME,\n        class: 'addon-notifications-handler',\n        showBadge: true,\n        badge: '',\n        badgeA11yText: 'addon.notifications.unreadnotification',\n        loading: true,\n    };\n\n    /**\n     * Initialize the handler.\n     */\n    initialize(): void {\n        CoreEvents.on(AddonNotificationsProvider.READ_CHANGED_EVENT, (data) => {\n            this.updateBadge(data.siteId);\n        });\n\n        CoreEvents.on(AddonNotificationsProvider.READ_CRON_EVENT, (data) => {\n            this.updateBadge(data.siteId);\n        });\n\n        // Reset info on logout.\n        CoreEvents.on(CoreEvents.LOGOUT, () => {\n            this.handlerData.badge = '';\n            this.handlerData.loading = true;\n        });\n\n        // If a push notification is received, refresh the count.\n        CorePushNotificationsDelegate.on('receive').subscribe((notification) => {\n            // New notification received. If it's from current site, refresh the data.\n            if (CoreUtils.isTrueOrOne(notification.notif) && CoreSites.isCurrentSite(notification.site)) {\n                this.updateBadge(notification.site);\n            }\n        });\n\n        // Register Badge counter.\n        CorePushNotificationsDelegate.registerCounterHandler(AddonNotificationsMainMenuHandlerService.name);\n    }\n\n    /**\n     * Check if the handler is enabled on a site level.\n     *\n     * @returns Whether or not the handler is enabled on a site level.\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * Returns the data needed to render the handler.\n     *\n     * @returns Data needed to render the handler.\n     */\n    getDisplayData(): CoreMainMenuHandlerData {\n        if (this.handlerData.loading) {\n            this.updateBadge();\n        }\n\n        return this.handlerData;\n    }\n\n    /**\n     * Triggers an update for the badge number and loading status. Mandatory if showBadge is enabled.\n     *\n     * @param siteId Site ID or current Site if undefined.\n     * @returns Promise resolved when done.\n     */\n    protected async updateBadge(siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n        if (!siteId) {\n            return;\n        }\n\n        try {\n            const unreadCountData = await AddonNotifications.getUnreadNotificationsCount(undefined, siteId);\n\n            this.handlerData.badge = unreadCountData.count > 0\n                ? unreadCountData.count + (unreadCountData.hasMore ? '+' : '')\n                : '';\n\n            CorePushNotifications.updateAddonCounter(AddonNotificationsMainMenuHandlerService.name, unreadCountData.count, siteId);\n\n            CoreEvents.trigger(\n                CoreMainMenuProvider.MAIN_MENU_HANDLER_BADGE_UPDATED,\n                {\n                    handler: AddonNotificationsMainMenuHandlerService.name,\n                    value: unreadCountData.count,\n                },\n                siteId,\n            );\n        } catch {\n            this.handlerData.badge = '';\n        } finally {\n            this.handlerData.loading = false;\n        }\n    }\n\n}\n\nexport const AddonNotificationsMainMenuHandler = makeSingleton(AddonNotificationsMainMenuHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}