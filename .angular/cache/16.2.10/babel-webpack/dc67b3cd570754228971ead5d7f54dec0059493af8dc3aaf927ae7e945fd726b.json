{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreXAPIOffline } from '@features/xapi/services/offline';\nimport { CoreXAPI, XAPI_STATE_DELETED } from '@features/xapi/services/xapi';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModH5PActivity, AddonModH5PActivityProvider } from './h5pactivity';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreXAPIIRI } from '@features/xapi/classes/iri';\nimport { CoreXAPIItemAgent } from '@features/xapi/classes/item-agent';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync H5P activities.\n */\nexport class AddonModH5PActivitySyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModH5PActivitySyncProvider');\n    this.componentTranslatableString = 'h5pactivity';\n  }\n  /**\n   * Try to synchronize all the H5P activities in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllActivities(siteId, force) {\n    return this.syncOnSites('H5P activities', siteId => this.syncAllActivitiesFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all H5P activities on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllActivitiesFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const [statements, states] = yield Promise.all([CoreXAPIOffline.getAllStatements(siteId), CoreXAPIOffline.getAllStates(siteId)]);\n      const entries = statements.concat(states);\n      const contextIds = CoreUtils.uniqueArray(entries.map(entry => 'contextid' in entry ? entry.contextid : entry.itemid));\n      // Sync all activities.\n      const promises = contextIds.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (contextId) {\n          const result = yield force ? _this.syncActivity(contextId, siteId) : _this.syncActivityIfNeeded(contextId, siteId);\n          if (result !== null && result !== void 0 && result.updated) {\n            // Sync successful, send event.\n            CoreEvents.trigger(AddonModH5PActivitySyncProvider.AUTO_SYNCED, {\n              contextId,\n              warnings: result.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Sync an H5P activity only if a certain time has passed since the last time.\n   *\n   * @param contextId Context ID of the activity.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the activity is synced or it doesn't need to be synced.\n   */\n  syncActivityIfNeeded(contextId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const needed = yield _this2.isSyncNeeded(contextId, siteId);\n      if (needed) {\n        return _this2.syncActivity(contextId, siteId);\n      }\n    })();\n  }\n  /**\n   * Synchronize an H5P activity. If it's already being synced it will reuse the same promise.\n   *\n   * @param contextId Context ID of the activity.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncActivity(contextId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    if (!CoreNetwork.isOnline()) {\n      // Cannot sync in offline.\n      throw new CoreNetworkError();\n    }\n    const currentSyncPromise = this.getOngoingSync(contextId, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for this discussion, return the promise.\n      return currentSyncPromise;\n    }\n    return this.addOngoingSync(contextId, this.syncActivityData(contextId, siteId), siteId);\n  }\n  /**\n   * Synchronize an H5P activity.\n   *\n   * @param contextId Context ID of the activity.\n   * @param siteId Site ID.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncActivityData(contextId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _ref4, _statements$find;\n      _this3.logger.debug(`Try to sync H5P activity with context ID '${contextId}'`);\n      let h5pActivity = null;\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Get all the statements stored for the activity.\n      const [statements, states] = yield Promise.all([CoreXAPIOffline.getContextStatements(contextId, siteId), CoreXAPIOffline.getItemStates(contextId, siteId)]);\n      const deleteOfflineData = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          yield Promise.all([statements.length ? CoreXAPIOffline.deleteStatementsForContext(contextId, siteId) : undefined, states.length ? CoreXAPIOffline.deleteStates(AddonModH5PActivityProvider.TRACK_COMPONENT, {\n            itemId: contextId,\n            siteId\n          }) : undefined]);\n          result.updated = true;\n        });\n        return function deleteOfflineData() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      const finishSync = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* () {\n          yield _this3.setSyncTime(contextId, siteId);\n          return result;\n        });\n        return function finishSync() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      if (!statements.length && !states.length) {\n        // Nothing to sync.\n        return finishSync();\n      }\n      // Get the activity instance.\n      const courseId = (_ref4 = (_statements$find = statements.find(statement => !!statement.courseid)) !== null && _statements$find !== void 0 ? _statements$find : states.find(state => !!state.courseid)) === null || _ref4 === void 0 ? void 0 : _ref4.courseid;\n      if (!courseId) {\n        // Data not valid (shouldn't happen), delete it.\n        yield deleteOfflineData();\n        return finishSync();\n      }\n      try {\n        h5pActivity = yield AddonModH5PActivity.getH5PActivityByContextId(courseId, contextId, {\n          siteId\n        });\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error) || CoreTextUtils.getErrorMessageFromError(error) === Translate.instant('core.course.modulenotfound')) {\n          // Activity no longer accessible. Delete the data and finish the sync.\n          yield deleteOfflineData();\n          return finishSync();\n        }\n        throw error;\n      }\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModH5PActivityProvider.COMPONENT, h5pActivity.id, siteId));\n      const results = yield Promise.all([_this3.syncStatements(h5pActivity.id, statements, siteId), _this3.syncStates(h5pActivity, states, siteId)]);\n      result.updated = results[0].updated || results[1].updated;\n      result.warnings = results[0].warnings.concat(results[1].warnings);\n      return finishSync();\n    })();\n  }\n  /**\n   * Sync statements.\n   *\n   * @param id H5P activity ID.\n   * @param statements Statements to sync.\n   * @param siteId Site ID.\n   * @returns Promise resolved with the sync result.\n   */\n  syncStatements(id, statements, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Send the statements in order.\n      for (let i = 0; i < statements.length; i++) {\n        const entry = statements[i];\n        try {\n          yield CoreXAPI.postStatementsOnline(entry.component, entry.statements, siteId);\n          result.updated = true;\n          yield CoreXAPIOffline.deleteStatements(entry.id, siteId);\n        } catch (error) {\n          if (!CoreUtils.isWebServiceError(error)) {\n            throw error;\n          }\n          // The WebService has thrown an error, this means that statements cannot be submitted. Delete them.\n          result.updated = true;\n          yield CoreXAPIOffline.deleteStatements(entry.id, siteId);\n          // Statements deleted, add a warning.\n          _this4.addOfflineDataDeletedWarning(result.warnings, entry.extra || '', error);\n        }\n      }\n      if (result.updated) {\n        // Data has been sent to server, invalidate attempts.\n        yield CoreUtils.ignoreErrors(AddonModH5PActivity.invalidateUserAttempts(id, undefined, siteId));\n      }\n      return result;\n    })();\n  }\n  /**\n   * Sync states.\n   *\n   * @param h5pActivity H5P activity instance.\n   * @param states States to sync.\n   * @param siteId Site ID.\n   * @returns Promise resolved with the sync result.\n   */\n  syncStates(h5pActivity, states, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      if (!states.length) {\n        return result;\n      }\n      const [site, activityIRI] = yield Promise.all([CoreSites.getSite(siteId), CoreXAPIIRI.generate(h5pActivity.context, 'activity', siteId)]);\n      const agent = JSON.stringify(CoreXAPIItemAgent.createFromSite(site).getData());\n      let lastAttempt;\n      try {\n        const attemptsData = yield AddonModH5PActivity.getUserAttempts(h5pActivity.id, {\n          cmId: h5pActivity.context,\n          readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */\n        });\n\n        lastAttempt = attemptsData.attempts.pop();\n      } catch (error) {\n        // Error getting attempts. If the WS has thrown an exception it means the user cannot retrieve the attempts for\n        // some reason (it shouldn't happen), continue synchronizing in that case.\n        if (!CoreUtils.isWebServiceError(error)) {\n          throw error;\n        }\n      }\n      yield Promise.all(states.map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (state) {\n          try {\n            if (lastAttempt && state.timecreated <= lastAttempt.timecreated) {\n              // State was created before the last attempt. It means the user finished an attempt in another device.\n              throw new CoreWSError({\n                message: Translate.instant('core.warningofflinedatadeletedreason'),\n                errorcode: 'offlinedataoutdated'\n              });\n            }\n            // Check if there is a newer state in LMS.\n            const onlineStates = yield CoreXAPI.getStatesSince(state.component, h5pActivity.context, {\n              registration: state.registration,\n              since: state.timecreated,\n              siteId\n            });\n            if (onlineStates.length) {\n              // There is newer data in the server, discard the offline data.\n              throw new CoreWSError({\n                message: Translate.instant('core.warningofflinedatadeletedreason'),\n                errorcode: 'offlinedataoutdated'\n              });\n            }\n            if (state.statedata === XAPI_STATE_DELETED) {\n              yield CoreXAPI.deleteStateOnline(state.component, activityIRI, agent, state.stateid, {\n                registration: state.registration,\n                siteId\n              });\n            } else if (state.statedata) {\n              yield CoreXAPI.postStateOnline(state.component, activityIRI, agent, state.stateid, state.statedata, {\n                registration: state.registration,\n                siteId\n              });\n            }\n            result.updated = true;\n            yield CoreXAPIOffline.deleteStates(state.component, {\n              itemId: h5pActivity.context,\n              stateId: state.stateid,\n              registration: state.registration,\n              siteId\n            });\n          } catch (error) {\n            if (!CoreUtils.isWebServiceError(error)) {\n              throw error;\n            }\n            // The WebService has thrown an error, this means the state cannot be submitted. Delete it.\n            result.updated = true;\n            yield CoreXAPIOffline.deleteStates(state.component, {\n              itemId: h5pActivity.context,\n              stateId: state.stateid,\n              registration: state.registration,\n              siteId\n            });\n            // State deleted, add a warning.\n            _this5.addOfflineDataDeletedWarning(result.warnings, state.extra || '', error);\n          }\n        });\n        return function (_x2) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n      return result;\n    })();\n  }\n}\n_class = AddonModH5PActivitySyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_h5pactivity_autom_synced';\n_class.ɵfac = function AddonModH5PActivitySyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModH5PActivitySync = makeSingleton(AddonModH5PActivitySyncProvider);","map":{"version":3,"names":["CoreNetworkError","CoreCourseActivitySyncBaseProvider","CoreCourseLogHelper","CoreXAPIOffline","CoreXAPI","XAPI_STATE_DELETED","CoreNetwork","CoreSites","CoreUtils","makeSingleton","Translate","CoreEvents","AddonModH5PActivity","AddonModH5PActivityProvider","CoreTextUtils","CoreXAPIIRI","CoreXAPIItemAgent","CoreWSError","AddonModH5PActivitySyncProvider","constructor","componentTranslatableString","syncAllActivities","siteId","force","syncOnSites","syncAllActivitiesFunc","_this","_asyncToGenerator","statements","states","Promise","all","getAllStatements","getAllStates","entries","concat","contextIds","uniqueArray","map","entry","contextid","itemid","promises","_ref","contextId","result","syncActivity","syncActivityIfNeeded","updated","trigger","AUTO_SYNCED","warnings","_x","apply","arguments","_this2","needed","isSyncNeeded","getCurrentSiteId","isOnline","currentSyncPromise","getOngoingSync","addOngoingSync","syncActivityData","_this3","_ref4","_statements$find","logger","debug","h5pActivity","getContextStatements","getItemStates","deleteOfflineData","_ref2","length","deleteStatementsForContext","undefined","deleteStates","TRACK_COMPONENT","itemId","finishSync","_ref3","setSyncTime","courseId","find","statement","courseid","state","getH5PActivityByContextId","error","isWebServiceError","getErrorMessageFromError","instant","ignoreErrors","COMPONENT","id","results","syncStatements","syncStates","_this4","i","postStatementsOnline","component","deleteStatements","addOfflineDataDeletedWarning","extra","invalidateUserAttempts","_this5","site","activityIRI","getSite","generate","context","agent","JSON","stringify","createFromSite","getData","lastAttempt","attemptsData","getUserAttempts","cmId","readingStrategy","attempts","pop","_ref5","timecreated","message","errorcode","onlineStates","getStatesSince","registration","since","statedata","deleteStateOnline","stateid","postStateOnline","stateId","_x2","_class","factory","ɵfac","providedIn","AddonModH5PActivitySync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/h5pactivity/services/h5pactivity-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreSyncResult } from '@services/sync';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreXAPIOffline } from '@features/xapi/services/offline';\nimport { CoreXAPI, XAPI_STATE_DELETED } from '@features/xapi/services/xapi';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport {\n    AddonModH5PActivity,\n    AddonModH5PActivityAttempt,\n    AddonModH5PActivityData,\n    AddonModH5PActivityProvider,\n} from './h5pactivity';\nimport { CoreXAPIStateDBRecord, CoreXAPIStatementDBRecord } from '@features/xapi/services/database/xapi';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreXAPIIRI } from '@features/xapi/classes/iri';\nimport { CoreXAPIItemAgent } from '@features/xapi/classes/item-agent';\nimport { CoreWSError } from '@classes/errors/wserror';\n\n/**\n * Service to sync H5P activities.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModH5PActivitySyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModH5PActivitySyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_h5pactivity_autom_synced';\n\n    protected componentTranslatableString = 'h5pactivity';\n\n    constructor() {\n        super('AddonModH5PActivitySyncProvider');\n    }\n\n    /**\n     * Try to synchronize all the H5P activities in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllActivities(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('H5P activities', (siteId) => this.syncAllActivitiesFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all H5P activities on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllActivitiesFunc(force: boolean, siteId?: string): Promise<void> {\n        const [statements, states] = await Promise.all([\n            CoreXAPIOffline.getAllStatements(siteId),\n            CoreXAPIOffline.getAllStates(siteId),\n        ]);\n\n        const entries = (<(CoreXAPIStatementDBRecord|CoreXAPIStateDBRecord)[]> statements).concat(states);\n        const contextIds = CoreUtils.uniqueArray(entries.map(entry => 'contextid' in entry ? entry.contextid : entry.itemid));\n\n        // Sync all activities.\n        const promises = contextIds.map(async (contextId) => {\n            const result = await (force ? this.syncActivity(contextId, siteId) :\n                this.syncActivityIfNeeded(contextId, siteId));\n\n            if (result?.updated) {\n                // Sync successful, send event.\n                CoreEvents.trigger(AddonModH5PActivitySyncProvider.AUTO_SYNCED, {\n                    contextId,\n                    warnings: result.warnings,\n                }, siteId);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Sync an H5P activity only if a certain time has passed since the last time.\n     *\n     * @param contextId Context ID of the activity.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the activity is synced or it doesn't need to be synced.\n     */\n    async syncActivityIfNeeded(contextId: number, siteId?: string): Promise<AddonModH5PActivitySyncResult | undefined> {\n        const needed = await this.isSyncNeeded(contextId, siteId);\n\n        if (needed) {\n            return this.syncActivity(contextId, siteId);\n        }\n    }\n\n    /**\n     * Synchronize an H5P activity. If it's already being synced it will reuse the same promise.\n     *\n     * @param contextId Context ID of the activity.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    syncActivity(contextId: number, siteId?: string): Promise<AddonModH5PActivitySyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        const currentSyncPromise = this.getOngoingSync(contextId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this discussion, return the promise.\n            return currentSyncPromise;\n        }\n\n        return this.addOngoingSync(contextId, this.syncActivityData(contextId, siteId), siteId);\n    }\n\n    /**\n     * Synchronize an H5P activity.\n     *\n     * @param contextId Context ID of the activity.\n     * @param siteId Site ID.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    protected async syncActivityData(contextId: number, siteId: string): Promise<AddonModH5PActivitySyncResult> {\n\n        this.logger.debug(`Try to sync H5P activity with context ID '${contextId}'`);\n\n        let h5pActivity: AddonModH5PActivityData | null = null;\n        const result: AddonModH5PActivitySyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Get all the statements stored for the activity.\n        const [statements, states] = await Promise.all([\n            CoreXAPIOffline.getContextStatements(contextId, siteId),\n            CoreXAPIOffline.getItemStates(contextId, siteId),\n        ]);\n\n        const deleteOfflineData = async (): Promise<void> => {\n            await Promise.all([\n                statements.length ? CoreXAPIOffline.deleteStatementsForContext(contextId, siteId) : undefined,\n                states.length ? CoreXAPIOffline.deleteStates(AddonModH5PActivityProvider.TRACK_COMPONENT, {\n                    itemId: contextId,\n                    siteId,\n                }) : undefined,\n            ]);\n\n            result.updated = true;\n        };\n        const finishSync = async (): Promise<AddonModH5PActivitySyncResult> => {\n            await this.setSyncTime(contextId, siteId);\n\n            return result;\n        };\n\n        if (!statements.length && !states.length) {\n            // Nothing to sync.\n            return finishSync();\n        }\n\n        // Get the activity instance.\n        const courseId = (statements.find(statement => !!statement.courseid) ?? states.find(state => !!state.courseid))?.courseid;\n        if (!courseId) {\n            // Data not valid (shouldn't happen), delete it.\n            await deleteOfflineData();\n\n            return finishSync();\n        }\n\n        try {\n            h5pActivity = await AddonModH5PActivity.getH5PActivityByContextId(courseId, contextId, { siteId });\n        } catch (error) {\n            if (\n                CoreUtils.isWebServiceError(error) ||\n                CoreTextUtils.getErrorMessageFromError(error) === Translate.instant('core.course.modulenotfound')\n            ) {\n                // Activity no longer accessible. Delete the data and finish the sync.\n                await deleteOfflineData();\n\n                return finishSync();\n            }\n\n            throw error;\n        }\n\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(\n            CoreCourseLogHelper.syncActivity(AddonModH5PActivityProvider.COMPONENT, h5pActivity.id, siteId),\n        );\n\n        const results = await Promise.all([\n            this.syncStatements(h5pActivity.id, statements, siteId),\n            this.syncStates(h5pActivity, states, siteId),\n        ]);\n\n        result.updated = results[0].updated || results[1].updated;\n        result.warnings = results[0].warnings.concat(results[1].warnings);\n\n        return finishSync();\n    }\n\n    /**\n     * Sync statements.\n     *\n     * @param id H5P activity ID.\n     * @param statements Statements to sync.\n     * @param siteId Site ID.\n     * @returns Promise resolved with the sync result.\n     */\n    protected async syncStatements(\n        id: number,\n        statements: CoreXAPIStatementDBRecord[],\n        siteId: string,\n    ): Promise<AddonModH5PActivitySyncResult> {\n        const result: AddonModH5PActivitySyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Send the statements in order.\n        for (let i = 0; i < statements.length; i++) {\n            const entry = statements[i];\n\n            try {\n                await CoreXAPI.postStatementsOnline(entry.component, entry.statements, siteId);\n\n                result.updated = true;\n\n                await CoreXAPIOffline.deleteStatements(entry.id, siteId);\n            } catch (error) {\n                if (!CoreUtils.isWebServiceError(error)) {\n                    throw error;\n                }\n\n                // The WebService has thrown an error, this means that statements cannot be submitted. Delete them.\n                result.updated = true;\n\n                await CoreXAPIOffline.deleteStatements(entry.id, siteId);\n\n                // Statements deleted, add a warning.\n                this.addOfflineDataDeletedWarning(result.warnings, entry.extra || '', error);\n            }\n        }\n\n        if (result.updated) {\n            // Data has been sent to server, invalidate attempts.\n            await CoreUtils.ignoreErrors(AddonModH5PActivity.invalidateUserAttempts(id, undefined, siteId));\n        }\n\n        return result;\n    }\n\n    /**\n     * Sync states.\n     *\n     * @param h5pActivity H5P activity instance.\n     * @param states States to sync.\n     * @param siteId Site ID.\n     * @returns Promise resolved with the sync result.\n     */\n    protected async syncStates(\n        h5pActivity: AddonModH5PActivityData,\n        states: CoreXAPIStateDBRecord[],\n        siteId: string,\n    ): Promise<AddonModH5PActivitySyncResult> {\n        const result: AddonModH5PActivitySyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        if (!states.length) {\n            return result;\n        }\n\n        const [site, activityIRI] = await Promise.all([\n            CoreSites.getSite(siteId),\n            CoreXAPIIRI.generate(h5pActivity.context, 'activity', siteId),\n        ]);\n        const agent = JSON.stringify(CoreXAPIItemAgent.createFromSite(site).getData());\n\n        let lastAttempt: AddonModH5PActivityAttempt | undefined;\n        try {\n            const attemptsData = await AddonModH5PActivity.getUserAttempts(h5pActivity.id, {\n                cmId: h5pActivity.context,\n                readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            });\n            lastAttempt = attemptsData.attempts.pop();\n        } catch (error) {\n            // Error getting attempts. If the WS has thrown an exception it means the user cannot retrieve the attempts for\n            // some reason (it shouldn't happen), continue synchronizing in that case.\n            if (!CoreUtils.isWebServiceError(error)) {\n                throw error;\n            }\n        }\n\n        await Promise.all(states.map(async (state) => {\n            try {\n                if (lastAttempt && state.timecreated <= lastAttempt.timecreated) {\n                    // State was created before the last attempt. It means the user finished an attempt in another device.\n                    throw new CoreWSError({\n                        message: Translate.instant('core.warningofflinedatadeletedreason'),\n                        errorcode: 'offlinedataoutdated',\n                    });\n                }\n\n                // Check if there is a newer state in LMS.\n                const onlineStates = await CoreXAPI.getStatesSince(state.component, h5pActivity.context, {\n                    registration: state.registration,\n                    since: state.timecreated,\n                    siteId,\n                });\n\n                if (onlineStates.length) {\n                    // There is newer data in the server, discard the offline data.\n                    throw new CoreWSError({\n                        message: Translate.instant('core.warningofflinedatadeletedreason'),\n                        errorcode: 'offlinedataoutdated',\n                    });\n                }\n\n                if (state.statedata === XAPI_STATE_DELETED) {\n                    await CoreXAPI.deleteStateOnline(state.component, activityIRI, agent, state.stateid, {\n                        registration: state.registration,\n                        siteId,\n                    });\n                } else if (state.statedata) {\n                    await CoreXAPI.postStateOnline(state.component, activityIRI, agent, state.stateid, state.statedata, {\n                        registration: state.registration,\n                        siteId,\n                    });\n                }\n\n                result.updated = true;\n\n                await CoreXAPIOffline.deleteStates(state.component, {\n                    itemId: h5pActivity.context,\n                    stateId: state.stateid,\n                    registration: state.registration,\n                    siteId,\n                });\n            } catch (error) {\n                if (!CoreUtils.isWebServiceError(error)) {\n                    throw error;\n                }\n\n                // The WebService has thrown an error, this means the state cannot be submitted. Delete it.\n                result.updated = true;\n\n                await CoreXAPIOffline.deleteStates(state.component, {\n                    itemId: h5pActivity.context,\n                    stateId: state.stateid,\n                    registration: state.registration,\n                    siteId,\n                });\n\n                // State deleted, add a warning.\n                this.addOfflineDataDeletedWarning(result.warnings, state.extra || '', error);\n            }\n        }));\n\n        return result;\n    }\n\n}\n\nexport const AddonModH5PActivitySync = makeSingleton(AddonModH5PActivitySyncProvider);\n\n/**\n * Sync result.\n */\nexport type AddonModH5PActivitySyncResult = CoreSyncResult;\n\n/**\n * Data passed to AUTO_SYNC event.\n */\nexport type AddonModH5PActivityAutoSyncData = {\n    contextId: number;\n    warnings: string[];\n};\n"],"mappings":";;AAgBA,SAASA,gBAAgB,QAAQ,+BAA+B;AAChE,SAASC,kCAAkC,QAAQ,wCAAwC;AAE3F,SAASC,mBAAmB,QAAQ,sCAAsC;AAC1E,SAASC,eAAe,QAAQ,iCAAiC;AACjE,SAASC,QAAQ,EAAEC,kBAAkB,QAAQ,8BAA8B;AAC3E,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,SAAS,QAAkC,iBAAiB;AACrE,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,aAAa,EAAEC,SAAS,QAAQ,aAAa;AACtD,SAASC,UAAU,QAAQ,oBAAoB;AAC/C,SACIC,mBAAmB,EAGnBC,2BAA2B,QACxB,eAAe;AAEtB,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,WAAW,QAAQ,4BAA4B;AACxD,SAASC,iBAAiB,QAAQ,mCAAmC;AACrE,SAASC,WAAW,QAAQ,yBAAyB;;AAErD;;;AAIA,OAAM,MAAOC,+BAAgC,SAAQjB,kCAAiE;EAMlHkB,YAAA;IACI,KAAK,CAAC,iCAAiC,CAAC;IAHlC,KAAAC,2BAA2B,GAAG,aAAa;EAIrD;EAEA;;;;;;;EAOAC,iBAAiBA,CAACC,MAAe,EAAEC,KAAe;IAC9C,OAAO,IAAI,CAACC,WAAW,CAAC,gBAAgB,EAAGF,MAAM,IAAK,IAAI,CAACG,qBAAqB,CAAC,CAAC,CAACF,KAAK,EAAED,MAAM,CAAC,EAAEA,MAAM,CAAC;EAC9G;EAEA;;;;;;;EAOgBG,qBAAqBA,CAACF,KAAc,EAAED,MAAe;IAAA,IAAAI,KAAA;IAAA,OAAAC,iBAAA;MACjE,MAAM,CAACC,UAAU,EAAEC,MAAM,CAAC,SAASC,OAAO,CAACC,GAAG,CAAC,CAC3C5B,eAAe,CAAC6B,gBAAgB,CAACV,MAAM,CAAC,EACxCnB,eAAe,CAAC8B,YAAY,CAACX,MAAM,CAAC,CACvC,CAAC;MAEF,MAAMY,OAAO,GAA0DN,UAAW,CAACO,MAAM,CAACN,MAAM,CAAC;MACjG,MAAMO,UAAU,GAAG5B,SAAS,CAAC6B,WAAW,CAACH,OAAO,CAACI,GAAG,CAACC,KAAK,IAAI,WAAW,IAAIA,KAAK,GAAGA,KAAK,CAACC,SAAS,GAAGD,KAAK,CAACE,MAAM,CAAC,CAAC;MAErH;MACA,MAAMC,QAAQ,GAAGN,UAAU,CAACE,GAAG;QAAA,IAAAK,IAAA,GAAAhB,iBAAA,CAAC,WAAOiB,SAAS,EAAI;UAChD,MAAMC,MAAM,SAAUtB,KAAK,GAAGG,KAAI,CAACoB,YAAY,CAACF,SAAS,EAAEtB,MAAM,CAAC,GAC9DI,KAAI,CAACqB,oBAAoB,CAACH,SAAS,EAAEtB,MAAM,CAAE;UAEjD,IAAIuB,MAAM,aAANA,MAAM,eAANA,MAAM,CAAEG,OAAO,EAAE;YACjB;YACArC,UAAU,CAACsC,OAAO,CAAC/B,+BAA+B,CAACgC,WAAW,EAAE;cAC5DN,SAAS;cACTO,QAAQ,EAAEN,MAAM,CAACM;aACpB,EAAE7B,MAAM,CAAC;;QAElB,CAAC;QAAA,iBAAA8B,EAAA;UAAA,OAAAT,IAAA,CAAAU,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC;MAEF,MAAMxB,OAAO,CAACC,GAAG,CAACW,QAAQ,CAAC;IAAC;EAChC;EAEA;;;;;;;EAOMK,oBAAoBA,CAACH,SAAiB,EAAEtB,MAAe;IAAA,IAAAiC,MAAA;IAAA,OAAA5B,iBAAA;MACzD,MAAM6B,MAAM,SAASD,MAAI,CAACE,YAAY,CAACb,SAAS,EAAEtB,MAAM,CAAC;MAEzD,IAAIkC,MAAM,EAAE;QACR,OAAOD,MAAI,CAACT,YAAY,CAACF,SAAS,EAAEtB,MAAM,CAAC;;IAC9C;EACL;EAEA;;;;;;;EAOAwB,YAAYA,CAACF,SAAiB,EAAEtB,MAAe;IAC3CA,MAAM,GAAGA,MAAM,IAAIf,SAAS,CAACmD,gBAAgB,EAAE;IAE/C,IAAI,CAACpD,WAAW,CAACqD,QAAQ,EAAE,EAAE;MACzB;MACA,MAAM,IAAI3D,gBAAgB,EAAE;;IAGhC,MAAM4D,kBAAkB,GAAG,IAAI,CAACC,cAAc,CAACjB,SAAS,EAAEtB,MAAM,CAAC;IACjE,IAAIsC,kBAAkB,EAAE;MACpB;MACA,OAAOA,kBAAkB;;IAG7B,OAAO,IAAI,CAACE,cAAc,CAAClB,SAAS,EAAE,IAAI,CAACmB,gBAAgB,CAACnB,SAAS,EAAEtB,MAAM,CAAC,EAAEA,MAAM,CAAC;EAC3F;EAEA;;;;;;;EAOgByC,gBAAgBA,CAACnB,SAAiB,EAAEtB,MAAc;IAAA,IAAA0C,MAAA;IAAA,OAAArC,iBAAA;MAAA,IAAAsC,KAAA,EAAAC,gBAAA;MAE9DF,MAAI,CAACG,MAAM,CAACC,KAAK,CAAC,6CAA6CxB,SAAS,GAAG,CAAC;MAE5E,IAAIyB,WAAW,GAAmC,IAAI;MACtD,MAAMxB,MAAM,GAAkC;QAC1CM,QAAQ,EAAE,EAAE;QACZH,OAAO,EAAE;OACZ;MAED;MACA,MAAM,CAACpB,UAAU,EAAEC,MAAM,CAAC,SAASC,OAAO,CAACC,GAAG,CAAC,CAC3C5B,eAAe,CAACmE,oBAAoB,CAAC1B,SAAS,EAAEtB,MAAM,CAAC,EACvDnB,eAAe,CAACoE,aAAa,CAAC3B,SAAS,EAAEtB,MAAM,CAAC,CACnD,CAAC;MAEF,MAAMkD,iBAAiB;QAAA,IAAAC,KAAA,GAAA9C,iBAAA,CAAG,aAA0B;UAChD,MAAMG,OAAO,CAACC,GAAG,CAAC,CACdH,UAAU,CAAC8C,MAAM,GAAGvE,eAAe,CAACwE,0BAA0B,CAAC/B,SAAS,EAAEtB,MAAM,CAAC,GAAGsD,SAAS,EAC7F/C,MAAM,CAAC6C,MAAM,GAAGvE,eAAe,CAAC0E,YAAY,CAAChE,2BAA2B,CAACiE,eAAe,EAAE;YACtFC,MAAM,EAAEnC,SAAS;YACjBtB;WACH,CAAC,GAAGsD,SAAS,CACjB,CAAC;UAEF/B,MAAM,CAACG,OAAO,GAAG,IAAI;QACzB,CAAC;QAAA,gBAVKwB,iBAAiBA,CAAA;UAAA,OAAAC,KAAA,CAAApB,KAAA,OAAAC,SAAA;QAAA;MAAA,GAUtB;MACD,MAAM0B,UAAU;QAAA,IAAAC,KAAA,GAAAtD,iBAAA,CAAG,aAAmD;UAClE,MAAMqC,MAAI,CAACkB,WAAW,CAACtC,SAAS,EAAEtB,MAAM,CAAC;UAEzC,OAAOuB,MAAM;QACjB,CAAC;QAAA,gBAJKmC,UAAUA,CAAA;UAAA,OAAAC,KAAA,CAAA5B,KAAA,OAAAC,SAAA;QAAA;MAAA,GAIf;MAED,IAAI,CAAC1B,UAAU,CAAC8C,MAAM,IAAI,CAAC7C,MAAM,CAAC6C,MAAM,EAAE;QACtC;QACA,OAAOM,UAAU,EAAE;;MAGvB;MACA,MAAMG,QAAQ,IAAAlB,KAAA,IAAAC,gBAAA,GAAItC,UAAU,CAACwD,IAAI,CAACC,SAAS,IAAI,CAAC,CAACA,SAAS,CAACC,QAAQ,CAAC,cAAApB,gBAAA,cAAAA,gBAAA,GAAIrC,MAAM,CAACuD,IAAI,CAACG,KAAK,IAAI,CAAC,CAACA,KAAK,CAACD,QAAQ,CAAC,cAAArB,KAAA,uBAA7FA,KAAA,CAAgGqB,QAAQ;MACzH,IAAI,CAACH,QAAQ,EAAE;QACX;QACA,MAAMX,iBAAiB,EAAE;QAEzB,OAAOQ,UAAU,EAAE;;MAGvB,IAAI;QACAX,WAAW,SAASzD,mBAAmB,CAAC4E,yBAAyB,CAACL,QAAQ,EAAEvC,SAAS,EAAE;UAAEtB;QAAM,CAAE,CAAC;OACrG,CAAC,OAAOmE,KAAK,EAAE;QACZ,IACIjF,SAAS,CAACkF,iBAAiB,CAACD,KAAK,CAAC,IAClC3E,aAAa,CAAC6E,wBAAwB,CAACF,KAAK,CAAC,KAAK/E,SAAS,CAACkF,OAAO,CAAC,4BAA4B,CAAC,EACnG;UACE;UACA,MAAMpB,iBAAiB,EAAE;UAEzB,OAAOQ,UAAU,EAAE;;QAGvB,MAAMS,KAAK;;MAGf;MACA,MAAMjF,SAAS,CAACqF,YAAY,CACxB3F,mBAAmB,CAAC4C,YAAY,CAACjC,2BAA2B,CAACiF,SAAS,EAAEzB,WAAW,CAAC0B,EAAE,EAAEzE,MAAM,CAAC,CAClG;MAED,MAAM0E,OAAO,SAASlE,OAAO,CAACC,GAAG,CAAC,CAC9BiC,MAAI,CAACiC,cAAc,CAAC5B,WAAW,CAAC0B,EAAE,EAAEnE,UAAU,EAAEN,MAAM,CAAC,EACvD0C,MAAI,CAACkC,UAAU,CAAC7B,WAAW,EAAExC,MAAM,EAAEP,MAAM,CAAC,CAC/C,CAAC;MAEFuB,MAAM,CAACG,OAAO,GAAGgD,OAAO,CAAC,CAAC,CAAC,CAAChD,OAAO,IAAIgD,OAAO,CAAC,CAAC,CAAC,CAAChD,OAAO;MACzDH,MAAM,CAACM,QAAQ,GAAG6C,OAAO,CAAC,CAAC,CAAC,CAAC7C,QAAQ,CAAChB,MAAM,CAAC6D,OAAO,CAAC,CAAC,CAAC,CAAC7C,QAAQ,CAAC;MAEjE,OAAO6B,UAAU,EAAE;IAAC;EACxB;EAEA;;;;;;;;EAQgBiB,cAAcA,CAC1BF,EAAU,EACVnE,UAAuC,EACvCN,MAAc;IAAA,IAAA6E,MAAA;IAAA,OAAAxE,iBAAA;MAEd,MAAMkB,MAAM,GAAkC;QAC1CM,QAAQ,EAAE,EAAE;QACZH,OAAO,EAAE;OACZ;MAED;MACA,KAAK,IAAIoD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxE,UAAU,CAAC8C,MAAM,EAAE0B,CAAC,EAAE,EAAE;QACxC,MAAM7D,KAAK,GAAGX,UAAU,CAACwE,CAAC,CAAC;QAE3B,IAAI;UACA,MAAMhG,QAAQ,CAACiG,oBAAoB,CAAC9D,KAAK,CAAC+D,SAAS,EAAE/D,KAAK,CAACX,UAAU,EAAEN,MAAM,CAAC;UAE9EuB,MAAM,CAACG,OAAO,GAAG,IAAI;UAErB,MAAM7C,eAAe,CAACoG,gBAAgB,CAAChE,KAAK,CAACwD,EAAE,EAAEzE,MAAM,CAAC;SAC3D,CAAC,OAAOmE,KAAK,EAAE;UACZ,IAAI,CAACjF,SAAS,CAACkF,iBAAiB,CAACD,KAAK,CAAC,EAAE;YACrC,MAAMA,KAAK;;UAGf;UACA5C,MAAM,CAACG,OAAO,GAAG,IAAI;UAErB,MAAM7C,eAAe,CAACoG,gBAAgB,CAAChE,KAAK,CAACwD,EAAE,EAAEzE,MAAM,CAAC;UAExD;UACA6E,MAAI,CAACK,4BAA4B,CAAC3D,MAAM,CAACM,QAAQ,EAAEZ,KAAK,CAACkE,KAAK,IAAI,EAAE,EAAEhB,KAAK,CAAC;;;MAIpF,IAAI5C,MAAM,CAACG,OAAO,EAAE;QAChB;QACA,MAAMxC,SAAS,CAACqF,YAAY,CAACjF,mBAAmB,CAAC8F,sBAAsB,CAACX,EAAE,EAAEnB,SAAS,EAAEtD,MAAM,CAAC,CAAC;;MAGnG,OAAOuB,MAAM;IAAC;EAClB;EAEA;;;;;;;;EAQgBqD,UAAUA,CACtB7B,WAAoC,EACpCxC,MAA+B,EAC/BP,MAAc;IAAA,IAAAqF,MAAA;IAAA,OAAAhF,iBAAA;MAEd,MAAMkB,MAAM,GAAkC;QAC1CM,QAAQ,EAAE,EAAE;QACZH,OAAO,EAAE;OACZ;MAED,IAAI,CAACnB,MAAM,CAAC6C,MAAM,EAAE;QAChB,OAAO7B,MAAM;;MAGjB,MAAM,CAAC+D,IAAI,EAAEC,WAAW,CAAC,SAAS/E,OAAO,CAACC,GAAG,CAAC,CAC1CxB,SAAS,CAACuG,OAAO,CAACxF,MAAM,CAAC,EACzBP,WAAW,CAACgG,QAAQ,CAAC1C,WAAW,CAAC2C,OAAO,EAAE,UAAU,EAAE1F,MAAM,CAAC,CAChE,CAAC;MACF,MAAM2F,KAAK,GAAGC,IAAI,CAACC,SAAS,CAACnG,iBAAiB,CAACoG,cAAc,CAACR,IAAI,CAAC,CAACS,OAAO,EAAE,CAAC;MAE9E,IAAIC,WAAmD;MACvD,IAAI;QACA,MAAMC,YAAY,SAAS3G,mBAAmB,CAAC4G,eAAe,CAACnD,WAAW,CAAC0B,EAAE,EAAE;UAC3E0B,IAAI,EAAEpD,WAAW,CAAC2C,OAAO;UACzBU,eAAe;SAClB,CAAC;;QACFJ,WAAW,GAAGC,YAAY,CAACI,QAAQ,CAACC,GAAG,EAAE;OAC5C,CAAC,OAAOnC,KAAK,EAAE;QACZ;QACA;QACA,IAAI,CAACjF,SAAS,CAACkF,iBAAiB,CAACD,KAAK,CAAC,EAAE;UACrC,MAAMA,KAAK;;;MAInB,MAAM3D,OAAO,CAACC,GAAG,CAACF,MAAM,CAACS,GAAG;QAAA,IAAAuF,KAAA,GAAAlG,iBAAA,CAAC,WAAO4D,KAAK,EAAI;UACzC,IAAI;YACA,IAAI+B,WAAW,IAAI/B,KAAK,CAACuC,WAAW,IAAIR,WAAW,CAACQ,WAAW,EAAE;cAC7D;cACA,MAAM,IAAI7G,WAAW,CAAC;gBAClB8G,OAAO,EAAErH,SAAS,CAACkF,OAAO,CAAC,sCAAsC,CAAC;gBAClEoC,SAAS,EAAE;eACd,CAAC;;YAGN;YACA,MAAMC,YAAY,SAAS7H,QAAQ,CAAC8H,cAAc,CAAC3C,KAAK,CAACe,SAAS,EAAEjC,WAAW,CAAC2C,OAAO,EAAE;cACrFmB,YAAY,EAAE5C,KAAK,CAAC4C,YAAY;cAChCC,KAAK,EAAE7C,KAAK,CAACuC,WAAW;cACxBxG;aACH,CAAC;YAEF,IAAI2G,YAAY,CAACvD,MAAM,EAAE;cACrB;cACA,MAAM,IAAIzD,WAAW,CAAC;gBAClB8G,OAAO,EAAErH,SAAS,CAACkF,OAAO,CAAC,sCAAsC,CAAC;gBAClEoC,SAAS,EAAE;eACd,CAAC;;YAGN,IAAIzC,KAAK,CAAC8C,SAAS,KAAKhI,kBAAkB,EAAE;cACxC,MAAMD,QAAQ,CAACkI,iBAAiB,CAAC/C,KAAK,CAACe,SAAS,EAAEO,WAAW,EAAEI,KAAK,EAAE1B,KAAK,CAACgD,OAAO,EAAE;gBACjFJ,YAAY,EAAE5C,KAAK,CAAC4C,YAAY;gBAChC7G;eACH,CAAC;aACL,MAAM,IAAIiE,KAAK,CAAC8C,SAAS,EAAE;cACxB,MAAMjI,QAAQ,CAACoI,eAAe,CAACjD,KAAK,CAACe,SAAS,EAAEO,WAAW,EAAEI,KAAK,EAAE1B,KAAK,CAACgD,OAAO,EAAEhD,KAAK,CAAC8C,SAAS,EAAE;gBAChGF,YAAY,EAAE5C,KAAK,CAAC4C,YAAY;gBAChC7G;eACH,CAAC;;YAGNuB,MAAM,CAACG,OAAO,GAAG,IAAI;YAErB,MAAM7C,eAAe,CAAC0E,YAAY,CAACU,KAAK,CAACe,SAAS,EAAE;cAChDvB,MAAM,EAAEV,WAAW,CAAC2C,OAAO;cAC3ByB,OAAO,EAAElD,KAAK,CAACgD,OAAO;cACtBJ,YAAY,EAAE5C,KAAK,CAAC4C,YAAY;cAChC7G;aACH,CAAC;WACL,CAAC,OAAOmE,KAAK,EAAE;YACZ,IAAI,CAACjF,SAAS,CAACkF,iBAAiB,CAACD,KAAK,CAAC,EAAE;cACrC,MAAMA,KAAK;;YAGf;YACA5C,MAAM,CAACG,OAAO,GAAG,IAAI;YAErB,MAAM7C,eAAe,CAAC0E,YAAY,CAACU,KAAK,CAACe,SAAS,EAAE;cAChDvB,MAAM,EAAEV,WAAW,CAAC2C,OAAO;cAC3ByB,OAAO,EAAElD,KAAK,CAACgD,OAAO;cACtBJ,YAAY,EAAE5C,KAAK,CAAC4C,YAAY;cAChC7G;aACH,CAAC;YAEF;YACAqF,MAAI,CAACH,4BAA4B,CAAC3D,MAAM,CAACM,QAAQ,EAAEoC,KAAK,CAACkB,KAAK,IAAI,EAAE,EAAEhB,KAAK,CAAC;;QAEpF,CAAC;QAAA,iBAAAiD,GAAA;UAAA,OAAAb,KAAA,CAAAxE,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC,CAAC;MAEH,OAAOT,MAAM;IAAC;EAClB;;SAnVS3B,+BAAgC;AAEzByH,MAAA,CAAAzF,WAAW,GAAG,oCAAoC;;mBAFzDhC,MAA+B;AAAA;;SAA/BA,MAA+B;EAAA0H,OAAA,EAA/B1H,MAA+B,CAAA2H,IAAA;EAAAC,UAAA,EADlB;AAAM;AAwVhC,OAAO,MAAMC,uBAAuB,GAAGtI,aAAa,CAACS,+BAA+B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}