{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreLogger } from '@singletons/logger';\nimport { makeSingleton, File, WebView } from '@singletons';\nimport { CoreText } from '@singletons/text';\nimport { CorePlatform } from '@services/platform';\nimport { CorePath } from '@singletons/path';\nimport { Zip } from '@features/native/plugins';\nimport * as i0 from \"@angular/core\";\n/**\n * Factory to interact with the file system.\n */\nexport class CoreFileProvider {\n  // 1 MB. Same chunk size as Ionic Native.\n  constructor() {\n    this.initialized = false;\n    this.basePath = '';\n    this.isHTMLAPI = false;\n    this.logger = CoreLogger.getInstance('CoreFileProvider');\n  }\n  /**\n   * Sets basePath to use with HTML API. Reserved for core use.\n   *\n   * @param path Base path to use.\n   */\n  setHTMLBasePath(path) {\n    this.isHTMLAPI = true;\n    this.basePath = path;\n  }\n  /**\n   * Checks if we're using HTML API.\n   *\n   * @returns True if uses HTML API, false otherwise.\n   */\n  usesHTMLAPI() {\n    return this.isHTMLAPI;\n  }\n  /**\n   * Initialize basePath based on the OS if it's not initialized already.\n   *\n   * @returns Promise to be resolved when the initialization is finished.\n   */\n  init() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.initialized) {\n        return;\n      }\n      yield CorePlatform.ready();\n      if (CorePlatform.isAndroid()) {\n        _this.basePath = File.externalApplicationStorageDirectory || _this.basePath;\n      } else if (CorePlatform.isIOS()) {\n        _this.basePath = File.documentsDirectory || _this.basePath;\n      } else if (!_this.isAvailable() || _this.basePath === '') {\n        _this.logger.error('Error getting device OS.');\n        return Promise.reject(new CoreError('Error getting device OS to initialize file system.'));\n      }\n      _this.initialized = true;\n      _this.logger.debug('FS initialized: ' + _this.basePath);\n    })();\n  }\n  /**\n   * Check if the plugin is available.\n   *\n   * @returns Whether the plugin is available.\n   */\n  isAvailable() {\n    return window.resolveLocalFileSystemURL !== undefined;\n  }\n  /**\n   * Get a file.\n   *\n   * @param path Relative path to the file.\n   * @returns Promise resolved when the file is retrieved.\n   */\n  getFile(path) {\n    return this.init().then(() => {\n      this.logger.debug('Get file: ' + path);\n      return File.resolveLocalFilesystemUrl(this.addBasePathIfNeeded(path));\n    }).then(entry => entry);\n  }\n  /**\n   * Get a directory.\n   *\n   * @param path Relative path to the directory.\n   * @returns Promise resolved when the directory is retrieved.\n   */\n  getDir(path) {\n    return this.init().then(() => {\n      this.logger.debug('Get directory: ' + path);\n      return File.resolveDirectoryUrl(this.addBasePathIfNeeded(path));\n    });\n  }\n  /**\n   * Get site folder path.\n   *\n   * @param siteId Site ID.\n   * @returns Site folder path.\n   */\n  getSiteFolder(siteId) {\n    return CoreFileProvider.SITESFOLDER + '/' + siteId;\n  }\n  /**\n   * Create a directory or a file.\n   *\n   * @param isDirectory True if a directory should be created, false if it should create a file.\n   * @param path Relative path to the dir/file.\n   * @param failIfExists True if it should fail if the dir/file exists, false otherwise.\n   * @param base Base path to create the dir/file in. If not set, use basePath.\n   * @returns Promise to be resolved when the dir/file is created.\n   */\n  create(isDirectory, path, failIfExists, base) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.init();\n      path = _this2.removeBasePath(path);\n      base = base || _this2.basePath;\n      if (path.indexOf('/') == -1) {\n        if (isDirectory) {\n          _this2.logger.debug('Create dir ' + path + ' in ' + base);\n          return File.createDir(base, path, !failIfExists);\n        } else {\n          _this2.logger.debug('Create file ' + path + ' in ' + base);\n          return File.createFile(base, path, !failIfExists);\n        }\n      } else {\n        // The file plugin doesn't allow creating more than 1 level at a time (e.g. tmp/folder).\n        // We need to create them 1 by 1.\n        const firstDir = path.substring(0, path.indexOf('/'));\n        const restOfPath = path.substring(path.indexOf('/') + 1);\n        _this2.logger.debug('Create dir ' + firstDir + ' in ' + base);\n        const newDirEntry = yield File.createDir(base, firstDir, true);\n        return _this2.create(isDirectory, restOfPath, failIfExists, newDirEntry.toURL());\n      }\n    })();\n  }\n  /**\n   * Create a directory.\n   *\n   * @param path Relative path to the directory.\n   * @param failIfExists True if it should fail if the directory exists, false otherwise.\n   * @returns Promise to be resolved when the directory is created.\n   */\n  createDir(path, failIfExists) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const entry = yield _this3.create(true, path, failIfExists);\n      return entry;\n    })();\n  }\n  /**\n   * Create a file.\n   *\n   * @param path Relative path to the file.\n   * @param failIfExists True if it should fail if the file exists, false otherwise..\n   * @returns Promise to be resolved when the file is created.\n   */\n  createFile(path, failIfExists) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const entry = yield _this4.create(false, path, failIfExists);\n      return entry;\n    })();\n  }\n  /**\n   * Removes a directory and all its contents.\n   *\n   * @param path Relative path to the directory.\n   * @returns Promise to be resolved when the directory is deleted.\n   */\n  removeDir(path) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.init();\n      path = _this5.removeBasePath(path);\n      _this5.logger.debug('Remove directory: ' + path);\n      yield File.removeRecursively(_this5.basePath, path);\n    })();\n  }\n  /**\n   * Removes a file and all its contents.\n   *\n   * @param path Relative path to the file.\n   * @returns Promise to be resolved when the file is deleted.\n   */\n  removeFile(path) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.init();\n      path = _this6.removeBasePath(path);\n      _this6.logger.debug('Remove file: ' + path);\n      try {\n        yield File.removeFile(_this6.basePath, path);\n      } catch (error) {\n        // The delete can fail if the path has encoded characters. Try again if that's the case.\n        const decodedPath = decodeURI(path);\n        if (decodedPath != path) {\n          yield File.removeFile(_this6.basePath, decodedPath);\n        } else {\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Removes a file given its FileEntry.\n   *\n   * @param entry File Entry.\n   * @returns Promise resolved when the file is deleted.\n   */\n  removeFileByFileEntry(entry) {\n    return new Promise((resolve, reject) => entry.remove(resolve, reject));\n  }\n  /**\n   * Retrieve the contents of a directory (not subdirectories).\n   *\n   * @param path Relative path to the directory.\n   * @returns Promise to be resolved when the contents are retrieved.\n   */\n  getDirectoryContents(path) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield _this7.init();\n      path = _this7.removeBasePath(path);\n      _this7.logger.debug('Get contents of dir: ' + path);\n      const result = yield File.listDir(_this7.basePath, path);\n      return result;\n    })();\n  }\n  /**\n   * Type guard to check if the param is a DirectoryEntry.\n   *\n   * @param entry Param to check.\n   * @returns Whether the param is a DirectoryEntry.\n   */\n  isDirectoryEntry(entry) {\n    return entry.isDirectory === true;\n  }\n  /**\n   * Calculate the size of a directory or a file.\n   *\n   * @param entry Directory or file.\n   * @returns Promise to be resolved when the size is calculated.\n   */\n  getSize(entry) {\n    var _this8 = this;\n    return new Promise((resolve, reject) => {\n      if (this.isDirectoryEntry(entry)) {\n        const directoryReader = entry.createReader();\n        directoryReader.readEntries( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (entries) {\n            const promises = [];\n            for (let i = 0; i < entries.length; i++) {\n              promises.push(_this8.getSize(entries[i]));\n            }\n            try {\n              const sizes = yield Promise.all(promises);\n              let directorySize = 0;\n              for (let i = 0; i < sizes.length; i++) {\n                const fileSize = Number(sizes[i]);\n                if (isNaN(fileSize)) {\n                  reject();\n                  return;\n                }\n                directorySize += fileSize;\n              }\n              resolve(directorySize);\n            } catch (error) {\n              reject(error);\n            }\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }(), reject);\n      } else {\n        entry.file(file => {\n          resolve(file.size);\n        }, reject);\n      }\n    });\n  }\n  /**\n   * Calculate the size of a directory.\n   *\n   * @param path Relative path to the directory.\n   * @returns Promise to be resolved when the size is calculated.\n   */\n  getDirectorySize(path) {\n    path = this.removeBasePath(path);\n    this.logger.debug('Get size of dir: ' + path);\n    return this.getDir(path).then(dirEntry => this.getSize(dirEntry));\n  }\n  /**\n   * Calculate the size of a file.\n   *\n   * @param path Relative path to the file.\n   * @returns Promise to be resolved when the size is calculated.\n   */\n  getFileSize(path) {\n    path = this.removeBasePath(path);\n    this.logger.debug('Get size of file: ' + path);\n    return this.getFile(path).then(fileEntry => this.getSize(fileEntry));\n  }\n  /**\n   * Get file object from a FileEntry.\n   *\n   * @param entry Relative path to the file.\n   * @returns Promise to be resolved when the file is retrieved.\n   */\n  getFileObjectFromFileEntry(entry) {\n    return new Promise((resolve, reject) => {\n      this.logger.debug('Get file object of: ' + entry.fullPath);\n      entry.file(resolve, reject);\n    });\n  }\n  /**\n   * Calculate the free space in the disk.\n   * Please notice that this function isn't reliable and it's not documented in the Cordova File plugin.\n   *\n   * @returns Promise resolved with the estimated free space in bytes.\n   */\n  calculateFreeSpace() {\n    return File.getFreeDiskSpace().then(size => {\n      if (CorePlatform.isIOS()) {\n        // In iOS the size is in bytes.\n        return Number(size);\n      }\n      // The size is in KB, convert it to bytes.\n      return Number(size) * 1024;\n    });\n  }\n  /**\n   * Normalize a filename that usually comes URL encoded.\n   *\n   * @param filename The file name.\n   * @returns The file name normalized.\n   */\n  normalizeFileName(filename) {\n    filename = CoreTextUtils.decodeURIComponent(filename);\n    return filename;\n  }\n  readFile(path, format = 0 /* CoreFileFormat.FORMATTEXT */, folder) {\n    if (!folder) {\n      folder = this.basePath;\n      path = this.removeBasePath(path);\n    }\n    this.logger.debug(`Read file ${path} with format ${format} in folder ${folder}`);\n    switch (format) {\n      case 1 /* CoreFileFormat.FORMATDATAURL */:\n        return File.readAsDataURL(folder, path);\n      case 2 /* CoreFileFormat.FORMATBINARYSTRING */:\n        return File.readAsBinaryString(folder, path);\n      case 3 /* CoreFileFormat.FORMATARRAYBUFFER */:\n        return File.readAsArrayBuffer(folder, path);\n      case 4 /* CoreFileFormat.FORMATJSON */:\n        return File.readAsText(folder, path).then(text => {\n          const parsed = CoreTextUtils.parseJSON(text, null);\n          if (parsed == null && text != null) {\n            throw new CoreError('Error parsing JSON file: ' + path);\n          }\n          return parsed;\n        });\n      default:\n        return File.readAsText(folder, path);\n    }\n  }\n  /**\n   * Read file contents from a file data object.\n   *\n   * @param fileData File's data.\n   * @param format Format to read the file.\n   * @returns Promise to be resolved when the file is read.\n   */\n  readFileData(fileData, format = 0 /* CoreFileFormat.FORMATTEXT */) {\n    format = format || 0 /* CoreFileFormat.FORMATTEXT */;\n    this.logger.debug('Read file from file data with format ' + format);\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = event => {\n        var _event$target, _event$target2;\n        if (((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result) !== undefined && event.target.result !== null) {\n          if (format == 4 /* CoreFileFormat.FORMATJSON */) {\n            // Convert to object.\n            const parsed = CoreTextUtils.parseJSON(event.target.result, null);\n            if (parsed == null) {\n              reject('Error parsing JSON file.');\n            }\n            resolve(parsed);\n          } else {\n            resolve(event.target.result);\n          }\n        } else if (((_event$target2 = event.target) === null || _event$target2 === void 0 ? void 0 : _event$target2.error) !== undefined && event.target.error !== null) {\n          reject(event.target.error);\n        } else {\n          reject({\n            code: null,\n            message: 'READER_ONLOADEND_ERR'\n          });\n        }\n      };\n      // Check if the load starts. If it doesn't start in 3 seconds, reject.\n      // Sometimes in Android the read doesn't start for some reason, so the promise never finishes.\n      let hasStarted = false;\n      reader.onloadstart = () => {\n        hasStarted = true;\n      };\n      setTimeout(() => {\n        if (!hasStarted) {\n          reject('Upload cannot start.');\n        }\n      }, 3000);\n      switch (format) {\n        case 1 /* CoreFileFormat.FORMATDATAURL */:\n          reader.readAsDataURL(fileData);\n          break;\n        case 2 /* CoreFileFormat.FORMATBINARYSTRING */:\n          reader.readAsBinaryString(fileData);\n          break;\n        case 3 /* CoreFileFormat.FORMATARRAYBUFFER */:\n          reader.readAsArrayBuffer(fileData);\n          break;\n        default:\n          reader.readAsText(fileData);\n      }\n    });\n  }\n  /**\n   * Writes some data in a file.\n   *\n   * @param path Relative path to the file.\n   * @param data Data to write.\n   * @param append Whether to append the data to the end of the file.\n   * @returns Promise to be resolved when the file is written.\n   */\n  writeFile(path, data, append) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      yield _this9.init();\n      path = _this9.removeBasePath(path);\n      _this9.logger.debug('Write file: ' + path);\n      // Create file (and parent folders) to prevent errors.\n      const fileEntry = yield _this9.createFile(path);\n      if (_this9.isHTMLAPI && (typeof data == 'string' || data.toString() == '[object ArrayBuffer]')) {\n        // We need to write Blobs.\n        const extension = CoreMimetypeUtils.getFileExtension(path);\n        const type = extension ? CoreMimetypeUtils.getMimeType(extension) : '';\n        data = new Blob([data], {\n          type: type || 'text/plain'\n        });\n      }\n      yield File.writeFile(_this9.basePath, path, data, {\n        replace: !append,\n        append: !!append\n      });\n      return fileEntry;\n    })();\n  }\n  /**\n   * Write some file data into a filesystem file.\n   * It's done in chunks to prevent crashing the app for big files.\n   * Please notice Ionic Native writeFile function already splits by chunks, but it doesn't have an onProgress function.\n   *\n   * @param file The data to write.\n   * @param path Path where to store the data.\n   * @param onProgress Function to call on progress.\n   * @param offset Offset where to start reading from.\n   * @param append Whether to append the data to the end of the file.\n   * @returns Promise resolved when done.\n   */\n  writeFileDataInFile(file, path, onProgress, offset = 0, append) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      offset = offset || 0;\n      try {\n        // Get the chunk to write.\n        const chunk = file.slice(offset, Math.min(offset + CoreFileProvider.CHUNK_SIZE, file.size));\n        const fileEntry = yield _this10.writeFile(path, chunk, append);\n        offset += CoreFileProvider.CHUNK_SIZE;\n        onProgress && onProgress({\n          lengthComputable: true,\n          loaded: offset,\n          total: file.size\n        });\n        if (offset >= file.size) {\n          // Done, stop.\n          return fileEntry;\n        }\n        // Read the next chunk.\n        return _this10.writeFileDataInFile(file, path, onProgress, offset, true);\n      } catch (error) {\n        if (error && error.target && error.target.error) {\n          // Error returned by the writer, throw the \"real\" error.\n          throw error.target.error;\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Gets a file that might be outside the app's folder.\n   *\n   * @param fullPath Absolute path to the file.\n   * @returns Promise to be resolved when the file is retrieved.\n   */\n  getExternalFile(fullPath) {\n    return File.resolveLocalFilesystemUrl(fullPath).then(entry => entry);\n  }\n  /**\n   * Calculate the size of a file.\n   *\n   * @param path Absolute path to the file.\n   * @returns Promise to be resolved when the size is calculated.\n   */\n  getExternalFileSize(path) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const fileEntry = yield _this11.getExternalFile(path);\n      return _this11.getSize(fileEntry);\n    })();\n  }\n  /**\n   * Removes a file that might be outside the app's folder.\n   *\n   * @param fullPath Absolute path to the file.\n   * @returns Promise to be resolved when the file is removed.\n   */\n  removeExternalFile(fullPath) {\n    return _asyncToGenerator(function* () {\n      const directory = fullPath.substring(0, fullPath.lastIndexOf('/'));\n      const filename = fullPath.substring(fullPath.lastIndexOf('/') + 1);\n      yield File.removeFile(directory, filename);\n    })();\n  }\n  /**\n   * Get the base path where the application files are stored.\n   *\n   * @returns Promise to be resolved when the base path is retrieved.\n   */\n  getBasePath() {\n    return this.init().then(() => {\n      if (this.basePath.slice(-1) == '/') {\n        return this.basePath;\n      } else {\n        return this.basePath + '/';\n      }\n    });\n  }\n  /**\n   * Get the base path where the application files are stored in the format to be used for downloads.\n   * iOS: Internal URL (cdvfile://).\n   * Others: basePath (file://)\n   *\n   * @returns Promise to be resolved when the base path is retrieved.\n   */\n  getBasePathToDownload() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      yield _this12.init();\n      if (CorePlatform.isIOS()) {\n        // In iOS we want the internal URL (cdvfile://localhost/persistent/...).\n        const dirEntry = yield File.resolveDirectoryUrl(_this12.basePath);\n        return dirEntry.toInternalURL();\n      } else {\n        // In the other platforms we use the basePath as it is (file://...).\n        return _this12.basePath;\n      }\n    })();\n  }\n  /**\n   * Get the base path where the application files are stored. Returns the value instantly, without waiting for it to be ready.\n   *\n   * @returns Base path. If the service hasn't been initialized it will return an invalid value.\n   */\n  getBasePathInstant() {\n    if (!this.basePath) {\n      return this.basePath;\n    } else if (this.basePath.slice(-1) == '/') {\n      return this.basePath;\n    } else {\n      return this.basePath + '/';\n    }\n  }\n  /**\n   * Move a dir.\n   *\n   * @param originalPath Path to the dir to move.\n   * @param newPath New path of the dir.\n   * @param destDirExists Set it to true if you know the directory where to put the dir exists. If false, the function will\n   *                      try to create it (slower).\n   * @returns Promise resolved when the entry is moved.\n   */\n  moveDir(originalPath, newPath, destDirExists) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const entry = yield _this13.copyOrMoveFileOrDir(originalPath, newPath, true, false, destDirExists);\n      return entry;\n    })();\n  }\n  /**\n   * Move a file.\n   *\n   * @param originalPath Path to the file to move.\n   * @param newPath New path of the file.\n   * @param destDirExists Set it to true if you know the directory where to put the file exists. If false, the function will\n   *                      try to create it (slower).\n   * @returns Promise resolved when the entry is moved.\n   */\n  moveFile(originalPath, newPath, destDirExists) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const entry = yield _this14.copyOrMoveFileOrDir(originalPath, newPath, false, false, destDirExists);\n      return entry;\n    })();\n  }\n  /**\n   * Copy a directory.\n   *\n   * @param from Path to the directory to move.\n   * @param to New path of the directory.\n   * @param destDirExists Set it to true if you know the directory where to put the dir exists. If false, the function will\n   *                      try to create it (slower).\n   * @returns Promise resolved when the entry is copied.\n   */\n  copyDir(from, to, destDirExists) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const entry = yield _this15.copyOrMoveFileOrDir(from, to, true, true, destDirExists);\n      return entry;\n    })();\n  }\n  /**\n   * Copy a file.\n   *\n   * @param from Path to the file to move.\n   * @param to New path of the file.\n   * @param destDirExists Set it to true if you know the directory where to put the file exists. If false, the function will\n   *                      try to create it (slower).\n   * @returns Promise resolved when the entry is copied.\n   */\n  copyFile(from, to, destDirExists) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const entry = yield _this16.copyOrMoveFileOrDir(from, to, false, true, destDirExists);\n      return entry;\n    })();\n  }\n  /**\n   * Copy or move a file or a directory.\n   *\n   * @param from Path to the file/dir to move.\n   * @param to New path of the file/dir.\n   * @param isDir Whether it's a dir or a file.\n   * @param copy Whether to copy. If false, it will move the file.\n   * @param destDirExists Set it to true if you know the directory where to put the file/dir exists. If false, the function will\n   *                      try to create it (slower).\n   * @returns Promise resolved when the entry is copied.\n   */\n  copyOrMoveFileOrDir(from, to, isDir, copy, destDirExists) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const fileIsInAppFolder = _this17.isPathInAppFolder(from);\n      if (!fileIsInAppFolder) {\n        return _this17.copyOrMoveExternalFile(from, to, copy);\n      }\n      const moveCopyFn = (...args) => copy ? isDir ? File.copyDir(...args) : File.copyFile(...args) : isDir ? File.moveDir(...args) : File.moveFile(...args);\n      yield _this17.init();\n      from = _this17.removeBasePath(from);\n      to = _this17.removeBasePath(to);\n      const toFileAndDir = _this17.getFileAndDirectoryFromPath(to);\n      if (toFileAndDir.directory && !destDirExists) {\n        // Create the target directory if it doesn't exist.\n        yield _this17.createDir(toFileAndDir.directory);\n      }\n      try {\n        const entry = yield moveCopyFn(_this17.basePath, from, _this17.basePath, to);\n        return entry;\n      } catch (error) {\n        // The copy can fail if the path has encoded characters. Try again if that's the case.\n        const decodedFrom = decodeURI(from);\n        const decodedTo = decodeURI(to);\n        if (from != decodedFrom || to != decodedTo) {\n          const entry = yield moveCopyFn(_this17.basePath, decodedFrom, _this17.basePath, decodedTo);\n          return entry;\n        } else {\n          return Promise.reject(error);\n        }\n      }\n    })();\n  }\n  /**\n   * Extract the file name and directory from a given path.\n   *\n   * @param path Path to be extracted.\n   * @returns Plain object containing the file name and directory.\n   * @description\n   * file.pdf         -> directory: '', name: 'file.pdf'\n   * /file.pdf        -> directory: '', name: 'file.pdf'\n   * path/file.pdf    -> directory: 'path', name: 'file.pdf'\n   * path/            -> directory: 'path', name: ''\n   * path             -> directory: '', name: 'path'\n   */\n  getFileAndDirectoryFromPath(path) {\n    const file = {\n      directory: '',\n      name: ''\n    };\n    file.directory = path.substring(0, path.lastIndexOf('/'));\n    file.name = path.substring(path.lastIndexOf('/') + 1);\n    return file;\n  }\n  /**\n   * Get the internal URL of a file.\n   * Please notice that with WKWebView these URLs no longer work in mobile. Use fileEntry.toURL() along with convertFileSrc.\n   *\n   * @param fileEntry File Entry.\n   * @returns Internal URL.\n   */\n  getInternalURL(fileEntry) {\n    if (!fileEntry.toInternalURL) {\n      // File doesn't implement toInternalURL, use toURL.\n      return fileEntry.toURL();\n    }\n    return fileEntry.toInternalURL();\n  }\n  /**\n   * Adds the basePath to a path if it doesn't have it already.\n   *\n   * @param path Path to treat.\n   * @returns Path with basePath added.\n   */\n  addBasePathIfNeeded(path) {\n    if (path.indexOf(this.basePath) > -1) {\n      return path;\n    } else {\n      return CorePath.concatenatePaths(this.basePath, path);\n    }\n  }\n  /**\n   * Remove the base path from a path.\n   *\n   * @param path Path to treat.\n   * @returns Path without basePath.\n   */\n  removeBasePath(path) {\n    return CoreText.removeStartingSlash(path.replace(this.basePath, ''));\n  }\n  /**\n   * Unzips a file.\n   *\n   * @param path Path to the ZIP file.\n   * @param destFolder Path to the destination folder. If not defined, a new folder will be created with the\n   *                   same location and name as the ZIP file (without extension).\n   * @param onProgress Function to call on progress.\n   * @param recreateDir Delete the dest directory before unzipping. Defaults to true.\n   * @returns Promise resolved when the file is unzipped.\n   */\n  unzipFile(path, destFolder, onProgress, recreateDir = true) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      // Get the source file.\n      const fileEntry = yield _this18.getFile(path);\n      if (destFolder && recreateDir) {\n        // Make sure the dest dir doesn't exist already.\n        yield CoreUtils.ignoreErrors(_this18.removeDir(destFolder));\n        // Now create the dir, otherwise if any of the ancestor dirs doesn't exist the unzip would fail.\n        yield _this18.createDir(destFolder);\n      }\n      // If destFolder is not set, use same location as ZIP file. We need to use absolute paths (including basePath).\n      destFolder = _this18.addBasePathIfNeeded(destFolder || CoreMimetypeUtils.removeExtension(path));\n      const result = yield Zip.unzip(fileEntry.toURL(), destFolder, onProgress);\n      if (result == -1) {\n        throw new CoreError('Unzip failed.');\n      }\n    })();\n  }\n  /**\n   * Search a string or regexp in a file contents and replace it. The result is saved in the same file.\n   *\n   * @param path Path to the file.\n   * @param search Value to search.\n   * @param newValue New value.\n   * @returns Promise resolved in success.\n   */\n  replaceInFile(path, search, newValue) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      let content = yield _this19.readFile(path);\n      if (content === undefined || content === null || !content.replace) {\n        throw new CoreError(`Error reading file ${path}`);\n      }\n      if (content.match(search)) {\n        content = content.replace(search, newValue);\n        yield _this19.writeFile(path, content);\n      }\n    })();\n  }\n  /**\n   * Get a file/dir metadata given the file's entry.\n   *\n   * @param fileEntry FileEntry retrieved from getFile or similar.\n   * @returns Promise resolved with metadata.\n   */\n  getMetadata(fileEntry) {\n    if (!fileEntry || !fileEntry.getMetadata) {\n      return Promise.reject(new CoreError('Cannot get metadata from file entry.'));\n    }\n    return new Promise((resolve, reject) => {\n      fileEntry.getMetadata(resolve, reject);\n    });\n  }\n  /**\n   * Get a file/dir metadata given the path.\n   *\n   * @param path Path to the file/dir.\n   * @param isDir True if directory, false if file.\n   * @returns Promise resolved with metadata.\n   */\n  getMetadataFromPath(path, isDir) {\n    let promise;\n    if (isDir) {\n      promise = this.getDir(path);\n    } else {\n      promise = this.getFile(path);\n    }\n    return promise.then(entry => this.getMetadata(entry));\n  }\n  /**\n   * Remove the starting slash of a path if it's there. E.g. '/sites/filepool' -> 'sites/filepool'.\n   *\n   * @param path Path.\n   * @returns Path without a slash in the first position.\n   * @deprecated since 4.1. Use CoreText.removeStartingSlash instead.\n   */\n  removeStartingSlash(path) {\n    return CoreText.removeStartingSlash(path);\n  }\n  /**\n   * Convenience function to copy or move an external file.\n   *\n   * @param from Absolute path to the file to copy/move.\n   * @param to Relative new path of the file (inside the app folder).\n   * @param copy True to copy, false to move.\n   * @returns Promise resolved when the entry is copied/moved.\n   */\n  copyOrMoveExternalFile(from, to, copy) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      // Get the file to copy/move.\n      const fileEntry = yield _this20.getExternalFile(from);\n      // Create the destination dir if it doesn't exist.\n      const dirAndFile = _this20.getFileAndDirectoryFromPath(to);\n      const dirEntry = yield _this20.createDir(dirAndFile.directory);\n      // Now copy/move the file.\n      return new Promise((resolve, reject) => {\n        if (copy) {\n          fileEntry.copyTo(dirEntry, dirAndFile.name, entry => resolve(entry), reject);\n        } else {\n          fileEntry.moveTo(dirEntry, dirAndFile.name, entry => resolve(entry), reject);\n        }\n      });\n    })();\n  }\n  /**\n   * Copy a file from outside of the app folder to somewhere inside the app folder.\n   *\n   * @param from Absolute path to the file to copy.\n   * @param to Relative new path of the file (inside the app folder).\n   * @returns Promise resolved when the entry is copied.\n   */\n  copyExternalFile(from, to) {\n    return this.copyOrMoveExternalFile(from, to, true);\n  }\n  /**\n   * Move a file from outside of the app folder to somewhere inside the app folder.\n   *\n   * @param from Absolute path to the file to move.\n   * @param to Relative new path of the file (inside the app folder).\n   * @returns Promise resolved when the entry is moved.\n   */\n  moveExternalFile(from, to) {\n    return this.copyOrMoveExternalFile(from, to, false);\n  }\n  /**\n   * Get a unique file name inside a folder, adding numbers to the file name if needed.\n   *\n   * @param dirPath Path to the destination folder.\n   * @param fileName File name that wants to be used.\n   * @param defaultExt Default extension to use if no extension found in the file.\n   * @returns Promise resolved with the unique file name.\n   */\n  getUniqueNameInFolder(dirPath, fileName, defaultExt) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      // Get existing files in the folder.\n      try {\n        const entries = yield _this21.getDirectoryContents(dirPath);\n        const files = {};\n        let fileNameWithoutExtension = CoreMimetypeUtils.removeExtension(fileName);\n        let extension = CoreMimetypeUtils.getFileExtension(fileName) || defaultExt;\n        // Clean the file name.\n        fileNameWithoutExtension = CoreTextUtils.removeSpecialCharactersForFiles(CoreTextUtils.decodeURIComponent(fileNameWithoutExtension));\n        // Index the files by name.\n        entries.forEach(entry => {\n          files[entry.name.toLowerCase()] = entry;\n        });\n        // Format extension.\n        if (extension) {\n          extension = '.' + extension;\n        } else {\n          extension = '';\n        }\n        return _this21.calculateUniqueName(files, fileNameWithoutExtension + extension);\n      } catch (error) {\n        // Folder doesn't exist, name is unique. Clean it and return it.\n        return CoreTextUtils.removeSpecialCharactersForFiles(CoreTextUtils.decodeURIComponent(fileName));\n      }\n    })();\n  }\n  /**\n   * Given a file name and a set of already used names, calculate a unique name.\n   *\n   * @param usedNames Object with names already used as keys.\n   * @param name Name to check.\n   * @returns Unique name.\n   */\n  calculateUniqueName(usedNames, name) {\n    if (usedNames[name.toLowerCase()] === undefined) {\n      // No file with the same name.\n      return name;\n    }\n    // Repeated name. Add a number until we find a free name.\n    const nameWithoutExtension = CoreMimetypeUtils.removeExtension(name);\n    let extension = CoreMimetypeUtils.getFileExtension(name);\n    let num = 1;\n    extension = extension ? '.' + extension : '';\n    do {\n      name = nameWithoutExtension + '(' + num + ')' + extension;\n      num++;\n    } while (usedNames[name.toLowerCase()] !== undefined);\n    return name;\n  }\n  /**\n   * Remove app temporary folder.\n   *\n   * @returns Promise resolved when done.\n   */\n  clearTmpFolder() {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      // Ignore errors because the folder might not exist.\n      yield CoreUtils.ignoreErrors(_this22.removeDir(CoreFileProvider.TMPFOLDER));\n    })();\n  }\n  /**\n   * Remove deleted sites folders.\n   *\n   * @returns Promise resolved when done.\n   */\n  clearDeletedSitesFolder(existingSiteNames) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      // Ignore errors because the folder might not exist.\n      const dirPath = CoreFileProvider.SITESFOLDER;\n      // Get the directory contents.\n      try {\n        const contents = yield _this23.getDirectoryContents(dirPath);\n        if (!contents.length) {\n          return;\n        }\n        const promises = contents.map( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (file) {\n            if (file.isDirectory) {\n              if (!existingSiteNames.includes(file.name)) {\n                // Site does not exist... delete it.\n                yield CoreUtils.ignoreErrors(_this23.removeDir(_this23.getSiteFolder(file.name)));\n              }\n            }\n          });\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n        yield Promise.all(promises);\n      } catch (_unused) {\n        // Ignore errors, maybe it doesn't exist.\n      }\n    })();\n  }\n  /**\n   * Given a folder path and a list of used files, remove all the files of the folder that aren't on the list of used files.\n   *\n   * @param dirPath Folder path.\n   * @param files List of used files.\n   * @returns Promise resolved when done, rejected if failure.\n   */\n  removeUnusedFiles(dirPath, files) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      // Get the directory contents.\n      try {\n        const contents = yield _this24.getDirectoryContents(dirPath);\n        if (!contents.length) {\n          return;\n        }\n        const filesMap = {};\n        const promises = [];\n        // Index the received files by fullPath and ignore the invalid ones.\n        files.forEach(file => {\n          if ('fullPath' in file) {\n            filesMap[file.fullPath] = file;\n          }\n        });\n        // Check which of the content files aren't used anymore and delete them.\n        contents.forEach(file => {\n          if (!filesMap[file.fullPath]) {\n            // File isn't used, delete it.\n            promises.push(_this24.removeFileByFileEntry(file));\n          }\n        });\n        yield Promise.all(promises);\n      } catch (_unused2) {\n        // Ignore errors, maybe it doesn't exist.\n      }\n    })();\n  }\n  /**\n   * Check if a file is inside the app's folder.\n   *\n   * @param path The absolute path of the file to check.\n   * @returns Whether the file is in the app's folder.\n   */\n  isFileInAppFolder(path) {\n    return path.indexOf(this.basePath) != -1;\n  }\n  /**\n   * Get the path to the www folder at runtime based on the WebView URL.\n   *\n   * @returns Path.\n   */\n  getWWWPath() {\n    // Use current URL, removing the path.\n    if (!window.location.pathname || window.location.pathname == '/') {\n      return window.location.href;\n    }\n    const position = window.location.href.indexOf(window.location.pathname);\n    if (position != -1) {\n      return window.location.href.substring(0, position);\n    }\n    return window.location.href;\n  }\n  /**\n   * Get the full path to the www folder.\n   *\n   * @returns Path.\n   */\n  getWWWAbsolutePath() {\n    if (window.cordova && cordova.file && cordova.file.applicationDirectory) {\n      return CorePath.concatenatePaths(cordova.file.applicationDirectory, 'www');\n    }\n    // Cannot use Cordova to get it, use the WebView URL.\n    return this.getWWWPath();\n  }\n  /**\n   * Helper function to call Ionic WebView convertFileSrc only in the needed platforms.\n   * This is needed to make files work with the Ionic WebView plugin.\n   *\n   * @param src Source to convert.\n   * @returns Converted src.\n   */\n  convertFileSrc(src) {\n    return CorePlatform.isMobile() ? WebView.convertFileSrc(src) : src;\n  }\n  /**\n   * Undo the conversion of convertFileSrc.\n   *\n   * @param src Source to unconvert.\n   * @returns Unconverted src.\n   */\n  unconvertFileSrc(src) {\n    if (!CorePlatform.isMobile()) {\n      return src;\n    }\n    if (CorePlatform.isIOS()) {\n      return src.replace(CoreConstants.CONFIG.ioswebviewscheme + '://localhost/_app_file_', 'file://');\n    }\n    return src.replace('http://localhost/_app_file_', 'file://');\n  }\n  /**\n   * Check if a certain path is in the app's folder (basePath).\n   *\n   * @param path Path to check.\n   * @returns Whether it's in the app folder.\n   */\n  isPathInAppFolder(path) {\n    return !path || !path.match(/^[a-z0-9]+:\\/\\//i) || path.indexOf(this.basePath) != -1;\n  }\n  /**\n   * Get the file's name.\n   *\n   * @param file The file.\n   * @returns The file name.\n   */\n  getFileName(file) {\n    return CoreUtils.isFileEntry(file) ? file.name : file.filename;\n  }\n}\n_class = CoreFileProvider;\n// Folders.\n_class.SITESFOLDER = 'sites';\n_class.TMPFOLDER = 'tmp';\n_class.CHUNK_SIZE = 1048576;\n_class.ɵfac = function CoreFileProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFile = makeSingleton(CoreFileProvider);","map":{"version":3,"names":["CoreMimetypeUtils","CoreTextUtils","CoreUtils","CoreConstants","CoreError","CoreLogger","makeSingleton","File","WebView","CoreText","CorePlatform","CorePath","Zip","CoreFileProvider","constructor","initialized","basePath","isHTMLAPI","logger","getInstance","setHTMLBasePath","path","usesHTMLAPI","init","_this","_asyncToGenerator","ready","isAndroid","externalApplicationStorageDirectory","isIOS","documentsDirectory","isAvailable","error","Promise","reject","debug","window","resolveLocalFileSystemURL","undefined","getFile","then","resolveLocalFilesystemUrl","addBasePathIfNeeded","entry","getDir","resolveDirectoryUrl","getSiteFolder","siteId","SITESFOLDER","create","isDirectory","failIfExists","base","_this2","removeBasePath","indexOf","createDir","createFile","firstDir","substring","restOfPath","newDirEntry","toURL","_this3","_this4","removeDir","_this5","removeRecursively","removeFile","_this6","decodedPath","decodeURI","removeFileByFileEntry","resolve","remove","getDirectoryContents","_this7","result","listDir","isDirectoryEntry","getSize","_this8","directoryReader","createReader","readEntries","_ref","entries","promises","i","length","push","sizes","all","directorySize","fileSize","Number","isNaN","_x","apply","arguments","file","size","getDirectorySize","dirEntry","getFileSize","fileEntry","getFileObjectFromFileEntry","fullPath","calculateFreeSpace","getFreeDiskSpace","normalizeFileName","filename","decodeURIComponent","readFile","format","folder","readAsDataURL","readAsBinaryString","readAsArrayBuffer","readAsText","text","parsed","parseJSON","readFileData","fileData","reader","FileReader","onloadend","event","_event$target","_event$target2","target","code","message","hasStarted","onloadstart","setTimeout","writeFile","data","append","_this9","toString","extension","getFileExtension","type","getMimeType","Blob","replace","writeFileDataInFile","onProgress","offset","_this10","chunk","slice","Math","min","CHUNK_SIZE","lengthComputable","loaded","total","getExternalFile","getExternalFileSize","_this11","removeExternalFile","directory","lastIndexOf","getBasePath","getBasePathToDownload","_this12","toInternalURL","getBasePathInstant","moveDir","originalPath","newPath","destDirExists","_this13","copyOrMoveFileOrDir","moveFile","_this14","copyDir","from","to","_this15","copyFile","_this16","isDir","copy","_this17","fileIsInAppFolder","isPathInAppFolder","copyOrMoveExternalFile","moveCopyFn","args","toFileAndDir","getFileAndDirectoryFromPath","decodedFrom","decodedTo","name","getInternalURL","concatenatePaths","removeStartingSlash","unzipFile","destFolder","recreateDir","_this18","ignoreErrors","removeExtension","unzip","replaceInFile","search","newValue","_this19","content","match","getMetadata","getMetadataFromPath","promise","_this20","dirAndFile","copyTo","moveTo","copyExternalFile","moveExternalFile","getUniqueNameInFolder","dirPath","fileName","defaultExt","_this21","files","fileNameWithoutExtension","removeSpecialCharactersForFiles","forEach","toLowerCase","calculateUniqueName","usedNames","nameWithoutExtension","num","clearTmpFolder","_this22","TMPFOLDER","clearDeletedSitesFolder","existingSiteNames","_this23","contents","map","_ref2","includes","_x2","_unused","removeUnusedFiles","_this24","filesMap","_unused2","isFileInAppFolder","getWWWPath","location","pathname","href","position","getWWWAbsolutePath","cordova","applicationDirectory","convertFileSrc","src","isMobile","unconvertFileSrc","CONFIG","ioswebviewscheme","getFileName","isFileEntry","_class","factory","ɵfac","providedIn","CoreFile"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/file.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { FileEntry, DirectoryEntry, Entry, Metadata, IFile } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\n\nimport { CoreLogger } from '@singletons/logger';\nimport { makeSingleton, File, WebView } from '@singletons';\nimport { CoreFileEntry } from '@services/file-helper';\nimport { CoreText } from '@singletons/text';\nimport { CorePlatform } from '@services/platform';\nimport { CorePath } from '@singletons/path';\nimport { Zip } from '@features/native/plugins';\n\n/**\n * Progress event used when writing a file data into a file.\n */\nexport type CoreFileProgressEvent = {\n    /**\n     * Whether the values are reliabñe.\n     */\n    lengthComputable?: boolean;\n\n    /**\n     * Number of treated bytes.\n     */\n    loaded?: number;\n\n    /**\n     * Total of bytes.\n     */\n    total?: number;\n};\n\n/**\n * Progress function.\n */\nexport type CoreFileProgressFunction = (event: CoreFileProgressEvent) => void;\n\n/**\n * Constants to define the format to read a file.\n */\nexport const enum CoreFileFormat {\n    FORMATTEXT = 0,\n    FORMATDATAURL = 1,\n    FORMATBINARYSTRING = 2,\n    FORMATARRAYBUFFER = 3,\n    FORMATJSON = 4,\n}\n\n/**\n * Factory to interact with the file system.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFileProvider {\n\n    // Folders.\n    static readonly SITESFOLDER = 'sites';\n    static readonly TMPFOLDER = 'tmp';\n\n    static readonly CHUNK_SIZE = 1048576; // 1 MB. Same chunk size as Ionic Native.\n\n    protected logger: CoreLogger;\n    protected initialized = false;\n    protected basePath = '';\n    protected isHTMLAPI = false;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreFileProvider');\n    }\n\n    /**\n     * Sets basePath to use with HTML API. Reserved for core use.\n     *\n     * @param path Base path to use.\n     */\n    setHTMLBasePath(path: string): void {\n        this.isHTMLAPI = true;\n        this.basePath = path;\n    }\n\n    /**\n     * Checks if we're using HTML API.\n     *\n     * @returns True if uses HTML API, false otherwise.\n     */\n    usesHTMLAPI(): boolean {\n        return this.isHTMLAPI;\n    }\n\n    /**\n     * Initialize basePath based on the OS if it's not initialized already.\n     *\n     * @returns Promise to be resolved when the initialization is finished.\n     */\n    async init(): Promise<void> {\n        if (this.initialized) {\n            return;\n        }\n\n        await CorePlatform.ready();\n\n        if (CorePlatform.isAndroid()) {\n            this.basePath = File.externalApplicationStorageDirectory || this.basePath;\n        } else if (CorePlatform.isIOS()) {\n            this.basePath = File.documentsDirectory || this.basePath;\n        } else if (!this.isAvailable() || this.basePath === '') {\n            this.logger.error('Error getting device OS.');\n\n            return Promise.reject(new CoreError('Error getting device OS to initialize file system.'));\n        }\n\n        this.initialized = true;\n        this.logger.debug('FS initialized: ' + this.basePath);\n    }\n\n    /**\n     * Check if the plugin is available.\n     *\n     * @returns Whether the plugin is available.\n     */\n    isAvailable(): boolean {\n        return window.resolveLocalFileSystemURL !== undefined;\n    }\n\n    /**\n     * Get a file.\n     *\n     * @param path Relative path to the file.\n     * @returns Promise resolved when the file is retrieved.\n     */\n    getFile(path: string): Promise<FileEntry> {\n        return this.init().then(() => {\n            this.logger.debug('Get file: ' + path);\n\n            return File.resolveLocalFilesystemUrl(this.addBasePathIfNeeded(path));\n        }).then((entry) => <FileEntry> entry);\n    }\n\n    /**\n     * Get a directory.\n     *\n     * @param path Relative path to the directory.\n     * @returns Promise resolved when the directory is retrieved.\n     */\n    getDir(path: string): Promise<DirectoryEntry> {\n        return this.init().then(() => {\n            this.logger.debug('Get directory: ' + path);\n\n            return File.resolveDirectoryUrl(this.addBasePathIfNeeded(path));\n        });\n    }\n\n    /**\n     * Get site folder path.\n     *\n     * @param siteId Site ID.\n     * @returns Site folder path.\n     */\n    getSiteFolder(siteId: string): string {\n        return CoreFileProvider.SITESFOLDER + '/' + siteId;\n    }\n\n    /**\n     * Create a directory or a file.\n     *\n     * @param isDirectory True if a directory should be created, false if it should create a file.\n     * @param path Relative path to the dir/file.\n     * @param failIfExists True if it should fail if the dir/file exists, false otherwise.\n     * @param base Base path to create the dir/file in. If not set, use basePath.\n     * @returns Promise to be resolved when the dir/file is created.\n     */\n    protected async create(\n        isDirectory: boolean,\n        path: string,\n        failIfExists?: boolean,\n        base?: string,\n    ): Promise<FileEntry | DirectoryEntry> {\n        await this.init();\n\n        path = this.removeBasePath(path);\n        base = base || this.basePath;\n\n        if (path.indexOf('/') == -1) {\n            if (isDirectory) {\n                this.logger.debug('Create dir ' + path + ' in ' + base);\n\n                return File.createDir(base, path, !failIfExists);\n            } else {\n                this.logger.debug('Create file ' + path + ' in ' + base);\n\n                return File.createFile(base, path, !failIfExists);\n            }\n        } else {\n            // The file plugin doesn't allow creating more than 1 level at a time (e.g. tmp/folder).\n            // We need to create them 1 by 1.\n            const firstDir = path.substring(0, path.indexOf('/'));\n            const restOfPath = path.substring(path.indexOf('/') + 1);\n\n            this.logger.debug('Create dir ' + firstDir + ' in ' + base);\n\n            const newDirEntry = await File.createDir(base, firstDir, true);\n\n            return this.create(isDirectory, restOfPath, failIfExists, newDirEntry.toURL());\n        }\n    }\n\n    /**\n     * Create a directory.\n     *\n     * @param path Relative path to the directory.\n     * @param failIfExists True if it should fail if the directory exists, false otherwise.\n     * @returns Promise to be resolved when the directory is created.\n     */\n    async createDir(path: string, failIfExists?: boolean): Promise<DirectoryEntry> {\n        const entry = <DirectoryEntry> await this.create(true, path, failIfExists);\n\n        return entry;\n    }\n\n    /**\n     * Create a file.\n     *\n     * @param path Relative path to the file.\n     * @param failIfExists True if it should fail if the file exists, false otherwise..\n     * @returns Promise to be resolved when the file is created.\n     */\n    async createFile(path: string, failIfExists?: boolean): Promise<FileEntry> {\n        const entry = <FileEntry> await this.create(false, path, failIfExists);\n\n        return entry;\n    }\n\n    /**\n     * Removes a directory and all its contents.\n     *\n     * @param path Relative path to the directory.\n     * @returns Promise to be resolved when the directory is deleted.\n     */\n    async removeDir(path: string): Promise<void> {\n        await this.init();\n\n        path = this.removeBasePath(path);\n        this.logger.debug('Remove directory: ' + path);\n\n        await File.removeRecursively(this.basePath, path);\n    }\n\n    /**\n     * Removes a file and all its contents.\n     *\n     * @param path Relative path to the file.\n     * @returns Promise to be resolved when the file is deleted.\n     */\n    async removeFile(path: string): Promise<void> {\n        await this.init();\n\n        path = this.removeBasePath(path);\n        this.logger.debug('Remove file: ' + path);\n\n        try {\n            await File.removeFile(this.basePath, path);\n        } catch (error) {\n            // The delete can fail if the path has encoded characters. Try again if that's the case.\n            const decodedPath = decodeURI(path);\n\n            if (decodedPath != path) {\n                await File.removeFile(this.basePath, decodedPath);\n            } else {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Removes a file given its FileEntry.\n     *\n     * @param entry File Entry.\n     * @returns Promise resolved when the file is deleted.\n     */\n    removeFileByFileEntry(entry: Entry): Promise<void> {\n        return new Promise((resolve, reject) => entry.remove(resolve, reject));\n    }\n\n    /**\n     * Retrieve the contents of a directory (not subdirectories).\n     *\n     * @param path Relative path to the directory.\n     * @returns Promise to be resolved when the contents are retrieved.\n     */\n    async getDirectoryContents(path: string): Promise<(FileEntry | DirectoryEntry)[]> {\n        await this.init();\n\n        path = this.removeBasePath(path);\n        this.logger.debug('Get contents of dir: ' + path);\n\n        const result = await File.listDir(this.basePath, path);\n\n        return <(FileEntry | DirectoryEntry)[]> result;\n    }\n\n    /**\n     * Type guard to check if the param is a DirectoryEntry.\n     *\n     * @param entry Param to check.\n     * @returns Whether the param is a DirectoryEntry.\n     */\n    protected isDirectoryEntry(entry: FileEntry | DirectoryEntry): entry is DirectoryEntry {\n        return entry.isDirectory === true;\n    }\n\n    /**\n     * Calculate the size of a directory or a file.\n     *\n     * @param entry Directory or file.\n     * @returns Promise to be resolved when the size is calculated.\n     */\n    protected getSize(entry: DirectoryEntry | FileEntry): Promise<number> {\n        return new Promise<number>((resolve, reject) => {\n            if (this.isDirectoryEntry(entry)) {\n                const directoryReader = entry.createReader();\n\n                directoryReader.readEntries(async (entries: (DirectoryEntry | FileEntry)[]) => {\n                    const promises: Promise<number>[] = [];\n                    for (let i = 0; i < entries.length; i++) {\n                        promises.push(this.getSize(entries[i]));\n                    }\n\n                    try {\n                        const sizes = await Promise.all(promises);\n\n                        let directorySize = 0;\n                        for (let i = 0; i < sizes.length; i++) {\n                            const fileSize = Number(sizes[i]);\n                            if (isNaN(fileSize)) {\n                                reject();\n\n                                return;\n                            }\n                            directorySize += fileSize;\n                        }\n                        resolve(directorySize);\n                    } catch (error) {\n                        reject(error);\n                    }\n                }, reject);\n            } else {\n                entry.file((file) => {\n                    resolve(file.size);\n                }, reject);\n            }\n        });\n    }\n\n    /**\n     * Calculate the size of a directory.\n     *\n     * @param path Relative path to the directory.\n     * @returns Promise to be resolved when the size is calculated.\n     */\n    getDirectorySize(path: string): Promise<number> {\n        path = this.removeBasePath(path);\n\n        this.logger.debug('Get size of dir: ' + path);\n\n        return this.getDir(path).then((dirEntry) => this.getSize(dirEntry));\n    }\n\n    /**\n     * Calculate the size of a file.\n     *\n     * @param path Relative path to the file.\n     * @returns Promise to be resolved when the size is calculated.\n     */\n    getFileSize(path: string): Promise<number> {\n        path = this.removeBasePath(path);\n\n        this.logger.debug('Get size of file: ' + path);\n\n        return this.getFile(path).then((fileEntry) => this.getSize(fileEntry));\n    }\n\n    /**\n     * Get file object from a FileEntry.\n     *\n     * @param entry Relative path to the file.\n     * @returns Promise to be resolved when the file is retrieved.\n     */\n    getFileObjectFromFileEntry(entry: FileEntry): Promise<IFile> {\n        return new Promise((resolve, reject): void => {\n            this.logger.debug('Get file object of: ' + entry.fullPath);\n            entry.file(resolve, reject);\n        });\n    }\n\n    /**\n     * Calculate the free space in the disk.\n     * Please notice that this function isn't reliable and it's not documented in the Cordova File plugin.\n     *\n     * @returns Promise resolved with the estimated free space in bytes.\n     */\n    calculateFreeSpace(): Promise<number> {\n        return File.getFreeDiskSpace().then((size) => {\n            if (CorePlatform.isIOS()) {\n                // In iOS the size is in bytes.\n                return Number(size);\n            }\n\n            // The size is in KB, convert it to bytes.\n            return Number(size) * 1024;\n        });\n    }\n\n    /**\n     * Normalize a filename that usually comes URL encoded.\n     *\n     * @param filename The file name.\n     * @returns The file name normalized.\n     */\n    normalizeFileName(filename: string): string {\n        filename = CoreTextUtils.decodeURIComponent(filename);\n\n        return filename;\n    }\n\n    /**\n     * Read a file from local file system.\n     *\n     * @param path Relative path to the file.\n     * @param format Format to read the file.\n     * @param folder Absolute path to the folder where the file is. Use it to read files outside of the app's data folder.\n     * @returns Promise to be resolved when the file is read.\n     */\n    readFile(\n        path: string,\n        format?: CoreFileFormat.FORMATTEXT | CoreFileFormat.FORMATDATAURL | CoreFileFormat.FORMATBINARYSTRING,\n        folder?: string,\n    ): Promise<string>;\n    readFile(path: string, format: CoreFileFormat.FORMATARRAYBUFFER, folder?: string): Promise<ArrayBuffer>;\n    readFile<T = unknown>(path: string, format: CoreFileFormat.FORMATJSON, folder?: string): Promise<T>;\n    readFile(\n        path: string,\n        format: CoreFileFormat = CoreFileFormat.FORMATTEXT,\n        folder?: string,\n    ): Promise<string | ArrayBuffer | unknown> {\n        if (!folder) {\n            folder = this.basePath;\n\n            path = this.removeBasePath(path);\n        }\n\n        this.logger.debug(`Read file ${path} with format ${format} in folder ${folder}`);\n\n        switch (format) {\n            case CoreFileFormat.FORMATDATAURL:\n                return File.readAsDataURL(folder, path);\n            case CoreFileFormat.FORMATBINARYSTRING:\n                return File.readAsBinaryString(folder, path);\n            case CoreFileFormat.FORMATARRAYBUFFER:\n                return File.readAsArrayBuffer(folder, path);\n            case CoreFileFormat.FORMATJSON:\n                return File.readAsText(folder, path).then((text) => {\n                    const parsed = CoreTextUtils.parseJSON(text, null);\n\n                    if (parsed == null && text != null) {\n                        throw new CoreError('Error parsing JSON file: ' + path);\n                    }\n\n                    return parsed;\n                });\n            default:\n                return File.readAsText(folder, path);\n        }\n    }\n\n    /**\n     * Read file contents from a file data object.\n     *\n     * @param fileData File's data.\n     * @param format Format to read the file.\n     * @returns Promise to be resolved when the file is read.\n     */\n    readFileData(fileData: IFile, format: CoreFileFormat = CoreFileFormat.FORMATTEXT): Promise<string | ArrayBuffer | unknown> {\n        format = format || CoreFileFormat.FORMATTEXT;\n        this.logger.debug('Read file from file data with format ' + format);\n\n        return new Promise((resolve, reject): void => {\n            const reader = new FileReader();\n\n            reader.onloadend = (event): void => {\n                if (event.target?.result !== undefined && event.target.result !== null) {\n                    if (format == CoreFileFormat.FORMATJSON) {\n                        // Convert to object.\n                        const parsed = CoreTextUtils.parseJSON(<string> event.target.result, null);\n\n                        if (parsed == null) {\n                            reject('Error parsing JSON file.');\n                        }\n\n                        resolve(parsed);\n                    } else {\n                        resolve(event.target.result);\n                    }\n                } else if (event.target?.error !== undefined && event.target.error !== null) {\n                    reject(event.target.error);\n                } else {\n                    reject({ code: null, message: 'READER_ONLOADEND_ERR' });\n                }\n            };\n\n            // Check if the load starts. If it doesn't start in 3 seconds, reject.\n            // Sometimes in Android the read doesn't start for some reason, so the promise never finishes.\n            let hasStarted = false;\n            reader.onloadstart = () => {\n                hasStarted = true;\n            };\n            setTimeout(() => {\n                if (!hasStarted) {\n                    reject('Upload cannot start.');\n                }\n            }, 3000);\n\n            switch (format) {\n                case CoreFileFormat.FORMATDATAURL:\n                    reader.readAsDataURL(fileData);\n                    break;\n                case CoreFileFormat.FORMATBINARYSTRING:\n                    reader.readAsBinaryString(fileData);\n                    break;\n                case CoreFileFormat.FORMATARRAYBUFFER:\n                    reader.readAsArrayBuffer(fileData);\n                    break;\n                default:\n                    reader.readAsText(fileData);\n            }\n        });\n    }\n\n    /**\n     * Writes some data in a file.\n     *\n     * @param path Relative path to the file.\n     * @param data Data to write.\n     * @param append Whether to append the data to the end of the file.\n     * @returns Promise to be resolved when the file is written.\n     */\n    async writeFile(path: string, data: string | Blob, append?: boolean): Promise<FileEntry> {\n        await this.init();\n\n        path = this.removeBasePath(path);\n        this.logger.debug('Write file: ' + path);\n\n        // Create file (and parent folders) to prevent errors.\n        const fileEntry = await this.createFile(path);\n\n        if (this.isHTMLAPI && (typeof data == 'string' || data.toString() == '[object ArrayBuffer]')) {\n            // We need to write Blobs.\n            const extension = CoreMimetypeUtils.getFileExtension(path);\n            const type = extension ? CoreMimetypeUtils.getMimeType(extension) : '';\n            data = new Blob([data], { type: type || 'text/plain' });\n        }\n\n        await File.writeFile(this.basePath, path, data, { replace: !append, append: !!append });\n\n        return fileEntry;\n    }\n\n    /**\n     * Write some file data into a filesystem file.\n     * It's done in chunks to prevent crashing the app for big files.\n     * Please notice Ionic Native writeFile function already splits by chunks, but it doesn't have an onProgress function.\n     *\n     * @param file The data to write.\n     * @param path Path where to store the data.\n     * @param onProgress Function to call on progress.\n     * @param offset Offset where to start reading from.\n     * @param append Whether to append the data to the end of the file.\n     * @returns Promise resolved when done.\n     */\n    async writeFileDataInFile(\n        file: Blob,\n        path: string,\n        onProgress?: CoreFileProgressFunction,\n        offset: number = 0,\n        append?: boolean,\n    ): Promise<FileEntry> {\n        offset = offset || 0;\n\n        try {\n            // Get the chunk to write.\n            const chunk = file.slice(offset, Math.min(offset + CoreFileProvider.CHUNK_SIZE, file.size));\n\n            const fileEntry = await this.writeFile(path, chunk, append);\n\n            offset += CoreFileProvider.CHUNK_SIZE;\n\n            onProgress && onProgress({\n                lengthComputable: true,\n                loaded: offset,\n                total: file.size,\n            });\n\n            if (offset >= file.size) {\n                // Done, stop.\n                return fileEntry;\n            }\n\n            // Read the next chunk.\n            return this.writeFileDataInFile(file, path, onProgress, offset, true);\n        } catch (error) {\n            if (error && error.target && error.target.error) {\n                // Error returned by the writer, throw the \"real\" error.\n                throw error.target.error;\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Gets a file that might be outside the app's folder.\n     *\n     * @param fullPath Absolute path to the file.\n     * @returns Promise to be resolved when the file is retrieved.\n     */\n    getExternalFile(fullPath: string): Promise<FileEntry> {\n        return File.resolveLocalFilesystemUrl(fullPath).then((entry) => <FileEntry> entry);\n    }\n\n    /**\n     * Calculate the size of a file.\n     *\n     * @param path Absolute path to the file.\n     * @returns Promise to be resolved when the size is calculated.\n     */\n    async getExternalFileSize(path: string): Promise<number> {\n        const fileEntry = await this.getExternalFile(path);\n\n        return this.getSize(fileEntry);\n    }\n\n    /**\n     * Removes a file that might be outside the app's folder.\n     *\n     * @param fullPath Absolute path to the file.\n     * @returns Promise to be resolved when the file is removed.\n     */\n    async removeExternalFile(fullPath: string): Promise<void> {\n        const directory = fullPath.substring(0, fullPath.lastIndexOf('/'));\n        const filename = fullPath.substring(fullPath.lastIndexOf('/') + 1);\n\n        await File.removeFile(directory, filename);\n    }\n\n    /**\n     * Get the base path where the application files are stored.\n     *\n     * @returns Promise to be resolved when the base path is retrieved.\n     */\n    getBasePath(): Promise<string> {\n        return this.init().then(() => {\n            if (this.basePath.slice(-1) == '/') {\n                return this.basePath;\n            } else {\n                return this.basePath + '/';\n            }\n        });\n    }\n\n    /**\n     * Get the base path where the application files are stored in the format to be used for downloads.\n     * iOS: Internal URL (cdvfile://).\n     * Others: basePath (file://)\n     *\n     * @returns Promise to be resolved when the base path is retrieved.\n     */\n    async getBasePathToDownload(): Promise<string> {\n        await this.init();\n\n        if (CorePlatform.isIOS()) {\n            // In iOS we want the internal URL (cdvfile://localhost/persistent/...).\n            const dirEntry = await File.resolveDirectoryUrl(this.basePath);\n\n            return dirEntry.toInternalURL();\n        } else {\n            // In the other platforms we use the basePath as it is (file://...).\n            return this.basePath;\n        }\n    }\n\n    /**\n     * Get the base path where the application files are stored. Returns the value instantly, without waiting for it to be ready.\n     *\n     * @returns Base path. If the service hasn't been initialized it will return an invalid value.\n     */\n    getBasePathInstant(): string {\n        if (!this.basePath) {\n            return this.basePath;\n        } else if (this.basePath.slice(-1) == '/') {\n            return this.basePath;\n        } else {\n            return this.basePath + '/';\n        }\n    }\n\n    /**\n     * Move a dir.\n     *\n     * @param originalPath Path to the dir to move.\n     * @param newPath New path of the dir.\n     * @param destDirExists Set it to true if you know the directory where to put the dir exists. If false, the function will\n     *                      try to create it (slower).\n     * @returns Promise resolved when the entry is moved.\n     */\n    async moveDir(originalPath: string, newPath: string, destDirExists?: boolean): Promise<DirectoryEntry> {\n        const entry = await this.copyOrMoveFileOrDir(originalPath, newPath, true, false, destDirExists);\n\n        return <DirectoryEntry> entry;\n    }\n\n    /**\n     * Move a file.\n     *\n     * @param originalPath Path to the file to move.\n     * @param newPath New path of the file.\n     * @param destDirExists Set it to true if you know the directory where to put the file exists. If false, the function will\n     *                      try to create it (slower).\n     * @returns Promise resolved when the entry is moved.\n     */\n    async moveFile(originalPath: string, newPath: string, destDirExists?: boolean): Promise<FileEntry> {\n        const entry = await this.copyOrMoveFileOrDir(originalPath, newPath, false, false, destDirExists);\n\n        return <FileEntry> entry;\n    }\n\n    /**\n     * Copy a directory.\n     *\n     * @param from Path to the directory to move.\n     * @param to New path of the directory.\n     * @param destDirExists Set it to true if you know the directory where to put the dir exists. If false, the function will\n     *                      try to create it (slower).\n     * @returns Promise resolved when the entry is copied.\n     */\n    async copyDir(from: string, to: string, destDirExists?: boolean): Promise<DirectoryEntry> {\n        const entry = await this.copyOrMoveFileOrDir(from, to, true, true, destDirExists);\n\n        return <DirectoryEntry> entry;\n    }\n\n    /**\n     * Copy a file.\n     *\n     * @param from Path to the file to move.\n     * @param to New path of the file.\n     * @param destDirExists Set it to true if you know the directory where to put the file exists. If false, the function will\n     *                      try to create it (slower).\n     * @returns Promise resolved when the entry is copied.\n     */\n    async copyFile(from: string, to: string, destDirExists?: boolean): Promise<FileEntry> {\n        const entry = await this.copyOrMoveFileOrDir(from, to, false, true, destDirExists);\n\n        return <FileEntry> entry;\n    }\n\n    /**\n     * Copy or move a file or a directory.\n     *\n     * @param from Path to the file/dir to move.\n     * @param to New path of the file/dir.\n     * @param isDir Whether it's a dir or a file.\n     * @param copy Whether to copy. If false, it will move the file.\n     * @param destDirExists Set it to true if you know the directory where to put the file/dir exists. If false, the function will\n     *                      try to create it (slower).\n     * @returns Promise resolved when the entry is copied.\n     */\n    protected async copyOrMoveFileOrDir(\n        from: string,\n        to: string,\n        isDir?: boolean,\n        copy?: boolean,\n        destDirExists?: boolean,\n    ): Promise<FileEntry | DirectoryEntry> {\n        const fileIsInAppFolder = this.isPathInAppFolder(from);\n\n        if (!fileIsInAppFolder) {\n            return this.copyOrMoveExternalFile(from, to, copy);\n        }\n\n        const moveCopyFn: MoveCopyFunction = (...args) => copy ?\n            (isDir ? File.copyDir(...args) : File.copyFile(...args)) :\n            (isDir ? File.moveDir(...args) : File.moveFile(...args));\n\n        await this.init();\n\n        from = this.removeBasePath(from);\n        to = this.removeBasePath(to);\n\n        const toFileAndDir = this.getFileAndDirectoryFromPath(to);\n\n        if (toFileAndDir.directory && !destDirExists) {\n            // Create the target directory if it doesn't exist.\n            await this.createDir(toFileAndDir.directory);\n        }\n\n        try {\n            const entry = await moveCopyFn(this.basePath, from, this.basePath, to);\n\n            return <FileEntry | DirectoryEntry> entry;\n        } catch (error) {\n            // The copy can fail if the path has encoded characters. Try again if that's the case.\n            const decodedFrom = decodeURI(from);\n            const decodedTo = decodeURI(to);\n\n            if (from != decodedFrom || to != decodedTo) {\n                const entry = await moveCopyFn(this.basePath, decodedFrom, this.basePath, decodedTo);\n\n                return <FileEntry | DirectoryEntry> entry;\n            } else {\n                return Promise.reject(error);\n            }\n        }\n    }\n\n    /**\n     * Extract the file name and directory from a given path.\n     *\n     * @param path Path to be extracted.\n     * @returns Plain object containing the file name and directory.\n     * @description\n     * file.pdf         -> directory: '', name: 'file.pdf'\n     * /file.pdf        -> directory: '', name: 'file.pdf'\n     * path/file.pdf    -> directory: 'path', name: 'file.pdf'\n     * path/            -> directory: 'path', name: ''\n     * path             -> directory: '', name: 'path'\n     */\n    getFileAndDirectoryFromPath(path: string): {directory: string; name: string} {\n        const file = {\n            directory: '',\n            name: '',\n        };\n\n        file.directory = path.substring(0, path.lastIndexOf('/'));\n        file.name = path.substring(path.lastIndexOf('/') + 1);\n\n        return file;\n    }\n\n    /**\n     * Get the internal URL of a file.\n     * Please notice that with WKWebView these URLs no longer work in mobile. Use fileEntry.toURL() along with convertFileSrc.\n     *\n     * @param fileEntry File Entry.\n     * @returns Internal URL.\n     */\n    getInternalURL(fileEntry: FileEntry): string {\n        if (!fileEntry.toInternalURL) {\n            // File doesn't implement toInternalURL, use toURL.\n            return fileEntry.toURL();\n        }\n\n        return fileEntry.toInternalURL();\n    }\n\n    /**\n     * Adds the basePath to a path if it doesn't have it already.\n     *\n     * @param path Path to treat.\n     * @returns Path with basePath added.\n     */\n    addBasePathIfNeeded(path: string): string {\n        if (path.indexOf(this.basePath) > -1) {\n            return path;\n        } else {\n            return CorePath.concatenatePaths(this.basePath, path);\n        }\n    }\n\n    /**\n     * Remove the base path from a path.\n     *\n     * @param path Path to treat.\n     * @returns Path without basePath.\n     */\n    removeBasePath(path: string): string {\n        return CoreText.removeStartingSlash(path.replace(this.basePath, ''));\n    }\n\n    /**\n     * Unzips a file.\n     *\n     * @param path Path to the ZIP file.\n     * @param destFolder Path to the destination folder. If not defined, a new folder will be created with the\n     *                   same location and name as the ZIP file (without extension).\n     * @param onProgress Function to call on progress.\n     * @param recreateDir Delete the dest directory before unzipping. Defaults to true.\n     * @returns Promise resolved when the file is unzipped.\n     */\n    async unzipFile(\n        path: string,\n        destFolder?: string,\n        onProgress?: (progress: ProgressEvent) => void,\n        recreateDir: boolean = true,\n    ): Promise<void> {\n        // Get the source file.\n        const fileEntry = await this.getFile(path);\n\n        if (destFolder && recreateDir) {\n            // Make sure the dest dir doesn't exist already.\n            await CoreUtils.ignoreErrors(this.removeDir(destFolder));\n\n            // Now create the dir, otherwise if any of the ancestor dirs doesn't exist the unzip would fail.\n            await this.createDir(destFolder);\n        }\n\n        // If destFolder is not set, use same location as ZIP file. We need to use absolute paths (including basePath).\n        destFolder = this.addBasePathIfNeeded(destFolder || CoreMimetypeUtils.removeExtension(path));\n\n        const result = await Zip.unzip(fileEntry.toURL(), destFolder, onProgress);\n\n        if (result == -1) {\n            throw new CoreError('Unzip failed.');\n        }\n    }\n\n    /**\n     * Search a string or regexp in a file contents and replace it. The result is saved in the same file.\n     *\n     * @param path Path to the file.\n     * @param search Value to search.\n     * @param newValue New value.\n     * @returns Promise resolved in success.\n     */\n    async replaceInFile(path: string, search: string | RegExp, newValue: string): Promise<void> {\n        let content = <string> await this.readFile(path);\n\n        if (content === undefined || content === null || !content.replace) {\n            throw new CoreError(`Error reading file ${path}`);\n        }\n\n        if (content.match(search)) {\n            content = content.replace(search, newValue);\n\n            await this.writeFile(path, content);\n        }\n    }\n\n    /**\n     * Get a file/dir metadata given the file's entry.\n     *\n     * @param fileEntry FileEntry retrieved from getFile or similar.\n     * @returns Promise resolved with metadata.\n     */\n    getMetadata(fileEntry: Entry): Promise<Metadata> {\n        if (!fileEntry || !fileEntry.getMetadata) {\n            return Promise.reject(new CoreError('Cannot get metadata from file entry.'));\n        }\n\n        return new Promise((resolve, reject): void => {\n            fileEntry.getMetadata(resolve, reject);\n        });\n    }\n\n    /**\n     * Get a file/dir metadata given the path.\n     *\n     * @param path Path to the file/dir.\n     * @param isDir True if directory, false if file.\n     * @returns Promise resolved with metadata.\n     */\n    getMetadataFromPath(path: string, isDir?: boolean): Promise<Metadata> {\n        let promise;\n        if (isDir) {\n            promise = this.getDir(path);\n        } else {\n            promise = this.getFile(path);\n        }\n\n        return promise.then((entry) => this.getMetadata(entry));\n    }\n\n    /**\n     * Remove the starting slash of a path if it's there. E.g. '/sites/filepool' -> 'sites/filepool'.\n     *\n     * @param path Path.\n     * @returns Path without a slash in the first position.\n     * @deprecated since 4.1. Use CoreText.removeStartingSlash instead.\n     */\n    removeStartingSlash(path: string): string {\n        return CoreText.removeStartingSlash(path);\n    }\n\n    /**\n     * Convenience function to copy or move an external file.\n     *\n     * @param from Absolute path to the file to copy/move.\n     * @param to Relative new path of the file (inside the app folder).\n     * @param copy True to copy, false to move.\n     * @returns Promise resolved when the entry is copied/moved.\n     */\n    protected async copyOrMoveExternalFile(from: string, to: string, copy?: boolean): Promise<FileEntry> {\n        // Get the file to copy/move.\n        const fileEntry = await this.getExternalFile(from);\n\n        // Create the destination dir if it doesn't exist.\n        const dirAndFile = this.getFileAndDirectoryFromPath(to);\n\n        const dirEntry = await this.createDir(dirAndFile.directory);\n\n        // Now copy/move the file.\n        return new Promise((resolve, reject): void => {\n            if (copy) {\n                fileEntry.copyTo(dirEntry, dirAndFile.name, (entry: FileEntry) => resolve(entry), reject);\n            } else {\n                fileEntry.moveTo(dirEntry, dirAndFile.name, (entry: FileEntry) => resolve(entry), reject);\n            }\n        });\n    }\n\n    /**\n     * Copy a file from outside of the app folder to somewhere inside the app folder.\n     *\n     * @param from Absolute path to the file to copy.\n     * @param to Relative new path of the file (inside the app folder).\n     * @returns Promise resolved when the entry is copied.\n     */\n    copyExternalFile(from: string, to: string): Promise<FileEntry> {\n        return this.copyOrMoveExternalFile(from, to, true);\n    }\n\n    /**\n     * Move a file from outside of the app folder to somewhere inside the app folder.\n     *\n     * @param from Absolute path to the file to move.\n     * @param to Relative new path of the file (inside the app folder).\n     * @returns Promise resolved when the entry is moved.\n     */\n    moveExternalFile(from: string, to: string): Promise<FileEntry> {\n        return this.copyOrMoveExternalFile(from, to, false);\n    }\n\n    /**\n     * Get a unique file name inside a folder, adding numbers to the file name if needed.\n     *\n     * @param dirPath Path to the destination folder.\n     * @param fileName File name that wants to be used.\n     * @param defaultExt Default extension to use if no extension found in the file.\n     * @returns Promise resolved with the unique file name.\n     */\n    async getUniqueNameInFolder(dirPath: string, fileName: string, defaultExt?: string): Promise<string> {\n        // Get existing files in the folder.\n        try {\n            const entries = await this.getDirectoryContents(dirPath);\n\n            const files = {};\n            let fileNameWithoutExtension = CoreMimetypeUtils.removeExtension(fileName);\n            let extension = CoreMimetypeUtils.getFileExtension(fileName) || defaultExt;\n\n            // Clean the file name.\n            fileNameWithoutExtension = CoreTextUtils.removeSpecialCharactersForFiles(\n                CoreTextUtils.decodeURIComponent(fileNameWithoutExtension),\n            );\n\n            // Index the files by name.\n            entries.forEach((entry) => {\n                files[entry.name.toLowerCase()] = entry;\n            });\n\n            // Format extension.\n            if (extension) {\n                extension = '.' + extension;\n            } else {\n                extension = '';\n            }\n\n            return this.calculateUniqueName(files, fileNameWithoutExtension + extension);\n        } catch (error) {\n            // Folder doesn't exist, name is unique. Clean it and return it.\n            return CoreTextUtils.removeSpecialCharactersForFiles(CoreTextUtils.decodeURIComponent(fileName));\n        }\n    }\n\n    /**\n     * Given a file name and a set of already used names, calculate a unique name.\n     *\n     * @param usedNames Object with names already used as keys.\n     * @param name Name to check.\n     * @returns Unique name.\n     */\n    calculateUniqueName(usedNames: Record<string, unknown>, name: string): string {\n        if (usedNames[name.toLowerCase()] === undefined) {\n            // No file with the same name.\n            return name;\n        }\n\n        // Repeated name. Add a number until we find a free name.\n        const nameWithoutExtension = CoreMimetypeUtils.removeExtension(name);\n        let extension = CoreMimetypeUtils.getFileExtension(name);\n        let num = 1;\n        extension = extension ? '.' + extension : '';\n\n        do {\n            name = nameWithoutExtension + '(' + num + ')' + extension;\n            num++;\n        } while (usedNames[name.toLowerCase()] !== undefined);\n\n        return name;\n    }\n\n    /**\n     * Remove app temporary folder.\n     *\n     * @returns Promise resolved when done.\n     */\n    async clearTmpFolder(): Promise<void> {\n        // Ignore errors because the folder might not exist.\n        await CoreUtils.ignoreErrors(this.removeDir(CoreFileProvider.TMPFOLDER));\n    }\n\n    /**\n     * Remove deleted sites folders.\n     *\n     * @returns Promise resolved when done.\n     */\n    async clearDeletedSitesFolder(existingSiteNames: string[]): Promise<void> {\n        // Ignore errors because the folder might not exist.\n        const dirPath = CoreFileProvider.SITESFOLDER;\n\n        // Get the directory contents.\n        try {\n            const contents = await this.getDirectoryContents(dirPath);\n\n            if (!contents.length) {\n                return;\n            }\n\n            const promises: Promise<void>[] = contents.map(async (file) => {\n                if (file.isDirectory) {\n                    if (!existingSiteNames.includes(file.name)) {\n                        // Site does not exist... delete it.\n                        await CoreUtils.ignoreErrors(this.removeDir(this.getSiteFolder(file.name)));\n                    }\n                }\n            });\n\n            await Promise.all(promises);\n        } catch {\n            // Ignore errors, maybe it doesn't exist.\n        }\n    }\n\n    /**\n     * Given a folder path and a list of used files, remove all the files of the folder that aren't on the list of used files.\n     *\n     * @param dirPath Folder path.\n     * @param files List of used files.\n     * @returns Promise resolved when done, rejected if failure.\n     */\n    async removeUnusedFiles(dirPath: string, files: CoreFileEntry[]): Promise<void> {\n        // Get the directory contents.\n        try {\n            const contents = await this.getDirectoryContents(dirPath);\n\n            if (!contents.length) {\n                return;\n            }\n\n            const filesMap: {[fullPath: string]: FileEntry} = {};\n            const promises: Promise<void>[] = [];\n\n            // Index the received files by fullPath and ignore the invalid ones.\n            files.forEach((file) => {\n                if ('fullPath' in file) {\n                    filesMap[file.fullPath] = file;\n                }\n            });\n\n            // Check which of the content files aren't used anymore and delete them.\n            contents.forEach((file) => {\n                if (!filesMap[file.fullPath]) {\n                    // File isn't used, delete it.\n                    promises.push(this.removeFileByFileEntry(file));\n                }\n            });\n\n            await Promise.all(promises);\n        } catch {\n            // Ignore errors, maybe it doesn't exist.\n        }\n    }\n\n    /**\n     * Check if a file is inside the app's folder.\n     *\n     * @param path The absolute path of the file to check.\n     * @returns Whether the file is in the app's folder.\n     */\n    isFileInAppFolder(path: string): boolean {\n        return path.indexOf(this.basePath) != -1;\n    }\n\n    /**\n     * Get the path to the www folder at runtime based on the WebView URL.\n     *\n     * @returns Path.\n     */\n    getWWWPath(): string {\n        // Use current URL, removing the path.\n        if (!window.location.pathname || window.location.pathname == '/') {\n            return window.location.href;\n        }\n\n        const position = window.location.href.indexOf(window.location.pathname);\n\n        if (position != -1) {\n            return window.location.href.substring(0, position);\n        }\n\n        return window.location.href;\n    }\n\n    /**\n     * Get the full path to the www folder.\n     *\n     * @returns Path.\n     */\n    getWWWAbsolutePath(): string {\n        if (window.cordova && cordova.file && cordova.file.applicationDirectory) {\n            return CorePath.concatenatePaths(cordova.file.applicationDirectory, 'www');\n        }\n\n        // Cannot use Cordova to get it, use the WebView URL.\n        return this.getWWWPath();\n    }\n\n    /**\n     * Helper function to call Ionic WebView convertFileSrc only in the needed platforms.\n     * This is needed to make files work with the Ionic WebView plugin.\n     *\n     * @param src Source to convert.\n     * @returns Converted src.\n     */\n    convertFileSrc(src: string): string {\n        return CorePlatform.isMobile() ? WebView.convertFileSrc(src) : src;\n    }\n\n    /**\n     * Undo the conversion of convertFileSrc.\n     *\n     * @param src Source to unconvert.\n     * @returns Unconverted src.\n     */\n    unconvertFileSrc(src: string): string {\n        if (!CorePlatform.isMobile()) {\n            return src;\n        }\n\n        if (CorePlatform.isIOS()) {\n            return src.replace(CoreConstants.CONFIG.ioswebviewscheme + '://localhost/_app_file_', 'file://');\n        }\n\n        return src.replace('http://localhost/_app_file_', 'file://');\n    }\n\n    /**\n     * Check if a certain path is in the app's folder (basePath).\n     *\n     * @param path Path to check.\n     * @returns Whether it's in the app folder.\n     */\n    protected isPathInAppFolder(path: string): boolean {\n        return !path || !path.match(/^[a-z0-9]+:\\/\\//i) || path.indexOf(this.basePath) != -1;\n    }\n\n    /**\n     * Get the file's name.\n     *\n     * @param file The file.\n     * @returns The file name.\n     */\n    getFileName(file: CoreFileEntry): string | undefined {\n        return CoreUtils.isFileEntry(file) ? file.name : file.filename;\n    }\n\n}\n\nexport const CoreFile = makeSingleton(CoreFileProvider);\n\ntype MoveCopyFunction = (path: string, name: string, newPath: string, newName: string) => Promise<Entry>;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}