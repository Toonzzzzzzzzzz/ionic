{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreQuestionBehaviourDelegate } from '@features/question/services/behaviour-delegate';\nimport { CoreQuestion } from '@features/question/services/question';\nimport { CoreSites } from '@services/sites';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { ATTEMPTS_TABLE_NAME } from './database/quiz';\nimport { AddonModQuizProvider } from './quiz';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline quiz.\n */\nexport class AddonModQuizOfflineProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('AddonModQuizOfflineProvider');\n  }\n  /**\n   * Classify the answers in questions.\n   *\n   * @param answers List of answers.\n   * @returns Object with the questions, the keys are the slot. Each question contains its answers.\n   */\n  classifyAnswersInQuestions(answers) {\n    const questionsWithAnswers = {};\n    // Classify the answers in each question.\n    for (const name in answers) {\n      const slot = CoreQuestion.getQuestionSlotFromName(name);\n      const nameWithoutPrefix = CoreQuestion.removeQuestionPrefix(name);\n      if (!questionsWithAnswers[slot]) {\n        questionsWithAnswers[slot] = {\n          answers: {},\n          prefix: name.substring(0, name.indexOf(nameWithoutPrefix))\n        };\n      }\n      questionsWithAnswers[slot].answers[nameWithoutPrefix] = answers[name];\n    }\n    return questionsWithAnswers;\n  }\n  /**\n   * Given a list of questions with answers classified in it, returns a list of answers (including prefix in the name).\n   *\n   * @param questions Questions.\n   * @returns Answers.\n   */\n  extractAnswersFromQuestions(questions) {\n    const answers = {};\n    for (const slot in questions) {\n      const question = questions[slot];\n      for (const name in question.answers) {\n        answers[question.prefix + name] = question.answers[name];\n      }\n    }\n    return answers;\n  }\n  /**\n   * Get all the offline attempts in a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the offline attempts.\n   */\n  getAllAttempts(siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      return db.getAllRecords(ATTEMPTS_TABLE_NAME);\n    })();\n  }\n  /**\n   * Retrieve an attempt answers from site DB.\n   *\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the answers.\n   */\n  getAttemptAnswers(attemptId, siteId) {\n    return CoreQuestion.getAttemptAnswers(AddonModQuizProvider.COMPONENT, attemptId, siteId);\n  }\n  /**\n   * Retrieve an attempt from site DB.\n   *\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the attempt.\n   */\n  getAttemptById(attemptId, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      return db.getRecord(ATTEMPTS_TABLE_NAME, {\n        id: attemptId\n      });\n    })();\n  }\n  /**\n   * Retrieve an attempt from site DB.\n   *\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, user current site's user.\n   * @returns Promise resolved with the attempts.\n   */\n  getQuizAttempts(quizId, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecords(ATTEMPTS_TABLE_NAME, {\n        quizid: quizId,\n        userid: userId || site.getUserId()\n      });\n    })();\n  }\n  /**\n   * Load local state in the questions.\n   *\n   * @param attemptId Attempt ID.\n   * @param questions List of questions.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  loadQuestionsLocalStates(attemptId, questions, siteId) {\n    return _asyncToGenerator(function* () {\n      yield Promise.all(questions.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (question) {\n          const dbQuestion = yield CoreUtils.ignoreErrors(CoreQuestion.getQuestion(AddonModQuizProvider.COMPONENT, attemptId, question.slot, siteId));\n          if (!dbQuestion) {\n            // Question not found.\n            return;\n          }\n          const state = CoreQuestion.getState(dbQuestion.state);\n          question.state = dbQuestion.state;\n          question.status = Translate.instant('core.question.' + state.status);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return questions;\n    })();\n  }\n  /**\n   * Process an attempt, saving its data.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param questions Object with the questions of the quiz. The keys should be the question slot.\n   * @param data Data to save.\n   * @param finish Whether to finish the quiz.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  processAttempt(quiz, attempt, questions, data, finish, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const now = CoreTimeUtils.timestamp();\n      const db = yield CoreSites.getSiteDb(siteId);\n      // Check if an attempt already exists. Return a new one if it doesn't.\n      let entry = yield CoreUtils.ignoreErrors(_this.getAttemptById(attempt.id, siteId));\n      if (entry) {\n        entry.timemodified = now;\n        entry.finished = finish ? 1 : 0;\n      } else {\n        var _attempt$userid, _attempt$attempt;\n        entry = {\n          quizid: quiz.id,\n          userid: (_attempt$userid = attempt.userid) !== null && _attempt$userid !== void 0 ? _attempt$userid : CoreSites.getCurrentSiteUserId(),\n          id: attempt.id,\n          courseid: quiz.course,\n          timecreated: now,\n          attempt: (_attempt$attempt = attempt.attempt) !== null && _attempt$attempt !== void 0 ? _attempt$attempt : 0,\n          currentpage: attempt.currentpage,\n          timemodified: now,\n          finished: finish ? 1 : 0\n        };\n      }\n      // Save attempt in DB.\n      yield db.insertRecord(ATTEMPTS_TABLE_NAME, entry);\n      // Attempt has been saved, now we need to save the answers.\n      yield _this.saveAnswers(quiz, attempt, questions, data, now, siteId);\n    })();\n  }\n  /**\n   * Remove an attempt and its answers from local DB.\n   *\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  removeAttemptAndAnswers(attemptId, siteId) {\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const db = yield CoreSites.getSiteDb(siteId);\n      yield Promise.all([CoreQuestion.removeAttemptAnswers(AddonModQuizProvider.COMPONENT, attemptId, siteId), CoreQuestion.removeAttemptQuestions(AddonModQuizProvider.COMPONENT, attemptId, siteId), db.deleteRecords(ATTEMPTS_TABLE_NAME, {\n        id: attemptId\n      })]);\n    })();\n  }\n  /**\n   * Remove a question and its answers from local DB.\n   *\n   * @param attemptId Attempt ID.\n   * @param slot Question slot.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when finished.\n   */\n  removeQuestionAndAnswers(attemptId, slot, siteId) {\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield Promise.all([CoreQuestion.removeQuestion(AddonModQuizProvider.COMPONENT, attemptId, slot, siteId), CoreQuestion.removeQuestionAnswers(AddonModQuizProvider.COMPONENT, attemptId, slot, siteId)]);\n    })();\n  }\n  /**\n   * Save an attempt's answers and calculate state for questions modified.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param questions Object with the questions of the quiz. The keys should be the question slot.\n   * @param answers Answers to save.\n   * @param timeMod Time modified to set in the answers. If not defined, current time.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  saveAnswers(quiz, attempt, questions, answers, timeMod, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _attempt$userid2;\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      timeMod = timeMod || CoreTimeUtils.timestamp();\n      const questionsWithAnswers = {};\n      const newStates = {};\n      // Classify the answers in each question.\n      for (const name in answers) {\n        const slot = CoreQuestion.getQuestionSlotFromName(name);\n        const nameWithoutPrefix = CoreQuestion.removeQuestionPrefix(name);\n        if (questions[slot]) {\n          if (!questionsWithAnswers[slot]) {\n            questionsWithAnswers[slot] = _objectSpread(_objectSpread({}, questions[slot]), {}, {\n              answers: {}\n            });\n          }\n          questionsWithAnswers[slot].answers[nameWithoutPrefix] = answers[name];\n        }\n      }\n      // First determine the new state of each question. We won't save the new state yet.\n      yield Promise.all(Object.values(questionsWithAnswers).map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (question) {\n          var _quiz$preferredbehavi;\n          const state = yield CoreQuestionBehaviourDelegate.determineNewState((_quiz$preferredbehavi = quiz.preferredbehaviour) !== null && _quiz$preferredbehavi !== void 0 ? _quiz$preferredbehavi : '', AddonModQuizProvider.COMPONENT, attempt.id, question, quiz.coursemodule, siteId);\n          // Check if state has changed.\n          if (state && state.name != question.state) {\n            newStates[question.slot] = state.name;\n          }\n          // Delete previously stored answers for this question.\n          yield CoreQuestion.removeQuestionAnswers(AddonModQuizProvider.COMPONENT, attempt.id, question.slot, siteId);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      // Now save the answers.\n      yield CoreQuestion.saveAnswers(AddonModQuizProvider.COMPONENT, quiz.id, attempt.id, (_attempt$userid2 = attempt.userid) !== null && _attempt$userid2 !== void 0 ? _attempt$userid2 : CoreSites.getCurrentSiteUserId(), answers, timeMod, siteId);\n      try {\n        // Answers have been saved, now we can save the questions with the states.\n        yield CoreUtils.allPromises(Object.keys(newStates).map( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (slot) {\n            var _attempt$userid3;\n            const question = questionsWithAnswers[Number(slot)];\n            yield CoreQuestion.saveQuestion(AddonModQuizProvider.COMPONENT, quiz.id, attempt.id, (_attempt$userid3 = attempt.userid) !== null && _attempt$userid3 !== void 0 ? _attempt$userid3 : CoreSites.getCurrentSiteUserId(), question, newStates[slot], siteId);\n          });\n          return function (_x3) {\n            return _ref3.apply(this, arguments);\n          };\n        }()));\n      } catch (error) {\n        // Ignore errors when saving question state.\n        _this2.logger.error('Error saving question state', error);\n      }\n    })();\n  }\n  /**\n   * Set attempt's current page.\n   *\n   * @param attemptId Attempt ID.\n   * @param page Page to set.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success, rejected otherwise.\n   */\n  setAttemptCurrentPage(attemptId, page, siteId) {\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      yield db.updateRecords(ATTEMPTS_TABLE_NAME, {\n        currentpage: page\n      }, {\n        id: attemptId\n      });\n    })();\n  }\n}\n_class = AddonModQuizOfflineProvider;\n_class.ɵfac = function AddonModQuizOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModQuizOffline = makeSingleton(AddonModQuizOfflineProvider);","map":{"version":3,"names":["CoreQuestionBehaviourDelegate","CoreQuestion","CoreSites","CoreTimeUtils","CoreUtils","makeSingleton","Translate","CoreLogger","ATTEMPTS_TABLE_NAME","AddonModQuizProvider","AddonModQuizOfflineProvider","constructor","logger","getInstance","classifyAnswersInQuestions","answers","questionsWithAnswers","name","slot","getQuestionSlotFromName","nameWithoutPrefix","removeQuestionPrefix","prefix","substring","indexOf","extractAnswersFromQuestions","questions","question","getAllAttempts","siteId","_asyncToGenerator","db","getSiteDb","getAllRecords","getAttemptAnswers","attemptId","COMPONENT","getAttemptById","getRecord","id","getQuizAttempts","quizId","userId","site","getSite","getDb","getRecords","quizid","userid","getUserId","loadQuestionsLocalStates","Promise","all","map","_ref","dbQuestion","ignoreErrors","getQuestion","state","getState","status","instant","_x","apply","arguments","processAttempt","quiz","attempt","data","finish","_this","getCurrentSiteId","now","timestamp","entry","timemodified","finished","_attempt$userid","_attempt$attempt","getCurrentSiteUserId","courseid","course","timecreated","currentpage","insertRecord","saveAnswers","removeAttemptAndAnswers","removeAttemptAnswers","removeAttemptQuestions","deleteRecords","removeQuestionAndAnswers","removeQuestion","removeQuestionAnswers","timeMod","_this2","_attempt$userid2","newStates","_objectSpread","Object","values","_ref2","_quiz$preferredbehavi","determineNewState","preferredbehaviour","coursemodule","_x2","allPromises","keys","_ref3","_attempt$userid3","Number","saveQuestion","_x3","error","setAttemptCurrentPage","page","updateRecords","factory","ɵfac","providedIn","AddonModQuizOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/quiz/services/quiz-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreQuestionBehaviourDelegate, CoreQuestionQuestionWithAnswers } from '@features/question/services/behaviour-delegate';\nimport { CoreQuestionAnswerDBRecord } from '@features/question/services/database/question';\nimport { CoreQuestion, CoreQuestionQuestionParsed, CoreQuestionsAnswers } from '@features/question/services/question';\nimport { CoreSites } from '@services/sites';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { AddonModQuizAttemptDBRecord, ATTEMPTS_TABLE_NAME } from './database/quiz';\nimport { AddonModQuizAttemptWSData, AddonModQuizProvider, AddonModQuizQuizWSData } from './quiz';\n\n/**\n * Service to handle offline quiz.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModQuizOfflineProvider {\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('AddonModQuizOfflineProvider');\n    }\n\n    /**\n     * Classify the answers in questions.\n     *\n     * @param answers List of answers.\n     * @returns Object with the questions, the keys are the slot. Each question contains its answers.\n     */\n    classifyAnswersInQuestions(answers: CoreQuestionsAnswers): AddonModQuizQuestionsWithAnswers {\n        const questionsWithAnswers: AddonModQuizQuestionsWithAnswers = {};\n\n        // Classify the answers in each question.\n        for (const name in answers) {\n            const slot = CoreQuestion.getQuestionSlotFromName(name);\n            const nameWithoutPrefix = CoreQuestion.removeQuestionPrefix(name);\n\n            if (!questionsWithAnswers[slot]) {\n                questionsWithAnswers[slot] = {\n                    answers: {},\n                    prefix: name.substring(0, name.indexOf(nameWithoutPrefix)),\n                };\n            }\n            questionsWithAnswers[slot].answers[nameWithoutPrefix] = answers[name];\n        }\n\n        return questionsWithAnswers;\n    }\n\n    /**\n     * Given a list of questions with answers classified in it, returns a list of answers (including prefix in the name).\n     *\n     * @param questions Questions.\n     * @returns Answers.\n     */\n    extractAnswersFromQuestions(questions: AddonModQuizQuestionsWithAnswers): CoreQuestionsAnswers {\n        const answers: CoreQuestionsAnswers = {};\n\n        for (const slot in questions) {\n            const question = questions[slot];\n\n            for (const name in question.answers) {\n                answers[question.prefix + name] = question.answers[name];\n            }\n        }\n\n        return answers;\n    }\n\n    /**\n     * Get all the offline attempts in a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the offline attempts.\n     */\n    async getAllAttempts(siteId?: string): Promise<AddonModQuizAttemptDBRecord[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        return db.getAllRecords(ATTEMPTS_TABLE_NAME);\n    }\n\n    /**\n     * Retrieve an attempt answers from site DB.\n     *\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the answers.\n     */\n    getAttemptAnswers(attemptId: number, siteId?: string): Promise<CoreQuestionAnswerDBRecord[]> {\n        return CoreQuestion.getAttemptAnswers(AddonModQuizProvider.COMPONENT, attemptId, siteId);\n    }\n\n    /**\n     * Retrieve an attempt from site DB.\n     *\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the attempt.\n     */\n    async getAttemptById(attemptId: number, siteId?: string): Promise<AddonModQuizAttemptDBRecord> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        return db.getRecord(ATTEMPTS_TABLE_NAME, { id: attemptId });\n    }\n\n    /**\n     * Retrieve an attempt from site DB.\n     *\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, user current site's user.\n     * @returns Promise resolved with the attempts.\n     */\n    async getQuizAttempts(quizId: number, siteId?: string, userId?: number): Promise<AddonModQuizAttemptDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecords(ATTEMPTS_TABLE_NAME, { quizid: quizId, userid: userId || site.getUserId() });\n    }\n\n    /**\n     * Load local state in the questions.\n     *\n     * @param attemptId Attempt ID.\n     * @param questions List of questions.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async loadQuestionsLocalStates(\n        attemptId: number,\n        questions: CoreQuestionQuestionParsed[],\n        siteId?: string,\n    ): Promise<CoreQuestionQuestionParsed[]> {\n\n        await Promise.all(questions.map(async (question) => {\n            const dbQuestion = await CoreUtils.ignoreErrors(\n                CoreQuestion.getQuestion(AddonModQuizProvider.COMPONENT, attemptId, question.slot, siteId),\n            );\n\n            if (!dbQuestion) {\n                // Question not found.\n                return;\n            }\n\n            const state = CoreQuestion.getState(dbQuestion.state);\n            question.state = dbQuestion.state;\n            question.status = Translate.instant('core.question.' + state.status);\n        }));\n\n        return questions;\n    }\n\n    /**\n     * Process an attempt, saving its data.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param questions Object with the questions of the quiz. The keys should be the question slot.\n     * @param data Data to save.\n     * @param finish Whether to finish the quiz.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    async processAttempt(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData,\n        questions: Record<number, CoreQuestionQuestionParsed>,\n        data: CoreQuestionsAnswers,\n        finish?: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n        const now = CoreTimeUtils.timestamp();\n\n        const db = await CoreSites.getSiteDb(siteId);\n\n        // Check if an attempt already exists. Return a new one if it doesn't.\n        let entry = await CoreUtils.ignoreErrors(this.getAttemptById(attempt.id, siteId));\n\n        if (entry) {\n            entry.timemodified = now;\n            entry.finished = finish ? 1 : 0;\n        } else {\n            entry = {\n                quizid: quiz.id,\n                userid: attempt.userid ?? CoreSites.getCurrentSiteUserId(),\n                id: attempt.id,\n                courseid: quiz.course,\n                timecreated: now,\n                attempt: attempt.attempt ?? 0,\n                currentpage: attempt.currentpage,\n                timemodified: now,\n                finished: finish ? 1 : 0,\n            };\n        }\n\n        // Save attempt in DB.\n        await db.insertRecord(ATTEMPTS_TABLE_NAME, entry);\n\n        // Attempt has been saved, now we need to save the answers.\n        await this.saveAnswers(quiz, attempt, questions, data, now, siteId);\n    }\n\n    /**\n     * Remove an attempt and its answers from local DB.\n     *\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async removeAttemptAndAnswers(attemptId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const db = await CoreSites.getSiteDb(siteId);\n\n        await Promise.all([\n            CoreQuestion.removeAttemptAnswers(AddonModQuizProvider.COMPONENT, attemptId, siteId),\n            CoreQuestion.removeAttemptQuestions(AddonModQuizProvider.COMPONENT, attemptId, siteId),\n            db.deleteRecords(ATTEMPTS_TABLE_NAME, { id: attemptId }),\n        ]);\n    }\n\n    /**\n     * Remove a question and its answers from local DB.\n     *\n     * @param attemptId Attempt ID.\n     * @param slot Question slot.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when finished.\n     */\n    async removeQuestionAndAnswers(attemptId: number, slot: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await Promise.all([\n            CoreQuestion.removeQuestion(AddonModQuizProvider.COMPONENT, attemptId, slot, siteId),\n            CoreQuestion.removeQuestionAnswers(AddonModQuizProvider.COMPONENT, attemptId, slot, siteId),\n        ]);\n    }\n\n    /**\n     * Save an attempt's answers and calculate state for questions modified.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param questions Object with the questions of the quiz. The keys should be the question slot.\n     * @param answers Answers to save.\n     * @param timeMod Time modified to set in the answers. If not defined, current time.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async saveAnswers(\n        quiz: AddonModQuizQuizWSData,\n        attempt: AddonModQuizAttemptWSData,\n        questions: Record<number, CoreQuestionQuestionParsed>,\n        answers: CoreQuestionsAnswers,\n        timeMod?: number,\n        siteId?: string,\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n        timeMod = timeMod || CoreTimeUtils.timestamp();\n\n        const questionsWithAnswers: Record<number, CoreQuestionQuestionWithAnswers> = {};\n        const newStates: Record<number, string> = {};\n\n        // Classify the answers in each question.\n        for (const name in answers) {\n            const slot = CoreQuestion.getQuestionSlotFromName(name);\n            const nameWithoutPrefix = CoreQuestion.removeQuestionPrefix(name);\n\n            if (questions[slot]) {\n                if (!questionsWithAnswers[slot]) {\n                    questionsWithAnswers[slot] = {\n                        ...questions[slot],\n                        answers: {},\n                    };\n                }\n                questionsWithAnswers[slot].answers[nameWithoutPrefix] = answers[name];\n            }\n        }\n\n        // First determine the new state of each question. We won't save the new state yet.\n        await Promise.all(Object.values(questionsWithAnswers).map(async (question) => {\n\n            const state = await CoreQuestionBehaviourDelegate.determineNewState(\n                quiz.preferredbehaviour ?? '',\n                AddonModQuizProvider.COMPONENT,\n                attempt.id,\n                question,\n                quiz.coursemodule,\n                siteId,\n            );\n\n            // Check if state has changed.\n            if (state && state.name != question.state) {\n                newStates[question.slot] = state.name;\n            }\n\n            // Delete previously stored answers for this question.\n            await CoreQuestion.removeQuestionAnswers(AddonModQuizProvider.COMPONENT, attempt.id, question.slot, siteId);\n        }));\n\n        // Now save the answers.\n        await CoreQuestion.saveAnswers(\n            AddonModQuizProvider.COMPONENT,\n            quiz.id,\n            attempt.id,\n            attempt.userid ?? CoreSites.getCurrentSiteUserId(),\n            answers,\n            timeMod,\n            siteId,\n        );\n\n        try {\n            // Answers have been saved, now we can save the questions with the states.\n            await CoreUtils.allPromises(Object.keys(newStates).map(async (slot) => {\n                const question = questionsWithAnswers[Number(slot)];\n\n                await CoreQuestion.saveQuestion(\n                    AddonModQuizProvider.COMPONENT,\n                    quiz.id,\n                    attempt.id,\n                    attempt.userid ?? CoreSites.getCurrentSiteUserId(),\n                    question,\n                    newStates[slot],\n                    siteId,\n                );\n            }));\n        } catch (error) {\n            // Ignore errors when saving question state.\n            this.logger.error('Error saving question state', error);\n        }\n\n    }\n\n    /**\n     * Set attempt's current page.\n     *\n     * @param attemptId Attempt ID.\n     * @param page Page to set.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success, rejected otherwise.\n     */\n    async setAttemptCurrentPage(attemptId: number, page: number, siteId?: string): Promise<void> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        await db.updateRecords(ATTEMPTS_TABLE_NAME, { currentpage: page }, { id: attemptId });\n    }\n\n}\n\nexport const AddonModQuizOffline = makeSingleton(AddonModQuizOfflineProvider);\n\n/**\n * Answers classified by question slot.\n */\nexport type AddonModQuizQuestionsWithAnswers = Record<number, {\n    prefix: string;\n    answers: CoreQuestionsAnswers;\n}>;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}