{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { Md5 } from 'ts-md5/dist/md5';\nimport { CoreApp } from '@services/app';\nimport { CoreNetwork } from '@services/network';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreFile } from '@services/file';\nimport { CorePluginFileDelegate } from '@services/plugin-file-delegate';\nimport { CoreSites } from '@services/sites';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreConstants } from '@/core/constants';\nimport { ApplicationInit, makeSingleton, NgZone, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { APP_SCHEMA, FILES_TABLE_NAME, QUEUE_TABLE_NAME, PACKAGES_TABLE_NAME, LINKS_TABLE_NAME } from '@services/database/filepool';\nimport { CoreFileHelper } from './file-helper';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport { lazyMap } from '../utils/lazy-map';\nimport { asyncInstance } from '../utils/async-instance';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CoreAnalytics, CoreAnalyticsEventType } from './analytics';\nimport * as i0 from \"@angular/core\";\n/*\n * Factory for handling downloading files and retrieve downloaded files.\n *\n * @description\n * This factory is responsible for handling downloading files.\n *\n * The two main goals of this is to keep the content available offline, and improve the user experience by caching\n * the content locally.\n */\nexport class CoreFilepoolProvider {\n  constructor() {\n    this.queueState = CoreFilepoolProvider.QUEUE_PAUSED;\n    this.urlAttributes = [new RegExp('(\\\\?|&)token=([A-Za-z0-9]*)'), new RegExp('(\\\\?|&)forcedownload=[0-1]'), new RegExp('(\\\\?|&)preview=[A-Za-z0-9]+'), new RegExp('(\\\\?|&)offline=[0-1]', 'g')];\n    // To handle file downloads using the queue.\n    this.queueDeferreds = {};\n    this.sizeCache = {}; // A \"cache\" to store file sizes.\n    // Variables to prevent downloading packages/files twice at the same time.\n    this.packagesPromises = {};\n    this.filePromises = {};\n    this.queueTable = asyncInstance();\n    this.logger = CoreLogger.getInstance('CoreFilepoolProvider');\n    this.filesTables = lazyMap(siteId => asyncInstance(() => CoreSites.getSiteTable(FILES_TABLE_NAME, {\n      siteId,\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.Lazy\n      },\n      primaryKeyColumns: ['fileId'],\n      onDestroy: () => delete this.filesTables[siteId]\n    })));\n    this.linksTables = lazyMap(siteId => asyncInstance(() => CoreSites.getSiteTable(LINKS_TABLE_NAME, {\n      siteId,\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.Lazy\n      },\n      primaryKeyColumns: ['fileId', 'component', 'componentId'],\n      onDestroy: () => delete this.linksTables[siteId]\n    })));\n    this.packagesTables = lazyMap(siteId => asyncInstance(() => CoreSites.getSiteTable(PACKAGES_TABLE_NAME, {\n      siteId,\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.Lazy\n      },\n      onDestroy: () => delete this.packagesTables[siteId]\n    })));\n  }\n  /**\n   * Initialize queue.\n   */\n  initialize() {\n    // Start processing the queue once the app is ready.\n    ApplicationInit.whenDone(() => {\n      this.checkQueueProcessing();\n      // Start queue when device goes online.\n      CoreNetwork.onConnectShouldBeStable().subscribe(() => {\n        // Execute the callback in the Angular zone, so change detection doesn't stop working.\n        NgZone.run(() => this.checkQueueProcessing());\n      });\n    });\n  }\n  /**\n   * Initialize database.\n   */\n  initializeDatabase() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield CoreApp.createTablesFromSchema(APP_SCHEMA);\n      } catch (e) {\n        // Ignore errors.\n      }\n      const queueTable = new CoreDatabaseTableProxy({\n        cachingStrategy: CoreDatabaseCachingStrategy.Lazy\n      }, CoreApp.getDB(), QUEUE_TABLE_NAME, ['siteId', 'fileId']);\n      yield queueTable.initialize();\n      _this.queueTable.setInstance(queueTable);\n    })();\n  }\n  /**\n   * Link a file with a component.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved on success.\n   */\n  addFileLink(siteId, fileId, component, componentId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!component) {\n        throw new CoreError('Cannot add link because component is invalid.');\n      }\n      yield _this2.linksTables[siteId].insert({\n        fileId,\n        component,\n        componentId: _this2.fixComponentId(componentId) || ''\n      });\n    })();\n  }\n  /**\n   * Link a file with a component by URL.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file Url.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved on success.\n   * @description\n   * Use this method to create a link between a URL and a component. You usually do not need to call this manually since\n   * downloading a file automatically does this. Note that this method does not check if the file exists in the pool.\n   */\n  addFileLinkByUrl(siteId, fileUrl, component, componentId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const file = yield _this3.fixPluginfileURL(siteId, fileUrl);\n      const fileId = _this3.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n      yield _this3.addFileLink(siteId, fileId, component, componentId);\n    })();\n  }\n  /**\n   * Link a file with several components.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param links Array of objects containing the component and optionally componentId.\n   * @returns Promise resolved on success.\n   */\n  addFileLinks(siteId, fileId, links) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const promises = links.map(link => _this4.addFileLink(siteId, fileId, link.component, link.componentId));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Add files to queue using a URL.\n   *\n   * @param siteId The site ID.\n   * @param files Array of files to add.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component (optional).\n   * @returns Resolved on success.\n   */\n  addFilesToQueue(siteId, files, component, componentId) {\n    return this.downloadOrPrefetchFiles(siteId, files, true, false, component, componentId);\n  }\n  /**\n   * Add a file to the pool.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param data Additional information to store about the file (timemodified, url, ...). See FILES_TABLE schema.\n   * @returns Promise resolved on success.\n   */\n  addFileToPool(siteId, fileId, data) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const record = _objectSpread({\n        fileId\n      }, data);\n      yield _this5.filesTables[siteId].insert(record);\n    })();\n  }\n  /**\n   * Adds a hash to a filename if needed.\n   *\n   * @param url The URL of the file, already treated (decoded, without revision, etc.).\n   * @param filename The filename.\n   * @returns The filename with the hash.\n   */\n  addHashToFilename(url, filename) {\n    // Check if the file already has a hash. If a file is downloaded and re-uploaded with the app it will have a hash already.\n    const matches = filename.match(/_[a-f0-9]{32}/g);\n    if (matches && matches.length) {\n      // There is at least 1 match. Get the last one.\n      const hash = matches[matches.length - 1];\n      const treatedUrl = url.replace(hash, ''); // Remove the hash from the URL.\n      // Check that the hash is valid.\n      if ('_' + Md5.hashAsciiStr('url:' + treatedUrl) == hash) {\n        // The data found is a hash of the URL, don't need to add it again.\n        return filename;\n      }\n    }\n    return filename + '_' + Md5.hashAsciiStr('url:' + url);\n  }\n  /**\n   * Add a file to the queue.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param url The absolute URL to the file.\n   * @param priority The priority this file should get in the queue (range 0-999).\n   * @param revision The revision of the file.\n   * @param timemodified The time this file was modified. Can be used to check file state.\n   * @param filePath Filepath to download the file to. If not defined, download to the filepool folder.\n   * @param onProgress Function to call on progress.\n   * @param options Extra options (isexternalfile, repositorytype).\n   * @param link The link to add for the file.\n   * @returns Promise resolved when the file is downloaded.\n   */\n  addToQueue(siteId, fileId, url, priority, revision, timemodified, filePath, onProgress, options = {}, link) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      _this6.logger.debug(`Adding ${fileId} to the queue`);\n      yield _this6.queueTable.insert({\n        siteId,\n        fileId,\n        url,\n        priority,\n        revision,\n        timemodified,\n        path: filePath,\n        isexternalfile: options.isexternalfile ? 1 : 0,\n        repositorytype: options.repositorytype,\n        links: JSON.stringify(link ? [link] : []),\n        added: Date.now()\n      });\n      // Check if the queue is running.\n      _this6.checkQueueProcessing();\n      _this6.notifyFileDownloading(siteId, fileId, link ? [link] : []);\n      return _this6.getQueuePromise(siteId, fileId, true, onProgress);\n    })();\n  }\n  /**\n   * Add an entry to queue using a URL.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The absolute URL to the file.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component (optional).\n   * @param timemodified The time this file was modified. Can be used to check file state.\n   * @param filePath Filepath to download the file to. If not defined, download to the filepool folder.\n   * @param onProgress Function to call on progress.\n   * @param priority The priority this file should get in the queue (range 0-999).\n   * @param options Extra options (isexternalfile, repositorytype).\n   * @param revision File revision. If not defined, it will be calculated using the URL.\n   * @param alreadyFixed Whether the URL has already been fixed.\n   * @returns Resolved on success.\n   */\n  addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified = 0, filePath, onProgress, priority = 0, options = {}, revision, alreadyFixed) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      var _revision;\n      if (!CoreFile.isAvailable()) {\n        throw new CoreError('File system cannot be used.');\n      }\n      const site = yield CoreSites.getSite(siteId);\n      if (!site.canDownloadFiles()) {\n        throw new CoreError(Translate.instant('core.cannotdownloadfiles'));\n      }\n      if (!alreadyFixed) {\n        var _file$timemodified;\n        // Fix the URL and use the fixed data.\n        const file = yield _this7.fixPluginfileURL(siteId, fileUrl, timemodified);\n        fileUrl = CoreFileHelper.getFileUrl(file);\n        timemodified = (_file$timemodified = file.timemodified) !== null && _file$timemodified !== void 0 ? _file$timemodified : timemodified;\n      }\n      revision = (_revision = revision) !== null && _revision !== void 0 ? _revision : _this7.getRevisionFromUrl(fileUrl);\n      const fileId = _this7.getFileIdByUrl(fileUrl);\n      const primaryKey = {\n        siteId,\n        fileId\n      };\n      // Set up the component.\n      const link = _this7.createComponentLink(component, componentId);\n      // Retrieve the queue deferred now if it exists.\n      // This is to prevent errors if file is removed from queue while we're checking if the file is in queue.\n      const queueDeferred = _this7.getQueueDeferred(siteId, fileId, false, onProgress);\n      let entry;\n      try {\n        entry = yield _this7.hasFileInQueue(siteId, fileId);\n      } catch (error) {\n        // Unsure why we could not get the record, let's add to the queue anyway.\n        return _this7.addToQueue(siteId, fileId, fileUrl, priority, revision, timemodified, filePath, onProgress, options, link);\n      }\n      const newData = {};\n      let foundLink = false;\n      // We already have the file in queue, we update the priority and links.\n      if (!entry.priority || entry.priority < priority) {\n        newData.priority = priority;\n      }\n      if (revision && entry.revision !== revision) {\n        newData.revision = revision;\n      }\n      if (timemodified && entry.timemodified !== timemodified) {\n        newData.timemodified = timemodified;\n      }\n      if (filePath && entry.path !== filePath) {\n        newData.path = filePath;\n      }\n      if (entry.isexternalfile !== options.isexternalfile && (entry.isexternalfile || options.isexternalfile)) {\n        newData.isexternalfile = options.isexternalfile;\n      }\n      if (entry.repositorytype !== options.repositorytype && (entry.repositorytype || options.repositorytype)) {\n        newData.repositorytype = options.repositorytype;\n      }\n      if (link) {\n        // We need to add the new link if it does not exist yet.\n        if (entry.linksUnserialized && entry.linksUnserialized.length) {\n          foundLink = entry.linksUnserialized.some(fileLink => fileLink.component == link.component && fileLink.componentId == link.componentId);\n        }\n        if (!foundLink) {\n          const links = entry.linksUnserialized || [];\n          links.push(link);\n          newData.links = JSON.stringify(links);\n        }\n      }\n      if (Object.keys(newData).length) {\n        // Update only when required.\n        _this7.logger.debug(`Updating file ${fileId} which is already in queue`);\n        return _this7.queueTable.update(newData, primaryKey).then(() => _this7.getQueuePromise(siteId, fileId, true, onProgress));\n      }\n      _this7.logger.debug(`File ${fileId} already in queue and does not require update`);\n      if (queueDeferred) {\n        // If we were able to retrieve the queue deferred before, we use that one.\n        return queueDeferred;\n      } else {\n        // Create a new deferred and return its promise.\n        return _this7.getQueuePromise(siteId, fileId, true, onProgress);\n      }\n    })();\n  }\n  /**\n   * Adds a file to the queue if the size is allowed to be downloaded.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The absolute URL to the file, already fixed.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param timemodified The time this file was modified.\n   * @param checkSize True if we shouldn't download files if their size is big, false otherwise.\n   * @param downloadUnknown True to download file in WiFi if their size is unknown, false otherwise.\n   *                        Ignored if checkSize=false.\n   * @param options Extra options (isexternalfile, repositorytype).\n   * @param revision File revision. If not defined, it will be calculated using the URL.\n   * @returns Promise resolved when the file is downloaded.\n   */\n  addToQueueIfNeeded(siteId, fileUrl, component, componentId, timemodified = 0, checkSize = true, downloadUnknown, options = {}, revision) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (!checkSize) {\n        // No need to check size, just add it to the queue.\n        yield _this8.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options, revision, true);\n      }\n      let size;\n      if (_this8.sizeCache[fileUrl] !== undefined) {\n        size = _this8.sizeCache[fileUrl];\n      } else {\n        if (!CoreNetwork.isOnline()) {\n          // Cannot check size in offline, stop.\n          throw new CoreError(Translate.instant('core.cannotconnect'));\n        }\n        size = yield CoreWS.getRemoteFileSize(fileUrl);\n      }\n      // Calculate the size of the file.\n      const isWifi = CoreNetwork.isWifi();\n      const sizeUnknown = size <= 0;\n      if (!sizeUnknown) {\n        // Store the size in the cache.\n        _this8.sizeCache[fileUrl] = size;\n      }\n      // Check if the file should be downloaded.\n      if (sizeUnknown && downloadUnknown && isWifi || !sizeUnknown && _this8.shouldDownload(size)) {\n        yield _this8.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options, revision, true);\n      }\n    })();\n  }\n  /**\n   * Check the queue processing.\n   *\n   * @description\n   * In mose cases, this will enable the queue processing if it was paused.\n   * Though, this will disable the queue if we are missing network or if the file system\n   * is not accessible. Also, this will have no effect if the queue is already running.\n   */\n  checkQueueProcessing() {\n    if (!CoreFile.isAvailable() || !CoreNetwork.isOnline()) {\n      this.queueState = CoreFilepoolProvider.QUEUE_PAUSED;\n      return;\n    } else if (this.queueState === CoreFilepoolProvider.QUEUE_RUNNING) {\n      return;\n    }\n    this.queueState = CoreFilepoolProvider.QUEUE_RUNNING;\n    this.processQueue();\n  }\n  /**\n   * Clear all packages status in a site.\n   *\n   * @param siteId Site ID.\n   * @returns Promise resolved when all status are cleared.\n   */\n  clearAllPackagesStatus(siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      _this9.logger.debug('Clear all packages status for site ' + siteId);\n      // Get all the packages to be able to \"notify\" the change in the status.\n      const entries = yield _this9.packagesTables[siteId].getMany();\n      // Delete all the entries.\n      yield _this9.packagesTables[siteId].delete();\n      entries.forEach(entry => {\n        if (!entry.component) {\n          return;\n        }\n        // Trigger module status changed, setting it as not downloaded.\n        _this9.triggerPackageStatusChanged(siteId, CoreConstants.NOT_DOWNLOADED, entry.component, entry.componentId);\n      });\n    })();\n  }\n  /**\n   * Clears the filepool. Use it only when all the files from a site are deleted.\n   *\n   * @param siteId ID of the site to clear.\n   * @returns Promise resolved when the filepool is cleared.\n   */\n  clearFilepool(siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      // Read the data first to be able to notify the deletions.\n      const filesEntries = yield _this10.filesTables[siteId].getMany();\n      const filesLinks = yield _this10.linksTables[siteId].getMany();\n      yield Promise.all([_this10.filesTables[siteId].delete(), _this10.linksTables[siteId].delete()]);\n      // Notify now.\n      const filesLinksMap = CoreUtils.arrayToObjectMultiple(filesLinks, 'fileId');\n      filesEntries.forEach(entry => _this10.notifyFileDeleted(siteId, entry.fileId, filesLinksMap[entry.fileId] || []));\n    })();\n  }\n  /**\n   * Returns whether a component has files in the pool.\n   *\n   * @param siteId The site ID.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Resolved means yes, rejected means no.\n   */\n  componentHasFiles(siteId, component, componentId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const conditions = {\n        component,\n        componentId: _this11.fixComponentId(componentId)\n      };\n      const hasAnyLinks = yield _this11.linksTables[siteId].hasAny(conditions);\n      if (!hasAnyLinks) {\n        throw new CoreError('Component doesn\\'t have files');\n      }\n    })();\n  }\n  /**\n   * Prepare a component link.\n   *\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Link, null if nothing to link.\n   */\n  createComponentLink(component, componentId) {\n    if (component !== undefined && component != null) {\n      return {\n        component,\n        componentId: this.fixComponentId(componentId)\n      };\n    }\n  }\n  /**\n   * Prepare list of links from component and componentId.\n   *\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Links.\n   */\n  createComponentLinks(component, componentId) {\n    const link = this.createComponentLink(component, componentId);\n    return link ? [link] : [];\n  }\n  /**\n   * Given the current status of a list of packages and the status of one of the packages,\n   * determine the new status for the list of packages. The status of a list of packages is:\n   *     - CoreConstants.NOT_DOWNLOADABLE if there are no downloadable packages.\n   *     - CoreConstants.NOT_DOWNLOADED if at least 1 package has status CoreConstants.NOT_DOWNLOADED.\n   *     - CoreConstants.DOWNLOADED if ALL the downloadable packages have status CoreConstants.DOWNLOADED.\n   *     - CoreConstants.DOWNLOADING if ALL the downloadable packages have status CoreConstants.DOWNLOADING or\n   *                                     CoreConstants.DOWNLOADED, with at least 1 package with CoreConstants.DOWNLOADING.\n   *     - CoreConstants.OUTDATED if ALL the downloadable packages have status CoreConstants.OUTDATED or CoreConstants.DOWNLOADED\n   *                                     or CoreConstants.DOWNLOADING, with at least 1 package with CoreConstants.OUTDATED.\n   *\n   * @param current Current status of the list of packages.\n   * @param packageStatus Status of one of the packages.\n   * @returns New status for the list of packages;\n   */\n  determinePackagesStatus(current, packageStatus) {\n    if (!current) {\n      current = CoreConstants.NOT_DOWNLOADABLE;\n    }\n    if (packageStatus === CoreConstants.NOT_DOWNLOADED) {\n      // If 1 package is not downloaded the status of the whole list will always be not downloaded.\n      return CoreConstants.NOT_DOWNLOADED;\n    } else if (packageStatus === CoreConstants.DOWNLOADED && current === CoreConstants.NOT_DOWNLOADABLE) {\n      // If all packages are downloaded or not downloadable with at least 1 downloaded, status will be downloaded.\n      return CoreConstants.DOWNLOADED;\n    } else if (packageStatus === CoreConstants.DOWNLOADING && (current === CoreConstants.NOT_DOWNLOADABLE || current === CoreConstants.DOWNLOADED)) {\n      // If all packages are downloading/downloaded/notdownloadable with at least 1 downloading, status will be downloading.\n      return CoreConstants.DOWNLOADING;\n    } else if (packageStatus === CoreConstants.OUTDATED && current !== CoreConstants.NOT_DOWNLOADED) {\n      // If there are no packages notdownloaded and there is at least 1 outdated, status will be outdated.\n      return CoreConstants.OUTDATED;\n    }\n    // Status remains the same.\n    return current;\n  }\n  /**\n   * Downloads a URL and update or add it to the pool.\n   *\n   * This uses the file system, you should always make sure that it is accessible before calling this method.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file URL.\n   * @param options Extra options (revision, timemodified, isexternalfile, repositorytype).\n   * @param filePath Filepath to download the file to. If defined, no extension will be added.\n   * @param onProgress Function to call on progress.\n   * @param poolFileObject When set, the object will be updated, a new entry will not be created.\n   * @returns Resolved with internal URL on success, rejected otherwise.\n   */\n  downloadForPoolByUrl(siteId, fileUrl, options = {}, filePath, onProgress, poolFileObject) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const fileId = _this12.getFileIdByUrl(fileUrl);\n      // Extract the anchor from the URL (if any).\n      const anchor = CoreUrl.getUrlAnchor(fileUrl);\n      if (anchor) {\n        fileUrl = fileUrl.replace(anchor, '');\n      }\n      const extension = CoreMimetypeUtils.guessExtensionFromUrl(fileUrl);\n      const addExtension = filePath === undefined;\n      const path = filePath || (yield _this12.getFilePath(siteId, fileId, extension));\n      if (poolFileObject && poolFileObject.fileId !== fileId) {\n        _this12.logger.error('Invalid object to update passed');\n        throw new CoreError('Invalid object to update passed.');\n      }\n      const downloadId = _this12.getFileDownloadId(fileUrl, path);\n      if (_this12.filePromises[siteId] && _this12.filePromises[siteId][downloadId] !== undefined) {\n        // There's already a download ongoing for this file in this location, return the promise.\n        return _this12.filePromises[siteId][downloadId];\n      } else if (!_this12.filePromises[siteId]) {\n        _this12.filePromises[siteId] = {};\n      }\n      _this12.filePromises[siteId][downloadId] = CoreSites.getSite(siteId).then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (site) {\n          if (!site.canDownloadFiles()) {\n            throw new CoreError(Translate.instant('core.cannotdownloadfiles'));\n          }\n          const entry = yield CoreWS.downloadFile(fileUrl, path, addExtension, onProgress);\n          const fileEntry = entry;\n          yield CorePluginFileDelegate.treatDownloadedFile(fileUrl, fileEntry, siteId, onProgress);\n          yield _this12.addFileToPool(siteId, fileId, {\n            downloadTime: Date.now(),\n            stale: 0,\n            url: fileUrl,\n            revision: options.revision,\n            timemodified: options.timemodified,\n            isexternalfile: options.isexternalfile ? 1 : 0,\n            repositorytype: options.repositorytype,\n            path: fileEntry.path,\n            extension: fileEntry.extension\n          });\n          CoreAnalytics.logEvent({\n            type: CoreAnalyticsEventType.DOWNLOAD_FILE,\n            fileUrl: CoreUrlUtils.unfixPluginfileURL(fileUrl, site.getURL())\n          });\n          // Add the anchor again to the local URL.\n          return fileEntry.toURL() + (anchor || '');\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()).finally(() => {\n        // Download finished, delete the promise.\n        delete _this12.filePromises[siteId][downloadId];\n      });\n      return _this12.filePromises[siteId][downloadId];\n    })();\n  }\n  /**\n   * Download or prefetch several files into the filepool folder.\n   *\n   * @param siteId The site ID.\n   * @param files Array of files to download.\n   * @param prefetch True if should prefetch the contents (queue), false if they should be downloaded right now.\n   * @param ignoreStale True if 'stale' should be ignored. Only if prefetch=false.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param dirPath Name of the directory where to store the files (inside filepool dir). If not defined, store\n   *                the files directly inside the filepool folder.\n   * @returns Resolved on success.\n   */\n  downloadOrPrefetchFiles(siteId, files, prefetch, ignoreStale, component, componentId, dirPath) {\n    const promises = [];\n    // Download files.\n    files.forEach(file => {\n      const url = CoreFileHelper.getFileUrl(file);\n      const timemodified = file.timemodified;\n      const options = {\n        isexternalfile: 'isexternalfile' in file ? file.isexternalfile : undefined,\n        repositorytype: 'repositorytype' in file ? file.repositorytype : undefined\n      };\n      let path;\n      if (dirPath) {\n        // Calculate the path to the file.\n        path = file.filename || '';\n        if (file.filepath && file.filepath !== '/') {\n          path = file.filepath.substring(1) + path;\n        }\n        path = CorePath.concatenatePaths(dirPath, path);\n      }\n      if (prefetch) {\n        promises.push(this.addToQueueByUrl(siteId, url, component, componentId, timemodified, path, undefined, 0, options));\n      } else {\n        promises.push(this.downloadUrl(siteId, url, ignoreStale, component, componentId, timemodified, undefined, path, options));\n      }\n    });\n    return CoreUtils.allPromises(promises);\n  }\n  /**\n   * Downloads or prefetches a list of files as a \"package\".\n   *\n   * @param siteId The site ID.\n   * @param fileList List of files to download.\n   * @param prefetch True if should prefetch the contents (queue), false if they should be downloaded right now.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param extra Extra data to store for the package.\n   * @param dirPath Name of the directory where to store the files (inside filepool dir). If not defined, store\n   *                the files directly inside the filepool folder.\n   * @param onProgress Function to call on progress.\n   * @returns Promise resolved when the package is downloaded.\n   */\n  downloadOrPrefetchPackage(siteId, fileList, prefetch, component, componentId, extra, dirPath, onProgress) {\n    var _this13 = this;\n    const packageId = this.getPackageId(component, componentId);\n    if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId] !== undefined) {\n      // There's already a download ongoing for this package, return the promise.\n      return this.packagesPromises[siteId][packageId];\n    } else if (!this.packagesPromises[siteId]) {\n      this.packagesPromises[siteId] = {};\n    }\n    // Set package as downloading.\n    const promise = this.storePackageStatus(siteId, CoreConstants.DOWNLOADING, component, componentId).then( /*#__PURE__*/_asyncToGenerator(function* () {\n      const promises = [];\n      let packageLoaded = 0;\n      fileList.forEach(file => {\n        const fileUrl = CoreFileHelper.getFileUrl(file);\n        const options = {\n          isexternalfile: 'isexternalfile' in file ? file.isexternalfile : undefined,\n          repositorytype: 'repositorytype' in file ? file.repositorytype : undefined\n        };\n        let path;\n        let promise;\n        let fileLoaded = 0;\n        let onFileProgress;\n        if (onProgress) {\n          // There's a onProgress event, create a function to receive file download progress events.\n          onFileProgress = progress => {\n            if (progress && progress.loaded) {\n              // Add the new size loaded to the package loaded.\n              packageLoaded = packageLoaded + (progress.loaded - fileLoaded);\n              fileLoaded = progress.loaded;\n              onProgress({\n                packageDownload: true,\n                loaded: packageLoaded,\n                fileProgress: progress\n              });\n            }\n          };\n        }\n        if (dirPath) {\n          // Calculate the path to the file.\n          path = file.filename || '';\n          if (file.filepath && file.filepath !== '/') {\n            path = file.filepath.substring(1) + path;\n          }\n          path = CorePath.concatenatePaths(dirPath, path);\n        }\n        if (prefetch) {\n          promise = _this13.addToQueueByUrl(siteId, fileUrl, component, componentId, file.timemodified, path, undefined, 0, options);\n        } else {\n          promise = _this13.downloadUrl(siteId, fileUrl, false, component, componentId, file.timemodified, onFileProgress, path, options);\n        }\n        // Using undefined for success & fail will pass the success/failure to the parent promise.\n        promises.push(promise);\n      });\n      try {\n        yield Promise.all(promises);\n        // Success prefetching, store package as downloaded.\n        yield _this13.storePackageStatus(siteId, CoreConstants.DOWNLOADED, component, componentId, extra);\n        return;\n      } catch (error) {\n        // Error downloading, go back to previous status and reject the promise.\n        yield _this13.setPackagePreviousStatus(siteId, component, componentId);\n        throw error;\n      }\n    })).finally(() => {\n      // Download finished, delete the promise.\n      delete this.packagesPromises[siteId][packageId];\n    });\n    this.packagesPromises[siteId][packageId] = promise;\n    return promise;\n  }\n  /**\n   * Downloads a list of files.\n   *\n   * @param siteId The site ID.\n   * @param fileList List of files to download.\n   * @param component The component to link the file to.\n   * @param componentId An ID to identify the download.\n   * @param extra Extra data to store for the package.\n   * @param dirPath Name of the directory where to store the files (inside filepool dir). If not defined, store\n   *                the files directly inside the filepool folder.\n   * @param onProgress Function to call on progress.\n   * @returns Promise resolved when all files are downloaded.\n   */\n  downloadPackage(siteId, fileList, component, componentId, extra, dirPath, onProgress) {\n    return this.downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, extra, dirPath, onProgress);\n  }\n  /**\n   * Downloads a file on the spot.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file URL.\n   * @param ignoreStale Whether 'stale' should be ignored.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param timemodified The time this file was modified. Can be used to check file state.\n   * @param onProgress On progress callback function.\n   * @param filePath Filepath to download the file to. If not defined, download to the filepool folder.\n   * @param options Extra options (isexternalfile, repositorytype).\n   * @param revision File revision. If not defined, it will be calculated using the URL.\n   * @returns Resolved with internal URL on success, rejected otherwise.\n   * @description\n   * Downloads a file on the spot.\n   *\n   * This will also take care of adding the file to the pool if it's missing. However, please note that this will\n   * not force a file to be re-downloaded if it is already part of the pool. You should mark a file as stale using\n   * invalidateFileByUrl to trigger a download.\n   */\n  downloadUrl(siteId, fileUrl, ignoreStale, component, componentId, timemodified = 0, onProgress, filePath, options = {}, revision) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      var _file$timemodified2;\n      let alreadyDownloaded = true;\n      if (!CoreFile.isAvailable()) {\n        throw new CoreError('File system cannot be used.');\n      }\n      const file = yield _this14.fixPluginfileURL(siteId, fileUrl, timemodified);\n      fileUrl = CoreFileHelper.getFileUrl(file);\n      options = Object.assign({}, options); // Create a copy to prevent modifying the original object.\n      options.timemodified = (_file$timemodified2 = file.timemodified) !== null && _file$timemodified2 !== void 0 ? _file$timemodified2 : timemodified;\n      options.revision = revision !== null && revision !== void 0 ? revision : _this14.getRevisionFromUrl(fileUrl);\n      const fileId = _this14.getFileIdByUrl(fileUrl);\n      const links = _this14.createComponentLinks(component, componentId);\n      const finishSuccessfulDownload = url => {\n        if (component !== undefined) {\n          CoreUtils.ignoreErrors(_this14.addFileLink(siteId, fileId, component, componentId));\n        }\n        if (!alreadyDownloaded) {\n          _this14.notifyFileDownloaded(siteId, fileId, links);\n        }\n        return url;\n      };\n      try {\n        const fileObject = yield _this14.hasFileInPool(siteId, fileId);\n        let url;\n        if (!fileObject || _this14.isFileOutdated(fileObject, options.revision, options.timemodified) && CoreNetwork.isOnline() && !ignoreStale) {\n          throw new CoreError('Needs to be downloaded');\n        }\n        // File downloaded and not outdated, return the file from disk.\n        if (filePath) {\n          url = yield _this14.getInternalUrlByPath(filePath);\n        } else {\n          url = yield _this14.getInternalUrlById(siteId, fileId);\n        }\n        // Add the anchor to the local URL if any.\n        const anchor = CoreUrl.getUrlAnchor(fileUrl);\n        return finishSuccessfulDownload(url + (anchor || ''));\n      } catch (error) {\n        // The file is not downloaded or it's outdated.\n        _this14.notifyFileDownloading(siteId, fileId, links);\n        alreadyDownloaded = false;\n        try {\n          const url = yield _this14.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress);\n          return finishSuccessfulDownload(url);\n        } catch (error) {\n          _this14.notifyFileDownloadError(siteId, fileId, links);\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Extract the downloadable URLs from an HTML code.\n   *\n   * @param html HTML code.\n   * @returns List of file urls.\n   */\n  extractDownloadableFilesFromHtml(html) {\n    let urls = [];\n    const element = CoreDomUtils.convertToElement(html);\n    const elements = Array.from(element.querySelectorAll('a, img, audio, video, source, track'));\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      const url = 'href' in element ? element.href : element.src;\n      if (url && CoreUrlUtils.isDownloadableUrl(url) && urls.indexOf(url) == -1) {\n        urls.push(url);\n      }\n      // Treat video poster.\n      if (element.tagName == 'VIDEO' && element.getAttribute('poster')) {\n        const poster = element.getAttribute('poster');\n        if (poster && CoreUrlUtils.isDownloadableUrl(poster) && urls.indexOf(poster) == -1) {\n          urls.push(poster);\n        }\n      }\n    }\n    // Now get other files from plugin file handlers.\n    urls = urls.concat(CorePluginFileDelegate.getDownloadableFilesFromHTML(element));\n    return urls;\n  }\n  /**\n   * Extract the downloadable URLs from an HTML code and returns them in fake file objects.\n   *\n   * @param html HTML code.\n   * @returns List of fake file objects with file URLs.\n   */\n  extractDownloadableFilesFromHtmlAsFakeFileObjects(html) {\n    const urls = this.extractDownloadableFilesFromHtml(html);\n    // Convert them to fake file objects.\n    return urls.map(url => ({\n      fileurl: url\n    }));\n  }\n  /**\n   * Fill Missing Extension In the File Object if needed.\n   * This is to migrate from old versions.\n   *\n   * @param entry File object to be migrated.\n   * @param siteId SiteID to get migrated.\n   * @returns Promise resolved when done.\n   */\n  fillExtensionInFile(entry, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      if (entry.extension !== undefined) {\n        // Already filled.\n        return;\n      }\n      const extension = CoreMimetypeUtils.getFileExtension(entry.path);\n      if (!extension) {\n        // Files does not have extension. Invalidate file (stale = true).\n        // Minor problem: file will remain in the filesystem once downloaded again.\n        _this15.logger.debug('Staled file with no extension ' + entry.fileId);\n        yield _this15.filesTables[siteId].update({\n          stale: 1\n        }, {\n          fileId: entry.fileId\n        });\n        return;\n      }\n      // File has extension. Save extension, and add extension to path.\n      const fileId = entry.fileId;\n      entry.fileId = CoreMimetypeUtils.removeExtension(fileId);\n      entry.extension = extension;\n      yield _this15.filesTables[siteId].update(entry, {\n        fileId\n      });\n      if (entry.fileId == fileId) {\n        // File ID hasn't changed, we're done.\n        _this15.logger.debug('Removed extesion ' + extension + ' from file ' + entry.fileId);\n        return;\n      }\n      // Now update the links.\n      yield _this15.linksTables[siteId].update({\n        fileId: entry.fileId\n      }, {\n        fileId\n      });\n    })();\n  }\n  /**\n   * Fix a component ID to always be a Number if possible.\n   *\n   * @param componentId The component ID.\n   * @returns The normalised component ID. -1 when undefined was passed.\n   */\n  fixComponentId(componentId) {\n    if (typeof componentId == 'number') {\n      return componentId;\n    }\n    if (componentId === undefined || componentId === null) {\n      return -1;\n    }\n    // Try to convert it to a number.\n    const id = parseInt(componentId, 10);\n    if (isNaN(id)) {\n      // Not a number.\n      return componentId;\n    }\n    return id;\n  }\n  /**\n   * Check whether the file can be downloaded, add the wstoken url and points to the correct script.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file URL.\n   * @param timemodified The timemodified of the file.\n   * @returns Promise resolved with the file data to use.\n   */\n  fixPluginfileURL(siteId, fileUrl, timemodified = 0) {\n    return _asyncToGenerator(function* () {\n      const file = yield CorePluginFileDelegate.getDownloadableFile({\n        fileurl: fileUrl,\n        timemodified\n      });\n      const site = yield CoreSites.getSite(siteId);\n      if ('fileurl' in file) {\n        file.fileurl = yield site.checkAndFixPluginfileURL(file.fileurl);\n      } else {\n        file.url = yield site.checkAndFixPluginfileURL(file.url);\n      }\n      return file;\n    })();\n  }\n  /**\n   * Convenience function to get component files.\n   *\n   * @param siteId Site Id.\n   * @param component The component to get.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved with the files.\n   */\n  getComponentFiles(siteId, component, componentId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      var _siteId;\n      siteId = (_siteId = siteId) !== null && _siteId !== void 0 ? _siteId : CoreSites.getCurrentSiteId();\n      const conditions = {\n        component,\n        componentId: _this16.fixComponentId(componentId)\n      };\n      const items = yield _this16.linksTables[siteId].getMany(conditions);\n      items.forEach(item => {\n        item.componentId = _this16.fixComponentId(item.componentId);\n      });\n      return items;\n    })();\n  }\n  /**\n   * Returns the local URL of a directory.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file URL.\n   * @returns Resolved with the URL. Rejected otherwise.\n   */\n  getDirectoryUrlByUrl(siteId, fileUrl) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreFile.isAvailable()) {\n        throw new CoreError('File system cannot be used.');\n      }\n      const file = yield _this17.fixPluginfileURL(siteId, fileUrl);\n      const fileId = _this17.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n      const filePath = yield _this17.getFilePath(siteId, fileId, '');\n      const dirEntry = yield CoreFile.getDir(filePath);\n      return dirEntry.toURL();\n    })();\n  }\n  /**\n   * Get the ID of a file download. Used to keep track of filePromises.\n   *\n   * @param fileUrl The file URL.\n   * @param filePath The file destination path.\n   * @returns File download ID.\n   */\n  getFileDownloadId(fileUrl, filePath) {\n    return Md5.hashAsciiStr(fileUrl + '###' + filePath);\n  }\n  /**\n   * Get the name of the event used to notify download events.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @returns Event name.\n   */\n  getFileEventName(siteId, fileId) {\n    return 'CoreFilepoolFile:' + siteId + ':' + fileId;\n  }\n  /**\n   * Get the name of the event used to notify download events.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The absolute URL to the file.\n   * @returns Promise resolved with event name.\n   */\n  getFileEventNameByUrl(siteId, fileUrl) {\n    return this.fixPluginfileURL(siteId, fileUrl).then(file => {\n      const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n      return this.getFileEventName(siteId, fileId);\n    });\n  }\n  /**\n   * Creates a unique ID based on a URL.\n   *\n   * This has a minimal handling of pluginfiles in order to generate a clean file ID which will not change if\n   * pointing to the same pluginfile URL even if the token or extra attributes have changed.\n   *\n   * @param fileUrl The absolute URL to the file.\n   * @returns The file ID.\n   */\n  getFileIdByUrl(fileUrl) {\n    let url = fileUrl;\n    // If site supports it, since 3.8 we use tokenpluginfile instead of pluginfile.\n    // For compatibility with files already downloaded, we need to use pluginfile to calculate the file ID.\n    url = url.replace(/\\/tokenpluginfile\\.php\\/[^/]+\\//, '/webservice/pluginfile.php/');\n    // Remove the revision number from the URL so updates on the file aren't detected as a different file.\n    url = this.removeRevisionFromUrl(url);\n    // Decode URL.\n    url = CoreTextUtils.decodeHTML(CoreTextUtils.decodeURIComponent(url));\n    if (url.indexOf('/webservice/pluginfile') !== -1) {\n      // Remove attributes that do not matter.\n      this.urlAttributes.forEach(regex => {\n        url = url.replace(regex, '');\n      });\n    }\n    // Remove the anchor.\n    url = CoreUrl.removeUrlAnchor(url);\n    // Try to guess the filename the target file should have.\n    // We want to keep the original file name so people can easily identify the files after the download.\n    const filename = this.guessFilenameFromUrl(url);\n    return this.addHashToFilename(url, filename);\n  }\n  /**\n   * Get the links of a file.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @returns Promise resolved with the links.\n   */\n  getFileLinks(siteId, fileId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const items = yield _this18.linksTables[siteId].getMany({\n        fileId\n      });\n      items.forEach(item => {\n        item.componentId = _this18.fixComponentId(item.componentId);\n      });\n      return items;\n    })();\n  }\n  /**\n   * Get the path to a file. This does not check if the file exists or not.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param extension Previously calculated extension. Empty to not add any. Undefined to calculate it.\n   * @returns The path to the file relative to storage root.\n   */\n  getFilePath(siteId, fileId, extension) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      let path = _this19.getFilepoolFolderPath(siteId) + '/' + fileId;\n      if (extension === undefined) {\n        // We need the extension to be able to open files properly.\n        try {\n          const entry = yield _this19.hasFileInPool(siteId, fileId);\n          if (entry.extension) {\n            path += '.' + entry.extension;\n          }\n        } catch (error) {\n          // If file not found, use the path without extension.\n        }\n      } else if (extension) {\n        path += '.' + extension;\n      }\n      return path;\n    })();\n  }\n  /**\n   * Get the path to a file from its URL. This does not check if the file exists or not.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file URL.\n   * @returns Promise resolved with the path to the file relative to storage root.\n   */\n  getFilePathByUrl(siteId, fileUrl) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const file = yield _this20.fixPluginfileURL(siteId, fileUrl);\n      const fileId = _this20.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n      return _this20.getFilePath(siteId, fileId);\n    })();\n  }\n  /**\n   * Get the url of a file form its path.\n   *\n   * @param siteId The site ID.\n   * @param path File path.\n   * @returns File url.\n   */\n  getFileUrlByPath(siteId, path) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const record = yield _this21.filesTables[siteId].getOne({\n        path\n      });\n      return record.url;\n    })();\n  }\n  /**\n   * Get site Filepool Folder Path\n   *\n   * @param siteId The site ID.\n   * @returns The root path to the filepool of the site.\n   */\n  getFilepoolFolderPath(siteId) {\n    return CoreFile.getSiteFolder(siteId) + '/' + CoreFilepoolProvider.FOLDER;\n  }\n  /**\n   * Get all the matching files from a component. Returns objects containing properties like path, extension and url.\n   *\n   * @param siteId The site ID.\n   * @param component The component to get.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved with the files on success.\n   */\n  getFilesByComponent(siteId, component, componentId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const items = yield _this22.getComponentFiles(siteId, component, componentId);\n      const files = [];\n      yield Promise.all(items.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (item) {\n          try {\n            const fileEntry = yield _this22.filesTables[siteId].getOneByPrimaryKey({\n              fileId: item.fileId\n            });\n            if (!fileEntry) {\n              return;\n            }\n            files.push(fileEntry);\n          } catch (error) {\n            // File not found, ignore error.\n          }\n        });\n        return function (_x2) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return files;\n    })();\n  }\n  /**\n   * Get the size of all the files from a component.\n   *\n   * @param siteId The site ID.\n   * @param component The component to get.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved with the size on success.\n   */\n  getFilesSizeByComponent(siteId, component, componentId) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const files = yield _this23.getFilesByComponent(siteId, component, componentId);\n      let size = 0;\n      yield Promise.all(files.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (file) {\n          try {\n            const fileSize = yield CoreFile.getFileSize(file.path);\n            size += fileSize;\n          } catch (_unused) {\n            // Ignore failures, maybe some file was deleted.\n          }\n        });\n        return function (_x3) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n      return size;\n    })();\n  }\n  /**\n   * Returns the file state: mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded or mmCoreOutdated.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl File URL.\n   * @param timemodified The time this file was modified.\n   * @param filePath Filepath to download the file to. If defined, no extension will be added.\n   * @param revision File revision. If not defined, it will be calculated using the URL.\n   * @returns Promise resolved with the file state.\n   */\n  getFileStateByUrl(siteId, fileUrl, timemodified = 0, filePath, revision) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      var _file$timemodified3, _revision2;\n      let file;\n      try {\n        file = yield _this24.fixPluginfileURL(siteId, fileUrl, timemodified);\n      } catch (e) {\n        return CoreConstants.NOT_DOWNLOADABLE;\n      }\n      fileUrl = CoreUrl.removeUrlAnchor(CoreFileHelper.getFileUrl(file));\n      timemodified = (_file$timemodified3 = file.timemodified) !== null && _file$timemodified3 !== void 0 ? _file$timemodified3 : timemodified;\n      revision = (_revision2 = revision) !== null && _revision2 !== void 0 ? _revision2 : _this24.getRevisionFromUrl(fileUrl);\n      const fileId = _this24.getFileIdByUrl(fileUrl);\n      try {\n        // Check if the file is in queue (waiting to be downloaded).\n        yield _this24.hasFileInQueue(siteId, fileId);\n        return CoreConstants.DOWNLOADING;\n      } catch (e) {\n        // Check if the file is being downloaded right now.\n        const extension = CoreMimetypeUtils.guessExtensionFromUrl(fileUrl);\n        filePath = filePath || (yield _this24.getFilePath(siteId, fileId, extension));\n        const downloadId = _this24.getFileDownloadId(fileUrl, filePath);\n        if (_this24.filePromises[siteId] && _this24.filePromises[siteId][downloadId] !== undefined) {\n          return CoreConstants.DOWNLOADING;\n        }\n        try {\n          // File is not being downloaded. Check if it's downloaded and if it's outdated.\n          const entry = yield _this24.hasFileInPool(siteId, fileId);\n          if (_this24.isFileOutdated(entry, revision, timemodified)) {\n            return CoreConstants.OUTDATED;\n          }\n          return CoreConstants.DOWNLOADED;\n        } catch (e) {\n          return CoreConstants.NOT_DOWNLOADED;\n        }\n      }\n    })();\n  }\n  /**\n   * Returns an absolute URL to access the file URL.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The absolute URL to the file.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param mode The type of URL to return. Accepts 'url' or 'src'.\n   * @param timemodified The time this file was modified.\n   * @param checkSize True if we shouldn't download files if their size is big, false otherwise.\n   * @param downloadUnknown True to download file in WiFi if their size is unknown, false otherwise.\n   *                        Ignored if checkSize=false.\n   * @param options Extra options (isexternalfile, repositorytype).\n   * @param revision File revision. If not defined, it will be calculated using the URL.\n   * @returns Resolved with the URL to use.\n   * @description\n   * This will return a URL pointing to the content of the requested URL.\n   *\n   * This handles the queue and validity of the file. If there is a local file and it's valid, return the local URL.\n   * If the file isn't downloaded or it's outdated, return the online URL and add it to the queue to be downloaded later.\n   */\n  getFileUrlByUrl(siteId, fileUrl, component, componentId, mode = 'url', timemodified = 0, checkSize = true, downloadUnknown, options = {}, revision) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      var _file$timemodified4, _revision3;\n      const addToQueue = fileUrl => {\n        // Add the file to queue if needed and ignore errors.\n        CoreUtils.ignoreErrors(_this25.addToQueueIfNeeded(siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options, revision));\n      };\n      const file = yield _this25.fixPluginfileURL(siteId, fileUrl, timemodified);\n      fileUrl = CoreFileHelper.getFileUrl(file);\n      timemodified = (_file$timemodified4 = file.timemodified) !== null && _file$timemodified4 !== void 0 ? _file$timemodified4 : timemodified;\n      revision = (_revision3 = revision) !== null && _revision3 !== void 0 ? _revision3 : _this25.getRevisionFromUrl(fileUrl);\n      const fileId = _this25.getFileIdByUrl(fileUrl);\n      try {\n        const entry = yield _this25.hasFileInPool(siteId, fileId);\n        if (entry === undefined) {\n          throw new CoreError('File not downloaded.');\n        }\n        if (_this25.isFileOutdated(entry, revision, timemodified) && CoreNetwork.isOnline()) {\n          throw new CoreError('File is outdated');\n        }\n      } catch (error) {\n        // The file is not downloaded or it's outdated. Add to queue and return the fixed URL.\n        addToQueue(fileUrl);\n        return fileUrl;\n      }\n      try {\n        // We found the file entry, now look for the file on disk.\n        const path = mode === 'src' ? yield _this25.getInternalSrcById(siteId, fileId) : yield _this25.getInternalUrlById(siteId, fileId);\n        // Add the anchor to the local URL if any.\n        const anchor = CoreUrl.getUrlAnchor(fileUrl);\n        return path + (anchor || '');\n      } catch (error) {\n        // The file is not on disk.\n        // We could not retrieve the file, delete the entries associated with that ID.\n        _this25.logger.debug('File ' + fileId + ' not found on disk');\n        _this25.removeFileById(siteId, fileId);\n        addToQueue(fileUrl);\n        return fileUrl;\n      }\n    })();\n  }\n  /**\n   * Returns the internal SRC of a file.\n   *\n   * The returned URL from this method is typically used with IMG tags.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @returns Resolved with the internal URL. Rejected otherwise.\n   */\n  getInternalSrcById(siteId, fileId) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreFile.isAvailable()) {\n        throw new CoreError('File system cannot be used.');\n      }\n      const path = yield _this26.getFilePath(siteId, fileId);\n      const fileEntry = yield CoreFile.getFile(path);\n      return CoreFile.convertFileSrc(fileEntry.toURL());\n    })();\n  }\n  /**\n   * Returns the local URL of a file.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @returns Resolved with the URL. Rejected otherwise.\n   */\n  getInternalUrlById(siteId, fileId) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreFile.isAvailable()) {\n        throw new CoreError('File system cannot be used.');\n      }\n      const path = yield _this27.getFilePath(siteId, fileId);\n      const fileEntry = yield CoreFile.getFile(path);\n      // This URL is usually used to launch files or put them in HTML.\n      return fileEntry.toURL();\n    })();\n  }\n  /**\n   * Returns the local URL of a file.\n   *\n   * @param filePath The file path.\n   * @returns Resolved with the URL.\n   */\n  getInternalUrlByPath(filePath) {\n    return _asyncToGenerator(function* () {\n      if (!CoreFile.isAvailable()) {\n        throw new CoreError('File system cannot be used.');\n      }\n      const fileEntry = yield CoreFile.getFile(filePath);\n      return fileEntry.toURL();\n    })();\n  }\n  /**\n   * Returns the local URL of a file.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file URL.\n   * @returns Resolved with the URL. Rejected otherwise.\n   */\n  getInternalUrlByUrl(siteId, fileUrl) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreFile.isAvailable()) {\n        throw new CoreError('File system cannot be used.');\n      }\n      const file = yield _this28.fixPluginfileURL(siteId, fileUrl);\n      const fileId = _this28.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n      return _this28.getInternalUrlById(siteId, fileId);\n    })();\n  }\n  /**\n   * Get the data stored for a package.\n   *\n   * @param siteId Site ID.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved with the data.\n   */\n  getPackageData(siteId, component, componentId) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      componentId = _this29.fixComponentId(componentId);\n      const packageId = _this29.getPackageId(component, componentId);\n      return _this29.packagesTables[siteId].getOneByPrimaryKey({\n        id: packageId\n      });\n    })();\n  }\n  /**\n   * Creates the name for a package directory (hash).\n   *\n   * @param url An URL to identify the package.\n   * @returns The directory name.\n   */\n  getPackageDirNameByUrl(url) {\n    let extension = '';\n    url = this.removeRevisionFromUrl(url);\n    if (url.indexOf('/webservice/pluginfile') !== -1) {\n      // Remove attributes that do not matter.\n      this.urlAttributes.forEach(regex => {\n        url = url.replace(regex, '');\n      });\n      // Guess the extension of the URL. This is for backwards compatibility.\n      const candidate = CoreMimetypeUtils.guessExtensionFromUrl(url);\n      if (candidate && candidate !== 'php') {\n        extension = '.' + candidate;\n      }\n    }\n    return Md5.hashAsciiStr('url:' + url) + extension;\n  }\n  /**\n   * Get the path to a directory to store a package files. This does not check if the file exists or not.\n   *\n   * @param siteId The site ID.\n   * @param url An URL to identify the package.\n   * @returns Promise resolved with the path of the package.\n   */\n  getPackageDirPathByUrl(siteId, url) {\n    return this.fixPluginfileURL(siteId, url).then(file => {\n      const dirName = this.getPackageDirNameByUrl(CoreFileHelper.getFileUrl(file));\n      return this.getFilePath(siteId, dirName, '');\n    });\n  }\n  /**\n   * Returns the local URL of a package directory.\n   *\n   * @param siteId The site ID.\n   * @param url An URL to identify the package.\n   * @returns Resolved with the URL.\n   */\n  getPackageDirUrlByUrl(siteId, url) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreFile.isAvailable()) {\n        throw new CoreError('File system cannot be used.');\n      }\n      const file = yield _this30.fixPluginfileURL(siteId, url);\n      const dirName = _this30.getPackageDirNameByUrl(CoreFileHelper.getFileUrl(file));\n      const dirPath = yield _this30.getFilePath(siteId, dirName, '');\n      const dirEntry = yield CoreFile.getDir(dirPath);\n      return dirEntry.toURL();\n    })();\n  }\n  /**\n   * Get a download promise. If the promise is not set, return undefined.\n   *\n   * @param siteId Site ID.\n   * @param component The component of the package.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Download promise or undefined.\n   */\n  getPackageDownloadPromise(siteId, component, componentId) {\n    const packageId = this.getPackageId(component, componentId);\n    if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId] !== undefined) {\n      return this.packagesPromises[siteId][packageId];\n    }\n  }\n  /**\n   * Get a package extra data.\n   *\n   * @param siteId Site ID.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved with the extra data.\n   */\n  getPackageExtra(siteId, component, componentId) {\n    return this.getPackageData(siteId, component, componentId).then(entry => entry.extra);\n  }\n  /**\n   * Get the ID of a package.\n   *\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Package ID.\n   */\n  getPackageId(component, componentId) {\n    return Md5.hashAsciiStr(component + '#' + this.fixComponentId(componentId));\n  }\n  /**\n   * Get a package previous status.\n   *\n   * @param siteId Site ID.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved with the status.\n   */\n  getPackagePreviousStatus(siteId, component, componentId) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const entry = yield _this31.getPackageData(siteId, component, componentId);\n        return entry.previous || CoreConstants.NOT_DOWNLOADED;\n      } catch (error) {\n        return CoreConstants.NOT_DOWNLOADED;\n      }\n    })();\n  }\n  /**\n   * Get a package status.\n   *\n   * @param siteId Site ID.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved with the status.\n   */\n  getPackageStatus(siteId, component, componentId) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const entry = yield _this32.getPackageData(siteId, component, componentId);\n        return entry.status || CoreConstants.NOT_DOWNLOADED;\n      } catch (error) {\n        return CoreConstants.NOT_DOWNLOADED;\n      }\n    })();\n  }\n  /**\n   * Return the array of arguments of the pluginfile url.\n   *\n   * @param url URL to get the args.\n   * @returns The args found, undefined if not a pluginfile.\n   */\n  getPluginFileArgs(url) {\n    if (!CoreUrlUtils.isPluginFileUrl(url)) {\n      // Not pluginfile, return.\n      return;\n    }\n    const relativePath = url.substring(url.indexOf('/pluginfile.php') + 16);\n    const args = relativePath.split('/');\n    if (args.length < 3) {\n      // To be a plugin file it should have at least contextId, Component and Filearea.\n      return;\n    }\n    return args;\n  }\n  /**\n   * Get the deferred object for a file in the queue.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param create True if it should create a new deferred if it doesn't exist.\n   * @param onProgress Function to call on progress.\n   * @returns Deferred.\n   */\n  getQueueDeferred(siteId, fileId, create = true, onProgress) {\n    if (!this.queueDeferreds[siteId]) {\n      if (!create) {\n        return;\n      }\n      this.queueDeferreds[siteId] = {};\n    }\n    if (!this.queueDeferreds[siteId][fileId]) {\n      if (!create) {\n        return;\n      }\n      this.queueDeferreds[siteId][fileId] = new CorePromisedValue();\n    }\n    if (onProgress) {\n      this.queueDeferreds[siteId][fileId].onProgress = onProgress;\n    }\n    return this.queueDeferreds[siteId][fileId];\n  }\n  /**\n   * Get the on progress for a file in the queue.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @returns On progress function, undefined if not found.\n   */\n  getQueueOnProgress(siteId, fileId) {\n    const deferred = this.getQueueDeferred(siteId, fileId, false);\n    return deferred === null || deferred === void 0 ? void 0 : deferred.onProgress;\n  }\n  /**\n   * Get the promise for a file in the queue.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param create True if it should create a new promise if it doesn't exist.\n   * @param onProgress Function to call on progress.\n   * @returns Promise.\n   */\n  getQueuePromise(siteId, fileId, create = true, onProgress) {\n    return this.getQueueDeferred(siteId, fileId, create, onProgress);\n  }\n  /**\n   * Get a revision number from a list of files (highest revision).\n   *\n   * @param files Package files.\n   * @returns Highest revision.\n   */\n  getRevisionFromFileList(files) {\n    let revision = 0;\n    files.forEach(file => {\n      const fileUrl = CoreFileHelper.getFileUrl(file);\n      if (fileUrl) {\n        const r = this.getRevisionFromUrl(fileUrl);\n        if (r > revision) {\n          revision = r;\n        }\n      }\n    });\n    return revision;\n  }\n  /**\n   * Get the revision number from a file URL.\n   *\n   * @param url URL to get the revision number.\n   * @returns Revision number.\n   */\n  getRevisionFromUrl(url) {\n    const args = this.getPluginFileArgs(url);\n    if (!args) {\n      // Not a pluginfile, no revision will be found.\n      return 0;\n    }\n    const revisionRegex = CorePluginFileDelegate.getComponentRevisionRegExp(args);\n    if (!revisionRegex) {\n      return 0;\n    }\n    const matches = url.match(revisionRegex);\n    if (matches && matches[1] !== undefined) {\n      return parseInt(matches[1], 10);\n    }\n    return 0;\n  }\n  /**\n   * Returns an absolute URL to use in IMG tags.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The absolute URL to the file.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param timemodified The time this file was modified.\n   * @param checkSize True if we shouldn't download files if their size is big, false otherwise.\n   * @param downloadUnknown True to download file in WiFi if their size is unknown, false otherwise.\n   *                        Ignored if checkSize=false.\n   * @param options Extra options (isexternalfile, repositorytype).\n   * @param revision File revision. If not defined, it will be calculated using the URL.\n   * @returns Resolved with the URL to use.\n   * @description\n   * This will return a URL pointing to the content of the requested URL.\n   * The URL returned is compatible to use with IMG tags.\n   */\n  getSrcByUrl(siteId, fileUrl, component, componentId, timemodified = 0, checkSize = true, downloadUnknown, options = {}, revision) {\n    return this.getFileUrlByUrl(siteId, fileUrl, component, componentId, 'src', timemodified, checkSize, downloadUnknown, options, revision);\n  }\n  /**\n   * Get time modified from a list of files.\n   *\n   * @param files List of files.\n   * @returns Time modified.\n   */\n  getTimemodifiedFromFileList(files) {\n    let timemodified = 0;\n    files.forEach(file => {\n      if (file.timemodified && file.timemodified > timemodified) {\n        timemodified = file.timemodified;\n      }\n    });\n    return timemodified;\n  }\n  /**\n   * Returns an absolute URL to access the file.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The absolute URL to the file.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param timemodified The time this file was modified.\n   * @param checkSize True if we shouldn't download files if their size is big, false otherwise.\n   * @param downloadUnknown True to download file in WiFi if their size is unknown, false otherwise.\n   *                        Ignored if checkSize=false.\n   * @param options Extra options (isexternalfile, repositorytype).\n   * @param revision File revision. If not defined, it will be calculated using the URL.\n   * @returns Resolved with the URL to use.\n   * @description\n   * This will return a URL pointing to the content of the requested URL.\n   * The URL returned is compatible to use with a local browser.\n   */\n  getUrlByUrl(siteId, fileUrl, component, componentId, timemodified = 0, checkSize = true, downloadUnknown, options = {}, revision) {\n    return this.getFileUrlByUrl(siteId, fileUrl, component, componentId, 'url', timemodified, checkSize, downloadUnknown, options, revision);\n  }\n  /**\n   * Guess the filename of a file from its URL. This is very weak and unreliable.\n   *\n   * @param fileUrl The file URL.\n   * @returns The filename treated so it doesn't have any special character.\n   */\n  guessFilenameFromUrl(fileUrl) {\n    let filename = '';\n    if (fileUrl.indexOf('/webservice/pluginfile') !== -1) {\n      // It's a pluginfile URL. Search for the 'file' param to extract the name.\n      const params = CoreUrlUtils.extractUrlParams(fileUrl);\n      if (params.file) {\n        filename = params.file.substring(params.file.lastIndexOf('/') + 1);\n      } else {\n        // 'file' param not found. Extract what's after the last '/' without params.\n        filename = CoreUrlUtils.getLastFileWithoutParams(fileUrl);\n      }\n    } else if (CoreUrlUtils.isGravatarUrl(fileUrl)) {\n      // Extract gravatar ID.\n      filename = 'gravatar_' + CoreUrlUtils.getLastFileWithoutParams(fileUrl);\n    } else if (CoreUrlUtils.isThemeImageUrl(fileUrl)) {\n      // Extract user ID.\n      const matches = fileUrl.match(/\\/core\\/([^/]*)\\//);\n      if (matches && matches[1]) {\n        filename = matches[1];\n      }\n      // Attach a constant and the image type.\n      filename = 'default_' + filename + '_' + CoreUrlUtils.getLastFileWithoutParams(fileUrl);\n    } else {\n      // Another URL. Just get what's after the last /.\n      filename = CoreUrlUtils.getLastFileWithoutParams(fileUrl);\n    }\n    // If there are hashes in the URL, extract them.\n    const index = filename.indexOf('#');\n    let hashes;\n    if (index != -1) {\n      hashes = filename.split('#');\n      // Remove the URL from the array.\n      hashes.shift();\n      filename = filename.substring(0, index);\n    }\n    // Remove the extension from the filename.\n    filename = CoreMimetypeUtils.removeExtension(filename);\n    if (hashes) {\n      // Add hashes to the name.\n      filename += '_' + hashes.join('_');\n    }\n    return CoreTextUtils.removeSpecialCharactersForFiles(filename);\n  }\n  /**\n   * Check if the file is already in the pool. This does not check if the file is on the disk.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file Id.\n   * @returns Resolved with file object from DB on success, rejected otherwise.\n   */\n  hasFileInPool(siteId, fileId) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      return _this33.filesTables[siteId].getOneByPrimaryKey({\n        fileId\n      });\n    })();\n  }\n  /**\n   * Check if the file is in the queue.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file Id.\n   * @returns Resolved with file object from DB on success, rejected otherwise.\n   */\n  hasFileInQueue(siteId, fileId) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      const entry = yield _this34.queueTable.getOneByPrimaryKey({\n        siteId,\n        fileId\n      });\n      if (entry === undefined) {\n        throw new CoreError('File not found in queue.');\n      }\n      return _objectSpread(_objectSpread({}, entry), {}, {\n        linksUnserialized: CoreTextUtils.parseJSON(entry.links, [])\n      });\n    })();\n  }\n  /**\n   * Invalidate all the files in a site.\n   *\n   * @param siteId The site ID.\n   * @param onlyUnknown True to only invalidate files from external repos or without revision/timemodified.\n   *                    It is advised to set it to true to reduce the performance and data usage of the app.\n   * @returns Resolved on success.\n   */\n  invalidateAllFiles(siteId, onlyUnknown = true) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      onlyUnknown ? yield _this35.filesTables[siteId].updateWhere({\n        stale: 1\n      }, {\n        sql: CoreFilepoolProvider.FILE_IS_UNKNOWN_SQL,\n        js: CoreFilepoolProvider.FILE_IS_UNKNOWN_JS\n      }) : yield _this35.filesTables[siteId].update({\n        stale: 1\n      });\n    })();\n  }\n  /**\n   * Invalidate a file by URL.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file URL.\n   * @returns Resolved on success.\n   * @description\n   * Invalidates a file by marking it stale. It will not be added to the queue automatically, but the next time this file\n   * is requested it will be added to the queue.\n   * You can manully call addToQueueByUrl to add this file to the queue immediately.\n   * Please note that, if a file is stale, the user will be presented the stale file if there is no network access.\n   */\n  invalidateFileByUrl(siteId, fileUrl) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      const file = yield _this36.fixPluginfileURL(siteId, fileUrl);\n      const fileId = _this36.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n      yield _this36.filesTables[siteId].update({\n        stale: 1\n      }, {\n        fileId\n      });\n    })();\n  }\n  /**\n   * Invalidate all the matching files from a component.\n   *\n   * @param siteId The site ID.\n   * @param component The component to invalidate.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param onlyUnknown True to only invalidate files from external repos or without revision/timemodified.\n   *                It is advised to set it to true to reduce the performance and data usage of the app.\n   * @returns Resolved when done.\n   */\n  invalidateFilesByComponent(siteId, component, componentId, onlyUnknown = true) {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      var _siteId2;\n      const items = yield _this37.getComponentFiles(siteId, component, componentId);\n      if (!items.length) {\n        // Nothing to invalidate.\n        return;\n      }\n      siteId = (_siteId2 = siteId) !== null && _siteId2 !== void 0 ? _siteId2 : CoreSites.getCurrentSiteId();\n      const fileIds = items.map(item => item.fileId);\n      const whereAndParams = SQLiteDB.getInOrEqual(fileIds);\n      whereAndParams.sql = 'fileId ' + whereAndParams.sql;\n      if (onlyUnknown) {\n        whereAndParams.sql += ' AND (' + CoreFilepoolProvider.FILE_IS_UNKNOWN_SQL + ')';\n      }\n      yield _this37.filesTables[siteId].updateWhere({\n        stale: 1\n      }, {\n        sql: whereAndParams.sql,\n        sqlParams: whereAndParams.params,\n        js: record => fileIds.includes(record.fileId) && (!onlyUnknown || CoreFilepoolProvider.FILE_IS_UNKNOWN_JS(record))\n      });\n    })();\n  }\n  /**\n   * Whether a file action indicates a file was downloaded or deleted.\n   *\n   * @param data Event data.\n   * @returns Whether downloaded or deleted.\n   */\n  isFileEventDownloadedOrDeleted(data) {\n    return data.action == \"download\" /* CoreFilepoolFileActions.DOWNLOAD */ && data.success == true || data.action == \"deleted\" /* CoreFilepoolFileActions.DELETED */;\n  }\n  /**\n   * Check whether a file is downloadable.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl File URL.\n   * @param timemodified The time this file was modified.\n   * @param filePath Filepath to download the file to. If defined, no extension will be added.\n   * @param revision File revision. If not defined, it will be calculated using the URL.\n   * @returns Promise resolved with a boolean: whether a file is downloadable.\n   */\n  isFileDownloadable(siteId, fileUrl, timemodified = 0, filePath, revision) {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      const state = yield _this38.getFileStateByUrl(siteId, fileUrl, timemodified, filePath, revision);\n      return state != CoreConstants.NOT_DOWNLOADABLE;\n    })();\n  }\n  /**\n   * Check if a file is downloading.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl File URL.\n   * @returns Promise resolved with boolean: whether the file is downloading.\n   */\n  isFileDownloadingByUrl(siteId, fileUrl) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      const file = yield _this39.fixPluginfileURL(siteId, fileUrl);\n      const fileId = _this39.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n      try {\n        yield _this39.hasFileInQueue(siteId, fileId);\n        return true;\n      } catch (_unused2) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Check if a file is outdated.\n   *\n   * @param entry Filepool entry.\n   * @param revision File revision number.\n   * @param timemodified The time this file was modified.\n   * @returns Whether the file is outdated.\n   */\n  isFileOutdated(entry, revision = 0, timemodified = 0) {\n    var _entry$timemodified, _entry$revision;\n    // Don't allow undefined values, convert them to 0.\n    const entryTimemodified = (_entry$timemodified = entry.timemodified) !== null && _entry$timemodified !== void 0 ? _entry$timemodified : 0;\n    const entryRevision = (_entry$revision = entry.revision) !== null && _entry$revision !== void 0 ? _entry$revision : 0;\n    return !!entry.stale || revision > entryRevision || timemodified > entryTimemodified;\n  }\n  /**\n   * Check if cannot determine if a file has been updated.\n   *\n   * @param entry Filepool entry.\n   * @returns Whether it cannot determine updates.\n   */\n  isFileUpdateUnknown(entry) {\n    return !!entry.isexternalfile || !entry.revision && !entry.timemodified;\n  }\n  /**\n   * Notify an action performed on a file to a list of components.\n   *\n   * @param siteId The site ID.\n   * @param eventData The file event data.\n   * @param links The links to the components.\n   */\n  notifyFileActionToComponents(siteId, eventData, links) {\n    links.forEach(link => {\n      const data = Object.assign({\n        component: link.component,\n        componentId: link.componentId\n      }, eventData);\n      CoreEvents.trigger(CoreEvents.COMPONENT_FILE_ACTION, data, siteId);\n    });\n  }\n  /**\n   * Notify a file has been deleted.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param links The links to components.\n   */\n  notifyFileDeleted(siteId, fileId, links) {\n    const data = {\n      fileId,\n      action: \"deleted\" /* CoreFilepoolFileActions.DELETED */\n    };\n\n    CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n    this.notifyFileActionToComponents(siteId, data, links);\n  }\n  /**\n   * Notify a file has been downloaded.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param links The links to components.\n   */\n  notifyFileDownloaded(siteId, fileId, links) {\n    const data = {\n      fileId,\n      action: \"download\" /* CoreFilepoolFileActions.DOWNLOAD */,\n      success: true\n    };\n    CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n    this.notifyFileActionToComponents(siteId, data, links);\n  }\n  /**\n   * Notify error occurred while downloading a file.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param links The links to components.\n   */\n  notifyFileDownloadError(siteId, fileId, links) {\n    const data = {\n      fileId,\n      action: \"download\" /* CoreFilepoolFileActions.DOWNLOAD */,\n      success: false\n    };\n    CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n    this.notifyFileActionToComponents(siteId, data, links);\n  }\n  /**\n   * Notify a file starts being downloaded or added to queue.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param links The links to components.\n   */\n  notifyFileDownloading(siteId, fileId, links) {\n    const data = {\n      fileId,\n      action: \"downloading\" /* CoreFilepoolFileActions.DOWNLOADING */\n    };\n\n    CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n    this.notifyFileActionToComponents(siteId, data, links);\n  }\n  /**\n   * Notify a file has been outdated.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param links The links to components.\n   */\n  notifyFileOutdated(siteId, fileId, links) {\n    const data = {\n      fileId,\n      action: \"outdated\" /* CoreFilepoolFileActions.OUTDATED */\n    };\n\n    CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n    this.notifyFileActionToComponents(siteId, data, links);\n  }\n  /**\n   * Prefetches a list of files.\n   *\n   * @param siteId The site ID.\n   * @param fileList List of files to download.\n   * @param component The component to link the file to.\n   * @param componentId An ID to identify the download.\n   * @param extra Extra data to store for the package.\n   * @param dirPath Name of the directory where to store the files (inside filepool dir). If not defined, store\n   *                the files directly inside the filepool folder.\n   * @param onProgress Function to call on progress.\n   * @returns Promise resolved when all files are downloaded.\n   */\n  prefetchPackage(siteId, fileList, component, componentId, extra, dirPath, onProgress) {\n    return this.downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, extra, dirPath, onProgress);\n  }\n  /**\n   * Process the queue.\n   *\n   * @description\n   * This loops over itself to keep on processing the queue in the background.\n   * The queue process is site agnostic.\n   */\n  processQueue() {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (_this40.queueState !== CoreFilepoolProvider.QUEUE_RUNNING) {\n          // Silently ignore, the queue is on pause.\n          throw CoreFilepoolProvider.ERR_QUEUE_ON_PAUSE;\n        } else if (!CoreFile.isAvailable() || !CoreNetwork.isOnline()) {\n          throw CoreFilepoolProvider.ERR_FS_OR_NETWORK_UNAVAILABLE;\n        }\n        yield _this40.processImportantQueueItem();\n      } catch (error) {\n        // We had an error, in which case we pause the processing.\n        if (error === CoreFilepoolProvider.ERR_FS_OR_NETWORK_UNAVAILABLE) {\n          _this40.logger.debug('Filesysem or network unavailable, pausing queue processing.');\n        } else if (error === CoreFilepoolProvider.ERR_QUEUE_IS_EMPTY) {\n          _this40.logger.debug('Queue is empty, pausing queue processing.');\n        }\n        _this40.queueState = CoreFilepoolProvider.QUEUE_PAUSED;\n        return;\n      }\n      // All good, we schedule next execution.\n      setTimeout(() => {\n        _this40.processQueue();\n      }, CoreFilepoolProvider.QUEUE_PROCESS_INTERVAL);\n    })();\n  }\n  /**\n   * Process the most important queue item.\n   *\n   * @returns Resolved on success. Rejected on failure.\n   */\n  processImportantQueueItem() {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const item = yield _this41.queueTable.getOne({}, {\n          sorting: [{\n            priority: 'desc'\n          }, {\n            added: 'asc'\n          }]\n        });\n        if (!item) {\n          throw CoreFilepoolProvider.ERR_QUEUE_IS_EMPTY;\n        }\n        return _this41.processQueueItem(_objectSpread(_objectSpread({}, item), {}, {\n          linksUnserialized: CoreTextUtils.parseJSON(item.links, [])\n        }));\n      } catch (err) {\n        throw CoreFilepoolProvider.ERR_QUEUE_IS_EMPTY;\n      }\n    })();\n  }\n  /**\n   * Process a queue item.\n   *\n   * @param item The object from the queue store.\n   * @returns Resolved on success. Rejected on failure.\n   */\n  processQueueItem(item) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      var _item$revision, _item$timemodified, _item$isexternalfile, _item$repositorytype;\n      // Cast optional fields to undefined instead of null.\n      const siteId = item.siteId;\n      const fileId = item.fileId;\n      const fileUrl = item.url;\n      const options = {\n        revision: (_item$revision = item.revision) !== null && _item$revision !== void 0 ? _item$revision : 0,\n        timemodified: (_item$timemodified = item.timemodified) !== null && _item$timemodified !== void 0 ? _item$timemodified : 0,\n        isexternalfile: (_item$isexternalfile = item.isexternalfile) !== null && _item$isexternalfile !== void 0 ? _item$isexternalfile : undefined,\n        repositorytype: (_item$repositorytype = item.repositorytype) !== null && _item$repositorytype !== void 0 ? _item$repositorytype : undefined\n      };\n      const filePath = item.path || undefined;\n      const links = item.linksUnserialized || [];\n      _this42.logger.debug('Processing queue item: ' + siteId + ', ' + fileId);\n      let entry;\n      // Check if the file is already in pool.\n      try {\n        entry = yield _this42.hasFileInPool(siteId, fileId);\n      } catch (error) {\n        // File not in pool.\n      }\n      if (entry && !options.isexternalfile && !_this42.isFileOutdated(entry, options.revision, options.timemodified)) {\n        // We have the file, it is not stale, we can update links and remove from queue.\n        _this42.logger.debug('Queued file already in store, ignoring...');\n        _this42.addFileLinks(siteId, fileId, links).catch(() => {\n          // Ignore errors.\n        });\n        _this42.removeFromQueue(siteId, fileId).catch(() => {\n          // Ignore errors.\n        }).finally(() => {\n          _this42.treatQueueDeferred(siteId, fileId, true);\n        });\n        return;\n      }\n      // The file does not exist, or is stale, ... download it.\n      const onProgress = _this42.getQueueOnProgress(siteId, fileId);\n      try {\n        yield _this42.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, entry);\n        // Success, we add links and remove from queue.\n        CoreUtils.ignoreErrors(_this42.addFileLinks(siteId, fileId, links));\n        // Wait for the item to be removed from queue before resolving the promise.\n        // If the item could not be removed from queue we still resolve the promise.\n        yield CoreUtils.ignoreErrors(_this42.removeFromQueue(siteId, fileId));\n        _this42.treatQueueDeferred(siteId, fileId, true);\n        _this42.notifyFileDownloaded(siteId, fileId, links);\n      } catch (errorObject) {\n        // Whoops, we have an error...\n        let dropFromQueue = false;\n        if (errorObject && errorObject.source === fileUrl) {\n          // This is most likely a FileTransfer error.\n          if (errorObject.code === 1) {\n            // FILE_NOT_FOUND_ERR.\n            // The file was not found, most likely a 404, we remove from queue.\n            dropFromQueue = true;\n          } else if (errorObject.code === 2) {\n            // INVALID_URL_ERR.\n            // The URL is invalid, we drop the file from the queue.\n            dropFromQueue = true;\n          } else if (errorObject.code === 3) {\n            // CONNECTION_ERR.\n            // If there was an HTTP status, then let's remove from the queue.\n            dropFromQueue = true;\n          } else if (errorObject.code === 4) {// ABORTED_ERR.\n            // The transfer was aborted, we will keep the file in queue.\n          } else if (errorObject.code === 5) {\n            // NOT_MODIFIED_ERR.\n            // We have the latest version of the file, HTTP 304 status.\n            dropFromQueue = true;\n          } else {\n            // Any error, let's remove the file from the queue to avoi locking down the queue.\n            dropFromQueue = true;\n          }\n        } else {\n          dropFromQueue = true;\n        }\n        let errorMessage;\n        // Some Android devices restrict the amount of usable storage using quotas.\n        // If this quota would be exceeded by the download, it throws an exception.\n        // We catch this exception here, and report a meaningful error message to the user.\n        if (errorObject instanceof FileTransferError && errorObject.exception && errorObject.exception.includes('EDQUOT')) {\n          errorMessage = 'core.course.insufficientavailablequota';\n        }\n        if (dropFromQueue) {\n          _this42.logger.debug('Item dropped from queue due to error: ' + fileUrl, errorObject);\n          yield CoreUtils.ignoreErrors(_this42.removeFromQueue(siteId, fileId));\n          _this42.treatQueueDeferred(siteId, fileId, false, errorMessage);\n          _this42.notifyFileDownloadError(siteId, fileId, links);\n        } else {\n          // We considered the file as legit but did not get it, failure.\n          _this42.treatQueueDeferred(siteId, fileId, false, errorMessage);\n          _this42.notifyFileDownloadError(siteId, fileId, links);\n          throw errorObject;\n        }\n      }\n    })();\n  }\n  /**\n   * Remove a file from the queue.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @returns Resolved on success. Rejected on failure. It is advised to silently ignore failures.\n   */\n  removeFromQueue(siteId, fileId) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      yield _this43.queueTable.deleteByPrimaryKey({\n        siteId,\n        fileId\n      });\n    })();\n  }\n  /**\n   * Remove a file from the pool.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @returns Resolved on success.\n   */\n  removeFileById(siteId, fileId) {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      // Get the path to the file first since it relies on the file object stored in the pool.\n      // Don't use getFilePath to prevent performing 2 DB requests.\n      let path = _this44.getFilepoolFolderPath(siteId) + '/' + fileId;\n      let fileUrl;\n      try {\n        const entry = yield _this44.hasFileInPool(siteId, fileId);\n        fileUrl = entry.url;\n        if (entry.extension) {\n          path += '.' + entry.extension;\n        }\n      } catch (error) {\n        // If file not found, use the path without extension.\n      }\n      const conditions = {\n        fileId\n      };\n      // Get links to components to notify them after remove.\n      const links = yield _this44.getFileLinks(siteId, fileId);\n      const promises = [];\n      // Remove entry from filepool store.\n      promises.push(_this44.filesTables[siteId].delete(conditions));\n      // Remove links.\n      promises.push(_this44.linksTables[siteId].delete(conditions));\n      // Remove the file.\n      if (CoreFile.isAvailable()) {\n        promises.push(CoreFile.removeFile(path).catch(error => {\n          if (error && error.code == 1) {\n            // Not found, ignore error since maybe it was deleted already.\n          } else {\n            throw error;\n          }\n        }));\n      }\n      yield Promise.all(promises);\n      _this44.notifyFileDeleted(siteId, fileId, links);\n      if (fileUrl) {\n        yield CoreUtils.ignoreErrors(CorePluginFileDelegate.fileDeleted(fileUrl, path, siteId));\n      }\n    })();\n  }\n  /**\n   * Delete all the matching files from a component.\n   *\n   * @param siteId The site ID.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Resolved on success.\n   */\n  removeFilesByComponent(siteId, component, componentId) {\n    var _this45 = this;\n    return _asyncToGenerator(function* () {\n      const items = yield _this45.getComponentFiles(siteId, component, componentId);\n      yield Promise.all(items.map(item => _this45.removeFileById(siteId, item.fileId)));\n    })();\n  }\n  /**\n   * Remove a file from the pool.\n   *\n   * @param siteId The site ID.\n   * @param fileUrl The file URL.\n   * @returns Resolved on success, rejected on failure.\n   */\n  removeFileByUrl(siteId, fileUrl) {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      const file = yield _this46.fixPluginfileURL(siteId, fileUrl);\n      const fileId = _this46.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n      yield _this46.removeFileById(siteId, fileId);\n    })();\n  }\n  /**\n   * Removes the revision number from a file URL.\n   *\n   * @param url URL to remove the revision number.\n   * @returns URL without revision number.\n   * @description\n   * The revision is used to know if a file has changed. We remove it from the URL to prevent storing a file per revision.\n   */\n  removeRevisionFromUrl(url) {\n    const args = this.getPluginFileArgs(url);\n    if (!args) {\n      // Not a pluginfile, no revision will be found.\n      return url;\n    }\n    return CorePluginFileDelegate.removeRevisionFromUrl(url, args);\n  }\n  /**\n   * Change the package status, setting it to the previous status.\n   *\n   * @param siteId Site ID.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved when the status is changed. Resolve param: new status.\n   */\n  setPackagePreviousStatus(siteId, component, componentId) {\n    var _this47 = this;\n    return _asyncToGenerator(function* () {\n      componentId = _this47.fixComponentId(componentId);\n      _this47.logger.debug(`Set previous status for package ${component} ${componentId}`);\n      const packageId = _this47.getPackageId(component, componentId);\n      // Get current stored data, we'll only update 'status' and 'updated' fields.\n      const entry = yield _this47.packagesTables[siteId].getOneByPrimaryKey({\n        id: packageId\n      });\n      const newData = {};\n      if (entry.status == CoreConstants.DOWNLOADING) {\n        // Going back from downloading to previous status, restore previous download time.\n        newData.downloadTime = entry.previousDownloadTime;\n      }\n      newData.status = entry.previous || CoreConstants.NOT_DOWNLOADED;\n      newData.updated = Date.now();\n      _this47.logger.debug(`Set previous status '${entry.status}' for package ${component} ${componentId}`);\n      yield _this47.packagesTables[siteId].update(newData, {\n        id: packageId\n      });\n      // Success updating, trigger event.\n      _this47.triggerPackageStatusChanged(siteId, newData.status, component, componentId);\n      return newData.status;\n    })();\n  }\n  /**\n   * Check if a file should be downloaded based on its size.\n   *\n   * @param size File size.\n   * @returns Whether file should be downloaded.\n   */\n  shouldDownload(size) {\n    return size <= CoreFilepoolProvider.DOWNLOAD_THRESHOLD || CoreNetwork.isWifi() && size <= CoreFilepoolProvider.WIFI_DOWNLOAD_THRESHOLD;\n  }\n  /**\n   * Convenience function to check if a file should be downloaded before opening it.\n   *\n   * @param url File online URL.\n   * @param size File size.\n   * @param options Options.\n   * @returns Promise resolved with boolean: whether file should be downloaded before opening it.\n   * @description\n   * Convenience function to check if a file should be downloaded before opening it.\n   *\n   * The default behaviour in the app is to download first and then open the local file in the following cases:\n   *     - The file is small (less than DOWNLOAD_THRESHOLD).\n   *     - The file cannot be streamed.\n   * If the file is big and can be streamed, the promise returned by this function will be rejected.\n   */\n  shouldDownloadFileBeforeOpen(url, size, options = {}) {\n    return _asyncToGenerator(function* () {\n      if (size >= 0 && size <= CoreFilepoolProvider.DOWNLOAD_THRESHOLD) {\n        // The file is small, download it.\n        return true;\n      }\n      if (CoreUtils.shouldOpenWithDialog(options)) {\n        // Open with dialog needs a local file.\n        return true;\n      }\n      const mimetype = yield CoreUtils.getMimeTypeFromUrl(url);\n      // If the file is streaming (audio or video), return false.\n      return !CoreMimetypeUtils.isStreamedMimetype(mimetype);\n    })();\n  }\n  /**\n   * Store package status.\n   *\n   * @param siteId Site ID.\n   * @param status New package status.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param extra Extra data to store for the package. If you want to store more than 1 value, use JSON.stringify.\n   * @returns Promise resolved when status is stored.\n   */\n  storePackageStatus(siteId, status, component, componentId, extra) {\n    var _this48 = this;\n    return _asyncToGenerator(function* () {\n      _this48.logger.debug(`Set status '${status}' for package ${component} ${componentId}`);\n      componentId = _this48.fixComponentId(componentId);\n      const packageId = _this48.getPackageId(component, componentId);\n      let downloadTime;\n      let previousDownloadTime;\n      if (status == CoreConstants.DOWNLOADING) {\n        // Set download time if package is now downloading.\n        downloadTime = CoreTimeUtils.timestamp();\n      }\n      let previousStatus;\n      // Search current status to set it as previous status.\n      try {\n        var _extra;\n        const entry = yield _this48.packagesTables[siteId].getOneByPrimaryKey({\n          id: packageId\n        });\n        extra = (_extra = extra) !== null && _extra !== void 0 ? _extra : entry.extra;\n        if (downloadTime === undefined) {\n          // Keep previous download time.\n          downloadTime = entry.downloadTime;\n          previousDownloadTime = entry.previousDownloadTime;\n        } else {\n          // The downloadTime will be updated, store current time as previous.\n          previousDownloadTime = entry.downloadTime;\n        }\n        previousStatus = entry.status;\n      } catch (error) {\n        // No previous status.\n      }\n      if (previousStatus === status) {\n        // The package already has this status, no need to change it.\n        return;\n      }\n      yield _this48.packagesTables[siteId].insert({\n        id: packageId,\n        component,\n        componentId,\n        status,\n        previous: previousStatus,\n        updated: Date.now(),\n        downloadTime,\n        previousDownloadTime,\n        extra\n      });\n      // Success inserting, trigger event.\n      _this48.triggerPackageStatusChanged(siteId, status, component, componentId);\n    })();\n  }\n  /**\n   * Search for files in a CSS code and try to download them. Once downloaded, replace their URLs\n   * and store the result in the CSS file.\n   *\n   * @param siteId Site ID.\n   * @param fileUrl CSS file URL. It must be the online URL, not a local path.\n   * @param cssCode CSS code.\n   * @param component The component to link the file to.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param revision Revision to use in all files. If not defined, it will be calculated using the URL of each file.\n   * @returns Promise resolved with the CSS code.\n   */\n  treatCSSCode(siteId, fileUrl, cssCode, component, componentId, revision) {\n    var _this49 = this;\n    return _asyncToGenerator(function* () {\n      const urls = CoreDomUtils.extractUrlsFromCSS(cssCode);\n      let updated = false;\n      // Get the path of the CSS file. If it's a local file, assume it's the path where to write the file.\n      const filePath = yield _this49.getFilePathByUrl(siteId, fileUrl);\n      // Download all files in the CSS.\n      yield Promise.all(urls.map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (url) {\n          if (!url.trim()) {\n            return; // Ignore empty URLs.\n          }\n\n          const absoluteUrl = CoreUrl.toAbsoluteURL(fileUrl, url);\n          try {\n            let fileUrl = absoluteUrl;\n            if (!CoreUrlUtils.isLocalFileUrl(absoluteUrl)) {\n              // Not a local file, download it.\n              fileUrl = yield _this49.downloadUrl(siteId, absoluteUrl, false, component, componentId, 0, undefined, undefined, undefined, revision);\n            }\n            // Convert the URL so it works in mobile devices.\n            fileUrl = CoreFile.convertFileSrc(fileUrl);\n            if (fileUrl !== url) {\n              cssCode = cssCode.replace(new RegExp(CoreTextUtils.escapeForRegex(url), 'g'), fileUrl);\n              updated = true;\n            }\n          } catch (error) {\n            _this49.logger.warn('Error treating file ', url, error);\n            // If the URL is relative, store the absolute URL.\n            if (absoluteUrl !== url) {\n              cssCode = cssCode.replace(new RegExp(CoreTextUtils.escapeForRegex(url), 'g'), absoluteUrl);\n              updated = true;\n            }\n          }\n        });\n        return function (_x4) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n      // All files downloaded. Store the result if it has changed.\n      if (updated) {\n        yield CoreFile.writeFile(filePath, cssCode);\n      }\n      return cssCode;\n    })();\n  }\n  /**\n   * Resolves or rejects a queue deferred and removes it from the list.\n   *\n   * @param siteId The site ID.\n   * @param fileId The file ID.\n   * @param resolve True if promise should be resolved, false if it should be rejected.\n   * @param error String identifier for error message, if rejected.\n   */\n  treatQueueDeferred(siteId, fileId, resolve, error) {\n    if (siteId in this.queueDeferreds && fileId in this.queueDeferreds[siteId]) {\n      if (resolve) {\n        this.queueDeferreds[siteId][fileId].resolve();\n      } else {\n        this.queueDeferreds[siteId][fileId].reject(new Error(error));\n      }\n      delete this.queueDeferreds[siteId][fileId];\n    }\n  }\n  /**\n   * Trigger package status changed event with the right data.\n   *\n   * @param siteId Site ID.\n   * @param status New package status.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   */\n  triggerPackageStatusChanged(siteId, status, component, componentId) {\n    const data = {\n      component,\n      componentId: this.fixComponentId(componentId),\n      status\n    };\n    CoreEvents.trigger(CoreEvents.PACKAGE_STATUS_CHANGED, data, siteId);\n  }\n  /**\n   * Update the download time of a package. This doesn't modify the previous download time.\n   * This function should be used if a package generates some new data during a download. Calling this function\n   * right after generating the data in the download will prevent detecting this data as an update.\n   *\n   * @param siteId Site ID.\n   * @param component Package's component.\n   * @param componentId An ID to use in conjunction with the component.\n   * @returns Promise resolved when status is stored.\n   */\n  updatePackageDownloadTime(siteId, component, componentId) {\n    var _this50 = this;\n    return _asyncToGenerator(function* () {\n      componentId = _this50.fixComponentId(componentId);\n      const packageId = _this50.getPackageId(component, componentId);\n      yield _this50.packagesTables[siteId].update({\n        downloadTime: CoreTimeUtils.timestamp()\n      }, {\n        id: packageId\n      });\n    })();\n  }\n}\n_class = CoreFilepoolProvider;\n// Constants.\n_class.QUEUE_PROCESS_INTERVAL = 0;\n_class.FOLDER = 'filepool';\n_class.WIFI_DOWNLOAD_THRESHOLD = 20971520;\n// 20MB.\n_class.DOWNLOAD_THRESHOLD = 2097152;\n// 2MB.\n_class.QUEUE_RUNNING = 'CoreFilepool:QUEUE_RUNNING';\n_class.QUEUE_PAUSED = 'CoreFilepool:QUEUE_PAUSED';\n_class.ERR_QUEUE_IS_EMPTY = 'CoreFilepoolError:ERR_QUEUE_IS_EMPTY';\n_class.ERR_FS_OR_NETWORK_UNAVAILABLE = 'CoreFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE';\n_class.ERR_QUEUE_ON_PAUSE = 'CoreFilepoolError:ERR_QUEUE_ON_PAUSE';\n_class.FILE_IS_UNKNOWN_SQL = 'isexternalfile = 1 OR ((revision IS NULL OR revision = 0) AND (timemodified IS NULL OR timemodified = 0))';\n_class.FILE_IS_UNKNOWN_JS = ({\n  isexternalfile,\n  revision,\n  timemodified\n}) => isexternalfile === 1 || (revision === null || revision === 0) && (timemodified === null || timemodified === 0);\n_class.ɵfac = function CoreFilepoolProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreFilepool = makeSingleton(CoreFilepoolProvider);","map":{"version":3,"names":["Md5","CoreApp","CoreNetwork","CoreEvents","CoreFile","CorePluginFileDelegate","CoreSites","CoreWS","CoreDomUtils","CoreMimetypeUtils","CoreTextUtils","CoreTimeUtils","CoreUrlUtils","CoreUtils","SQLiteDB","CoreError","CoreConstants","ApplicationInit","makeSingleton","NgZone","Translate","CoreLogger","APP_SCHEMA","FILES_TABLE_NAME","QUEUE_TABLE_NAME","PACKAGES_TABLE_NAME","LINKS_TABLE_NAME","CoreFileHelper","CoreUrl","CoreDatabaseCachingStrategy","CoreDatabaseTableProxy","lazyMap","asyncInstance","CorePath","CorePromisedValue","CoreAnalytics","CoreAnalyticsEventType","CoreFilepoolProvider","constructor","queueState","QUEUE_PAUSED","urlAttributes","RegExp","queueDeferreds","sizeCache","packagesPromises","filePromises","queueTable","logger","getInstance","filesTables","siteId","getSiteTable","config","cachingStrategy","Lazy","primaryKeyColumns","onDestroy","linksTables","packagesTables","initialize","whenDone","checkQueueProcessing","onConnectShouldBeStable","subscribe","run","initializeDatabase","_this","_asyncToGenerator","createTablesFromSchema","e","getDB","setInstance","addFileLink","fileId","component","componentId","_this2","insert","fixComponentId","addFileLinkByUrl","fileUrl","_this3","file","fixPluginfileURL","getFileIdByUrl","getFileUrl","addFileLinks","links","_this4","promises","map","link","Promise","all","addFilesToQueue","files","downloadOrPrefetchFiles","addFileToPool","data","_this5","record","_objectSpread","addHashToFilename","url","filename","matches","match","length","hash","treatedUrl","replace","hashAsciiStr","addToQueue","priority","revision","timemodified","filePath","onProgress","options","_this6","debug","path","isexternalfile","repositorytype","JSON","stringify","added","Date","now","notifyFileDownloading","getQueuePromise","addToQueueByUrl","alreadyFixed","_this7","_revision","isAvailable","site","getSite","canDownloadFiles","instant","_file$timemodified","getRevisionFromUrl","primaryKey","createComponentLink","queueDeferred","getQueueDeferred","entry","hasFileInQueue","error","newData","foundLink","linksUnserialized","some","fileLink","push","Object","keys","update","then","addToQueueIfNeeded","checkSize","downloadUnknown","_this8","undefined","size","isOnline","getRemoteFileSize","isWifi","sizeUnknown","shouldDownload","QUEUE_RUNNING","processQueue","clearAllPackagesStatus","_this9","entries","getMany","delete","forEach","triggerPackageStatusChanged","NOT_DOWNLOADED","clearFilepool","_this10","filesEntries","filesLinks","filesLinksMap","arrayToObjectMultiple","notifyFileDeleted","componentHasFiles","_this11","conditions","hasAnyLinks","hasAny","createComponentLinks","determinePackagesStatus","current","packageStatus","NOT_DOWNLOADABLE","DOWNLOADED","DOWNLOADING","OUTDATED","downloadForPoolByUrl","poolFileObject","_this12","anchor","getUrlAnchor","extension","guessExtensionFromUrl","addExtension","getFilePath","downloadId","getFileDownloadId","_ref","downloadFile","fileEntry","treatDownloadedFile","downloadTime","stale","logEvent","type","DOWNLOAD_FILE","unfixPluginfileURL","getURL","toURL","_x","apply","arguments","finally","prefetch","ignoreStale","dirPath","filepath","substring","concatenatePaths","downloadUrl","allPromises","downloadOrPrefetchPackage","fileList","extra","_this13","packageId","getPackageId","promise","storePackageStatus","packageLoaded","fileLoaded","onFileProgress","progress","loaded","packageDownload","fileProgress","setPackagePreviousStatus","downloadPackage","_this14","_file$timemodified2","alreadyDownloaded","assign","finishSuccessfulDownload","ignoreErrors","notifyFileDownloaded","fileObject","hasFileInPool","isFileOutdated","getInternalUrlByPath","getInternalUrlById","notifyFileDownloadError","extractDownloadableFilesFromHtml","html","urls","element","convertToElement","elements","Array","from","querySelectorAll","i","href","src","isDownloadableUrl","indexOf","tagName","getAttribute","poster","concat","getDownloadableFilesFromHTML","extractDownloadableFilesFromHtmlAsFakeFileObjects","fileurl","fillExtensionInFile","_this15","getFileExtension","removeExtension","id","parseInt","isNaN","getDownloadableFile","checkAndFixPluginfileURL","getComponentFiles","_this16","_siteId","getCurrentSiteId","items","item","getDirectoryUrlByUrl","_this17","dirEntry","getDir","getFileEventName","getFileEventNameByUrl","removeRevisionFromUrl","decodeHTML","decodeURIComponent","regex","removeUrlAnchor","guessFilenameFromUrl","getFileLinks","_this18","_this19","getFilepoolFolderPath","getFilePathByUrl","_this20","getFileUrlByPath","_this21","getOne","getSiteFolder","FOLDER","getFilesByComponent","_this22","_ref3","getOneByPrimaryKey","_x2","getFilesSizeByComponent","_this23","_ref4","fileSize","getFileSize","_unused","_x3","getFileStateByUrl","_this24","_file$timemodified3","_revision2","getFileUrlByUrl","mode","_this25","_file$timemodified4","_revision3","getInternalSrcById","removeFileById","_this26","getFile","convertFileSrc","_this27","getInternalUrlByUrl","_this28","getPackageData","_this29","getPackageDirNameByUrl","candidate","getPackageDirPathByUrl","dirName","getPackageDirUrlByUrl","_this30","getPackageDownloadPromise","getPackageExtra","getPackagePreviousStatus","_this31","previous","getPackageStatus","_this32","status","getPluginFileArgs","isPluginFileUrl","relativePath","args","split","create","getQueueOnProgress","deferred","getRevisionFromFileList","r","revisionRegex","getComponentRevisionRegExp","getSrcByUrl","getTimemodifiedFromFileList","getUrlByUrl","params","extractUrlParams","lastIndexOf","getLastFileWithoutParams","isGravatarUrl","isThemeImageUrl","index","hashes","shift","join","removeSpecialCharactersForFiles","_this33","_this34","parseJSON","invalidateAllFiles","onlyUnknown","_this35","updateWhere","sql","FILE_IS_UNKNOWN_SQL","js","FILE_IS_UNKNOWN_JS","invalidateFileByUrl","_this36","invalidateFilesByComponent","_this37","_siteId2","fileIds","whereAndParams","getInOrEqual","sqlParams","includes","isFileEventDownloadedOrDeleted","action","success","isFileDownloadable","_this38","state","isFileDownloadingByUrl","_this39","_unused2","_entry$timemodified","_entry$revision","entryTimemodified","entryRevision","isFileUpdateUnknown","notifyFileActionToComponents","eventData","trigger","COMPONENT_FILE_ACTION","notifyFileOutdated","prefetchPackage","_this40","ERR_QUEUE_ON_PAUSE","ERR_FS_OR_NETWORK_UNAVAILABLE","processImportantQueueItem","ERR_QUEUE_IS_EMPTY","setTimeout","QUEUE_PROCESS_INTERVAL","_this41","sorting","processQueueItem","err","_this42","_item$revision","_item$timemodified","_item$isexternalfile","_item$repositorytype","catch","removeFromQueue","treatQueueDeferred","errorObject","dropFromQueue","source","code","errorMessage","FileTransferError","exception","_this43","deleteByPrimaryKey","_this44","removeFile","fileDeleted","removeFilesByComponent","_this45","removeFileByUrl","_this46","_this47","previousDownloadTime","updated","DOWNLOAD_THRESHOLD","WIFI_DOWNLOAD_THRESHOLD","shouldDownloadFileBeforeOpen","shouldOpenWithDialog","mimetype","getMimeTypeFromUrl","isStreamedMimetype","_this48","timestamp","previousStatus","_extra","treatCSSCode","cssCode","_this49","extractUrlsFromCSS","_ref5","trim","absoluteUrl","toAbsoluteURL","isLocalFileUrl","escapeForRegex","warn","_x4","writeFile","resolve","reject","Error","PACKAGE_STATUS_CHANGED","updatePackageDownloadTime","_this50","_class","factory","ɵfac","providedIn","CoreFilepool"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/filepool.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { Md5 } from 'ts-md5/dist/md5';\n\nimport { CoreApp } from '@services/app';\nimport { CoreNetwork } from '@services/network';\nimport { CoreEventPackageStatusChanged, CoreEvents } from '@singletons/events';\nimport { CoreFile } from '@services/file';\nimport { CorePluginFileDelegate } from '@services/plugin-file-delegate';\nimport { CoreSites } from '@services/sites';\nimport { CoreWS, CoreWSExternalFile, CoreWSFile } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreMimetypeUtils } from '@services/utils/mimetype';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils, CoreUtilsOpenFileOptions } from '@services/utils/utils';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreConstants } from '@/core/constants';\nimport { ApplicationInit, makeSingleton, NgZone, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport {\n    APP_SCHEMA,\n    FILES_TABLE_NAME,\n    QUEUE_TABLE_NAME,\n    PACKAGES_TABLE_NAME,\n    LINKS_TABLE_NAME,\n    CoreFilepoolFileEntry,\n    CoreFilepoolComponentLink,\n    CoreFilepoolFileOptions,\n    CoreFilepoolLinksRecord,\n    CoreFilepoolPackageEntry,\n    CoreFilepoolQueueEntry,\n    CoreFilepoolQueueDBEntry,\n} from '@services/database/filepool';\nimport { CoreFileHelper } from './file-helper';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreDatabaseTable } from '@classes/database/database-table';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport { lazyMap, LazyMap } from '../utils/lazy-map';\nimport { asyncInstance, AsyncInstance } from '../utils/async-instance';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CoreAnalytics, CoreAnalyticsEventType } from './analytics';\n\n/*\n * Factory for handling downloading files and retrieve downloaded files.\n *\n * @description\n * This factory is responsible for handling downloading files.\n *\n * The two main goals of this is to keep the content available offline, and improve the user experience by caching\n * the content locally.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreFilepoolProvider {\n\n    // Constants.\n    protected static readonly QUEUE_PROCESS_INTERVAL = 0;\n    protected static readonly FOLDER = 'filepool';\n    protected static readonly WIFI_DOWNLOAD_THRESHOLD = 20971520; // 20MB.\n    protected static readonly DOWNLOAD_THRESHOLD = 2097152; // 2MB.\n    protected static readonly QUEUE_RUNNING = 'CoreFilepool:QUEUE_RUNNING';\n    protected static readonly QUEUE_PAUSED = 'CoreFilepool:QUEUE_PAUSED';\n    protected static readonly ERR_QUEUE_IS_EMPTY = 'CoreFilepoolError:ERR_QUEUE_IS_EMPTY';\n    protected static readonly ERR_FS_OR_NETWORK_UNAVAILABLE = 'CoreFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE';\n    protected static readonly ERR_QUEUE_ON_PAUSE = 'CoreFilepoolError:ERR_QUEUE_ON_PAUSE';\n\n    protected static readonly FILE_IS_UNKNOWN_SQL =\n        'isexternalfile = 1 OR ((revision IS NULL OR revision = 0) AND (timemodified IS NULL OR timemodified = 0))';\n\n    protected static readonly FILE_IS_UNKNOWN_JS =\n        ({ isexternalfile, revision, timemodified }: CoreFilepoolFileEntry): boolean =>\n            isexternalfile === 1 || ((revision === null || revision === 0) && (timemodified === null || timemodified === 0));\n\n    protected logger: CoreLogger;\n    protected queueState = CoreFilepoolProvider.QUEUE_PAUSED;\n    protected urlAttributes: RegExp[] = [\n        new RegExp('(\\\\?|&)token=([A-Za-z0-9]*)'),\n        new RegExp('(\\\\?|&)forcedownload=[0-1]'),\n        new RegExp('(\\\\?|&)preview=[A-Za-z0-9]+'),\n        new RegExp('(\\\\?|&)offline=[0-1]', 'g'),\n    ];\n\n    // To handle file downloads using the queue.\n    protected queueDeferreds: { [s: string]: { [s: string]: CoreFilepoolPromisedValue } } = {};\n    protected sizeCache: {[fileUrl: string]: number} = {}; // A \"cache\" to store file sizes.\n    // Variables to prevent downloading packages/files twice at the same time.\n    protected packagesPromises: { [s: string]: { [s: string]: Promise<void> } } = {};\n    protected filePromises: { [s: string]: { [s: string]: Promise<string> } } = {};\n    protected filesTables: LazyMap<AsyncInstance<CoreDatabaseTable<CoreFilepoolFileEntry, 'fileId'>>>;\n    protected linksTables:\n        LazyMap<AsyncInstance<CoreDatabaseTable<CoreFilepoolLinksRecord, 'fileId' | 'component' | 'componentId'>>>;\n\n    protected packagesTables: LazyMap<AsyncInstance<CoreDatabaseTable<CoreFilepoolPackageEntry>>>;\n    protected queueTable = asyncInstance<CoreDatabaseTable<CoreFilepoolQueueDBEntry, 'siteId' | 'fileId'>>();\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreFilepoolProvider');\n        this.filesTables = lazyMap(\n            siteId => asyncInstance(\n                () => CoreSites.getSiteTable<CoreFilepoolFileEntry, 'fileId'>(FILES_TABLE_NAME, {\n                    siteId,\n                    config: { cachingStrategy: CoreDatabaseCachingStrategy.Lazy },\n                    primaryKeyColumns: ['fileId'],\n                    onDestroy: () => delete this.filesTables[siteId],\n                }),\n            ),\n        );\n        this.linksTables = lazyMap(\n            siteId => asyncInstance(\n                () => CoreSites.getSiteTable<CoreFilepoolLinksRecord, 'fileId' | 'component' | 'componentId'>(LINKS_TABLE_NAME, {\n                    siteId,\n                    config: { cachingStrategy: CoreDatabaseCachingStrategy.Lazy },\n                    primaryKeyColumns: ['fileId', 'component', 'componentId'],\n                    onDestroy: () => delete this.linksTables[siteId],\n                }),\n            ),\n        );\n        this.packagesTables = lazyMap(\n            siteId => asyncInstance(\n                () => CoreSites.getSiteTable<CoreFilepoolPackageEntry, 'id'>(PACKAGES_TABLE_NAME, {\n                    siteId,\n                    config: { cachingStrategy: CoreDatabaseCachingStrategy.Lazy },\n                    onDestroy: () => delete this.packagesTables[siteId],\n                }),\n            ),\n        );\n    }\n\n    /**\n     * Initialize queue.\n     */\n    initialize(): void {\n        // Start processing the queue once the app is ready.\n        ApplicationInit.whenDone(() => {\n            this.checkQueueProcessing();\n\n            // Start queue when device goes online.\n            CoreNetwork.onConnectShouldBeStable().subscribe(() => {\n                // Execute the callback in the Angular zone, so change detection doesn't stop working.\n                NgZone.run(() => this.checkQueueProcessing());\n            });\n        });\n    }\n\n    /**\n     * Initialize database.\n     */\n    async initializeDatabase(): Promise<void> {\n        try {\n            await CoreApp.createTablesFromSchema(APP_SCHEMA);\n        } catch (e) {\n            // Ignore errors.\n        }\n\n        const queueTable = new CoreDatabaseTableProxy<CoreFilepoolQueueDBEntry, 'siteId' | 'fileId'>(\n            { cachingStrategy: CoreDatabaseCachingStrategy.Lazy },\n            CoreApp.getDB(),\n            QUEUE_TABLE_NAME,\n            ['siteId','fileId'],\n        );\n\n        await queueTable.initialize();\n\n        this.queueTable.setInstance(queueTable);\n    }\n\n    /**\n     * Link a file with a component.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved on success.\n     */\n    protected async addFileLink(siteId: string, fileId: string, component: string, componentId?: string | number): Promise<void> {\n        if (!component) {\n            throw new CoreError('Cannot add link because component is invalid.');\n        }\n\n        await this.linksTables[siteId].insert({\n            fileId,\n            component,\n            componentId: this.fixComponentId(componentId) || '',\n        });\n    }\n\n    /**\n     * Link a file with a component by URL.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file Url.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved on success.\n     * @description\n     * Use this method to create a link between a URL and a component. You usually do not need to call this manually since\n     * downloading a file automatically does this. Note that this method does not check if the file exists in the pool.\n     */\n    async addFileLinkByUrl(siteId: string, fileUrl: string, component: string, componentId?: string | number): Promise<void> {\n        const file = await this.fixPluginfileURL(siteId, fileUrl);\n        const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n\n        await this.addFileLink(siteId, fileId, component, componentId);\n    }\n\n    /**\n     * Link a file with several components.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param links Array of objects containing the component and optionally componentId.\n     * @returns Promise resolved on success.\n     */\n    protected async addFileLinks(siteId: string, fileId: string, links: CoreFilepoolComponentLink[]): Promise<void> {\n        const promises = links.map((link) => this.addFileLink(siteId, fileId, link.component, link.componentId));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Add files to queue using a URL.\n     *\n     * @param siteId The site ID.\n     * @param files Array of files to add.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component (optional).\n     * @returns Resolved on success.\n     */\n    addFilesToQueue(siteId: string, files: CoreWSFile[], component?: string, componentId?: string | number): Promise<void> {\n        return this.downloadOrPrefetchFiles(siteId, files, true, false, component, componentId);\n    }\n\n    /**\n     * Add a file to the pool.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param data Additional information to store about the file (timemodified, url, ...). See FILES_TABLE schema.\n     * @returns Promise resolved on success.\n     */\n    protected async addFileToPool(siteId: string, fileId: string, data: Omit<CoreFilepoolFileEntry, 'fileId'>): Promise<void> {\n        const record = {\n            fileId,\n            ...data,\n        };\n\n        await this.filesTables[siteId].insert(record);\n    }\n\n    /**\n     * Adds a hash to a filename if needed.\n     *\n     * @param url The URL of the file, already treated (decoded, without revision, etc.).\n     * @param filename The filename.\n     * @returns The filename with the hash.\n     */\n    protected addHashToFilename(url: string, filename: string): string {\n        // Check if the file already has a hash. If a file is downloaded and re-uploaded with the app it will have a hash already.\n        const matches = filename.match(/_[a-f0-9]{32}/g);\n\n        if (matches && matches.length) {\n            // There is at least 1 match. Get the last one.\n            const hash = matches[matches.length - 1];\n            const treatedUrl = url.replace(hash, ''); // Remove the hash from the URL.\n\n            // Check that the hash is valid.\n            if ('_' + Md5.hashAsciiStr('url:' + treatedUrl) == hash) {\n                // The data found is a hash of the URL, don't need to add it again.\n                return filename;\n            }\n        }\n\n        return filename + '_' + Md5.hashAsciiStr('url:' + url);\n    }\n\n    /**\n     * Add a file to the queue.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param url The absolute URL to the file.\n     * @param priority The priority this file should get in the queue (range 0-999).\n     * @param revision The revision of the file.\n     * @param timemodified The time this file was modified. Can be used to check file state.\n     * @param filePath Filepath to download the file to. If not defined, download to the filepool folder.\n     * @param onProgress Function to call on progress.\n     * @param options Extra options (isexternalfile, repositorytype).\n     * @param link The link to add for the file.\n     * @returns Promise resolved when the file is downloaded.\n     */\n    protected async addToQueue(\n        siteId: string,\n        fileId: string,\n        url: string,\n        priority: number,\n        revision: number,\n        timemodified: number,\n        filePath?: string,\n        onProgress?: CoreFilepoolOnProgressCallback,\n        options: CoreFilepoolFileOptions = {},\n        link?: CoreFilepoolComponentLink,\n    ): Promise<void> {\n        this.logger.debug(`Adding ${fileId} to the queue`);\n\n        await this.queueTable.insert({\n            siteId,\n            fileId,\n            url,\n            priority,\n            revision,\n            timemodified,\n            path: filePath,\n            isexternalfile: options.isexternalfile ? 1 : 0,\n            repositorytype: options.repositorytype,\n            links: JSON.stringify(link ? [link] : []),\n            added: Date.now(),\n        });\n\n        // Check if the queue is running.\n        this.checkQueueProcessing();\n        this.notifyFileDownloading(siteId, fileId, link ? [link] : []);\n\n        return this.getQueuePromise(siteId, fileId, true, onProgress);\n    }\n\n    /**\n     * Add an entry to queue using a URL.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The absolute URL to the file.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component (optional).\n     * @param timemodified The time this file was modified. Can be used to check file state.\n     * @param filePath Filepath to download the file to. If not defined, download to the filepool folder.\n     * @param onProgress Function to call on progress.\n     * @param priority The priority this file should get in the queue (range 0-999).\n     * @param options Extra options (isexternalfile, repositorytype).\n     * @param revision File revision. If not defined, it will be calculated using the URL.\n     * @param alreadyFixed Whether the URL has already been fixed.\n     * @returns Resolved on success.\n     */\n    async addToQueueByUrl(\n        siteId: string,\n        fileUrl: string,\n        component?: string,\n        componentId?: string | number,\n        timemodified: number = 0,\n        filePath?: string,\n        onProgress?: CoreFilepoolOnProgressCallback,\n        priority: number = 0,\n        options: CoreFilepoolFileOptions = {},\n        revision?: number,\n        alreadyFixed?: boolean,\n    ): Promise<void> {\n        if (!CoreFile.isAvailable()) {\n            throw new CoreError('File system cannot be used.');\n        }\n\n        const site = await CoreSites.getSite(siteId);\n        if (!site.canDownloadFiles()) {\n            throw new CoreError(Translate.instant('core.cannotdownloadfiles'));\n        }\n\n        if (!alreadyFixed) {\n            // Fix the URL and use the fixed data.\n            const file = await this.fixPluginfileURL(siteId, fileUrl, timemodified);\n\n            fileUrl = CoreFileHelper.getFileUrl(file);\n            timemodified = file.timemodified ?? timemodified;\n        }\n\n        revision = revision ?? this.getRevisionFromUrl(fileUrl);\n        const fileId = this.getFileIdByUrl(fileUrl);\n\n        const primaryKey = { siteId, fileId };\n\n        // Set up the component.\n        const link = this.createComponentLink(component, componentId);\n\n        // Retrieve the queue deferred now if it exists.\n        // This is to prevent errors if file is removed from queue while we're checking if the file is in queue.\n        const queueDeferred = this.getQueueDeferred(siteId, fileId, false, onProgress);\n        let entry: CoreFilepoolQueueEntry;\n\n        try {\n            entry = await this.hasFileInQueue(siteId, fileId);\n        } catch (error) {\n            // Unsure why we could not get the record, let's add to the queue anyway.\n            return this.addToQueue(siteId, fileId, fileUrl, priority, revision, timemodified, filePath, onProgress, options, link);\n        }\n\n        const newData: Partial<CoreFilepoolQueueDBEntry> = {};\n        let foundLink = false;\n\n        // We already have the file in queue, we update the priority and links.\n        if (!entry.priority || entry.priority < priority) {\n            newData.priority = priority;\n        }\n        if (revision && entry.revision !== revision) {\n            newData.revision = revision;\n        }\n        if (timemodified && entry.timemodified !== timemodified) {\n            newData.timemodified = timemodified;\n        }\n        if (filePath && entry.path !== filePath) {\n            newData.path = filePath;\n        }\n        if (entry.isexternalfile !== options.isexternalfile && (entry.isexternalfile || options.isexternalfile)) {\n            newData.isexternalfile = options.isexternalfile;\n        }\n        if (entry.repositorytype !== options.repositorytype && (entry.repositorytype || options.repositorytype)) {\n            newData.repositorytype = options.repositorytype;\n        }\n\n        if (link) {\n            // We need to add the new link if it does not exist yet.\n            if (entry.linksUnserialized && entry.linksUnserialized.length) {\n                foundLink = entry.linksUnserialized.some((fileLink) =>\n                    fileLink.component == link.component && fileLink.componentId == link.componentId);\n            }\n\n            if (!foundLink) {\n                const links = entry.linksUnserialized || [];\n                links.push(link);\n                newData.links = JSON.stringify(links);\n            }\n        }\n\n        if (Object.keys(newData).length) {\n            // Update only when required.\n            this.logger.debug(`Updating file ${fileId} which is already in queue`);\n\n            return this.queueTable.update(newData, primaryKey).then(() => this.getQueuePromise(siteId, fileId, true, onProgress));\n        }\n\n        this.logger.debug(`File ${fileId} already in queue and does not require update`);\n        if (queueDeferred) {\n            // If we were able to retrieve the queue deferred before, we use that one.\n            return queueDeferred;\n        } else {\n            // Create a new deferred and return its promise.\n            return this.getQueuePromise(siteId, fileId, true, onProgress);\n        }\n    }\n\n    /**\n     * Adds a file to the queue if the size is allowed to be downloaded.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The absolute URL to the file, already fixed.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param timemodified The time this file was modified.\n     * @param checkSize True if we shouldn't download files if their size is big, false otherwise.\n     * @param downloadUnknown True to download file in WiFi if their size is unknown, false otherwise.\n     *                        Ignored if checkSize=false.\n     * @param options Extra options (isexternalfile, repositorytype).\n     * @param revision File revision. If not defined, it will be calculated using the URL.\n     * @returns Promise resolved when the file is downloaded.\n     */\n    protected async addToQueueIfNeeded(\n        siteId: string,\n        fileUrl: string,\n        component?: string,\n        componentId?: string | number,\n        timemodified: number = 0,\n        checkSize: boolean = true,\n        downloadUnknown?: boolean,\n        options: CoreFilepoolFileOptions = {},\n        revision?: number,\n    ): Promise<void> {\n        if (!checkSize) {\n            // No need to check size, just add it to the queue.\n            await this.addToQueueByUrl(\n                siteId,\n                fileUrl,\n                component,\n                componentId,\n                timemodified,\n                undefined,\n                undefined,\n                0,\n                options,\n                revision,\n                true,\n            );\n        }\n\n        let size: number;\n\n        if (this.sizeCache[fileUrl] !== undefined) {\n            size = this.sizeCache[fileUrl];\n        } else {\n            if (!CoreNetwork.isOnline()) {\n                // Cannot check size in offline, stop.\n                throw new CoreError(Translate.instant('core.cannotconnect'));\n            }\n\n            size = await CoreWS.getRemoteFileSize(fileUrl);\n        }\n\n        // Calculate the size of the file.\n        const isWifi = CoreNetwork.isWifi();\n        const sizeUnknown = size <= 0;\n\n        if (!sizeUnknown) {\n            // Store the size in the cache.\n            this.sizeCache[fileUrl] = size;\n        }\n\n        // Check if the file should be downloaded.\n        if ((sizeUnknown && downloadUnknown && isWifi) || (!sizeUnknown && this.shouldDownload(size))) {\n            await this.addToQueueByUrl(\n                siteId,\n                fileUrl,\n                component,\n                componentId,\n                timemodified,\n                undefined,\n                undefined,\n                0,\n                options,\n                revision,\n                true,\n            );\n        }\n    }\n\n    /**\n     * Check the queue processing.\n     *\n     * @description\n     * In mose cases, this will enable the queue processing if it was paused.\n     * Though, this will disable the queue if we are missing network or if the file system\n     * is not accessible. Also, this will have no effect if the queue is already running.\n     */\n    protected checkQueueProcessing(): void {\n        if (!CoreFile.isAvailable() || !CoreNetwork.isOnline()) {\n            this.queueState = CoreFilepoolProvider.QUEUE_PAUSED;\n\n            return;\n        } else if (this.queueState === CoreFilepoolProvider.QUEUE_RUNNING) {\n            return;\n        }\n\n        this.queueState = CoreFilepoolProvider.QUEUE_RUNNING;\n        this.processQueue();\n    }\n\n    /**\n     * Clear all packages status in a site.\n     *\n     * @param siteId Site ID.\n     * @returns Promise resolved when all status are cleared.\n     */\n    async clearAllPackagesStatus(siteId: string): Promise<void> {\n        this.logger.debug('Clear all packages status for site ' + siteId);\n\n        // Get all the packages to be able to \"notify\" the change in the status.\n        const entries = await this.packagesTables[siteId].getMany();\n        // Delete all the entries.\n        await this.packagesTables[siteId].delete();\n\n        entries.forEach((entry) => {\n            if (!entry.component) {\n                return;\n            }\n\n            // Trigger module status changed, setting it as not downloaded.\n            this.triggerPackageStatusChanged(siteId, CoreConstants.NOT_DOWNLOADED, entry.component, entry.componentId);\n        });\n    }\n\n    /**\n     * Clears the filepool. Use it only when all the files from a site are deleted.\n     *\n     * @param siteId ID of the site to clear.\n     * @returns Promise resolved when the filepool is cleared.\n     */\n    async clearFilepool(siteId: string): Promise<void> {\n        // Read the data first to be able to notify the deletions.\n        const filesEntries = await this.filesTables[siteId].getMany();\n        const filesLinks = await this.linksTables[siteId].getMany();\n\n        await Promise.all([\n            this.filesTables[siteId].delete(),\n            this.linksTables[siteId].delete(),\n        ]);\n\n        // Notify now.\n        const filesLinksMap = CoreUtils.arrayToObjectMultiple(filesLinks, 'fileId');\n\n        filesEntries.forEach(entry => this.notifyFileDeleted(siteId, entry.fileId, filesLinksMap[entry.fileId] || []));\n    }\n\n    /**\n     * Returns whether a component has files in the pool.\n     *\n     * @param siteId The site ID.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Resolved means yes, rejected means no.\n     */\n    async componentHasFiles(siteId: string, component: string, componentId?: string | number): Promise<void> {\n        const conditions = {\n            component,\n            componentId: this.fixComponentId(componentId),\n        };\n\n        const hasAnyLinks = await this.linksTables[siteId].hasAny(conditions);\n\n        if (!hasAnyLinks) {\n            throw new CoreError('Component doesn\\'t have files');\n        }\n    }\n\n    /**\n     * Prepare a component link.\n     *\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Link, null if nothing to link.\n     */\n    protected createComponentLink(component?: string, componentId?: string | number): CoreFilepoolComponentLink | undefined {\n        if (component !== undefined && component != null) {\n            return { component, componentId: this.fixComponentId(componentId) };\n        }\n    }\n\n    /**\n     * Prepare list of links from component and componentId.\n     *\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Links.\n     */\n    protected createComponentLinks(component?: string, componentId?: string | number): CoreFilepoolComponentLink[] {\n        const link = this.createComponentLink(component, componentId);\n\n        return link ? [link] : [];\n    }\n\n    /**\n     * Given the current status of a list of packages and the status of one of the packages,\n     * determine the new status for the list of packages. The status of a list of packages is:\n     *     - CoreConstants.NOT_DOWNLOADABLE if there are no downloadable packages.\n     *     - CoreConstants.NOT_DOWNLOADED if at least 1 package has status CoreConstants.NOT_DOWNLOADED.\n     *     - CoreConstants.DOWNLOADED if ALL the downloadable packages have status CoreConstants.DOWNLOADED.\n     *     - CoreConstants.DOWNLOADING if ALL the downloadable packages have status CoreConstants.DOWNLOADING or\n     *                                     CoreConstants.DOWNLOADED, with at least 1 package with CoreConstants.DOWNLOADING.\n     *     - CoreConstants.OUTDATED if ALL the downloadable packages have status CoreConstants.OUTDATED or CoreConstants.DOWNLOADED\n     *                                     or CoreConstants.DOWNLOADING, with at least 1 package with CoreConstants.OUTDATED.\n     *\n     * @param current Current status of the list of packages.\n     * @param packageStatus Status of one of the packages.\n     * @returns New status for the list of packages;\n     */\n    determinePackagesStatus(current: string, packageStatus: string): string {\n        if (!current) {\n            current = CoreConstants.NOT_DOWNLOADABLE;\n        }\n\n        if (packageStatus === CoreConstants.NOT_DOWNLOADED) {\n            // If 1 package is not downloaded the status of the whole list will always be not downloaded.\n            return CoreConstants.NOT_DOWNLOADED;\n        } else if (packageStatus === CoreConstants.DOWNLOADED && current === CoreConstants.NOT_DOWNLOADABLE) {\n            // If all packages are downloaded or not downloadable with at least 1 downloaded, status will be downloaded.\n            return CoreConstants.DOWNLOADED;\n        } else if (packageStatus === CoreConstants.DOWNLOADING &&\n            (current === CoreConstants.NOT_DOWNLOADABLE || current === CoreConstants.DOWNLOADED)) {\n            // If all packages are downloading/downloaded/notdownloadable with at least 1 downloading, status will be downloading.\n            return CoreConstants.DOWNLOADING;\n        } else if (packageStatus === CoreConstants.OUTDATED && current !== CoreConstants.NOT_DOWNLOADED) {\n            // If there are no packages notdownloaded and there is at least 1 outdated, status will be outdated.\n            return CoreConstants.OUTDATED;\n        }\n\n        // Status remains the same.\n        return current;\n    }\n\n    /**\n     * Downloads a URL and update or add it to the pool.\n     *\n     * This uses the file system, you should always make sure that it is accessible before calling this method.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file URL.\n     * @param options Extra options (revision, timemodified, isexternalfile, repositorytype).\n     * @param filePath Filepath to download the file to. If defined, no extension will be added.\n     * @param onProgress Function to call on progress.\n     * @param poolFileObject When set, the object will be updated, a new entry will not be created.\n     * @returns Resolved with internal URL on success, rejected otherwise.\n     */\n    protected async downloadForPoolByUrl(\n        siteId: string,\n        fileUrl: string,\n        options: CoreFilepoolFileOptions = {},\n        filePath?: string,\n        onProgress?: CoreFilepoolOnProgressCallback,\n        poolFileObject?: CoreFilepoolFileEntry,\n    ): Promise<string> {\n        const fileId = this.getFileIdByUrl(fileUrl);\n\n        // Extract the anchor from the URL (if any).\n        const anchor = CoreUrl.getUrlAnchor(fileUrl);\n        if (anchor) {\n            fileUrl = fileUrl.replace(anchor, '');\n        }\n\n        const extension = CoreMimetypeUtils.guessExtensionFromUrl(fileUrl);\n        const addExtension = filePath === undefined;\n        const path = filePath || (await this.getFilePath(siteId, fileId, extension));\n\n        if (poolFileObject && poolFileObject.fileId !== fileId) {\n            this.logger.error('Invalid object to update passed');\n\n            throw new CoreError('Invalid object to update passed.');\n        }\n\n        const downloadId = this.getFileDownloadId(fileUrl, path);\n\n        if (this.filePromises[siteId] && this.filePromises[siteId][downloadId] !== undefined) {\n            // There's already a download ongoing for this file in this location, return the promise.\n            return this.filePromises[siteId][downloadId];\n        } else if (!this.filePromises[siteId]) {\n            this.filePromises[siteId] = {};\n        }\n\n        this.filePromises[siteId][downloadId] = CoreSites.getSite(siteId).then(async (site) => {\n            if (!site.canDownloadFiles()) {\n                throw new CoreError(Translate.instant('core.cannotdownloadfiles'));\n            }\n\n            const entry = await CoreWS.downloadFile(fileUrl, path, addExtension, onProgress);\n            const fileEntry = entry;\n            await CorePluginFileDelegate.treatDownloadedFile(fileUrl, fileEntry, siteId, onProgress);\n\n            await this.addFileToPool(siteId, fileId, {\n                downloadTime: Date.now(),\n                stale: 0,\n                url: fileUrl,\n                revision: options.revision,\n                timemodified: options.timemodified,\n                isexternalfile: options.isexternalfile ? 1 : 0,\n                repositorytype: options.repositorytype,\n                path: fileEntry.path,\n                extension: fileEntry.extension,\n            });\n\n            CoreAnalytics.logEvent({\n                type: CoreAnalyticsEventType.DOWNLOAD_FILE,\n                fileUrl: CoreUrlUtils.unfixPluginfileURL(fileUrl, site.getURL()),\n            });\n\n            // Add the anchor again to the local URL.\n            return fileEntry.toURL() + (anchor || '');\n        }).finally(() => {\n            // Download finished, delete the promise.\n            delete this.filePromises[siteId][downloadId];\n        });\n\n        return this.filePromises[siteId][downloadId];\n    }\n\n    /**\n     * Download or prefetch several files into the filepool folder.\n     *\n     * @param siteId The site ID.\n     * @param files Array of files to download.\n     * @param prefetch True if should prefetch the contents (queue), false if they should be downloaded right now.\n     * @param ignoreStale True if 'stale' should be ignored. Only if prefetch=false.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param dirPath Name of the directory where to store the files (inside filepool dir). If not defined, store\n     *                the files directly inside the filepool folder.\n     * @returns Resolved on success.\n     */\n    downloadOrPrefetchFiles(\n        siteId: string,\n        files: CoreWSFile[],\n        prefetch: boolean,\n        ignoreStale?: boolean,\n        component?: string,\n        componentId?: string | number,\n        dirPath?: string,\n    ): Promise<void> {\n        const promises: Promise<unknown>[] = [];\n\n        // Download files.\n        files.forEach((file) => {\n            const url = CoreFileHelper.getFileUrl(file);\n            const timemodified = file.timemodified;\n            const options = {\n                isexternalfile: 'isexternalfile' in file ? file.isexternalfile : undefined,\n                repositorytype: 'repositorytype' in file ? file.repositorytype : undefined,\n            };\n            let path: string | undefined;\n\n            if (dirPath) {\n                // Calculate the path to the file.\n                path = file.filename || '';\n                if (file.filepath && file.filepath !== '/') {\n                    path = file.filepath.substring(1) + path;\n                }\n                path = CorePath.concatenatePaths(dirPath, path);\n            }\n\n            if (prefetch) {\n                promises.push(this.addToQueueByUrl(siteId, url, component, componentId, timemodified, path, undefined, 0, options));\n            } else {\n                promises.push(this.downloadUrl(\n                    siteId,\n                    url,\n                    ignoreStale,\n                    component,\n                    componentId,\n                    timemodified,\n                    undefined,\n                    path,\n                    options,\n                ));\n            }\n        });\n\n        return CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Downloads or prefetches a list of files as a \"package\".\n     *\n     * @param siteId The site ID.\n     * @param fileList List of files to download.\n     * @param prefetch True if should prefetch the contents (queue), false if they should be downloaded right now.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param extra Extra data to store for the package.\n     * @param dirPath Name of the directory where to store the files (inside filepool dir). If not defined, store\n     *                the files directly inside the filepool folder.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when the package is downloaded.\n     */\n    downloadOrPrefetchPackage(\n        siteId: string,\n        fileList: CoreWSFile[],\n        prefetch: boolean,\n        component: string,\n        componentId?: string | number,\n        extra?: string,\n        dirPath?: string,\n        onProgress?: CoreFilepoolOnProgressCallback,\n    ): Promise<void> {\n        const packageId = this.getPackageId(component, componentId);\n\n        if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId] !== undefined) {\n            // There's already a download ongoing for this package, return the promise.\n            return this.packagesPromises[siteId][packageId];\n        } else if (!this.packagesPromises[siteId]) {\n            this.packagesPromises[siteId] = {};\n        }\n\n        // Set package as downloading.\n        const promise = this.storePackageStatus(siteId, CoreConstants.DOWNLOADING, component, componentId).then(async () => {\n            const promises: Promise<string | void>[] = [];\n            let packageLoaded = 0;\n\n            fileList.forEach((file) => {\n                const fileUrl = CoreFileHelper.getFileUrl(file);\n                const options = {\n                    isexternalfile: 'isexternalfile' in file ? file.isexternalfile : undefined,\n                    repositorytype: 'repositorytype' in file ? file.repositorytype : undefined,\n                };\n                let path: string | undefined;\n                let promise: Promise<string | void>;\n                let fileLoaded = 0;\n                let onFileProgress: ((progress: ProgressEvent) => void) | undefined;\n\n                if (onProgress) {\n                    // There's a onProgress event, create a function to receive file download progress events.\n                    onFileProgress = (progress: ProgressEvent): void => {\n                        if (progress && progress.loaded) {\n                            // Add the new size loaded to the package loaded.\n                            packageLoaded = packageLoaded + (progress.loaded - fileLoaded);\n                            fileLoaded = progress.loaded;\n                            onProgress({\n                                packageDownload: true,\n                                loaded: packageLoaded,\n                                fileProgress: progress,\n                            });\n                        }\n                    };\n                }\n\n                if (dirPath) {\n                    // Calculate the path to the file.\n                    path = file.filename || '';\n                    if (file.filepath && file.filepath !== '/') {\n                        path = file.filepath.substring(1) + path;\n                    }\n                    path = CorePath.concatenatePaths(dirPath, path);\n                }\n\n                if (prefetch) {\n                    promise = this.addToQueueByUrl(\n                        siteId,\n                        fileUrl,\n                        component,\n                        componentId,\n                        file.timemodified,\n                        path,\n                        undefined,\n                        0,\n                        options,\n                    );\n                } else {\n                    promise = this.downloadUrl(\n                        siteId,\n                        fileUrl,\n                        false,\n                        component,\n                        componentId,\n                        file.timemodified,\n                        onFileProgress,\n                        path,\n                        options,\n                    );\n                }\n\n                // Using undefined for success & fail will pass the success/failure to the parent promise.\n                promises.push(promise);\n            });\n\n            try {\n                await Promise.all(promises);\n                // Success prefetching, store package as downloaded.\n                await this.storePackageStatus(siteId, CoreConstants.DOWNLOADED, component, componentId, extra);\n\n                return;\n            } catch (error) {\n                // Error downloading, go back to previous status and reject the promise.\n                await this.setPackagePreviousStatus(siteId, component, componentId);\n\n                throw error;\n            }\n        }).finally(() => {\n            // Download finished, delete the promise.\n            delete this.packagesPromises[siteId][packageId];\n        });\n\n        this.packagesPromises[siteId][packageId] = promise;\n\n        return promise;\n    }\n\n    /**\n     * Downloads a list of files.\n     *\n     * @param siteId The site ID.\n     * @param fileList List of files to download.\n     * @param component The component to link the file to.\n     * @param componentId An ID to identify the download.\n     * @param extra Extra data to store for the package.\n     * @param dirPath Name of the directory where to store the files (inside filepool dir). If not defined, store\n     *                the files directly inside the filepool folder.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when all files are downloaded.\n     */\n    downloadPackage(\n        siteId: string,\n        fileList: CoreWSFile[],\n        component: string,\n        componentId?: string | number,\n        extra?: string,\n        dirPath?: string,\n        onProgress?: CoreFilepoolOnProgressCallback,\n    ): Promise<void> {\n        return this.downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, extra, dirPath, onProgress);\n    }\n\n    /**\n     * Downloads a file on the spot.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file URL.\n     * @param ignoreStale Whether 'stale' should be ignored.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param timemodified The time this file was modified. Can be used to check file state.\n     * @param onProgress On progress callback function.\n     * @param filePath Filepath to download the file to. If not defined, download to the filepool folder.\n     * @param options Extra options (isexternalfile, repositorytype).\n     * @param revision File revision. If not defined, it will be calculated using the URL.\n     * @returns Resolved with internal URL on success, rejected otherwise.\n     * @description\n     * Downloads a file on the spot.\n     *\n     * This will also take care of adding the file to the pool if it's missing. However, please note that this will\n     * not force a file to be re-downloaded if it is already part of the pool. You should mark a file as stale using\n     * invalidateFileByUrl to trigger a download.\n     */\n    async downloadUrl(\n        siteId: string,\n        fileUrl: string,\n        ignoreStale?: boolean,\n        component?: string,\n        componentId?: string | number,\n        timemodified: number = 0,\n        onProgress?: CoreFilepoolOnProgressCallback,\n        filePath?: string,\n        options: CoreFilepoolFileOptions = {},\n        revision?: number,\n    ): Promise<string> {\n        let alreadyDownloaded = true;\n\n        if (!CoreFile.isAvailable()) {\n            throw new CoreError('File system cannot be used.');\n        }\n\n        const file = await this.fixPluginfileURL(siteId, fileUrl, timemodified);\n        fileUrl = CoreFileHelper.getFileUrl(file);\n\n        options = Object.assign({}, options); // Create a copy to prevent modifying the original object.\n        options.timemodified = file.timemodified ?? timemodified;\n        options.revision = revision ?? this.getRevisionFromUrl(fileUrl);\n        const fileId = this.getFileIdByUrl(fileUrl);\n\n        const links = this.createComponentLinks(component, componentId);\n\n        const finishSuccessfulDownload = (url: string): string => {\n            if (component !== undefined) {\n                CoreUtils.ignoreErrors(this.addFileLink(siteId, fileId, component, componentId));\n            }\n\n            if (!alreadyDownloaded) {\n                this.notifyFileDownloaded(siteId, fileId, links);\n            }\n\n            return url;\n        };\n\n        try {\n            const fileObject = await this.hasFileInPool(siteId, fileId);\n            let url: string;\n\n            if (!fileObject ||\n                this.isFileOutdated(fileObject, options.revision, options.timemodified) &&\n                CoreNetwork.isOnline() &&\n                !ignoreStale\n            ) {\n                throw new CoreError('Needs to be downloaded');\n            }\n\n            // File downloaded and not outdated, return the file from disk.\n            if (filePath) {\n                url = await this.getInternalUrlByPath(filePath);\n            } else {\n                url = await this.getInternalUrlById(siteId, fileId);\n            }\n\n            // Add the anchor to the local URL if any.\n            const anchor = CoreUrl.getUrlAnchor(fileUrl);\n\n            return finishSuccessfulDownload(url + (anchor || ''));\n        } catch (error) {\n            // The file is not downloaded or it's outdated.\n            this.notifyFileDownloading(siteId, fileId, links);\n            alreadyDownloaded = false;\n\n            try {\n                const url = await this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress);\n\n                return finishSuccessfulDownload(url);\n            } catch (error) {\n                this.notifyFileDownloadError(siteId, fileId, links);\n\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Extract the downloadable URLs from an HTML code.\n     *\n     * @param html HTML code.\n     * @returns List of file urls.\n     */\n    extractDownloadableFilesFromHtml(html: string): string[] {\n        let urls: string[] = [];\n\n        const element = CoreDomUtils.convertToElement(html);\n        const elements: AnchorOrMediaElement[] = Array.from(element.querySelectorAll('a, img, audio, video, source, track'));\n\n        for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            const url = 'href' in element ? element.href : element.src;\n\n            if (url && CoreUrlUtils.isDownloadableUrl(url) && urls.indexOf(url) == -1) {\n                urls.push(url);\n            }\n\n            // Treat video poster.\n            if (element.tagName == 'VIDEO' && element.getAttribute('poster')) {\n                const poster = element.getAttribute('poster');\n                if (poster && CoreUrlUtils.isDownloadableUrl(poster) && urls.indexOf(poster) == -1) {\n                    urls.push(poster);\n                }\n            }\n        }\n\n        // Now get other files from plugin file handlers.\n        urls = urls.concat(CorePluginFileDelegate.getDownloadableFilesFromHTML(element));\n\n        return urls;\n    }\n\n    /**\n     * Extract the downloadable URLs from an HTML code and returns them in fake file objects.\n     *\n     * @param html HTML code.\n     * @returns List of fake file objects with file URLs.\n     */\n    extractDownloadableFilesFromHtmlAsFakeFileObjects(html: string): CoreWSExternalFile[] {\n        const urls = this.extractDownloadableFilesFromHtml(html);\n\n        // Convert them to fake file objects.\n        return urls.map((url) => ({\n            fileurl: url,\n        }));\n    }\n\n    /**\n     * Fill Missing Extension In the File Object if needed.\n     * This is to migrate from old versions.\n     *\n     * @param entry File object to be migrated.\n     * @param siteId SiteID to get migrated.\n     * @returns Promise resolved when done.\n     */\n    protected async fillExtensionInFile(entry: CoreFilepoolFileEntry, siteId: string): Promise<void> {\n        if (entry.extension !== undefined) {\n            // Already filled.\n            return;\n        }\n\n        const extension = CoreMimetypeUtils.getFileExtension(entry.path);\n        if (!extension) {\n            // Files does not have extension. Invalidate file (stale = true).\n            // Minor problem: file will remain in the filesystem once downloaded again.\n            this.logger.debug('Staled file with no extension ' + entry.fileId);\n\n            await this.filesTables[siteId].update({ stale: 1 }, { fileId: entry.fileId });\n\n            return;\n        }\n\n        // File has extension. Save extension, and add extension to path.\n        const fileId = entry.fileId;\n        entry.fileId = CoreMimetypeUtils.removeExtension(fileId);\n        entry.extension = extension;\n\n        await this.filesTables[siteId].update(entry, { fileId });\n        if (entry.fileId == fileId) {\n            // File ID hasn't changed, we're done.\n            this.logger.debug('Removed extesion ' + extension + ' from file ' + entry.fileId);\n\n            return;\n        }\n\n        // Now update the links.\n        await this.linksTables[siteId].update({ fileId: entry.fileId }, { fileId });\n    }\n\n    /**\n     * Fix a component ID to always be a Number if possible.\n     *\n     * @param componentId The component ID.\n     * @returns The normalised component ID. -1 when undefined was passed.\n     */\n    protected fixComponentId(componentId?: string | number): string | number {\n        if (typeof componentId == 'number') {\n            return componentId;\n        }\n\n        if (componentId === undefined || componentId === null) {\n            return -1;\n        }\n\n        // Try to convert it to a number.\n        const id = parseInt(componentId, 10);\n        if (isNaN(id)) {\n            // Not a number.\n            return componentId;\n        }\n\n        return id;\n    }\n\n    /**\n     * Check whether the file can be downloaded, add the wstoken url and points to the correct script.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file URL.\n     * @param timemodified The timemodified of the file.\n     * @returns Promise resolved with the file data to use.\n     */\n    protected async fixPluginfileURL(siteId: string, fileUrl: string, timemodified: number = 0): Promise<CoreWSFile> {\n        const file = await CorePluginFileDelegate.getDownloadableFile({ fileurl: fileUrl, timemodified });\n        const site = await CoreSites.getSite(siteId);\n\n        if ('fileurl' in file) {\n            file.fileurl = await site.checkAndFixPluginfileURL(file.fileurl);\n        } else {\n            file.url = await site.checkAndFixPluginfileURL(file.url);\n        }\n\n        return file;\n    }\n\n    /**\n     * Convenience function to get component files.\n     *\n     * @param siteId Site Id.\n     * @param component The component to get.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved with the files.\n     */\n    protected async getComponentFiles(\n        siteId: string | undefined,\n        component: string,\n        componentId?: string | number,\n    ): Promise<CoreFilepoolLinksRecord[]> {\n        siteId = siteId ?? CoreSites.getCurrentSiteId();\n        const conditions = {\n            component,\n            componentId: this.fixComponentId(componentId),\n        };\n\n        const items = await this.linksTables[siteId].getMany(conditions);\n\n        items.forEach((item) => {\n            item.componentId = this.fixComponentId(item.componentId);\n        });\n\n        return items;\n    }\n\n    /**\n     * Returns the local URL of a directory.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file URL.\n     * @returns Resolved with the URL. Rejected otherwise.\n     */\n    async getDirectoryUrlByUrl(siteId: string, fileUrl: string): Promise<string> {\n        if (!CoreFile.isAvailable()) {\n            throw new CoreError('File system cannot be used.');\n        }\n\n        const file = await this.fixPluginfileURL(siteId, fileUrl);\n        const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n        const filePath = await this.getFilePath(siteId, fileId, '');\n        const dirEntry = await CoreFile.getDir(filePath);\n\n        return dirEntry.toURL();\n    }\n\n    /**\n     * Get the ID of a file download. Used to keep track of filePromises.\n     *\n     * @param fileUrl The file URL.\n     * @param filePath The file destination path.\n     * @returns File download ID.\n     */\n    protected getFileDownloadId(fileUrl: string, filePath: string): string {\n        return <string> Md5.hashAsciiStr(fileUrl + '###' + filePath);\n    }\n\n    /**\n     * Get the name of the event used to notify download events.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @returns Event name.\n     */\n    protected getFileEventName(siteId: string, fileId: string): string {\n        return 'CoreFilepoolFile:' + siteId + ':' + fileId;\n    }\n\n    /**\n     * Get the name of the event used to notify download events.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The absolute URL to the file.\n     * @returns Promise resolved with event name.\n     */\n    getFileEventNameByUrl(siteId: string, fileUrl: string): Promise<string> {\n        return this.fixPluginfileURL(siteId, fileUrl).then((file) => {\n            const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n\n            return this.getFileEventName(siteId, fileId);\n        });\n    }\n\n    /**\n     * Creates a unique ID based on a URL.\n     *\n     * This has a minimal handling of pluginfiles in order to generate a clean file ID which will not change if\n     * pointing to the same pluginfile URL even if the token or extra attributes have changed.\n     *\n     * @param fileUrl The absolute URL to the file.\n     * @returns The file ID.\n     */\n    protected getFileIdByUrl(fileUrl: string): string {\n        let url = fileUrl;\n\n        // If site supports it, since 3.8 we use tokenpluginfile instead of pluginfile.\n        // For compatibility with files already downloaded, we need to use pluginfile to calculate the file ID.\n        url = url.replace(/\\/tokenpluginfile\\.php\\/[^/]+\\//, '/webservice/pluginfile.php/');\n\n        // Remove the revision number from the URL so updates on the file aren't detected as a different file.\n        url = this.removeRevisionFromUrl(url);\n\n        // Decode URL.\n        url = CoreTextUtils.decodeHTML(CoreTextUtils.decodeURIComponent(url));\n\n        if (url.indexOf('/webservice/pluginfile') !== -1) {\n            // Remove attributes that do not matter.\n            this.urlAttributes.forEach((regex) => {\n                url = url.replace(regex, '');\n            });\n        }\n\n        // Remove the anchor.\n        url = CoreUrl.removeUrlAnchor(url);\n\n        // Try to guess the filename the target file should have.\n        // We want to keep the original file name so people can easily identify the files after the download.\n        const filename = this.guessFilenameFromUrl(url);\n\n        return this.addHashToFilename(url, filename);\n    }\n\n    /**\n     * Get the links of a file.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @returns Promise resolved with the links.\n     */\n    protected async getFileLinks(siteId: string, fileId: string): Promise<CoreFilepoolLinksRecord[]> {\n        const items = await this.linksTables[siteId].getMany({ fileId });\n\n        items.forEach((item) => {\n            item.componentId = this.fixComponentId(item.componentId);\n        });\n\n        return items;\n    }\n\n    /**\n     * Get the path to a file. This does not check if the file exists or not.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param extension Previously calculated extension. Empty to not add any. Undefined to calculate it.\n     * @returns The path to the file relative to storage root.\n     */\n    protected async getFilePath(siteId: string, fileId: string, extension?: string): Promise<string> {\n        let path = this.getFilepoolFolderPath(siteId) + '/' + fileId;\n\n        if (extension === undefined) {\n            // We need the extension to be able to open files properly.\n            try {\n                const entry = await this.hasFileInPool(siteId, fileId);\n\n                if (entry.extension) {\n                    path += '.' + entry.extension;\n                }\n            } catch (error) {\n                // If file not found, use the path without extension.\n            }\n        } else if (extension) {\n            path += '.' + extension;\n        }\n\n        return path;\n    }\n\n    /**\n     * Get the path to a file from its URL. This does not check if the file exists or not.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file URL.\n     * @returns Promise resolved with the path to the file relative to storage root.\n     */\n    async getFilePathByUrl(siteId: string, fileUrl: string): Promise<string> {\n        const file = await this.fixPluginfileURL(siteId, fileUrl);\n        const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n\n        return this.getFilePath(siteId, fileId);\n    }\n\n    /**\n     * Get the url of a file form its path.\n     *\n     * @param siteId The site ID.\n     * @param path File path.\n     * @returns File url.\n     */\n    async getFileUrlByPath(siteId: string, path: string): Promise<string> {\n        const record = await this.filesTables[siteId].getOne({ path });\n\n        return record.url;\n    }\n\n    /**\n     * Get site Filepool Folder Path\n     *\n     * @param siteId The site ID.\n     * @returns The root path to the filepool of the site.\n     */\n    getFilepoolFolderPath(siteId: string): string {\n        return CoreFile.getSiteFolder(siteId) + '/' + CoreFilepoolProvider.FOLDER;\n    }\n\n    /**\n     * Get all the matching files from a component. Returns objects containing properties like path, extension and url.\n     *\n     * @param siteId The site ID.\n     * @param component The component to get.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved with the files on success.\n     */\n    async getFilesByComponent(siteId: string, component: string, componentId?: string | number): Promise<CoreFilepoolFileEntry[]> {\n        const items = await this.getComponentFiles(siteId, component, componentId);\n        const files: CoreFilepoolFileEntry[] = [];\n\n        await Promise.all(items.map(async (item) => {\n            try {\n                const fileEntry = await this.filesTables[siteId].getOneByPrimaryKey({ fileId: item.fileId });\n\n                if (!fileEntry) {\n                    return;\n                }\n\n                files.push(fileEntry);\n            } catch (error) {\n                // File not found, ignore error.\n            }\n        }));\n\n        return files;\n    }\n\n    /**\n     * Get the size of all the files from a component.\n     *\n     * @param siteId The site ID.\n     * @param component The component to get.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved with the size on success.\n     */\n    async getFilesSizeByComponent(siteId: string, component: string, componentId?: string | number): Promise<number> {\n        const files = await this.getFilesByComponent(siteId, component, componentId);\n\n        let size = 0;\n\n        await Promise.all(files.map(async (file) => {\n            try {\n                const fileSize = await CoreFile.getFileSize(file.path);\n\n                size += fileSize;\n            } catch {\n                // Ignore failures, maybe some file was deleted.\n            }\n        }));\n\n        return size;\n    }\n\n    /**\n     * Returns the file state: mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded or mmCoreOutdated.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl File URL.\n     * @param timemodified The time this file was modified.\n     * @param filePath Filepath to download the file to. If defined, no extension will be added.\n     * @param revision File revision. If not defined, it will be calculated using the URL.\n     * @returns Promise resolved with the file state.\n     */\n    async getFileStateByUrl(\n        siteId: string,\n        fileUrl: string,\n        timemodified: number = 0,\n        filePath?: string,\n        revision?: number,\n    ): Promise<string> {\n        let file: CoreWSFile;\n\n        try {\n            file = await this.fixPluginfileURL(siteId, fileUrl, timemodified);\n        } catch (e) {\n            return CoreConstants.NOT_DOWNLOADABLE;\n        }\n\n        fileUrl = CoreUrl.removeUrlAnchor(CoreFileHelper.getFileUrl(file));\n        timemodified = file.timemodified ?? timemodified;\n        revision = revision ?? this.getRevisionFromUrl(fileUrl);\n        const fileId = this.getFileIdByUrl(fileUrl);\n\n        try {\n            // Check if the file is in queue (waiting to be downloaded).\n            await this.hasFileInQueue(siteId, fileId);\n\n            return CoreConstants.DOWNLOADING;\n        } catch (e) {\n            // Check if the file is being downloaded right now.\n            const extension = CoreMimetypeUtils.guessExtensionFromUrl(fileUrl);\n            filePath = filePath || (await this.getFilePath(siteId, fileId, extension));\n\n            const downloadId = this.getFileDownloadId(fileUrl, filePath);\n\n            if (this.filePromises[siteId] && this.filePromises[siteId][downloadId] !== undefined) {\n                return CoreConstants.DOWNLOADING;\n            }\n\n            try {\n                // File is not being downloaded. Check if it's downloaded and if it's outdated.\n                const entry = await this.hasFileInPool(siteId, fileId);\n\n                if (this.isFileOutdated(entry, revision, timemodified)) {\n                    return CoreConstants.OUTDATED;\n                }\n\n                return CoreConstants.DOWNLOADED;\n            } catch (e) {\n                return CoreConstants.NOT_DOWNLOADED;\n            }\n        }\n    }\n\n    /**\n     * Returns an absolute URL to access the file URL.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The absolute URL to the file.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param mode The type of URL to return. Accepts 'url' or 'src'.\n     * @param timemodified The time this file was modified.\n     * @param checkSize True if we shouldn't download files if their size is big, false otherwise.\n     * @param downloadUnknown True to download file in WiFi if their size is unknown, false otherwise.\n     *                        Ignored if checkSize=false.\n     * @param options Extra options (isexternalfile, repositorytype).\n     * @param revision File revision. If not defined, it will be calculated using the URL.\n     * @returns Resolved with the URL to use.\n     * @description\n     * This will return a URL pointing to the content of the requested URL.\n     *\n     * This handles the queue and validity of the file. If there is a local file and it's valid, return the local URL.\n     * If the file isn't downloaded or it's outdated, return the online URL and add it to the queue to be downloaded later.\n     */\n    protected async getFileUrlByUrl(\n        siteId: string,\n        fileUrl: string,\n        component?: string,\n        componentId?: string | number,\n        mode: string = 'url',\n        timemodified: number = 0,\n        checkSize: boolean = true,\n        downloadUnknown?: boolean,\n        options: CoreFilepoolFileOptions = {},\n        revision?: number,\n    ): Promise<string> {\n        const addToQueue = (fileUrl: string): void => {\n            // Add the file to queue if needed and ignore errors.\n            CoreUtils.ignoreErrors(this.addToQueueIfNeeded(\n                siteId,\n                fileUrl,\n                component,\n                componentId,\n                timemodified,\n                checkSize,\n                downloadUnknown,\n                options,\n                revision,\n            ));\n        };\n\n        const file = await this.fixPluginfileURL(siteId, fileUrl, timemodified);\n\n        fileUrl = CoreFileHelper.getFileUrl(file);\n        timemodified = file.timemodified ?? timemodified;\n        revision = revision ?? this.getRevisionFromUrl(fileUrl);\n        const fileId = this.getFileIdByUrl(fileUrl);\n\n        try {\n            const entry = await this.hasFileInPool(siteId, fileId);\n\n            if (entry === undefined) {\n                throw new CoreError('File not downloaded.');\n            }\n\n            if (this.isFileOutdated(entry, revision, timemodified) && CoreNetwork.isOnline()) {\n                throw new CoreError('File is outdated');\n            }\n        } catch (error) {\n            // The file is not downloaded or it's outdated. Add to queue and return the fixed URL.\n            addToQueue(fileUrl);\n\n            return fileUrl;\n        }\n\n        try {\n            // We found the file entry, now look for the file on disk.\n            const path = mode === 'src' ?\n                await this.getInternalSrcById(siteId, fileId) :\n                await this.getInternalUrlById(siteId, fileId);\n\n            // Add the anchor to the local URL if any.\n            const anchor = CoreUrl.getUrlAnchor(fileUrl);\n\n            return path + (anchor || '');\n        } catch (error) {\n            // The file is not on disk.\n            // We could not retrieve the file, delete the entries associated with that ID.\n            this.logger.debug('File ' + fileId + ' not found on disk');\n            this.removeFileById(siteId, fileId);\n            addToQueue(fileUrl);\n\n            return fileUrl;\n        }\n    }\n\n    /**\n     * Returns the internal SRC of a file.\n     *\n     * The returned URL from this method is typically used with IMG tags.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @returns Resolved with the internal URL. Rejected otherwise.\n     */\n    protected async getInternalSrcById(siteId: string, fileId: string): Promise<string> {\n        if (!CoreFile.isAvailable()) {\n            throw new CoreError('File system cannot be used.');\n        }\n\n        const path = await this.getFilePath(siteId, fileId);\n        const fileEntry = await CoreFile.getFile(path);\n\n        return CoreFile.convertFileSrc(fileEntry.toURL());\n    }\n\n    /**\n     * Returns the local URL of a file.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @returns Resolved with the URL. Rejected otherwise.\n     */\n    protected async getInternalUrlById(siteId: string, fileId: string): Promise<string> {\n        if (!CoreFile.isAvailable()) {\n            throw new CoreError('File system cannot be used.');\n        }\n\n        const path = await this.getFilePath(siteId, fileId);\n        const fileEntry = await CoreFile.getFile(path);\n\n        // This URL is usually used to launch files or put them in HTML.\n        return fileEntry.toURL();\n    }\n\n    /**\n     * Returns the local URL of a file.\n     *\n     * @param filePath The file path.\n     * @returns Resolved with the URL.\n     */\n    protected async getInternalUrlByPath(filePath: string): Promise<string> {\n        if (!CoreFile.isAvailable()) {\n            throw new CoreError('File system cannot be used.');\n        }\n\n        const fileEntry = await CoreFile.getFile(filePath);\n\n        return fileEntry.toURL();\n    }\n\n    /**\n     * Returns the local URL of a file.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file URL.\n     * @returns Resolved with the URL. Rejected otherwise.\n     */\n    async getInternalUrlByUrl(siteId: string, fileUrl: string): Promise<string> {\n        if (!CoreFile.isAvailable()) {\n            throw new CoreError('File system cannot be used.');\n        }\n\n        const file = await this.fixPluginfileURL(siteId, fileUrl);\n        const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n\n        return this.getInternalUrlById(siteId, fileId);\n    }\n\n    /**\n     * Get the data stored for a package.\n     *\n     * @param siteId Site ID.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved with the data.\n     */\n    async getPackageData(siteId: string, component: string, componentId?: string | number): Promise<CoreFilepoolPackageEntry> {\n        componentId = this.fixComponentId(componentId);\n\n        const packageId = this.getPackageId(component, componentId);\n\n        return this.packagesTables[siteId].getOneByPrimaryKey({ id: packageId });\n    }\n\n    /**\n     * Creates the name for a package directory (hash).\n     *\n     * @param url An URL to identify the package.\n     * @returns The directory name.\n     */\n    protected getPackageDirNameByUrl(url: string): string {\n        let extension = '';\n\n        url = this.removeRevisionFromUrl(url);\n\n        if (url.indexOf('/webservice/pluginfile') !== -1) {\n            // Remove attributes that do not matter.\n            this.urlAttributes.forEach((regex) => {\n                url = url.replace(regex, '');\n            });\n\n            // Guess the extension of the URL. This is for backwards compatibility.\n            const candidate = CoreMimetypeUtils.guessExtensionFromUrl(url);\n            if (candidate && candidate !== 'php') {\n                extension = '.' + candidate;\n            }\n        }\n\n        return Md5.hashAsciiStr('url:' + url) + extension;\n    }\n\n    /**\n     * Get the path to a directory to store a package files. This does not check if the file exists or not.\n     *\n     * @param siteId The site ID.\n     * @param url An URL to identify the package.\n     * @returns Promise resolved with the path of the package.\n     */\n    getPackageDirPathByUrl(siteId: string, url: string): Promise<string> {\n        return this.fixPluginfileURL(siteId, url).then((file) => {\n            const dirName = this.getPackageDirNameByUrl(CoreFileHelper.getFileUrl(file));\n\n            return this.getFilePath(siteId, dirName, '');\n        });\n    }\n\n    /**\n     * Returns the local URL of a package directory.\n     *\n     * @param siteId The site ID.\n     * @param url An URL to identify the package.\n     * @returns Resolved with the URL.\n     */\n    async getPackageDirUrlByUrl(siteId: string, url: string): Promise<string> {\n        if (!CoreFile.isAvailable()) {\n            throw new CoreError('File system cannot be used.');\n        }\n\n        const file = await this.fixPluginfileURL(siteId, url);\n        const dirName = this.getPackageDirNameByUrl(CoreFileHelper.getFileUrl(file));\n        const dirPath = await this.getFilePath(siteId, dirName, '');\n        const dirEntry = await CoreFile.getDir(dirPath);\n\n        return dirEntry.toURL();\n    }\n\n    /**\n     * Get a download promise. If the promise is not set, return undefined.\n     *\n     * @param siteId Site ID.\n     * @param component The component of the package.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Download promise or undefined.\n     */\n    getPackageDownloadPromise(siteId: string, component: string, componentId?: string | number): Promise<void> | undefined {\n        const packageId = this.getPackageId(component, componentId);\n        if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId] !== undefined) {\n            return this.packagesPromises[siteId][packageId];\n        }\n    }\n\n    /**\n     * Get a package extra data.\n     *\n     * @param siteId Site ID.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved with the extra data.\n     */\n    getPackageExtra(siteId: string, component: string, componentId?: string | number): Promise<string | undefined> {\n        return this.getPackageData(siteId, component, componentId).then((entry) => entry.extra);\n    }\n\n    /**\n     * Get the ID of a package.\n     *\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Package ID.\n     */\n    getPackageId(component: string, componentId?: string | number): string {\n        return <string> Md5.hashAsciiStr(component + '#' + this.fixComponentId(componentId));\n    }\n\n    /**\n     * Get a package previous status.\n     *\n     * @param siteId Site ID.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved with the status.\n     */\n    async getPackagePreviousStatus(siteId: string, component: string, componentId?: string | number): Promise<string> {\n        try {\n            const entry = await this.getPackageData(siteId, component, componentId);\n\n            return entry.previous || CoreConstants.NOT_DOWNLOADED;\n        } catch (error) {\n            return CoreConstants.NOT_DOWNLOADED;\n        }\n    }\n\n    /**\n     * Get a package status.\n     *\n     * @param siteId Site ID.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved with the status.\n     */\n    async getPackageStatus(siteId: string, component: string, componentId?: string | number): Promise<string> {\n        try {\n            const entry = await this.getPackageData(siteId, component, componentId);\n\n            return entry.status || CoreConstants.NOT_DOWNLOADED;\n        } catch (error) {\n            return CoreConstants.NOT_DOWNLOADED;\n        }\n    }\n\n    /**\n     * Return the array of arguments of the pluginfile url.\n     *\n     * @param url URL to get the args.\n     * @returns The args found, undefined if not a pluginfile.\n     */\n    protected getPluginFileArgs(url: string): string[] | undefined {\n        if (!CoreUrlUtils.isPluginFileUrl(url)) {\n            // Not pluginfile, return.\n            return;\n        }\n\n        const relativePath = url.substring(url.indexOf('/pluginfile.php') + 16);\n        const args = relativePath.split('/');\n\n        if (args.length < 3) {\n            // To be a plugin file it should have at least contextId, Component and Filearea.\n            return;\n        }\n\n        return args;\n    }\n\n    /**\n     * Get the deferred object for a file in the queue.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param create True if it should create a new deferred if it doesn't exist.\n     * @param onProgress Function to call on progress.\n     * @returns Deferred.\n     */\n    protected getQueueDeferred(\n        siteId: string,\n        fileId: string,\n        create: boolean = true,\n        onProgress?: CoreFilepoolOnProgressCallback,\n    ): CoreFilepoolPromisedValue | undefined {\n        if (!this.queueDeferreds[siteId]) {\n            if (!create) {\n                return;\n            }\n            this.queueDeferreds[siteId] = {};\n        }\n        if (!this.queueDeferreds[siteId][fileId]) {\n            if (!create) {\n                return;\n            }\n            this.queueDeferreds[siteId][fileId] = new CorePromisedValue();\n        }\n\n        if (onProgress) {\n            this.queueDeferreds[siteId][fileId].onProgress = onProgress;\n        }\n\n        return this.queueDeferreds[siteId][fileId];\n    }\n\n    /**\n     * Get the on progress for a file in the queue.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @returns On progress function, undefined if not found.\n     */\n    protected getQueueOnProgress(siteId: string, fileId: string): CoreFilepoolOnProgressCallback | undefined {\n        const deferred = this.getQueueDeferred(siteId, fileId, false);\n\n        return deferred?.onProgress;\n    }\n\n    /**\n     * Get the promise for a file in the queue.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param create True if it should create a new promise if it doesn't exist.\n     * @param onProgress Function to call on progress.\n     * @returns Promise.\n     */\n    protected getQueuePromise(\n        siteId: string,\n        fileId: string,\n        create: boolean = true,\n        onProgress?: CoreFilepoolOnProgressCallback,\n    ): Promise<void> | undefined {\n        return this.getQueueDeferred(siteId, fileId, create, onProgress);\n    }\n\n    /**\n     * Get a revision number from a list of files (highest revision).\n     *\n     * @param files Package files.\n     * @returns Highest revision.\n     */\n    getRevisionFromFileList(files: CoreWSFile[]): number {\n        let revision = 0;\n\n        files.forEach((file) => {\n            const fileUrl = CoreFileHelper.getFileUrl(file);\n\n            if (fileUrl) {\n                const r = this.getRevisionFromUrl(fileUrl);\n                if (r > revision) {\n                    revision = r;\n                }\n            }\n        });\n\n        return revision;\n    }\n\n    /**\n     * Get the revision number from a file URL.\n     *\n     * @param url URL to get the revision number.\n     * @returns Revision number.\n     */\n    protected getRevisionFromUrl(url: string): number {\n        const args = this.getPluginFileArgs(url);\n        if (!args) {\n            // Not a pluginfile, no revision will be found.\n            return 0;\n        }\n\n        const revisionRegex = CorePluginFileDelegate.getComponentRevisionRegExp(args);\n        if (!revisionRegex) {\n            return 0;\n        }\n\n        const matches = url.match(revisionRegex);\n        if (matches && matches[1] !== undefined) {\n            return parseInt(matches[1], 10);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Returns an absolute URL to use in IMG tags.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The absolute URL to the file.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param timemodified The time this file was modified.\n     * @param checkSize True if we shouldn't download files if their size is big, false otherwise.\n     * @param downloadUnknown True to download file in WiFi if their size is unknown, false otherwise.\n     *                        Ignored if checkSize=false.\n     * @param options Extra options (isexternalfile, repositorytype).\n     * @param revision File revision. If not defined, it will be calculated using the URL.\n     * @returns Resolved with the URL to use.\n     * @description\n     * This will return a URL pointing to the content of the requested URL.\n     * The URL returned is compatible to use with IMG tags.\n     */\n    getSrcByUrl(\n        siteId: string,\n        fileUrl: string,\n        component?: string,\n        componentId?: string | number,\n        timemodified: number = 0,\n        checkSize: boolean = true,\n        downloadUnknown?: boolean,\n        options: CoreFilepoolFileOptions = {},\n        revision?: number,\n    ): Promise<string> {\n        return this.getFileUrlByUrl(\n            siteId,\n            fileUrl,\n            component,\n            componentId,\n            'src',\n            timemodified,\n            checkSize,\n            downloadUnknown,\n            options,\n            revision,\n        );\n    }\n\n    /**\n     * Get time modified from a list of files.\n     *\n     * @param files List of files.\n     * @returns Time modified.\n     */\n    getTimemodifiedFromFileList(files: CoreWSFile[]): number {\n        let timemodified = 0;\n\n        files.forEach((file) => {\n            if (file.timemodified && file.timemodified > timemodified) {\n                timemodified = file.timemodified;\n            }\n        });\n\n        return timemodified;\n    }\n\n    /**\n     * Returns an absolute URL to access the file.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The absolute URL to the file.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param timemodified The time this file was modified.\n     * @param checkSize True if we shouldn't download files if their size is big, false otherwise.\n     * @param downloadUnknown True to download file in WiFi if their size is unknown, false otherwise.\n     *                        Ignored if checkSize=false.\n     * @param options Extra options (isexternalfile, repositorytype).\n     * @param revision File revision. If not defined, it will be calculated using the URL.\n     * @returns Resolved with the URL to use.\n     * @description\n     * This will return a URL pointing to the content of the requested URL.\n     * The URL returned is compatible to use with a local browser.\n     */\n    getUrlByUrl(\n        siteId: string,\n        fileUrl: string,\n        component?: string,\n        componentId?: string | number,\n        timemodified: number = 0,\n        checkSize: boolean = true,\n        downloadUnknown?: boolean,\n        options: CoreFilepoolFileOptions = {},\n        revision?: number,\n    ): Promise<string> {\n        return this.getFileUrlByUrl(\n            siteId,\n            fileUrl,\n            component,\n            componentId,\n            'url',\n            timemodified,\n            checkSize,\n            downloadUnknown,\n            options,\n            revision,\n        );\n    }\n\n    /**\n     * Guess the filename of a file from its URL. This is very weak and unreliable.\n     *\n     * @param fileUrl The file URL.\n     * @returns The filename treated so it doesn't have any special character.\n     */\n    protected guessFilenameFromUrl(fileUrl: string): string {\n        let filename = '';\n\n        if (fileUrl.indexOf('/webservice/pluginfile') !== -1) {\n            // It's a pluginfile URL. Search for the 'file' param to extract the name.\n            const params = CoreUrlUtils.extractUrlParams(fileUrl);\n            if (params.file) {\n                filename = params.file.substring(params.file.lastIndexOf('/') + 1);\n            } else {\n                // 'file' param not found. Extract what's after the last '/' without params.\n                filename = CoreUrlUtils.getLastFileWithoutParams(fileUrl);\n            }\n        } else if (CoreUrlUtils.isGravatarUrl(fileUrl)) {\n            // Extract gravatar ID.\n            filename = 'gravatar_' + CoreUrlUtils.getLastFileWithoutParams(fileUrl);\n        } else if (CoreUrlUtils.isThemeImageUrl(fileUrl)) {\n            // Extract user ID.\n            const matches = fileUrl.match(/\\/core\\/([^/]*)\\//);\n            if (matches && matches[1]) {\n                filename = matches[1];\n            }\n            // Attach a constant and the image type.\n            filename = 'default_' + filename + '_' + CoreUrlUtils.getLastFileWithoutParams(fileUrl);\n        } else {\n            // Another URL. Just get what's after the last /.\n            filename = CoreUrlUtils.getLastFileWithoutParams(fileUrl);\n        }\n\n        // If there are hashes in the URL, extract them.\n        const index = filename.indexOf('#');\n        let hashes: string[] | undefined;\n\n        if (index != -1) {\n            hashes = filename.split('#');\n\n            // Remove the URL from the array.\n            hashes.shift();\n\n            filename = filename.substring(0, index);\n        }\n\n        // Remove the extension from the filename.\n        filename = CoreMimetypeUtils.removeExtension(filename);\n\n        if (hashes) {\n            // Add hashes to the name.\n            filename += '_' + hashes.join('_');\n        }\n\n        return CoreTextUtils.removeSpecialCharactersForFiles(filename);\n    }\n\n    /**\n     * Check if the file is already in the pool. This does not check if the file is on the disk.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file Id.\n     * @returns Resolved with file object from DB on success, rejected otherwise.\n     */\n    protected async hasFileInPool(siteId: string, fileId: string): Promise<CoreFilepoolFileEntry> {\n        return this.filesTables[siteId].getOneByPrimaryKey({ fileId });\n    }\n\n    /**\n     * Check if the file is in the queue.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file Id.\n     * @returns Resolved with file object from DB on success, rejected otherwise.\n     */\n    protected async hasFileInQueue(siteId: string, fileId: string): Promise<CoreFilepoolQueueEntry> {\n        const entry = await this.queueTable.getOneByPrimaryKey({ siteId, fileId });\n\n        if (entry === undefined) {\n            throw new CoreError('File not found in queue.');\n        }\n\n        return {\n            ...entry,\n            linksUnserialized: CoreTextUtils.parseJSON(entry.links, []),\n        };\n    }\n\n    /**\n     * Invalidate all the files in a site.\n     *\n     * @param siteId The site ID.\n     * @param onlyUnknown True to only invalidate files from external repos or without revision/timemodified.\n     *                    It is advised to set it to true to reduce the performance and data usage of the app.\n     * @returns Resolved on success.\n     */\n    async invalidateAllFiles(siteId: string, onlyUnknown: boolean = true): Promise<void> {\n        onlyUnknown\n            ? await this.filesTables[siteId].updateWhere(\n                { stale: 1 },\n                {\n                    sql: CoreFilepoolProvider.FILE_IS_UNKNOWN_SQL,\n                    js: CoreFilepoolProvider.FILE_IS_UNKNOWN_JS,\n                },\n            )\n            : await this.filesTables[siteId].update({ stale: 1 });\n    }\n\n    /**\n     * Invalidate a file by URL.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file URL.\n     * @returns Resolved on success.\n     * @description\n     * Invalidates a file by marking it stale. It will not be added to the queue automatically, but the next time this file\n     * is requested it will be added to the queue.\n     * You can manully call addToQueueByUrl to add this file to the queue immediately.\n     * Please note that, if a file is stale, the user will be presented the stale file if there is no network access.\n     */\n    async invalidateFileByUrl(siteId: string, fileUrl: string): Promise<void> {\n        const file = await this.fixPluginfileURL(siteId, fileUrl);\n        const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n\n        await this.filesTables[siteId].update({ stale: 1 }, { fileId });\n    }\n\n    /**\n     * Invalidate all the matching files from a component.\n     *\n     * @param siteId The site ID.\n     * @param component The component to invalidate.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param onlyUnknown True to only invalidate files from external repos or without revision/timemodified.\n     *                It is advised to set it to true to reduce the performance and data usage of the app.\n     * @returns Resolved when done.\n     */\n    async invalidateFilesByComponent(\n        siteId: string | undefined,\n        component: string,\n        componentId?: string | number,\n        onlyUnknown: boolean = true,\n    ): Promise<void> {\n        const items = await this.getComponentFiles(siteId, component, componentId);\n\n        if (!items.length) {\n            // Nothing to invalidate.\n            return;\n        }\n\n        siteId = siteId ?? CoreSites.getCurrentSiteId();\n\n        const fileIds = items.map((item) => item.fileId);\n\n        const whereAndParams = SQLiteDB.getInOrEqual(fileIds);\n\n        whereAndParams.sql = 'fileId ' + whereAndParams.sql;\n\n        if (onlyUnknown) {\n            whereAndParams.sql += ' AND (' + CoreFilepoolProvider.FILE_IS_UNKNOWN_SQL + ')';\n        }\n\n        await this.filesTables[siteId].updateWhere(\n            { stale: 1 },\n            {\n                sql: whereAndParams.sql,\n                sqlParams: whereAndParams.params,\n                js: record => fileIds.includes(record.fileId) && (\n                    !onlyUnknown || CoreFilepoolProvider.FILE_IS_UNKNOWN_JS(record)\n                ),\n            },\n        );\n    }\n\n    /**\n     * Whether a file action indicates a file was downloaded or deleted.\n     *\n     * @param data Event data.\n     * @returns Whether downloaded or deleted.\n     */\n    isFileEventDownloadedOrDeleted(data: CoreFilepoolFileEventData): boolean {\n        return (data.action == CoreFilepoolFileActions.DOWNLOAD && data.success == true) ||\n                data.action == CoreFilepoolFileActions.DELETED;\n    }\n\n    /**\n     * Check whether a file is downloadable.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl File URL.\n     * @param timemodified The time this file was modified.\n     * @param filePath Filepath to download the file to. If defined, no extension will be added.\n     * @param revision File revision. If not defined, it will be calculated using the URL.\n     * @returns Promise resolved with a boolean: whether a file is downloadable.\n     */\n    async isFileDownloadable(\n        siteId: string,\n        fileUrl: string,\n        timemodified: number = 0,\n        filePath?: string,\n        revision?: number,\n    ): Promise<boolean> {\n        const state = await this.getFileStateByUrl(siteId, fileUrl, timemodified, filePath, revision);\n\n        return state != CoreConstants.NOT_DOWNLOADABLE;\n    }\n\n    /**\n     * Check if a file is downloading.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl File URL.\n     * @returns Promise resolved with boolean: whether the file is downloading.\n     */\n    async isFileDownloadingByUrl(siteId: string, fileUrl: string): Promise<boolean> {\n        const file = await this.fixPluginfileURL(siteId, fileUrl);\n        const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n\n        try {\n            await this.hasFileInQueue(siteId, fileId);\n\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Check if a file is outdated.\n     *\n     * @param entry Filepool entry.\n     * @param revision File revision number.\n     * @param timemodified The time this file was modified.\n     * @returns Whether the file is outdated.\n     */\n    protected isFileOutdated(entry: CoreFilepoolFileEntry, revision = 0, timemodified = 0): boolean {\n        // Don't allow undefined values, convert them to 0.\n        const entryTimemodified = entry.timemodified ?? 0;\n        const entryRevision = entry.revision ?? 0;\n\n        return !!entry.stale || revision > entryRevision || timemodified > entryTimemodified;\n    }\n\n    /**\n     * Check if cannot determine if a file has been updated.\n     *\n     * @param entry Filepool entry.\n     * @returns Whether it cannot determine updates.\n     */\n    protected isFileUpdateUnknown(entry: CoreFilepoolFileEntry): boolean {\n        return !!entry.isexternalfile || (!entry.revision && !entry.timemodified);\n    }\n\n    /**\n     * Notify an action performed on a file to a list of components.\n     *\n     * @param siteId The site ID.\n     * @param eventData The file event data.\n     * @param links The links to the components.\n     */\n    protected notifyFileActionToComponents(\n        siteId: string,\n        eventData: CoreFilepoolFileEventData,\n        links: CoreFilepoolComponentLink[],\n    ): void {\n        links.forEach((link) => {\n            const data: CoreFilepoolComponentFileEventData = Object.assign({\n                component: link.component,\n                componentId: link.componentId,\n            }, eventData);\n\n            CoreEvents.trigger(CoreEvents.COMPONENT_FILE_ACTION, data, siteId);\n        });\n    }\n\n    /**\n     * Notify a file has been deleted.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param links The links to components.\n     */\n    protected notifyFileDeleted(siteId: string, fileId: string, links: CoreFilepoolComponentLink[]): void {\n        const data: CoreFilepoolFileEventData = {\n            fileId,\n            action: CoreFilepoolFileActions.DELETED,\n        };\n\n        CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n        this.notifyFileActionToComponents(siteId, data, links);\n    }\n\n    /**\n     * Notify a file has been downloaded.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param links The links to components.\n     */\n    protected notifyFileDownloaded(siteId: string, fileId: string, links: CoreFilepoolComponentLink[]): void {\n        const data: CoreFilepoolFileEventData = {\n            fileId,\n            action: CoreFilepoolFileActions.DOWNLOAD,\n            success: true,\n        };\n\n        CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n        this.notifyFileActionToComponents(siteId, data, links);\n    }\n\n    /**\n     * Notify error occurred while downloading a file.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param links The links to components.\n     */\n    protected notifyFileDownloadError(siteId: string, fileId: string, links: CoreFilepoolComponentLink[]): void {\n        const data: CoreFilepoolFileEventData = {\n            fileId,\n            action: CoreFilepoolFileActions.DOWNLOAD,\n            success: false,\n        };\n\n        CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n        this.notifyFileActionToComponents(siteId, data, links);\n    }\n\n    /**\n     * Notify a file starts being downloaded or added to queue.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param links The links to components.\n     */\n    protected notifyFileDownloading(siteId: string, fileId: string, links: CoreFilepoolComponentLink[]): void {\n        const data: CoreFilepoolFileEventData = {\n            fileId,\n            action: CoreFilepoolFileActions.DOWNLOADING,\n        };\n\n        CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n        this.notifyFileActionToComponents(siteId, data, links);\n    }\n\n    /**\n     * Notify a file has been outdated.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param links The links to components.\n     */\n    protected notifyFileOutdated(siteId: string, fileId: string, links: CoreFilepoolComponentLink[]): void {\n        const data: CoreFilepoolFileEventData = {\n            fileId,\n            action: CoreFilepoolFileActions.OUTDATED,\n        };\n\n        CoreEvents.trigger(this.getFileEventName(siteId, fileId), data);\n        this.notifyFileActionToComponents(siteId, data, links);\n    }\n\n    /**\n     * Prefetches a list of files.\n     *\n     * @param siteId The site ID.\n     * @param fileList List of files to download.\n     * @param component The component to link the file to.\n     * @param componentId An ID to identify the download.\n     * @param extra Extra data to store for the package.\n     * @param dirPath Name of the directory where to store the files (inside filepool dir). If not defined, store\n     *                the files directly inside the filepool folder.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when all files are downloaded.\n     */\n    prefetchPackage(\n        siteId: string,\n        fileList: CoreWSFile[],\n        component: string,\n        componentId?: string | number,\n        extra?: string,\n        dirPath?: string,\n        onProgress?: CoreFilepoolOnProgressCallback,\n    ): Promise<void> {\n        return this.downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, extra, dirPath, onProgress);\n    }\n\n    /**\n     * Process the queue.\n     *\n     * @description\n     * This loops over itself to keep on processing the queue in the background.\n     * The queue process is site agnostic.\n     */\n    protected async processQueue(): Promise<void> {\n        try {\n            if (this.queueState !== CoreFilepoolProvider.QUEUE_RUNNING) {\n                // Silently ignore, the queue is on pause.\n                throw CoreFilepoolProvider.ERR_QUEUE_ON_PAUSE;\n            } else if (!CoreFile.isAvailable() || !CoreNetwork.isOnline()) {\n                throw CoreFilepoolProvider.ERR_FS_OR_NETWORK_UNAVAILABLE;\n            }\n\n            await this.processImportantQueueItem();\n        } catch (error) {\n            // We had an error, in which case we pause the processing.\n            if (error === CoreFilepoolProvider.ERR_FS_OR_NETWORK_UNAVAILABLE) {\n                this.logger.debug('Filesysem or network unavailable, pausing queue processing.');\n            } else if (error === CoreFilepoolProvider.ERR_QUEUE_IS_EMPTY) {\n                this.logger.debug('Queue is empty, pausing queue processing.');\n            }\n\n            this.queueState = CoreFilepoolProvider.QUEUE_PAUSED;\n\n            return;\n        }\n\n        // All good, we schedule next execution.\n        setTimeout(() => {\n            this.processQueue();\n        }, CoreFilepoolProvider.QUEUE_PROCESS_INTERVAL);\n    }\n\n    /**\n     * Process the most important queue item.\n     *\n     * @returns Resolved on success. Rejected on failure.\n     */\n    protected async processImportantQueueItem(): Promise<void> {\n        try {\n            const item = await this.queueTable.getOne({}, {\n                sorting: [\n                    { priority: 'desc' },\n                    { added: 'asc' },\n                ],\n            });\n\n            if (!item) {\n                throw CoreFilepoolProvider.ERR_QUEUE_IS_EMPTY;\n            }\n\n            return this.processQueueItem({\n                ...item,\n                linksUnserialized: CoreTextUtils.parseJSON(item.links, []),\n            });\n        } catch (err) {\n            throw CoreFilepoolProvider.ERR_QUEUE_IS_EMPTY;\n        }\n    }\n\n    /**\n     * Process a queue item.\n     *\n     * @param item The object from the queue store.\n     * @returns Resolved on success. Rejected on failure.\n     */\n    protected async processQueueItem(item: CoreFilepoolQueueEntry): Promise<void> {\n        // Cast optional fields to undefined instead of null.\n        const siteId = item.siteId;\n        const fileId = item.fileId;\n        const fileUrl = item.url;\n        const options = {\n            revision: item.revision ?? 0,\n            timemodified: item.timemodified ?? 0,\n            isexternalfile: item.isexternalfile ?? undefined,\n            repositorytype: item.repositorytype ?? undefined,\n        };\n        const filePath = item.path || undefined;\n        const links = item.linksUnserialized || [];\n\n        this.logger.debug('Processing queue item: ' + siteId + ', ' + fileId);\n\n        let entry: CoreFilepoolFileEntry | undefined;\n\n        // Check if the file is already in pool.\n        try {\n            entry = await this.hasFileInPool(siteId, fileId);\n        } catch (error) {\n            // File not in pool.\n        }\n\n        if (entry && !options.isexternalfile && !this.isFileOutdated(entry, options.revision, options.timemodified)) {\n            // We have the file, it is not stale, we can update links and remove from queue.\n            this.logger.debug('Queued file already in store, ignoring...');\n            this.addFileLinks(siteId, fileId, links).catch(() => {\n                // Ignore errors.\n            });\n            this.removeFromQueue(siteId, fileId).catch(() => {\n                // Ignore errors.\n            }).finally(() => {\n                this.treatQueueDeferred(siteId, fileId, true);\n            });\n\n            return;\n        }\n\n        // The file does not exist, or is stale, ... download it.\n        const onProgress = this.getQueueOnProgress(siteId, fileId);\n\n        try {\n            await this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, entry);\n\n            // Success, we add links and remove from queue.\n            CoreUtils.ignoreErrors(this.addFileLinks(siteId, fileId, links));\n\n            // Wait for the item to be removed from queue before resolving the promise.\n            // If the item could not be removed from queue we still resolve the promise.\n            await CoreUtils.ignoreErrors(this.removeFromQueue(siteId, fileId));\n\n            this.treatQueueDeferred(siteId, fileId, true);\n            this.notifyFileDownloaded(siteId, fileId, links);\n        } catch (errorObject) {\n            // Whoops, we have an error...\n            let dropFromQueue = false;\n\n            if (errorObject && errorObject.source === fileUrl) {\n                // This is most likely a FileTransfer error.\n                if (errorObject.code === 1) { // FILE_NOT_FOUND_ERR.\n                    // The file was not found, most likely a 404, we remove from queue.\n                    dropFromQueue = true;\n                } else if (errorObject.code === 2) { // INVALID_URL_ERR.\n                    // The URL is invalid, we drop the file from the queue.\n                    dropFromQueue = true;\n                } else if (errorObject.code === 3) { // CONNECTION_ERR.\n                    // If there was an HTTP status, then let's remove from the queue.\n                    dropFromQueue = true;\n                } else if (errorObject.code === 4) { // ABORTED_ERR.\n                    // The transfer was aborted, we will keep the file in queue.\n                } else if (errorObject.code === 5) { // NOT_MODIFIED_ERR.\n                    // We have the latest version of the file, HTTP 304 status.\n                    dropFromQueue = true;\n                } else {\n                    // Any error, let's remove the file from the queue to avoi locking down the queue.\n                    dropFromQueue = true;\n                }\n            } else {\n                dropFromQueue = true;\n            }\n\n            let errorMessage: string | undefined;\n            // Some Android devices restrict the amount of usable storage using quotas.\n            // If this quota would be exceeded by the download, it throws an exception.\n            // We catch this exception here, and report a meaningful error message to the user.\n            if (errorObject instanceof FileTransferError && errorObject.exception && errorObject.exception.includes('EDQUOT')) {\n                errorMessage = 'core.course.insufficientavailablequota';\n            }\n\n            if (dropFromQueue) {\n                this.logger.debug('Item dropped from queue due to error: ' + fileUrl, errorObject);\n\n                await CoreUtils.ignoreErrors(this.removeFromQueue(siteId, fileId));\n\n                this.treatQueueDeferred(siteId, fileId, false, errorMessage);\n                this.notifyFileDownloadError(siteId, fileId, links);\n            } else {\n                // We considered the file as legit but did not get it, failure.\n                this.treatQueueDeferred(siteId, fileId, false, errorMessage);\n                this.notifyFileDownloadError(siteId, fileId, links);\n\n                throw errorObject;\n            }\n        }\n    }\n\n    /**\n     * Remove a file from the queue.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @returns Resolved on success. Rejected on failure. It is advised to silently ignore failures.\n     */\n    protected async removeFromQueue(siteId: string, fileId: string): Promise<void> {\n        await this.queueTable.deleteByPrimaryKey({ siteId, fileId });\n    }\n\n    /**\n     * Remove a file from the pool.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @returns Resolved on success.\n     */\n    protected async removeFileById(siteId: string, fileId: string): Promise<void> {\n        // Get the path to the file first since it relies on the file object stored in the pool.\n        // Don't use getFilePath to prevent performing 2 DB requests.\n        let path = this.getFilepoolFolderPath(siteId) + '/' + fileId;\n        let fileUrl: string | undefined;\n\n        try {\n            const entry = await this.hasFileInPool(siteId, fileId);\n\n            fileUrl = entry.url;\n            if (entry.extension) {\n                path += '.' + entry.extension;\n            }\n        } catch (error) {\n            // If file not found, use the path without extension.\n        }\n\n        const conditions = {\n            fileId,\n        };\n\n        // Get links to components to notify them after remove.\n        const links = await this.getFileLinks(siteId, fileId);\n        const promises: Promise<unknown>[] = [];\n\n        // Remove entry from filepool store.\n        promises.push(this.filesTables[siteId].delete(conditions));\n\n        // Remove links.\n        promises.push(this.linksTables[siteId].delete(conditions));\n\n        // Remove the file.\n        if (CoreFile.isAvailable()) {\n            promises.push(CoreFile.removeFile(path).catch((error) => {\n                if (error && error.code == 1) {\n                    // Not found, ignore error since maybe it was deleted already.\n                } else {\n                    throw error;\n                }\n            }));\n        }\n\n        await Promise.all(promises);\n\n        this.notifyFileDeleted(siteId, fileId, links);\n\n        if (fileUrl) {\n            await CoreUtils.ignoreErrors(CorePluginFileDelegate.fileDeleted(fileUrl, path, siteId));\n        }\n    }\n\n    /**\n     * Delete all the matching files from a component.\n     *\n     * @param siteId The site ID.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Resolved on success.\n     */\n    async removeFilesByComponent(siteId: string, component: string, componentId?: string | number): Promise<void> {\n        const items = await this.getComponentFiles(siteId, component, componentId);\n\n        await Promise.all(items.map((item) => this.removeFileById(siteId, item.fileId)));\n    }\n\n    /**\n     * Remove a file from the pool.\n     *\n     * @param siteId The site ID.\n     * @param fileUrl The file URL.\n     * @returns Resolved on success, rejected on failure.\n     */\n    async removeFileByUrl(siteId: string, fileUrl: string): Promise<void> {\n        const file = await this.fixPluginfileURL(siteId, fileUrl);\n        const fileId = this.getFileIdByUrl(CoreFileHelper.getFileUrl(file));\n\n        await this.removeFileById(siteId, fileId);\n    }\n\n    /**\n     * Removes the revision number from a file URL.\n     *\n     * @param url URL to remove the revision number.\n     * @returns URL without revision number.\n     * @description\n     * The revision is used to know if a file has changed. We remove it from the URL to prevent storing a file per revision.\n     */\n    protected removeRevisionFromUrl(url: string): string {\n        const args = this.getPluginFileArgs(url);\n        if (!args) {\n            // Not a pluginfile, no revision will be found.\n            return url;\n        }\n\n        return CorePluginFileDelegate.removeRevisionFromUrl(url, args);\n    }\n\n    /**\n     * Change the package status, setting it to the previous status.\n     *\n     * @param siteId Site ID.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved when the status is changed. Resolve param: new status.\n     */\n    async setPackagePreviousStatus(siteId: string, component: string, componentId?: string | number): Promise<string> {\n        componentId = this.fixComponentId(componentId);\n        this.logger.debug(`Set previous status for package ${component} ${componentId}`);\n\n        const packageId = this.getPackageId(component, componentId);\n\n        // Get current stored data, we'll only update 'status' and 'updated' fields.\n        const entry = await this.packagesTables[siteId].getOneByPrimaryKey({ id: packageId });\n        const newData: CoreFilepoolPackageEntry = {};\n        if (entry.status == CoreConstants.DOWNLOADING) {\n            // Going back from downloading to previous status, restore previous download time.\n            newData.downloadTime = entry.previousDownloadTime;\n        }\n        newData.status = entry.previous || CoreConstants.NOT_DOWNLOADED;\n        newData.updated = Date.now();\n        this.logger.debug(`Set previous status '${entry.status}' for package ${component} ${componentId}`);\n\n        await this.packagesTables[siteId].update(newData, { id: packageId });\n        // Success updating, trigger event.\n        this.triggerPackageStatusChanged(siteId, newData.status, component, componentId);\n\n        return newData.status;\n    }\n\n    /**\n     * Check if a file should be downloaded based on its size.\n     *\n     * @param size File size.\n     * @returns Whether file should be downloaded.\n     */\n    shouldDownload(size: number): boolean {\n        return size <= CoreFilepoolProvider.DOWNLOAD_THRESHOLD ||\n            (CoreNetwork.isWifi() && size <= CoreFilepoolProvider.WIFI_DOWNLOAD_THRESHOLD);\n    }\n\n    /**\n     * Convenience function to check if a file should be downloaded before opening it.\n     *\n     * @param url File online URL.\n     * @param size File size.\n     * @param options Options.\n     * @returns Promise resolved with boolean: whether file should be downloaded before opening it.\n     * @description\n     * Convenience function to check if a file should be downloaded before opening it.\n     *\n     * The default behaviour in the app is to download first and then open the local file in the following cases:\n     *     - The file is small (less than DOWNLOAD_THRESHOLD).\n     *     - The file cannot be streamed.\n     * If the file is big and can be streamed, the promise returned by this function will be rejected.\n     */\n    async shouldDownloadFileBeforeOpen(url: string, size: number, options: CoreUtilsOpenFileOptions = {}): Promise<boolean> {\n        if (size >= 0 && size <= CoreFilepoolProvider.DOWNLOAD_THRESHOLD) {\n            // The file is small, download it.\n            return true;\n        }\n\n        if (CoreUtils.shouldOpenWithDialog(options)) {\n            // Open with dialog needs a local file.\n            return true;\n        }\n\n        const mimetype = await CoreUtils.getMimeTypeFromUrl(url);\n\n        // If the file is streaming (audio or video), return false.\n        return !CoreMimetypeUtils.isStreamedMimetype(mimetype);\n    }\n\n    /**\n     * Store package status.\n     *\n     * @param siteId Site ID.\n     * @param status New package status.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param extra Extra data to store for the package. If you want to store more than 1 value, use JSON.stringify.\n     * @returns Promise resolved when status is stored.\n     */\n    async storePackageStatus(\n        siteId: string,\n        status: string,\n        component: string,\n        componentId?: string | number,\n        extra?: string,\n    ): Promise<void> {\n        this.logger.debug(`Set status '${status}' for package ${component} ${componentId}`);\n        componentId = this.fixComponentId(componentId);\n\n        const packageId = this.getPackageId(component, componentId);\n        let downloadTime: number | undefined;\n        let previousDownloadTime: number | undefined;\n\n        if (status == CoreConstants.DOWNLOADING) {\n            // Set download time if package is now downloading.\n            downloadTime = CoreTimeUtils.timestamp();\n        }\n\n        let previousStatus: string | undefined;\n        // Search current status to set it as previous status.\n        try {\n            const entry = await this.packagesTables[siteId].getOneByPrimaryKey({ id: packageId });\n\n            extra = extra ?? entry.extra;\n            if (downloadTime === undefined) {\n                // Keep previous download time.\n                downloadTime = entry.downloadTime;\n                previousDownloadTime = entry.previousDownloadTime;\n            } else {\n                // The downloadTime will be updated, store current time as previous.\n                previousDownloadTime = entry.downloadTime;\n            }\n\n            previousStatus = entry.status;\n        } catch (error) {\n            // No previous status.\n        }\n\n        if (previousStatus === status) {\n            // The package already has this status, no need to change it.\n            return;\n        }\n\n        await this.packagesTables[siteId].insert({\n            id: packageId,\n            component,\n            componentId,\n            status,\n            previous: previousStatus,\n            updated: Date.now(),\n            downloadTime,\n            previousDownloadTime,\n            extra,\n        });\n\n        // Success inserting, trigger event.\n        this.triggerPackageStatusChanged(siteId, status, component, componentId);\n    }\n\n    /**\n     * Search for files in a CSS code and try to download them. Once downloaded, replace their URLs\n     * and store the result in the CSS file.\n     *\n     * @param siteId Site ID.\n     * @param fileUrl CSS file URL. It must be the online URL, not a local path.\n     * @param cssCode CSS code.\n     * @param component The component to link the file to.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param revision Revision to use in all files. If not defined, it will be calculated using the URL of each file.\n     * @returns Promise resolved with the CSS code.\n     */\n    async treatCSSCode(\n        siteId: string,\n        fileUrl: string,\n        cssCode: string,\n        component?: string,\n        componentId?: string | number,\n        revision?: number,\n    ): Promise<string> {\n        const urls = CoreDomUtils.extractUrlsFromCSS(cssCode);\n        let updated = false;\n\n        // Get the path of the CSS file. If it's a local file, assume it's the path where to write the file.\n        const filePath = await this.getFilePathByUrl(siteId, fileUrl);\n\n        // Download all files in the CSS.\n        await Promise.all(urls.map(async (url) => {\n            if (!url.trim()) {\n                return; // Ignore empty URLs.\n            }\n\n            const absoluteUrl = CoreUrl.toAbsoluteURL(fileUrl, url);\n\n            try {\n                let fileUrl = absoluteUrl;\n\n                if (!CoreUrlUtils.isLocalFileUrl(absoluteUrl)) {\n                    // Not a local file, download it.\n                    fileUrl = await this.downloadUrl(\n                        siteId,\n                        absoluteUrl,\n                        false,\n                        component,\n                        componentId,\n                        0,\n                        undefined,\n                        undefined,\n                        undefined,\n                        revision,\n                    );\n                }\n\n                // Convert the URL so it works in mobile devices.\n                fileUrl = CoreFile.convertFileSrc(fileUrl);\n\n                if (fileUrl !== url) {\n                    cssCode = cssCode.replace(new RegExp(CoreTextUtils.escapeForRegex(url), 'g'), fileUrl);\n                    updated = true;\n                }\n            } catch (error) {\n                this.logger.warn('Error treating file ', url, error);\n\n                // If the URL is relative, store the absolute URL.\n                if (absoluteUrl !== url) {\n                    cssCode = cssCode.replace(new RegExp(CoreTextUtils.escapeForRegex(url), 'g'), absoluteUrl);\n                    updated = true;\n                }\n            }\n        }));\n\n        // All files downloaded. Store the result if it has changed.\n        if (updated) {\n            await CoreFile.writeFile(filePath, cssCode);\n        }\n\n        return cssCode;\n    }\n\n    /**\n     * Resolves or rejects a queue deferred and removes it from the list.\n     *\n     * @param siteId The site ID.\n     * @param fileId The file ID.\n     * @param resolve True if promise should be resolved, false if it should be rejected.\n     * @param error String identifier for error message, if rejected.\n     */\n    protected treatQueueDeferred(siteId: string, fileId: string, resolve: boolean, error?: string): void {\n        if (siteId in this.queueDeferreds && fileId in this.queueDeferreds[siteId]) {\n            if (resolve) {\n                this.queueDeferreds[siteId][fileId].resolve();\n            } else {\n                this.queueDeferreds[siteId][fileId].reject(new Error(error));\n            }\n            delete this.queueDeferreds[siteId][fileId];\n        }\n    }\n\n    /**\n     * Trigger package status changed event with the right data.\n     *\n     * @param siteId Site ID.\n     * @param status New package status.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     */\n    protected triggerPackageStatusChanged(siteId: string, status: string, component: string, componentId?: string | number): void {\n        const data: CoreEventPackageStatusChanged = {\n            component,\n            componentId: this.fixComponentId(componentId),\n            status,\n        };\n\n        CoreEvents.trigger(CoreEvents.PACKAGE_STATUS_CHANGED, data, siteId);\n    }\n\n    /**\n     * Update the download time of a package. This doesn't modify the previous download time.\n     * This function should be used if a package generates some new data during a download. Calling this function\n     * right after generating the data in the download will prevent detecting this data as an update.\n     *\n     * @param siteId Site ID.\n     * @param component Package's component.\n     * @param componentId An ID to use in conjunction with the component.\n     * @returns Promise resolved when status is stored.\n     */\n    async updatePackageDownloadTime(siteId: string, component: string, componentId?: string | number): Promise<void> {\n        componentId = this.fixComponentId(componentId);\n\n        const packageId = this.getPackageId(component, componentId);\n\n        await this.packagesTables[siteId].update(\n            { downloadTime: CoreTimeUtils.timestamp() },\n            { id: packageId },\n        );\n    }\n\n}\n\nexport const CoreFilepool = makeSingleton(CoreFilepoolProvider);\n\n/**\n * File actions.\n */\nexport const enum CoreFilepoolFileActions {\n    DOWNLOAD = 'download',\n    DOWNLOADING = 'downloading',\n    DELETED = 'deleted',\n    OUTDATED = 'outdated',\n}\n\n/**\n * Data sent to file events.\n */\nexport type CoreFilepoolFileEventData = {\n    /**\n     * The file ID.\n     */\n    fileId: string;\n\n    /**\n     * The file ID.\n     */\n    action: CoreFilepoolFileActions;\n\n    /**\n     * Whether the action was a success. Only for DOWNLOAD action.\n     */\n    success?: boolean;\n};\n\n/**\n * Data sent to component file events.\n */\nexport type CoreFilepoolComponentFileEventData = CoreFilepoolFileEventData & {\n    /**\n     * The component.\n     */\n    component: string;\n\n    /**\n     * The component ID.\n     */\n    componentId?: string | number;\n};\n\n/**\n * Function called when file download progress ocurred.\n */\nexport type CoreFilepoolOnProgressCallback<T = unknown> = (event: T) => void;\n\n/**\n * Deferred promise for file pool. It's similar to the result of $q.defer() in AngularJS.\n */\ntype CoreFilepoolPromisedValue = CorePromisedValue<void> & {\n    onProgress?: CoreFilepoolOnProgressCallback; // On Progress function.\n};\n\ntype AnchorOrMediaElement =\n    HTMLAnchorElement | HTMLImageElement | HTMLAudioElement | HTMLVideoElement | HTMLSourceElement | HTMLTrackElement;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}