{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModQuizPreflightModalComponent } from '../components/preflight-modal/preflight-modal';\nimport { AddonModQuizAccessRuleDelegate } from './access-rules-delegate';\nimport { AddonModQuizModuleHandlerService } from './handlers/module';\nimport { AddonModQuiz, AddonModQuizProvider } from './quiz';\nimport { AddonModQuizOffline } from './quiz-offline';\nimport * as i0 from \"@angular/core\";\n/**\n * Helper service that provides some features for quiz.\n */\nexport class AddonModQuizHelperProvider {\n  /**\n   * Validate a preflight data or show a modal to input the preflight data if required.\n   * It calls AddonModQuizProvider.startAttempt if a new attempt is needed.\n   *\n   * @param quiz Quiz.\n   * @param accessInfo Quiz access info.\n   * @param preflightData Object where to store the preflight data.\n   * @param attempt Attempt to continue. Don't pass any value if the user needs to start a new attempt.\n   * @param offline Whether the attempt is offline.\n   * @param prefetch Whether user is prefetching.\n   * @param title The title to display in the modal and in the submit button.\n   * @param siteId Site ID. If not defined, current site.\n   * @param retrying Whether we're retrying after a failure.\n   * @returns Promise resolved when the preflight data is validated. The resolve param is the attempt.\n   */\n  getAndCheckPreflightData(quiz, accessInfo, preflightData, attempt, offline, prefetch, title, siteId, retrying) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const rules = accessInfo === null || accessInfo === void 0 ? void 0 : accessInfo.activerulenames;\n      // Check if the user needs to input preflight data.\n      const preflightCheckRequired = yield AddonModQuizAccessRuleDelegate.isPreflightCheckRequired(rules, quiz, attempt, prefetch, siteId);\n      if (preflightCheckRequired) {\n        // Preflight check is required. Show a modal with the preflight form.\n        const data = yield _this.getPreflightData(quiz, accessInfo, attempt, prefetch, title, siteId);\n        // Data entered by the user, add it to preflight data and check it again.\n        Object.assign(preflightData, data);\n      }\n      // Get some fixed preflight data from access rules (data that doesn't require user interaction).\n      yield AddonModQuizAccessRuleDelegate.getFixedPreflightData(rules, quiz, preflightData, attempt, prefetch, siteId);\n      try {\n        // All the preflight data is gathered, now validate it.\n        return yield _this.validatePreflightData(quiz, accessInfo, preflightData, attempt, offline, prefetch, siteId);\n      } catch (error) {\n        if (prefetch) {\n          throw error;\n        } else if (retrying && !preflightCheckRequired) {\n          // We're retrying after a failure, but the preflight check wasn't required.\n          // This means there's something wrong with some access rule or user is offline and data isn't cached.\n          // Don't retry again because it would lead to an infinite loop.\n          throw error;\n        }\n        // Show error and ask for the preflight again.\n        // Wait to show the error because we want it to be shown over the preflight modal.\n        setTimeout(() => {\n          CoreDomUtils.showErrorModalDefault(error, 'core.error', true);\n        }, 100);\n        return _this.getAndCheckPreflightData(quiz, accessInfo, preflightData, attempt, offline, prefetch, title, siteId, true);\n      }\n    })();\n  }\n  /**\n   * Get the preflight data from the user using a modal.\n   *\n   * @param quiz Quiz.\n   * @param accessInfo Quiz access info.\n   * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n   * @param prefetch Whether the user is prefetching the quiz.\n   * @param title The title to display in the modal and in the submit button.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the preflight data. Rejected if user cancels.\n   */\n  getPreflightData(quiz, accessInfo, attempt, prefetch, title, siteId) {\n    return _asyncToGenerator(function* () {\n      const notSupported = [];\n      const rules = accessInfo === null || accessInfo === void 0 ? void 0 : accessInfo.activerulenames;\n      // Check if there is any unsupported rule.\n      rules.forEach(rule => {\n        if (!AddonModQuizAccessRuleDelegate.isAccessRuleSupported(rule)) {\n          notSupported.push(rule);\n        }\n      });\n      if (notSupported.length) {\n        throw new CoreError(Translate.instant('addon.mod_quiz.errorrulesnotsupported') + ' ' + JSON.stringify(notSupported));\n      }\n      // Create and show the modal.\n      const modalData = yield CoreDomUtils.openModal({\n        component: AddonModQuizPreflightModalComponent,\n        componentProps: {\n          title: title,\n          quiz,\n          attempt,\n          prefetch: !!prefetch,\n          siteId: siteId,\n          rules: rules\n        }\n      });\n      if (!modalData) {\n        throw new CoreCanceledError();\n      }\n      return modalData;\n    })();\n  }\n  /**\n   * Gets the mark string from a question HTML.\n   * Example result: \"Marked out of 1.00\".\n   *\n   * @param html Question's HTML.\n   * @returns Question's mark.\n   */\n  getQuestionMarkFromHtml(html) {\n    const element = CoreDomUtils.convertToElement(html);\n    return CoreDomUtils.getContentsOfElement(element, '.grade');\n  }\n  /**\n   * Get a quiz ID by attempt ID.\n   *\n   * @param attemptId Attempt ID.\n   * @param options Other options.\n   * @returns Promise resolved with the quiz ID.\n   */\n  getQuizIdByAttemptId(attemptId, options = {}) {\n    return _asyncToGenerator(function* () {\n      // Use getAttemptReview to retrieve the quiz ID.\n      const reviewData = yield AddonModQuiz.getAttemptReview(attemptId, options);\n      if (reviewData.attempt.quiz) {\n        return reviewData.attempt.quiz;\n      }\n      throw new CoreError('Cannot get quiz ID.');\n    })();\n  }\n  /**\n   * Handle a review link.\n   *\n   * @param attemptId Attempt ID.\n   * @param page Page to load, -1 to all questions in same page.\n   * @param quizId Quiz ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  handleReviewLink(attemptId, page, quizId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const modal = yield CoreDomUtils.showModalLoading();\n      try {\n        if (!quizId) {\n          quizId = yield _this2.getQuizIdByAttemptId(attemptId, {\n            siteId\n          });\n        }\n        const module = yield CoreCourse.getModuleBasicInfoByInstance(quizId, 'quiz', {\n          siteId,\n          readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */\n        });\n        // Go to the review page.\n        yield CoreNavigator.navigateToSitePath(`${AddonModQuizModuleHandlerService.PAGE_NAME}/${module.course}/${module.id}/review/${attemptId}`, {\n          params: {\n            page: page == undefined || isNaN(page) ? -1 : page\n          },\n          siteId\n        });\n      } catch (error) {\n        CoreDomUtils.showErrorModalDefault(error, 'An error occurred while loading the required data.');\n      } finally {\n        modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Add some calculated data to the attempt.\n   *\n   * @param quiz Quiz.\n   * @param attempt Attempt.\n   * @param highlight Whether we should check if attempt should be highlighted.\n   * @param bestGrade Quiz's best grade (formatted). Required if highlight=true.\n   * @param isLastAttempt Whether the attempt is the last one.\n   * @param siteId Site ID.\n   * @returns Quiz attemptw with calculated data.\n   */\n  setAttemptCalculatedData(quiz, attempt, highlight, bestGrade, isLastAttempt, siteId) {\n    return _asyncToGenerator(function* () {\n      const formattedAttempt = attempt;\n      formattedAttempt.rescaledGrade = AddonModQuiz.rescaleGrade(attempt.sumgrades, quiz, false);\n      formattedAttempt.finished = AddonModQuiz.isAttemptFinished(attempt.state);\n      formattedAttempt.readableState = AddonModQuiz.getAttemptReadableState(quiz, attempt);\n      if (quiz.showMarkColumn && formattedAttempt.finished) {\n        formattedAttempt.readableMark = AddonModQuiz.formatGrade(attempt.sumgrades, quiz.decimalpoints);\n      } else {\n        formattedAttempt.readableMark = '';\n      }\n      if (quiz.showGradeColumn && formattedAttempt.finished) {\n        formattedAttempt.readableGrade = AddonModQuiz.formatGrade(Number(formattedAttempt.rescaledGrade), quiz.decimalpoints);\n        // Highlight the highest grade if appropriate.\n        formattedAttempt.highlightGrade = !!(highlight && !attempt.preview && attempt.state == AddonModQuizProvider.ATTEMPT_FINISHED && formattedAttempt.readableGrade == bestGrade);\n      } else {\n        formattedAttempt.readableGrade = '';\n      }\n      if (isLastAttempt || isLastAttempt === undefined) {\n        formattedAttempt.finishedOffline = yield AddonModQuiz.isAttemptFinishedOffline(attempt.id, siteId);\n      }\n      return formattedAttempt;\n    })();\n  }\n  /**\n   * Add some calculated data to the quiz.\n   *\n   * @param quiz Quiz.\n   * @param options Review options.\n   * @returns Quiz data with some calculated more.\n   */\n  setQuizCalculatedData(quiz, options) {\n    const formattedQuiz = quiz;\n    formattedQuiz.sumGradesFormatted = AddonModQuiz.formatGrade(quiz.sumgrades, quiz.decimalpoints);\n    formattedQuiz.gradeFormatted = AddonModQuiz.formatGrade(quiz.grade, quiz.decimalpoints);\n    formattedQuiz.showAttemptColumn = quiz.attempts != 1;\n    formattedQuiz.showGradeColumn = options.someoptions.marks >= AddonModQuizProvider.QUESTION_OPTIONS_MARK_AND_MAX && AddonModQuiz.quizHasGrades(quiz);\n    formattedQuiz.showMarkColumn = formattedQuiz.showGradeColumn && quiz.grade != quiz.sumgrades;\n    formattedQuiz.showFeedbackColumn = !!quiz.hasfeedback && !!options.alloptions.overallfeedback;\n    return formattedQuiz;\n  }\n  /**\n   * Validate the preflight data. It calls AddonModQuizProvider.startAttempt if a new attempt is needed.\n   *\n   * @param quiz Quiz.\n   * @param accessInfo Quiz access info.\n   * @param preflightData Object where to store the preflight data.\n   * @param attempt Attempt to continue. Don't pass any value if the user needs to start a new attempt.\n   * @param offline Whether the attempt is offline.\n   * @param prefetch Whether user is prefetching.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the preflight data is validated.\n   */\n  validatePreflightData(quiz, accessInfo, preflightData, attempt, offline, prefetch, siteId) {\n    return _asyncToGenerator(function* () {\n      const rules = accessInfo.activerulenames;\n      const modOptions = {\n        cmId: quiz.coursemodule,\n        readingStrategy: offline ? 1 /* CoreSitesReadingStrategy.PREFER_CACHE */ : 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      try {\n        if (attempt) {\n          if (attempt.state != AddonModQuizProvider.ATTEMPT_OVERDUE && !attempt.finishedOffline) {\n            var _attempt$currentpage;\n            // We're continuing an attempt. Call getAttemptData to validate the preflight data.\n            yield AddonModQuiz.getAttemptData(attempt.id, (_attempt$currentpage = attempt.currentpage) !== null && _attempt$currentpage !== void 0 ? _attempt$currentpage : 0, preflightData, modOptions);\n            if (offline) {\n              var _storedAttempt$curren;\n              // Get current page stored in local.\n              const storedAttempt = yield CoreUtils.ignoreErrors(AddonModQuizOffline.getAttemptById(attempt.id));\n              attempt.currentpage = (_storedAttempt$curren = storedAttempt === null || storedAttempt === void 0 ? void 0 : storedAttempt.currentpage) !== null && _storedAttempt$curren !== void 0 ? _storedAttempt$curren : attempt.currentpage;\n            }\n          } else {\n            // Attempt is overdue or finished in offline, we can only see the summary.\n            // Call getAttemptSummary to validate the preflight data.\n            yield AddonModQuiz.getAttemptSummary(attempt.id, preflightData, modOptions);\n          }\n        } else {\n          // We're starting a new attempt, call startAttempt.\n          attempt = yield AddonModQuiz.startAttempt(quiz.id, preflightData, false, siteId);\n        }\n        // Preflight data validated.\n        AddonModQuizAccessRuleDelegate.notifyPreflightCheckPassed(rules, quiz, attempt, preflightData, prefetch, siteId);\n        return attempt;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService returned an error, assume the preflight failed.\n          AddonModQuizAccessRuleDelegate.notifyPreflightCheckFailed(rules, quiz, attempt, preflightData, prefetch, siteId);\n        }\n        throw error;\n      }\n    })();\n  }\n}\n_class = AddonModQuizHelperProvider;\n_class.ɵfac = function AddonModQuizHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModQuizHelper = makeSingleton(AddonModQuizHelperProvider);","map":{"version":3,"names":["CoreCanceledError","CoreError","CoreCourse","CoreNavigator","CoreSites","CoreDomUtils","CoreUtils","makeSingleton","Translate","AddonModQuizPreflightModalComponent","AddonModQuizAccessRuleDelegate","AddonModQuizModuleHandlerService","AddonModQuiz","AddonModQuizProvider","AddonModQuizOffline","AddonModQuizHelperProvider","getAndCheckPreflightData","quiz","accessInfo","preflightData","attempt","offline","prefetch","title","siteId","retrying","_this","_asyncToGenerator","rules","activerulenames","preflightCheckRequired","isPreflightCheckRequired","data","getPreflightData","Object","assign","getFixedPreflightData","validatePreflightData","error","setTimeout","showErrorModalDefault","notSupported","forEach","rule","isAccessRuleSupported","push","length","instant","JSON","stringify","modalData","openModal","component","componentProps","getQuestionMarkFromHtml","html","element","convertToElement","getContentsOfElement","getQuizIdByAttemptId","attemptId","options","reviewData","getAttemptReview","handleReviewLink","page","quizId","_this2","getCurrentSiteId","modal","showModalLoading","module","getModuleBasicInfoByInstance","readingStrategy","navigateToSitePath","PAGE_NAME","course","id","params","undefined","isNaN","dismiss","setAttemptCalculatedData","highlight","bestGrade","isLastAttempt","formattedAttempt","rescaledGrade","rescaleGrade","sumgrades","finished","isAttemptFinished","state","readableState","getAttemptReadableState","showMarkColumn","readableMark","formatGrade","decimalpoints","showGradeColumn","readableGrade","Number","highlightGrade","preview","ATTEMPT_FINISHED","finishedOffline","isAttemptFinishedOffline","setQuizCalculatedData","formattedQuiz","sumGradesFormatted","gradeFormatted","grade","showAttemptColumn","attempts","someoptions","marks","QUESTION_OPTIONS_MARK_AND_MAX","quizHasGrades","showFeedbackColumn","hasfeedback","alloptions","overallfeedback","modOptions","cmId","coursemodule","ATTEMPT_OVERDUE","_attempt$currentpage","getAttemptData","currentpage","_storedAttempt$curren","storedAttempt","ignoreErrors","getAttemptById","getAttemptSummary","startAttempt","notifyPreflightCheckPassed","isWebServiceError","notifyPreflightCheckFailed","factory","ɵfac","providedIn","AddonModQuizHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/quiz/services/quiz-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModQuizPreflightModalComponent } from '../components/preflight-modal/preflight-modal';\nimport { AddonModQuizAccessRuleDelegate } from './access-rules-delegate';\nimport { AddonModQuizModuleHandlerService } from './handlers/module';\nimport {\n    AddonModQuiz,\n    AddonModQuizAttemptWSData,\n    AddonModQuizCombinedReviewOptions,\n    AddonModQuizGetQuizAccessInformationWSResponse,\n    AddonModQuizProvider,\n    AddonModQuizQuizWSData,\n} from './quiz';\nimport { AddonModQuizOffline } from './quiz-offline';\n\n/**\n * Helper service that provides some features for quiz.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModQuizHelperProvider {\n\n    /**\n     * Validate a preflight data or show a modal to input the preflight data if required.\n     * It calls AddonModQuizProvider.startAttempt if a new attempt is needed.\n     *\n     * @param quiz Quiz.\n     * @param accessInfo Quiz access info.\n     * @param preflightData Object where to store the preflight data.\n     * @param attempt Attempt to continue. Don't pass any value if the user needs to start a new attempt.\n     * @param offline Whether the attempt is offline.\n     * @param prefetch Whether user is prefetching.\n     * @param title The title to display in the modal and in the submit button.\n     * @param siteId Site ID. If not defined, current site.\n     * @param retrying Whether we're retrying after a failure.\n     * @returns Promise resolved when the preflight data is validated. The resolve param is the attempt.\n     */\n    async getAndCheckPreflightData(\n        quiz: AddonModQuizQuizWSData,\n        accessInfo: AddonModQuizGetQuizAccessInformationWSResponse,\n        preflightData: Record<string, string>,\n        attempt?: AddonModQuizAttemptWSData,\n        offline?: boolean,\n        prefetch?: boolean,\n        title?: string,\n        siteId?: string,\n        retrying?: boolean,\n    ): Promise<AddonModQuizAttemptWSData> {\n\n        const rules = accessInfo?.activerulenames;\n\n        // Check if the user needs to input preflight data.\n        const preflightCheckRequired = await AddonModQuizAccessRuleDelegate.isPreflightCheckRequired(\n            rules,\n            quiz,\n            attempt,\n            prefetch,\n            siteId,\n        );\n\n        if (preflightCheckRequired) {\n            // Preflight check is required. Show a modal with the preflight form.\n            const data = await this.getPreflightData(quiz, accessInfo, attempt, prefetch, title, siteId);\n\n            // Data entered by the user, add it to preflight data and check it again.\n            Object.assign(preflightData, data);\n        }\n\n        // Get some fixed preflight data from access rules (data that doesn't require user interaction).\n        await AddonModQuizAccessRuleDelegate.getFixedPreflightData(rules, quiz, preflightData, attempt, prefetch, siteId);\n\n        try {\n            // All the preflight data is gathered, now validate it.\n            return await this.validatePreflightData(quiz, accessInfo, preflightData, attempt, offline, prefetch, siteId);\n        } catch (error) {\n\n            if (prefetch) {\n                throw error;\n            } else if (retrying && !preflightCheckRequired) {\n                // We're retrying after a failure, but the preflight check wasn't required.\n                // This means there's something wrong with some access rule or user is offline and data isn't cached.\n                // Don't retry again because it would lead to an infinite loop.\n                throw error;\n            }\n\n            // Show error and ask for the preflight again.\n            // Wait to show the error because we want it to be shown over the preflight modal.\n            setTimeout(() => {\n                CoreDomUtils.showErrorModalDefault(error, 'core.error', true);\n            }, 100);\n\n            return this.getAndCheckPreflightData(\n                quiz,\n                accessInfo,\n                preflightData,\n                attempt,\n                offline,\n                prefetch,\n                title,\n                siteId,\n                true,\n            );\n        }\n    }\n\n    /**\n     * Get the preflight data from the user using a modal.\n     *\n     * @param quiz Quiz.\n     * @param accessInfo Quiz access info.\n     * @param attempt The attempt started/continued. If not supplied, user is starting a new attempt.\n     * @param prefetch Whether the user is prefetching the quiz.\n     * @param title The title to display in the modal and in the submit button.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the preflight data. Rejected if user cancels.\n     */\n    async getPreflightData(\n        quiz: AddonModQuizQuizWSData,\n        accessInfo: AddonModQuizGetQuizAccessInformationWSResponse,\n        attempt?: AddonModQuizAttemptWSData,\n        prefetch?: boolean,\n        title?: string,\n        siteId?: string,\n    ): Promise<Record<string, string>> {\n        const notSupported: string[] = [];\n        const rules = accessInfo?.activerulenames;\n\n        // Check if there is any unsupported rule.\n        rules.forEach((rule) => {\n            if (!AddonModQuizAccessRuleDelegate.isAccessRuleSupported(rule)) {\n                notSupported.push(rule);\n            }\n        });\n\n        if (notSupported.length) {\n            throw new CoreError(\n                Translate.instant('addon.mod_quiz.errorrulesnotsupported') + ' ' + JSON.stringify(notSupported),\n            );\n        }\n\n        // Create and show the modal.\n        const modalData = await CoreDomUtils.openModal<Record<string, string>>({\n            component: AddonModQuizPreflightModalComponent,\n            componentProps: {\n                title: title,\n                quiz,\n                attempt,\n                prefetch: !!prefetch,\n                siteId: siteId,\n                rules: rules,\n            },\n        });\n\n        if (!modalData) {\n            throw new CoreCanceledError();\n        }\n\n        return modalData;\n    }\n\n    /**\n     * Gets the mark string from a question HTML.\n     * Example result: \"Marked out of 1.00\".\n     *\n     * @param html Question's HTML.\n     * @returns Question's mark.\n     */\n    getQuestionMarkFromHtml(html: string): string | undefined {\n        const element = CoreDomUtils.convertToElement(html);\n\n        return CoreDomUtils.getContentsOfElement(element, '.grade');\n    }\n\n    /**\n     * Get a quiz ID by attempt ID.\n     *\n     * @param attemptId Attempt ID.\n     * @param options Other options.\n     * @returns Promise resolved with the quiz ID.\n     */\n    async getQuizIdByAttemptId(attemptId: number, options: { cmId?: number; siteId?: string } = {}): Promise<number> {\n        // Use getAttemptReview to retrieve the quiz ID.\n        const reviewData = await AddonModQuiz.getAttemptReview(attemptId, options);\n\n        if (reviewData.attempt.quiz) {\n            return reviewData.attempt.quiz;\n        }\n\n        throw new CoreError('Cannot get quiz ID.');\n    }\n\n    /**\n     * Handle a review link.\n     *\n     * @param attemptId Attempt ID.\n     * @param page Page to load, -1 to all questions in same page.\n     * @param quizId Quiz ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async handleReviewLink(attemptId: number, page?: number, quizId?: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const modal = await CoreDomUtils.showModalLoading();\n\n        try {\n            if (!quizId) {\n                quizId = await this.getQuizIdByAttemptId(attemptId, { siteId });\n            }\n\n            const module = await CoreCourse.getModuleBasicInfoByInstance(\n                quizId,\n                'quiz',\n                { siteId, readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE },\n            );\n\n            // Go to the review page.\n            await CoreNavigator.navigateToSitePath(\n                `${AddonModQuizModuleHandlerService.PAGE_NAME}/${module.course}/${module.id}/review/${attemptId}`,\n                {\n                    params: {\n                        page: page == undefined || isNaN(page) ? -1 : page,\n                    },\n                    siteId,\n                },\n            );\n        } catch (error) {\n            CoreDomUtils.showErrorModalDefault(error, 'An error occurred while loading the required data.');\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Add some calculated data to the attempt.\n     *\n     * @param quiz Quiz.\n     * @param attempt Attempt.\n     * @param highlight Whether we should check if attempt should be highlighted.\n     * @param bestGrade Quiz's best grade (formatted). Required if highlight=true.\n     * @param isLastAttempt Whether the attempt is the last one.\n     * @param siteId Site ID.\n     * @returns Quiz attemptw with calculated data.\n     */\n    async setAttemptCalculatedData(\n        quiz: AddonModQuizQuizData,\n        attempt: AddonModQuizAttemptWSData,\n        highlight?: boolean,\n        bestGrade?: string,\n        isLastAttempt?: boolean,\n        siteId?: string,\n    ): Promise<AddonModQuizAttempt> {\n        const formattedAttempt = <AddonModQuizAttempt> attempt;\n\n        formattedAttempt.rescaledGrade = AddonModQuiz.rescaleGrade(attempt.sumgrades, quiz, false);\n        formattedAttempt.finished = AddonModQuiz.isAttemptFinished(attempt.state);\n        formattedAttempt.readableState = AddonModQuiz.getAttemptReadableState(quiz, attempt);\n\n        if (quiz.showMarkColumn && formattedAttempt.finished) {\n            formattedAttempt.readableMark = AddonModQuiz.formatGrade(attempt.sumgrades, quiz.decimalpoints);\n        } else {\n            formattedAttempt.readableMark = '';\n        }\n\n        if (quiz.showGradeColumn && formattedAttempt.finished) {\n            formattedAttempt.readableGrade = AddonModQuiz.formatGrade(\n                Number(formattedAttempt.rescaledGrade),\n                quiz.decimalpoints,\n            );\n\n            // Highlight the highest grade if appropriate.\n            formattedAttempt.highlightGrade = !!(highlight && !attempt.preview &&\n                attempt.state == AddonModQuizProvider.ATTEMPT_FINISHED && formattedAttempt.readableGrade == bestGrade);\n        } else {\n            formattedAttempt.readableGrade = '';\n        }\n\n        if (isLastAttempt || isLastAttempt === undefined) {\n            formattedAttempt.finishedOffline = await AddonModQuiz.isAttemptFinishedOffline(attempt.id, siteId);\n        }\n\n        return formattedAttempt;\n    }\n\n    /**\n     * Add some calculated data to the quiz.\n     *\n     * @param quiz Quiz.\n     * @param options Review options.\n     * @returns Quiz data with some calculated more.\n     */\n    setQuizCalculatedData(quiz: AddonModQuizQuizWSData, options: AddonModQuizCombinedReviewOptions): AddonModQuizQuizData {\n        const formattedQuiz = <AddonModQuizQuizData> quiz;\n\n        formattedQuiz.sumGradesFormatted = AddonModQuiz.formatGrade(quiz.sumgrades, quiz.decimalpoints);\n        formattedQuiz.gradeFormatted = AddonModQuiz.formatGrade(quiz.grade, quiz.decimalpoints);\n\n        formattedQuiz.showAttemptColumn = quiz.attempts != 1;\n        formattedQuiz.showGradeColumn = options.someoptions.marks >= AddonModQuizProvider.QUESTION_OPTIONS_MARK_AND_MAX &&\n            AddonModQuiz.quizHasGrades(quiz);\n        formattedQuiz.showMarkColumn = formattedQuiz.showGradeColumn && quiz.grade != quiz.sumgrades;\n        formattedQuiz.showFeedbackColumn = !!quiz.hasfeedback && !!options.alloptions.overallfeedback;\n\n        return formattedQuiz;\n    }\n\n    /**\n     * Validate the preflight data. It calls AddonModQuizProvider.startAttempt if a new attempt is needed.\n     *\n     * @param quiz Quiz.\n     * @param accessInfo Quiz access info.\n     * @param preflightData Object where to store the preflight data.\n     * @param attempt Attempt to continue. Don't pass any value if the user needs to start a new attempt.\n     * @param offline Whether the attempt is offline.\n     * @param prefetch Whether user is prefetching.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the preflight data is validated.\n     */\n    async validatePreflightData(\n        quiz: AddonModQuizQuizWSData,\n        accessInfo: AddonModQuizGetQuizAccessInformationWSResponse,\n        preflightData: Record<string, string>,\n        attempt?: AddonModQuizAttempt,\n        offline?: boolean,\n        prefetch?: boolean,\n        siteId?: string,\n    ): Promise<AddonModQuizAttempt> {\n\n        const rules = accessInfo.activerulenames;\n        const modOptions = {\n            cmId: quiz.coursemodule,\n            readingStrategy: offline ? CoreSitesReadingStrategy.PREFER_CACHE : CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        try {\n            if (attempt) {\n                if (attempt.state != AddonModQuizProvider.ATTEMPT_OVERDUE && !attempt.finishedOffline) {\n                    // We're continuing an attempt. Call getAttemptData to validate the preflight data.\n                    await AddonModQuiz.getAttemptData(attempt.id, attempt.currentpage ?? 0, preflightData, modOptions);\n\n                    if (offline) {\n                        // Get current page stored in local.\n                        const storedAttempt = await CoreUtils.ignoreErrors(\n                            AddonModQuizOffline.getAttemptById(attempt.id),\n                        );\n\n                        attempt.currentpage = storedAttempt?.currentpage ?? attempt.currentpage;\n                    }\n                } else {\n                    // Attempt is overdue or finished in offline, we can only see the summary.\n                    // Call getAttemptSummary to validate the preflight data.\n                    await AddonModQuiz.getAttemptSummary(attempt.id, preflightData, modOptions);\n                }\n            } else {\n                // We're starting a new attempt, call startAttempt.\n                attempt = await AddonModQuiz.startAttempt(quiz.id, preflightData, false, siteId);\n            }\n\n            // Preflight data validated.\n            AddonModQuizAccessRuleDelegate.notifyPreflightCheckPassed(\n                rules,\n                quiz,\n                attempt,\n                preflightData,\n                prefetch,\n                siteId,\n            );\n\n            return attempt;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService returned an error, assume the preflight failed.\n                AddonModQuizAccessRuleDelegate.notifyPreflightCheckFailed(\n                    rules,\n                    quiz,\n                    attempt,\n                    preflightData,\n                    prefetch,\n                    siteId,\n                );\n            }\n\n            throw error;\n        }\n    }\n\n}\n\nexport const AddonModQuizHelper = makeSingleton(AddonModQuizHelperProvider);\n\n/**\n * Quiz data with calculated data.\n */\nexport type AddonModQuizQuizData = AddonModQuizQuizWSData & {\n    sumGradesFormatted?: string;\n    gradeFormatted?: string;\n    showAttemptColumn?: boolean;\n    showGradeColumn?: boolean;\n    showMarkColumn?: boolean;\n    showFeedbackColumn?: boolean;\n};\n\n/**\n * Attempt data with calculated data.\n */\nexport type AddonModQuizAttempt = AddonModQuizAttemptWSData & {\n    finishedOffline?: boolean;\n    rescaledGrade?: string;\n    finished?: boolean;\n    readableState?: string[];\n    readableMark?: string;\n    readableGrade?: string;\n    highlightGrade?: boolean;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}