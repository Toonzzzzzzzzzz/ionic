{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { makeSingleton } from '@singletons';\nimport { FEEDBACK_TABLE_NAME } from './database/feedback';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline feedback.\n */\nexport class AddonModFeedbackOfflineProvider {\n  /**\n   * Delete the stored for a certain feedback page.\n   *\n   * @param feedbackId Feedback ID.\n   * @param page Page of the form to delete responses from.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteFeedbackPageResponses(feedbackId, page, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(FEEDBACK_TABLE_NAME, {\n        feedbackid: feedbackId,\n        page: page\n      });\n    })();\n  }\n  /**\n   * Get all the stored feedback responses data from all the feedback.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with entries.\n   */\n  getAllFeedbackResponses(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entries = yield site.getDb().getAllRecords(FEEDBACK_TABLE_NAME);\n      return entries.map(entry => _this.parseResponse(entry));\n    })();\n  }\n  /**\n   * Get all the stored responses from a certain feedback.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with responses.\n   */\n  getFeedbackResponses(feedbackId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entries = yield site.getDb().getRecords(FEEDBACK_TABLE_NAME, {\n        feedbackid: feedbackId\n      });\n      return entries.map(entry => _this2.parseResponse(entry));\n    })();\n  }\n  /**\n   * Get the stored responses for a certain feedback page.\n   *\n   * @param feedbackId Feedback ID.\n   * @param page Page of the form to get responses from.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with responses.\n   */\n  getFeedbackPageResponses(feedbackId, page, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        feedbackid: feedbackId,\n        page: page\n      };\n      const entry = yield site.getDb().getRecord(FEEDBACK_TABLE_NAME, conditions);\n      return _this3.parseResponse(entry);\n    })();\n  }\n  /**\n   * Get if the feedback have something to be synced.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if the feedback have something to be synced.\n   */\n  hasFeedbackOfflineData(feedbackId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const responses = yield _this4.getFeedbackResponses(feedbackId, siteId);\n      return !!responses.length;\n    })();\n  }\n  /**\n   * Parse \"options\" and \"attachments\" columns of a fetched record.\n   *\n   * @param record Record object\n   * @returns Record object with columns parsed.\n   */\n  parseResponse(record) {\n    return Object.assign(record, {\n      responses: CoreTextUtils.parseJSON(record.responses)\n    });\n  }\n  /**\n   * Save page responses to be sent later.\n   *\n   * @param feedbackId Feedback ID.\n   * @param page The page being processed.\n   * @param responses The data to be processed the key is the field name (usually type[index]_id)\n   * @param courseId Course ID the feedback belongs to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  saveResponses(feedbackId, page, responses, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        feedbackid: feedbackId,\n        page: page,\n        courseid: courseId,\n        responses: JSON.stringify(responses),\n        timemodified: CoreTimeUtils.timestamp()\n      };\n      yield site.getDb().insertRecord(FEEDBACK_TABLE_NAME, entry);\n    })();\n  }\n}\n_class = AddonModFeedbackOfflineProvider;\n_class.ɵfac = function AddonModFeedbackOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModFeedbackOffline = makeSingleton(AddonModFeedbackOfflineProvider);","map":{"version":3,"names":["CoreSites","CoreTextUtils","CoreTimeUtils","makeSingleton","FEEDBACK_TABLE_NAME","AddonModFeedbackOfflineProvider","deleteFeedbackPageResponses","feedbackId","page","siteId","_asyncToGenerator","site","getSite","getDb","deleteRecords","feedbackid","getAllFeedbackResponses","_this","entries","getAllRecords","map","entry","parseResponse","getFeedbackResponses","_this2","getRecords","getFeedbackPageResponses","_this3","conditions","getRecord","hasFeedbackOfflineData","_this4","responses","length","record","Object","assign","parseJSON","saveResponses","courseId","courseid","JSON","stringify","timemodified","timestamp","insertRecord","factory","ɵfac","providedIn","AddonModFeedbackOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/feedback/services/feedback-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { makeSingleton } from '@singletons';\nimport { AddonModFeedbackResponseDBRecord, FEEDBACK_TABLE_NAME } from './database/feedback';\nimport { AddonModFeedbackResponseValue } from './feedback';\n\n/**\n * Service to handle offline feedback.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModFeedbackOfflineProvider {\n\n    /**\n     * Delete the stored for a certain feedback page.\n     *\n     * @param feedbackId Feedback ID.\n     * @param page Page of the form to delete responses from.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    async deleteFeedbackPageResponses(feedbackId: number, page: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(FEEDBACK_TABLE_NAME, <Partial<AddonModFeedbackResponseDBRecord>> {\n            feedbackid: feedbackId,\n            page: page,\n        });\n    }\n\n    /**\n     * Get all the stored feedback responses data from all the feedback.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with entries.\n     */\n    async getAllFeedbackResponses(siteId?: string): Promise<AddonModFeedbackOfflineResponse[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entries = await site.getDb().getAllRecords<AddonModFeedbackResponseDBRecord>(FEEDBACK_TABLE_NAME);\n\n        return entries.map(entry => this.parseResponse(entry));\n    }\n\n    /**\n     * Get all the stored responses from a certain feedback.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with responses.\n     */\n    async getFeedbackResponses(feedbackId: number, siteId?: string): Promise<AddonModFeedbackOfflineResponse[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entries = await site.getDb().getRecords<AddonModFeedbackResponseDBRecord>(FEEDBACK_TABLE_NAME, {\n            feedbackid: feedbackId,\n        });\n\n        return entries.map(entry => this.parseResponse(entry));\n    }\n\n    /**\n     * Get the stored responses for a certain feedback page.\n     *\n     * @param feedbackId Feedback ID.\n     * @param page Page of the form to get responses from.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with responses.\n     */\n    async getFeedbackPageResponses(feedbackId: number, page: number, siteId?: string): Promise<AddonModFeedbackOfflineResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModFeedbackResponseDBRecord> = {\n            feedbackid: feedbackId,\n            page: page,\n        };\n\n        const entry = await site.getDb().getRecord<AddonModFeedbackResponseDBRecord>(FEEDBACK_TABLE_NAME, conditions);\n\n        return this.parseResponse(entry);\n    }\n\n    /**\n     * Get if the feedback have something to be synced.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if the feedback have something to be synced.\n     */\n    async hasFeedbackOfflineData(feedbackId: number, siteId?: string): Promise<boolean> {\n        const responses = await this.getFeedbackResponses(feedbackId, siteId);\n\n        return !!responses.length;\n    }\n\n    /**\n     * Parse \"options\" and \"attachments\" columns of a fetched record.\n     *\n     * @param record Record object\n     * @returns Record object with columns parsed.\n     */\n    protected parseResponse(record: AddonModFeedbackResponseDBRecord): AddonModFeedbackOfflineResponse {\n        return Object.assign(record, {\n            responses: <Record<string, AddonModFeedbackResponseValue>> CoreTextUtils.parseJSON(record.responses),\n        });\n    }\n\n    /**\n     * Save page responses to be sent later.\n     *\n     * @param feedbackId Feedback ID.\n     * @param page The page being processed.\n     * @param responses The data to be processed the key is the field name (usually type[index]_id)\n     * @param courseId Course ID the feedback belongs to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async saveResponses(\n        feedbackId: number,\n        page: number,\n        responses: Record<string, AddonModFeedbackResponseValue>,\n        courseId: number,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entry: AddonModFeedbackResponseDBRecord = {\n            feedbackid: feedbackId,\n            page: page,\n            courseid: courseId,\n            responses: JSON.stringify(responses),\n            timemodified: CoreTimeUtils.timestamp(),\n        };\n\n        await site.getDb().insertRecord(FEEDBACK_TABLE_NAME, entry);\n    }\n\n}\n\nexport const AddonModFeedbackOffline = makeSingleton(AddonModFeedbackOfflineProvider);\n\n/**\n * Feedback offline response with parsed data.\n */\nexport type AddonModFeedbackOfflineResponse = Omit<AddonModFeedbackResponseDBRecord, 'responses'> & {\n    responses: Record<string, AddonModFeedbackResponseValue>;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}