{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreFile } from '@services/file';\nimport { CoreFilepool } from '@services/filepool';\nimport { CorePlatform } from '@services/platform';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModScorm, AddonModScormProvider } from '../scorm';\nimport { AddonModScormSync } from '../scorm-sync';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to prefetch SCORMs.\n */\nexport class AddonModScormPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n  constructor() {\n    super(...arguments);\n    this.name = 'AddonModScorm';\n    this.modName = 'scorm';\n    this.component = AddonModScormProvider.COMPONENT;\n    this.updatesNames = /^configuration$|^.*files$|^tracks$/;\n  }\n  /**\n   * @inheritdoc\n   */\n  download(module, courseId, dirPath, onProgress) {\n    return this.prefetchPackage(module, courseId, siteId => this.downloadOrPrefetchScorm(module, courseId, true, false, onProgress, siteId));\n  }\n  /**\n   * Download or prefetch a SCORM.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @param prefetch True to prefetch, false to download right away.\n   * @param onProgress Function to call on progress.\n   * @param siteId Site ID.\n   * @returns Promise resolved with the \"extra\" data to store: the hash of the file.\n   */\n  downloadOrPrefetchScorm(module, courseId, single, prefetch, onProgress, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _scorm$sha1hash;\n      const scorm = yield _this.getScorm(module, courseId, siteId);\n      const files = _this.getIntroFilesFromInstance(module, scorm);\n      yield Promise.all([\n      // Download the SCORM file.\n      _this.downloadOrPrefetchMainFileIfNeeded(scorm, prefetch, onProgress, siteId),\n      // Download WS data. If it fails we don't want to fail the whole download, so we'll ignore the error for now.\n      // @todo Implement a warning system so the user knows which SCORMs have failed.\n      CoreUtils.ignoreErrors(_this.fetchWSData(scorm, siteId)),\n      // Download intro files, ignoring errors.\n      CoreUtils.ignoreErrors(CoreFilepool.downloadOrPrefetchFiles(siteId, files, prefetch, false, _this.component, module.id))]);\n      // Success, return the hash.\n      return (_scorm$sha1hash = scorm.sha1hash) !== null && _scorm$sha1hash !== void 0 ? _scorm$sha1hash : '';\n    })();\n  }\n  /**\n   * Downloads/Prefetches and unzips the SCORM package.\n   *\n   * @param scorm SCORM object.\n   * @param prefetch True if prefetch, false otherwise.\n   * @param onProgress Function to call on progress.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the file is downloaded and unzipped.\n   */\n  downloadOrPrefetchMainFile(scorm, prefetch, onProgress, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _scorm$moduleurl;\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const packageUrl = AddonModScorm.getPackageUrl(scorm);\n      // Get the folder where the unzipped files will be.\n      const dirPath = yield AddonModScorm.getScormFolder((_scorm$moduleurl = scorm.moduleurl) !== null && _scorm$moduleurl !== void 0 ? _scorm$moduleurl : '');\n      // Notify that the download is starting.\n      onProgress && onProgress({\n        message: 'core.downloading'\n      });\n      // Download the ZIP file to the filepool.\n      if (prefetch) {\n        yield CoreFilepool.addToQueueByUrl(siteId, packageUrl, _this2.component, scorm.coursemodule, undefined, undefined, event => _this2.downloadProgress(true, onProgress, event));\n      } else {\n        yield CoreFilepool.downloadUrl(siteId, packageUrl, true, _this2.component, scorm.coursemodule, undefined, event => _this2.downloadProgress(true, onProgress, event));\n      }\n      // Get the ZIP file path.\n      const zipPath = yield CoreFilepool.getFilePathByUrl(siteId, packageUrl);\n      // Notify that the unzip is starting.\n      onProgress && onProgress({\n        message: 'core.unzipping'\n      });\n      // Unzip and delete the zip when finished.\n      yield CoreFile.unzipFile(zipPath, dirPath, event => _this2.downloadProgress(false, onProgress, event));\n      yield CoreUtils.ignoreErrors(CoreFilepool.removeFileByUrl(siteId, packageUrl));\n    })();\n  }\n  /**\n   * Downloads/Prefetches and unzips the SCORM package if it should be downloaded.\n   *\n   * @param scorm SCORM object.\n   * @param prefetch True if prefetch, false otherwise.\n   * @param onProgress Function to call on progress.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the file is downloaded and unzipped.\n   */\n  downloadOrPrefetchMainFileIfNeeded(scorm, prefetch, onProgress, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const result = AddonModScorm.isScormUnsupported(scorm);\n      if (result) {\n        throw new CoreError(Translate.instant(result));\n      }\n      // First verify that the file needs to be downloaded.\n      // It needs to be checked manually because the ZIP file is deleted after unzipped, so the filepool will always download it.\n      const download = yield AddonModScorm.shouldDownloadMainFile(scorm, undefined, siteId);\n      if (download) {\n        yield _this3.downloadOrPrefetchMainFile(scorm, prefetch, onProgress, siteId);\n      }\n    })();\n  }\n  /**\n   * Function that converts a regular ProgressEvent into a AddonModScormProgressEvent.\n   *\n   * @param downloading True when downloading, false when unzipping.\n   * @param onProgress Function to call on progress.\n   * @param progress Event returned by the download function.\n   */\n  downloadProgress(downloading, onProgress, progress) {\n    if (onProgress && progress && progress.loaded) {\n      onProgress({\n        downloading,\n        progress\n      });\n    }\n  }\n  /**\n   * Get WS data for SCORM.\n   *\n   * @param scorm SCORM object.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is prefetched.\n   */\n  fetchWSData(scorm, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const modOptions = {\n        cmId: scorm.coursemodule,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      yield Promise.all([\n      // Prefetch number of attempts (including not completed).\n      _this4.fetchAttempts(scorm, modOptions),\n      // Prefetch SCOs.\n      AddonModScorm.getScos(scorm.id, modOptions),\n      // Prefetch access information.\n      AddonModScorm.getAccessInformation(scorm.id, modOptions)]);\n    })();\n  }\n  /**\n   * Fetch attempts WS data.\n   *\n   * @param scorm SCORM object.\n   * @param modOptions Options.\n   * @returns Promise resolved when done.\n   */\n  fetchAttempts(scorm, modOptions) {\n    return _asyncToGenerator(function* () {\n      // If it fails, assume we have no attempts.\n      const numAttempts = yield CoreUtils.ignoreErrors(AddonModScorm.getAttemptCountOnline(scorm.id, modOptions), 0);\n      if (numAttempts <= 0) {\n        // No attempts. We'll still try to get user data to be able to identify SCOs not visible and so.\n        yield AddonModScorm.getScormUserDataOnline(scorm.id, 0, modOptions);\n        return;\n      }\n      // Get user data for each attempt.\n      const promises = [];\n      for (let i = 1; i <= numAttempts; i++) {\n        promises.push(AddonModScorm.getScormUserDataOnline(scorm.id, i, modOptions).catch(error => {\n          // Ignore failures of all the attempts that aren't the last one.\n          if (i == numAttempts) {\n            throw error;\n          }\n        }));\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  getDownloadSize(module, courseId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const scorm = yield _this5.getScorm(module, courseId);\n      if (AddonModScorm.isScormUnsupported(scorm)) {\n        return {\n          size: -1,\n          total: false\n        };\n      } else if (!scorm.packagesize) {\n        // We don't have package size, try to calculate it.\n        const size = yield AddonModScorm.calculateScormSize(scorm);\n        return {\n          size: size,\n          total: true\n        };\n      } else {\n        return {\n          size: scorm.packagesize,\n          total: true\n        };\n      }\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  getDownloadedSize(module, courseId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      var _scorm$moduleurl2;\n      const scorm = yield _this6.getScorm(module, courseId);\n      // Get the folder where SCORM should be unzipped.\n      const path = yield AddonModScorm.getScormFolder((_scorm$moduleurl2 = scorm.moduleurl) !== null && _scorm$moduleurl2 !== void 0 ? _scorm$moduleurl2 : '');\n      return CoreFile.getDirectorySize(path);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  getFiles(module, courseId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const scorm = yield _this7.getScorm(module, courseId);\n        return AddonModScorm.getScormFileList(scorm);\n      } catch (_unused) {\n        // SCORM not found, return empty list.\n        return [];\n      }\n    })();\n  }\n  /**\n   * Get the SCORM instance from a module instance.\n   *\n   * @param module Module.\n   * @param courseId Course ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved with the SCORM.\n   */\n  getScorm(module, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      let moduleUrl = 'url' in module ? module.url : undefined;\n      if (!moduleUrl) {\n        module = yield CoreCourse.getModule(module.id, module.course, undefined, true, false, siteId);\n        moduleUrl = module.url;\n      }\n      return AddonModScorm.getScorm(courseId, module.id, {\n        moduleUrl,\n        siteId\n      });\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateContent(moduleId, courseId) {\n    return AddonModScorm.invalidateContent(moduleId, courseId);\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateModule(module, courseId) {\n    // Invalidate the calls required to check if a SCORM is downloadable.\n    return AddonModScorm.invalidateScormData(courseId);\n  }\n  /**\n   * @inheritdoc\n   */\n  isDownloadable(module, courseId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const scorm = yield _this8.getScorm(module, courseId);\n      if (scorm.warningMessage) {\n        // SCORM closed or not opened yet.\n        return false;\n      }\n      if (AddonModScorm.isScormUnsupported(scorm)) {\n        return false;\n      }\n      return true;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  prefetch(module, courseId, single, dirPath, onProgress) {\n    return this.prefetchPackage(module, courseId, siteId => this.downloadOrPrefetchScorm(module, courseId, !!single, true, onProgress, siteId));\n  }\n  /**\n   * Remove module downloaded files. If not defined, we'll use getFiles to remove them (slow).\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when done.\n   */\n  removeFiles(module, courseId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      var _scorm$moduleurl3;\n      const siteId = CoreSites.getCurrentSiteId();\n      const scorm = yield _this9.getScorm(module, courseId, siteId);\n      // Get the folder where SCORM should be unzipped.\n      const path = yield AddonModScorm.getScormFolder((_scorm$moduleurl3 = scorm.moduleurl) !== null && _scorm$moduleurl3 !== void 0 ? _scorm$moduleurl3 : '');\n      const promises = [];\n      // Remove the unzipped folder.\n      promises.push(CoreFile.removeDir(path).catch(error => {\n        if (error && (error.code == 1 || !CorePlatform.isMobile())) {\n          // Not found, ignore error.\n        } else {\n          throw error;\n        }\n      }));\n      // Delete other files.\n      promises.push(CoreFilepool.removeFilesByComponent(siteId, _this9.component, module.id));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Sync a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  sync(module, courseId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const scorm = yield _this10.getScorm(module, courseId, siteId);\n      return AddonModScormSync.syncScorm(scorm, siteId);\n    })();\n  }\n}\n_class = AddonModScormPrefetchHandlerService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵAddonModScormPrefetchHandlerService_BaseFactory;\n  return function AddonModScormPrefetchHandlerService_Factory(t) {\n    return (ɵAddonModScormPrefetchHandlerService_BaseFactory || (ɵAddonModScormPrefetchHandlerService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModScormPrefetchHandler = makeSingleton(AddonModScormPrefetchHandlerService);","map":{"version":3,"names":["CoreError","CoreCourseActivityPrefetchHandlerBase","CoreCourse","CoreFile","CoreFilepool","CorePlatform","CoreSites","CoreUtils","makeSingleton","Translate","AddonModScorm","AddonModScormProvider","AddonModScormSync","AddonModScormPrefetchHandlerService","constructor","name","modName","component","COMPONENT","updatesNames","download","module","courseId","dirPath","onProgress","prefetchPackage","siteId","downloadOrPrefetchScorm","single","prefetch","_this","_asyncToGenerator","_scorm$sha1hash","scorm","getScorm","files","getIntroFilesFromInstance","Promise","all","downloadOrPrefetchMainFileIfNeeded","ignoreErrors","fetchWSData","downloadOrPrefetchFiles","id","sha1hash","downloadOrPrefetchMainFile","_this2","_scorm$moduleurl","getCurrentSiteId","packageUrl","getPackageUrl","getScormFolder","moduleurl","message","addToQueueByUrl","coursemodule","undefined","event","downloadProgress","downloadUrl","zipPath","getFilePathByUrl","unzipFile","removeFileByUrl","_this3","result","isScormUnsupported","instant","shouldDownloadMainFile","downloading","progress","loaded","_this4","modOptions","cmId","readingStrategy","fetchAttempts","getScos","getAccessInformation","numAttempts","getAttemptCountOnline","getScormUserDataOnline","promises","i","push","catch","error","getDownloadSize","_this5","size","total","packagesize","calculateScormSize","getDownloadedSize","_this6","_scorm$moduleurl2","path","getDirectorySize","getFiles","_this7","getScormFileList","_unused","moduleUrl","url","getModule","course","invalidateContent","moduleId","invalidateModule","invalidateScormData","isDownloadable","_this8","warningMessage","removeFiles","_this9","_scorm$moduleurl3","removeDir","code","isMobile","removeFilesByComponent","sync","_this10","syncScorm","t","factory","ɵfac","providedIn","AddonModScormPrefetchHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/scorm/services/handlers/prefetch.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourse, CoreCourseAnyModuleData, CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreFile } from '@services/file';\nimport { CoreFilepool } from '@services/filepool';\nimport { CorePlatform } from '@services/platform';\nimport { CoreFileSizeSum } from '@services/plugin-file-delegate';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModScorm, AddonModScormProvider, AddonModScormScorm } from '../scorm';\nimport { AddonModScormSync } from '../scorm-sync';\n\n/**\n * Handler to prefetch SCORMs.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModScormPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n\n    name = 'AddonModScorm';\n    modName = 'scorm';\n    component = AddonModScormProvider.COMPONENT;\n    updatesNames = /^configuration$|^.*files$|^tracks$/;\n\n    /**\n     * @inheritdoc\n     */\n    download(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        dirPath?: string,\n        onProgress?: AddonModScormProgressCallback,\n    ): Promise<void> {\n        return this.prefetchPackage(\n            module,\n            courseId,\n            (siteId) => this.downloadOrPrefetchScorm(module, courseId, true, false, onProgress, siteId),\n        );\n    }\n\n    /**\n     * Download or prefetch a SCORM.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param prefetch True to prefetch, false to download right away.\n     * @param onProgress Function to call on progress.\n     * @param siteId Site ID.\n     * @returns Promise resolved with the \"extra\" data to store: the hash of the file.\n     */\n    protected async downloadOrPrefetchScorm(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        single: boolean,\n        prefetch: boolean,\n        onProgress: AddonModScormProgressCallback | undefined,\n        siteId: string,\n    ): Promise<string> {\n\n        const scorm = await this.getScorm(module, courseId, siteId);\n\n        const files = this.getIntroFilesFromInstance(module, scorm);\n\n        await Promise.all([\n            // Download the SCORM file.\n            this.downloadOrPrefetchMainFileIfNeeded(scorm, prefetch, onProgress, siteId),\n            // Download WS data. If it fails we don't want to fail the whole download, so we'll ignore the error for now.\n            // @todo Implement a warning system so the user knows which SCORMs have failed.\n            CoreUtils.ignoreErrors(this.fetchWSData(scorm, siteId)),\n            // Download intro files, ignoring errors.\n            CoreUtils.ignoreErrors(CoreFilepool.downloadOrPrefetchFiles(siteId, files, prefetch, false, this.component, module.id)),\n        ]);\n\n        // Success, return the hash.\n        return scorm.sha1hash ?? '';\n    }\n\n    /**\n     * Downloads/Prefetches and unzips the SCORM package.\n     *\n     * @param scorm SCORM object.\n     * @param prefetch True if prefetch, false otherwise.\n     * @param onProgress Function to call on progress.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the file is downloaded and unzipped.\n     */\n    protected async downloadOrPrefetchMainFile(\n        scorm: AddonModScormScorm,\n        prefetch?: boolean,\n        onProgress?: AddonModScormProgressCallback,\n        siteId?: string,\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const packageUrl = AddonModScorm.getPackageUrl(scorm);\n\n        // Get the folder where the unzipped files will be.\n        const dirPath = await AddonModScorm.getScormFolder(scorm.moduleurl ?? '');\n\n        // Notify that the download is starting.\n        onProgress && onProgress({ message: 'core.downloading' });\n\n        // Download the ZIP file to the filepool.\n        if (prefetch) {\n            await CoreFilepool.addToQueueByUrl(\n                siteId,\n                packageUrl,\n                this.component,\n                scorm.coursemodule,\n                undefined,\n                undefined,\n                (event: ProgressEvent<EventTarget>) => this.downloadProgress(true, onProgress, event),\n            );\n        } else {\n            await CoreFilepool.downloadUrl(\n                siteId,\n                packageUrl,\n                true,\n                this.component,\n                scorm.coursemodule,\n                undefined,\n                (event: ProgressEvent<EventTarget>) => this.downloadProgress(true, onProgress, event),\n            );\n        }\n\n        // Get the ZIP file path.\n        const zipPath = await CoreFilepool.getFilePathByUrl(siteId, packageUrl);\n\n        // Notify that the unzip is starting.\n        onProgress && onProgress({ message: 'core.unzipping' });\n\n        // Unzip and delete the zip when finished.\n        await CoreFile.unzipFile(\n            zipPath,\n            dirPath,\n            (event: ProgressEvent<EventTarget>) => this.downloadProgress(false, onProgress, event),\n        );\n\n        await CoreUtils.ignoreErrors(CoreFilepool.removeFileByUrl(siteId, packageUrl));\n    }\n\n    /**\n     * Downloads/Prefetches and unzips the SCORM package if it should be downloaded.\n     *\n     * @param scorm SCORM object.\n     * @param prefetch True if prefetch, false otherwise.\n     * @param onProgress Function to call on progress.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the file is downloaded and unzipped.\n     */\n    protected async downloadOrPrefetchMainFileIfNeeded(\n        scorm: AddonModScormScorm,\n        prefetch?: boolean,\n        onProgress?: AddonModScormProgressCallback,\n        siteId?: string,\n    ): Promise<void> {\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const result = AddonModScorm.isScormUnsupported(scorm);\n\n        if (result) {\n            throw new CoreError(Translate.instant(result));\n        }\n\n        // First verify that the file needs to be downloaded.\n        // It needs to be checked manually because the ZIP file is deleted after unzipped, so the filepool will always download it.\n        const download = await AddonModScorm.shouldDownloadMainFile(scorm, undefined, siteId);\n\n        if (download) {\n            await this.downloadOrPrefetchMainFile(scorm, prefetch, onProgress, siteId);\n        }\n    }\n\n    /**\n     * Function that converts a regular ProgressEvent into a AddonModScormProgressEvent.\n     *\n     * @param downloading True when downloading, false when unzipping.\n     * @param onProgress Function to call on progress.\n     * @param progress Event returned by the download function.\n     */\n    protected downloadProgress(downloading: boolean, onProgress?: AddonModScormProgressCallback, progress?: ProgressEvent): void {\n        if (onProgress && progress && progress.loaded) {\n            onProgress({ downloading, progress });\n        }\n    }\n\n    /**\n     * Get WS data for SCORM.\n     *\n     * @param scorm SCORM object.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is prefetched.\n     */\n    async fetchWSData(scorm: AddonModScormScorm, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const modOptions: CoreCourseCommonModWSOptions = {\n            cmId: scorm.coursemodule,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        await Promise.all([\n            // Prefetch number of attempts (including not completed).\n            this.fetchAttempts(scorm, modOptions),\n            // Prefetch SCOs.\n            AddonModScorm.getScos(scorm.id, modOptions),\n            // Prefetch access information.\n            AddonModScorm.getAccessInformation(scorm.id, modOptions),\n        ]);\n    }\n\n    /**\n     * Fetch attempts WS data.\n     *\n     * @param scorm SCORM object.\n     * @param modOptions Options.\n     * @returns Promise resolved when done.\n     */\n    async fetchAttempts(scorm: AddonModScormScorm, modOptions: CoreCourseCommonModWSOptions): Promise<void> {\n        // If it fails, assume we have no attempts.\n        const numAttempts = await CoreUtils.ignoreErrors(AddonModScorm.getAttemptCountOnline(scorm.id, modOptions), 0);\n\n        if (numAttempts <= 0) {\n            // No attempts. We'll still try to get user data to be able to identify SCOs not visible and so.\n            await AddonModScorm.getScormUserDataOnline(scorm.id, 0, modOptions);\n\n            return;\n        }\n\n        // Get user data for each attempt.\n        const promises: Promise<unknown>[] = [];\n\n        for (let i = 1; i <= numAttempts; i++) {\n            promises.push(AddonModScorm.getScormUserDataOnline(scorm.id, i, modOptions).catch((error) => {\n                // Ignore failures of all the attempts that aren't the last one.\n                if (i == numAttempts) {\n                    throw error;\n                }\n            }));\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getDownloadSize(module: CoreCourseAnyModuleData, courseId: number): Promise<CoreFileSizeSum> {\n        const scorm = await this.getScorm(module, courseId);\n\n        if (AddonModScorm.isScormUnsupported(scorm)) {\n            return { size: -1, total: false };\n        } else if (!scorm.packagesize) {\n            // We don't have package size, try to calculate it.\n            const size = await AddonModScorm.calculateScormSize(scorm);\n\n            return { size: size, total: true };\n        } else {\n            return { size: scorm.packagesize, total: true };\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getDownloadedSize(module: CoreCourseAnyModuleData, courseId: number): Promise<number> {\n        const scorm = await this.getScorm(module, courseId);\n\n        // Get the folder where SCORM should be unzipped.\n        const path = await AddonModScorm.getScormFolder(scorm.moduleurl ?? '');\n\n        return CoreFile.getDirectorySize(path);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<CoreWSFile[]> {\n        try {\n            const scorm = await this.getScorm(module, courseId);\n\n            return AddonModScorm.getScormFileList(scorm);\n        } catch {\n            // SCORM not found, return empty list.\n            return [];\n        }\n    }\n\n    /**\n     * Get the SCORM instance from a module instance.\n     *\n     * @param module Module.\n     * @param courseId Course ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved with the SCORM.\n     */\n    protected async getScorm(module: CoreCourseAnyModuleData, courseId: number, siteId?: string): Promise<AddonModScormScorm> {\n        let moduleUrl = 'url' in module ? module.url : undefined;\n        if (!moduleUrl) {\n            module = await CoreCourse.getModule(module.id, module.course, undefined, true, false, siteId);\n\n            moduleUrl = module.url;\n        }\n\n        return AddonModScorm.getScorm(courseId, module.id, { moduleUrl, siteId });\n    }\n\n    /**\n     * @inheritdoc\n     */\n    invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        return AddonModScorm.invalidateContent(moduleId, courseId);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    invalidateModule(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        // Invalidate the calls required to check if a SCORM is downloadable.\n        return AddonModScorm.invalidateScormData(courseId);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async isDownloadable(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        const scorm = await this.getScorm(module, courseId);\n\n        if (scorm.warningMessage) {\n            // SCORM closed or not opened yet.\n            return false;\n        }\n\n        if (AddonModScorm.isScormUnsupported(scorm)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    prefetch(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        single?: boolean,\n        dirPath?: string,\n        onProgress?: AddonModScormProgressCallback,\n    ): Promise<void> {\n        return this.prefetchPackage(\n            module,\n            courseId,\n            (siteId) => this.downloadOrPrefetchScorm(module, courseId, !!single, true, onProgress, siteId),\n        );\n    }\n\n    /**\n     * Remove module downloaded files. If not defined, we'll use getFiles to remove them (slow).\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when done.\n     */\n    async removeFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        const scorm = await this.getScorm(module, courseId, siteId);\n\n        // Get the folder where SCORM should be unzipped.\n        const path = await AddonModScorm.getScormFolder(scorm.moduleurl ?? '');\n\n        const promises: Promise<unknown>[] = [];\n\n        // Remove the unzipped folder.\n        promises.push(CoreFile.removeDir(path).catch((error) => {\n            if (error && (error.code == 1 || !CorePlatform.isMobile())) {\n                // Not found, ignore error.\n            } else {\n                throw error;\n            }\n        }));\n\n        // Delete other files.\n        promises.push(CoreFilepool.removeFilesByComponent(siteId, this.component, module.id));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Sync a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async sync(module: CoreCourseAnyModuleData, courseId: number, siteId?: string): Promise<unknown> {\n        const scorm = await this.getScorm(module, courseId, siteId);\n\n        return AddonModScormSync.syncScorm(scorm, siteId);\n    }\n\n}\n\nexport const AddonModScormPrefetchHandler = makeSingleton(AddonModScormPrefetchHandlerService);\n\n/**\n * Progress event used when downloading a SCORM.\n */\nexport type AddonModScormProgressEvent = {\n    downloading?: boolean; // Whether the event is due to the download of a chunk of data.\n    progress?: ProgressEvent; // Progress event sent by the download.\n    message?: string; // A message related to the progress, used to notify that a certain step of the download has started.\n};\n\n/**\n * Progress callback when downloading a SCORM.\n */\nexport type AddonModScormProgressCallback = (event: AddonModScormProgressEvent) => void;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}