{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreDelegate } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreQuestionDelegate } from './question-delegate';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./handlers/default-behaviour\";\n/**\n * Delegate to register question behaviour handlers.\n */\nexport class CoreQuestionBehaviourDelegateService extends CoreDelegate {\n  constructor(defaultHandler) {\n    super('CoreQuestionBehaviourDelegate', true);\n    this.defaultHandler = defaultHandler;\n    this.handlerNameProperty = 'type';\n  }\n  /**\n   * Determine a question new state based on its answer(s).\n   *\n   * @param behaviour Name of the behaviour.\n   * @param component Component the question belongs to.\n   * @param attemptId Attempt ID the question belongs to.\n   * @param question The question.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with state.\n   */\n  determineNewState(behaviour, component, attemptId, question, componentId, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      behaviour = CoreQuestionDelegate.getBehaviourForQuestion(question, behaviour);\n      return _this.executeFunctionOnEnabled(behaviour, 'determineNewState', [component, attemptId, question, componentId, siteId]);\n    })();\n  }\n  /**\n   * Handle a question behaviour.\n   * If the behaviour requires a submit button, it should add it to question.behaviourButtons.\n   * If the behaviour requires to show some extra data, it should return a directive to render it.\n   *\n   * @param behaviour Default behaviour.\n   * @param question The question.\n   * @returns Promise resolved with components to render some extra data in the question.\n   */\n  handleQuestion(behaviour, question) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      behaviour = CoreQuestionDelegate.getBehaviourForQuestion(question, behaviour);\n      return _this2.executeFunctionOnEnabled(behaviour, 'handleQuestion', [question]);\n    })();\n  }\n  /**\n   * Check if a question behaviour is supported.\n   *\n   * @param behaviour Name of the behaviour.\n   * @returns Whether it's supported.\n   */\n  isBehaviourSupported(behaviour) {\n    return this.hasHandler(behaviour, true);\n  }\n}\n_class = CoreQuestionBehaviourDelegateService;\n_class.ɵfac = function CoreQuestionBehaviourDelegateService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.CoreQuestionBehaviourDefaultHandler));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreQuestionBehaviourDelegate = makeSingleton(CoreQuestionBehaviourDelegateService);","map":{"version":3,"names":["CoreDelegate","makeSingleton","CoreQuestionDelegate","CoreQuestionBehaviourDelegateService","constructor","defaultHandler","handlerNameProperty","determineNewState","behaviour","component","attemptId","question","componentId","siteId","_this","_asyncToGenerator","getBehaviourForQuestion","executeFunctionOnEnabled","handleQuestion","_this2","isBehaviourSupported","hasHandler","i0","ɵɵinject","i1","CoreQuestionBehaviourDefaultHandler","factory","ɵfac","providedIn","CoreQuestionBehaviourDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/question/services/behaviour-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\n\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport { CoreQuestionBehaviourDefaultHandler } from './handlers/default-behaviour';\nimport { CoreQuestionQuestionParsed, CoreQuestionsAnswers, CoreQuestionState } from './question';\nimport { CoreQuestionDelegate } from './question-delegate';\n\n/**\n * Interface that all question behaviour handlers must implement.\n */\nexport interface CoreQuestionBehaviourHandler extends CoreDelegateHandler {\n    /**\n     * Type of the behaviour the handler supports. E.g. 'adaptive'.\n     */\n    type: string;\n\n    /**\n     * Determine a question new state based on its answer(s).\n     *\n     * @param component Component the question belongs to.\n     * @param attemptId Attempt ID the question belongs to.\n     * @param question The question.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns State (or promise resolved with state).\n     */\n    determineNewState?(\n        component: string,\n        attemptId: number,\n        question: CoreQuestionQuestionWithAnswers,\n        componentId: string | number,\n        siteId?: string,\n    ): CoreQuestionState | Promise<CoreQuestionState>;\n\n    /**\n     * Handle a question behaviour.\n     * If the behaviour requires a submit button, it should add it to question.behaviourButtons.\n     * If the behaviour requires to show some extra data, it should return the components to render it.\n     *\n     * @param question The question.\n     * @returns Components (or promise resolved with components) to render some extra data in the question\n     *         (e.g. certainty options). Don't return anything if no extra data is required.\n     */\n    handleQuestion?(question: CoreQuestionQuestionParsed): void | Type<unknown>[] | Promise<Type<unknown>[]>;\n}\n\n/**\n * Delegate to register question behaviour handlers.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreQuestionBehaviourDelegateService extends CoreDelegate<CoreQuestionBehaviourHandler> {\n\n    protected handlerNameProperty = 'type';\n\n    constructor(protected defaultHandler: CoreQuestionBehaviourDefaultHandler) {\n        super('CoreQuestionBehaviourDelegate', true);\n    }\n\n    /**\n     * Determine a question new state based on its answer(s).\n     *\n     * @param behaviour Name of the behaviour.\n     * @param component Component the question belongs to.\n     * @param attemptId Attempt ID the question belongs to.\n     * @param question The question.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with state.\n     */\n    async determineNewState(\n        behaviour: string,\n        component: string,\n        attemptId: number,\n        question: CoreQuestionQuestionWithAnswers,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<CoreQuestionState | undefined> {\n        behaviour = CoreQuestionDelegate.getBehaviourForQuestion(question, behaviour);\n\n        return this.executeFunctionOnEnabled(\n            behaviour,\n            'determineNewState',\n            [component, attemptId, question, componentId, siteId],\n        );\n    }\n\n    /**\n     * Handle a question behaviour.\n     * If the behaviour requires a submit button, it should add it to question.behaviourButtons.\n     * If the behaviour requires to show some extra data, it should return a directive to render it.\n     *\n     * @param behaviour Default behaviour.\n     * @param question The question.\n     * @returns Promise resolved with components to render some extra data in the question.\n     */\n    async handleQuestion(behaviour: string, question: CoreQuestionQuestionParsed): Promise<Type<unknown>[] | undefined> {\n        behaviour = CoreQuestionDelegate.getBehaviourForQuestion(question, behaviour);\n\n        return this.executeFunctionOnEnabled(behaviour, 'handleQuestion', [question]);\n    }\n\n    /**\n     * Check if a question behaviour is supported.\n     *\n     * @param behaviour Name of the behaviour.\n     * @returns Whether it's supported.\n     */\n    isBehaviourSupported(behaviour: string): boolean {\n        return this.hasHandler(behaviour, true);\n    }\n\n}\n\nexport const CoreQuestionBehaviourDelegate = makeSingleton(CoreQuestionBehaviourDelegateService);\n\n/**\n * Answers classified by question slot.\n */\nexport type CoreQuestionQuestionWithAnswers = CoreQuestionQuestionParsed & {\n    answers: CoreQuestionsAnswers;\n};\n"],"mappings":";;AAgBA,SAASA,YAAY,QAA6B,mBAAmB;AACrE,SAASC,aAAa,QAAQ,aAAa;AAG3C,SAASC,oBAAoB,QAAQ,qBAAqB;;;AAyC1D;;;AAIA,OAAM,MAAOC,oCAAqC,SAAQH,YAA0C;EAIhGI,YAAsBC,cAAmD;IACrE,KAAK,CAAC,+BAA+B,EAAE,IAAI,CAAC;IAD1B,KAAAA,cAAc,GAAdA,cAAc;IAF1B,KAAAC,mBAAmB,GAAG,MAAM;EAItC;EAEA;;;;;;;;;;;EAWMC,iBAAiBA,CACnBC,SAAiB,EACjBC,SAAiB,EACjBC,SAAiB,EACjBC,QAAyC,EACzCC,WAA4B,EAC5BC,MAAe;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAEfP,SAAS,GAAGN,oBAAoB,CAACc,uBAAuB,CAACL,QAAQ,EAAEH,SAAS,CAAC;MAE7E,OAAOM,KAAI,CAACG,wBAAwB,CAChCT,SAAS,EACT,mBAAmB,EACnB,CAACC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,MAAM,CAAC,CACxD;IAAC;EACN;EAEA;;;;;;;;;EASMK,cAAcA,CAACV,SAAiB,EAAEG,QAAoC;IAAA,IAAAQ,MAAA;IAAA,OAAAJ,iBAAA;MACxEP,SAAS,GAAGN,oBAAoB,CAACc,uBAAuB,CAACL,QAAQ,EAAEH,SAAS,CAAC;MAE7E,OAAOW,MAAI,CAACF,wBAAwB,CAACT,SAAS,EAAE,gBAAgB,EAAE,CAACG,QAAQ,CAAC,CAAC;IAAC;EAClF;EAEA;;;;;;EAMAS,oBAAoBA,CAACZ,SAAiB;IAClC,OAAO,IAAI,CAACa,UAAU,CAACb,SAAS,EAAE,IAAI,CAAC;EAC3C;;SA3DSL,oCAAqC;;mBAArCA,MAAoC,EAAAmB,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,mCAAA;AAAA;;SAApCtB,MAAoC;EAAAuB,OAAA,EAApCvB,MAAoC,CAAAwB,IAAA;EAAAC,UAAA,EADvB;AAAM;AAgEhC,OAAO,MAAMC,6BAA6B,GAAG5B,aAAa,CAACE,oCAAoC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}