{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModImscp:';\n/**\n * Service that provides some features for IMSCP.\n */\nexport class AddonModImscpProvider {\n  /**\n   * Get the IMSCP toc as an array.\n   *\n   * @param contents The module contents.\n   * @returns The toc.\n   */\n  getToc(contents) {\n    if (!contents || !contents.length) {\n      return [];\n    }\n    return CoreTextUtils.parseJSON(contents[0].content || '');\n  }\n  /**\n   * Get the imscp toc as an array of items (not nested) to build the navigation tree.\n   *\n   * @param contents The module contents.\n   * @returns The toc as a list.\n   */\n  createItemList(contents) {\n    const items = [];\n    this.getToc(contents).forEach(item => {\n      items.push({\n        href: item.href,\n        title: item.title,\n        level: item.level\n      });\n      item.subitems.forEach(subitem => {\n        items.push({\n          href: subitem.href,\n          title: subitem.title,\n          level: subitem.level\n        });\n      });\n    });\n    return items;\n  }\n  /**\n   * Check if we should ommit the file download.\n   *\n   * @param fileName The file name\n   * @returns True if we should ommit the file.\n   */\n  checkSpecialFiles(fileName) {\n    return fileName == 'imsmanifest.xml';\n  }\n  /**\n   * Get cache key for imscp data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getImscpDataCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'imscp:' + courseId;\n  }\n  /**\n   * Get a imscp with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the imscp is retrieved.\n   */\n  getImscpByKey(courseId, key, value, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this.getImscpDataCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModImscpProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_imscp_get_imscps_by_courses', params, preSets);\n      const currentImscp = response.imscps.find(imscp => imscp[key] == value);\n      if (currentImscp) {\n        return currentImscp;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get a imscp by course module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the imscp is retrieved.\n   */\n  getImscp(courseId, cmId, options = {}) {\n    return this.getImscpByKey(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Given a filepath, get a certain fileurl from module contents.\n   *\n   * @param items Module contents.\n   * @param targetFilePath Path of the searched file.\n   * @returns File URL.\n   */\n  getFileUrlFromContents(items, targetFilePath) {\n    const item = items.find(item => {\n      if (item.type != 'file') {\n        return false;\n      }\n      const filePath = CorePath.concatenatePaths(item.filepath, item.filename);\n      const filePathAlt = filePath.charAt(0) === '/' ? filePath.substring(1) : '/' + filePath;\n      // Check if it's main file.\n      return filePath === targetFilePath || filePathAlt === targetFilePath;\n    });\n    return item === null || item === void 0 ? void 0 : item.fileurl;\n  }\n  /**\n   * Get src of a imscp item.\n   *\n   * @param module The module object.\n   * @param itemHref Href of item to get.\n   * @returns Promise resolved with the item src.\n   */\n  getIframeSrc(module, itemHref) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const siteId = CoreSites.getCurrentSiteId();\n      try {\n        const dirPath = yield CoreFilepool.getPackageDirUrlByUrl(siteId, module.url || '');\n        return CorePath.concatenatePaths(dirPath, itemHref);\n      } catch (error) {\n        // Error getting directory, there was an error downloading or we're in browser. Return online URL if connected.\n        if (CoreNetwork.isOnline()) {\n          const contents = yield CoreCourse.getModuleContents(module);\n          const indexUrl = _this2.getFileUrlFromContents(contents, itemHref);\n          if (indexUrl) {\n            const site = yield CoreSites.getSite(siteId);\n            return site.checkAndFixPluginfileURL(indexUrl);\n          }\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Get last item viewed's href in the app for a IMSCP.\n   *\n   * @param id IMSCP instance ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with last item viewed's href, undefined if none.\n   */\n  getLastItemViewed(id, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = yield site.getLastViewed(AddonModImscpProvider.COMPONENT, id);\n      return entry === null || entry === void 0 ? void 0 : entry.value;\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID of the module.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the content is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const promises = [];\n      promises.push(_this3.invalidateImscpData(courseId, siteId));\n      promises.push(CoreFilepool.invalidateFilesByComponent(siteId, AddonModImscpProvider.COMPONENT, moduleId));\n      promises.push(CoreCourse.invalidateModule(moduleId, siteId));\n      yield CoreUtils.allPromises(promises);\n    })();\n  }\n  /**\n   * Invalidates imscp data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateImscpData(courseId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this4.getImscpDataCacheKey(courseId));\n    })();\n  }\n  /**\n   * Check if a file is downloadable. The file param must have 'type' and 'filename' attributes\n   * like in core_course_get_contents response.\n   *\n   * @param file File to check.\n   * @returns True if downloadable, false otherwise.\n   */\n  isFileDownloadable(file) {\n    return file.type === 'file' && !this.checkSpecialFiles(file.filename);\n  }\n  /**\n   * Return whether or not the plugin is enabled in a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n   */\n  isPluginEnabled(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.canDownloadFiles();\n    })();\n  }\n  /**\n   * Report a IMSCP as being viewed.\n   *\n   * @param id Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(id, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        imscpid: id\n      };\n      yield CoreCourseLogHelper.log('mod_imscp_view_imscp', params, AddonModImscpProvider.COMPONENT, id, siteId);\n    })();\n  }\n  /**\n   * Store last item viewed in the app for a IMSCP.\n   *\n   * @param id IMSCP instance ID.\n   * @param href Item href.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with last item viewed, undefined if none.\n   */\n  storeLastItemViewed(id, href, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.storeLastViewed(AddonModImscpProvider.COMPONENT, id, href, {\n        data: String(courseId)\n      });\n    })();\n  }\n}\n_class = AddonModImscpProvider;\n_class.COMPONENT = 'mmaModImscp';\n_class.ɵfac = function AddonModImscpProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModImscp = makeSingleton(AddonModImscpProvider);","map":{"version":3,"names":["CoreError","CoreSite","CoreCourse","CoreCourseLogHelper","CoreNetwork","CoreFilepool","CoreSites","CoreTextUtils","CoreUtils","makeSingleton","Translate","CorePath","ROOT_CACHE_KEY","AddonModImscpProvider","getToc","contents","length","parseJSON","content","createItemList","items","forEach","item","push","href","title","level","subitems","subitem","checkSpecialFiles","fileName","getImscpDataCacheKey","courseId","getImscpByKey","key","value","options","_this","_asyncToGenerator","site","getSite","siteId","params","courseids","preSets","_objectSpread","cacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","response","read","currentImscp","imscps","find","imscp","instant","getImscp","cmId","getFileUrlFromContents","targetFilePath","type","filePath","concatenatePaths","filepath","filename","filePathAlt","charAt","substring","fileurl","getIframeSrc","module","itemHref","_this2","getCurrentSiteId","dirPath","getPackageDirUrlByUrl","url","error","isOnline","getModuleContents","indexUrl","checkAndFixPluginfileURL","getLastItemViewed","id","entry","getLastViewed","invalidateContent","moduleId","_this3","promises","invalidateImscpData","invalidateFilesByComponent","invalidateModule","allPromises","_this4","invalidateWsCacheForKey","isFileDownloadable","file","isPluginEnabled","canDownloadFiles","logView","imscpid","log","storeLastItemViewed","storeLastViewed","data","String","_class","factory","ɵfac","providedIn","AddonModImscp"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/imscp/services/imscp.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourse, CoreCourseModuleContentFile } from '@features/course/services/course';\nimport { CoreCourseModuleData } from '@features/course/services/course-helper';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSitesCommonWSOptions, CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaModImscp:';\n\n/**\n * Service that provides some features for IMSCP.\n */\n@Injectable( { providedIn: 'root' })\nexport class AddonModImscpProvider {\n\n    static readonly COMPONENT = 'mmaModImscp';\n\n    /**\n     * Get the IMSCP toc as an array.\n     *\n     * @param contents The module contents.\n     * @returns The toc.\n     */\n    protected getToc(contents: CoreCourseModuleContentFile[]): AddonModImscpTocItemTree[] {\n        if (!contents || !contents.length) {\n            return [];\n        }\n\n        return CoreTextUtils.parseJSON<AddonModImscpTocItemTree[]>(contents[0].content || '');\n    }\n\n    /**\n     * Get the imscp toc as an array of items (not nested) to build the navigation tree.\n     *\n     * @param contents The module contents.\n     * @returns The toc as a list.\n     */\n    createItemList(contents: CoreCourseModuleContentFile[]): AddonModImscpTocItem[] {\n        const items: AddonModImscpTocItem[] = [];\n\n        this.getToc(contents).forEach((item) => {\n            items.push({ href: item.href, title: item.title, level: item.level });\n\n            item.subitems.forEach((subitem) => {\n                items.push({ href: subitem.href, title: subitem.title, level: subitem.level });\n            });\n        });\n\n        return items;\n    }\n\n    /**\n     * Check if we should ommit the file download.\n     *\n     * @param fileName The file name\n     * @returns True if we should ommit the file.\n     */\n    protected checkSpecialFiles(fileName: string): boolean {\n        return fileName == 'imsmanifest.xml';\n    }\n\n    /**\n     * Get cache key for imscp data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getImscpDataCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'imscp:' + courseId;\n    }\n\n    /**\n     * Get a imscp with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the imscp is retrieved.\n     */\n    protected async getImscpByKey(\n        courseId: number,\n        key: string,\n        value: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModImscpImscp> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModImscpGetImscpsByCoursesWSParams = {\n            courseids: [courseId],\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getImscpDataCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModImscpProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        const response =\n            await site.read<AddonModImscpGetImscpsByCoursesWSResponse>('mod_imscp_get_imscps_by_courses', params, preSets);\n\n        const currentImscp = response.imscps.find((imscp) => imscp[key] == value);\n        if (currentImscp) {\n            return currentImscp;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get a imscp by course module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the imscp is retrieved.\n     */\n    getImscp(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModImscpImscp> {\n        return this.getImscpByKey(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Given a filepath, get a certain fileurl from module contents.\n     *\n     * @param items Module contents.\n     * @param targetFilePath Path of the searched file.\n     * @returns File URL.\n     */\n    protected getFileUrlFromContents(items: CoreCourseModuleContentFile[], targetFilePath: string): string | undefined {\n        const item = items.find((item) => {\n            if (item.type != 'file') {\n                return false;\n            }\n\n            const filePath = CorePath.concatenatePaths(item.filepath, item.filename);\n            const filePathAlt = filePath.charAt(0) === '/' ? filePath.substring(1) : '/' + filePath;\n\n            // Check if it's main file.\n            return filePath === targetFilePath || filePathAlt === targetFilePath;\n        });\n\n        return item?.fileurl;\n    }\n\n    /**\n     * Get src of a imscp item.\n     *\n     * @param module The module object.\n     * @param itemHref Href of item to get.\n     * @returns Promise resolved with the item src.\n     */\n    async getIframeSrc(module: CoreCourseModuleData, itemHref: string): Promise<string> {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        try {\n            const dirPath = await CoreFilepool.getPackageDirUrlByUrl(siteId, module.url || '');\n\n            return CorePath.concatenatePaths(dirPath, itemHref);\n        } catch (error) {\n            // Error getting directory, there was an error downloading or we're in browser. Return online URL if connected.\n            if (CoreNetwork.isOnline()) {\n                const contents = await CoreCourse.getModuleContents(module);\n\n                const indexUrl = this.getFileUrlFromContents(contents, itemHref);\n\n                if (indexUrl) {\n                    const site = await CoreSites.getSite(siteId);\n\n                    return site.checkAndFixPluginfileURL(indexUrl);\n                }\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Get last item viewed's href in the app for a IMSCP.\n     *\n     * @param id IMSCP instance ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with last item viewed's href, undefined if none.\n     */\n    async getLastItemViewed(id: number, siteId?: string): Promise<string | undefined> {\n        const site = await CoreSites.getSite(siteId);\n        const entry = await site.getLastViewed(AddonModImscpProvider.COMPONENT, id);\n\n        return entry?.value;\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID of the module.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the content is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const promises: Promise<void>[] = [];\n\n        promises.push(this.invalidateImscpData(courseId, siteId));\n        promises.push(CoreFilepool.invalidateFilesByComponent(siteId, AddonModImscpProvider.COMPONENT, moduleId));\n        promises.push(CoreCourse.invalidateModule(moduleId, siteId));\n\n        await CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Invalidates imscp data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateImscpData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getImscpDataCacheKey(courseId));\n    }\n\n    /**\n     * Check if a file is downloadable. The file param must have 'type' and 'filename' attributes\n     * like in core_course_get_contents response.\n     *\n     * @param file File to check.\n     * @returns True if downloadable, false otherwise.\n     */\n    isFileDownloadable(file: CoreCourseModuleContentFile): boolean {\n        return file.type === 'file' && !this.checkSpecialFiles(file.filename);\n    }\n\n    /**\n     * Return whether or not the plugin is enabled in a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n     */\n    async isPluginEnabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.canDownloadFiles();\n    }\n\n    /**\n     * Report a IMSCP as being viewed.\n     *\n     * @param id Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logView(id: number, siteId?: string): Promise<void> {\n        const params: AddonModImscpViewImscpWSParams = {\n            imscpid: id,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_imscp_view_imscp',\n            params,\n            AddonModImscpProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Store last item viewed in the app for a IMSCP.\n     *\n     * @param id IMSCP instance ID.\n     * @param href Item href.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with last item viewed, undefined if none.\n     */\n    async storeLastItemViewed(id: number, href: string, courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.storeLastViewed(AddonModImscpProvider.COMPONENT, id, href, { data: String(courseId) });\n    }\n\n}\nexport const AddonModImscp = makeSingleton(AddonModImscpProvider);\n\n/**\n * Params of mod_imscp_view_imscp WS.\n */\ntype AddonModImscpViewImscpWSParams = {\n    imscpid: number; // Imscp instance id.\n};\n\n/**\n * IMSCP returned by mod_imscp_get_imscps_by_courses.\n */\nexport type AddonModImscpImscp = {\n    id: number; // IMSCP id.\n    coursemodule: number; // Course module id.\n    course: number; // Course id.\n    name: string; // Activity name.\n    intro?: string; // The IMSCP intro.\n    introformat?: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    revision?: number; // Revision.\n    keepold?: number; // Number of old IMSCP to keep.\n    structure?: string; // IMSCP structure.\n    timemodified?: string; // Time of last modification.\n    section?: number; // Course section id.\n    visible?: boolean; // If visible.\n    groupmode?: number; // Group mode.\n    groupingid?: number; // Group id.\n};\n\n/**\n * Params of mod_imscp_get_imscps_by_courses WS.\n */\ntype AddonModImscpGetImscpsByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_imscp_get_imscps_by_courses WS.\n */\ntype AddonModImscpGetImscpsByCoursesWSResponse = {\n    imscps: AddonModImscpImscp[];\n    warnings?: CoreWSExternalWarning[];\n};\n\nexport type AddonModImscpTocItem = {\n    href: string;\n    title: string;\n    level: string;\n};\n\ntype AddonModImscpTocItemTree = AddonModImscpTocItem & {\n    subitems: AddonModImscpTocItem[];\n};\n"],"mappings":";;;AAeA,SAASA,SAAS,QAAQ,uBAAuB;AACjD,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,UAAU,QAAqC,kCAAkC;AAE1F,SAASC,mBAAmB,QAAQ,sCAAsC;AAC1E,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAAmCC,SAAS,QAAQ,iBAAiB;AACrE,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,SAAS,QAAQ,uBAAuB;AAEjD,SAASC,aAAa,EAAEC,SAAS,QAAQ,aAAa;AACtD,SAASC,QAAQ,QAAQ,kBAAkB;;AAG3C,MAAMC,cAAc,GAAG,cAAc;AAErC;;;AAIA,OAAM,MAAOC,qBAAqB;EAI9B;;;;;;EAMUC,MAAMA,CAACC,QAAuC;IACpD,IAAI,CAACA,QAAQ,IAAI,CAACA,QAAQ,CAACC,MAAM,EAAE;MAC/B,OAAO,EAAE;;IAGb,OAAOT,aAAa,CAACU,SAAS,CAA6BF,QAAQ,CAAC,CAAC,CAAC,CAACG,OAAO,IAAI,EAAE,CAAC;EACzF;EAEA;;;;;;EAMAC,cAAcA,CAACJ,QAAuC;IAClD,MAAMK,KAAK,GAA2B,EAAE;IAExC,IAAI,CAACN,MAAM,CAACC,QAAQ,CAAC,CAACM,OAAO,CAAEC,IAAI,IAAI;MACnCF,KAAK,CAACG,IAAI,CAAC;QAAEC,IAAI,EAAEF,IAAI,CAACE,IAAI;QAAEC,KAAK,EAAEH,IAAI,CAACG,KAAK;QAAEC,KAAK,EAAEJ,IAAI,CAACI;MAAK,CAAE,CAAC;MAErEJ,IAAI,CAACK,QAAQ,CAACN,OAAO,CAAEO,OAAO,IAAI;QAC9BR,KAAK,CAACG,IAAI,CAAC;UAAEC,IAAI,EAAEI,OAAO,CAACJ,IAAI;UAAEC,KAAK,EAAEG,OAAO,CAACH,KAAK;UAAEC,KAAK,EAAEE,OAAO,CAACF;QAAK,CAAE,CAAC;MAClF,CAAC,CAAC;IACN,CAAC,CAAC;IAEF,OAAON,KAAK;EAChB;EAEA;;;;;;EAMUS,iBAAiBA,CAACC,QAAgB;IACxC,OAAOA,QAAQ,IAAI,iBAAiB;EACxC;EAEA;;;;;;EAMUC,oBAAoBA,CAACC,QAAgB;IAC3C,OAAOpB,cAAc,GAAG,QAAQ,GAAGoB,QAAQ;EAC/C;EAEA;;;;;;;;;EASgBC,aAAaA,CACzBD,QAAgB,EAChBE,GAAW,EACXC,KAAa,EACbC,OAAA,GAAoC,EAAE;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAEtC,MAAMC,IAAI,SAASjC,SAAS,CAACkC,OAAO,CAACJ,OAAO,CAACK,MAAM,CAAC;MAEpD,MAAMC,MAAM,GAA4C;QACpDC,SAAS,EAAE,CAACX,QAAQ;OACvB;MAED,MAAMY,OAAO,GAAAC,aAAA;QACTC,QAAQ,EAAET,KAAI,CAACN,oBAAoB,CAACC,QAAQ,CAAC;QAC7Ce,eAAe,EAAE9C,QAAQ,CAAC+C,gBAAgB;QAC1CC,SAAS,EAAEpC,qBAAqB,CAACqC;MAAS,GACvC5C,SAAS,CAAC6C,yBAAyB,CAACf,OAAO,CAACgB,eAAe,CAAC,CAClE;MAED,MAAMC,QAAQ,SACJd,IAAI,CAACe,IAAI,CAA4C,iCAAiC,EAAEZ,MAAM,EAAEE,OAAO,CAAC;MAElH,MAAMW,YAAY,GAAGF,QAAQ,CAACG,MAAM,CAACC,IAAI,CAAEC,KAAK,IAAKA,KAAK,CAACxB,GAAG,CAAC,IAAIC,KAAK,CAAC;MACzE,IAAIoB,YAAY,EAAE;QACd,OAAOA,YAAY;;MAGvB,MAAM,IAAIvD,SAAS,CAACU,SAAS,CAACiD,OAAO,CAAC,4BAA4B,CAAC,CAAC;IAAC;EACzE;EAEA;;;;;;;;EAQAC,QAAQA,CAAC5B,QAAgB,EAAE6B,IAAY,EAAEzB,OAAA,GAAoC,EAAE;IAC3E,OAAO,IAAI,CAACH,aAAa,CAACD,QAAQ,EAAE,cAAc,EAAE6B,IAAI,EAAEzB,OAAO,CAAC;EACtE;EAEA;;;;;;;EAOU0B,sBAAsBA,CAAC1C,KAAoC,EAAE2C,cAAsB;IACzF,MAAMzC,IAAI,GAAGF,KAAK,CAACqC,IAAI,CAAEnC,IAAI,IAAI;MAC7B,IAAIA,IAAI,CAAC0C,IAAI,IAAI,MAAM,EAAE;QACrB,OAAO,KAAK;;MAGhB,MAAMC,QAAQ,GAAGtD,QAAQ,CAACuD,gBAAgB,CAAC5C,IAAI,CAAC6C,QAAQ,EAAE7C,IAAI,CAAC8C,QAAQ,CAAC;MACxE,MAAMC,WAAW,GAAGJ,QAAQ,CAACK,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,GAAGL,QAAQ,CAACM,SAAS,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGN,QAAQ;MAEvF;MACA,OAAOA,QAAQ,KAAKF,cAAc,IAAIM,WAAW,KAAKN,cAAc;IACxE,CAAC,CAAC;IAEF,OAAOzC,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEkD,OAAO;EACxB;EAEA;;;;;;;EAOMC,YAAYA,CAACC,MAA4B,EAAEC,QAAgB;IAAA,IAAAC,MAAA;IAAA,OAAAtC,iBAAA;MAC7D,MAAMG,MAAM,GAAGnC,SAAS,CAACuE,gBAAgB,EAAE;MAE3C,IAAI;QACA,MAAMC,OAAO,SAASzE,YAAY,CAAC0E,qBAAqB,CAACtC,MAAM,EAAEiC,MAAM,CAACM,GAAG,IAAI,EAAE,CAAC;QAElF,OAAOrE,QAAQ,CAACuD,gBAAgB,CAACY,OAAO,EAAEH,QAAQ,CAAC;OACtD,CAAC,OAAOM,KAAK,EAAE;QACZ;QACA,IAAI7E,WAAW,CAAC8E,QAAQ,EAAE,EAAE;UACxB,MAAMnE,QAAQ,SAASb,UAAU,CAACiF,iBAAiB,CAACT,MAAM,CAAC;UAE3D,MAAMU,QAAQ,GAAGR,MAAI,CAACd,sBAAsB,CAAC/C,QAAQ,EAAE4D,QAAQ,CAAC;UAEhE,IAAIS,QAAQ,EAAE;YACV,MAAM7C,IAAI,SAASjC,SAAS,CAACkC,OAAO,CAACC,MAAM,CAAC;YAE5C,OAAOF,IAAI,CAAC8C,wBAAwB,CAACD,QAAQ,CAAC;;;QAItD,MAAMH,KAAK;;IACd;EACL;EAEA;;;;;;;EAOMK,iBAAiBA,CAACC,EAAU,EAAE9C,MAAe;IAAA,OAAAH,iBAAA;MAC/C,MAAMC,IAAI,SAASjC,SAAS,CAACkC,OAAO,CAACC,MAAM,CAAC;MAC5C,MAAM+C,KAAK,SAASjD,IAAI,CAACkD,aAAa,CAAC5E,qBAAqB,CAACqC,SAAS,EAAEqC,EAAE,CAAC;MAE3E,OAAOC,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAErD,KAAK;IAAC;EACxB;EAEA;;;;;;;;EAQMuD,iBAAiBA,CAACC,QAAgB,EAAE3D,QAAgB,EAAES,MAAe;IAAA,IAAAmD,MAAA;IAAA,OAAAtD,iBAAA;MACvEG,MAAM,GAAGA,MAAM,IAAInC,SAAS,CAACuE,gBAAgB,EAAE;MAE/C,MAAMgB,QAAQ,GAAoB,EAAE;MAEpCA,QAAQ,CAACtE,IAAI,CAACqE,MAAI,CAACE,mBAAmB,CAAC9D,QAAQ,EAAES,MAAM,CAAC,CAAC;MACzDoD,QAAQ,CAACtE,IAAI,CAAClB,YAAY,CAAC0F,0BAA0B,CAACtD,MAAM,EAAE5B,qBAAqB,CAACqC,SAAS,EAAEyC,QAAQ,CAAC,CAAC;MACzGE,QAAQ,CAACtE,IAAI,CAACrB,UAAU,CAAC8F,gBAAgB,CAACL,QAAQ,EAAElD,MAAM,CAAC,CAAC;MAE5D,MAAMjC,SAAS,CAACyF,WAAW,CAACJ,QAAQ,CAAC;IAAC;EAC1C;EAEA;;;;;;;EAOMC,mBAAmBA,CAAC9D,QAAgB,EAAES,MAAe;IAAA,IAAAyD,MAAA;IAAA,OAAA5D,iBAAA;MACvD,MAAMC,IAAI,SAASjC,SAAS,CAACkC,OAAO,CAACC,MAAM,CAAC;MAE5C,MAAMF,IAAI,CAAC4D,uBAAuB,CAACD,MAAI,CAACnE,oBAAoB,CAACC,QAAQ,CAAC,CAAC;IAAC;EAC5E;EAEA;;;;;;;EAOAoE,kBAAkBA,CAACC,IAAiC;IAChD,OAAOA,IAAI,CAACrC,IAAI,KAAK,MAAM,IAAI,CAAC,IAAI,CAACnC,iBAAiB,CAACwE,IAAI,CAACjC,QAAQ,CAAC;EACzE;EAEA;;;;;;EAMMkC,eAAeA,CAAC7D,MAAe;IAAA,OAAAH,iBAAA;MACjC,MAAMC,IAAI,SAASjC,SAAS,CAACkC,OAAO,CAACC,MAAM,CAAC;MAE5C,OAAOF,IAAI,CAACgE,gBAAgB,EAAE;IAAC;EACnC;EAEA;;;;;;;EAOMC,OAAOA,CAACjB,EAAU,EAAE9C,MAAe;IAAA,OAAAH,iBAAA;MACrC,MAAMI,MAAM,GAAmC;QAC3C+D,OAAO,EAAElB;OACZ;MAED,MAAMpF,mBAAmB,CAACuG,GAAG,CACzB,sBAAsB,EACtBhE,MAAM,EACN7B,qBAAqB,CAACqC,SAAS,EAC/BqC,EAAE,EACF9C,MAAM,CACT;IAAC;EACN;EAEA;;;;;;;;;EASMkE,mBAAmBA,CAACpB,EAAU,EAAE/D,IAAY,EAAEQ,QAAgB,EAAES,MAAe;IAAA,OAAAH,iBAAA;MACjF,MAAMC,IAAI,SAASjC,SAAS,CAACkC,OAAO,CAACC,MAAM,CAAC;MAE5C,MAAMF,IAAI,CAACqE,eAAe,CAAC/F,qBAAqB,CAACqC,SAAS,EAAEqC,EAAE,EAAE/D,IAAI,EAAE;QAAEqF,IAAI,EAAEC,MAAM,CAAC9E,QAAQ;MAAC,CAAE,CAAC;IAAC;EACtG;;SA5QSnB,qBAAqB;AAEdkG,MAAA,CAAA7D,SAAS,GAAG,aAAa;;mBAFhCrC,MAAqB;AAAA;;SAArBA,MAAqB;EAAAmG,OAAA,EAArBnG,MAAqB,CAAAoG,IAAA;EAAAC,UAAA,EADP;AAAM;AAgRjC,OAAO,MAAMC,aAAa,GAAG1G,aAAa,CAACI,qBAAqB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}