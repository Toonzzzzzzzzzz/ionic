{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUser, USER_NOREPLY_USER } from '@features/user/services/user';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreLogger } from '@singletons/logger';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreCourseModuleDelegate } from '@features/course/services/module-delegate';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaNotifications:';\n/**\n * Service to handle notifications.\n */\nexport class AddonNotificationsProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('AddonNotificationsProvider');\n  }\n  /**\n   * Convert a push notification data to use the same format as the get_messages WS.\n   *\n   * @param notification Push notification to convert.\n   * @returns Converted notification.\n   */\n  convertPushToMessage(notification) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _notification$message, _CoreSites$getCurrent, _notification$id, _notification$userfro, _siteInfo$userid, _siteInfo$fullname, _notification$title, _notification$notif, _notification$date;\n      const message = (_notification$message = notification.message) !== null && _notification$message !== void 0 ? _notification$message : '';\n      const siteInfo = (_CoreSites$getCurrent = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent === void 0 ? void 0 : _CoreSites$getCurrent.getInfo();\n      if (notification.senderImage && notification.customdata && !notification.customdata.notificationiconurl) {\n        notification.customdata.notificationiconurl = notification.senderImage;\n      }\n      const notificationMessage = {\n        id: (_notification$id = notification.id) !== null && _notification$id !== void 0 ? _notification$id : 0,\n        useridfrom: notification.userfromid ? Number(notification.userfromid) : USER_NOREPLY_USER,\n        userfromfullname: (_notification$userfro = notification.userfromfullname) !== null && _notification$userfro !== void 0 ? _notification$userfro : Translate.instant('core.noreplyname'),\n        useridto: notification.usertoid ? Number(notification.usertoid) : (_siteInfo$userid = siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.userid) !== null && _siteInfo$userid !== void 0 ? _siteInfo$userid : 0,\n        usertofullname: (_siteInfo$fullname = siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.fullname) !== null && _siteInfo$fullname !== void 0 ? _siteInfo$fullname : '',\n        subject: (_notification$title = notification.title) !== null && _notification$title !== void 0 ? _notification$title : '',\n        text: message,\n        fullmessage: message,\n        fullmessageformat: 1,\n        fullmessagehtml: message,\n        smallmessage: message,\n        notification: Number((_notification$notif = notification.notif) !== null && _notification$notif !== void 0 ? _notification$notif : 1),\n        contexturl: notification.contexturl || null,\n        contexturlname: null,\n        timecreated: Number((_notification$date = notification.date) !== null && _notification$date !== void 0 ? _notification$date : 0),\n        timeread: 0,\n        component: notification.moodlecomponent,\n        customdata: notification.customdata ? JSON.stringify(notification.customdata) : undefined\n      };\n      const formatted = yield _this.formatNotificationsData([notificationMessage]);\n      return formatted[0];\n    })();\n  }\n  /**\n   * Function to format notification data.\n   *\n   * @param notifications List of notifications.\n   * @returns Promise resolved with notifications.\n   */\n  formatNotificationsData(notifications) {\n    return _asyncToGenerator(function* () {\n      const promises = notifications.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (notificationRaw) {\n          var _notification$customd, _notification$customd2, _notification$customd3;\n          const notification = notificationRaw;\n          notification.mobiletext = notification.fullmessagehtml || notification.fullmessage || notification.smallmessage;\n          notification.moodlecomponent = notification.component;\n          notification.notification = 1;\n          notification.notif = 1;\n          notification.read = notification.timeread > 0;\n          if (typeof notification.customdata == 'string') {\n            notification.customdata = CoreTextUtils.parseJSON(notification.customdata, {});\n          }\n          // Try to set courseid the notification belongs to.\n          if ((_notification$customd = notification.customdata) !== null && _notification$customd !== void 0 && _notification$customd.courseid) {\n            notification.courseid = notification.customdata.courseid;\n          } else if (!notification.courseid) {\n            const courseIdMatch = notification.fullmessagehtml.match(/course\\/view\\.php\\?id=([^\"]*)/);\n            if (courseIdMatch !== null && courseIdMatch !== void 0 && courseIdMatch[1]) {\n              notification.courseid = parseInt(courseIdMatch[1], 10);\n            }\n          }\n          if (!notification.iconurl) {\n            // The iconurl is only returned in 4.0 or above. Calculate it if not present.\n            if (notification.moodlecomponent && notification.moodlecomponent.startsWith('mod_')) {\n              notification.iconurl = yield CoreCourseModuleDelegate.getModuleIconSrc(notification.moodlecomponent.replace('mod_', ''));\n            }\n          }\n          const imgUrl = ((_notification$customd2 = notification.customdata) === null || _notification$customd2 === void 0 ? void 0 : _notification$customd2.notificationpictureurl) || ((_notification$customd3 = notification.customdata) === null || _notification$customd3 === void 0 ? void 0 : _notification$customd3.notificationiconurl);\n          notification.imgUrl = imgUrl ? String(imgUrl) : undefined;\n          if (notification.useridfrom > 0) {\n            // Try to get the profile picture of the user.\n            try {\n              const user = yield CoreUser.getProfile(notification.useridfrom, notification.courseid, true);\n              notification.profileimageurlfrom = user.profileimageurl;\n              notification.userfromfullname = user.fullname;\n            } catch (_unused) {\n              // Error getting user. This can happen if device is offline or the user is deleted.\n            }\n          }\n          return notification;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return Promise.all(promises);\n    })();\n  }\n  /**\n   * Get the cache key for the get notification preferences call.\n   *\n   * @returns Cache key.\n   */\n  getNotificationPreferencesCacheKey() {\n    return ROOT_CACHE_KEY + 'notificationPreferences';\n  }\n  /**\n   * Get notification preferences.\n   *\n   * @param options Options.\n   * @returns Promise resolved with the notification preferences.\n   */\n  getNotificationPreferences(options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.logger.debug('Get notification preferences');\n      const site = yield CoreSites.getSite(options.siteId);\n      const preSets = _objectSpread({\n        cacheKey: _this2.getNotificationPreferencesCacheKey(),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const data = yield site.read('core_message_get_user_notification_preferences', {}, preSets);\n      return data.preferences;\n    })();\n  }\n  /**\n   * Get cache key for notification list WS calls.\n   *\n   * @returns Cache key.\n   */\n  getNotificationsCacheKey() {\n    return ROOT_CACHE_KEY + 'list';\n  }\n  /**\n   * Get some notifications.\n   *\n   * @param notifications Current list of loaded notifications. It's used to calculate the offset.\n   * @param options Other options.\n   * @returns Promise resolved with notifications and if can load more.\n   * @deprecated since 4.1. Use getNotificationsWithStatus instead.\n   */\n  getNotifications(notifications, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      notifications = notifications || [];\n      options = options || {};\n      options.limit = options.limit || AddonNotificationsProvider.LIST_LIMIT;\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      let newNotifications;\n      // Request 1 more notification so we can know if there are more notifications.\n      const originalLimit = options.limit;\n      options.limit = options.limit + 1;\n      const site = yield CoreSites.getSite(options.siteId);\n      if (site.isVersionGreaterEqualThan('4.0')) {\n        // In 4.0 the app can request read and unread at the same time.\n        options.offset = notifications.length;\n        newNotifications = yield _this3.getNotificationsWithStatus(AddonNotificationsGetReadType.BOTH, options);\n      } else {\n        // We need 2 calls, one for read and the other one for unread.\n        options.offset = notifications.reduce((total, current) => total + (current.read ? 0 : 1), 0);\n        const unread = yield _this3.getNotificationsWithStatus(AddonNotificationsGetReadType.UNREAD, options);\n        newNotifications = unread;\n        if (unread.length < options.limit) {\n          // Limit not reached. Get read notifications until reach the limit.\n          const readOptions = _objectSpread(_objectSpread({}, options), {}, {\n            offset: notifications.length - options.offset,\n            limit: options.limit - unread.length\n          });\n          try {\n            const read = yield _this3.getNotificationsWithStatus(AddonNotificationsGetReadType.READ, readOptions);\n            newNotifications = unread.concat(read);\n          } catch (error) {\n            if (unread.length <= 0) {\n              throw error;\n            }\n          }\n        }\n      }\n      return {\n        notifications: newNotifications.slice(0, originalLimit),\n        canLoadMore: newNotifications.length > originalLimit\n      };\n    })();\n  }\n  /**\n   * Get notifications from site.\n   *\n   * @param read True if should get read notifications, false otherwise.\n   * @param options Other options.\n   * @returns Promise resolved with notifications.\n   */\n  getNotificationsWithStatus(read, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      options.offset = options.offset || 0;\n      options.limit = options.limit || AddonNotificationsProvider.LIST_LIMIT;\n      const typeText = read === AddonNotificationsGetReadType.READ ? 'read' : read === AddonNotificationsGetReadType.UNREAD ? 'unread' : 'read and unread';\n      _this4.logger.debug(`Get ${typeText} notifications from ${options.offset}. Limit: ${options.limit}`);\n      const site = yield CoreSites.getSite(options.siteId);\n      const data = {\n        useridto: site.getUserId(),\n        useridfrom: 0,\n        type: 'notifications',\n        read: read,\n        newestfirst: true,\n        limitfrom: options.offset,\n        limitnum: options.limit\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this4.getNotificationsCacheKey()\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      // Get unread notifications.\n      const response = yield site.read('core_message_get_messages', data, preSets);\n      const notifications = response.messages;\n      return _this4.formatNotificationsData(notifications);\n    })();\n  }\n  /**\n   * Get unread notifications count. Do not cache calls.\n   *\n   * @param userId The user id who received the notification. If not defined, use current user.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the message notifications count.\n   */\n  getUnreadNotificationsCount(userId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // @since 4.0\n      if (site.wsAvailable('core_message_get_unread_notification_count')) {\n        const params = {\n          useridto: userId || site.getUserId()\n        };\n        const preSets = {\n          cacheKey: _this5.getUnreadNotificationsCountCacheKey(params.useridto),\n          getFromCache: false,\n          typeExpected: 'number'\n        };\n        try {\n          const count = yield site.read('core_message_get_unread_notification_count', params, preSets);\n          return {\n            count,\n            hasMore: false\n          };\n        } catch (_unused2) {\n          // Return no notifications if the call fails.\n          return {\n            count: 0,\n            hasMore: false\n          };\n        }\n      }\n      // Fallback call\n      try {\n        const unread = yield _this5.getNotificationsWithStatus(AddonNotificationsGetReadType.UNREAD, {\n          limit: AddonNotificationsProvider.LIST_LIMIT + 1,\n          siteId\n        });\n        return {\n          count: Math.min(unread.length, AddonNotificationsProvider.LIST_LIMIT),\n          hasMore: unread.length > AddonNotificationsProvider.LIST_LIMIT\n        };\n      } catch (_unused3) {\n        // Return no notifications if the call fails.\n        return {\n          count: 0,\n          hasMore: false\n        };\n      }\n    })();\n  }\n  /**\n   * Get cache key for unread notifications count WS calls.\n   *\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getUnreadNotificationsCountCacheKey(userId) {\n    return `${ROOT_CACHE_KEY}count:${userId}`;\n  }\n  /**\n   * Mark all message notification as read.\n   *\n   * @returns Resolved when done.\n   */\n  markAllNotificationsAsRead(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        useridto: CoreSites.getCurrentSiteUserId()\n      };\n      return site.write('core_message_mark_all_notifications_as_read', params);\n    })();\n  }\n  /**\n   * Mark a single notification as read.\n   *\n   * @param notificationId ID of notification to mark as read\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  markNotificationRead(notificationId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        notificationid: notificationId,\n        timeread: CoreTimeUtils.timestamp()\n      };\n      return site.write('core_message_mark_notification_read', params);\n    })();\n  }\n  /**\n   * Invalidate get notification preferences.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data is invalidated.\n   */\n  invalidateNotificationPreferences(siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this6.getNotificationPreferencesCacheKey());\n    })();\n  }\n  /**\n   * Invalidates notifications list WS calls.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the list is invalidated.\n   */\n  invalidateNotificationsList(siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this7.getNotificationsCacheKey());\n    })();\n  }\n}\n_class = AddonNotificationsProvider;\n_class.READ_CHANGED_EVENT = 'addon_notifications_read_changed_event';\n_class.READ_CRON_EVENT = 'addon_notifications_read_cron_event';\n_class.PUSH_SIMULATION_COMPONENT = 'AddonNotificationsPushSimulation';\n_class.LIST_LIMIT = 20;\n_class.ɵfac = function AddonNotificationsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonNotifications = makeSingleton(AddonNotificationsProvider);\n/**\n * Constants to get either read, unread or both notifications.\n */\nexport var AddonNotificationsGetReadType;\n(function (AddonNotificationsGetReadType) {\n  AddonNotificationsGetReadType[AddonNotificationsGetReadType[\"UNREAD\"] = 0] = \"UNREAD\";\n  AddonNotificationsGetReadType[AddonNotificationsGetReadType[\"READ\"] = 1] = \"READ\";\n  AddonNotificationsGetReadType[AddonNotificationsGetReadType[\"BOTH\"] = 2] = \"BOTH\";\n})(AddonNotificationsGetReadType || (AddonNotificationsGetReadType = {}));","map":{"version":3,"names":["CoreSites","CoreTextUtils","CoreTimeUtils","CoreUser","USER_NOREPLY_USER","CoreSite","CoreLogger","Translate","makeSingleton","CoreCourseModuleDelegate","ROOT_CACHE_KEY","AddonNotificationsProvider","constructor","logger","getInstance","convertPushToMessage","notification","_this","_asyncToGenerator","_notification$message","_CoreSites$getCurrent","_notification$id","_notification$userfro","_siteInfo$userid","_siteInfo$fullname","_notification$title","_notification$notif","_notification$date","message","siteInfo","getCurrentSite","getInfo","senderImage","customdata","notificationiconurl","notificationMessage","id","useridfrom","userfromid","Number","userfromfullname","instant","useridto","usertoid","userid","usertofullname","fullname","subject","title","text","fullmessage","fullmessageformat","fullmessagehtml","smallmessage","notif","contexturl","contexturlname","timecreated","date","timeread","component","moodlecomponent","JSON","stringify","undefined","formatted","formatNotificationsData","notifications","promises","map","_ref","notificationRaw","_notification$customd","_notification$customd2","_notification$customd3","mobiletext","read","parseJSON","courseid","courseIdMatch","match","parseInt","iconurl","startsWith","getModuleIconSrc","replace","imgUrl","notificationpictureurl","String","user","getProfile","profileimageurlfrom","profileimageurl","_unused","_x","apply","arguments","Promise","all","getNotificationPreferencesCacheKey","getNotificationPreferences","options","_this2","debug","site","getSite","siteId","preSets","_objectSpread","cacheKey","updateFrequency","FREQUENCY_SOMETIMES","getReadingStrategyPreSets","readingStrategy","data","preferences","getNotificationsCacheKey","getNotifications","_this3","limit","LIST_LIMIT","getCurrentSiteId","newNotifications","originalLimit","isVersionGreaterEqualThan","offset","length","getNotificationsWithStatus","AddonNotificationsGetReadType","BOTH","reduce","total","current","unread","UNREAD","readOptions","READ","concat","error","slice","canLoadMore","_this4","typeText","getUserId","type","newestfirst","limitfrom","limitnum","response","messages","getUnreadNotificationsCount","userId","_this5","wsAvailable","params","getUnreadNotificationsCountCacheKey","getFromCache","typeExpected","count","hasMore","_unused2","Math","min","_unused3","markAllNotificationsAsRead","getCurrentSiteUserId","write","markNotificationRead","notificationId","notificationid","timestamp","invalidateNotificationPreferences","_this6","invalidateWsCacheForKey","invalidateNotificationsList","_this7","_class","READ_CHANGED_EVENT","READ_CRON_EVENT","PUSH_SIMULATION_COMPONENT","factory","ɵfac","providedIn","AddonNotifications"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/notifications/services/notifications.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreSites, CoreSitesCommonWSOptions } from '@services/sites';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUser, USER_NOREPLY_USER } from '@features/user/services/user';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreLogger } from '@singletons/logger';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreCourseModuleDelegate } from '@features/course/services/module-delegate';\nimport { AddonNotificationsPushNotification } from './handlers/push-click';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonNotificationsProvider.READ_CHANGED_EVENT]: AddonNotificationsReadChangedEvent;\n    }\n\n}\n\nconst ROOT_CACHE_KEY = 'mmaNotifications:';\n\n/**\n * Service to handle notifications.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonNotificationsProvider {\n\n    static readonly READ_CHANGED_EVENT = 'addon_notifications_read_changed_event';\n    static readonly READ_CRON_EVENT = 'addon_notifications_read_cron_event';\n    static readonly PUSH_SIMULATION_COMPONENT = 'AddonNotificationsPushSimulation';\n    static readonly LIST_LIMIT = 20;\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('AddonNotificationsProvider');\n    }\n\n    /**\n     * Convert a push notification data to use the same format as the get_messages WS.\n     *\n     * @param notification Push notification to convert.\n     * @returns Converted notification.\n     */\n    async convertPushToMessage(\n        notification: AddonNotificationsPushNotification,\n    ): Promise<AddonNotificationsNotificationMessageFormatted> {\n        const message = notification.message ?? '';\n        const siteInfo = CoreSites.getCurrentSite()?.getInfo();\n\n        if (notification.senderImage && notification.customdata && !notification.customdata.notificationiconurl) {\n            notification.customdata.notificationiconurl = notification.senderImage;\n        }\n\n        const notificationMessage: AddonNotificationsNotificationMessage = {\n            id: notification.id ?? 0,\n            useridfrom: notification.userfromid ? Number(notification.userfromid) : USER_NOREPLY_USER,\n            userfromfullname: notification.userfromfullname ?? Translate.instant('core.noreplyname'),\n            useridto: notification.usertoid ? Number(notification.usertoid) : (siteInfo?.userid ?? 0),\n            usertofullname: siteInfo?.fullname ?? '',\n            subject: notification.title ?? '',\n            text: message,\n            fullmessage: message,\n            fullmessageformat: 1,\n            fullmessagehtml: message,\n            smallmessage: message,\n            notification: Number(notification.notif ?? 1),\n            contexturl: notification.contexturl || null,\n            contexturlname: null,\n            timecreated: Number(notification.date ?? 0),\n            timeread: 0,\n            component: notification.moodlecomponent,\n            customdata: notification.customdata ? JSON.stringify(notification.customdata) : undefined,\n        };\n\n        const formatted = await this.formatNotificationsData([notificationMessage]);\n\n        return formatted[0];\n    }\n\n    /**\n     * Function to format notification data.\n     *\n     * @param notifications List of notifications.\n     * @returns Promise resolved with notifications.\n     */\n    protected async formatNotificationsData(\n        notifications: AddonNotificationsNotificationMessage[],\n    ): Promise<AddonNotificationsNotificationMessageFormatted[]> {\n\n        const promises = notifications.map(async (notificationRaw) => {\n            const notification = <AddonNotificationsNotificationMessageFormatted> notificationRaw;\n\n            notification.mobiletext = notification.fullmessagehtml || notification.fullmessage || notification.smallmessage;\n            notification.moodlecomponent = notification.component;\n            notification.notification = 1;\n            notification.notif = 1;\n            notification.read = notification.timeread > 0;\n\n            if (typeof notification.customdata == 'string') {\n                notification.customdata = CoreTextUtils.parseJSON<Record<string, string|number>>(notification.customdata, {});\n            }\n\n            // Try to set courseid the notification belongs to.\n            if (notification.customdata?.courseid) {\n                notification.courseid = <number> notification.customdata.courseid;\n            } else if (!notification.courseid) {\n                const courseIdMatch = notification.fullmessagehtml.match(/course\\/view\\.php\\?id=([^\"]*)/);\n                if (courseIdMatch?.[1]) {\n                    notification.courseid = parseInt(courseIdMatch[1], 10);\n                }\n            }\n\n            if (!notification.iconurl) {\n                // The iconurl is only returned in 4.0 or above. Calculate it if not present.\n                if (notification.moodlecomponent && notification.moodlecomponent.startsWith('mod_')) {\n                    notification.iconurl = await CoreCourseModuleDelegate.getModuleIconSrc(\n                        notification.moodlecomponent.replace('mod_', ''),\n                    );\n                }\n            }\n\n            const imgUrl = notification.customdata?.notificationpictureurl || notification.customdata?.notificationiconurl;\n            notification.imgUrl = imgUrl ? String(imgUrl) : undefined;\n\n            if (notification.useridfrom > 0) {\n                // Try to get the profile picture of the user.\n                try {\n                    const user = await CoreUser.getProfile(notification.useridfrom, notification.courseid, true);\n\n                    notification.profileimageurlfrom = user.profileimageurl;\n                    notification.userfromfullname = user.fullname;\n                } catch {\n                    // Error getting user. This can happen if device is offline or the user is deleted.\n                }\n            }\n\n            return notification;\n        });\n\n        return Promise.all(promises);\n    }\n\n    /**\n     * Get the cache key for the get notification preferences call.\n     *\n     * @returns Cache key.\n     */\n    protected getNotificationPreferencesCacheKey(): string {\n        return ROOT_CACHE_KEY + 'notificationPreferences';\n    }\n\n    /**\n     * Get notification preferences.\n     *\n     * @param options Options.\n     * @returns Promise resolved with the notification preferences.\n     */\n    async getNotificationPreferences(options: CoreSitesCommonWSOptions = {}): Promise<AddonNotificationsPreferences> {\n        this.logger.debug('Get notification preferences');\n\n        const site = await CoreSites.getSite(options.siteId);\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getNotificationPreferencesCacheKey(),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const data = await site.read<AddonNotificationsGetUserNotificationPreferencesResult>(\n            'core_message_get_user_notification_preferences',\n            {},\n            preSets,\n        );\n\n        return data.preferences;\n    }\n\n    /**\n     * Get cache key for notification list WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getNotificationsCacheKey(): string {\n        return ROOT_CACHE_KEY + 'list';\n    }\n\n    /**\n     * Get some notifications.\n     *\n     * @param notifications Current list of loaded notifications. It's used to calculate the offset.\n     * @param options Other options.\n     * @returns Promise resolved with notifications and if can load more.\n     * @deprecated since 4.1. Use getNotificationsWithStatus instead.\n     */\n    async getNotifications(\n        notifications: AddonNotificationsNotificationMessageFormatted[],\n        options?: AddonNotificationsGetNotificationsOptions,\n    ): Promise<{notifications: AddonNotificationsNotificationMessageFormatted[]; canLoadMore: boolean}> {\n\n        notifications = notifications || [];\n        options = options || {};\n        options.limit = options.limit || AddonNotificationsProvider.LIST_LIMIT;\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n        let newNotifications: AddonNotificationsNotificationMessageFormatted[];\n\n        // Request 1 more notification so we can know if there are more notifications.\n        const originalLimit = options.limit;\n        options.limit = options.limit + 1;\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        if (site.isVersionGreaterEqualThan('4.0')) {\n            // In 4.0 the app can request read and unread at the same time.\n            options.offset = notifications.length;\n            newNotifications = await this.getNotificationsWithStatus(\n                AddonNotificationsGetReadType.BOTH,\n                options,\n            );\n        } else {\n            // We need 2 calls, one for read and the other one for unread.\n            options.offset = notifications.reduce((total, current) => total + (current.read ? 0 : 1), 0);\n\n            const unread = await this.getNotificationsWithStatus(AddonNotificationsGetReadType.UNREAD, options);\n\n            newNotifications = unread;\n\n            if (unread.length < options.limit) {\n                // Limit not reached. Get read notifications until reach the limit.\n                const readOptions = {\n                    ...options,\n                    offset: notifications.length - options.offset,\n                    limit: options.limit - unread.length,\n                };\n\n                try {\n                    const read = await this.getNotificationsWithStatus(AddonNotificationsGetReadType.READ, readOptions);\n\n                    newNotifications = unread.concat(read);\n                } catch (error) {\n                    if (unread.length <= 0) {\n                        throw error;\n                    }\n                }\n            }\n        }\n\n        return {\n            notifications: newNotifications.slice(0, originalLimit),\n            canLoadMore: newNotifications.length > originalLimit,\n        };\n    }\n\n    /**\n     * Get notifications from site.\n     *\n     * @param read True if should get read notifications, false otherwise.\n     * @param options Other options.\n     * @returns Promise resolved with notifications.\n     */\n    async getNotificationsWithStatus(\n        read: AddonNotificationsGetReadType,\n        options: AddonNotificationsGetNotificationsOptions = {},\n    ): Promise<AddonNotificationsNotificationMessageFormatted[]> {\n        options.offset = options.offset || 0;\n        options.limit = options.limit || AddonNotificationsProvider.LIST_LIMIT;\n\n        const typeText = read === AddonNotificationsGetReadType.READ ?\n            'read' :\n            (read === AddonNotificationsGetReadType.UNREAD ? 'unread' : 'read and unread');\n        this.logger.debug(`Get ${typeText} notifications from ${options.offset}. Limit: ${options.limit}`);\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const data: AddonNotificationsGetMessagesWSParams = {\n            useridto: site.getUserId(),\n            useridfrom: 0,\n            type: 'notifications',\n            read: read,\n            newestfirst: true,\n            limitfrom: options.offset,\n            limitnum: options.limit,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getNotificationsCacheKey(),\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        // Get unread notifications.\n        const response = await site.read<AddonNotificationsGetMessagesWSResponse>('core_message_get_messages', data, preSets);\n\n        const notifications = response.messages;\n\n        return this.formatNotificationsData(notifications);\n    }\n\n    /**\n     * Get unread notifications count. Do not cache calls.\n     *\n     * @param userId The user id who received the notification. If not defined, use current user.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the message notifications count.\n     */\n    async getUnreadNotificationsCount(userId?: number, siteId?: string): Promise<{ count: number; hasMore: boolean} > {\n        const site = await CoreSites.getSite(siteId);\n\n        // @since 4.0\n        if (site.wsAvailable('core_message_get_unread_notification_count')) {\n            const params: CoreMessageGetUnreadNotificationCountWSParams = {\n                useridto: userId || site.getUserId(),\n            };\n\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getUnreadNotificationsCountCacheKey(params.useridto),\n                getFromCache: false, // Always try to get the latest number.\n                typeExpected: 'number',\n            };\n\n            try {\n                const count = await site.read<number>('core_message_get_unread_notification_count', params, preSets);\n\n                return {\n                    count,\n                    hasMore: false,\n                };\n            } catch {\n                // Return no notifications if the call fails.\n                return {\n                    count: 0,\n                    hasMore: false,\n                };\n            }\n        }\n\n        // Fallback call\n        try {\n            const unread = await this.getNotificationsWithStatus(AddonNotificationsGetReadType.UNREAD, {\n                limit: AddonNotificationsProvider.LIST_LIMIT + 1,\n                siteId,\n            });\n\n            return {\n                count: Math.min(unread.length, AddonNotificationsProvider.LIST_LIMIT),\n                hasMore: unread.length > AddonNotificationsProvider.LIST_LIMIT,\n            };\n        } catch {\n            // Return no notifications if the call fails.\n            return {\n                count: 0,\n                hasMore: false,\n            };\n        }\n    }\n\n    /**\n     * Get cache key for unread notifications count WS calls.\n     *\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getUnreadNotificationsCountCacheKey(userId: number): string {\n        return `${ROOT_CACHE_KEY}count:${userId}`;\n    }\n\n    /**\n     * Mark all message notification as read.\n     *\n     * @returns Resolved when done.\n     */\n    async markAllNotificationsAsRead(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreMessageMarkAllNotificationsAsReadWSParams = {\n            useridto: CoreSites.getCurrentSiteUserId(),\n        };\n\n        return site.write<boolean>('core_message_mark_all_notifications_as_read', params);\n    }\n\n    /**\n     * Mark a single notification as read.\n     *\n     * @param notificationId ID of notification to mark as read\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async markNotificationRead(\n        notificationId: number,\n        siteId?: string,\n    ): Promise<CoreMessageMarkNotificationReadWSResponse> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        const params: CoreMessageMarkNotificationReadWSParams = {\n            notificationid: notificationId,\n            timeread: CoreTimeUtils.timestamp(),\n        };\n\n        return site.write<CoreMessageMarkNotificationReadWSResponse>('core_message_mark_notification_read', params);\n    }\n\n    /**\n     * Invalidate get notification preferences.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data is invalidated.\n     */\n    async invalidateNotificationPreferences(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getNotificationPreferencesCacheKey());\n    }\n\n    /**\n     * Invalidates notifications list WS calls.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the list is invalidated.\n     */\n    async invalidateNotificationsList(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getNotificationsCacheKey());\n    }\n\n}\n\nexport const AddonNotifications = makeSingleton(AddonNotificationsProvider);\n\n/**\n * Preferences returned by core_message_get_user_notification_preferences.\n */\nexport type AddonNotificationsPreferences = {\n    userid: number; // User id.\n    disableall: number | boolean; // Whether all the preferences are disabled.\n    processors: AddonNotificationsPreferencesProcessor[]; // Config form values.\n    components: AddonNotificationsPreferencesComponent[]; // Available components.\n    enableall?: boolean; // Calculated in the app. Whether all the preferences are enabled.\n};\n\n/**\n * Processor in notification preferences.\n */\nexport type AddonNotificationsPreferencesProcessor = {\n    displayname: string; // Display name.\n    name: string; // Processor name.\n    hassettings: boolean; // Whether has settings.\n    contextid: number; // Context id.\n    userconfigured: number; // Whether is configured by the user.\n};\n\n/**\n * Component in notification preferences.\n */\nexport type AddonNotificationsPreferencesComponent = {\n    displayname: string; // Display name.\n    notifications: AddonNotificationsPreferencesNotification[]; // List of notificaitons for the component.\n};\n\n/**\n * Notification processor in notification preferences component.\n */\nexport type AddonNotificationsPreferencesNotification = {\n    displayname: string; // Display name.\n    preferencekey: string; // Preference key.\n    processors: AddonNotificationsPreferencesNotificationProcessor[]; // Processors values for this notification.\n};\n\n/**\n * Notification processor in notification preferences component.\n */\nexport type AddonNotificationsPreferencesNotificationProcessor = {\n    displayname: string; // Display name.\n    name: string; // Processor name.\n    locked: boolean; // Is locked by admin?.\n    lockedmessage?: string; // @since 3.6. Text to display if locked.\n    userconfigured: number; // Is configured?.\n    enabled?: boolean; // @since 4.0. Processor enabled.\n    loggedin: AddonNotificationsPreferencesNotificationProcessorState; // @deprecatedonmoodle since 4.0.\n    loggedoff: AddonNotificationsPreferencesNotificationProcessorState; // @deprecatedonmoodle since 4.0.\n};\n\n/**\n * State in notification processor in notification preferences component.\n *\n * @deprecatedonmoodle since 4.0\n */\nexport type AddonNotificationsPreferencesNotificationProcessorState = {\n    name: 'loggedoff' | 'loggedin'; // Name.\n    displayname: string; // Display name.\n    checked: boolean; // Is checked?.\n};\n\nexport type AddonNotificationsPreferencesNotificationProcessorStateSetting = 'loggedoff' | 'loggedin' | 'enabled';\n\n/**\n * Params of core_message_get_messages WS.\n */\nexport type AddonNotificationsGetMessagesWSParams = {\n    useridto: number; // The user id who received the message, 0 for any user.\n    useridfrom?: number; // The user id who send the message, 0 for any user. -10 or -20 for no-reply or support user.\n    type?: string; // Type of message to return, expected values are: notifications, conversations and both.\n    read?: AddonNotificationsGetReadType; // 0=unread, 1=read. @since 4.0 it also accepts 2=both.\n    newestfirst?: boolean; // True for ordering by newest first, false for oldest first.\n    limitfrom?: number; // Limit from.\n    limitnum?: number; // Limit number.\n};\n\n/**\n * Data returned by core_message_get_messages WS.\n */\nexport type AddonNotificationsGetMessagesWSResponse = {\n    messages: AddonNotificationsNotificationMessage[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Message data returned by core_message_get_messages.\n */\nexport type AddonNotificationsNotificationMessage = {\n    id: number; // Message id.\n    useridfrom: number; // User from id.\n    useridto: number; // User to id.\n    subject: string; // The message subject.\n    text: string; // The message text formated.\n    fullmessage: string; // The message.\n    fullmessageformat: number; // Fullmessage format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    fullmessagehtml: string; // The message in html.\n    smallmessage: string; // The shorten message.\n    notification: number; // Is a notification?.\n    contexturl: string | null; // Context URL.\n    contexturlname: string | null; // Context URL link name.\n    timecreated: number; // Time created.\n    timeread: number; // Time read.\n    usertofullname: string; // User to full name.\n    userfromfullname: string; // User from full name.\n    component?: string; // @since 3.7. The component that generated the notification.\n    eventtype?: string; // @since 3.7. The type of notification.\n    customdata?: string; // @since 3.7. Custom data to be passed to the message processor.\n    iconurl?: string; // @since 4.0. Icon URL, only for notifications.\n};\n\n/**\n * Message data returned by core_message_get_messages with some calculated data.\n */\nexport type AddonNotificationsNotificationMessageFormatted =\n        Omit<AddonNotificationsNotificationMessage, 'customdata'> & AddonNotificationsNotificationCalculatedData;\n\n/**\n * Result of WS core_message_get_user_notification_preferences.\n */\nexport type AddonNotificationsGetUserNotificationPreferencesResult = {\n    preferences: AddonNotificationsPreferences;\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Calculated data for messages returned by core_message_get_messages.\n */\nexport type AddonNotificationsNotificationCalculatedData = {\n    mobiletext: string; // Calculated in the app. Text to display for the notification.\n    moodlecomponent?: string; // Calculated in the app. Moodle's component.\n    notif: number; // Calculated in the app. Whether it's a notification.\n    notification: number; // Calculated in the app in some cases. Whether it's a notification.\n    read: boolean; // Calculated in the app. Whether the notifications is read.\n    courseid?: number; // Calculated in the app. Course the notification belongs to.\n    profileimageurlfrom?: string; // Calculated in the app. Avatar of user that sent the notification.\n    userfromfullname?: string; // Calculated in the app in some cases. User from full name.\n    customdata?: Record<string, string|number>; // Parsed custom data.\n    imgUrl?: string; // Calculated in the app. URL of the image to use if the notification has no real user from.\n};\n\n/**\n * Params of core_message_mark_all_notifications_as_read WS.\n */\nexport type CoreMessageMarkAllNotificationsAsReadWSParams = {\n    useridto: number; // The user id who received the message, 0 for any user.\n    useridfrom?: number; // The user id who send the message, 0 for any user. -10 or -20 for no-reply or support user.\n    timecreatedto?: number; // Mark messages created before this time as read, 0 for all messages.\n};\n\n/**\n * Params of core_message_mark_notification_read WS.\n */\nexport type CoreMessageMarkNotificationReadWSParams = {\n    notificationid: number; // Id of the notification.\n    timeread?: number; // Timestamp for when the notification should be marked read.\n};\n\n/**\n * Data returned by core_message_mark_notification_read WS.\n */\nexport type CoreMessageMarkNotificationReadWSResponse = {\n    notificationid: number; // Id of the notification.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_message_get_unread_notification_count WS.\n */\nexport type CoreMessageGetUnreadNotificationCountWSParams = {\n    useridto: number; // User id who received the notification, 0 for any user.\n};\n\n/**\n * Options to pass to getNotifications.\n */\nexport type AddonNotificationsGetNotificationsOptions = CoreSitesCommonWSOptions & {\n    offset?: number; // Offset to use. Defaults to 0.\n    limit?: number; // Number of notifications to get. Defaults to LIST_LIMIT.\n};\n\n/**\n * Constants to get either read, unread or both notifications.\n */\nexport enum AddonNotificationsGetReadType {\n    UNREAD = 0,\n    READ = 1,\n    BOTH = 2,\n}\n\n/**\n * Event triggered when one or more notifications are read.\n */\nexport type AddonNotificationsReadChangedEvent = {\n    id?: number; // Set to the single id notification read. Undefined if multiple.\n    time: number; // Time of the change.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}