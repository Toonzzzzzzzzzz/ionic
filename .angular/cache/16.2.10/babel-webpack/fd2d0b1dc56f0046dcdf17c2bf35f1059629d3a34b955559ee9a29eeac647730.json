{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { ENTRIES_TABLE_NAME } from './database/glossary';\nimport { AddonModGlossaryOffline } from './glossary-offline';\nimport * as i0 from \"@angular/core\";\nexport const GLOSSARY_ENTRY_ADDED = 'addon_mod_glossary_entry_added';\nexport const GLOSSARY_ENTRY_UPDATED = 'addon_mod_glossary_entry_updated';\nexport const GLOSSARY_ENTRY_DELETED = 'addon_mod_glossary_entry_deleted';\n/**\n * Service that provides some features for glossaries.\n */\nexport class AddonModGlossaryProvider {\n  /**\n   * Get the course glossary cache key.\n   *\n   * @param courseId Course Id.\n   * @returns Cache key.\n   */\n  getCourseGlossariesCacheKey(courseId) {\n    return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}courseGlossaries:${courseId}`;\n  }\n  /**\n   * Get all the glossaries in a course.\n   *\n   * @param courseId Course Id.\n   * @param options Other options.\n   * @returns Resolved with the glossaries.\n   */\n  getCourseGlossaries(courseId, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this.getCourseGlossariesCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModGlossaryProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const result = yield site.read('mod_glossary_get_glossaries_by_courses', params, preSets);\n      return result.glossaries;\n    })();\n  }\n  /**\n   * Invalidate all glossaries in a course.\n   *\n   * @param courseId Course Id.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateCourseGlossaries(courseId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this2.getCourseGlossariesCacheKey(courseId);\n      yield site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Get the entries by author cache key.\n   *\n   * @param glossaryId Glossary Id.\n   * @returns Cache key.\n   */\n  getEntriesByAuthorCacheKey(glossaryId) {\n    return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesByAuthor:${glossaryId}:ALL:LASTNAME:ASC`;\n  }\n  /**\n   * Get entries by author.\n   *\n   * @param glossaryId Glossary Id.\n   * @param options Other options.\n   * @returns Resolved with the entries.\n   */\n  getEntriesByAuthor(glossaryId, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        id: glossaryId,\n        letter: 'ALL',\n        field: 'LASTNAME',\n        sort: 'ASC',\n        from: options.from || 0,\n        limit: options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this3.getEntriesByAuthorCacheKey(glossaryId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModGlossaryProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_glossary_get_entries_by_author', params, preSets);\n    })();\n  }\n  /**\n   * Invalidate cache of entries by author.\n   *\n   * @param glossaryId Glossary Id.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateEntriesByAuthor(glossaryId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this4.getEntriesByAuthorCacheKey(glossaryId);\n      yield site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Get entries by category.\n   *\n   * @param glossaryId Glossary Id.\n   * @param options Other options.\n   * @returns Resolved with the entries.\n   */\n  getEntriesByCategory(glossaryId, options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        id: glossaryId,\n        categoryid: AddonModGlossaryProvider.SHOW_ALL_CATEGORIES,\n        from: options.from || 0,\n        limit: options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this5.getEntriesByCategoryCacheKey(glossaryId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModGlossaryProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_glossary_get_entries_by_category', params, preSets);\n    })();\n  }\n  /**\n   * Invalidate cache of entries by category.\n   *\n   * @param glossaryId Glossary Id.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateEntriesByCategory(glossaryId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this6.getEntriesByCategoryCacheKey(glossaryId);\n      yield site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Get the entries by category cache key.\n   *\n   * @param glossaryId Glossary Id.\n   * @returns Cache key.\n   */\n  getEntriesByCategoryCacheKey(glossaryId) {\n    const prefix = `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesByCategory`;\n    return `${prefix}:${glossaryId}:${AddonModGlossaryProvider.SHOW_ALL_CATEGORIES}`;\n  }\n  /**\n   * Get the entries by date cache key.\n   *\n   * @param glossaryId Glossary Id.\n   * @param order The way to order the records.\n   * @returns Cache key.\n   */\n  getEntriesByDateCacheKey(glossaryId, order) {\n    return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesByDate:${glossaryId}:${order}:DESC`;\n  }\n  /**\n   * Get entries by date.\n   *\n   * @param glossaryId Glossary Id.\n   * @param order The way to order the records.\n   * @param options Other options.\n   * @returns Resolved with the entries.\n   */\n  getEntriesByDate(glossaryId, order, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        id: glossaryId,\n        order: order,\n        sort: 'DESC',\n        from: options.from || 0,\n        limit: options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this7.getEntriesByDateCacheKey(glossaryId, order),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModGlossaryProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_glossary_get_entries_by_date', params, preSets);\n    })();\n  }\n  /**\n   * Invalidate cache of entries by date.\n   *\n   * @param glossaryId Glossary Id.\n   * @param order The way to order the records.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateEntriesByDate(glossaryId, order, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this8.getEntriesByDateCacheKey(glossaryId, order);\n      yield site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Get the entries by letter cache key.\n   *\n   * @param glossaryId Glossary Id.\n   * @returns Cache key.\n   */\n  getEntriesByLetterCacheKey(glossaryId) {\n    return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesByLetter:${glossaryId}:ALL`;\n  }\n  /**\n   * Get entries by letter.\n   *\n   * @param glossaryId Glossary Id.\n   * @param options Other options.\n   * @returns Resolved with the entries.\n   */\n  getEntriesByLetter(glossaryId, options = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const from = options.from || 0;\n      const limit = options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES;\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        id: glossaryId,\n        letter: 'ALL',\n        from,\n        limit\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this9.getEntriesByLetterCacheKey(glossaryId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModGlossaryProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const result = yield site.read('mod_glossary_get_entries_by_letter', params, preSets);\n      if (limit === AddonModGlossaryProvider.LIMIT_ENTRIES) {\n        // Store entries in background, don't block the user for this.\n        CoreUtils.ignoreErrors(_this9.storeEntries(glossaryId, result.entries, from, site.getId()));\n      }\n      return result;\n    })();\n  }\n  /**\n   * Invalidate cache of entries by letter.\n   *\n   * @param glossaryId Glossary Id.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateEntriesByLetter(glossaryId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this10.getEntriesByLetterCacheKey(glossaryId);\n      yield site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Get the entries by search cache key.\n   *\n   * @param glossaryId Glossary Id.\n   * @param query The search query.\n   * @param fullSearch Whether or not full search is required.\n   * @returns Cache key.\n   */\n  getEntriesBySearchCacheKey(glossaryId, query, fullSearch) {\n    return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesBySearch:${glossaryId}:${fullSearch}:CONCEPT:ASC:${query}`;\n  }\n  /**\n   * Get entries by search.\n   *\n   * @param glossaryId Glossary Id.\n   * @param query The search query.\n   * @param fullSearch Whether or not full search is required.\n   * @param options Get entries options.\n   * @returns Resolved with the entries.\n   */\n  getEntriesBySearch(glossaryId, query, fullSearch, options = {}) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        id: glossaryId,\n        query: query,\n        fullsearch: fullSearch,\n        order: 'CONCEPT',\n        sort: 'ASC',\n        from: options.from || 0,\n        limit: options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this11.getEntriesBySearchCacheKey(glossaryId, query, fullSearch),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModGlossaryProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_glossary_get_entries_by_search', params, preSets);\n    })();\n  }\n  /**\n   * Invalidate cache of entries by search.\n   *\n   * @param glossaryId Glossary Id.\n   * @param query The search query.\n   * @param fullSearch Whether or not full search is required.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateEntriesBySearch(glossaryId, query, fullSearch, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const key = _this12.getEntriesBySearchCacheKey(glossaryId, query, fullSearch);\n      yield site.invalidateWsCacheForKey(key);\n    })();\n  }\n  /**\n   * Get the glossary categories cache key.\n   *\n   * @param glossaryId Glossary Id.\n   * @returns The cache key.\n   */\n  getCategoriesCacheKey(glossaryId) {\n    return AddonModGlossaryProvider.ROOT_CACHE_KEY + 'categories:' + glossaryId;\n  }\n  /**\n   * Get all the categories related to the glossary.\n   *\n   * @param glossaryId Glossary Id.\n   * @param options Other options.\n   * @returns Promise resolved with the categories if supported or empty array if not.\n   */\n  getAllCategories(glossaryId, options = {}) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      return _this13.getCategories(glossaryId, [], site, options);\n    })();\n  }\n  /**\n   * Get the categories related to the glossary by sections. It's a recursive function see initial call values.\n   *\n   * @param glossaryId Glossary Id.\n   * @param categories Already fetched categories where to append the fetch.\n   * @param site Site object.\n   * @param options Other options.\n   * @returns Promise resolved with the categories.\n   */\n  getCategories(glossaryId, categories, site, options = {}) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const from = options.from || 0;\n      const limit = options.limit || AddonModGlossaryProvider.LIMIT_CATEGORIES;\n      const params = {\n        id: glossaryId,\n        from,\n        limit\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this14.getCategoriesCacheKey(glossaryId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModGlossaryProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_glossary_get_categories', params, preSets);\n      categories = categories.concat(response.categories);\n      const canLoadMore = from + limit < response.count;\n      if (canLoadMore) {\n        return _this14.getCategories(glossaryId, categories, site, _objectSpread(_objectSpread({}, options), {}, {\n          from: from + limit\n        }));\n      }\n      return categories;\n    })();\n  }\n  /**\n   * Invalidate cache of categories by glossary id.\n   *\n   * @param glossaryId Glossary Id.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateCategories(glossaryId, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this15.getCategoriesCacheKey(glossaryId));\n    })();\n  }\n  /**\n   * Get an entry by ID cache key.\n   *\n   * @param entryId Entry Id.\n   * @returns Cache key.\n   */\n  getEntryCacheKey(entryId) {\n    return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}getEntry:${entryId}`;\n  }\n  /**\n   * Get one entry by ID.\n   *\n   * @param entryId Entry ID.\n   * @param options Other options.\n   * @returns Promise resolved with the entry.\n   */\n  getEntry(entryId, options = {}) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        id: entryId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this16.getEntryCacheKey(entryId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModGlossaryProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      try {\n        return yield site.read('mod_glossary_get_entry_by_id', params, preSets);\n      } catch (error) {\n        // Entry not found. Search it in the list of entries.\n        try {\n          const data = yield _this16.getStoredDataForEntry(entryId, site.getId());\n          if (data.from !== undefined) {\n            const response = yield CoreUtils.ignoreErrors(_this16.getEntryFromList(data.glossaryId, entryId, data.from, false, options));\n            if (response) {\n              return response;\n            }\n          }\n          // Page not specified or entry not found in the page, search all pages.\n          return yield _this16.getEntryFromList(data.glossaryId, entryId, 0, true, options);\n        } catch (_unused) {\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Get a glossary ID and the \"from\" of a given entry.\n   *\n   * @param entryId Entry ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the glossary ID and the \"from\".\n   */\n  getStoredDataForEntry(entryId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const conditions = {\n        entryid: entryId\n      };\n      const record = yield site.getDb().getRecord(ENTRIES_TABLE_NAME, conditions);\n      return {\n        glossaryId: record.glossaryid,\n        from: record.pagefrom\n      };\n    })();\n  }\n  /**\n   * Get an entry from the list of entries.\n   *\n   * @param glossaryId Glossary ID.\n   * @param entryId Entry ID.\n   * @param from Page to get.\n   * @param loadNext Whether to load next pages if not found.\n   * @param options Options.\n   * @returns Promise resolved with the entry data.\n   */\n  getEntryFromList(glossaryId, entryId, from, loadNext, options = {}) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      // Get the entries from this \"page\" and check if the entry we're looking for is in it.\n      const result = yield _this17.getEntriesByLetter(glossaryId, {\n        from: from,\n        readingStrategy: 0 /* CoreSitesReadingStrategy.ONLY_CACHE */,\n        cmId: options.cmId,\n        siteId: options.siteId\n      });\n      const entry = result.entries.find(entry => entry.id == entryId);\n      if (entry) {\n        // Entry found, return it.\n        return {\n          entry,\n          from\n        };\n      }\n      const nextFrom = from + result.entries.length;\n      if (nextFrom < result.count && loadNext) {\n        // Get the next \"page\".\n        return _this17.getEntryFromList(glossaryId, entryId, nextFrom, true, options);\n      }\n      // No more pages and the entry wasn't found. Reject.\n      throw new CoreError('Entry not found.');\n    })();\n  }\n  /**\n   * Check whether the site can delete glossary entries.\n   *\n   * @param siteId Site id.\n   * @returns Whether the site can delete entries.\n   */\n  canDeleteEntries(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.wsAvailable('mod_glossary_delete_entry');\n    })();\n  }\n  /**\n   * Check whether the site can update glossary entries.\n   *\n   * @param siteId Site id.\n   * @returns Whether the site can update entries.\n   */\n  canUpdateEntries(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.wsAvailable('mod_glossary_update_entry');\n    })();\n  }\n  /**\n   * Performs the whole fetch of the entries using the proper function and arguments.\n   *\n   * @param fetchFunction Function to fetch.\n   * @param options Other options.\n   * @returns Promise resolved with all entrries.\n   */\n  fetchAllEntries(fetchFunction, options = {}) {\n    options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n    const entries = [];\n    const fetchMoreEntries = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        const result = yield fetchFunction(_objectSpread({\n          from: entries.length\n        }, options));\n        Array.prototype.push.apply(entries, result.entries);\n        return entries.length < result.count ? fetchMoreEntries() : entries;\n      });\n      return function fetchMoreEntries() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    return fetchMoreEntries();\n  }\n  /**\n   * Invalidate cache of entry by ID.\n   *\n   * @param entryId Entry Id.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateEntry(entryId, siteId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this18.getEntryCacheKey(entryId));\n    })();\n  }\n  /**\n   * Invalidate cache of all entries in the array.\n   *\n   * @param entries Entry objects to invalidate.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateEntries(entries, siteId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const keys = [];\n      entries.forEach(entry => {\n        keys.push(_this19.getEntryCacheKey(entry.id));\n      });\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateMultipleWsCacheForKey(keys);\n    })();\n  }\n  /**\n   * Invalidate the prefetched content except files.\n   * To invalidate files, use AddonModGlossary#invalidateFiles.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID.\n   */\n  invalidateContent(moduleId, courseId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const glossary = yield _this20.getGlossary(courseId, moduleId);\n      yield CoreUtils.ignoreErrors(_this20.invalidateGlossaryEntries(glossary));\n      yield CoreUtils.allPromises([_this20.invalidateCourseGlossaries(courseId), _this20.invalidateCategories(glossary.id)]);\n    })();\n  }\n  /**\n   * Invalidate the prefetched content for a given glossary, except files.\n   * To invalidate files, use AddonModGlossaryProvider#invalidateFiles.\n   *\n   * @param glossary The glossary object.\n   * @param onlyEntriesList If true, entries won't be invalidated.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  invalidateGlossaryEntries(glossary, onlyEntriesList, siteId) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const promises = [];\n      if (!onlyEntriesList) {\n        promises.push(_this21.fetchAllEntries(options => _this21.getEntriesByLetter(glossary.id, options), {\n          cmId: glossary.coursemodule,\n          readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n          siteId\n        }).then(entries => _this21.invalidateEntries(entries, siteId)));\n      }\n      glossary.browsemodes.forEach(mode => {\n        switch (mode) {\n          case 'letter':\n            promises.push(_this21.invalidateEntriesByLetter(glossary.id, siteId));\n            break;\n          case 'cat':\n            promises.push(_this21.invalidateEntriesByCategory(glossary.id, siteId));\n            break;\n          case 'date':\n            promises.push(_this21.invalidateEntriesByDate(glossary.id, 'CREATION', siteId));\n            promises.push(_this21.invalidateEntriesByDate(glossary.id, 'UPDATE', siteId));\n            break;\n          case 'author':\n            promises.push(_this21.invalidateEntriesByAuthor(glossary.id, siteId));\n            break;\n          default:\n        }\n      });\n      yield CoreUtils.allPromises(promises);\n    })();\n  }\n  /**\n   * Get one glossary by cmid.\n   *\n   * @param courseId Course Id.\n   * @param cmId Course Module Id.\n   * @param options Other options.\n   * @returns Promise resolved with the glossary.\n   */\n  getGlossary(courseId, cmId, options = {}) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const glossaries = yield _this22.getCourseGlossaries(courseId, options);\n      const glossary = glossaries.find(glossary => glossary.coursemodule == cmId);\n      if (glossary) {\n        return glossary;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get one glossary by glossary ID.\n   *\n   * @param courseId Course Id.\n   * @param glossaryId Glossary Id.\n   * @param options Other options.\n   * @returns Promise resolved with the glossary.\n   */\n  getGlossaryById(courseId, glossaryId, options = {}) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const glossaries = yield _this23.getCourseGlossaries(courseId, options);\n      const glossary = glossaries.find(glossary => glossary.id == glossaryId);\n      if (glossary) {\n        return glossary;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Create a new entry on a glossary\n   *\n   * @param glossaryId Glossary ID.\n   * @param concept Glossary entry concept.\n   * @param definition Glossary entry concept definition.\n   * @param courseId Course ID of the glossary.\n   * @param entryOptions Options for the entry.\n   * @param attachments Attachments ID if sending online, result of CoreFileUploaderProvider#storeFilesToUpload otherwise.\n   * @param otherOptions Other options.\n   * @returns Promise resolved with entry ID if entry was created in server, false if stored in device.\n   */\n  addEntry(glossaryId, concept, definition, courseId, entryOptions, attachments, otherOptions = {}) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      otherOptions.siteId = otherOptions.siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a new entry to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          var _otherOptions$timeCre;\n          if (otherOptions.checkDuplicates) {\n            // Check if the entry is duplicated in online or offline mode.\n            const conceptUsed = yield _this24.isConceptUsed(glossaryId, concept, {\n              cmId: otherOptions.cmId,\n              siteId: otherOptions.siteId\n            });\n            if (conceptUsed) {\n              throw new CoreError(Translate.instant('addon.mod_glossary.errconceptalreadyexists'));\n            }\n          }\n          if (typeof attachments == 'number') {\n            // When storing in offline the attachments can't be a draft ID.\n            throw new CoreError('Error adding entry.');\n          }\n          yield AddonModGlossaryOffline.addOfflineEntry(glossaryId, concept, definition, courseId, (_otherOptions$timeCre = otherOptions.timeCreated) !== null && _otherOptions$timeCre !== void 0 ? _otherOptions$timeCre : Date.now(), entryOptions, attachments, otherOptions.siteId, undefined);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline() && otherOptions.allowOffline) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        // Try to add it in online.\n        const entryId = yield _this24.addEntryOnline(glossaryId, concept, definition, entryOptions, attachments, otherOptions.siteId);\n        return entryId;\n      } catch (error) {\n        if (otherOptions.allowOffline && !CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server, store in offline.\n          return storeOffline();\n        }\n        // The WebService has thrown an error or offline not supported, reject.\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Create a new entry on a glossary. It does not cache calls. It will fail if offline or cannot connect.\n   *\n   * @param glossaryId Glossary ID.\n   * @param concept Glossary entry concept.\n   * @param definition Glossary entry concept definition.\n   * @param options Options for the entry.\n   * @param attachId Attachments ID (if any attachment).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the entry ID if created, rejected otherwise.\n   */\n  addEntryOnline(glossaryId, concept, definition, options, attachId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        glossaryid: glossaryId,\n        concept: concept,\n        definition: definition,\n        definitionformat: 1,\n        options: CoreUtils.objectToArrayOfObjects(options || {}, 'name', 'value')\n      };\n      if (attachId) {\n        var _params$options;\n        (_params$options = params.options) === null || _params$options === void 0 || _params$options.push({\n          name: 'attachmentsid',\n          value: String(attachId)\n        });\n      }\n      const response = yield site.write('mod_glossary_add_entry', params);\n      CoreEvents.trigger(GLOSSARY_ENTRY_ADDED, {\n        glossaryId,\n        entryId: response.entryid\n      }, siteId);\n      return response.entryid;\n    })();\n  }\n  /**\n   * Update an existing entry on a glossary.\n   *\n   * @param glossaryId Glossary ID.\n   * @param entryId Entry ID.\n   * @param concept Glossary entry concept.\n   * @param definition Glossary entry concept definition.\n   * @param options Options for the entry.\n   * @param attachId Attachments ID (if any attachment).\n   * @param siteId Site ID. If not defined, current site.\n   */\n  updateEntry(glossaryId, entryId, concept, definition, options, attachId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        entryid: entryId,\n        concept: concept,\n        definition: definition,\n        definitionformat: 1,\n        options: CoreUtils.objectToArrayOfObjects(options || {}, 'name', 'value')\n      };\n      if (attachId) {\n        var _params$options2;\n        (_params$options2 = params.options) === null || _params$options2 === void 0 || _params$options2.push({\n          name: 'attachmentsid',\n          value: String(attachId)\n        });\n      }\n      const response = yield site.write('mod_glossary_update_entry', params);\n      if (!response.result) {\n        var _response$warnings$0$, _response$warnings;\n        throw new CoreError((_response$warnings$0$ = (_response$warnings = response.warnings) === null || _response$warnings === void 0 ? void 0 : _response$warnings[0].message) !== null && _response$warnings$0$ !== void 0 ? _response$warnings$0$ : 'Error updating entry');\n      }\n      CoreEvents.trigger(GLOSSARY_ENTRY_UPDATED, {\n        glossaryId,\n        entryId\n      }, siteId);\n    })();\n  }\n  /**\n   * Delete entry.\n   *\n   * @param glossaryId Glossary id.\n   * @param entryId Entry id.\n   */\n  deleteEntry(glossaryId, entryId) {\n    return _asyncToGenerator(function* () {\n      const site = CoreSites.getRequiredCurrentSite();\n      yield site.write('mod_glossary_delete_entry', {\n        entryid: entryId\n      });\n      CoreEvents.trigger(GLOSSARY_ENTRY_DELETED, {\n        glossaryId,\n        entryId\n      });\n    })();\n  }\n  /**\n   * Check if a entry concept is already used.\n   *\n   * @param glossaryId Glossary ID.\n   * @param concept Concept to check.\n   * @param options Other options.\n   * @returns Promise resolved with true if used, resolved with false if not used or error.\n   */\n  isConceptUsed(glossaryId, concept, options = {}) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // Check offline first.\n        const exists = yield AddonModGlossaryOffline.isConceptUsed(glossaryId, concept, options.timeCreated, options.siteId);\n        if (exists) {\n          return true;\n        }\n        // If we get here, there's no offline entry with this name, check online.\n        // Get entries from the cache.\n        const entries = yield _this25.fetchAllEntries(options => _this25.getEntriesByLetter(glossaryId, options), {\n          cmId: options.cmId,\n          readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */,\n          siteId: options.siteId\n        });\n        // Check if there's any entry with the same concept.\n        return entries.some(entry => entry.concept == concept);\n      } catch (_unused2) {\n        // Error, assume not used.\n        return false;\n      }\n    })();\n  }\n  /**\n   * Report a glossary as being viewed.\n   *\n   * @param glossaryId Glossary ID.\n   * @param mode The mode in which the glossary was viewed.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  logView(glossaryId, mode, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        id: glossaryId,\n        mode: mode\n      };\n      yield CoreCourseLogHelper.log('mod_glossary_view_glossary', params, AddonModGlossaryProvider.COMPONENT, glossaryId, siteId);\n    })();\n  }\n  /**\n   * Report a glossary entry as being viewed.\n   *\n   * @param entryId Entry ID.\n   * @param glossaryId Glossary ID.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  logEntryView(entryId, glossaryId, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        id: entryId\n      };\n      yield CoreCourseLogHelper.log('mod_glossary_view_entry', params, AddonModGlossaryProvider.COMPONENT, glossaryId, siteId);\n    })();\n  }\n  /**\n   * Store several entries so we can determine their glossaryId in offline.\n   *\n   * @param glossaryId Glossary ID the entries belongs to.\n   * @param entries Entries.\n   * @param from The \"page\" the entries belong to.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  storeEntries(glossaryId, entries, from, siteId) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all(entries.map(entry => _this26.storeEntryId(glossaryId, entry.id, from, siteId)));\n    })();\n  }\n  /**\n   * Store an entry so we can determine its glossaryId in offline.\n   *\n   * @param glossaryId Glossary ID the entry belongs to.\n   * @param entryId Entry ID.\n   * @param from The \"page\" the entry belongs to.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  storeEntryId(glossaryId, entryId, from, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        entryid: entryId,\n        glossaryid: glossaryId,\n        pagefrom: from\n      };\n      yield site.getDb().insertRecord(ENTRIES_TABLE_NAME, entry);\n    })();\n  }\n}\n_class = AddonModGlossaryProvider;\n_class.COMPONENT = 'mmaModGlossary';\n_class.LIMIT_ENTRIES = 25;\n_class.LIMIT_CATEGORIES = 10;\n_class.SHOW_ALL_CATEGORIES = 0;\n_class.ROOT_CACHE_KEY = 'mmaModGlossary:';\n_class.ɵfac = function AddonModGlossaryProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModGlossary = makeSingleton(AddonModGlossaryProvider);","map":{"version":3,"names":["CoreError","CoreSite","CoreCourseLogHelper","CoreNetwork","CoreSites","CoreSitesReadingStrategy","CoreUtils","makeSingleton","Translate","CoreEvents","ENTRIES_TABLE_NAME","AddonModGlossaryOffline","GLOSSARY_ENTRY_ADDED","GLOSSARY_ENTRY_UPDATED","GLOSSARY_ENTRY_DELETED","AddonModGlossaryProvider","getCourseGlossariesCacheKey","courseId","ROOT_CACHE_KEY","getCourseGlossaries","options","_this","_asyncToGenerator","site","getSite","siteId","params","courseids","preSets","_objectSpread","cacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","result","read","glossaries","invalidateCourseGlossaries","_this2","key","invalidateWsCacheForKey","getEntriesByAuthorCacheKey","glossaryId","getEntriesByAuthor","_this3","id","letter","field","sort","from","limit","LIMIT_ENTRIES","FREQUENCY_SOMETIMES","componentId","cmId","invalidateEntriesByAuthor","_this4","getEntriesByCategory","_this5","categoryid","SHOW_ALL_CATEGORIES","getEntriesByCategoryCacheKey","invalidateEntriesByCategory","_this6","prefix","getEntriesByDateCacheKey","order","getEntriesByDate","_this7","invalidateEntriesByDate","_this8","getEntriesByLetterCacheKey","getEntriesByLetter","_this9","ignoreErrors","storeEntries","entries","getId","invalidateEntriesByLetter","_this10","getEntriesBySearchCacheKey","query","fullSearch","getEntriesBySearch","_this11","fullsearch","invalidateEntriesBySearch","_this12","getCategoriesCacheKey","getAllCategories","_this13","getCategories","categories","_this14","LIMIT_CATEGORIES","response","concat","canLoadMore","count","invalidateCategories","_this15","getEntryCacheKey","entryId","getEntry","_this16","error","data","getStoredDataForEntry","undefined","getEntryFromList","_unused","conditions","entryid","record","getDb","getRecord","glossaryid","pagefrom","loadNext","_this17","entry","find","nextFrom","length","canDeleteEntries","wsAvailable","canUpdateEntries","fetchAllEntries","fetchFunction","getCurrentSiteId","fetchMoreEntries","_ref","Array","prototype","push","apply","arguments","invalidateEntry","_this18","invalidateEntries","_this19","keys","forEach","invalidateMultipleWsCacheForKey","invalidateContent","moduleId","_this20","glossary","getGlossary","invalidateGlossaryEntries","allPromises","onlyEntriesList","_this21","promises","coursemodule","then","browsemodes","mode","_this22","instant","getGlossaryById","_this23","addEntry","concept","definition","entryOptions","attachments","otherOptions","_this24","storeOffline","_ref2","_otherOptions$timeCre","checkDuplicates","conceptUsed","isConceptUsed","addOfflineEntry","timeCreated","Date","now","isOnline","allowOffline","addEntryOnline","isWebServiceError","attachId","definitionformat","objectToArrayOfObjects","_params$options","name","value","String","write","trigger","updateEntry","_params$options2","_response$warnings$0$","_response$warnings","warnings","message","deleteEntry","getRequiredCurrentSite","_this25","exists","some","_unused2","logView","log","logEntryView","_this26","Promise","all","map","storeEntryId","insertRecord","_class","factory","ɵfac","providedIn","AddonModGlossary"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/glossary/services/glossary.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreFileUploaderStoreFilesResult } from '@features/fileuploader/services/fileuploader';\nimport { CoreRatingInfo } from '@features/rating/services/rating';\nimport { CoreTagItem } from '@features/tag/services/tag';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModGlossaryEntryDBRecord, ENTRIES_TABLE_NAME } from './database/glossary';\nimport { AddonModGlossaryOffline } from './glossary-offline';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nexport const GLOSSARY_ENTRY_ADDED = 'addon_mod_glossary_entry_added';\nexport const GLOSSARY_ENTRY_UPDATED = 'addon_mod_glossary_entry_updated';\nexport const GLOSSARY_ENTRY_DELETED = 'addon_mod_glossary_entry_deleted';\n\n/**\n * Service that provides some features for glossaries.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModGlossaryProvider {\n\n    static readonly COMPONENT = 'mmaModGlossary';\n    static readonly LIMIT_ENTRIES = 25;\n    static readonly LIMIT_CATEGORIES = 10;\n\n    private static readonly SHOW_ALL_CATEGORIES = 0;\n    private static readonly ROOT_CACHE_KEY = 'mmaModGlossary:';\n\n    /**\n     * Get the course glossary cache key.\n     *\n     * @param courseId Course Id.\n     * @returns Cache key.\n     */\n    protected getCourseGlossariesCacheKey(courseId: number): string {\n        return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}courseGlossaries:${courseId}`;\n    }\n\n    /**\n     * Get all the glossaries in a course.\n     *\n     * @param courseId Course Id.\n     * @param options Other options.\n     * @returns Resolved with the glossaries.\n     */\n    async getCourseGlossaries(courseId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModGlossaryGlossary[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModGlossaryGetGlossariesByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCourseGlossariesCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModGlossaryProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const result = await site.read<AddonModGlossaryGetGlossariesByCoursesWSResponse>(\n            'mod_glossary_get_glossaries_by_courses',\n            params,\n            preSets,\n        );\n\n        return result.glossaries;\n    }\n\n    /**\n     * Invalidate all glossaries in a course.\n     *\n     * @param courseId Course Id.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateCourseGlossaries(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const key = this.getCourseGlossariesCacheKey(courseId);\n\n        await site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Get the entries by author cache key.\n     *\n     * @param glossaryId Glossary Id.\n     * @returns Cache key.\n     */\n    protected getEntriesByAuthorCacheKey(glossaryId: number): string {\n        return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesByAuthor:${glossaryId}:ALL:LASTNAME:ASC`;\n    }\n\n    /**\n     * Get entries by author.\n     *\n     * @param glossaryId Glossary Id.\n     * @param options Other options.\n     * @returns Resolved with the entries.\n     */\n    async getEntriesByAuthor(\n        glossaryId: number,\n        options: AddonModGlossaryGetEntriesOptions = {},\n    ): Promise<AddonModGlossaryGetEntriesWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModGlossaryGetEntriesByAuthorWSParams = {\n            id: glossaryId,\n            letter: 'ALL',\n            field: 'LASTNAME',\n            sort: 'ASC',\n            from: options.from || 0,\n            limit: options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEntriesByAuthorCacheKey(glossaryId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModGlossaryProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_glossary_get_entries_by_author', params, preSets);\n    }\n\n    /**\n     * Invalidate cache of entries by author.\n     *\n     * @param glossaryId Glossary Id.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateEntriesByAuthor(glossaryId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const key = this.getEntriesByAuthorCacheKey(glossaryId);\n\n        await site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Get entries by category.\n     *\n     * @param glossaryId Glossary Id.\n     * @param options Other options.\n     * @returns Resolved with the entries.\n     */\n    async getEntriesByCategory(\n        glossaryId: number,\n        options: AddonModGlossaryGetEntriesOptions = {},\n    ): Promise<AddonModGlossaryGetEntriesByCategoryWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModGlossaryGetEntriesByCategoryWSParams = {\n            id: glossaryId,\n            categoryid: AddonModGlossaryProvider.SHOW_ALL_CATEGORIES,\n            from: options.from || 0,\n            limit: options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEntriesByCategoryCacheKey(glossaryId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModGlossaryProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_glossary_get_entries_by_category', params, preSets);\n    }\n\n    /**\n     * Invalidate cache of entries by category.\n     *\n     * @param glossaryId Glossary Id.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateEntriesByCategory(glossaryId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const key = this.getEntriesByCategoryCacheKey(glossaryId);\n\n        await site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Get the entries by category cache key.\n     *\n     * @param glossaryId Glossary Id.\n     * @returns Cache key.\n     */\n    getEntriesByCategoryCacheKey(glossaryId: number): string {\n        const prefix = `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesByCategory`;\n\n        return `${prefix}:${glossaryId}:${AddonModGlossaryProvider.SHOW_ALL_CATEGORIES}`;\n    }\n\n    /**\n     * Get the entries by date cache key.\n     *\n     * @param glossaryId Glossary Id.\n     * @param order The way to order the records.\n     * @returns Cache key.\n     */\n    getEntriesByDateCacheKey(glossaryId: number, order: string): string {\n        return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesByDate:${glossaryId}:${order}:DESC`;\n    }\n\n    /**\n     * Get entries by date.\n     *\n     * @param glossaryId Glossary Id.\n     * @param order The way to order the records.\n     * @param options Other options.\n     * @returns Resolved with the entries.\n     */\n    async getEntriesByDate(\n        glossaryId: number,\n        order: string,\n        options: AddonModGlossaryGetEntriesOptions = {},\n    ): Promise<AddonModGlossaryGetEntriesWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModGlossaryGetEntriesByDateWSParams = {\n            id: glossaryId,\n            order: order,\n            sort: 'DESC',\n            from: options.from || 0,\n            limit: options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEntriesByDateCacheKey(glossaryId, order),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModGlossaryProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_glossary_get_entries_by_date', params, preSets);\n    }\n\n    /**\n     * Invalidate cache of entries by date.\n     *\n     * @param glossaryId Glossary Id.\n     * @param order The way to order the records.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateEntriesByDate(glossaryId: number, order: string, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const key = this.getEntriesByDateCacheKey(glossaryId, order);\n\n        await site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Get the entries by letter cache key.\n     *\n     * @param glossaryId Glossary Id.\n     * @returns Cache key.\n     */\n    protected getEntriesByLetterCacheKey(glossaryId: number): string {\n        return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesByLetter:${glossaryId}:ALL`;\n    }\n\n    /**\n     * Get entries by letter.\n     *\n     * @param glossaryId Glossary Id.\n     * @param options Other options.\n     * @returns Resolved with the entries.\n     */\n    async getEntriesByLetter(\n        glossaryId: number,\n        options: AddonModGlossaryGetEntriesOptions = {},\n    ): Promise<AddonModGlossaryGetEntriesWSResponse> {\n        const from = options.from || 0;\n        const limit = options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES;\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModGlossaryGetEntriesByLetterWSParams = {\n            id: glossaryId,\n            letter: 'ALL',\n            from,\n            limit,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEntriesByLetterCacheKey(glossaryId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModGlossaryProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const result = await site.read<AddonModGlossaryGetEntriesWSResponse>(\n            'mod_glossary_get_entries_by_letter',\n            params,\n            preSets,\n        );\n\n        if (limit === AddonModGlossaryProvider.LIMIT_ENTRIES) {\n            // Store entries in background, don't block the user for this.\n            CoreUtils.ignoreErrors(this.storeEntries(glossaryId, result.entries, from, site.getId()));\n        }\n\n        return result;\n    }\n\n    /**\n     * Invalidate cache of entries by letter.\n     *\n     * @param glossaryId Glossary Id.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateEntriesByLetter(glossaryId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const key = this.getEntriesByLetterCacheKey(glossaryId);\n\n        await site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Get the entries by search cache key.\n     *\n     * @param glossaryId Glossary Id.\n     * @param query The search query.\n     * @param fullSearch Whether or not full search is required.\n     * @returns Cache key.\n     */\n    protected getEntriesBySearchCacheKey(glossaryId: number, query: string, fullSearch: boolean): string {\n        return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}entriesBySearch:${glossaryId}:${fullSearch}:CONCEPT:ASC:${query}`;\n    }\n\n    /**\n     * Get entries by search.\n     *\n     * @param glossaryId Glossary Id.\n     * @param query The search query.\n     * @param fullSearch Whether or not full search is required.\n     * @param options Get entries options.\n     * @returns Resolved with the entries.\n     */\n    async getEntriesBySearch(\n        glossaryId: number,\n        query: string,\n        fullSearch: boolean,\n        options: AddonModGlossaryGetEntriesOptions = {},\n    ): Promise<AddonModGlossaryGetEntriesWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModGlossaryGetEntriesBySearchWSParams = {\n            id: glossaryId,\n            query: query,\n            fullsearch: fullSearch,\n            order: 'CONCEPT',\n            sort: 'ASC',\n            from: options.from || 0,\n            limit: options.limit || AddonModGlossaryProvider.LIMIT_ENTRIES,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getEntriesBySearchCacheKey(glossaryId, query, fullSearch),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModGlossaryProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_glossary_get_entries_by_search', params, preSets);\n    }\n\n    /**\n     * Invalidate cache of entries by search.\n     *\n     * @param glossaryId Glossary Id.\n     * @param query The search query.\n     * @param fullSearch Whether or not full search is required.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateEntriesBySearch(\n        glossaryId: number,\n        query: string,\n        fullSearch: boolean,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const key = this.getEntriesBySearchCacheKey(glossaryId, query, fullSearch);\n\n        await site.invalidateWsCacheForKey(key);\n    }\n\n    /**\n     * Get the glossary categories cache key.\n     *\n     * @param glossaryId Glossary Id.\n     * @returns The cache key.\n     */\n    protected getCategoriesCacheKey(glossaryId: number): string {\n        return AddonModGlossaryProvider.ROOT_CACHE_KEY + 'categories:' + glossaryId;\n    }\n\n    /**\n     * Get all the categories related to the glossary.\n     *\n     * @param glossaryId Glossary Id.\n     * @param options Other options.\n     * @returns Promise resolved with the categories if supported or empty array if not.\n     */\n    async getAllCategories(glossaryId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModGlossaryCategory[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        return this.getCategories(glossaryId, [], site, options);\n    }\n\n    /**\n     * Get the categories related to the glossary by sections. It's a recursive function see initial call values.\n     *\n     * @param glossaryId Glossary Id.\n     * @param categories Already fetched categories where to append the fetch.\n     * @param site Site object.\n     * @param options Other options.\n     * @returns Promise resolved with the categories.\n     */\n    protected async getCategories(\n        glossaryId: number,\n        categories: AddonModGlossaryCategory[],\n        site: CoreSite,\n        options: AddonModGlossaryGetCategoriesOptions = {},\n    ): Promise<AddonModGlossaryCategory[]> {\n        const from = options.from || 0;\n        const limit = options.limit || AddonModGlossaryProvider.LIMIT_CATEGORIES;\n\n        const params: AddonModGlossaryGetCategoriesWSParams = {\n            id: glossaryId,\n            from,\n            limit,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getCategoriesCacheKey(glossaryId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModGlossaryProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModGlossaryGetCategoriesWSResponse>('mod_glossary_get_categories', params, preSets);\n\n        categories = categories.concat(response.categories);\n        const canLoadMore = (from + limit) < response.count;\n        if (canLoadMore) {\n            return this.getCategories(glossaryId, categories, site, {\n                ...options,\n                from: from + limit,\n            });\n        }\n\n        return categories;\n    }\n\n    /**\n     * Invalidate cache of categories by glossary id.\n     *\n     * @param glossaryId Glossary Id.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateCategories(glossaryId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCategoriesCacheKey(glossaryId));\n    }\n\n    /**\n     * Get an entry by ID cache key.\n     *\n     * @param entryId Entry Id.\n     * @returns Cache key.\n     */\n    protected getEntryCacheKey(entryId: number): string {\n        return `${AddonModGlossaryProvider.ROOT_CACHE_KEY}getEntry:${entryId}`;\n    }\n\n    /**\n     * Get one entry by ID.\n     *\n     * @param entryId Entry ID.\n     * @param options Other options.\n     * @returns Promise resolved with the entry.\n     */\n    async getEntry(entryId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModGlossaryGetEntryByIdResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModGlossaryGetEntryByIdWSParams = {\n            id: entryId,\n        };\n        const preSets = {\n            cacheKey: this.getEntryCacheKey(entryId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModGlossaryProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        try {\n            return await site.read<AddonModGlossaryGetEntryByIdWSResponse>('mod_glossary_get_entry_by_id', params, preSets);\n        } catch (error) {\n            // Entry not found. Search it in the list of entries.\n            try {\n                const data = await this.getStoredDataForEntry(entryId, site.getId());\n\n                if (data.from !== undefined) {\n                    const response = await CoreUtils.ignoreErrors(\n                        this.getEntryFromList(data.glossaryId, entryId, data.from, false, options),\n                    );\n\n                    if (response) {\n                        return response;\n                    }\n                }\n\n                // Page not specified or entry not found in the page, search all pages.\n                return await this.getEntryFromList(data.glossaryId, entryId, 0, true, options);\n            } catch {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Get a glossary ID and the \"from\" of a given entry.\n     *\n     * @param entryId Entry ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the glossary ID and the \"from\".\n     */\n    async getStoredDataForEntry(entryId: number, siteId?: string): Promise<{glossaryId: number; from: number}> {\n        const site = await CoreSites.getSite(siteId);\n\n        const conditions: Partial<AddonModGlossaryEntryDBRecord> = {\n            entryid: entryId,\n        };\n\n        const record = await site.getDb().getRecord<AddonModGlossaryEntryDBRecord>(ENTRIES_TABLE_NAME, conditions);\n\n        return {\n            glossaryId: record.glossaryid,\n            from: record.pagefrom,\n        };\n    }\n\n    /**\n     * Get an entry from the list of entries.\n     *\n     * @param glossaryId Glossary ID.\n     * @param entryId Entry ID.\n     * @param from Page to get.\n     * @param loadNext Whether to load next pages if not found.\n     * @param options Options.\n     * @returns Promise resolved with the entry data.\n     */\n    protected async getEntryFromList(\n        glossaryId: number,\n        entryId: number,\n        from: number,\n        loadNext: boolean,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModGlossaryGetEntryByIdResponse> {\n        // Get the entries from this \"page\" and check if the entry we're looking for is in it.\n        const result = await this.getEntriesByLetter(glossaryId, {\n            from: from,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_CACHE,\n            cmId: options.cmId,\n            siteId: options.siteId,\n        });\n\n        const entry = result.entries.find(entry => entry.id == entryId);\n\n        if (entry) {\n            // Entry found, return it.\n            return { entry, from };\n        }\n\n        const nextFrom = from + result.entries.length;\n        if (nextFrom < result.count && loadNext) {\n            // Get the next \"page\".\n            return this.getEntryFromList(glossaryId, entryId, nextFrom, true, options);\n        }\n\n        // No more pages and the entry wasn't found. Reject.\n        throw new CoreError('Entry not found.');\n    }\n\n    /**\n     * Check whether the site can delete glossary entries.\n     *\n     * @param siteId Site id.\n     * @returns Whether the site can delete entries.\n     */\n    async canDeleteEntries(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.wsAvailable('mod_glossary_delete_entry');\n    }\n\n    /**\n     * Check whether the site can update glossary entries.\n     *\n     * @param siteId Site id.\n     * @returns Whether the site can update entries.\n     */\n    async canUpdateEntries(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.wsAvailable('mod_glossary_update_entry');\n    }\n\n    /**\n     * Performs the whole fetch of the entries using the proper function and arguments.\n     *\n     * @param fetchFunction Function to fetch.\n     * @param options Other options.\n     * @returns Promise resolved with all entrries.\n     */\n    fetchAllEntries(\n        fetchFunction: (options?: AddonModGlossaryGetEntriesOptions) => Promise<AddonModGlossaryGetEntriesWSResponse>,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModGlossaryEntry[]> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        const entries: AddonModGlossaryEntry[] = [];\n\n        const fetchMoreEntries = async (): Promise<AddonModGlossaryEntry[]> => {\n            const result = await fetchFunction({\n                from: entries.length,\n                ...options, // Include all options.\n            });\n\n            Array.prototype.push.apply(entries, result.entries);\n\n            return entries.length < result.count ? fetchMoreEntries() : entries;\n        };\n\n        return fetchMoreEntries();\n    }\n\n    /**\n     * Invalidate cache of entry by ID.\n     *\n     * @param entryId Entry Id.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateEntry(entryId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getEntryCacheKey(entryId));\n    }\n\n    /**\n     * Invalidate cache of all entries in the array.\n     *\n     * @param entries Entry objects to invalidate.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    protected async invalidateEntries(entries: AddonModGlossaryEntry[], siteId?: string): Promise<void> {\n        const keys: string[] = [];\n        entries.forEach((entry) => {\n            keys.push(this.getEntryCacheKey(entry.id));\n        });\n\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateMultipleWsCacheForKey(keys);\n    }\n\n    /**\n     * Invalidate the prefetched content except files.\n     * To invalidate files, use AddonModGlossary#invalidateFiles.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID.\n     */\n    async invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        const glossary = await this.getGlossary(courseId, moduleId);\n\n        await CoreUtils.ignoreErrors(this.invalidateGlossaryEntries(glossary));\n\n        await CoreUtils.allPromises([\n            this.invalidateCourseGlossaries(courseId),\n            this.invalidateCategories(glossary.id),\n        ]);\n    }\n\n    /**\n     * Invalidate the prefetched content for a given glossary, except files.\n     * To invalidate files, use AddonModGlossaryProvider#invalidateFiles.\n     *\n     * @param glossary The glossary object.\n     * @param onlyEntriesList If true, entries won't be invalidated.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async invalidateGlossaryEntries(glossary: AddonModGlossaryGlossary, onlyEntriesList?: boolean, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const promises: Promise<void>[] = [];\n\n        if (!onlyEntriesList) {\n            promises.push(this.fetchAllEntries((options) => this.getEntriesByLetter(glossary.id, options), {\n                cmId: glossary.coursemodule,\n                readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n                siteId,\n            }).then((entries) => this.invalidateEntries(entries, siteId)));\n        }\n\n        glossary.browsemodes.forEach((mode) => {\n            switch (mode) {\n                case 'letter':\n                    promises.push(this.invalidateEntriesByLetter(glossary.id, siteId));\n                    break;\n                case 'cat':\n                    promises.push(this.invalidateEntriesByCategory(glossary.id, siteId));\n                    break;\n                case 'date':\n                    promises.push(this.invalidateEntriesByDate(glossary.id, 'CREATION', siteId));\n                    promises.push(this.invalidateEntriesByDate(glossary.id, 'UPDATE', siteId));\n                    break;\n                case 'author':\n                    promises.push(this.invalidateEntriesByAuthor(glossary.id, siteId));\n                    break;\n                default:\n            }\n        });\n\n        await CoreUtils.allPromises(promises);\n    }\n\n    /**\n     * Get one glossary by cmid.\n     *\n     * @param courseId Course Id.\n     * @param cmId Course Module Id.\n     * @param options Other options.\n     * @returns Promise resolved with the glossary.\n     */\n    async getGlossary(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModGlossaryGlossary> {\n        const glossaries = await this.getCourseGlossaries(courseId, options);\n\n        const glossary = glossaries.find((glossary) => glossary.coursemodule == cmId);\n\n        if (glossary) {\n            return glossary;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get one glossary by glossary ID.\n     *\n     * @param courseId Course Id.\n     * @param glossaryId Glossary Id.\n     * @param options Other options.\n     * @returns Promise resolved with the glossary.\n     */\n    async getGlossaryById(\n        courseId: number,\n        glossaryId: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModGlossaryGlossary> {\n        const glossaries = await this.getCourseGlossaries(courseId, options);\n\n        const glossary = glossaries.find((glossary) => glossary.id == glossaryId);\n\n        if (glossary) {\n            return glossary;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Create a new entry on a glossary\n     *\n     * @param glossaryId Glossary ID.\n     * @param concept Glossary entry concept.\n     * @param definition Glossary entry concept definition.\n     * @param courseId Course ID of the glossary.\n     * @param entryOptions Options for the entry.\n     * @param attachments Attachments ID if sending online, result of CoreFileUploaderProvider#storeFilesToUpload otherwise.\n     * @param otherOptions Other options.\n     * @returns Promise resolved with entry ID if entry was created in server, false if stored in device.\n     */\n    async addEntry(\n        glossaryId: number,\n        concept: string,\n        definition: string,\n        courseId: number,\n        entryOptions: Record<string, AddonModGlossaryEntryOption>,\n        attachments?: number | CoreFileUploaderStoreFilesResult,\n        otherOptions: AddonModGlossaryAddEntryOptions = {},\n    ): Promise<number | false> {\n        otherOptions.siteId = otherOptions.siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a new entry to be synchronized later.\n        const storeOffline = async (): Promise<false> => {\n            if (otherOptions.checkDuplicates) {\n                // Check if the entry is duplicated in online or offline mode.\n                const conceptUsed = await this.isConceptUsed(glossaryId, concept, {\n                    cmId: otherOptions.cmId,\n                    siteId: otherOptions.siteId,\n                });\n\n                if (conceptUsed) {\n                    throw new CoreError(Translate.instant('addon.mod_glossary.errconceptalreadyexists'));\n                }\n            }\n\n            if (typeof attachments == 'number') {\n                // When storing in offline the attachments can't be a draft ID.\n                throw new CoreError('Error adding entry.');\n            }\n\n            await AddonModGlossaryOffline.addOfflineEntry(\n                glossaryId,\n                concept,\n                definition,\n                courseId,\n                otherOptions.timeCreated ?? Date.now(),\n                entryOptions,\n                attachments,\n                otherOptions.siteId,\n                undefined,\n            );\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline() && otherOptions.allowOffline) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            // Try to add it in online.\n            const entryId = await this.addEntryOnline(\n                glossaryId,\n                concept,\n                definition,\n                entryOptions,\n                <number> attachments,\n                otherOptions.siteId,\n            );\n\n            return entryId;\n        } catch (error) {\n            if (otherOptions.allowOffline && !CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server, store in offline.\n                return storeOffline();\n            }\n\n            // The WebService has thrown an error or offline not supported, reject.\n            throw error;\n        }\n    }\n\n    /**\n     * Create a new entry on a glossary. It does not cache calls. It will fail if offline or cannot connect.\n     *\n     * @param glossaryId Glossary ID.\n     * @param concept Glossary entry concept.\n     * @param definition Glossary entry concept definition.\n     * @param options Options for the entry.\n     * @param attachId Attachments ID (if any attachment).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the entry ID if created, rejected otherwise.\n     */\n    async addEntryOnline(\n        glossaryId: number,\n        concept: string,\n        definition: string,\n        options?: Record<string, AddonModGlossaryEntryOption>,\n        attachId?: number,\n        siteId?: string,\n    ): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModGlossaryAddEntryWSParams = {\n            glossaryid: glossaryId,\n            concept: concept,\n            definition: definition,\n            definitionformat: 1,\n            options: CoreUtils.objectToArrayOfObjects(options || {}, 'name', 'value'),\n        };\n\n        if (attachId) {\n            params.options?.push({\n                name: 'attachmentsid',\n                value: String(attachId),\n            });\n        }\n\n        const response = await site.write<AddonModGlossaryAddEntryWSResponse>('mod_glossary_add_entry', params);\n\n        CoreEvents.trigger(GLOSSARY_ENTRY_ADDED, { glossaryId, entryId: response.entryid }, siteId);\n\n        return response.entryid;\n    }\n\n    /**\n     * Update an existing entry on a glossary.\n     *\n     * @param glossaryId Glossary ID.\n     * @param entryId Entry ID.\n     * @param concept Glossary entry concept.\n     * @param definition Glossary entry concept definition.\n     * @param options Options for the entry.\n     * @param attachId Attachments ID (if any attachment).\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async updateEntry(\n        glossaryId: number,\n        entryId: number,\n        concept: string,\n        definition: string,\n        options?: Record<string, AddonModGlossaryEntryOption>,\n        attachId?: number,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModGlossaryUpdateEntryWSParams = {\n            entryid: entryId,\n            concept: concept,\n            definition: definition,\n            definitionformat: 1,\n            options: CoreUtils.objectToArrayOfObjects(options || {}, 'name', 'value'),\n        };\n\n        if (attachId) {\n            params.options?.push({\n                name: 'attachmentsid',\n                value: String(attachId),\n            });\n        }\n\n        const response = await site.write<AddonModGlossaryUpdateEntryWSResponse>('mod_glossary_update_entry', params);\n\n        if (!response.result) {\n            throw new CoreError(response.warnings?.[0].message ?? 'Error updating entry');\n        }\n\n        CoreEvents.trigger(GLOSSARY_ENTRY_UPDATED, { glossaryId, entryId }, siteId);\n    }\n\n    /**\n     * Delete entry.\n     *\n     * @param glossaryId Glossary id.\n     * @param entryId Entry id.\n     */\n    async deleteEntry(glossaryId: number, entryId: number): Promise<void> {\n        const site = CoreSites.getRequiredCurrentSite();\n\n        await site.write('mod_glossary_delete_entry', { entryid: entryId });\n\n        CoreEvents.trigger(GLOSSARY_ENTRY_DELETED, { glossaryId, entryId });\n    }\n\n    /**\n     * Check if a entry concept is already used.\n     *\n     * @param glossaryId Glossary ID.\n     * @param concept Concept to check.\n     * @param options Other options.\n     * @returns Promise resolved with true if used, resolved with false if not used or error.\n     */\n    async isConceptUsed(glossaryId: number, concept: string, options: AddonModGlossaryIsConceptUsedOptions = {}): Promise<boolean> {\n        try {\n            // Check offline first.\n            const exists = await AddonModGlossaryOffline.isConceptUsed(glossaryId, concept, options.timeCreated, options.siteId);\n\n            if (exists) {\n                return true;\n            }\n\n            // If we get here, there's no offline entry with this name, check online.\n            // Get entries from the cache.\n            const entries = await this.fetchAllEntries((options) => this.getEntriesByLetter(glossaryId, options), {\n                cmId: options.cmId,\n                readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n                siteId: options.siteId,\n            });\n\n            // Check if there's any entry with the same concept.\n            return entries.some((entry) => entry.concept == concept);\n        } catch {\n            // Error, assume not used.\n            return false;\n        }\n    }\n\n    /**\n     * Report a glossary as being viewed.\n     *\n     * @param glossaryId Glossary ID.\n     * @param mode The mode in which the glossary was viewed.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async logView(glossaryId: number, mode: string, siteId?: string): Promise<void> {\n        const params: AddonModGlossaryViewGlossaryWSParams = {\n            id: glossaryId,\n            mode: mode,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_glossary_view_glossary',\n            params,\n            AddonModGlossaryProvider.COMPONENT,\n            glossaryId,\n            siteId,\n        );\n    }\n\n    /**\n     * Report a glossary entry as being viewed.\n     *\n     * @param entryId Entry ID.\n     * @param glossaryId Glossary ID.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    async logEntryView(entryId: number, glossaryId: number, siteId?: string): Promise<void> {\n        const params: AddonModGlossaryViewEntryWSParams = {\n            id: entryId,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_glossary_view_entry',\n            params,\n            AddonModGlossaryProvider.COMPONENT,\n            glossaryId,\n            siteId,\n        );\n    }\n\n    /**\n     * Store several entries so we can determine their glossaryId in offline.\n     *\n     * @param glossaryId Glossary ID the entries belongs to.\n     * @param entries Entries.\n     * @param from The \"page\" the entries belong to.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    protected async storeEntries(\n        glossaryId: number,\n        entries: AddonModGlossaryEntry[],\n        from: number,\n        siteId?: string,\n    ): Promise<void> {\n        await Promise.all(entries.map((entry) => this.storeEntryId(glossaryId, entry.id, from, siteId)));\n    }\n\n    /**\n     * Store an entry so we can determine its glossaryId in offline.\n     *\n     * @param glossaryId Glossary ID the entry belongs to.\n     * @param entryId Entry ID.\n     * @param from The \"page\" the entry belongs to.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    protected async storeEntryId(glossaryId: number, entryId: number, from: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entry: AddonModGlossaryEntryDBRecord = {\n            entryid: entryId,\n            glossaryid: glossaryId,\n            pagefrom: from,\n        };\n\n        await site.getDb().insertRecord(ENTRIES_TABLE_NAME, entry);\n    }\n\n}\n\nexport const AddonModGlossary = makeSingleton(AddonModGlossaryProvider);\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [GLOSSARY_ENTRY_ADDED]: AddonModGlossaryEntryAddedEventData;\n        [GLOSSARY_ENTRY_UPDATED]: AddonModGlossaryEntryUpdatedEventData;\n        [GLOSSARY_ENTRY_DELETED]: AddonModGlossaryEntryDeletedEventData;\n    }\n\n}\n\n/**\n * GLOSSARY_ENTRY_ADDED event payload.\n */\nexport type AddonModGlossaryEntryAddedEventData = {\n    glossaryId: number;\n    entryId?: number;\n    timecreated?: number;\n};\n\n/**\n * GLOSSARY_ENTRY_UPDATED event payload.\n */\nexport type AddonModGlossaryEntryUpdatedEventData = {\n    glossaryId: number;\n    entryId?: number;\n    timecreated?: number;\n};\n\n/**\n * GLOSSARY_ENTRY_DELETED event payload.\n */\nexport type AddonModGlossaryEntryDeletedEventData = {\n    glossaryId: number;\n    entryId?: number;\n    timecreated?: number;\n};\n\n/**\n * Params of mod_glossary_get_glossaries_by_courses WS.\n */\nexport type AddonModGlossaryGetGlossariesByCoursesWSParams = {\n    courseids?: number[]; // Array of course IDs.\n};\n\n/**\n * Data returned by mod_glossary_get_glossaries_by_courses WS.\n */\nexport type AddonModGlossaryGetGlossariesByCoursesWSResponse = {\n    glossaries: AddonModGlossaryGlossary[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data returned by mod_glossary_get_glossaries_by_courses WS.\n */\nexport type AddonModGlossaryGlossary = {\n    id: number; // Glossary id.\n    coursemodule: number; // Course module id.\n    course: number; // Course id.\n    name: string; // Glossary name.\n    intro: string; // The Glossary intro.\n    introformat: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    allowduplicatedentries: number; // If enabled, multiple entries can have the same concept name.\n    displayformat: string; // Display format type.\n    mainglossary: number; // If enabled this glossary is a main glossary.\n    showspecial: number; // If enabled, participants can browse the glossary by special characters, such as @ and #.\n    showalphabet: number; // If enabled, participants can browse the glossary by letters of the alphabet.\n    showall: number; // If enabled, participants can browse all entries at once.\n    allowcomments: number; // If enabled, all participants with permission will be able to add comments to glossary entries.\n    allowprintview: number; // If enabled, students are provided with a link to a printer-friendly version of the glossary.\n    usedynalink: number; // If enabled, the entry will be automatically linked.\n    defaultapproval: number; // If set to no, entries require approving by a teacher before they are viewable by everyone.\n    approvaldisplayformat: string; // When approving glossary items you may wish to use a different display format.\n    globalglossary: number;\n    entbypage: number; // Entries shown per page.\n    editalways: number; // Always allow editing.\n    rsstype: number; // RSS type.\n    rssarticles: number; // This setting specifies the number of glossary entry concepts to include in the RSS feed.\n    assessed: number; // Aggregate type.\n    assesstimestart: number; // Restrict rating to items created after this.\n    assesstimefinish: number; // Restrict rating to items created before this.\n    scale: number; // Scale ID.\n    timecreated: number; // Time created.\n    timemodified: number; // Time modified.\n    completionentries: number; // Number of entries to complete.\n    section: number; // Section.\n    visible: number; // Visible.\n    groupmode: number; // Group mode.\n    groupingid: number; // Grouping ID.\n    browsemodes: string[];\n    canaddentry?: number; // Whether the user can add a new entry.\n};\n\n/**\n * Common data passed to the get entries WebServices.\n */\nexport type AddonModGlossaryCommonGetEntriesWSParams = {\n    id: number; // Glossary entry ID.\n    from?: number; // Start returning records from here.\n    limit?: number; // Number of records to return.\n    options?: {\n        // When false, includes the non-approved entries created by the user.\n        // When true, also includes the ones that the user has the permission to approve.\n        includenotapproved?: boolean;\n    }; // An array of options.\n};\n\n/**\n * Data returned by the different get entries WebServices.\n */\nexport type AddonModGlossaryGetEntriesWSResponse = {\n    count: number; // The total number of records matching the request.\n    entries: AddonModGlossaryEntry[];\n    ratinginfo?: CoreRatingInfo; // Rating information.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_glossary_get_entries_by_author WS.\n */\nexport type AddonModGlossaryGetEntriesByAuthorWSParams = AddonModGlossaryCommonGetEntriesWSParams & {\n    letter: string; // First letter of firstname or lastname, or either keywords: 'ALL' or 'SPECIAL'.\n    field?: string; // Search and order using: 'FIRSTNAME' or 'LASTNAME'.\n    sort?: string; // The direction of the order: 'ASC' or 'DESC'.\n};\n\n/**\n * Params of mod_glossary_get_entries_by_category WS.\n */\nexport type AddonModGlossaryGetEntriesByCategoryWSParams = AddonModGlossaryCommonGetEntriesWSParams & {\n    categoryid: number; // The category ID. Use '0' for all categories, or '-1' for uncategorised entries.\n};\n\n/**\n * Data returned by mod_glossary_get_entries_by_category WS.\n */\nexport type AddonModGlossaryGetEntriesByCategoryWSResponse = Omit<AddonModGlossaryGetEntriesWSResponse, 'entries'> & {\n    entries: AddonModGlossaryEntryWithCategory[];\n};\n\n/**\n * Params of mod_glossary_get_entries_by_date WS.\n */\nexport type AddonModGlossaryGetEntriesByDateWSParams = AddonModGlossaryCommonGetEntriesWSParams & {\n    order?: string; // Order the records by: 'CREATION' or 'UPDATE'.\n    sort?: string; // The direction of the order: 'ASC' or 'DESC'.\n};\n\n/**\n * Params of mod_glossary_get_entries_by_letter WS.\n */\nexport type AddonModGlossaryGetEntriesByLetterWSParams = AddonModGlossaryCommonGetEntriesWSParams & {\n    letter: string; // A letter, or either keywords: 'ALL' or 'SPECIAL'.\n};\n\n/**\n * Params of mod_glossary_get_entries_by_search WS.\n */\nexport type AddonModGlossaryGetEntriesBySearchWSParams = AddonModGlossaryCommonGetEntriesWSParams & {\n    query: string; // The query string.\n    fullsearch?: boolean; // The query.\n    order?: string; // Order by: 'CONCEPT', 'CREATION' or 'UPDATE'.\n    sort?: string; // The direction of the order: 'ASC' or 'DESC'.\n};\n\n/**\n * Entry data returned by several WS.\n */\nexport type AddonModGlossaryEntry = {\n    id: number; // The entry ID.\n    glossaryid: number; // The glossary ID.\n    userid: number; // Author ID.\n    userfullname: string; // Author full name.\n    userpictureurl: string; // Author picture.\n    concept: string; // The concept.\n    definition: string; // The definition.\n    definitionformat: number; // Definition format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    definitiontrust: boolean; // The definition trust flag.\n    definitioninlinefiles?: CoreWSExternalFile[];\n    attachment: boolean; // Whether or not the entry has attachments.\n    attachments?: CoreWSExternalFile[];\n    timecreated: number; // Time created.\n    timemodified: number; // Time modified.\n    teacherentry: boolean; // The entry was created by a teacher, or equivalent.\n    sourceglossaryid: number; // The source glossary ID.\n    usedynalink: boolean; // Whether the concept should be automatically linked.\n    casesensitive: boolean; // When true, the matching is case sensitive.\n    fullmatch: boolean; // When true, the matching is done on full words only.\n    approved: boolean; // Whether the entry was approved.\n    tags?: CoreTagItem[];\n};\n\n/**\n * Entry data returned by several WS.\n */\nexport type AddonModGlossaryEntryWithCategory = AddonModGlossaryEntry & {\n    categoryid?: number; // The category ID. This may be '-1' when the entry is not categorised.\n    categoryname?: string; // The category name. May be empty when the entry is not categorised.\n};\n\n/**\n * Params of mod_glossary_get_categories WS.\n */\nexport type AddonModGlossaryGetCategoriesWSParams = {\n    id: number; // The glossary ID.\n    from?: number; // Start returning records from here.\n    limit?: number; // Number of records to return.\n};\n\n/**\n * Data returned by mod_glossary_get_categories WS.\n */\nexport type AddonModGlossaryGetCategoriesWSResponse = {\n    count: number; // The total number of records.\n    categories: AddonModGlossaryCategory[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data returned by mod_glossary_get_categories WS.\n */\nexport type AddonModGlossaryCategory = {\n    id: number; // The category ID.\n    glossaryid: number; // The glossary ID.\n    name: string; // The name of the category.\n    usedynalink: boolean; // Whether the category is automatically linked.\n};\n\n/**\n * Params of mod_glossary_get_entry_by_id WS.\n */\nexport type AddonModGlossaryGetEntryByIdWSParams = {\n    id: number; // Glossary entry ID.\n};\n\n/**\n * Data returned by mod_glossary_get_entry_by_id WS.\n */\nexport type AddonModGlossaryGetEntryByIdWSResponse = {\n    entry: AddonModGlossaryEntry;\n    ratinginfo?: CoreRatingInfo; // Rating information.\n    permissions?: {\n        candelete: boolean; // Whether the user can delete the entry.\n        canupdate: boolean; // Whether the user can update the entry.\n    }; // User permissions for the managing the entry.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Data returned by mod_glossary_get_entry_by_id WS, with some calculated data if needed.\n */\nexport type AddonModGlossaryGetEntryByIdResponse = AddonModGlossaryGetEntryByIdWSResponse & {\n    from?: number;\n};\n\n/**\n * Params of mod_glossary_add_entry WS.\n */\nexport type AddonModGlossaryAddEntryWSParams = {\n    glossaryid: number; // Glossary id.\n    concept: string; // Glossary concept.\n    definition: string; // Glossary concept definition.\n    definitionformat: number; // Definition format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    options?: { // Optional settings.\n        name: string; // The allowed keys (value format) are:\n        // inlineattachmentsid (int); the draft file area id for inline attachments\n        // attachmentsid (int); the draft file area id for attachments\n        // categories (comma separated int); comma separated category ids\n        // aliases (comma separated str); comma separated aliases\n        // usedynalink (bool); whether the entry should be automatically linked.\n        // casesensitive (bool); whether the entry is case sensitive.\n        // fullmatch (bool); whether to match whole words only.\n        value: string | number; // The value of the option (validated inside the function).\n    }[];\n};\n\n/**\n * Data returned by mod_glossary_add_entry WS.\n */\nexport type AddonModGlossaryAddEntryWSResponse = {\n    entryid: number; // New glossary entry ID.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_glossary_update_entry WS.\n */\nexport type AddonModGlossaryUpdateEntryWSParams = {\n    entryid: number; // Glossary entry id to update.\n    concept: string; // Glossary concept.\n    definition: string; // Glossary concept definition.\n    definitionformat: number; // Definition format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    options?: { // Optional settings.\n        name: string; // The allowed keys (value format) are:\n        // inlineattachmentsid (int); the draft file area id for inline attachments\n        // attachmentsid (int); the draft file area id for attachments\n        // categories (comma separated int); comma separated category ids\n        // aliases (comma separated str); comma separated aliases\n        // usedynalink (bool); whether the entry should be automatically linked.\n        // casesensitive (bool); whether the entry is case sensitive.\n        // fullmatch (bool); whether to match whole words only.\n        value: string | number; // The value of the option (validated inside the function).\n    }[];\n};\n\n/**\n * Data returned by mod_glossary_update_entry WS.\n */\nexport type AddonModGlossaryUpdateEntryWSResponse = {\n    result: boolean; // The update result.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_glossary_view_glossary WS.\n */\nexport type AddonModGlossaryViewGlossaryWSParams = {\n    id: number; // Glossary instance ID.\n    mode: string; // The mode in which the glossary is viewed.\n};\n\n/**\n * Params of mod_glossary_view_entry WS.\n */\nexport type AddonModGlossaryViewEntryWSParams = {\n    id: number; // Glossary entry ID.\n};\n\n/**\n * Options to pass to add entry.\n */\nexport type AddonModGlossaryAddEntryOptions = {\n    timeCreated?: number; // The time the entry was created. If not defined, current time.\n    allowOffline?: boolean; // True if it can be stored in offline, false otherwise.\n    checkDuplicates?: boolean; // Check for duplicates before storing offline. Only used if allowOffline is true.\n    cmId?: number; // Module ID.\n    siteId?: string; // Site ID. If not defined, current site.\n};\n\n/**\n * Options to pass to the different get entries functions.\n */\nexport type AddonModGlossaryGetEntriesOptions = CoreCourseCommonModWSOptions & {\n    from?: number; // Start returning records from here. Defaults to 0.\n    limit?: number; // Number of records to return. Defaults to AddonModGlossaryProvider.LIMIT_ENTRIES.\n};\n\n/**\n * Options to pass to get categories.\n */\nexport type AddonModGlossaryGetCategoriesOptions = CoreCourseCommonModWSOptions & {\n    from?: number; // Start returning records from here. Defaults to 0.\n    limit?: number; // Number of records to return. Defaults to AddonModGlossaryProvider.LIMIT_CATEGORIES.\n};\n\n/**\n * Options to pass to is concept used.\n */\nexport type AddonModGlossaryIsConceptUsedOptions = {\n    cmId?: number; // Module ID.\n    timeCreated?: number; // Timecreated to check that is not the timecreated we are editing.\n    siteId?: string; // Site ID. If not defined, current site.\n};\n\n/**\n * Possible values for entry options.\n */\nexport type AddonModGlossaryEntryOption = string | number;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}