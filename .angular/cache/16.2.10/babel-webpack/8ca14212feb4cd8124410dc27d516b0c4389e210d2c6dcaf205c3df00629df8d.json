{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBaseProvider, CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModWorkshop, AddonModWorkshopAction, AddonModWorkshopSubmissionType } from './workshop';\nimport { AddonModWorkshopHelper } from './workshop-helper';\nimport { AddonModWorkshopOffline } from './workshop-offline';\nimport { ADDON_MOD_WORKSHOP_COMPONENT } from '@addons/mod/workshop/constants';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync workshops.\n */\nexport class AddonModWorkshopSyncProvider extends CoreSyncBaseProvider {\n  constructor() {\n    super('AddonModWorkshopSyncProvider');\n    this.componentTranslatableString = 'workshop';\n  }\n  /**\n   * Check if an workshop has data to synchronize.\n   *\n   * @param workshopId Workshop ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if has data to sync, false otherwise.\n   */\n  hasDataToSync(workshopId, siteId) {\n    return AddonModWorkshopOffline.hasWorkshopOfflineData(workshopId, siteId);\n  }\n  /**\n   * Try to synchronize all workshops that need it and haven't been synchronized in a while.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved when the sync is done.\n   */\n  syncAllWorkshops(siteId, force) {\n    return this.syncOnSites('all workshops', siteId => this.syncAllWorkshopsFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all workshops on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllWorkshopsFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const workshopIds = yield AddonModWorkshopOffline.getAllWorkshops(siteId);\n      // Sync all workshops that haven't been synced for a while.\n      const promises = workshopIds.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (workshopId) {\n          const data = force ? yield _this.syncWorkshop(workshopId, siteId) : yield _this.syncWorkshopIfNeeded(workshopId, siteId);\n          if (data && data.updated) {\n            // Sync done. Send event.\n            CoreEvents.trigger(AddonModWorkshopSyncProvider.AUTO_SYNCED, {\n              workshopId: workshopId,\n              warnings: data.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Sync a workshop only if a certain time has passed since the last time.\n   *\n   * @param workshopId Workshop ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the workshop is synced or if it doesn't need to be synced.\n   */\n  syncWorkshopIfNeeded(workshopId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const needed = yield _this2.isSyncNeeded(workshopId, siteId);\n      if (needed) {\n        return _this2.syncWorkshop(workshopId, siteId);\n      }\n    })();\n  }\n  /**\n   * Try to synchronize a workshop.\n   *\n   * @param workshopId Workshop ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncWorkshop(workshopId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const currentSyncPromise = this.getOngoingSync(workshopId, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for this discussion, return the promise.\n      return currentSyncPromise;\n    }\n    // Verify that workshop isn't blocked.\n    if (CoreSync.isBlocked(ADDON_MOD_WORKSHOP_COMPONENT, workshopId, siteId)) {\n      this.logger.debug(`Cannot sync workshop '${workshopId}' because it is blocked.`);\n      throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', {\n        $a: this.componentTranslate\n      }));\n    }\n    this.logger.debug(`Try to sync workshop '${workshopId}' in site ${siteId}'`);\n    const syncPromise = this.performSyncWorkshop(workshopId, siteId);\n    return this.addOngoingSync(workshopId, syncPromise, siteId);\n  }\n  /**\n   * Perform the workshop sync.\n   *\n   * @param workshopId Workshop ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  performSyncWorkshop(workshopId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(ADDON_MOD_WORKSHOP_COMPONENT, workshopId, siteId));\n      // Get offline submissions to be sent.\n      const syncs = yield Promise.all([\n      // Get offline submissions to be sent.\n      CoreUtils.ignoreErrors(AddonModWorkshopOffline.getSubmissions(workshopId, siteId), []),\n      // Get offline submission assessments to be sent.\n      CoreUtils.ignoreErrors(AddonModWorkshopOffline.getAssessments(workshopId, siteId), []),\n      // Get offline submission evaluations to be sent.\n      CoreUtils.ignoreErrors(AddonModWorkshopOffline.getEvaluateSubmissions(workshopId, siteId), []),\n      // Get offline assessment evaluations to be sent.\n      CoreUtils.ignoreErrors(AddonModWorkshopOffline.getEvaluateAssessments(workshopId, siteId), [])]);\n      let courseId;\n      // Get courseId from the first object\n      for (const x in syncs) {\n        if (syncs[x].length > 0 && syncs[x][0].courseid) {\n          courseId = syncs[x][0].courseid;\n          break;\n        }\n      }\n      if (!courseId) {\n        // Sync finished, set sync time.\n        yield CoreUtils.ignoreErrors(_this3.setSyncTime(workshopId, siteId));\n        // Nothing to sync.\n        return result;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      const workshop = yield AddonModWorkshop.getWorkshopById(courseId, workshopId, {\n        siteId\n      });\n      const submissionsActions = syncs[0];\n      const assessments = syncs[1];\n      const submissionEvaluations = syncs[2];\n      const assessmentEvaluations = syncs[3];\n      const offlineSubmissions = {};\n      const promises = [];\n      submissionsActions.forEach(action => {\n        offlineSubmissions[action.submissionid] = offlineSubmissions[action.submissionid] || [];\n        offlineSubmissions[action.submissionid].push(action);\n      });\n      Object.keys(offlineSubmissions).forEach(submissionId => {\n        const submissionActions = offlineSubmissions[submissionId];\n        promises.push(_this3.syncSubmission(workshop, submissionActions, result, siteId).then(() => {\n          result.updated = true;\n          return;\n        }));\n      });\n      assessments.forEach(assessment => {\n        promises.push(_this3.syncAssessment(workshop, assessment, result, siteId).then(() => {\n          result.updated = true;\n          return;\n        }));\n      });\n      submissionEvaluations.forEach(evaluation => {\n        promises.push(_this3.syncEvaluateSubmission(workshop, evaluation, result, siteId).then(() => {\n          result.updated = true;\n          return;\n        }));\n      });\n      assessmentEvaluations.forEach(evaluation => {\n        promises.push(_this3.syncEvaluateAssessment(workshop, evaluation, result, siteId).then(() => {\n          result.updated = true;\n          return;\n        }));\n      });\n      yield Promise.all(promises);\n      if (result.updated) {\n        // Data has been sent to server. Now invalidate the WS calls.\n        yield CoreUtils.ignoreErrors(AddonModWorkshop.invalidateContentById(workshopId, courseId, siteId));\n      }\n      // Sync finished, set sync time.\n      yield CoreUtils.ignoreErrors(_this3.setSyncTime(workshopId, siteId));\n      // All done, return the warnings.\n      return result;\n    })();\n  }\n  /**\n   * Synchronize a submission.\n   *\n   * @param workshop Workshop.\n   * @param submissionActions Submission actions offline data.\n   * @param result Object with the result of the sync.\n   * @param siteId Site ID.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  syncSubmission(workshop, submissionActions, result, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let discardError;\n      // Sort entries by timemodified.\n      submissionActions = submissionActions.sort((a, b) => a.timemodified - b.timemodified);\n      let timemodified = 0;\n      let submissionId = submissionActions[0].submissionid;\n      if (submissionId > 0) {\n        // Is editing.\n        try {\n          const submission = yield AddonModWorkshop.getSubmission(workshop.id, submissionId, {\n            cmId: workshop.coursemodule,\n            siteId\n          });\n          timemodified = submission.timemodified;\n        } catch (_unused) {\n          timemodified = -1;\n        }\n      }\n      if (timemodified < 0 || timemodified >= submissionActions[0].timemodified) {\n        // The entry was not found in Moodle or the entry has been modified, discard the action.\n        result.updated = true;\n        discardError = Translate.instant('addon.mod_workshop.warningsubmissionmodified');\n        yield AddonModWorkshopOffline.deleteAllSubmissionActions(workshop.id, siteId);\n        _this4.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n        return;\n      }\n      submissionActions.forEach( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (action) {\n          submissionId = action.submissionid > 0 ? action.submissionid : submissionId;\n          try {\n            let attachmentsId;\n            // Upload attachments first if any.\n            if (action.attachmentsid) {\n              const files = yield AddonModWorkshopHelper.getSubmissionFilesFromOfflineFilesObject(action.attachmentsid, workshop.id, siteId);\n              attachmentsId = yield AddonModWorkshopHelper.uploadOrStoreSubmissionFiles(workshop.id, files, false, siteId);\n            } else {\n              // Remove all files.\n              attachmentsId = yield AddonModWorkshopHelper.uploadOrStoreSubmissionFiles(workshop.id, [], false, siteId);\n            }\n            if (workshop.submissiontypefile == AddonModWorkshopSubmissionType.SUBMISSION_TYPE_DISABLED) {\n              attachmentsId = undefined;\n            }\n            // Perform the action.\n            switch (action.action) {\n              case AddonModWorkshopAction.ADD:\n                submissionId = yield AddonModWorkshop.addSubmissionOnline(workshop.id, action.title, action.content, attachmentsId, siteId);\n                break;\n              case AddonModWorkshopAction.UPDATE:\n                yield AddonModWorkshop.updateSubmissionOnline(submissionId, action.title, action.content, attachmentsId, siteId);\n                break;\n              case AddonModWorkshopAction.DELETE:\n                yield AddonModWorkshop.deleteSubmissionOnline(submissionId, siteId);\n            }\n          } catch (error) {\n            if (error && CoreUtils.isWebServiceError(error)) {\n              // The WebService has thrown an error, this means it cannot be performed. Discard.\n              discardError = CoreTextUtils.getErrorMessageFromError(error);\n            }\n            // Couldn't connect to server, reject.\n            throw error;\n          }\n          // Delete the offline data.\n          result.updated = true;\n          yield AddonModWorkshopOffline.deleteSubmissionAction(action.workshopid, action.action, siteId);\n          // Delete stored files.\n          if (action.action == AddonModWorkshopAction.ADD || action.action == AddonModWorkshopAction.UPDATE) {\n            return AddonModWorkshopHelper.deleteSubmissionStoredFiles(action.workshopid, siteId);\n          }\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      if (discardError) {\n        // Submission was discarded, add a warning.\n        _this4.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n      }\n    })();\n  }\n  /**\n   * Synchronize an assessment.\n   *\n   * @param workshop Workshop.\n   * @param assessmentData Assessment offline data.\n   * @param result Object with the result of the sync.\n   * @param siteId Site ID.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  syncAssessment(workshop, assessmentData, result, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      let discardError;\n      const assessmentId = assessmentData.assessmentid;\n      let timemodified = 0;\n      try {\n        const assessment = yield AddonModWorkshop.getAssessment(workshop.id, assessmentId, {\n          cmId: workshop.coursemodule,\n          siteId\n        });\n        timemodified = assessment.timemodified;\n      } catch (_unused2) {\n        timemodified = -1;\n      }\n      if (timemodified < 0 || timemodified >= assessmentData.timemodified) {\n        // The entry was not found in Moodle or the entry has been modified, discard the action.\n        result.updated = true;\n        discardError = Translate.instant('addon.mod_workshop.warningassessmentmodified');\n        yield AddonModWorkshopOffline.deleteAssessment(workshop.id, assessmentId, siteId);\n        _this5.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n        return;\n      }\n      let attachmentsId = 0;\n      const inputData = assessmentData.inputdata;\n      try {\n        let files = [];\n        // Upload attachments first if any.\n        if (inputData.feedbackauthorattachmentsid && typeof inputData.feedbackauthorattachmentsid !== 'number') {\n          files = yield AddonModWorkshopHelper.getAssessmentFilesFromOfflineFilesObject(inputData.feedbackauthorattachmentsid, workshop.id, assessmentId, siteId);\n        }\n        attachmentsId = yield AddonModWorkshopHelper.uploadOrStoreAssessmentFiles(workshop.id, assessmentId, files, false, siteId);\n        inputData.feedbackauthorattachmentsid = attachmentsId || 0;\n        yield AddonModWorkshop.updateAssessmentOnline(assessmentId, inputData, siteId);\n      } catch (error) {\n        if (error && CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means it cannot be performed. Discard.\n          discardError = CoreTextUtils.getErrorMessageFromError(error);\n        } else {\n          // Couldn't connect to server, reject.\n          throw error;\n        }\n      }\n      // Delete the offline data.\n      result.updated = true;\n      yield AddonModWorkshopOffline.deleteAssessment(workshop.id, assessmentId, siteId);\n      yield AddonModWorkshopHelper.deleteAssessmentStoredFiles(workshop.id, assessmentId, siteId);\n      if (discardError) {\n        // Assessment was discarded, add a warning.\n        _this5.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n      }\n    })();\n  }\n  /**\n   * Synchronize a submission evaluation.\n   *\n   * @param workshop Workshop.\n   * @param evaluate Submission evaluation offline data.\n   * @param result Object with the result of the sync.\n   * @param siteId Site ID.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  syncEvaluateSubmission(workshop, evaluate, result, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      let discardError;\n      const submissionId = evaluate.submissionid;\n      let timemodified = 0;\n      try {\n        const submission = yield AddonModWorkshop.getSubmission(workshop.id, submissionId, {\n          cmId: workshop.coursemodule,\n          siteId\n        });\n        timemodified = submission.timemodified;\n      } catch (_unused3) {\n        timemodified = -1;\n      }\n      if (timemodified < 0 || timemodified >= evaluate.timemodified) {\n        // The entry was not found in Moodle or the entry has been modified, discard the action.\n        result.updated = true;\n        discardError = Translate.instant('addon.mod_workshop.warningsubmissionmodified');\n        yield AddonModWorkshopOffline.deleteEvaluateSubmission(workshop.id, submissionId, siteId);\n        _this6.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n        return;\n      }\n      try {\n        yield AddonModWorkshop.evaluateSubmissionOnline(submissionId, evaluate.feedbacktext, evaluate.published, evaluate.gradeover, siteId);\n      } catch (error) {\n        if (error && CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means it cannot be performed. Discard.\n          discardError = CoreTextUtils.getErrorMessageFromError(error);\n        } else {\n          // Couldn't connect to server, reject.\n          throw error;\n        }\n      }\n      // Delete the offline data.\n      result.updated = true;\n      yield AddonModWorkshopOffline.deleteEvaluateSubmission(workshop.id, submissionId, siteId);\n      if (discardError) {\n        // Assessment was discarded, add a warning.\n        _this6.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n      }\n    })();\n  }\n  /**\n   * Synchronize a assessment evaluation.\n   *\n   * @param workshop Workshop.\n   * @param evaluate Assessment evaluation offline data.\n   * @param result Object with the result of the sync.\n   * @param siteId Site ID.\n   * @returns Promise resolved if success, rejected otherwise.\n   */\n  syncEvaluateAssessment(workshop, evaluate, result, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      let discardError;\n      const assessmentId = evaluate.assessmentid;\n      let timemodified = 0;\n      try {\n        const assessment = yield AddonModWorkshop.getAssessment(workshop.id, assessmentId, {\n          cmId: workshop.coursemodule,\n          siteId\n        });\n        timemodified = assessment.timemodified;\n      } catch (_unused4) {\n        timemodified = -1;\n      }\n      if (timemodified < 0 || timemodified >= evaluate.timemodified) {\n        // The entry was not found in Moodle or the entry has been modified, discard the action.\n        result.updated = true;\n        discardError = Translate.instant('addon.mod_workshop.warningassessmentmodified');\n        return AddonModWorkshopOffline.deleteEvaluateAssessment(workshop.id, assessmentId, siteId);\n      }\n      try {\n        yield AddonModWorkshop.evaluateAssessmentOnline(assessmentId, evaluate.feedbacktext, evaluate.weight, evaluate.gradinggradeover, siteId);\n      } catch (error) {\n        if (error && CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means it cannot be performed. Discard.\n          discardError = CoreTextUtils.getErrorMessageFromError(error);\n        } else {\n          // Couldn't connect to server, reject.\n          throw error;\n        }\n      }\n      // Delete the offline data.\n      result.updated = true;\n      yield AddonModWorkshopOffline.deleteEvaluateAssessment(workshop.id, assessmentId, siteId);\n      if (discardError) {\n        // Assessment was discarded, add a warning.\n        _this7.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n      }\n    })();\n  }\n}\n_class = AddonModWorkshopSyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_workshop_autom_synced';\n_class.MANUAL_SYNCED = 'addon_mod_workshop_manual_synced';\n_class.ɵfac = function AddonModWorkshopSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModWorkshopSync = makeSingleton(AddonModWorkshopSyncProvider);","map":{"version":3,"names":["CoreSyncBaseProvider","CoreSyncBlockedError","CoreNetworkError","CoreCourseLogHelper","CoreNetwork","CoreSites","CoreSync","CoreTextUtils","CoreUtils","Translate","makeSingleton","CoreEvents","AddonModWorkshop","AddonModWorkshopAction","AddonModWorkshopSubmissionType","AddonModWorkshopHelper","AddonModWorkshopOffline","ADDON_MOD_WORKSHOP_COMPONENT","AddonModWorkshopSyncProvider","constructor","componentTranslatableString","hasDataToSync","workshopId","siteId","hasWorkshopOfflineData","syncAllWorkshops","force","syncOnSites","syncAllWorkshopsFunc","_this","_asyncToGenerator","workshopIds","getAllWorkshops","promises","map","_ref","data","syncWorkshop","syncWorkshopIfNeeded","updated","trigger","AUTO_SYNCED","warnings","_x","apply","arguments","Promise","all","_this2","needed","isSyncNeeded","getCurrentSiteId","currentSyncPromise","getOngoingSync","isBlocked","logger","debug","instant","$a","componentTranslate","syncPromise","performSyncWorkshop","addOngoingSync","_this3","result","ignoreErrors","syncActivity","syncs","getSubmissions","getAssessments","getEvaluateSubmissions","getEvaluateAssessments","courseId","x","length","courseid","setSyncTime","isOnline","workshop","getWorkshopById","submissionsActions","assessments","submissionEvaluations","assessmentEvaluations","offlineSubmissions","forEach","action","submissionid","push","Object","keys","submissionId","submissionActions","syncSubmission","then","assessment","syncAssessment","evaluation","syncEvaluateSubmission","syncEvaluateAssessment","invalidateContentById","_this4","discardError","sort","a","b","timemodified","submission","getSubmission","id","cmId","coursemodule","_unused","deleteAllSubmissionActions","addOfflineDataDeletedWarning","name","_ref2","attachmentsId","attachmentsid","files","getSubmissionFilesFromOfflineFilesObject","uploadOrStoreSubmissionFiles","submissiontypefile","SUBMISSION_TYPE_DISABLED","undefined","ADD","addSubmissionOnline","title","content","UPDATE","updateSubmissionOnline","DELETE","deleteSubmissionOnline","error","isWebServiceError","getErrorMessageFromError","deleteSubmissionAction","workshopid","deleteSubmissionStoredFiles","_x2","assessmentData","_this5","assessmentId","assessmentid","getAssessment","_unused2","deleteAssessment","inputData","inputdata","feedbackauthorattachmentsid","getAssessmentFilesFromOfflineFilesObject","uploadOrStoreAssessmentFiles","updateAssessmentOnline","deleteAssessmentStoredFiles","evaluate","_this6","_unused3","deleteEvaluateSubmission","evaluateSubmissionOnline","feedbacktext","published","gradeover","_this7","_unused4","deleteEvaluateAssessment","evaluateAssessmentOnline","weight","gradinggradeover","_class","MANUAL_SYNCED","factory","ɵfac","providedIn","AddonModWorkshopSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/workshop/services/workshop-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSyncBaseProvider, CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreFileUploaderStoreFilesResult } from '@features/fileuploader/services/fileuploader';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFileEntry } from '@services/file-helper';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { Translate, makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModWorkshop,\n    AddonModWorkshopAction,\n    AddonModWorkshopData,\n    AddonModWorkshopSubmissionType,\n} from './workshop';\nimport { AddonModWorkshopHelper } from './workshop-helper';\nimport { AddonModWorkshopOffline,\n    AddonModWorkshopOfflineAssessment,\n    AddonModWorkshopOfflineEvaluateAssessment,\n    AddonModWorkshopOfflineEvaluateSubmission,\n    AddonModWorkshopOfflineSubmission,\n} from './workshop-offline';\nimport { ADDON_MOD_WORKSHOP_COMPONENT } from '@addons/mod/workshop/constants';\n\n/**\n * Service to sync workshops.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModWorkshopSyncProvider extends CoreSyncBaseProvider<AddonModWorkshopSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_workshop_autom_synced';\n    static readonly MANUAL_SYNCED = 'addon_mod_workshop_manual_synced';\n\n    protected componentTranslatableString = 'workshop';\n\n    constructor() {\n        super('AddonModWorkshopSyncProvider');\n    }\n\n    /**\n     * Check if an workshop has data to synchronize.\n     *\n     * @param workshopId Workshop ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if has data to sync, false otherwise.\n     */\n    hasDataToSync(workshopId: number, siteId?: string): Promise<boolean> {\n        return AddonModWorkshopOffline.hasWorkshopOfflineData(workshopId, siteId);\n    }\n\n    /**\n     * Try to synchronize all workshops that need it and haven't been synchronized in a while.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved when the sync is done.\n     */\n    syncAllWorkshops(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all workshops', (siteId) => this.syncAllWorkshopsFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all workshops on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllWorkshopsFunc(force: boolean, siteId: string): Promise<void> {\n        const workshopIds = await AddonModWorkshopOffline.getAllWorkshops(siteId);\n\n        // Sync all workshops that haven't been synced for a while.\n        const promises = workshopIds.map(async (workshopId) => {\n            const data = force\n                ? await this.syncWorkshop(workshopId, siteId)\n                : await this.syncWorkshopIfNeeded(workshopId, siteId);\n\n            if (data && data.updated) {\n                // Sync done. Send event.\n                CoreEvents.trigger(AddonModWorkshopSyncProvider.AUTO_SYNCED, {\n                    workshopId: workshopId,\n                    warnings: data.warnings,\n                }, siteId);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Sync a workshop only if a certain time has passed since the last time.\n     *\n     * @param workshopId Workshop ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the workshop is synced or if it doesn't need to be synced.\n     */\n    async syncWorkshopIfNeeded(workshopId: number, siteId?: string): Promise<AddonModWorkshopSyncResult | undefined> {\n        const needed = await this.isSyncNeeded(workshopId, siteId);\n\n        if (needed) {\n            return this.syncWorkshop(workshopId, siteId);\n        }\n    }\n\n    /**\n     * Try to synchronize a workshop.\n     *\n     * @param workshopId Workshop ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    syncWorkshop(workshopId: number, siteId?: string): Promise<AddonModWorkshopSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(workshopId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this discussion, return the promise.\n            return currentSyncPromise;\n        }\n\n        // Verify that workshop isn't blocked.\n        if (CoreSync.isBlocked(ADDON_MOD_WORKSHOP_COMPONENT, workshopId, siteId)) {\n            this.logger.debug(`Cannot sync workshop '${workshopId}' because it is blocked.`);\n\n            throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));\n        }\n\n        this.logger.debug(`Try to sync workshop '${workshopId}' in site ${siteId}'`);\n\n        const syncPromise = this.performSyncWorkshop(workshopId, siteId);\n\n        return this.addOngoingSync(workshopId, syncPromise, siteId);\n    }\n\n    /**\n     * Perform the workshop sync.\n     *\n     * @param workshopId Workshop ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    protected async performSyncWorkshop(workshopId: number, siteId: string): Promise<AddonModWorkshopSyncResult> {\n        const result: AddonModWorkshopSyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(ADDON_MOD_WORKSHOP_COMPONENT, workshopId, siteId));\n\n        // Get offline submissions to be sent.\n        const syncs = await Promise.all([\n            // Get offline submissions to be sent.\n            CoreUtils.ignoreErrors(AddonModWorkshopOffline.getSubmissions(workshopId, siteId), []),\n            // Get offline submission assessments to be sent.\n            CoreUtils.ignoreErrors(AddonModWorkshopOffline.getAssessments(workshopId, siteId), []),\n            // Get offline submission evaluations to be sent.\n            CoreUtils.ignoreErrors(AddonModWorkshopOffline.getEvaluateSubmissions(workshopId, siteId), []),\n            // Get offline assessment evaluations to be sent.\n            CoreUtils.ignoreErrors(AddonModWorkshopOffline.getEvaluateAssessments(workshopId, siteId), []),\n        ]);\n\n        let courseId: number | undefined;\n\n        // Get courseId from the first object\n        for (const x in syncs) {\n            if (syncs[x].length > 0 && syncs[x][0].courseid) {\n                courseId = syncs[x][0].courseid;\n                break;\n            }\n        }\n\n        if (!courseId) {\n            // Sync finished, set sync time.\n            await CoreUtils.ignoreErrors(this.setSyncTime(workshopId, siteId));\n\n            // Nothing to sync.\n            return result;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        const workshop = await AddonModWorkshop.getWorkshopById(courseId, workshopId, { siteId });\n\n        const submissionsActions: AddonModWorkshopOfflineSubmission[] = syncs[0];\n        const assessments: AddonModWorkshopOfflineAssessment[] = syncs[1];\n        const submissionEvaluations: AddonModWorkshopOfflineEvaluateSubmission[] = syncs[2];\n        const assessmentEvaluations: AddonModWorkshopOfflineEvaluateAssessment[] = syncs[3];\n        const offlineSubmissions: Record<string, AddonModWorkshopOfflineSubmission[]> = {};\n\n        const promises: Promise<void>[] = [];\n\n        submissionsActions.forEach((action) => {\n            offlineSubmissions[action.submissionid] = offlineSubmissions[action.submissionid] || [];\n            offlineSubmissions[action.submissionid].push(action);\n        });\n\n        Object.keys(offlineSubmissions).forEach((submissionId) => {\n            const submissionActions = offlineSubmissions[submissionId];\n            promises.push(this.syncSubmission(workshop, submissionActions, result, siteId).then(() => {\n                result.updated = true;\n\n                return;\n            }));\n        });\n\n        assessments.forEach((assessment) => {\n            promises.push(this.syncAssessment(workshop, assessment, result, siteId).then(() => {\n                result.updated = true;\n\n                return;\n            }));\n        });\n\n        submissionEvaluations.forEach((evaluation) => {\n            promises.push(this.syncEvaluateSubmission(workshop, evaluation, result, siteId).then(() => {\n                result.updated = true;\n\n                return;\n            }));\n        });\n\n        assessmentEvaluations.forEach((evaluation) => {\n            promises.push(this.syncEvaluateAssessment(workshop, evaluation, result, siteId).then(() => {\n                result.updated = true;\n\n                return;\n            }));\n        });\n\n        await Promise.all(promises);\n\n        if (result.updated) {\n            // Data has been sent to server. Now invalidate the WS calls.\n            await CoreUtils.ignoreErrors(AddonModWorkshop.invalidateContentById(workshopId, courseId, siteId));\n        }\n\n        // Sync finished, set sync time.\n        await CoreUtils.ignoreErrors(this.setSyncTime(workshopId, siteId));\n\n        // All done, return the warnings.\n        return result;\n    }\n\n    /**\n     * Synchronize a submission.\n     *\n     * @param workshop Workshop.\n     * @param submissionActions Submission actions offline data.\n     * @param result Object with the result of the sync.\n     * @param siteId Site ID.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    protected async syncSubmission(\n        workshop: AddonModWorkshopData,\n        submissionActions: AddonModWorkshopOfflineSubmission[],\n        result: AddonModWorkshopSyncResult,\n        siteId: string,\n    ): Promise<void> {\n        let discardError: string | undefined;\n\n        // Sort entries by timemodified.\n        submissionActions = submissionActions.sort((a, b) => a.timemodified - b.timemodified);\n\n        let timemodified = 0;\n        let submissionId = submissionActions[0].submissionid;\n\n        if (submissionId > 0) {\n            // Is editing.\n            try {\n                const submission = await AddonModWorkshop.getSubmission(workshop.id, submissionId, {\n                    cmId: workshop.coursemodule,\n                    siteId,\n                });\n\n                timemodified = submission.timemodified;\n            } catch {\n                timemodified = -1;\n            }\n        }\n\n        if (timemodified < 0 || timemodified >= submissionActions[0].timemodified) {\n            // The entry was not found in Moodle or the entry has been modified, discard the action.\n            result.updated = true;\n            discardError = Translate.instant('addon.mod_workshop.warningsubmissionmodified');\n\n            await AddonModWorkshopOffline.deleteAllSubmissionActions(workshop.id, siteId);\n\n            this.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n\n            return;\n        }\n\n        submissionActions.forEach(async (action) => {\n            submissionId = action.submissionid > 0 ? action.submissionid : submissionId;\n\n            try {\n                let attachmentsId: number | undefined;\n\n                // Upload attachments first if any.\n                if (action.attachmentsid) {\n                    const files = await AddonModWorkshopHelper.getSubmissionFilesFromOfflineFilesObject(\n                        action.attachmentsid,\n                        workshop.id,\n                        siteId,\n                    );\n\n                    attachmentsId = await AddonModWorkshopHelper.uploadOrStoreSubmissionFiles(\n                        workshop.id,\n                        files,\n                        false,\n                        siteId,\n                    );\n                } else {\n                    // Remove all files.\n                    attachmentsId = await AddonModWorkshopHelper.uploadOrStoreSubmissionFiles(\n                        workshop.id,\n                        [],\n                        false,\n                        siteId,\n                    );\n                }\n\n                if (workshop.submissiontypefile == AddonModWorkshopSubmissionType.SUBMISSION_TYPE_DISABLED) {\n                    attachmentsId = undefined;\n                }\n\n                // Perform the action.\n                switch (action.action) {\n                    case AddonModWorkshopAction.ADD:\n                        submissionId = await AddonModWorkshop.addSubmissionOnline(\n                            workshop.id,\n                            action.title,\n                            action.content,\n                            attachmentsId,\n                            siteId,\n                        );\n\n                        break;\n                    case AddonModWorkshopAction.UPDATE:\n                        await AddonModWorkshop.updateSubmissionOnline(\n                            submissionId,\n                            action.title,\n                            action.content,\n                            attachmentsId,\n                            siteId,\n                        );\n\n                        break;\n                    case AddonModWorkshopAction.DELETE:\n                        await AddonModWorkshop.deleteSubmissionOnline(submissionId, siteId);\n                }\n            } catch (error) {\n                if (error && CoreUtils.isWebServiceError(error)) {\n                    // The WebService has thrown an error, this means it cannot be performed. Discard.\n                    discardError = CoreTextUtils.getErrorMessageFromError(error);\n                }\n\n                // Couldn't connect to server, reject.\n                throw error;\n\n            }\n            // Delete the offline data.\n            result.updated = true;\n\n            await AddonModWorkshopOffline.deleteSubmissionAction(\n                action.workshopid,\n                action.action,\n                siteId,\n            );\n\n            // Delete stored files.\n            if (action.action == AddonModWorkshopAction.ADD || action.action == AddonModWorkshopAction.UPDATE) {\n\n                return AddonModWorkshopHelper.deleteSubmissionStoredFiles(\n                    action.workshopid,\n                    siteId,\n                );\n            }\n        });\n\n        if (discardError) {\n            // Submission was discarded, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n        }\n    }\n\n    /**\n     * Synchronize an assessment.\n     *\n     * @param workshop Workshop.\n     * @param assessmentData Assessment offline data.\n     * @param result Object with the result of the sync.\n     * @param siteId Site ID.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    protected async syncAssessment(\n        workshop: AddonModWorkshopData,\n        assessmentData: AddonModWorkshopOfflineAssessment,\n        result: AddonModWorkshopSyncResult,\n        siteId: string,\n    ): Promise<void> {\n        let discardError: string | undefined;\n        const assessmentId = assessmentData.assessmentid;\n\n        let timemodified = 0;\n\n        try {\n            const assessment = await AddonModWorkshop.getAssessment(workshop.id, assessmentId, {\n                cmId: workshop.coursemodule,\n                siteId,\n            });\n\n            timemodified = assessment.timemodified;\n        } catch {\n            timemodified = -1;\n        }\n\n        if (timemodified < 0 || timemodified >= assessmentData.timemodified) {\n            // The entry was not found in Moodle or the entry has been modified, discard the action.\n            result.updated = true;\n            discardError = Translate.instant('addon.mod_workshop.warningassessmentmodified');\n\n            await AddonModWorkshopOffline.deleteAssessment(workshop.id, assessmentId, siteId);\n\n            this.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n\n            return;\n        }\n\n        let attachmentsId = 0;\n        const inputData = assessmentData.inputdata;\n\n        try {\n            let files: CoreFileEntry[] = [];\n            // Upload attachments first if any.\n            if (inputData.feedbackauthorattachmentsid && typeof inputData.feedbackauthorattachmentsid !== 'number') {\n                files = await AddonModWorkshopHelper.getAssessmentFilesFromOfflineFilesObject(\n                    <CoreFileUploaderStoreFilesResult>inputData.feedbackauthorattachmentsid,\n                    workshop.id,\n                    assessmentId,\n                    siteId,\n                );\n            }\n\n            attachmentsId =\n                await AddonModWorkshopHelper.uploadOrStoreAssessmentFiles(workshop.id, assessmentId, files, false, siteId);\n\n            inputData.feedbackauthorattachmentsid = attachmentsId || 0;\n\n            await AddonModWorkshop.updateAssessmentOnline(assessmentId, inputData, siteId);\n        } catch (error) {\n            if (error && CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means it cannot be performed. Discard.\n                discardError = CoreTextUtils.getErrorMessageFromError(error);\n            } else {\n                // Couldn't connect to server, reject.\n                throw error;\n            }\n        }\n\n        // Delete the offline data.\n        result.updated = true;\n\n        await AddonModWorkshopOffline.deleteAssessment(workshop.id, assessmentId, siteId);\n        await AddonModWorkshopHelper.deleteAssessmentStoredFiles(workshop.id, assessmentId, siteId);\n\n        if (discardError) {\n            // Assessment was discarded, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n        }\n    }\n\n    /**\n     * Synchronize a submission evaluation.\n     *\n     * @param workshop Workshop.\n     * @param evaluate Submission evaluation offline data.\n     * @param result Object with the result of the sync.\n     * @param siteId Site ID.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    protected async syncEvaluateSubmission(\n        workshop: AddonModWorkshopData,\n        evaluate: AddonModWorkshopOfflineEvaluateSubmission,\n        result: AddonModWorkshopSyncResult,\n        siteId: string,\n    ): Promise<void> {\n        let discardError: string | undefined;\n        const submissionId = evaluate.submissionid;\n\n        let timemodified = 0;\n\n        try {\n            const submission = await AddonModWorkshop.getSubmission(workshop.id, submissionId, {\n                cmId: workshop.coursemodule,\n                siteId,\n            });\n\n            timemodified = submission.timemodified;\n        } catch {\n            timemodified = -1;\n        }\n\n        if (timemodified < 0 || timemodified >= evaluate.timemodified) {\n            // The entry was not found in Moodle or the entry has been modified, discard the action.\n            result.updated = true;\n            discardError = Translate.instant('addon.mod_workshop.warningsubmissionmodified');\n\n            await AddonModWorkshopOffline.deleteEvaluateSubmission(workshop.id, submissionId, siteId);\n\n            this.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n\n            return;\n        }\n\n        try {\n            await AddonModWorkshop.evaluateSubmissionOnline(\n                submissionId,\n                evaluate.feedbacktext,\n                evaluate.published,\n                evaluate.gradeover,\n                siteId,\n            );\n        } catch (error) {\n            if (error && CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means it cannot be performed. Discard.\n                discardError = CoreTextUtils.getErrorMessageFromError(error);\n            } else {\n                // Couldn't connect to server, reject.\n                throw error;\n            }\n        }\n\n        // Delete the offline data.\n        result.updated = true;\n\n        await AddonModWorkshopOffline.deleteEvaluateSubmission(workshop.id, submissionId, siteId);\n\n        if (discardError) {\n            // Assessment was discarded, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n        }\n    }\n\n    /**\n     * Synchronize a assessment evaluation.\n     *\n     * @param workshop Workshop.\n     * @param evaluate Assessment evaluation offline data.\n     * @param result Object with the result of the sync.\n     * @param siteId Site ID.\n     * @returns Promise resolved if success, rejected otherwise.\n     */\n    protected async syncEvaluateAssessment(\n        workshop: AddonModWorkshopData,\n        evaluate: AddonModWorkshopOfflineEvaluateAssessment,\n        result: AddonModWorkshopSyncResult,\n        siteId: string,\n    ): Promise<void> {\n        let discardError: string | undefined;\n        const assessmentId = evaluate.assessmentid;\n\n        let timemodified = 0;\n\n        try {\n            const assessment = await AddonModWorkshop.getAssessment(workshop.id, assessmentId, {\n                cmId: workshop.coursemodule,\n                siteId,\n            });\n\n            timemodified = assessment.timemodified;\n        } catch {\n            timemodified = -1;\n        }\n\n        if (timemodified < 0 || timemodified >= evaluate.timemodified) {\n            // The entry was not found in Moodle or the entry has been modified, discard the action.\n            result.updated = true;\n            discardError = Translate.instant('addon.mod_workshop.warningassessmentmodified');\n\n            return AddonModWorkshopOffline.deleteEvaluateAssessment(workshop.id, assessmentId, siteId);\n        }\n\n        try {\n            await AddonModWorkshop.evaluateAssessmentOnline(\n                assessmentId,\n                evaluate.feedbacktext,\n                evaluate.weight,\n                evaluate.gradinggradeover,\n                siteId,\n            );\n        } catch (error) {\n            if (error && CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means it cannot be performed. Discard.\n                discardError = CoreTextUtils.getErrorMessageFromError(error);\n            } else {\n                // Couldn't connect to server, reject.\n                throw error;\n            }\n        }\n\n        // Delete the offline data.\n        result.updated = true;\n\n        await AddonModWorkshopOffline.deleteEvaluateAssessment(workshop.id, assessmentId, siteId);\n\n        if (discardError) {\n            // Assessment was discarded, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, workshop.name, discardError);\n        }\n    }\n\n}\nexport const AddonModWorkshopSync = makeSingleton(AddonModWorkshopSyncProvider);\n\nexport type AddonModWorkshopAutoSyncData = {\n    workshopId: number;\n    warnings: string[];\n};\n\nexport type AddonModWorkshopSyncResult = CoreSyncResult;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}