{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { EventEmitter } from '@angular/core';\nimport { Translate } from '@singletons';\nimport { CoreSettingsHelper } from '@features/settings/services/settings-helper';\nimport { CoreAriaRoleTab } from './aria-role-tab';\nimport { CoreDom } from '@singletons/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreError } from './errors/error';\nimport { CorePromisedValue } from './promised-value';\nimport { CoreDirectivesRegistry } from '@singletons/directives-registry';\nimport { CorePlatform } from '@services/platform';\nimport { IonicSlides } from '@ionic/angular';\nimport * as i0 from \"@angular/core\";\nconst _c0 = [\"swiperRef\"];\n/**\n * Class to abstract some common code for tabs.\n */\nexport class CoreTabsBaseComponent {\n  set swiperRef(swiperRef) {\n    /**\n     * This setTimeout waits for Ionic's async initialization to complete.\n     * Otherwise, an outdated swiper reference will be used.\n     */\n    setTimeout(() => {\n      var _swiperRef$nativeElem;\n      if (swiperRef !== null && swiperRef !== void 0 && (_swiperRef$nativeElem = swiperRef.nativeElement) !== null && _swiperRef$nativeElem !== void 0 && _swiperRef$nativeElem.swiper && !this.swiper) {\n        this.swiper = swiperRef.nativeElement.swiper;\n        this.swiper.changeLanguageDirection(CorePlatform.isRTL ? 'rtl' : 'ltr');\n        Object.keys(this.swiperOpts).forEach(key => {\n          if (this.swiper) {\n            this.swiper.params[key] = this.swiperOpts[key];\n          }\n        });\n        // Subscribe to changes.\n        this.swiper.on('slideChangeTransitionEnd', () => {\n          this.slideChanged();\n        });\n        this.init();\n      }\n    }, 0);\n  }\n  constructor(element) {\n    this.selectedIndex = 0; // Index of the tab to select.\n    this.hideUntil = false; // Determine when should the contents be shown.\n    this.ionChange = new EventEmitter(); // Emitted when the tab changes.\n    this.tabs = []; // List of tabs.\n    this.hideTabs = false;\n    this.showPrevButton = false;\n    this.showNextButton = false;\n    this.maxSlides = 3;\n    this.numTabsShown = 0;\n    this.description = '';\n    this.swiperOpts = {\n      modules: [IonicSlides],\n      slidesPerView: 3,\n      centerInsufficientSlides: true,\n      threshold: 10\n    };\n    this.isDestroyed = false;\n    this.isCurrentView = true;\n    this.shouldSlideToInitial = false; // Whether we need to slide to the initial slide because it's out of view.\n    this.hasSliddenToInitial = false; // Whether we've already slidden to the initial slide or there was no need.\n    this.selectHistory = [];\n    // Swiper documentation: https://swiperjs.com/swiper-api\n    this.isInTransition = false; // Wether Slides is in transition.\n    this.subscriptions = [];\n    this.onReadyPromise = new CorePromisedValue();\n    this.backButtonFunction = event => this.backButtonClicked(event);\n    this.tabAction = new CoreTabsRoleTab(this);\n    CoreDirectivesRegistry.register(element.nativeElement, this);\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnInit() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Change the side when the language changes.\n      _this.subscriptions.push(Translate.onLangChange.subscribe(() => {\n        setTimeout(() => {\n          var _this$swiper;\n          (_this$swiper = _this.swiper) === null || _this$swiper === void 0 || _this$swiper.changeLanguageDirection(CorePlatform.isRTL ? 'rtl' : 'ltr');\n        });\n      }));\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  ngAfterViewInit() {\n    if (this.isDestroyed) {\n      return;\n    }\n    this.init();\n    this.resizeListener = CoreDom.onWindowResize(() => {\n      this.calculateSlides();\n    });\n  }\n  /**\n   * @inheritdoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ngOnChanges(changes) {\n    this.init();\n  }\n  /**\n   * @inheritdoc\n   */\n  ionViewDidEnter() {\n    this.isCurrentView = true;\n    this.calculateSlides();\n    document.addEventListener('ionBackButton', this.backButtonFunction);\n  }\n  /**\n   * Back button clicked.\n   *\n   * @param event Event.\n   */\n  backButtonClicked(event) {\n    event.detail.register(40, processNextHandler => {\n      if (this.selectHistory.length > 1) {\n        // The previous page in history is not the last one, we need the previous one.\n        const previousTabId = this.selectHistory[this.selectHistory.length - 2];\n        // Remove curent and previous tabs from history.\n        this.selectHistory = this.selectHistory.filter(tabId => this.selected != tabId && previousTabId != tabId);\n        this.selectTab(previousTabId);\n        return;\n      }\n      if (this.firstSelectedTab && this.selected != this.firstSelectedTab) {\n        // All history is gone but we are not in the first selected tab.\n        this.selectHistory = [];\n        this.selectTab(this.firstSelectedTab);\n        return;\n      }\n      processNextHandler();\n    });\n  }\n  /**\n   * @inheritdoc\n   */\n  ionViewDidLeave() {\n    // Unregister the custom back button action for this component.\n    document.removeEventListener('ionBackButton', this.backButtonFunction);\n    this.isCurrentView = false;\n  }\n  /**\n   * Updates the number of slides to show.\n   */\n  calculateSlides() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.isCurrentView || !_this2.swiper) {\n        // Don't calculate if component isn't in current view, the calculations are wrong.\n        return;\n      }\n      _this2.numTabsShown = _this2.tabs.reduce((prev, current) => current.enabled ? prev + 1 : prev, 0);\n      if (_this2.numTabsShown <= 1) {\n        _this2.hideTabs = true;\n        // Only one, nothing to do here.\n        return;\n      }\n      _this2.hideTabs = false;\n      yield _this2.calculateMaxSlides();\n      _this2.swiperOpts.slidesPerView = Math.min(_this2.maxSlides, _this2.numTabsShown);\n      _this2.slideChanged();\n      _this2.swiper.update();\n      yield CoreUtils.nextTick();\n      if (!_this2.hasSliddenToInitial && _this2.selectedIndex && _this2.selectedIndex >= _this2.swiper.slidesPerViewDynamic()) {\n        _this2.hasSliddenToInitial = true;\n        _this2.shouldSlideToInitial = true;\n        setTimeout(() => {\n          if (_this2.shouldSlideToInitial) {\n            var _this2$swiper;\n            (_this2$swiper = _this2.swiper) === null || _this2$swiper === void 0 || _this2$swiper.slideTo(_this2.selectedIndex, 0);\n            _this2.shouldSlideToInitial = false;\n          }\n        }, 400);\n        return;\n      } else if (_this2.selectedIndex) {\n        _this2.hasSliddenToInitial = true;\n      }\n      setTimeout(() => {\n        _this2.slideChanged(); // Call slide changed again, sometimes the slide active index takes a while to be updated.\n      }, 400);\n    })();\n  }\n  /**\n   * Get the tab on a index.\n   *\n   * @param tabId Tab ID.\n   * @returns Selected tab.\n   */\n  getTabIndex(tabId) {\n    if (!tabId) {\n      return -1;\n    }\n    return this.tabs.findIndex(tab => tabId === tab.id);\n  }\n  /**\n   * Get the current selected tab.\n   *\n   * @returns Selected tab.\n   */\n  getSelected() {\n    const index = this.getTabIndex(this.selected);\n    return index >= 0 ? this.tabs[index] : undefined;\n  }\n  /**\n   * Init the component.\n   */\n  init() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.hideUntil || !_this3.swiper) {\n        // Hidden, do nothing.\n        return;\n      }\n      try {\n        const selectedTab = _this3.calculateInitialTab();\n        if (!selectedTab) {\n          // No enabled tabs, return.\n          throw new CoreError('No enabled tabs.');\n        }\n        _this3.firstSelectedTab = selectedTab.id;\n        if (_this3.firstSelectedTab !== undefined) {\n          _this3.selectTab(_this3.firstSelectedTab);\n        }\n        // Check which arrows should be shown.\n        _this3.calculateSlides();\n      } catch (_unused) {\n        // Something went wrong, ignore.\n      }\n    })();\n  }\n  /**\n   * Calculate the initial tab to load.\n   *\n   * @returns Initial tab, undefined if no valid tab found.\n   */\n  calculateInitialTab() {\n    const selectedTab = this.tabs[this.selectedIndex || 0] || undefined;\n    if (selectedTab && selectedTab.enabled) {\n      return selectedTab;\n    }\n    // The tab is not enabled or not shown. Get the first tab that is enabled.\n    return this.tabs.find(tab => tab.enabled) || undefined;\n  }\n  /**\n   * Method executed when the slides are changed.\n   */\n  slideChanged() {\n    if (!this.swiper) {\n      return;\n    }\n    this.isInTransition = false;\n    const slidesCount = this.swiper.slides.length || 0;\n    if (slidesCount > 0) {\n      this.showPrevButton = !this.swiper.isBeginning;\n      this.showNextButton = !this.swiper.isEnd;\n    } else {\n      this.showPrevButton = false;\n      this.showNextButton = false;\n    }\n    const currentIndex = this.swiper.activeIndex;\n    if (this.shouldSlideToInitial && currentIndex != this.selectedIndex) {\n      // Current tab has changed, don't slide to initial anymore.\n      this.shouldSlideToInitial = false;\n    }\n  }\n  /**\n   * Calculate the number of slides that can fit on the screen.\n   */\n  calculateMaxSlides() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this4.swiper) {\n        return;\n      }\n      _this4.maxSlides = 3;\n      yield CoreUtils.nextTick();\n      if (!_this4.swiper.width) {\n        return;\n      }\n      const zoomLevel = yield CoreSettingsHelper.getZoom();\n      _this4.maxSlides = Math.floor(_this4.swiper.width / (zoomLevel / 100 * CoreTabsBaseComponent.MIN_TAB_WIDTH));\n    })();\n  }\n  /**\n   * Method that shows the next tab.\n   */\n  slideNext() {\n    // Stop if slides are in transition.\n    if (!this.showNextButton || this.isInTransition || !this.swiper) {\n      return;\n    }\n    if (this.swiper.isBeginning) {\n      // Slide to the second page.\n      this.swiper.slideTo(this.maxSlides);\n    } else {\n      const currentIndex = this.swiper.activeIndex;\n      if (currentIndex !== undefined) {\n        const nextSlideIndex = currentIndex + this.maxSlides;\n        this.isInTransition = true;\n        if (nextSlideIndex < this.numTabsShown) {\n          // Slide to the next page.\n          this.swiper.slideTo(nextSlideIndex);\n        } else {\n          // Slide to the latest slide.\n          this.swiper.slideTo(this.numTabsShown - 1);\n        }\n      }\n    }\n  }\n  /**\n   * Method that shows the previous tab.\n   */\n  slidePrev() {\n    // Stop if slides are in transition.\n    if (!this.showPrevButton || this.isInTransition || !this.swiper) {\n      return;\n    }\n    if (this.swiper.isEnd) {\n      this.swiper.slideTo(this.numTabsShown - this.maxSlides * 2);\n      // Slide to the previous of the latest page.\n    } else {\n      const currentIndex = this.swiper.activeIndex;\n      if (currentIndex !== undefined) {\n        const prevSlideIndex = currentIndex - this.maxSlides;\n        this.isInTransition = true;\n        if (prevSlideIndex >= 0) {\n          // Slide to the previous page.\n          this.swiper.slideTo(prevSlideIndex);\n        } else {\n          // Slide to the first page.\n          this.swiper.slideTo(0);\n        }\n      }\n    }\n  }\n  /**\n   * Select a tab by ID.\n   *\n   * @param tabId Tab ID.\n   * @param e Event.\n   * @returns Promise resolved when done.\n   */\n  selectTab(tabId, e) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const index = _this5.tabs.findIndex(tab => tabId == tab.id);\n      if (index < 0) {\n        return;\n      }\n      return _this5.selectByIndex(index, e);\n    })();\n  }\n  /**\n   * Select a tab by index.\n   *\n   * @param index Index to select.\n   * @param e Event.\n   * @returns Promise resolved when done.\n   */\n  selectByIndex(index, e) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      e === null || e === void 0 || e.preventDefault();\n      e === null || e === void 0 || e.stopPropagation();\n      if (index < 0 || index >= _this6.tabs.length) {\n        if (_this6.selected) {\n          // Invalid index do not change tab.\n          return;\n        }\n        // Index isn't valid, select the first one.\n        index = 0;\n      }\n      const tabToSelect = _this6.tabs[index];\n      if (!tabToSelect || !tabToSelect.enabled) {\n        // Not enabled.\n        return;\n      }\n      if (_this6.selected && _this6.swiper) {\n        // Check if we need to slide to the tab because it's not visible.\n        const firstVisibleTab = _this6.swiper.activeIndex;\n        const lastVisibleTab = firstVisibleTab + _this6.swiper.slidesPerViewDynamic() - 1;\n        if (index < firstVisibleTab || index > lastVisibleTab) {\n          _this6.swiper.slideTo(index, 0, true);\n        }\n      }\n      if (tabToSelect.id === _this6.selected) {\n        // Already selected.\n        return;\n      }\n      const suceeded = yield _this6.loadTab(tabToSelect);\n      if (suceeded !== false) {\n        _this6.tabSelected(tabToSelect, index);\n      }\n      _this6.onReadyPromise.resolve();\n    })();\n  }\n  /**\n   * Update selected tab.\n   *\n   * @param tab Tab.\n   * @param tabIndex Tab index.\n   */\n  tabSelected(tab, tabIndex) {\n    var _tab$id;\n    this.selectHistory.push((_tab$id = tab.id) !== null && _tab$id !== void 0 ? _tab$id : '');\n    this.selected = tab.id;\n    this.selectedIndex = tabIndex;\n    this.ionChange.emit(tab);\n  }\n  /**\n   * Load the tab.\n   *\n   * @param tabToSelect Tab to load.\n   * @returns Promise resolved with true if tab is successfully loaded.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  loadTab(tabToSelect) {\n    return _asyncToGenerator(function* () {\n      // Each implementation should override this function.\n      return true;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  ready() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.onReadyPromise;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnDestroy() {\n    var _this$resizeListener;\n    this.isDestroyed = true;\n    (_this$resizeListener = this.resizeListener) === null || _this$resizeListener === void 0 || _this$resizeListener.off();\n    this.subscriptions.forEach(subscription => subscription.unsubscribe());\n  }\n}\n/**\n * Helper class to manage rol tab.\n */\n_class = CoreTabsBaseComponent;\n// Minimum tab's width.\n_class.MIN_TAB_WIDTH = 107;\n_class.ɵfac = function CoreTabsBaseComponent_Factory(t) {\n  return new (t || _class)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n_class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: _class,\n  selectors: [[\"ng-component\"]],\n  viewQuery: function CoreTabsBaseComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.swiperRef = _t.first);\n    }\n  },\n  inputs: {\n    selectedIndex: \"selectedIndex\",\n    hideUntil: \"hideUntil\"\n  },\n  outputs: {\n    ionChange: \"ionChange\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature],\n  decls: 0,\n  vars: 0,\n  template: function CoreTabsBaseComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nclass CoreTabsRoleTab extends CoreAriaRoleTab {\n  /**\n   * @inheritdoc\n   */\n  selectTab(tabId, e) {\n    this.componentInstance.selectTab(tabId, e);\n  }\n  /**\n   * @inheritdoc\n   */\n  getSelectableTabs() {\n    return this.componentInstance.tabs.filter(tab => tab.enabled).map(tab => ({\n      id: tab.id || '',\n      findIndex: tab.id || ''\n    }));\n  }\n}","map":{"version":3,"names":["EventEmitter","Translate","CoreSettingsHelper","CoreAriaRoleTab","CoreDom","CoreUtils","CoreError","CorePromisedValue","CoreDirectivesRegistry","CorePlatform","IonicSlides","CoreTabsBaseComponent","swiperRef","setTimeout","_swiperRef$nativeElem","nativeElement","swiper","changeLanguageDirection","isRTL","Object","keys","swiperOpts","forEach","key","params","on","slideChanged","init","constructor","element","selectedIndex","hideUntil","ionChange","tabs","hideTabs","showPrevButton","showNextButton","maxSlides","numTabsShown","description","modules","slidesPerView","centerInsufficientSlides","threshold","isDestroyed","isCurrentView","shouldSlideToInitial","hasSliddenToInitial","selectHistory","isInTransition","subscriptions","onReadyPromise","backButtonFunction","event","backButtonClicked","tabAction","CoreTabsRoleTab","register","ngOnInit","_this","_asyncToGenerator","push","onLangChange","subscribe","_this$swiper","ngAfterViewInit","resizeListener","onWindowResize","calculateSlides","ngOnChanges","changes","ionViewDidEnter","document","addEventListener","detail","processNextHandler","length","previousTabId","filter","tabId","selected","selectTab","firstSelectedTab","ionViewDidLeave","removeEventListener","_this2","reduce","prev","current","enabled","calculateMaxSlides","Math","min","update","nextTick","slidesPerViewDynamic","_this2$swiper","slideTo","getTabIndex","findIndex","tab","id","getSelected","index","undefined","_this3","selectedTab","calculateInitialTab","_unused","find","slidesCount","slides","isBeginning","isEnd","currentIndex","activeIndex","_this4","width","zoomLevel","getZoom","floor","MIN_TAB_WIDTH","slideNext","nextSlideIndex","slidePrev","prevSlideIndex","e","_this5","selectByIndex","_this6","preventDefault","stopPropagation","tabToSelect","firstVisibleTab","lastVisibleTab","suceeded","loadTab","tabSelected","resolve","tabIndex","_tab$id","emit","ready","_this7","ngOnDestroy","_this$resizeListener","off","subscription","unsubscribe","_class","i0","ɵɵdirectiveInject","ElementRef","selectors","viewQuery","CoreTabsBaseComponent_Query","rf","ctx","componentInstance","getSelectableTabs","map"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/tabs.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n    Component,\n    Input,\n    Output,\n    EventEmitter,\n    OnInit,\n    OnChanges,\n    OnDestroy,\n    AfterViewInit,\n    ViewChild,\n    SimpleChange,\n    ElementRef,\n} from '@angular/core';\nimport { BackButtonEvent } from '@ionic/core';\nimport { Subscription } from 'rxjs';\n\nimport { Translate } from '@singletons';\nimport { CoreSettingsHelper } from '@features/settings/services/settings-helper';\nimport { CoreAriaRoleTab, CoreAriaRoleTabFindable } from './aria-role-tab';\nimport { CoreEventObserver } from '@singletons/events';\nimport { CoreDom } from '@singletons/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreError } from './errors/error';\nimport { CorePromisedValue } from './promised-value';\nimport { AsyncDirective } from './async-directive';\nimport { CoreDirectivesRegistry } from '@singletons/directives-registry';\nimport { CorePlatform } from '@services/platform';\nimport { Swiper } from 'swiper';\nimport { SwiperOptions } from 'swiper/types';\nimport { IonicSlides } from '@ionic/angular';\n\n/**\n * Class to abstract some common code for tabs.\n */\n@Component({\n    template: '',\n})\nexport class CoreTabsBaseComponent<T extends CoreTabBase> implements OnInit, AfterViewInit, OnChanges, OnDestroy, AsyncDirective {\n\n    // Minimum tab's width.\n    protected static readonly MIN_TAB_WIDTH = 107;\n\n    @Input() selectedIndex = 0; // Index of the tab to select.\n    @Input() hideUntil = false; // Determine when should the contents be shown.\n    @Output() protected ionChange = new EventEmitter<T>(); // Emitted when the tab changes.\n\n    protected swiper?: Swiper;\n    @ViewChild('swiperRef')\n    set swiperRef(swiperRef: ElementRef) {\n        /**\n         * This setTimeout waits for Ionic's async initialization to complete.\n         * Otherwise, an outdated swiper reference will be used.\n         */\n        setTimeout(() => {\n            if (swiperRef?.nativeElement?.swiper && !this.swiper) {\n                this.swiper = swiperRef.nativeElement.swiper as Swiper;\n\n                this.swiper.changeLanguageDirection(CorePlatform.isRTL ? 'rtl' : 'ltr');\n\n                Object.keys(this.swiperOpts).forEach((key) => {\n                    if (this.swiper) {\n                        this.swiper.params[key] = this.swiperOpts[key];\n                    }\n                });\n\n                // Subscribe to changes.\n                this.swiper.on('slideChangeTransitionEnd', () => {\n                    this.slideChanged();\n                });\n\n                this.init();\n            }\n        }, 0);\n    }\n\n    tabs: T[] = []; // List of tabs.\n\n    hideTabs = false;\n    selected?: string; // Selected tab id.\n    showPrevButton = false;\n    showNextButton = false;\n    maxSlides = 3;\n    numTabsShown = 0;\n    description = '';\n    swiperOpts: SwiperOptions = {\n        modules: [IonicSlides],\n        slidesPerView: 3,\n        centerInsufficientSlides: true,\n        threshold: 10,\n    };\n\n    protected resizeListener?: CoreEventObserver;\n    protected isDestroyed = false;\n    protected isCurrentView = true;\n    protected shouldSlideToInitial = false; // Whether we need to slide to the initial slide because it's out of view.\n    protected hasSliddenToInitial = false; // Whether we've already slidden to the initial slide or there was no need.\n    protected selectHistory: string[] = [];\n\n    protected firstSelectedTab?: string; // ID of the first selected tab to control history.\n    protected backButtonFunction: (event: BackButtonEvent) => void;\n    // Swiper documentation: https://swiperjs.com/swiper-api\n    protected isInTransition = false; // Wether Slides is in transition.\n    protected subscriptions: Subscription[] = [];\n    protected onReadyPromise = new CorePromisedValue<void>();\n\n    tabAction: CoreTabsRoleTab<T>;\n\n    constructor(element: ElementRef) {\n        this.backButtonFunction = (event) => this.backButtonClicked(event);\n\n        this.tabAction = new CoreTabsRoleTab(this);\n\n        CoreDirectivesRegistry.register(element.nativeElement, this);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async ngOnInit(): Promise<void> {\n        // Change the side when the language changes.\n        this.subscriptions.push(Translate.onLangChange.subscribe(() => {\n            setTimeout(() => {\n                this.swiper?.changeLanguageDirection(CorePlatform.isRTL ? 'rtl' : 'ltr');\n            });\n        }));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngAfterViewInit(): void {\n        if (this.isDestroyed) {\n            return;\n        }\n\n        this.init();\n\n        this.resizeListener = CoreDom.onWindowResize(() => {\n            this.calculateSlides();\n        });\n    }\n\n    /**\n     * @inheritdoc\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ngOnChanges(changes: Record<string, SimpleChange>): void {\n        this.init();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ionViewDidEnter(): void {\n        this.isCurrentView = true;\n\n        this.calculateSlides();\n\n        document.addEventListener('ionBackButton', this.backButtonFunction);\n    }\n\n    /**\n     * Back button clicked.\n     *\n     * @param event Event.\n     */\n    protected backButtonClicked(event: BackButtonEvent): void {\n        event.detail.register(40, (processNextHandler: () => void) => {\n            if (this.selectHistory.length > 1) {\n                // The previous page in history is not the last one, we need the previous one.\n                const previousTabId = this.selectHistory[this.selectHistory.length - 2];\n\n                // Remove curent and previous tabs from history.\n                this.selectHistory = this.selectHistory.filter((tabId) => this.selected != tabId && previousTabId != tabId);\n\n                this.selectTab(previousTabId);\n\n                return;\n            }\n\n            if (this.firstSelectedTab && this.selected != this.firstSelectedTab) {\n                // All history is gone but we are not in the first selected tab.\n                this.selectHistory = [];\n\n                this.selectTab(this.firstSelectedTab);\n\n                return;\n            }\n\n            processNextHandler();\n        });\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ionViewDidLeave(): void {\n        // Unregister the custom back button action for this component.\n        document.removeEventListener('ionBackButton', this.backButtonFunction);\n\n        this.isCurrentView = false;\n    }\n\n    /**\n     * Updates the number of slides to show.\n     */\n    protected async calculateSlides(): Promise<void> {\n        if (!this.isCurrentView || !this.swiper) {\n            // Don't calculate if component isn't in current view, the calculations are wrong.\n            return;\n        }\n\n        this.numTabsShown = this.tabs.reduce((prev: number, current) => current.enabled ? prev + 1 : prev, 0);\n        if (this.numTabsShown <= 1) {\n            this.hideTabs = true;\n\n            // Only one, nothing to do here.\n            return;\n        }\n        this.hideTabs = false;\n\n        await this.calculateMaxSlides();\n\n        this.swiperOpts.slidesPerView = Math.min(this.maxSlides, this.numTabsShown);\n\n        this.slideChanged();\n\n        this.swiper.update();\n        await CoreUtils.nextTick();\n\n        if (!this.hasSliddenToInitial && this.selectedIndex && this.selectedIndex >= this.swiper.slidesPerViewDynamic()) {\n            this.hasSliddenToInitial = true;\n            this.shouldSlideToInitial = true;\n\n            setTimeout(() => {\n                if (this.shouldSlideToInitial) {\n                    this.swiper?.slideTo(this.selectedIndex, 0);\n                    this.shouldSlideToInitial = false;\n                }\n            }, 400);\n\n            return;\n        } else if (this.selectedIndex) {\n            this.hasSliddenToInitial = true;\n        }\n\n        setTimeout(() => {\n            this.slideChanged(); // Call slide changed again, sometimes the slide active index takes a while to be updated.\n        }, 400);\n    }\n\n    /**\n     * Get the tab on a index.\n     *\n     * @param tabId Tab ID.\n     * @returns Selected tab.\n     */\n    protected getTabIndex(tabId?: string): number {\n        if (!tabId) {\n            return -1;\n        }\n\n        return this.tabs.findIndex((tab) => tabId === tab.id);\n    }\n\n    /**\n     * Get the current selected tab.\n     *\n     * @returns Selected tab.\n     */\n    getSelected(): T | undefined {\n        const index = this.getTabIndex(this.selected);\n\n        return index >= 0 ? this.tabs[index] : undefined;\n    }\n\n    /**\n     * Init the component.\n     */\n    protected async init(): Promise<void> {\n        if (!this.hideUntil || !this.swiper) {\n            // Hidden, do nothing.\n            return;\n        }\n\n        try {\n            const selectedTab = this.calculateInitialTab();\n            if (!selectedTab) {\n                // No enabled tabs, return.\n                throw new CoreError('No enabled tabs.');\n            }\n\n            this.firstSelectedTab = selectedTab.id;\n            if (this.firstSelectedTab !== undefined) {\n                this.selectTab(this.firstSelectedTab);\n            }\n\n            // Check which arrows should be shown.\n            this.calculateSlides();\n        } catch {\n            // Something went wrong, ignore.\n        }\n    }\n\n    /**\n     * Calculate the initial tab to load.\n     *\n     * @returns Initial tab, undefined if no valid tab found.\n     */\n    protected calculateInitialTab(): T | undefined {\n        const selectedTab: T | undefined = this.tabs[this.selectedIndex || 0] || undefined;\n\n        if (selectedTab && selectedTab.enabled) {\n            return selectedTab;\n        }\n\n        // The tab is not enabled or not shown. Get the first tab that is enabled.\n        return this.tabs.find((tab) => tab.enabled) || undefined;\n    }\n\n    /**\n     * Method executed when the slides are changed.\n     */\n    slideChanged(): void {\n        if (!this.swiper) {\n            return;\n        }\n\n        this.isInTransition = false;\n        const slidesCount = this.swiper.slides.length || 0;\n        if (slidesCount > 0) {\n            this.showPrevButton = !this.swiper.isBeginning;\n            this.showNextButton = !this.swiper.isEnd;\n        } else {\n            this.showPrevButton = false;\n            this.showNextButton = false;\n        }\n\n        const currentIndex = this.swiper.activeIndex;\n        if (this.shouldSlideToInitial && currentIndex != this.selectedIndex) {\n            // Current tab has changed, don't slide to initial anymore.\n            this.shouldSlideToInitial = false;\n        }\n    }\n\n    /**\n     * Calculate the number of slides that can fit on the screen.\n     */\n    protected async calculateMaxSlides(): Promise<void> {\n        if (!this.swiper) {\n            return;\n        }\n\n        this.maxSlides = 3;\n        await CoreUtils.nextTick();\n\n        if (!this.swiper.width) {\n            return;\n        }\n\n        const zoomLevel = await CoreSettingsHelper.getZoom();\n\n        this.maxSlides = Math.floor(this.swiper.width / (zoomLevel / 100 * CoreTabsBaseComponent.MIN_TAB_WIDTH));\n    }\n\n    /**\n     * Method that shows the next tab.\n     */\n    slideNext(): void {\n        // Stop if slides are in transition.\n        if (!this.showNextButton || this.isInTransition || !this.swiper) {\n            return;\n        }\n\n        if (this.swiper.isBeginning) {\n            // Slide to the second page.\n            this.swiper.slideTo(this.maxSlides);\n        } else {\n            const currentIndex = this.swiper.activeIndex;\n            if (currentIndex !== undefined) {\n                const nextSlideIndex = currentIndex + this.maxSlides;\n                this.isInTransition = true;\n                if (nextSlideIndex < this.numTabsShown) {\n                    // Slide to the next page.\n                    this.swiper.slideTo(nextSlideIndex);\n                } else {\n                    // Slide to the latest slide.\n                    this.swiper.slideTo(this.numTabsShown - 1);\n                }\n            }\n\n        }\n    }\n\n    /**\n     * Method that shows the previous tab.\n     */\n    slidePrev(): void {\n        // Stop if slides are in transition.\n        if (!this.showPrevButton || this.isInTransition || !this.swiper) {\n            return;\n        }\n\n        if (this.swiper.isEnd) {\n            this.swiper.slideTo(this.numTabsShown - this.maxSlides * 2);\n            // Slide to the previous of the latest page.\n        } else {\n            const currentIndex = this.swiper.activeIndex;\n            if (currentIndex !== undefined) {\n                const prevSlideIndex = currentIndex - this.maxSlides;\n                this.isInTransition = true;\n                if (prevSlideIndex >= 0) {\n                    // Slide to the previous page.\n                    this.swiper.slideTo(prevSlideIndex);\n                } else {\n                    // Slide to the first page.\n                    this.swiper.slideTo(0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Select a tab by ID.\n     *\n     * @param tabId Tab ID.\n     * @param e Event.\n     * @returns Promise resolved when done.\n     */\n    async selectTab(tabId: string, e?: Event): Promise<void> {\n        const index = this.tabs.findIndex((tab) => tabId == tab.id);\n        if (index < 0) {\n            return;\n        }\n\n        return this.selectByIndex(index, e);\n    }\n\n    /**\n     * Select a tab by index.\n     *\n     * @param index Index to select.\n     * @param e Event.\n     * @returns Promise resolved when done.\n     */\n    async selectByIndex(index: number, e?: Event): Promise<void> {\n        e?.preventDefault();\n        e?.stopPropagation();\n\n        if (index < 0 || index >= this.tabs.length) {\n            if (this.selected) {\n                // Invalid index do not change tab.\n                return;\n            }\n\n            // Index isn't valid, select the first one.\n            index = 0;\n        }\n\n        const tabToSelect = this.tabs[index];\n        if (!tabToSelect || !tabToSelect.enabled) {\n            // Not enabled.\n            return;\n        }\n\n        if (this.selected && this.swiper) {\n            // Check if we need to slide to the tab because it's not visible.\n            const firstVisibleTab = this.swiper.activeIndex;\n            const lastVisibleTab = firstVisibleTab + this.swiper.slidesPerViewDynamic() - 1;\n            if (index < firstVisibleTab || index > lastVisibleTab) {\n                this.swiper.slideTo(index, 0, true);\n            }\n        }\n\n        if (tabToSelect.id === this.selected) {\n            // Already selected.\n            return;\n        }\n\n        const suceeded = await this.loadTab(tabToSelect);\n\n        if (suceeded !== false) {\n            this.tabSelected(tabToSelect, index);\n        }\n        this.onReadyPromise.resolve();\n    }\n\n    /**\n     * Update selected tab.\n     *\n     * @param tab Tab.\n     * @param tabIndex Tab index.\n     */\n    protected tabSelected(tab: T, tabIndex: number): void {\n        this.selectHistory.push(tab.id ?? '');\n        this.selected = tab.id;\n        this.selectedIndex = tabIndex;\n\n        this.ionChange.emit(tab);\n    }\n\n    /**\n     * Load the tab.\n     *\n     * @param tabToSelect Tab to load.\n     * @returns Promise resolved with true if tab is successfully loaded.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    protected async loadTab(tabToSelect: T): Promise<boolean> {\n        // Each implementation should override this function.\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async ready(): Promise<void> {\n        return this.onReadyPromise;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngOnDestroy(): void {\n        this.isDestroyed = true;\n\n        this.resizeListener?.off();\n        this.subscriptions.forEach((subscription) => subscription.unsubscribe());\n    }\n\n}\n\n/**\n * Helper class to manage rol tab.\n */\nclass CoreTabsRoleTab<T extends CoreTabBase> extends CoreAriaRoleTab<CoreTabsBaseComponent<T>> {\n\n    /**\n     * @inheritdoc\n     */\n    selectTab(tabId: string, e: Event): void {\n        this.componentInstance.selectTab(tabId, e);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getSelectableTabs(): CoreAriaRoleTabFindable[] {\n        return this.componentInstance.tabs.filter((tab) => tab.enabled).map((tab) => ({\n            id: tab.id || '',\n            findIndex: tab.id || '',\n        }));\n    }\n\n}\n\n/**\n * Data for each tab.\n */\nexport type CoreTabBase = {\n    title: string; // The translatable tab title.\n    id?: string; // Unique tab id.\n    class?: string; // Class, if needed.\n    icon?: string; // The tab icon.\n    badge?: string; // A badge to add in the tab.\n    badgeStyle?: string; // The badge color.\n    badgeA11yText?: string; // Accessibility text to add on the badge.\n    enabled?: boolean; // Whether the tab is enabled.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}