{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreComments } from '@features/comments/services/comments';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { AddonModGlossary, AddonModGlossaryProvider } from '../glossary';\nimport { AddonModGlossarySync } from '../glossary-sync';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to prefetch forums.\n */\nexport class AddonModGlossaryPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n  constructor() {\n    super(...arguments);\n    this.name = 'AddonModGlossary';\n    this.modName = 'glossary';\n    this.component = AddonModGlossaryProvider.COMPONENT;\n    this.updatesNames = /^configuration$|^.*files$|^entries$/;\n  }\n  /**\n   * @inheritdoc\n   */\n  getFiles(module, courseId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const glossary = yield AddonModGlossary.getGlossary(courseId, module.id);\n        const entries = yield AddonModGlossary.fetchAllEntries(options => AddonModGlossary.getEntriesByLetter(glossary.id, options), {\n          cmId: module.id\n        });\n        return _this.getFilesFromGlossaryAndEntries(module, glossary, entries);\n      } catch (_unused) {\n        // Glossary not found, return empty list.\n        return [];\n      }\n    })();\n  }\n  /**\n   * Get the list of downloadable files. It includes entry embedded files.\n   *\n   * @param module Module to get the files.\n   * @param glossary Glossary\n   * @param entries Entries of the Glossary.\n   * @returns List of Files.\n   */\n  getFilesFromGlossaryAndEntries(module, glossary, entries) {\n    let files = this.getIntroFilesFromInstance(module, glossary);\n    // Get entries files.\n    entries.forEach(entry => {\n      files = files.concat(entry.attachments || []);\n      if (entry.definitioninlinefiles && entry.definitioninlinefiles.length) {\n        files = files.concat(entry.definitioninlinefiles);\n      }\n    });\n    return files;\n  }\n  /**\n   * @inheritdoc\n   */\n  invalidateContent(moduleId, courseId) {\n    return AddonModGlossary.invalidateContent(moduleId, courseId);\n  }\n  /**\n   * @inheritdoc\n   */\n  prefetch(module, courseId) {\n    return this.prefetchPackage(module, courseId, siteId => this.prefetchGlossary(module, courseId, siteId));\n  }\n  /**\n   * Prefetch a glossary.\n   *\n   * @param module The module object returned by WS.\n   * @param courseId Course ID the module belongs to.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  prefetchGlossary(module, courseId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const options = {\n        cmId: module.id,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      };\n      // Prefetch the glossary data.\n      const glossary = yield AddonModGlossary.getGlossary(courseId, module.id, {\n        siteId\n      });\n      const promises = [];\n      glossary.browsemodes.forEach(mode => {\n        switch (mode) {\n          case 'letter':\n            // Always done. Look bellow.\n            break;\n          case 'cat':\n            promises.push(AddonModGlossary.fetchAllEntries(newOptions => AddonModGlossary.getEntriesByCategory(glossary.id, newOptions), options));\n            break;\n          case 'date':\n            promises.push(AddonModGlossary.fetchAllEntries(newOptions => AddonModGlossary.getEntriesByDate(glossary.id, 'CREATION', newOptions), options));\n            promises.push(AddonModGlossary.fetchAllEntries(newOptions => AddonModGlossary.getEntriesByDate(glossary.id, 'UPDATE', newOptions), options));\n            break;\n          case 'author':\n            promises.push(AddonModGlossary.fetchAllEntries(newOptions => AddonModGlossary.getEntriesByAuthor(glossary.id, newOptions), options));\n            break;\n          default:\n        }\n      });\n      // Fetch all entries to get information from.\n      promises.push(AddonModGlossary.fetchAllEntries(newOptions => AddonModGlossary.getEntriesByLetter(glossary.id, newOptions), options).then(entries => {\n        const promises = [];\n        const commentsEnabled = !CoreComments.areCommentsDisabledInSite();\n        entries.forEach(entry => {\n          // Don't fetch individual entries, it's too many WS calls.\n          if (glossary.allowcomments && commentsEnabled) {\n            promises.push(CoreComments.getComments('module', glossary.coursemodule, 'mod_glossary', entry.id, 'glossary_entry', 0, siteId));\n          }\n        });\n        const files = _this2.getFilesFromGlossaryAndEntries(module, glossary, entries);\n        promises.push(CoreFilepool.addFilesToQueue(siteId, files, _this2.component, module.id));\n        // Prefetch user avatars.\n        promises.push(CoreUser.prefetchUserAvatars(entries, 'userpictureurl', siteId));\n        return Promise.all(promises);\n      }));\n      // Get all categories.\n      promises.push(AddonModGlossary.getAllCategories(glossary.id, options));\n      // Prefetch data for link handlers.\n      promises.push(CoreCourse.getModuleBasicInfo(module.id, {\n        siteId\n      }));\n      promises.push(CoreCourse.getModuleBasicInfoByInstance(glossary.id, 'glossary', {\n        siteId\n      }));\n      // Get course data, needed to determine upload max size if it's configured to be course limit.\n      promises.push(CoreUtils.ignoreErrors(CoreCourses.getCourseByField('id', courseId, siteId)));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  sync(module, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const results = yield Promise.all([AddonModGlossarySync.syncGlossaryEntries(module.instance, undefined, siteId), AddonModGlossarySync.syncRatings(module.id, undefined, siteId)]);\n      return {\n        updated: results[0].updated || results[1].updated,\n        warnings: results[0].warnings.concat(results[1].warnings)\n      };\n    })();\n  }\n}\n_class = AddonModGlossaryPrefetchHandlerService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵAddonModGlossaryPrefetchHandlerService_BaseFactory;\n  return function AddonModGlossaryPrefetchHandlerService_Factory(t) {\n    return (ɵAddonModGlossaryPrefetchHandlerService_BaseFactory || (ɵAddonModGlossaryPrefetchHandlerService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModGlossaryPrefetchHandler = makeSingleton(AddonModGlossaryPrefetchHandlerService);","map":{"version":3,"names":["CoreComments","CoreCourseActivityPrefetchHandlerBase","CoreCourse","CoreCourses","CoreUser","CoreFilepool","CoreUtils","makeSingleton","AddonModGlossary","AddonModGlossaryProvider","AddonModGlossarySync","AddonModGlossaryPrefetchHandlerService","constructor","name","modName","component","COMPONENT","updatesNames","getFiles","module","courseId","_this","_asyncToGenerator","glossary","getGlossary","id","entries","fetchAllEntries","options","getEntriesByLetter","cmId","getFilesFromGlossaryAndEntries","_unused","files","getIntroFilesFromInstance","forEach","entry","concat","attachments","definitioninlinefiles","length","invalidateContent","moduleId","prefetch","prefetchPackage","siteId","prefetchGlossary","_this2","readingStrategy","promises","browsemodes","mode","push","newOptions","getEntriesByCategory","getEntriesByDate","getEntriesByAuthor","then","commentsEnabled","areCommentsDisabledInSite","allowcomments","getComments","coursemodule","addFilesToQueue","prefetchUserAvatars","Promise","all","getAllCategories","getModuleBasicInfo","getModuleBasicInfoByInstance","ignoreErrors","getCourseByField","sync","results","syncGlossaryEntries","instance","undefined","syncRatings","updated","warnings","t","factory","ɵfac","providedIn","AddonModGlossaryPrefetchHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/glossary/services/handlers/prefetch.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreComments } from '@features/comments/services/comments';\nimport { CoreCourseActivityPrefetchHandlerBase } from '@features/course/classes/activity-prefetch-handler';\nimport { CoreCourse, CoreCourseAnyModuleData } from '@features/course/services/course';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { AddonModGlossary, AddonModGlossaryEntry, AddonModGlossaryGlossary, AddonModGlossaryProvider } from '../glossary';\nimport { AddonModGlossarySync, AddonModGlossarySyncResult } from '../glossary-sync';\n\n/**\n * Handler to prefetch forums.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModGlossaryPrefetchHandlerService extends CoreCourseActivityPrefetchHandlerBase {\n\n    name = 'AddonModGlossary';\n    modName = 'glossary';\n    component = AddonModGlossaryProvider.COMPONENT;\n    updatesNames = /^configuration$|^.*files$|^entries$/;\n\n    /**\n     * @inheritdoc\n     */\n    async getFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<CoreWSFile[]> {\n        try {\n            const glossary = await AddonModGlossary.getGlossary(courseId, module.id);\n\n            const entries = await AddonModGlossary.fetchAllEntries(\n                (options) => AddonModGlossary.getEntriesByLetter(glossary.id, options),\n                {\n                    cmId: module.id,\n                },\n            );\n\n            return this.getFilesFromGlossaryAndEntries(module, glossary, entries);\n        } catch {\n            // Glossary not found, return empty list.\n            return [];\n        }\n    }\n\n    /**\n     * Get the list of downloadable files. It includes entry embedded files.\n     *\n     * @param module Module to get the files.\n     * @param glossary Glossary\n     * @param entries Entries of the Glossary.\n     * @returns List of Files.\n     */\n    protected getFilesFromGlossaryAndEntries(\n        module: CoreCourseAnyModuleData,\n        glossary: AddonModGlossaryGlossary,\n        entries: AddonModGlossaryEntry[],\n    ): CoreWSFile[] {\n        let files = this.getIntroFilesFromInstance(module, glossary);\n\n        // Get entries files.\n        entries.forEach((entry) => {\n            files = files.concat(entry.attachments || []);\n\n            if (entry.definitioninlinefiles && entry.definitioninlinefiles.length) {\n                files = files.concat(entry.definitioninlinefiles);\n            }\n        });\n\n        return files;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        return AddonModGlossary.invalidateContent(moduleId, courseId);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    prefetch(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        return this.prefetchPackage(module, courseId, (siteId) => this.prefetchGlossary(module, courseId, siteId));\n    }\n\n    /**\n     * Prefetch a glossary.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID the module belongs to.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async prefetchGlossary(module: CoreCourseAnyModuleData, courseId: number, siteId: string): Promise<void> {\n        const options = {\n            cmId: module.id,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        };\n\n        // Prefetch the glossary data.\n        const glossary = await AddonModGlossary.getGlossary(courseId, module.id, { siteId });\n\n        const promises: Promise<unknown>[] = [];\n\n        glossary.browsemodes.forEach((mode) => {\n            switch (mode) {\n                case 'letter': // Always done. Look bellow.\n                    break;\n                case 'cat':\n                    promises.push(AddonModGlossary.fetchAllEntries(\n                        (newOptions) => AddonModGlossary.getEntriesByCategory(glossary.id, newOptions),\n                        options,\n                    ));\n                    break;\n                case 'date':\n                    promises.push(AddonModGlossary.fetchAllEntries(\n                        (newOptions) => AddonModGlossary.getEntriesByDate(glossary.id, 'CREATION', newOptions),\n                        options,\n                    ));\n                    promises.push(AddonModGlossary.fetchAllEntries(\n                        (newOptions) => AddonModGlossary.getEntriesByDate(glossary.id, 'UPDATE', newOptions),\n                        options,\n                    ));\n                    break;\n                case 'author':\n                    promises.push(AddonModGlossary.fetchAllEntries(\n                        (newOptions) => AddonModGlossary.getEntriesByAuthor(glossary.id, newOptions),\n                        options,\n                    ));\n                    break;\n                default:\n            }\n        });\n\n        // Fetch all entries to get information from.\n        promises.push(AddonModGlossary.fetchAllEntries(\n            (newOptions) => AddonModGlossary.getEntriesByLetter(glossary.id, newOptions),\n            options,\n        ).then((entries) => {\n            const promises: Promise<unknown>[] = [];\n            const commentsEnabled = !CoreComments.areCommentsDisabledInSite();\n\n            entries.forEach((entry) => {\n                // Don't fetch individual entries, it's too many WS calls.\n                if (glossary.allowcomments && commentsEnabled) {\n                    promises.push(CoreComments.getComments(\n                        'module',\n                        glossary.coursemodule,\n                        'mod_glossary',\n                        entry.id,\n                        'glossary_entry',\n                        0,\n                        siteId,\n                    ));\n                }\n            });\n\n            const files = this.getFilesFromGlossaryAndEntries(module, glossary, entries);\n            promises.push(CoreFilepool.addFilesToQueue(siteId, files, this.component, module.id));\n\n            // Prefetch user avatars.\n            promises.push(CoreUser.prefetchUserAvatars(entries, 'userpictureurl', siteId));\n\n            return Promise.all(promises);\n        }));\n\n        // Get all categories.\n        promises.push(AddonModGlossary.getAllCategories(glossary.id, options));\n\n        // Prefetch data for link handlers.\n        promises.push(CoreCourse.getModuleBasicInfo(module.id, { siteId }));\n        promises.push(CoreCourse.getModuleBasicInfoByInstance(glossary.id, 'glossary', { siteId }));\n\n        // Get course data, needed to determine upload max size if it's configured to be course limit.\n        promises.push(CoreUtils.ignoreErrors(CoreCourses.getCourseByField('id', courseId, siteId)));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async sync(module: CoreCourseAnyModuleData, courseId: number, siteId?: string): Promise<AddonModGlossarySyncResult> {\n        const results = await Promise.all([\n            AddonModGlossarySync.syncGlossaryEntries(module.instance, undefined, siteId),\n            AddonModGlossarySync.syncRatings(module.id, undefined, siteId),\n        ]);\n\n        return {\n            updated: results[0].updated || results[1].updated,\n            warnings: results[0].warnings.concat(results[1].warnings),\n        };\n    }\n\n}\n\nexport const AddonModGlossaryPrefetchHandler = makeSingleton(AddonModGlossaryPrefetchHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}