{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { EventEmitter, TemplateRef } from '@angular/core';\nimport { CoreDomUtils, VerticalPoint } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreDom } from '@singletons/dom';\nimport { CoreMath } from '@singletons/math';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ionic/angular\";\nimport * as i2 from \"@angular/common\";\nconst _c0 = [\"swiperRef\"];\nconst _c1 = function (a0, a1) {\n  return {\n    item: a0,\n    active: a1\n  };\n};\nfunction CoreSwipeSlidesComponent_swiper_container_0_swiper_slide_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 5);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    const item_r3 = ctx_r6.$implicit;\n    const index_r4 = ctx_r6.index;\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c1, item_r3, ctx_r5.isActive(index_r4)));\n  }\n}\nfunction CoreSwipeSlidesComponent_swiper_container_0_swiper_slide_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"swiper-slide\");\n    i0.ɵɵtemplate(1, CoreSwipeSlidesComponent_swiper_container_0_swiper_slide_2_ng_container_1_Template, 1, 5, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const index_r4 = ctx.index;\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵattribute(\"aria-hidden\", !ctx_r2.isActive(index_r4));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.template);\n  }\n}\nfunction CoreSwipeSlidesComponent_swiper_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"swiper-container\", 1, 2);\n    i0.ɵɵlistener(\"slidechangetransitionstart\", function CoreSwipeSlidesComponent_swiper_container_0_Template_swiper_container_slidechangetransitionstart_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.slideWillChange());\n    })(\"slidechangetransitionend\", function CoreSwipeSlidesComponent_swiper_container_0_Template_swiper_container_slidechangetransitionend_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.slideDidChange());\n    });\n    i0.ɵɵtemplate(2, CoreSwipeSlidesComponent_swiper_container_0_swiper_slide_2_Template, 2, 2, \"swiper-slide\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"initialSlide\", ctx_r0.options.initialSlide)(\"runCallbacksOnInit\", ctx_r0.options.runCallbacksOnInit);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.items);\n  }\n}\n/**\n * Helper component to display swipable slides.\n */\nexport class CoreSwipeSlidesComponent {\n  set swiperRef(swiperRef) {\n    /**\n     * This setTimeout waits for Ionic's async initialization to complete.\n     * Otherwise, an outdated swiper reference will be used.\n     */\n    setTimeout(() => {\n      var _swiperRef$nativeElem;\n      if (swiperRef !== null && swiperRef !== void 0 && (_swiperRef$nativeElem = swiperRef.nativeElement) !== null && _swiperRef$nativeElem !== void 0 && _swiperRef$nativeElem.swiper) {\n        this.swiper = swiperRef.nativeElement.swiper;\n        Object.keys(this.options).forEach(key => {\n          if (this.swiper) {\n            this.swiper.params[key] = this.options[key];\n          }\n        });\n      }\n    }, 0);\n  }\n  constructor(elementRef, content) {\n    this.content = content;\n    this.options = {};\n    this.onWillChange = new EventEmitter();\n    this.onDidChange = new EventEmitter();\n    this.activeSlideIndexes = [];\n    this.hostElement = elementRef.nativeElement;\n    this.resizeListener = CoreDom.onWindowResize(() => {\n      this.updateSlidesComponent();\n    });\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnChanges(changes) {\n    if (!this.unsubscribe && this.manager) {\n      this.initialize(this.manager);\n    }\n    if (changes.options) {\n      Object.keys(this.options).forEach(key => {\n        if (this.swiper) {\n          this.swiper.params[key] = this.options[key];\n        }\n      });\n    }\n  }\n  get items() {\n    var _this$manager;\n    return ((_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.getSource().getItems()) || [];\n  }\n  get loaded() {\n    var _this$manager2;\n    return !!((_this$manager2 = this.manager) !== null && _this$manager2 !== void 0 && _this$manager2.getSource().isLoaded());\n  }\n  /**\n   * Check whether the slide with the given index is active.\n   *\n   * @param index Slide index.\n   * @returns Whether the slide is active.\n   */\n  isActive(index) {\n    return this.activeSlideIndexes.includes(index);\n  }\n  /**\n   * Initialize some properties based on the manager.\n   */\n  initialize(manager) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.unsubscribe = manager.getSource().addListener({\n        onItemsUpdated: () => _this.onItemsUpdated()\n      });\n      // Don't call default callbacks on init, emit our own events instead.\n      // This is because default callbacks aren't triggered for index 0, and to prevent auto scroll on init.\n      _this.options.runCallbacksOnInit = false;\n      yield manager.getSource().waitForLoaded();\n      if (_this.options.initialSlide === undefined) {\n        // Calculate the initial slide.\n        const index = manager.getSource().getInitialItemIndex();\n        _this.options.initialSlide = Math.max(index, 0);\n      }\n      // Emit change events with the initial item.\n      const items = manager.getSource().getItems();\n      if (!items || !items.length) {\n        return;\n      }\n      // Validate that the initial index is inside the valid range.\n      const initialIndex = CoreMath.clamp(_this.options.initialSlide, 0, items.length - 1);\n      const initialItemData = {\n        index: initialIndex,\n        item: items[initialIndex]\n      };\n      _this.activeSlideIndexes = [initialIndex];\n      manager.setSelectedItem(items[initialIndex]);\n      _this.onWillChange.emit(initialItemData);\n      _this.onDidChange.emit(initialItemData);\n    })();\n  }\n  /**\n   * Slide to a certain index.\n   *\n   * @param index Index.\n   * @param speed Animation speed.\n   * @param runCallbacks Whether to run callbacks.\n   */\n  slideToIndex(index, speed, runCallbacks) {\n    var _this$swiper;\n    // If slides are being updated, wait for the update to finish.\n    if (!this.swiper) {\n      return;\n    }\n    // Verify that the number of slides matches the number of items.\n    const slidesLength = this.swiper.slides.length;\n    if (slidesLength !== this.items.length) {\n      // Number doesn't match, do a new update to try to match them.\n      this.updateSlidesComponent();\n    }\n    (_this$swiper = this.swiper) === null || _this$swiper === void 0 || _this$swiper.slideTo(index, speed, runCallbacks);\n  }\n  /**\n   * Slide to a certain item.\n   *\n   * @param item Item.\n   * @param speed Animation speed.\n   * @param runCallbacks Whether to run callbacks.\n   */\n  slideToItem(item, speed, runCallbacks) {\n    var _this$manager$getSour, _this$manager3;\n    const index = (_this$manager$getSour = (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.getSource().getItemIndex(item)) !== null && _this$manager$getSour !== void 0 ? _this$manager$getSour : -1;\n    if (index != -1) {\n      this.slideToIndex(index, speed, runCallbacks);\n    }\n  }\n  /**\n   * Slide to next slide.\n   *\n   * @param speed Animation speed.\n   * @param runCallbacks Whether to run callbacks.\n   */\n  slideNext(speed, runCallbacks) {\n    var _this$swiper2;\n    (_this$swiper2 = this.swiper) === null || _this$swiper2 === void 0 || _this$swiper2.slideNext(speed, runCallbacks);\n  }\n  /**\n   * Slide to previous slide.\n   *\n   * @param speed Animation speed.\n   * @param runCallbacks Whether to run callbacks.\n   */\n  slidePrev(speed, runCallbacks) {\n    var _this$swiper3;\n    (_this$swiper3 = this.swiper) === null || _this$swiper3 === void 0 || _this$swiper3.slidePrev(speed, runCallbacks);\n  }\n  /**\n   * Called when items list has been updated.\n   */\n  onItemsUpdated() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _this2$manager, _this2$manager$getSou;\n      // Wait for slides to be added in DOM.\n      yield CoreUtils.nextTick();\n      // Update the slides component so the slides list reflects the new items.\n      _this2.updateSlidesComponent();\n      const currentItem = (_this2$manager = _this2.manager) === null || _this2$manager === void 0 ? void 0 : _this2$manager.getSelectedItem();\n      if (!currentItem || !_this2.manager) {\n        return;\n      }\n      // Keep the same slide in case the list has changed.\n      const newIndex = (_this2$manager$getSou = _this2.manager.getSource().getItemIndex(currentItem)) !== null && _this2$manager$getSou !== void 0 ? _this2$manager$getSou : -1;\n      if (newIndex != -1) {\n        var _this2$swiper;\n        (_this2$swiper = _this2.swiper) === null || _this2$swiper === void 0 || _this2$swiper.slideTo(newIndex, 0, false);\n      }\n    })();\n  }\n  /**\n   * Slide will change.\n   */\n  slideWillChange() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _this3$manager;\n      const currentItemData = yield _this3.getCurrentSlideItemData();\n      if (!currentItemData) {\n        return;\n      }\n      _this3.activeSlideIndexes.push(currentItemData.index);\n      (_this3$manager = _this3.manager) === null || _this3$manager === void 0 || _this3$manager.setSelectedItem(currentItemData.item);\n      _this3.onWillChange.emit(currentItemData);\n      // Apply scroll on change. In some devices it's too soon to do it, that's why it's done again in DidChange.\n      yield _this3.applyScrollOnChange();\n    })();\n  }\n  /**\n   * Slide did change.\n   */\n  slideDidChange() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const currentItemData = yield _this4.getCurrentSlideItemData();\n      if (!currentItemData) {\n        _this4.activeSlideIndexes = [];\n        return;\n      }\n      _this4.activeSlideIndexes = [currentItemData.index];\n      _this4.onDidChange.emit(currentItemData);\n      yield _this4.applyScrollOnChange();\n    })();\n  }\n  /**\n   * Treat scroll on change.\n   *\n   * @returns Promise resolved when done.\n   */\n  applyScrollOnChange() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var _this5$content;\n      if (_this5.options.scrollOnChange !== 'top') {\n        return;\n      }\n      // Scroll top. This can be improved in the future to keep the scroll for each slide.\n      const scrollElement = yield (_this5$content = _this5.content) === null || _this5$content === void 0 ? void 0 : _this5$content.getScrollElement();\n      if (!scrollElement || CoreDomUtils.isElementOutsideOfScreen(scrollElement, _this5.hostElement, VerticalPoint.TOP)) {\n        // Scroll to top.\n        _this5.hostElement.scrollIntoView({\n          behavior: 'smooth'\n        });\n      }\n    })();\n  }\n  /**\n   * Get current item and index based on current slide.\n   *\n   * @returns Promise resolved with current item data. Null if not found.\n   */\n  getCurrentSlideItemData() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this6.swiper || !_this6.manager) {\n        return null;\n      }\n      const index = _this6.swiper.activeIndex;\n      const items = _this6.manager.getSource().getItems();\n      const currentItem = items && items[index];\n      if (!currentItem) {\n        return null;\n      }\n      return {\n        item: currentItem,\n        index\n      };\n    })();\n  }\n  /**\n   * Update slides component.\n   */\n  updateSlidesComponent() {\n    var _this$swiper4;\n    (_this$swiper4 = this.swiper) === null || _this$swiper4 === void 0 || _this$swiper4.update();\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnDestroy() {\n    this.unsubscribe && this.unsubscribe();\n    this.resizeListener.off();\n  }\n}\n_class = CoreSwipeSlidesComponent;\n_class.ɵfac = function CoreSwipeSlidesComponent_Factory(t) {\n  return new (t || _class)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.IonContent));\n};\n_class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: _class,\n  selectors: [[\"core-swipe-slides\"]],\n  contentQueries: function CoreSwipeSlidesComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n    }\n  },\n  viewQuery: function CoreSwipeSlidesComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.swiperRef = _t.first);\n    }\n  },\n  inputs: {\n    manager: \"manager\",\n    options: \"options\"\n  },\n  outputs: {\n    onWillChange: \"onWillChange\",\n    onDidChange: \"onDidChange\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature],\n  decls: 1,\n  vars: 1,\n  consts: [[3, \"initialSlide\", \"runCallbacksOnInit\", \"slidechangetransitionstart\", \"slidechangetransitionend\", 4, \"ngIf\"], [3, \"initialSlide\", \"runCallbacksOnInit\", \"slidechangetransitionstart\", \"slidechangetransitionend\"], [\"swiperRef\", \"\"], [4, \"ngFor\", \"ngForOf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n  template: function CoreSwipeSlidesComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵtemplate(0, CoreSwipeSlidesComponent_swiper_container_0_Template, 3, 3, \"swiper-container\", 0);\n    }\n    if (rf & 2) {\n      i0.ɵɵproperty(\"ngIf\", ctx.loaded);\n    }\n  },\n  dependencies: [i2.NgForOf, i2.NgIf, i2.NgTemplateOutlet],\n  styles: [\"[_nghost-%COMP%]   swiper-container[_ngcontent-%COMP%] {\\n  height: 100%;\\n}\\n[_nghost-%COMP%]   swiper-container[_ngcontent-%COMP%]   swiper-slide[_ngcontent-%COMP%] {\\n  display: block;\\n  font-size: inherit;\\n  justify-content: start;\\n  align-items: start;\\n  text-align: start;\\n}\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9jb3JlL2NvbXBvbmVudHMvc3dpcGUtc2xpZGVzL3N3aXBlLXNsaWRlcy5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNJO0VBQ0ksWUFBQTtBQUFSO0FBRVE7RUFDSSxjQUFBO0VBQ0Esa0JBQUE7RUFDQSxzQkFBQTtFQUNBLGtCQUFBO0VBQ0EsaUJBQUE7QUFBWiIsInNvdXJjZXNDb250ZW50IjpbIjpob3N0IHtcbiAgICBzd2lwZXItY29udGFpbmVyIHtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgICAgIHN3aXBlci1zbGlkZSB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3RhcnQ7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogc3RhcnQ7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0= */\"]\n});","map":{"version":3,"names":["EventEmitter","TemplateRef","CoreDomUtils","VerticalPoint","CoreUtils","CoreDom","CoreMath","i0","ɵɵelementContainer","ɵɵproperty","ctx_r5","template","ɵɵpureFunction2","_c1","item_r3","isActive","index_r4","ɵɵelementStart","ɵɵtemplate","CoreSwipeSlidesComponent_swiper_container_0_swiper_slide_2_ng_container_1_Template","ɵɵelementEnd","ɵɵattribute","ctx_r2","ɵɵadvance","ɵɵlistener","CoreSwipeSlidesComponent_swiper_container_0_Template_swiper_container_slidechangetransitionstart_0_listener","ɵɵrestoreView","_r8","ctx_r7","ɵɵnextContext","ɵɵresetView","slideWillChange","CoreSwipeSlidesComponent_swiper_container_0_Template_swiper_container_slidechangetransitionend_0_listener","ctx_r9","slideDidChange","CoreSwipeSlidesComponent_swiper_container_0_swiper_slide_2_Template","ctx_r0","options","initialSlide","runCallbacksOnInit","items","CoreSwipeSlidesComponent","swiperRef","setTimeout","_swiperRef$nativeElem","nativeElement","swiper","Object","keys","forEach","key","params","constructor","elementRef","content","onWillChange","onDidChange","activeSlideIndexes","hostElement","resizeListener","onWindowResize","updateSlidesComponent","ngOnChanges","changes","unsubscribe","manager","initialize","_this$manager","getSource","getItems","loaded","_this$manager2","isLoaded","index","includes","_this","_asyncToGenerator","addListener","onItemsUpdated","waitForLoaded","undefined","getInitialItemIndex","Math","max","length","initialIndex","clamp","initialItemData","item","setSelectedItem","emit","slideToIndex","speed","runCallbacks","_this$swiper","slidesLength","slides","slideTo","slideToItem","_this$manager$getSour","_this$manager3","getItemIndex","slideNext","_this$swiper2","slidePrev","_this$swiper3","_this2","_this2$manager","_this2$manager$getSou","nextTick","currentItem","getSelectedItem","newIndex","_this2$swiper","_this3","_this3$manager","currentItemData","getCurrentSlideItemData","push","applyScrollOnChange","_this4","_this5","_this5$content","scrollOnChange","scrollElement","getScrollElement","isElementOutsideOfScreen","TOP","scrollIntoView","behavior","_this6","activeIndex","_this$swiper4","update","ngOnDestroy","off","ɵɵdirectiveInject","ElementRef","i1","IonContent","selectors","contentQueries","CoreSwipeSlidesComponent_ContentQueries","rf","ctx","dirIndex","CoreSwipeSlidesComponent_swiper_container_0_Template"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/components/swipe-slides/swipe-slides.ts","/home/toon/works/gitionic7/ionic-github/ionic/src/core/components/swipe-slides/swipe-slides.html"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n    Component, ContentChild, ElementRef, EventEmitter, Input, OnChanges, OnDestroy, Output, SimpleChange, TemplateRef, ViewChild,\n} from '@angular/core';\nimport { CoreSwipeSlidesItemsManager } from '@classes/items-management/swipe-slides-items-manager';\nimport { IonContent } from '@ionic/angular';\nimport { CoreDomUtils, VerticalPoint } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreDom } from '@singletons/dom';\nimport { CoreEventObserver } from '@singletons/events';\nimport { CoreMath } from '@singletons/math';\nimport { Swiper } from 'swiper';\nimport { SwiperOptions } from 'swiper/types';\n/**\n * Helper component to display swipable slides.\n */\n@Component({\n    selector: 'core-swipe-slides',\n    templateUrl: 'swipe-slides.html',\n    styleUrls: ['swipe-slides.scss'],\n})\nexport class CoreSwipeSlidesComponent<Item = unknown> implements OnChanges, OnDestroy {\n\n    @Input() manager?: CoreSwipeSlidesItemsManager<Item>;\n    @Input() options: CoreSwipeSlidesOptions = {};\n    @Output() onWillChange = new EventEmitter<CoreSwipeCurrentItemData<Item>>();\n    @Output() onDidChange = new EventEmitter<CoreSwipeCurrentItemData<Item>>();\n\n    protected swiper?: Swiper;\n    @ViewChild('swiperRef')\n    set swiperRef(swiperRef: ElementRef) {\n        /**\n         * This setTimeout waits for Ionic's async initialization to complete.\n         * Otherwise, an outdated swiper reference will be used.\n         */\n        setTimeout(() => {\n            if (swiperRef?.nativeElement?.swiper) {\n                this.swiper = swiperRef.nativeElement.swiper as Swiper;\n\n                Object.keys(this.options).forEach((key) => {\n                    if (this.swiper) {\n                        this.swiper.params[key] = this.options[key];\n                    }\n                });\n            }\n        }, 0);\n    }\n\n    @ContentChild(TemplateRef) template?: TemplateRef<unknown>; // Template defined by the content.\n\n    protected hostElement: HTMLElement;\n    protected unsubscribe?: () => void;\n    protected resizeListener: CoreEventObserver;\n    protected activeSlideIndexes: number[] = [];\n\n    constructor(\n        elementRef: ElementRef<HTMLElement>,\n        protected content?: IonContent,\n    ) {\n        this.hostElement = elementRef.nativeElement;\n\n        this.resizeListener = CoreDom.onWindowResize(() => {\n            this.updateSlidesComponent();\n        });\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngOnChanges(changes: { [name: string]: SimpleChange }): void {\n        if (!this.unsubscribe && this.manager) {\n            this.initialize(this.manager);\n        }\n\n        if (changes.options) {\n            Object.keys(this.options).forEach((key) => {\n                if (this.swiper) {\n                    this.swiper.params[key] = this.options[key];\n                }\n            });\n        }\n    }\n\n    get items(): Item[] {\n        return this.manager?.getSource().getItems() || [];\n    }\n\n    get loaded(): boolean {\n        return !!this.manager?.getSource().isLoaded();\n    }\n\n    /**\n     * Check whether the slide with the given index is active.\n     *\n     * @param index Slide index.\n     * @returns Whether the slide is active.\n     */\n    isActive(index: number): boolean {\n        return this.activeSlideIndexes.includes(index);\n    }\n\n    /**\n     * Initialize some properties based on the manager.\n     */\n    protected async initialize(manager: CoreSwipeSlidesItemsManager<Item>): Promise<void> {\n        this.unsubscribe = manager.getSource().addListener({\n            onItemsUpdated: () => this.onItemsUpdated(),\n        });\n\n        // Don't call default callbacks on init, emit our own events instead.\n        // This is because default callbacks aren't triggered for index 0, and to prevent auto scroll on init.\n        this.options.runCallbacksOnInit = false;\n\n        await manager.getSource().waitForLoaded();\n\n        if (this.options.initialSlide === undefined) {\n            // Calculate the initial slide.\n            const index = manager.getSource().getInitialItemIndex();\n            this.options.initialSlide = Math.max(index, 0);\n        }\n\n        // Emit change events with the initial item.\n        const items = manager.getSource().getItems();\n        if (!items || !items.length) {\n            return;\n        }\n\n        // Validate that the initial index is inside the valid range.\n        const initialIndex = CoreMath.clamp(this.options.initialSlide, 0, items.length - 1);\n\n        const initialItemData = {\n            index: initialIndex,\n            item: items[initialIndex],\n        };\n\n        this.activeSlideIndexes = [initialIndex];\n\n        manager.setSelectedItem(items[initialIndex]);\n        this.onWillChange.emit(initialItemData);\n        this.onDidChange.emit(initialItemData);\n    }\n\n    /**\n     * Slide to a certain index.\n     *\n     * @param index Index.\n     * @param speed Animation speed.\n     * @param runCallbacks Whether to run callbacks.\n     */\n    slideToIndex(index: number, speed?: number, runCallbacks?: boolean): void {\n        // If slides are being updated, wait for the update to finish.\n        if (!this.swiper) {\n            return;\n        }\n\n        // Verify that the number of slides matches the number of items.\n        const slidesLength = this.swiper.slides.length;\n        if (slidesLength !== this.items.length) {\n            // Number doesn't match, do a new update to try to match them.\n            this.updateSlidesComponent();\n        }\n\n        this.swiper?.slideTo(index, speed, runCallbacks);\n    }\n\n    /**\n     * Slide to a certain item.\n     *\n     * @param item Item.\n     * @param speed Animation speed.\n     * @param runCallbacks Whether to run callbacks.\n     */\n    slideToItem(item: Item, speed?: number, runCallbacks?: boolean): void {\n        const index = this.manager?.getSource().getItemIndex(item) ?? -1;\n        if (index != -1) {\n            this.slideToIndex(index, speed, runCallbacks);\n        }\n    }\n\n    /**\n     * Slide to next slide.\n     *\n     * @param speed Animation speed.\n     * @param runCallbacks Whether to run callbacks.\n     */\n    slideNext(speed?: number, runCallbacks?: boolean): void {\n        this.swiper?.slideNext(speed, runCallbacks);\n    }\n\n    /**\n     * Slide to previous slide.\n     *\n     * @param speed Animation speed.\n     * @param runCallbacks Whether to run callbacks.\n     */\n    slidePrev(speed?: number, runCallbacks?: boolean): void {\n        this.swiper?.slidePrev(speed, runCallbacks);\n    }\n\n    /**\n     * Called when items list has been updated.\n     */\n    protected async onItemsUpdated(): Promise<void> {\n        // Wait for slides to be added in DOM.\n        await CoreUtils.nextTick();\n\n        // Update the slides component so the slides list reflects the new items.\n        this.updateSlidesComponent();\n\n        const currentItem = this.manager?.getSelectedItem();\n\n        if (!currentItem || !this.manager) {\n            return;\n        }\n\n        // Keep the same slide in case the list has changed.\n        const newIndex = this.manager.getSource().getItemIndex(currentItem) ?? -1;\n        if (newIndex != -1) {\n            this.swiper?.slideTo(newIndex, 0, false);\n        }\n    }\n\n    /**\n     * Slide will change.\n     */\n    async slideWillChange(): Promise<void> {\n        const currentItemData = await this.getCurrentSlideItemData();\n        if (!currentItemData) {\n            return;\n        }\n\n        this.activeSlideIndexes.push(currentItemData.index);\n        this.manager?.setSelectedItem(currentItemData.item);\n\n        this.onWillChange.emit(currentItemData);\n\n        // Apply scroll on change. In some devices it's too soon to do it, that's why it's done again in DidChange.\n        await this.applyScrollOnChange();\n    }\n\n    /**\n     * Slide did change.\n     */\n    async slideDidChange(): Promise<void> {\n        const currentItemData = await this.getCurrentSlideItemData();\n        if (!currentItemData) {\n            this.activeSlideIndexes = [];\n\n            return;\n        }\n\n        this.activeSlideIndexes = [currentItemData.index];\n\n        this.onDidChange.emit(currentItemData);\n\n        await this.applyScrollOnChange();\n    }\n\n    /**\n     * Treat scroll on change.\n     *\n     * @returns Promise resolved when done.\n     */\n    protected async applyScrollOnChange(): Promise<void> {\n        if (this.options.scrollOnChange !== 'top') {\n            return;\n        }\n\n        // Scroll top. This can be improved in the future to keep the scroll for each slide.\n        const scrollElement = await this.content?.getScrollElement();\n\n        if (!scrollElement || CoreDomUtils.isElementOutsideOfScreen(scrollElement, this.hostElement, VerticalPoint.TOP)) {\n            // Scroll to top.\n            this.hostElement.scrollIntoView({ behavior: 'smooth' });\n        }\n    }\n\n    /**\n     * Get current item and index based on current slide.\n     *\n     * @returns Promise resolved with current item data. Null if not found.\n     */\n    protected async getCurrentSlideItemData(): Promise<CoreSwipeCurrentItemData<Item> | null> {\n        if (!this.swiper || !this.manager) {\n            return null;\n        }\n\n        const index = this.swiper.activeIndex;\n        const items = this.manager.getSource().getItems();\n        const currentItem = items && items[index];\n\n        if (!currentItem) {\n            return null;\n        }\n\n        return {\n            item: currentItem,\n            index,\n        };\n    }\n\n    /**\n     * Update slides component.\n     */\n    updateSlidesComponent(): void {\n        this.swiper?.update();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngOnDestroy(): void {\n        this.unsubscribe && this.unsubscribe();\n        this.resizeListener.off();\n    }\n\n}\n\n/**\n * Options to pass to the component.\n *\n * @todo Change unknown with the right type once Swiper library is used.\n */\nexport type CoreSwipeSlidesOptions = SwiperOptions & {\n    scrollOnChange?: 'top' | 'none'; // Scroll behaviour on change slide. By default, none.\n};\n\n/**\n * Data about current item.\n */\nexport type CoreSwipeCurrentItemData<Item> = {\n    index: number;\n    item: Item;\n};\n","<swiper-container #swiperRef *ngIf=\"loaded\" (slidechangetransitionstart)=\"slideWillChange()\" (slidechangetransitionend)=\"slideDidChange()\"\n    [initialSlide]=\"options.initialSlide\" [runCallbacksOnInit]=\"options.runCallbacksOnInit\">\n    <swiper-slide *ngFor=\"let item of items; index as index\" [attr.aria-hidden]=\"!isActive(index)\">\n        <ng-container *ngIf=\"template\" [ngTemplateOutlet]=\"template\" [ngTemplateOutletContext]=\"{item: item, active: isActive(index)}\" />\n    </swiper-slide>\n</swiper-container>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}