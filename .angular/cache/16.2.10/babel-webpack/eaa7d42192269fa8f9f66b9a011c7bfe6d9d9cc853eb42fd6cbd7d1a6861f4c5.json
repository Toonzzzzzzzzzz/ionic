{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _class;\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModLesson, AddonModLessonProvider } from './lesson';\nimport { CoreTime } from '@singletons/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/forms\";\n/**\n * Helper service that provides some features for quiz.\n */\nexport class AddonModLessonHelperProvider {\n  constructor(formBuilder) {\n    this.formBuilder = formBuilder;\n  }\n  /**\n   * Given the HTML of next activity link, format it to extract the href and the text.\n   *\n   * @param activityLink HTML of the activity link.\n   * @returns Formatted data.\n   */\n  formatActivityLink(activityLink) {\n    const element = CoreDomUtils.convertToElement(activityLink);\n    const anchor = element.querySelector('a');\n    if (!anchor) {\n      // Anchor not found, return the original HTML.\n      return {\n        formatted: false,\n        label: activityLink,\n        href: ''\n      };\n    }\n    return {\n      formatted: true,\n      label: anchor.innerHTML,\n      href: anchor.href\n    };\n  }\n  /**\n   * Given the HTML of an answer from a content page, extract the data to render the answer.\n   *\n   * @param html Answer's HTML.\n   * @returns Data to render the answer.\n   */\n  getContentPageAnswerDataFromHtml(html) {\n    const data = {\n      buttonText: '',\n      content: ''\n    };\n    const element = CoreDomUtils.convertToElement(html);\n    // Search the input button.\n    const button = element.querySelector('input[type=\"button\"]');\n    if (button) {\n      // Extract the button content and remove it from the HTML.\n      data.buttonText = button.value;\n      button.remove();\n    }\n    data.content = element.innerHTML.trim();\n    return data;\n  }\n  /**\n   * Get the buttons to change pages.\n   *\n   * @param html Page's HTML.\n   * @returns List of buttons.\n   */\n  getPageButtonsFromHtml(html) {\n    const buttons = [];\n    const element = CoreDomUtils.convertToElement(html);\n    // Get the container of the buttons if it exists.\n    let buttonsContainer = element.querySelector('.branchbuttoncontainer');\n    if (!buttonsContainer) {\n      // Button container not found, might be a legacy lesson (from 1.9).\n      if (!element.querySelector('form input[type=\"submit\"]')) {\n        // No buttons found.\n        return buttons;\n      }\n      buttonsContainer = element;\n    }\n    const forms = Array.from(buttonsContainer.querySelectorAll('form'));\n    forms.forEach(form => {\n      const buttonSelector = 'input[type=\"submit\"], button[type=\"submit\"]';\n      const buttonEl = form.querySelector(buttonSelector);\n      const inputs = Array.from(form.querySelectorAll('input'));\n      if (!buttonEl || !inputs || !inputs.length) {\n        // Button not found or no inputs, ignore it.\n        return;\n      }\n      const button = {\n        id: buttonEl.id,\n        title: buttonEl.title || buttonEl.value,\n        content: buttonEl.tagName == 'INPUT' ? buttonEl.value : buttonEl.innerHTML.trim(),\n        data: {}\n      };\n      inputs.forEach(input => {\n        if (input.type != 'submit') {\n          button.data[input.name] = input.value;\n        }\n      });\n      buttons.push(button);\n    });\n    return buttons;\n  }\n  /**\n   * Given a page data, get the page contents.\n   *\n   * @param data Page data.\n   * @returns Page contents.\n   */\n  getPageContentsFromPageData(data) {\n    var _data$page, _data$page2;\n    // Search the page contents inside the whole page HTML. Use data.pagecontent because it's filtered.\n    const element = CoreDomUtils.convertToElement(data.pagecontent || '');\n    const contents = element.querySelector('.contents');\n    if (contents) {\n      return contents.innerHTML.trim();\n    }\n    // Cannot find contents element.\n    if (AddonModLesson.isQuestionPage(((_data$page = data.page) === null || _data$page === void 0 ? void 0 : _data$page.type) || -1) || ((_data$page2 = data.page) === null || _data$page2 === void 0 ? void 0 : _data$page2.qtype) == AddonModLessonProvider.LESSON_PAGE_BRANCHTABLE) {\n      var _data$page3;\n      // Return page.contents to prevent having duplicated elements (some elements like videos might not work).\n      return ((_data$page3 = data.page) === null || _data$page3 === void 0 ? void 0 : _data$page3.contents) || '';\n    } else {\n      // It's an end of cluster, end of branch, etc. Return the whole pagecontent to match what's displayed in web.\n      return data.pagecontent || '';\n    }\n  }\n  /**\n   * Get a question and all the data required to render it from the page data.\n   *\n   * @param questionForm The form group where to add the controls.\n   * @param pageData Page data.\n   * @returns Question data.\n   */\n  getQuestionFromPageData(questionForm, pageData) {\n    var _pageData$page;\n    const element = CoreDomUtils.convertToElement(pageData.pagecontent || '');\n    // Get the container of the question answers if it exists.\n    const fieldContainer = element.querySelector('.fcontainer');\n    // Get hidden inputs and add their data to the form group.\n    const hiddenInputs = Array.from(element.querySelectorAll('input[type=\"hidden\"]'));\n    hiddenInputs.forEach(input => {\n      questionForm.addControl(input.name, this.formBuilder.control(input.value));\n    });\n    // Get the submit button and extract its value.\n    const submitButton = element.querySelector('input[type=\"submit\"]');\n    const question = {\n      template: '',\n      submitLabel: submitButton ? submitButton.value : Translate.instant('addon.mod_lesson.submit')\n    };\n    if (!fieldContainer) {\n      // Element not found, return.\n      return question;\n    }\n    switch ((_pageData$page = pageData.page) === null || _pageData$page === void 0 ? void 0 : _pageData$page.qtype) {\n      case AddonModLessonProvider.LESSON_PAGE_TRUEFALSE:\n      case AddonModLessonProvider.LESSON_PAGE_MULTICHOICE:\n        return this.getMultiChoiceQuestionData(questionForm, question, fieldContainer);\n      case AddonModLessonProvider.LESSON_PAGE_NUMERICAL:\n      case AddonModLessonProvider.LESSON_PAGE_SHORTANSWER:\n        return this.getInputQuestionData(questionForm, question, fieldContainer, pageData.page.qtype);\n      case AddonModLessonProvider.LESSON_PAGE_ESSAY:\n        {\n          return this.getEssayQuestionData(questionForm, question, fieldContainer);\n        }\n      case AddonModLessonProvider.LESSON_PAGE_MATCHING:\n        {\n          return this.getMatchingQuestionData(questionForm, question, fieldContainer);\n        }\n    }\n    return question;\n  }\n  /**\n   * Get a multichoice question data.\n   *\n   * @param questionForm The form group where to add the controls.\n   * @param question Basic question data.\n   * @param fieldContainer HTMLElement containing the data.\n   * @returns Question data.\n   */\n  getMultiChoiceQuestionData(questionForm, question, fieldContainer) {\n    const multiChoiceQuestion = _objectSpread(_objectSpread({}, question), {}, {\n      template: 'multichoice',\n      options: [],\n      multi: false\n    });\n    // Get all the inputs. Search radio first.\n    let inputs = Array.from(fieldContainer.querySelectorAll('input[type=\"radio\"]'));\n    if (!inputs || !inputs.length) {\n      // Radio buttons not found, it might be a multi answer. Search for checkbox.\n      multiChoiceQuestion.multi = true;\n      inputs = Array.from(fieldContainer.querySelectorAll('input[type=\"checkbox\"]'));\n      if (!inputs || !inputs.length) {\n        // No checkbox found either. Stop.\n        return multiChoiceQuestion;\n      }\n    }\n    let controlAdded = false;\n    inputs.forEach(input => {\n      const parent = input.parentElement;\n      const option = {\n        id: input.id,\n        name: input.name,\n        value: input.value,\n        checked: !!input.checked,\n        disabled: !!input.disabled,\n        text: ''\n      };\n      if (option.checked || multiChoiceQuestion.multi) {\n        // Add the control.\n        const value = multiChoiceQuestion.multi ? {\n          value: option.checked,\n          disabled: option.disabled\n        } : option.checked;\n        questionForm.addControl(option.name, this.formBuilder.control(value));\n        controlAdded = true;\n      }\n      // Remove the input and use the rest of the parent contents as the label.\n      input.remove();\n      option.text = (parent === null || parent === void 0 ? void 0 : parent.innerHTML.trim()) || '';\n      multiChoiceQuestion.options.push(option);\n    });\n    if (!multiChoiceQuestion.multi) {\n      multiChoiceQuestion.controlName = inputs[0].name;\n      if (!controlAdded) {\n        // No checked option for single choice, add the control with an empty value.\n        questionForm.addControl(multiChoiceQuestion.controlName, this.formBuilder.control(''));\n      }\n    }\n    return multiChoiceQuestion;\n  }\n  /**\n   * Get an input question data.\n   *\n   * @param questionForm The form group where to add the controls.\n   * @param question Basic question data.\n   * @param fieldContainer HTMLElement containing the data.\n   * @param questionType Type of the question.\n   * @returns Question data.\n   */\n  getInputQuestionData(questionForm, question, fieldContainer, questionType) {\n    const inputQuestion = question;\n    inputQuestion.template = 'shortanswer';\n    // Get the input.\n    const input = fieldContainer.querySelector('input[type=\"text\"], input[type=\"number\"]');\n    if (!input) {\n      return inputQuestion;\n    }\n    inputQuestion.input = {\n      id: input.id,\n      name: input.name,\n      maxlength: input.maxLength,\n      type: 'text' // Use text for numerical questions too to allow different decimal separators.\n    };\n    // Init the control.\n    questionForm.addControl(input.name, this.formBuilder.control({\n      value: questionType === AddonModLessonProvider.LESSON_PAGE_NUMERICAL ? CoreUtils.formatFloat(input.value) : input.value,\n      disabled: input.readOnly\n    }));\n    return inputQuestion;\n  }\n  /**\n   * Get an essay question data.\n   *\n   * @param questionForm The form group where to add the controls.\n   * @param question Basic question data.\n   * @param fieldContainer HTMLElement containing the data.\n   * @returns Question data.\n   */\n  getEssayQuestionData(questionForm, question, fieldContainer) {\n    const essayQuestion = question;\n    essayQuestion.template = 'essay';\n    // Get the textarea.\n    const textarea = fieldContainer.querySelector('textarea');\n    if (!textarea) {\n      // Textarea not found, probably review mode.\n      const answerEl = fieldContainer.querySelector('.reviewessay');\n      if (!answerEl) {\n        // Answer not found, stop.\n        return essayQuestion;\n      }\n      essayQuestion.useranswer = answerEl.innerHTML;\n    } else {\n      essayQuestion.textarea = {\n        id: textarea.id,\n        name: textarea.name || 'answer[text]'\n      };\n      // Init the control.\n      essayQuestion.control = this.formBuilder.control('');\n      questionForm.addControl(essayQuestion.textarea.name, essayQuestion.control);\n    }\n    return essayQuestion;\n  }\n  /**\n   * Get a matching question data.\n   *\n   * @param questionForm The form group where to add the controls.\n   * @param question Basic question data.\n   * @param fieldContainer HTMLElement containing the data.\n   * @returns Question data.\n   */\n  getMatchingQuestionData(questionForm, question, fieldContainer) {\n    const matchingQuestion = _objectSpread(_objectSpread({}, question), {}, {\n      template: 'matching',\n      rows: []\n    });\n    const rows = Array.from(fieldContainer.querySelectorAll('.answeroption'));\n    rows.forEach(row => {\n      const label = row.querySelector('label');\n      const select = row.querySelector('select');\n      const options = Array.from(row.querySelectorAll('option'));\n      if (!label || !select || !options || !options.length) {\n        return;\n      }\n      // Get the row's text (label).\n      const rowData = {\n        text: label.innerHTML.trim(),\n        id: select.id,\n        name: select.name,\n        options: []\n      };\n      // Treat each option.\n      let controlAdded = false;\n      options.forEach(option => {\n        if (option.value === undefined) {\n          // Option not valid, ignore it.\n          return;\n        }\n        const optionData = {\n          value: option.value,\n          label: option.innerHTML.trim(),\n          selected: option.selected\n        };\n        if (optionData.selected) {\n          controlAdded = true;\n          questionForm.addControl(rowData.name, this.formBuilder.control({\n            value: optionData.value,\n            disabled: !!select.disabled\n          }));\n        }\n        rowData.options.push(optionData);\n      });\n      if (!controlAdded) {\n        // No selected option, add the control with an empty value.\n        questionForm.addControl(rowData.name, this.formBuilder.control({\n          value: '',\n          disabled: !!select.disabled\n        }));\n      }\n      matchingQuestion.rows.push(rowData);\n    });\n    return matchingQuestion;\n  }\n  /**\n   * Given the HTML of an answer from a question page, extract the data to render the answer.\n   *\n   * @param html Answer's HTML.\n   * @returns Object with the data to render the answer. If the answer doesn't require any parsing, return a string with the HTML.\n   */\n  getQuestionPageAnswerDataFromHtml(html) {\n    const element = CoreDomUtils.convertToElement(html);\n    // Check if it has a checkbox.\n    let input = element.querySelector('input[type=\"checkbox\"][name*=\"answer\"]');\n    if (input) {\n      // Truefalse or multichoice.\n      const successBadge = element.querySelector('.badge.badge-success');\n      const data = {\n        isCheckbox: true,\n        checked: !!input.checked,\n        name: input.name,\n        highlight: !!element.querySelector('.highlight'),\n        content: '',\n        successBadge: successBadge === null || successBadge === void 0 ? void 0 : successBadge.innerText\n      };\n      input.remove();\n      successBadge === null || successBadge === void 0 || successBadge.remove();\n      data.content = element.innerHTML.trim();\n      return data;\n    }\n    // Check if it has an input text or number.\n    input = element.querySelector('input[type=\"number\"],input[type=\"text\"]');\n    if (input) {\n      // Short answer or numeric.\n      return {\n        isText: true,\n        value: input.value\n      };\n    }\n    // Check if it has a select.\n    const select = element.querySelector('select');\n    if (select !== null && select !== void 0 && select.options) {\n      // Matching.\n      const selectedOption = select.options[select.selectedIndex];\n      const data = {\n        isSelect: true,\n        id: select.id,\n        value: selectedOption ? selectedOption.value : '',\n        content: ''\n      };\n      select.remove();\n      data.content = element.innerHTML.trim();\n      return data;\n    }\n    // The answer doesn't need any parsing, return the HTML as it is.\n    return html;\n  }\n  /**\n   * Get a label to identify a retake (lesson attempt).\n   *\n   * @param retake Retake object.\n   * @param includeDuration Whether to include the duration of the retake.\n   * @returns Retake label.\n   */\n  getRetakeLabel(retake, includeDuration) {\n    const data = {\n      retake: retake.try + 1,\n      grade: '',\n      timestart: '',\n      duration: ''\n    };\n    const hasGrade = retake.grade != null;\n    if (hasGrade || retake.end) {\n      // Retake finished with or without grade (if the lesson only has content pages, it has no grade).\n      if (hasGrade) {\n        data.grade = Translate.instant('core.percentagenumber', {\n          $a: retake.grade\n        });\n      }\n      data.timestart = CoreTimeUtils.userDate(retake.timestart * 1000);\n      if (includeDuration) {\n        data.duration = CoreTime.formatTime(retake.timeend - retake.timestart);\n      }\n    } else {\n      // The user has not completed the retake.\n      data.grade = Translate.instant('addon.mod_lesson.notcompleted');\n      if (retake.timestart) {\n        data.timestart = CoreTimeUtils.userDate(retake.timestart * 1000);\n      }\n    }\n    return Translate.instant('addon.mod_lesson.retakelabel' + (includeDuration ? 'full' : 'short'), data);\n  }\n  /**\n   * Prepare the question data to be sent to server.\n   *\n   * @param question Question to prepare.\n   * @param data Data to prepare.\n   * @returns Data to send.\n   */\n  prepareQuestionData(question, data) {\n    if (question.template == 'essay') {\n      const textarea = question.textarea;\n      // Add some HTML to the answer if needed.\n      if (textarea) {\n        data[textarea.name] = CoreTextUtils.formatHtmlLines(data[textarea.name] || '');\n      }\n    } else if (question.template == 'multichoice' && question.multi) {\n      // Only send the options with value set to true.\n      for (const name in data) {\n        if (name.match(/answer\\[\\d+\\]/) && data[name] == false) {\n          delete data[name];\n        }\n      }\n    }\n    return data;\n  }\n  /**\n   * Given the feedback of a process page in HTML, remove the question text.\n   *\n   * @param html Feedback's HTML.\n   * @returns Feedback without the question text.\n   */\n  removeQuestionFromFeedback(html) {\n    const element = CoreDomUtils.convertToElement(html);\n    // Remove the question text.\n    CoreDomUtils.removeElement(element, '.generalbox:not(.feedback):not(.correctanswer)');\n    return element.innerHTML.trim();\n  }\n}\n_class = AddonModLessonHelperProvider;\n_class.ɵfac = function AddonModLessonHelperProvider_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.FormBuilder));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModLessonHelper = makeSingleton(AddonModLessonHelperProvider);","map":{"version":3,"names":["CoreDomUtils","CoreTextUtils","CoreTimeUtils","makeSingleton","Translate","AddonModLesson","AddonModLessonProvider","CoreTime","CoreUtils","AddonModLessonHelperProvider","constructor","formBuilder","formatActivityLink","activityLink","element","convertToElement","anchor","querySelector","formatted","label","href","innerHTML","getContentPageAnswerDataFromHtml","html","data","buttonText","content","button","value","remove","trim","getPageButtonsFromHtml","buttons","buttonsContainer","forms","Array","from","querySelectorAll","forEach","form","buttonSelector","buttonEl","inputs","length","id","title","tagName","input","type","name","push","getPageContentsFromPageData","_data$page","_data$page2","pagecontent","contents","isQuestionPage","page","qtype","LESSON_PAGE_BRANCHTABLE","_data$page3","getQuestionFromPageData","questionForm","pageData","_pageData$page","fieldContainer","hiddenInputs","addControl","control","submitButton","question","template","submitLabel","instant","LESSON_PAGE_TRUEFALSE","LESSON_PAGE_MULTICHOICE","getMultiChoiceQuestionData","LESSON_PAGE_NUMERICAL","LESSON_PAGE_SHORTANSWER","getInputQuestionData","LESSON_PAGE_ESSAY","getEssayQuestionData","LESSON_PAGE_MATCHING","getMatchingQuestionData","multiChoiceQuestion","_objectSpread","options","multi","controlAdded","parent","parentElement","option","checked","disabled","text","controlName","questionType","inputQuestion","maxlength","maxLength","formatFloat","readOnly","essayQuestion","textarea","answerEl","useranswer","matchingQuestion","rows","row","select","rowData","undefined","optionData","selected","getQuestionPageAnswerDataFromHtml","successBadge","isCheckbox","highlight","innerText","isText","selectedOption","selectedIndex","isSelect","getRetakeLabel","retake","includeDuration","try","grade","timestart","duration","hasGrade","end","$a","userDate","formatTime","timeend","prepareQuestionData","formatHtmlLines","match","removeQuestionFromFeedback","removeElement","i0","ɵɵinject","i1","FormBuilder","factory","ɵfac","providedIn","AddonModLessonHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/lesson/services/lesson-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { FormBuilder, FormControl, FormGroup } from '@angular/forms';\n\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreFormFields } from '@singletons/form';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { makeSingleton, Translate } from '@singletons';\nimport {\n    AddonModLesson,\n    AddonModLessonAttemptsOverviewsAttemptWSData,\n    AddonModLessonGetPageDataWSResponse,\n    AddonModLessonProvider,\n} from './lesson';\nimport { CoreTime } from '@singletons/time';\nimport { CoreUtils } from '@services/utils/utils';\n\n/**\n * Helper service that provides some features for quiz.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModLessonHelperProvider {\n\n    constructor(\n        protected formBuilder: FormBuilder,\n    ) {}\n\n    /**\n     * Given the HTML of next activity link, format it to extract the href and the text.\n     *\n     * @param activityLink HTML of the activity link.\n     * @returns Formatted data.\n     */\n    formatActivityLink(activityLink: string): AddonModLessonActivityLink {\n        const element = CoreDomUtils.convertToElement(activityLink);\n        const anchor = element.querySelector('a');\n\n        if (!anchor) {\n            // Anchor not found, return the original HTML.\n            return {\n                formatted: false,\n                label: activityLink,\n                href: '',\n            };\n        }\n\n        return {\n            formatted: true,\n            label: anchor.innerHTML,\n            href: anchor.href,\n        };\n    }\n\n    /**\n     * Given the HTML of an answer from a content page, extract the data to render the answer.\n     *\n     * @param html Answer's HTML.\n     * @returns Data to render the answer.\n     */\n    getContentPageAnswerDataFromHtml(html: string): {buttonText: string; content: string} {\n        const data = {\n            buttonText: '',\n            content: '',\n        };\n        const element = CoreDomUtils.convertToElement(html);\n\n        // Search the input button.\n        const button = <HTMLInputElement> element.querySelector('input[type=\"button\"]');\n\n        if (button) {\n            // Extract the button content and remove it from the HTML.\n            data.buttonText = button.value;\n            button.remove();\n        }\n\n        data.content = element.innerHTML.trim();\n\n        return data;\n    }\n\n    /**\n     * Get the buttons to change pages.\n     *\n     * @param html Page's HTML.\n     * @returns List of buttons.\n     */\n    getPageButtonsFromHtml(html: string): AddonModLessonPageButton[] {\n        const buttons: AddonModLessonPageButton[] = [];\n        const element = CoreDomUtils.convertToElement(html);\n\n        // Get the container of the buttons if it exists.\n        let buttonsContainer = element.querySelector('.branchbuttoncontainer');\n\n        if (!buttonsContainer) {\n            // Button container not found, might be a legacy lesson (from 1.9).\n            if (!element.querySelector('form input[type=\"submit\"]')) {\n                // No buttons found.\n                return buttons;\n            }\n            buttonsContainer = element;\n        }\n\n        const forms = Array.from(buttonsContainer.querySelectorAll('form'));\n        forms.forEach((form) => {\n            const buttonSelector = 'input[type=\"submit\"], button[type=\"submit\"]';\n            const buttonEl = <HTMLInputElement | HTMLButtonElement> form.querySelector(buttonSelector);\n            const inputs = Array.from(form.querySelectorAll('input'));\n\n            if (!buttonEl || !inputs || !inputs.length) {\n                // Button not found or no inputs, ignore it.\n                return;\n            }\n\n            const button: AddonModLessonPageButton = {\n                id: buttonEl.id,\n                title: buttonEl.title || buttonEl.value,\n                content: buttonEl.tagName == 'INPUT' ? buttonEl.value : buttonEl.innerHTML.trim(),\n                data: {},\n            };\n\n            inputs.forEach((input) => {\n                if (input.type != 'submit') {\n                    button.data[input.name] = input.value;\n                }\n            });\n\n            buttons.push(button);\n        });\n\n        return buttons;\n    }\n\n    /**\n     * Given a page data, get the page contents.\n     *\n     * @param data Page data.\n     * @returns Page contents.\n     */\n    getPageContentsFromPageData(data: AddonModLessonGetPageDataWSResponse): string {\n        // Search the page contents inside the whole page HTML. Use data.pagecontent because it's filtered.\n        const element = CoreDomUtils.convertToElement(data.pagecontent || '');\n        const contents = element.querySelector('.contents');\n\n        if (contents) {\n            return contents.innerHTML.trim();\n        }\n\n        // Cannot find contents element.\n        if (AddonModLesson.isQuestionPage(data.page?.type || -1) ||\n                data.page?.qtype == AddonModLessonProvider.LESSON_PAGE_BRANCHTABLE) {\n            // Return page.contents to prevent having duplicated elements (some elements like videos might not work).\n            return data.page?.contents || '';\n        } else {\n            // It's an end of cluster, end of branch, etc. Return the whole pagecontent to match what's displayed in web.\n            return data.pagecontent || '';\n        }\n    }\n\n    /**\n     * Get a question and all the data required to render it from the page data.\n     *\n     * @param questionForm The form group where to add the controls.\n     * @param pageData Page data.\n     * @returns Question data.\n     */\n    getQuestionFromPageData(questionForm: FormGroup, pageData: AddonModLessonGetPageDataWSResponse): AddonModLessonQuestion {\n        const element = CoreDomUtils.convertToElement(pageData.pagecontent || '');\n\n        // Get the container of the question answers if it exists.\n        const fieldContainer = <HTMLElement> element.querySelector('.fcontainer');\n\n        // Get hidden inputs and add their data to the form group.\n        const hiddenInputs = <HTMLInputElement[]> Array.from(element.querySelectorAll('input[type=\"hidden\"]'));\n        hiddenInputs.forEach((input) => {\n            questionForm.addControl(input.name, this.formBuilder.control(input.value));\n        });\n\n        // Get the submit button and extract its value.\n        const submitButton = <HTMLInputElement> element.querySelector('input[type=\"submit\"]');\n        const question: AddonModLessonQuestion = {\n            template: '',\n            submitLabel: submitButton ? submitButton.value : Translate.instant('addon.mod_lesson.submit'),\n        };\n\n        if (!fieldContainer) {\n            // Element not found, return.\n            return question;\n        }\n\n        switch (pageData.page?.qtype) {\n            case AddonModLessonProvider.LESSON_PAGE_TRUEFALSE:\n            case AddonModLessonProvider.LESSON_PAGE_MULTICHOICE:\n                return this.getMultiChoiceQuestionData(questionForm, question, fieldContainer);\n\n            case AddonModLessonProvider.LESSON_PAGE_NUMERICAL:\n            case AddonModLessonProvider.LESSON_PAGE_SHORTANSWER:\n                return this.getInputQuestionData(questionForm, question, fieldContainer, pageData.page.qtype);\n\n            case AddonModLessonProvider.LESSON_PAGE_ESSAY: {\n                return this.getEssayQuestionData(questionForm, question, fieldContainer);\n            }\n\n            case AddonModLessonProvider.LESSON_PAGE_MATCHING: {\n                return this.getMatchingQuestionData(questionForm, question, fieldContainer);\n            }\n        }\n\n        return question;\n    }\n\n    /**\n     * Get a multichoice question data.\n     *\n     * @param questionForm The form group where to add the controls.\n     * @param question Basic question data.\n     * @param fieldContainer HTMLElement containing the data.\n     * @returns Question data.\n     */\n    protected getMultiChoiceQuestionData(\n        questionForm: FormGroup,\n        question: AddonModLessonQuestion,\n        fieldContainer: HTMLElement,\n    ): AddonModLessonMultichoiceQuestion {\n        const multiChoiceQuestion = <AddonModLessonMultichoiceQuestion> {\n            ...question,\n            template: 'multichoice',\n            options: [],\n            multi: false,\n        };\n\n        // Get all the inputs. Search radio first.\n        let inputs = <HTMLInputElement[]> Array.from(fieldContainer.querySelectorAll('input[type=\"radio\"]'));\n        if (!inputs || !inputs.length) {\n            // Radio buttons not found, it might be a multi answer. Search for checkbox.\n            multiChoiceQuestion.multi = true;\n            inputs = <HTMLInputElement[]> Array.from(fieldContainer.querySelectorAll('input[type=\"checkbox\"]'));\n\n            if (!inputs || !inputs.length) {\n                // No checkbox found either. Stop.\n                return multiChoiceQuestion;\n            }\n        }\n\n        let controlAdded = false;\n        inputs.forEach((input) => {\n            const parent = input.parentElement;\n            const option: AddonModLessonMultichoiceOption = {\n                id: input.id,\n                name: input.name,\n                value: input.value,\n                checked: !!input.checked,\n                disabled: !!input.disabled,\n                text: '',\n            };\n\n            if (option.checked || multiChoiceQuestion.multi) {\n                // Add the control.\n                const value = multiChoiceQuestion.multi ?\n                    { value: option.checked, disabled: option.disabled } : option.checked;\n                questionForm.addControl(option.name, this.formBuilder.control(value));\n                controlAdded = true;\n            }\n\n            // Remove the input and use the rest of the parent contents as the label.\n            input.remove();\n            option.text = parent?.innerHTML.trim() || '';\n            multiChoiceQuestion.options!.push(option);\n        });\n\n        if (!multiChoiceQuestion.multi) {\n            multiChoiceQuestion.controlName = inputs[0].name;\n\n            if (!controlAdded) {\n                // No checked option for single choice, add the control with an empty value.\n                questionForm.addControl(multiChoiceQuestion.controlName, this.formBuilder.control(''));\n            }\n        }\n\n        return multiChoiceQuestion;\n    }\n\n    /**\n     * Get an input question data.\n     *\n     * @param questionForm The form group where to add the controls.\n     * @param question Basic question data.\n     * @param fieldContainer HTMLElement containing the data.\n     * @param questionType Type of the question.\n     * @returns Question data.\n     */\n    protected getInputQuestionData(\n        questionForm: FormGroup,\n        question: AddonModLessonQuestion,\n        fieldContainer: HTMLElement,\n        questionType: number,\n    ): AddonModLessonInputQuestion {\n\n        const inputQuestion = <AddonModLessonInputQuestion> question;\n        inputQuestion.template = 'shortanswer';\n\n        // Get the input.\n        const input = fieldContainer.querySelector<HTMLInputElement>('input[type=\"text\"], input[type=\"number\"]');\n        if (!input) {\n            return inputQuestion;\n        }\n\n        inputQuestion.input = {\n            id: input.id,\n            name: input.name,\n            maxlength: input.maxLength,\n            type: 'text', // Use text for numerical questions too to allow different decimal separators.\n        };\n\n        // Init the control.\n        questionForm.addControl(input.name, this.formBuilder.control({\n            value: questionType === AddonModLessonProvider.LESSON_PAGE_NUMERICAL ? CoreUtils.formatFloat(input.value) : input.value,\n            disabled: input.readOnly,\n        }));\n\n        return inputQuestion;\n    }\n\n    /**\n     * Get an essay question data.\n     *\n     * @param questionForm The form group where to add the controls.\n     * @param question Basic question data.\n     * @param fieldContainer HTMLElement containing the data.\n     * @returns Question data.\n     */\n    protected getEssayQuestionData(\n        questionForm: FormGroup,\n        question: AddonModLessonQuestion,\n        fieldContainer: HTMLElement,\n    ): AddonModLessonEssayQuestion {\n        const essayQuestion = <AddonModLessonEssayQuestion> question;\n        essayQuestion.template = 'essay';\n\n        // Get the textarea.\n        const textarea = fieldContainer.querySelector('textarea');\n\n        if (!textarea) {\n            // Textarea not found, probably review mode.\n            const answerEl = fieldContainer.querySelector('.reviewessay');\n            if (!answerEl) {\n                // Answer not found, stop.\n                return essayQuestion;\n            }\n            essayQuestion.useranswer = answerEl.innerHTML;\n\n        } else {\n            essayQuestion.textarea = {\n                id: textarea.id,\n                name: textarea.name || 'answer[text]',\n            };\n\n            // Init the control.\n            essayQuestion.control = this.formBuilder.control('');\n            questionForm.addControl(essayQuestion.textarea.name, essayQuestion.control);\n        }\n\n        return essayQuestion;\n    }\n\n    /**\n     * Get a matching question data.\n     *\n     * @param questionForm The form group where to add the controls.\n     * @param question Basic question data.\n     * @param fieldContainer HTMLElement containing the data.\n     * @returns Question data.\n     */\n    protected getMatchingQuestionData(\n        questionForm: FormGroup,\n        question: AddonModLessonQuestion,\n        fieldContainer: HTMLElement,\n    ): AddonModLessonMatchingQuestion {\n\n        const matchingQuestion = <AddonModLessonMatchingQuestion> {\n            ...question,\n            template: 'matching',\n            rows: [],\n        };\n\n        const rows = Array.from(fieldContainer.querySelectorAll('.answeroption'));\n\n        rows.forEach((row) => {\n            const label = row.querySelector('label');\n            const select = row.querySelector('select');\n            const options = Array.from(row.querySelectorAll('option'));\n\n            if (!label || !select || !options || !options.length) {\n                return;\n            }\n\n            // Get the row's text (label).\n            const rowData: AddonModLessonMatchingRow = {\n                text: label.innerHTML.trim(),\n                id: select.id,\n                name: select.name,\n                options: [],\n            };\n\n            // Treat each option.\n            let controlAdded = false;\n            options.forEach((option) => {\n                if (option.value === undefined) {\n                    // Option not valid, ignore it.\n                    return;\n                }\n\n                const optionData: AddonModLessonMatchingRowOption = {\n                    value: option.value,\n                    label: option.innerHTML.trim(),\n                    selected: option.selected,\n                };\n\n                if (optionData.selected) {\n                    controlAdded = true;\n                    questionForm.addControl(\n                        rowData.name,\n                        this.formBuilder.control({ value: optionData.value, disabled: !!select.disabled }),\n                    );\n                }\n\n                rowData.options.push(optionData);\n            });\n\n            if (!controlAdded) {\n                // No selected option, add the control with an empty value.\n                questionForm.addControl(rowData.name, this.formBuilder.control({ value: '', disabled: !!select.disabled }));\n            }\n\n            matchingQuestion.rows.push(rowData);\n        });\n\n        return matchingQuestion;\n    }\n\n    /**\n     * Given the HTML of an answer from a question page, extract the data to render the answer.\n     *\n     * @param html Answer's HTML.\n     * @returns Object with the data to render the answer. If the answer doesn't require any parsing, return a string with the HTML.\n     */\n    getQuestionPageAnswerDataFromHtml(html: string): AddonModLessonAnswerData {\n        const element = CoreDomUtils.convertToElement(html);\n\n        // Check if it has a checkbox.\n        let input = element.querySelector<HTMLInputElement>('input[type=\"checkbox\"][name*=\"answer\"]');\n        if (input) {\n            // Truefalse or multichoice.\n            const successBadge = element.querySelector<HTMLElement>('.badge.badge-success');\n            const data: AddonModLessonCheckboxAnswerData = {\n                isCheckbox: true,\n                checked: !!input.checked,\n                name: input.name,\n                highlight: !!element.querySelector('.highlight'),\n                content: '',\n                successBadge: successBadge?.innerText,\n            };\n\n            input.remove();\n            successBadge?.remove();\n            data.content = element.innerHTML.trim();\n\n            return data;\n        }\n\n        // Check if it has an input text or number.\n        input = element.querySelector<HTMLInputElement>('input[type=\"number\"],input[type=\"text\"]');\n        if (input) {\n            // Short answer or numeric.\n            return {\n                isText: true,\n                value: input.value,\n            };\n        }\n\n        // Check if it has a select.\n        const select = element.querySelector('select');\n        if (select?.options) {\n            // Matching.\n            const selectedOption = select.options[select.selectedIndex];\n            const data: AddonModLessonSelectAnswerData = {\n                isSelect: true,\n                id: select.id,\n                value: selectedOption ? selectedOption.value : '',\n                content: '',\n            };\n\n            select.remove();\n            data.content = element.innerHTML.trim();\n\n            return data;\n        }\n\n        // The answer doesn't need any parsing, return the HTML as it is.\n        return html;\n    }\n\n    /**\n     * Get a label to identify a retake (lesson attempt).\n     *\n     * @param retake Retake object.\n     * @param includeDuration Whether to include the duration of the retake.\n     * @returns Retake label.\n     */\n    getRetakeLabel(retake: AddonModLessonAttemptsOverviewsAttemptWSData, includeDuration?: boolean): string {\n        const data = {\n            retake: retake.try + 1,\n            grade: '',\n            timestart: '',\n            duration: '',\n        };\n        const hasGrade = retake.grade != null;\n\n        if (hasGrade || retake.end) {\n            // Retake finished with or without grade (if the lesson only has content pages, it has no grade).\n            if (hasGrade) {\n                data.grade = Translate.instant('core.percentagenumber', { $a: retake.grade });\n            }\n            data.timestart = CoreTimeUtils.userDate(retake.timestart * 1000);\n            if (includeDuration) {\n                data.duration = CoreTime.formatTime(retake.timeend - retake.timestart);\n            }\n        } else {\n            // The user has not completed the retake.\n            data.grade = Translate.instant('addon.mod_lesson.notcompleted');\n            if (retake.timestart) {\n                data.timestart = CoreTimeUtils.userDate(retake.timestart * 1000);\n            }\n        }\n\n        return Translate.instant('addon.mod_lesson.retakelabel' + (includeDuration ? 'full' : 'short'), data);\n    }\n\n    /**\n     * Prepare the question data to be sent to server.\n     *\n     * @param question Question to prepare.\n     * @param data Data to prepare.\n     * @returns Data to send.\n     */\n    prepareQuestionData(question: AddonModLessonQuestion, data: CoreFormFields): CoreFormFields {\n        if (question.template == 'essay') {\n            const textarea = (<AddonModLessonEssayQuestion> question).textarea;\n\n            // Add some HTML to the answer if needed.\n            if (textarea) {\n                data[textarea.name] = CoreTextUtils.formatHtmlLines(<string> data[textarea.name] || '');\n            }\n        } else if (question.template == 'multichoice' && (<AddonModLessonMultichoiceQuestion> question).multi) {\n            // Only send the options with value set to true.\n            for (const name in data) {\n                if (name.match(/answer\\[\\d+\\]/) && data[name] == false) {\n                    delete data[name];\n                }\n            }\n        }\n\n        return data;\n    }\n\n    /**\n     * Given the feedback of a process page in HTML, remove the question text.\n     *\n     * @param html Feedback's HTML.\n     * @returns Feedback without the question text.\n     */\n    removeQuestionFromFeedback(html: string): string {\n        const element = CoreDomUtils.convertToElement(html);\n\n        // Remove the question text.\n        CoreDomUtils.removeElement(element, '.generalbox:not(.feedback):not(.correctanswer)');\n\n        return element.innerHTML.trim();\n    }\n\n}\n\nexport const AddonModLessonHelper = makeSingleton(AddonModLessonHelperProvider);\n\n/**\n * Page button data.\n */\nexport type AddonModLessonPageButton = {\n    id: string;\n    title: string;\n    content: string;\n    data: Record<string, string>;\n};\n\n/**\n * Generic question data.\n */\nexport type AddonModLessonQuestionBasicData = {\n    template: string; // Name of the template to use.\n    submitLabel: string; // Text to display in submit.\n};\n\n/**\n * Multichoice question data.\n */\nexport type AddonModLessonMultichoiceQuestion = AddonModLessonQuestionBasicData & {\n    multi: boolean; // Whether it allows multiple answers.\n    options: AddonModLessonMultichoiceOption[]; // Options for multichoice question.\n    controlName?: string; // Name of the form control, for single choice.\n};\n\n/**\n * Short answer or numeric question data.\n */\nexport type AddonModLessonInputQuestion = AddonModLessonQuestionBasicData & {\n    input?: AddonModLessonQuestionInput; // Text input for text/number questions.\n};\n\n/**\n * Essay question data.\n */\nexport type AddonModLessonEssayQuestion = AddonModLessonQuestionBasicData & {\n    useranswer?: string; // User answer, for reviewing.\n    textarea?: AddonModLessonTextareaData; // Data for the textarea.\n    control?: FormControl; // Form control.\n};\n\n/**\n * Matching question data.\n */\nexport type AddonModLessonMatchingQuestion = AddonModLessonQuestionBasicData & {\n    rows: AddonModLessonMatchingRow[];\n};\n\n/**\n * Data for each option in a multichoice question.\n */\nexport type AddonModLessonMultichoiceOption = {\n    id: string;\n    name: string;\n    value: string;\n    checked: boolean;\n    disabled: boolean;\n    text: string;\n};\n\n/**\n * Input data for text/number questions.\n */\nexport type AddonModLessonQuestionInput = {\n    id: string;\n    name: string;\n    maxlength: number;\n    type: string;\n};\n\n/**\n * Textarea data for essay questions.\n */\nexport type AddonModLessonTextareaData = {\n    id: string;\n    name: string;\n};\n\n/**\n * Data for each row in a matching question.\n */\nexport type AddonModLessonMatchingRow = {\n    id: string;\n    name: string;\n    text: string;\n    options: AddonModLessonMatchingRowOption[];\n};\n\n/**\n * Data for each option in a row in a matching question.\n */\nexport type AddonModLessonMatchingRowOption = {\n    value: string;\n    label: string;\n    selected: boolean;\n};\n\n/**\n * Checkbox answer.\n */\nexport type AddonModLessonCheckboxAnswerData = {\n    isCheckbox: true;\n    checked: boolean;\n    name: string;\n    highlight: boolean;\n    content: string;\n    successBadge?: string;\n};\n\n/**\n * Text answer.\n */\nexport type AddonModLessonTextAnswerData = {\n    isText: true;\n    value: string;\n};\n\n/**\n * Select answer.\n */\nexport type AddonModLessonSelectAnswerData = {\n    isSelect: true;\n    id: string;\n    value: string;\n    content: string;\n};\n\n/**\n * Any possible answer data.\n */\nexport type AddonModLessonAnswerData =\n    AddonModLessonCheckboxAnswerData | AddonModLessonTextAnswerData | AddonModLessonSelectAnswerData | string;\n\n/**\n * Any possible question data.\n */\nexport type AddonModLessonQuestion = AddonModLessonQuestionBasicData & Partial<AddonModLessonMultichoiceQuestion> &\nPartial<AddonModLessonInputQuestion> & Partial<AddonModLessonEssayQuestion> & Partial<AddonModLessonMatchingQuestion>;\n\n/**\n * Activity link data.\n */\nexport type AddonModLessonActivityLink = {\n    formatted: boolean;\n    label: string;\n    href: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}