{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreFile } from '@services/file';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreQuestion, CoreQuestionProvider } from './question';\nimport { CoreQuestionDelegate } from './question-delegate';\nimport { CoreIcons } from '@singletons/icons';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport * as i0 from \"@angular/core\";\n/**\n * Service with some common functions to handle questions.\n */\nexport class CoreQuestionHelperProvider {\n  constructor() {\n    this.lastErrorShown = 0;\n  }\n  /**\n   * Add a behaviour button to the question's \"behaviourButtons\" property.\n   *\n   * @param question Question.\n   * @param button Behaviour button (DOM element).\n   */\n  addBehaviourButton(question, button) {\n    if (!button || !question) {\n      return;\n    }\n    question.behaviourButtons = question.behaviourButtons || [];\n    // Extract the data we want.\n    if (button instanceof HTMLInputElement) {\n      // Old behaviour that changed in 4.2 because of MDL-78874.\n      question.behaviourButtons.push({\n        id: button.id,\n        name: button.name,\n        value: button.value,\n        disabled: button.disabled\n      });\n      return;\n    }\n    if (!(button instanceof HTMLButtonElement)) {\n      return;\n    }\n    question.behaviourButtons.push({\n      id: button.id,\n      name: button.name,\n      value: button.innerHTML,\n      disabled: button.disabled\n    });\n  }\n  /**\n   * Clear questions temporary data after the data has been saved.\n   *\n   * @param questions The list of questions.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @returns Promise resolved when done.\n   */\n  clearTmpData(questions, component, componentId) {\n    return _asyncToGenerator(function* () {\n      questions = questions || [];\n      yield Promise.all(questions.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (question) {\n          yield CoreQuestionDelegate.clearTmpData(question, component, componentId);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Delete files stored for a question.\n   *\n   * @param question Question.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteStoredQuestionFiles(question, component, componentId, siteId) {\n    return _asyncToGenerator(function* () {\n      const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n      const folderPath = CoreQuestion.getQuestionFolder(question.type, component, questionComponentId, siteId);\n      // Ignore errors, maybe the folder doesn't exist.\n      yield CoreUtils.ignoreErrors(CoreFile.removeDir(folderPath));\n    })();\n  }\n  /**\n   * Extract question behaviour submit buttons from the question's HTML and add them to \"behaviourButtons\" property.\n   * The buttons aren't deleted from the content because all the im-controls block will be removed afterwards.\n   *\n   * @param question Question to treat.\n   * @param selector Selector to search the buttons. By default, '.im-controls [type=\"submit\"]'.\n   */\n  extractQbehaviourButtons(question, selector) {\n    if (CoreQuestionDelegate.getPreventSubmitMessage(question)) {\n      // The question is not fully supported, don't extract the buttons.\n      return;\n    }\n    selector = selector || '.im-controls [type=\"submit\"]';\n    const element = CoreDomUtils.convertToElement(question.html);\n    // Search the buttons.\n    const buttons = Array.from(element.querySelectorAll(selector));\n    buttons.forEach(button => {\n      this.addBehaviourButton(question, button);\n    });\n  }\n  /**\n   * Check if the question has CBM and, if so, extract the certainty options and add them to a new\n   * \"behaviourCertaintyOptions\" property.\n   * The value of the selected option is stored in question.behaviourCertaintySelected.\n   * We don't remove them from HTML because the whole im-controls block will be removed afterwards.\n   *\n   * @param question Question to treat.\n   * @returns Wether the certainty is found.\n   */\n  extractQbehaviourCBM(question) {\n    const element = CoreDomUtils.convertToElement(question.html);\n    const labels = Array.from(element.querySelectorAll('.im-controls .certaintychoices label[for*=\"certainty\"]'));\n    question.behaviourCertaintyOptions = [];\n    labels.forEach(label => {\n      // Search the radio button inside this certainty and add its data to the options array.\n      const input = label.querySelector('input[type=\"radio\"]');\n      if (input) {\n        var _question$behaviourCe;\n        (_question$behaviourCe = question.behaviourCertaintyOptions) === null || _question$behaviourCe === void 0 || _question$behaviourCe.push({\n          id: input.id,\n          name: input.name,\n          value: input.value,\n          text: CoreTextUtils.cleanTags(label.innerHTML),\n          disabled: input.disabled\n        });\n        if (input.checked) {\n          question.behaviourCertaintySelected = input.value;\n        }\n      }\n    });\n    // If we have a certainty value stored in local we'll use that one.\n    if (question.localAnswers && question.localAnswers['-certainty'] !== undefined) {\n      question.behaviourCertaintySelected = question.localAnswers['-certainty'];\n    }\n    return labels.length > 0;\n  }\n  /**\n   * Check if the question has a redo button and, if so, add it to \"behaviourButtons\" property\n   * and remove it from the HTML.\n   *\n   * @param question Question to treat.\n   */\n  extractQbehaviourRedoButton(question) {\n    // Create a fake div element so we can search using querySelector.\n    const redoSelector = '[type=\"submit\"][name*=redoslot], [type=\"submit\"][name*=tryagain]';\n    // Search redo button in feedback.\n    if (!this.searchBehaviourButton(question, 'html', '.outcome ' + redoSelector)) {\n      // Not found in question HTML.\n      if (question.feedbackHtml) {\n        // We extracted the feedback already, search it in there.\n        if (this.searchBehaviourButton(question, 'feedbackHtml', redoSelector)) {\n          // Button found, stop.\n          return;\n        }\n      }\n      // Button still not found. Now search in the info box if it exists.\n      if (question.infoHtml) {\n        this.searchBehaviourButton(question, 'infoHtml', redoSelector);\n      }\n    }\n  }\n  /**\n   * Check if the question contains a \"seen\" input.\n   * If so, add the name and value to a \"behaviourSeenInput\" property and remove the input.\n   *\n   * @param question Question to treat.\n   * @returns Whether the seen input is found.\n   */\n  extractQbehaviourSeenInput(question) {\n    var _seenInput$parentElem;\n    const element = CoreDomUtils.convertToElement(question.html);\n    // Search the \"seen\" input.\n    const seenInput = element.querySelector('input[type=\"hidden\"][name*=seen]');\n    if (!seenInput) {\n      return false;\n    }\n    // Get the data and remove the input.\n    question.behaviourSeenInput = {\n      name: seenInput.name,\n      value: seenInput.value\n    };\n    (_seenInput$parentElem = seenInput.parentElement) === null || _seenInput$parentElem === void 0 || _seenInput$parentElem.removeChild(seenInput);\n    question.html = element.innerHTML;\n    return true;\n  }\n  /**\n   * Removes the comment from the question HTML code and adds it in a new \"commentHtml\" property.\n   *\n   * @param question Question.\n   */\n  extractQuestionComment(question) {\n    this.extractQuestionLastElementNotInContent(question, '.comment', 'commentHtml');\n  }\n  /**\n   * Removes the feedback from the question HTML code and adds it in a new \"feedbackHtml\" property.\n   *\n   * @param question Question.\n   */\n  extractQuestionFeedback(question) {\n    this.extractQuestionLastElementNotInContent(question, '.outcome', 'feedbackHtml');\n  }\n  /**\n   * Extracts the info box from a question and add it to an \"infoHtml\" property.\n   *\n   * @param question Question.\n   * @param selector Selector to search the element.\n   */\n  extractQuestionInfoBox(question, selector) {\n    this.extractQuestionLastElementNotInContent(question, selector, 'infoHtml');\n  }\n  /**\n   * Searches the last occurrence of a certain element and check it's not in the question contents.\n   * If found, removes it from the question HTML and adds it to a new property inside question.\n   *\n   * @param question Question.\n   * @param selector Selector to search the element.\n   * @param attrName Name of the attribute to store the HTML in.\n   */\n  extractQuestionLastElementNotInContent(question, selector, attrName) {\n    const element = CoreDomUtils.convertToElement(question.html);\n    const matches = Array.from(element.querySelectorAll(selector));\n    // Get the last element and check it's not in the question contents.\n    let last = matches.pop();\n    while (last) {\n      if (!last.closest('.formulation')) {\n        var _last$parentElement;\n        // Not in question contents. Add it to a separate attribute and remove it from the HTML.\n        question[attrName] = last.innerHTML;\n        (_last$parentElement = last.parentElement) === null || _last$parentElement === void 0 || _last$parentElement.removeChild(last);\n        question.html = element.innerHTML;\n        return;\n      }\n      // It's inside the question content, treat next element.\n      last = matches.pop();\n    }\n  }\n  /**\n   * Removes the scripts from a question's HTML and adds it in a new 'scriptsCode' property.\n   * It will also search for init_question functions of the question type and add the object to an 'initObjects' property.\n   *\n   * @param question Question.\n   * @param usageId Usage ID.\n   */\n  extractQuestionScripts(question, usageId) {\n    var _question$html;\n    question.scriptsCode = '';\n    question.initObjects = undefined;\n    question.amdArgs = undefined;\n    // Search the scripts.\n    const matches = (_question$html = question.html) === null || _question$html === void 0 ? void 0 : _question$html.match(/<script[^>]*>[\\s\\S]*?<\\/script>/mg);\n    if (!matches) {\n      // No scripts, stop.\n      return;\n    }\n    matches.forEach(scriptCode => {\n      if (scriptCode.match(/<script[^>]+type=\"math\\/tex\"/m)) {\n        // Don't remove math/tex scripts, they're needed to render the math expressions.\n        return;\n      }\n      // Add the script to scriptsCode and remove it from html.\n      question.scriptsCode += scriptCode;\n      question.html = question.html.replace(scriptCode, '');\n      // Search init_question functions for this type.\n      const initMatches = scriptCode.match(new RegExp('M.qtype_' + question.type + '.init_question\\\\(.*?}\\\\);', 'mg'));\n      if (initMatches) {\n        let initMatch = initMatches.pop();\n        if (initMatch) {\n          // Remove start and end of the match, we only want the object.\n          initMatch = initMatch.replace('M.qtype_' + question.type + '.init_question(', '');\n          initMatch = initMatch.substring(0, initMatch.length - 2);\n          // Try to convert it to an object and add it to the question.\n          question.initObjects = CoreTextUtils.parseJSON(initMatch, null);\n        }\n      }\n      const amdRegExp = new RegExp('require\\\\(\\\\[[\"\\']qtype_' + question.type + '/question[\"\\']\\\\],[^f]*' + 'function\\\\(amd\\\\)[^\\\\{]*\\\\{[^a]*amd\\\\.init\\\\(([\"\\'](q|question-' + usageId + '-)' + question.slot + '[\"\\'].*?)\\\\);', 'm');\n      const amdMatch = scriptCode.match(amdRegExp);\n      if (amdMatch) {\n        // Try to convert the arguments to an array and add them to the question.\n        question.amdArgs = CoreTextUtils.parseJSON('[' + amdMatch[1] + ']', null);\n      }\n    });\n  }\n  /**\n   * Get the names of all the inputs inside an HTML code.\n   * This function will return an object where the keys are the input names. The values will always be true.\n   * This is in order to make this function compatible with other functions like CoreQuestionProvider.getBasicAnswers.\n   *\n   * @param html HTML code.\n   * @returns Object where the keys are the names.\n   */\n  getAllInputNamesFromHtml(html) {\n    const element = CoreDomUtils.convertToElement('<form>' + html + '</form>');\n    const form = element.children[0];\n    const answers = {};\n    // Search all input elements.\n    Array.from(form.elements).forEach(element => {\n      const name = element.name || '';\n      // Ignore flag and submit inputs.\n      if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {\n        return;\n      }\n      answers[CoreQuestion.removeQuestionPrefix(name)] = true;\n    });\n    return answers;\n  }\n  /**\n   * Retrieve the answers entered in a form.\n   * We don't use ngModel because it doesn't detect changes done by JavaScript and some questions might do that.\n   *\n   * @param form Form.\n   * @returns Object with the answers.\n   */\n  getAnswersFromForm(form) {\n    if (!form || !form.elements) {\n      return {};\n    }\n    const answers = {};\n    const elements = Array.from(form.elements);\n    elements.forEach(element => {\n      const name = element.name || element.getAttribute('ng-reflect-name') || '';\n      // Ignore flag and submit inputs.\n      if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {\n        return;\n      }\n      // Get the value.\n      if (element.type == 'checkbox') {\n        answers[name] = !!element.checked;\n      } else if (element.type == 'radio') {\n        if (element.checked) {\n          answers[name] = element.value;\n        }\n      } else {\n        answers[name] = element.value;\n      }\n    });\n    return answers;\n  }\n  /**\n   * Given an HTML code with list of attachments, returns the list of attached files (filename and fileurl).\n   * Please take into account that this function will treat all the anchors in the HTML, you should provide\n   * an HTML containing only the attachments anchors.\n   *\n   * @param html HTML code to search in.\n   * @returns Attachments.\n   */\n  getQuestionAttachmentsFromHtml(html) {\n    const element = CoreDomUtils.convertToElement(html);\n    // Remove the filemanager (area to attach files to a question).\n    CoreDomUtils.removeElement(element, 'div[id*=filemanager]');\n    // Search the anchors.\n    const anchors = Array.from(element.querySelectorAll('a'));\n    const attachments = [];\n    anchors.forEach(anchor => {\n      let content = anchor.innerHTML;\n      // Check anchor is valid.\n      if (anchor.href && content) {\n        content = CoreTextUtils.cleanTags(content, {\n          singleLine: true,\n          trim: true\n        });\n        attachments.push({\n          filename: content,\n          fileurl: anchor.href\n        });\n      }\n    });\n    return attachments;\n  }\n  /**\n   * Get the sequence check from a question HTML.\n   *\n   * @param html Question's HTML.\n   * @returns Object with the sequencecheck name and value.\n   */\n  getQuestionSequenceCheckFromHtml(html) {\n    if (!html) {\n      return;\n    }\n    // Search the input holding the sequencecheck.\n    const element = CoreDomUtils.convertToElement(html);\n    const input = element.querySelector('input[name*=sequencecheck]');\n    if (!input || input.name === undefined || input.value === undefined) {\n      return;\n    }\n    return {\n      name: input.name,\n      value: input.value\n    };\n  }\n  /**\n   * Get the CSS class for a question based on its state.\n   *\n   * @param name Question's state name.\n   * @returns State class.\n   */\n  getQuestionStateClass(name) {\n    const state = CoreQuestion.getState(name);\n    return state ? state.class : '';\n  }\n  /**\n   * Return the files of a certain response file area.\n   *\n   * @param question Question.\n   * @param areaName Name of the area, e.g. 'attachments'.\n   * @returns List of files.\n   */\n  getResponseFileAreaFiles(question, areaName) {\n    if (!question.responsefileareas) {\n      return [];\n    }\n    const area = question.responsefileareas.find(area => area.area == areaName);\n    return (area === null || area === void 0 ? void 0 : area.files) || [];\n  }\n  /**\n   * Get files stored for a question.\n   *\n   * @param question Question.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the files.\n   */\n  getStoredQuestionFiles(question, component, componentId, siteId) {\n    const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n    const folderPath = CoreQuestion.getQuestionFolder(question.type, component, questionComponentId, siteId);\n    return CoreFile.getDirectoryContents(folderPath);\n  }\n  /**\n   * Get the validation error message from a question HTML if it's there.\n   *\n   * @param html Question's HTML.\n   * @returns Validation error message if present.\n   */\n  getValidationErrorFromHtml(html) {\n    const element = CoreDomUtils.convertToElement(html);\n    return CoreDomUtils.getContentsOfElement(element, '.validationerror');\n  }\n  /**\n   * Check if some HTML contains draft file URLs for the current site.\n   *\n   * @param html Question's HTML.\n   * @returns Whether it contains draft files URLs.\n   */\n  hasDraftFileUrls(html) {\n    var _CoreSites$getCurrent;\n    let url = (_CoreSites$getCurrent = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent === void 0 ? void 0 : _CoreSites$getCurrent.getURL();\n    if (!url) {\n      return false;\n    }\n    if (url.slice(-1) != '/') {\n      url = url += '/';\n    }\n    url += 'draftfile.php';\n    return html.indexOf(url) != -1;\n  }\n  /**\n   * Load local answers of a question.\n   *\n   * @param question Question.\n   * @param component Component.\n   * @param attemptId Attempt ID.\n   * @returns Promise resolved when done.\n   */\n  loadLocalAnswers(question, component, attemptId) {\n    return _asyncToGenerator(function* () {\n      const answers = yield CoreUtils.ignoreErrors(CoreQuestion.getQuestionAnswers(component, attemptId, question.slot));\n      if (answers) {\n        question.localAnswers = CoreQuestion.convertAnswersArrayToObject(answers, true);\n      } else {\n        question.localAnswers = {};\n      }\n    })();\n  }\n  /**\n   * For each input element found in the HTML, search if there's a local answer stored and\n   * override the HTML's value with the local one.\n   *\n   * @param question Question.\n   */\n  loadLocalAnswersInHtml(question) {\n    const element = CoreDomUtils.convertToElement('<form>' + question.html + '</form>');\n    const form = element.children[0];\n    // Search all input elements.\n    Array.from(form.elements).forEach(element => {\n      let name = element.name || '';\n      // Ignore flag and submit inputs.\n      if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON' || !question.localAnswers) {\n        return;\n      }\n      // Search if there's a local answer.\n      name = CoreQuestion.removeQuestionPrefix(name);\n      if (question.localAnswers[name] === undefined) {\n        if (Object.keys(question.localAnswers).length && element.type == 'radio') {\n          // No answer stored, but there is a sequencecheck or similar. This means the user cleared his choice.\n          element.removeAttribute('checked');\n        }\n        return;\n      }\n      if (element.tagName == 'TEXTAREA') {\n        // Just put the answer inside the textarea.\n        element.innerHTML = question.localAnswers[name];\n      } else if (element.tagName == 'SELECT') {\n        // Search the selected option and select it.\n        const selected = element.querySelector('option[value=\"' + question.localAnswers[name] + '\"]');\n        if (selected) {\n          selected.setAttribute('selected', 'selected');\n        }\n      } else if (element.type == 'radio') {\n        // Check if this radio is selected.\n        if (element.value == question.localAnswers[name]) {\n          element.setAttribute('checked', 'checked');\n        } else {\n          element.removeAttribute('checked');\n        }\n      } else if (element.type == 'checkbox') {\n        // Check if this checkbox is checked.\n        if (CoreUtils.isTrueOrOne(question.localAnswers[name])) {\n          element.setAttribute('checked', 'checked');\n        } else {\n          element.removeAttribute('checked');\n        }\n      } else {\n        // Put the answer in the value.\n        element.setAttribute('value', question.localAnswers[name]);\n      }\n    });\n    // Update the question HTML.\n    question.html = form.innerHTML;\n  }\n  /**\n   * Prefetch the files in a question HTML.\n   *\n   * @param question Question.\n   * @param component The component to link the files to. If not defined, question component.\n   * @param componentId An ID to use in conjunction with the component. If not defined, question ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param usageId Usage ID. Required in Moodle 3.7+.\n   * @returns Promise resolved when all the files have been downloaded.\n   */\n  prefetchQuestionFiles(question, component, componentId, siteId, usageId) {\n    return _asyncToGenerator(function* () {\n      if (!component) {\n        component = CoreQuestionProvider.COMPONENT;\n        componentId = question.questionnumber;\n      }\n      const files = CoreQuestionDelegate.getAdditionalDownloadableFiles(question, usageId) || [];\n      files.push(...CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(question.html));\n      const site = yield CoreSites.getSite(siteId);\n      const treated = {};\n      yield Promise.all(files.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (file) {\n          const timemodified = file.timemodified || 0;\n          const fileUrl = CoreFileHelper.getFileUrl(file);\n          if (treated[fileUrl]) {\n            return;\n          }\n          treated[fileUrl] = true;\n          if (!site.canDownloadFiles() && site.isSitePluginFileUrl(fileUrl)) {\n            return;\n          }\n          if (CoreUrlUtils.isThemeImageUrl(fileUrl) && fileUrl.indexOf('flagged') > -1) {\n            // Ignore flag images.\n            return;\n          }\n          yield CoreFilepool.addToQueueByUrl(site.getId(), fileUrl, component, componentId, timemodified);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Prepare and return the answers.\n   *\n   * @param questions The list of questions.\n   * @param answers The input data.\n   * @param offline True if data should be saved in offline.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with answers to send to server.\n   */\n  prepareAnswers(questions, answers, offline, component, componentId, siteId) {\n    return _asyncToGenerator(function* () {\n      yield CoreUtils.allPromises(questions.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (question) {\n          yield CoreQuestionDelegate.prepareAnswersForQuestion(question, answers, offline, component, componentId, siteId);\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return answers;\n    })();\n  }\n  /**\n   * Replace Moodle's correct/incorrect classes with the Mobile ones.\n   *\n   * @param element DOM element.\n   */\n  replaceCorrectnessClasses(element) {\n    CoreDomUtils.replaceClassesInElement(element, {\n      correct: 'core-question-answer-correct',\n      incorrect: 'core-question-answer-incorrect'\n    });\n  }\n  /**\n   * Replace Moodle's feedback classes with the Mobile ones.\n   *\n   * @param element DOM element.\n   */\n  replaceFeedbackClasses(element) {\n    CoreDomUtils.replaceClassesInElement(element, {\n      outcome: 'core-question-feedback-container core-question-feedback-padding',\n      specificfeedback: 'core-question-feedback-container core-question-feedback-inline'\n    });\n  }\n  /**\n   * Search a behaviour button in a certain question property containing HTML.\n   *\n   * @param question Question.\n   * @param htmlProperty The name of the property containing the HTML to search.\n   * @param selector The selector to find the button.\n   * @returns Whether the button is found.\n   */\n  searchBehaviourButton(question, htmlProperty, selector) {\n    var _button$parentElement;\n    const element = CoreDomUtils.convertToElement(question[htmlProperty]);\n    const button = element.querySelector(selector);\n    if (!button) {\n      return false;\n    }\n    // Add a behaviour button to the question's \"behaviourButtons\" property.\n    this.addBehaviourButton(question, button);\n    // Remove the button from the HTML.\n    (_button$parentElement = button.parentElement) === null || _button$parentElement === void 0 || _button$parentElement.removeChild(button);\n    // Update the question's html.\n    question[htmlProperty] = element.innerHTML;\n    return true;\n  }\n  /**\n   * Convenience function to show a parsing error and abort.\n   *\n   * @param onAbort If supplied, will emit an event.\n   * @param error Error to show.\n   */\n  showComponentError(onAbort, error) {\n    // Prevent consecutive errors.\n    const now = Date.now();\n    if (now - this.lastErrorShown > 500) {\n      this.lastErrorShown = now;\n      CoreDomUtils.showErrorModalDefault(error || '', 'addon.mod_quiz.errorparsequestions', true);\n    }\n    onAbort === null || onAbort === void 0 || onAbort.emit();\n  }\n  /**\n   * Treat correctness icons, replacing them with local icons and setting click events to show the feedback if needed.\n   *\n   * @param element DOM element.\n   */\n  treatCorrectnessIcons(element) {\n    const icons = Array.from(element.querySelectorAll('img.icon, img.questioncorrectnessicon, i.icon'));\n    icons.forEach(icon => {\n      var _icon$parentNode;\n      let correct = false;\n      if ('src' in icon) {\n        if (icon.src.indexOf('correct') >= 0) {\n          correct = true;\n        } else if (icon.src.indexOf('incorrect') < 0) {\n          return;\n        }\n      } else {\n        const classList = icon.classList.toString();\n        if (classList.indexOf('fa-check') >= 0) {\n          correct = true;\n        } else if (classList.indexOf('fa-xmark') < 0 && classList.indexOf('fa-remove') < 0) {\n          return;\n        }\n      }\n      // Replace the icon with the font version.\n      const newIcon = document.createElement('ion-icon');\n      if (correct) {\n        const iconName = 'check';\n        newIcon.setAttribute('name', `fas-${iconName}`);\n        newIcon.setAttribute('src', CoreIcons.getIconSrc('font-awesome', 'solid', iconName));\n        newIcon.className = 'core-correct-icon ion-color ion-color-success questioncorrectnessicon';\n      } else {\n        const iconName = 'xmark';\n        newIcon.setAttribute('name', `fas-${iconName}`);\n        newIcon.setAttribute('src', CoreIcons.getIconSrc('font-awesome', 'solid', iconName));\n        newIcon.className = 'core-correct-icon ion-color ion-color-danger questioncorrectnessicon';\n      }\n      newIcon.title = icon.title;\n      newIcon.setAttribute('aria-label', icon.title);\n      (_icon$parentNode = icon.parentNode) === null || _icon$parentNode === void 0 || _icon$parentNode.replaceChild(newIcon, icon);\n    });\n    // Treat legacy markup used before MDL-77856 (4.2).\n    const spans = Array.from(element.querySelectorAll('.feedbackspan.accesshide'));\n    spans.forEach(span => {\n      // Search if there's a hidden feedback for this element.\n      const icon = span.previousSibling;\n      if (!icon || !icon.classList.contains('icon') && !icon.classList.contains('questioncorrectnessicon')) {\n        return;\n      }\n      icon.classList.add('questioncorrectnessicon');\n      if (span.innerHTML) {\n        // There's a hidden feedback. Mark the icon as tappable.\n        // The click listener is only added if treatCorrectnessIconsClicks is called.\n        icon.setAttribute('tappable', '');\n      }\n    });\n  }\n  /**\n   * Add click listeners to all tappable correctness icons.\n   *\n   * @param element DOM element.\n   * @param component The component to use when viewing the feedback.\n   * @param componentId An ID to use in conjunction with the component.\n   * @param contextLevel The context level.\n   * @param contextInstanceId Instance ID related to the context.\n   * @param courseId Course ID the text belongs to. It can be used to improve performance with filters.\n   */\n  treatCorrectnessIconsClicks(element, component, componentId, contextLevel, contextInstanceId, courseId) {\n    const icons = Array.from(element.querySelectorAll('ion-icon.questioncorrectnessicon'));\n    const title = Translate.instant('core.question.feedback');\n    const getClickableFeedback = icon => {\n      const parentElement = icon.parentElement;\n      const parentIsClickable = parentElement instanceof HTMLButtonElement || parentElement instanceof HTMLAnchorElement;\n      if (parentElement && parentIsClickable && parentElement.dataset.toggle === 'popover') {\n        return {\n          element: parentElement,\n          html: parentElement === null || parentElement === void 0 ? void 0 : parentElement.dataset.content\n        };\n      }\n      // Support legacy icons used before MDL-77856 (4.2).\n      if (icon.hasAttribute('tappable')) {\n        var _parentElement$queryS;\n        return {\n          element: icon,\n          html: parentElement === null || parentElement === void 0 || (_parentElement$queryS = parentElement.querySelector('.feedbackspan.accesshide')) === null || _parentElement$queryS === void 0 ? void 0 : _parentElement$queryS.innerHTML\n        };\n      }\n      return null;\n    };\n    icons.forEach(icon => {\n      const target = getClickableFeedback(icon);\n      if (!target || !target.html) {\n        return;\n      }\n      // There's a hidden feedback, show it when the icon is clicked.\n      target.element.dataset.disabledA11yClicks = 'true';\n      target.element.addEventListener('click', event => {\n        var _target$html;\n        event.preventDefault();\n        event.stopPropagation();\n        CoreTextUtils.viewText(title, (_target$html = target.html) !== null && _target$html !== void 0 ? _target$html : '', {\n          component: component,\n          componentId: componentId,\n          filter: true,\n          contextLevel: contextLevel,\n          instanceId: contextInstanceId,\n          courseId: courseId\n        });\n      });\n    });\n  }\n}\n_class = CoreQuestionHelperProvider;\n_class.ɵfac = function CoreQuestionHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreQuestionHelper = makeSingleton(CoreQuestionHelperProvider);","map":{"version":3,"names":["CoreFile","CoreFileHelper","CoreFilepool","CoreSites","CoreDomUtils","CoreTextUtils","CoreUtils","makeSingleton","Translate","CoreQuestion","CoreQuestionProvider","CoreQuestionDelegate","CoreIcons","CoreUrlUtils","CoreQuestionHelperProvider","constructor","lastErrorShown","addBehaviourButton","question","button","behaviourButtons","HTMLInputElement","push","id","name","value","disabled","HTMLButtonElement","innerHTML","clearTmpData","questions","component","componentId","_asyncToGenerator","Promise","all","map","_ref","_x","apply","arguments","deleteStoredQuestionFiles","siteId","questionComponentId","getQuestionComponentId","folderPath","getQuestionFolder","type","ignoreErrors","removeDir","extractQbehaviourButtons","selector","getPreventSubmitMessage","element","convertToElement","html","buttons","Array","from","querySelectorAll","forEach","extractQbehaviourCBM","labels","behaviourCertaintyOptions","label","input","querySelector","_question$behaviourCe","text","cleanTags","checked","behaviourCertaintySelected","localAnswers","undefined","length","extractQbehaviourRedoButton","redoSelector","searchBehaviourButton","feedbackHtml","infoHtml","extractQbehaviourSeenInput","_seenInput$parentElem","seenInput","behaviourSeenInput","parentElement","removeChild","extractQuestionComment","extractQuestionLastElementNotInContent","extractQuestionFeedback","extractQuestionInfoBox","attrName","matches","last","pop","closest","_last$parentElement","extractQuestionScripts","usageId","_question$html","scriptsCode","initObjects","amdArgs","match","scriptCode","replace","initMatches","RegExp","initMatch","substring","parseJSON","amdRegExp","slot","amdMatch","getAllInputNamesFromHtml","form","children","answers","elements","tagName","removeQuestionPrefix","getAnswersFromForm","getAttribute","getQuestionAttachmentsFromHtml","removeElement","anchors","attachments","anchor","content","href","singleLine","trim","filename","fileurl","getQuestionSequenceCheckFromHtml","getQuestionStateClass","state","getState","class","getResponseFileAreaFiles","areaName","responsefileareas","area","find","files","getStoredQuestionFiles","getDirectoryContents","getValidationErrorFromHtml","getContentsOfElement","hasDraftFileUrls","_CoreSites$getCurrent","url","getCurrentSite","getURL","slice","indexOf","loadLocalAnswers","attemptId","getQuestionAnswers","convertAnswersArrayToObject","loadLocalAnswersInHtml","Object","keys","removeAttribute","selected","setAttribute","isTrueOrOne","prefetchQuestionFiles","COMPONENT","questionnumber","getAdditionalDownloadableFiles","extractDownloadableFilesFromHtmlAsFakeFileObjects","site","getSite","treated","_ref2","file","timemodified","fileUrl","getFileUrl","canDownloadFiles","isSitePluginFileUrl","isThemeImageUrl","addToQueueByUrl","getId","_x2","prepareAnswers","offline","allPromises","_ref3","prepareAnswersForQuestion","_x3","replaceCorrectnessClasses","replaceClassesInElement","correct","incorrect","replaceFeedbackClasses","outcome","specificfeedback","htmlProperty","_button$parentElement","showComponentError","onAbort","error","now","Date","showErrorModalDefault","emit","treatCorrectnessIcons","icons","icon","_icon$parentNode","src","classList","toString","newIcon","document","createElement","iconName","getIconSrc","className","title","parentNode","replaceChild","spans","span","previousSibling","contains","add","treatCorrectnessIconsClicks","contextLevel","contextInstanceId","courseId","instant","getClickableFeedback","parentIsClickable","HTMLAnchorElement","dataset","toggle","hasAttribute","_parentElement$queryS","target","disabledA11yClicks","addEventListener","event","_target$html","preventDefault","stopPropagation","viewText","filter","instanceId","factory","ɵfac","providedIn","CoreQuestionHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/question/services/question-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, EventEmitter } from '@angular/core';\nimport { FileEntry, DirectoryEntry } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreFile } from '@services/file';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreQuestion, CoreQuestionProvider, CoreQuestionQuestionParsed, CoreQuestionsAnswers } from './question';\nimport { CoreQuestionDelegate } from './question-delegate';\nimport { CoreIcons } from '@singletons/icons';\nimport { CoreUrlUtils } from '@services/utils/url';\n\n/**\n * Service with some common functions to handle questions.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreQuestionHelperProvider {\n\n    protected lastErrorShown = 0;\n\n    /**\n     * Add a behaviour button to the question's \"behaviourButtons\" property.\n     *\n     * @param question Question.\n     * @param button Behaviour button (DOM element).\n     */\n    protected addBehaviourButton(question: CoreQuestionQuestion, button: HTMLElement): void {\n        if (!button || !question) {\n            return;\n        }\n\n        question.behaviourButtons = question.behaviourButtons || [];\n\n        // Extract the data we want.\n        if (button instanceof HTMLInputElement) {\n            // Old behaviour that changed in 4.2 because of MDL-78874.\n            question.behaviourButtons.push({\n                id: button.id,\n                name: button.name,\n                value: button.value,\n                disabled: button.disabled,\n            });\n\n            return;\n        }\n\n        if (!(button instanceof HTMLButtonElement)) {\n            return;\n        }\n\n        question.behaviourButtons.push({\n            id: button.id,\n            name: button.name,\n            value: button.innerHTML,\n            disabled: button.disabled,\n        });\n    }\n\n    /**\n     * Clear questions temporary data after the data has been saved.\n     *\n     * @param questions The list of questions.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns Promise resolved when done.\n     */\n    async clearTmpData(questions: CoreQuestionQuestionParsed[], component: string, componentId: string | number): Promise<void> {\n        questions = questions || [];\n\n        await Promise.all(questions.map(async (question) => {\n            await CoreQuestionDelegate.clearTmpData(question, component, componentId);\n        }));\n    }\n\n    /**\n     * Delete files stored for a question.\n     *\n     * @param question Question.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteStoredQuestionFiles(\n        question: CoreQuestionQuestionParsed,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<void> {\n        const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n        const folderPath = CoreQuestion.getQuestionFolder(question.type, component, questionComponentId, siteId);\n\n        // Ignore errors, maybe the folder doesn't exist.\n        await CoreUtils.ignoreErrors(CoreFile.removeDir(folderPath));\n    }\n\n    /**\n     * Extract question behaviour submit buttons from the question's HTML and add them to \"behaviourButtons\" property.\n     * The buttons aren't deleted from the content because all the im-controls block will be removed afterwards.\n     *\n     * @param question Question to treat.\n     * @param selector Selector to search the buttons. By default, '.im-controls [type=\"submit\"]'.\n     */\n    extractQbehaviourButtons(question: CoreQuestionQuestionParsed, selector?: string): void {\n        if (CoreQuestionDelegate.getPreventSubmitMessage(question)) {\n            // The question is not fully supported, don't extract the buttons.\n            return;\n        }\n\n        selector = selector || '.im-controls [type=\"submit\"]';\n\n        const element = CoreDomUtils.convertToElement(question.html);\n\n        // Search the buttons.\n        const buttons = <HTMLInputElement[]> Array.from(element.querySelectorAll(selector));\n        buttons.forEach((button) => {\n            this.addBehaviourButton(question, button);\n        });\n    }\n\n    /**\n     * Check if the question has CBM and, if so, extract the certainty options and add them to a new\n     * \"behaviourCertaintyOptions\" property.\n     * The value of the selected option is stored in question.behaviourCertaintySelected.\n     * We don't remove them from HTML because the whole im-controls block will be removed afterwards.\n     *\n     * @param question Question to treat.\n     * @returns Wether the certainty is found.\n     */\n    extractQbehaviourCBM(question: CoreQuestionQuestion): boolean {\n        const element = CoreDomUtils.convertToElement(question.html);\n\n        const labels = Array.from(element.querySelectorAll('.im-controls .certaintychoices label[for*=\"certainty\"]'));\n        question.behaviourCertaintyOptions = [];\n\n        labels.forEach((label) => {\n            // Search the radio button inside this certainty and add its data to the options array.\n            const input = <HTMLInputElement> label.querySelector('input[type=\"radio\"]');\n            if (input) {\n                question.behaviourCertaintyOptions?.push({\n                    id: input.id,\n                    name: input.name,\n                    value: input.value,\n                    text: CoreTextUtils.cleanTags(label.innerHTML),\n                    disabled: input.disabled,\n                });\n\n                if (input.checked) {\n                    question.behaviourCertaintySelected = input.value;\n                }\n            }\n        });\n\n        // If we have a certainty value stored in local we'll use that one.\n        if (question.localAnswers && question.localAnswers['-certainty'] !== undefined) {\n            question.behaviourCertaintySelected = question.localAnswers['-certainty'];\n        }\n\n        return labels.length > 0;\n    }\n\n    /**\n     * Check if the question has a redo button and, if so, add it to \"behaviourButtons\" property\n     * and remove it from the HTML.\n     *\n     * @param question Question to treat.\n     */\n    extractQbehaviourRedoButton(question: CoreQuestionQuestion): void {\n        // Create a fake div element so we can search using querySelector.\n        const redoSelector = '[type=\"submit\"][name*=redoslot], [type=\"submit\"][name*=tryagain]';\n\n        // Search redo button in feedback.\n        if (!this.searchBehaviourButton(question, 'html', '.outcome ' + redoSelector)) {\n            // Not found in question HTML.\n            if (question.feedbackHtml) {\n                // We extracted the feedback already, search it in there.\n                if (this.searchBehaviourButton(question, 'feedbackHtml', redoSelector)) {\n                    // Button found, stop.\n                    return;\n                }\n            }\n\n            // Button still not found. Now search in the info box if it exists.\n            if (question.infoHtml) {\n                this.searchBehaviourButton(question, 'infoHtml', redoSelector);\n            }\n        }\n    }\n\n    /**\n     * Check if the question contains a \"seen\" input.\n     * If so, add the name and value to a \"behaviourSeenInput\" property and remove the input.\n     *\n     * @param question Question to treat.\n     * @returns Whether the seen input is found.\n     */\n    extractQbehaviourSeenInput(question: CoreQuestionQuestion): boolean {\n        const element = CoreDomUtils.convertToElement(question.html);\n\n        // Search the \"seen\" input.\n        const seenInput = <HTMLInputElement> element.querySelector('input[type=\"hidden\"][name*=seen]');\n        if (!seenInput) {\n            return false;\n        }\n\n        // Get the data and remove the input.\n        question.behaviourSeenInput = {\n            name: seenInput.name,\n            value: seenInput.value,\n        };\n        seenInput.parentElement?.removeChild(seenInput);\n        question.html = element.innerHTML;\n\n        return true;\n    }\n\n    /**\n     * Removes the comment from the question HTML code and adds it in a new \"commentHtml\" property.\n     *\n     * @param question Question.\n     */\n    extractQuestionComment(question: CoreQuestionQuestion): void {\n        this.extractQuestionLastElementNotInContent(question, '.comment', 'commentHtml');\n    }\n\n    /**\n     * Removes the feedback from the question HTML code and adds it in a new \"feedbackHtml\" property.\n     *\n     * @param question Question.\n     */\n    extractQuestionFeedback(question: CoreQuestionQuestion): void {\n        this.extractQuestionLastElementNotInContent(question, '.outcome', 'feedbackHtml');\n    }\n\n    /**\n     * Extracts the info box from a question and add it to an \"infoHtml\" property.\n     *\n     * @param question Question.\n     * @param selector Selector to search the element.\n     */\n    extractQuestionInfoBox(question: CoreQuestionQuestion, selector: string): void {\n        this.extractQuestionLastElementNotInContent(question, selector, 'infoHtml');\n    }\n\n    /**\n     * Searches the last occurrence of a certain element and check it's not in the question contents.\n     * If found, removes it from the question HTML and adds it to a new property inside question.\n     *\n     * @param question Question.\n     * @param selector Selector to search the element.\n     * @param attrName Name of the attribute to store the HTML in.\n     */\n    protected extractQuestionLastElementNotInContent(question: CoreQuestionQuestion, selector: string, attrName: string): void {\n        const element = CoreDomUtils.convertToElement(question.html);\n        const matches = <HTMLElement[]> Array.from(element.querySelectorAll(selector));\n\n        // Get the last element and check it's not in the question contents.\n        let last = matches.pop();\n        while (last) {\n            if (!last.closest('.formulation')) {\n                // Not in question contents. Add it to a separate attribute and remove it from the HTML.\n                question[attrName] = last.innerHTML;\n                last.parentElement?.removeChild(last);\n                question.html = element.innerHTML;\n\n                return;\n            }\n\n            // It's inside the question content, treat next element.\n            last = matches.pop();\n        }\n    }\n\n    /**\n     * Removes the scripts from a question's HTML and adds it in a new 'scriptsCode' property.\n     * It will also search for init_question functions of the question type and add the object to an 'initObjects' property.\n     *\n     * @param question Question.\n     * @param usageId Usage ID.\n     */\n    extractQuestionScripts(question: CoreQuestionQuestion, usageId?: number): void {\n        question.scriptsCode = '';\n        question.initObjects = undefined;\n        question.amdArgs = undefined;\n\n        // Search the scripts.\n        const matches = question.html?.match(/<script[^>]*>[\\s\\S]*?<\\/script>/mg);\n        if (!matches) {\n            // No scripts, stop.\n            return;\n        }\n\n        matches.forEach((scriptCode) => {\n            if (scriptCode.match(/<script[^>]+type=\"math\\/tex\"/m)) {\n                // Don't remove math/tex scripts, they're needed to render the math expressions.\n                return;\n            }\n\n            // Add the script to scriptsCode and remove it from html.\n            question.scriptsCode += scriptCode;\n            question.html = question.html.replace(scriptCode, '');\n\n            // Search init_question functions for this type.\n            const initMatches = scriptCode.match(new RegExp('M.qtype_' + question.type + '.init_question\\\\(.*?}\\\\);', 'mg'));\n            if (initMatches) {\n                let initMatch = initMatches.pop();\n\n                if (initMatch) {\n                    // Remove start and end of the match, we only want the object.\n                    initMatch = initMatch.replace('M.qtype_' + question.type + '.init_question(', '');\n                    initMatch = initMatch.substring(0, initMatch.length - 2);\n\n                    // Try to convert it to an object and add it to the question.\n                    question.initObjects = CoreTextUtils.parseJSON(initMatch, null);\n                }\n            }\n\n            const amdRegExp = new RegExp('require\\\\(\\\\[[\"\\']qtype_' + question.type + '/question[\"\\']\\\\],[^f]*' +\n                'function\\\\(amd\\\\)[^\\\\{]*\\\\{[^a]*amd\\\\.init\\\\(([\"\\'](q|question-' + usageId + '-)' + question.slot +\n                '[\"\\'].*?)\\\\);', 'm');\n            const amdMatch = scriptCode.match(amdRegExp);\n\n            if (amdMatch) {\n                // Try to convert the arguments to an array and add them to the question.\n                question.amdArgs = CoreTextUtils.parseJSON('[' + amdMatch[1] + ']', null);\n            }\n        });\n    }\n\n    /**\n     * Get the names of all the inputs inside an HTML code.\n     * This function will return an object where the keys are the input names. The values will always be true.\n     * This is in order to make this function compatible with other functions like CoreQuestionProvider.getBasicAnswers.\n     *\n     * @param html HTML code.\n     * @returns Object where the keys are the names.\n     */\n    getAllInputNamesFromHtml(html: string): Record<string, boolean> {\n        const element = CoreDomUtils.convertToElement('<form>' + html + '</form>');\n        const form = <HTMLFormElement> element.children[0];\n        const answers: Record<string, boolean> = {};\n\n        // Search all input elements.\n        Array.from(form.elements).forEach((element: HTMLInputElement) => {\n            const name = element.name || '';\n\n            // Ignore flag and submit inputs.\n            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {\n                return;\n            }\n\n            answers[CoreQuestion.removeQuestionPrefix(name)] = true;\n        });\n\n        return answers;\n    }\n\n    /**\n     * Retrieve the answers entered in a form.\n     * We don't use ngModel because it doesn't detect changes done by JavaScript and some questions might do that.\n     *\n     * @param form Form.\n     * @returns Object with the answers.\n     */\n    getAnswersFromForm(form: HTMLFormElement): CoreQuestionsAnswers {\n        if (!form || !form.elements) {\n            return {};\n        }\n\n        const answers: CoreQuestionsAnswers = {};\n        const elements = Array.from(form.elements);\n\n        elements.forEach((element: HTMLInputElement) => {\n            const name = element.name || element.getAttribute('ng-reflect-name') || '';\n\n            // Ignore flag and submit inputs.\n            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {\n                return;\n            }\n\n            // Get the value.\n            if (element.type == 'checkbox') {\n                answers[name] = !!element.checked;\n            } else if (element.type == 'radio') {\n                if (element.checked) {\n                    answers[name] = element.value;\n                }\n            } else {\n                answers[name] = element.value;\n            }\n        });\n\n        return answers;\n    }\n\n    /**\n     * Given an HTML code with list of attachments, returns the list of attached files (filename and fileurl).\n     * Please take into account that this function will treat all the anchors in the HTML, you should provide\n     * an HTML containing only the attachments anchors.\n     *\n     * @param html HTML code to search in.\n     * @returns Attachments.\n     */\n    getQuestionAttachmentsFromHtml(html: string): CoreWSFile[] {\n        const element = CoreDomUtils.convertToElement(html);\n\n        // Remove the filemanager (area to attach files to a question).\n        CoreDomUtils.removeElement(element, 'div[id*=filemanager]');\n\n        // Search the anchors.\n        const anchors = Array.from(element.querySelectorAll('a'));\n        const attachments: CoreWSFile[] = [];\n\n        anchors.forEach((anchor) => {\n            let content = anchor.innerHTML;\n\n            // Check anchor is valid.\n            if (anchor.href && content) {\n                content = CoreTextUtils.cleanTags(content, { singleLine: true, trim: true });\n                attachments.push({\n                    filename: content,\n                    fileurl: anchor.href,\n                });\n            }\n        });\n\n        return attachments;\n    }\n\n    /**\n     * Get the sequence check from a question HTML.\n     *\n     * @param html Question's HTML.\n     * @returns Object with the sequencecheck name and value.\n     */\n    getQuestionSequenceCheckFromHtml(html: string): { name: string; value: string } | undefined {\n        if (!html) {\n            return;\n        }\n\n        // Search the input holding the sequencecheck.\n        const element = CoreDomUtils.convertToElement(html);\n        const input = <HTMLInputElement> element.querySelector('input[name*=sequencecheck]');\n\n        if (!input || input.name === undefined || input.value === undefined) {\n            return;\n        }\n\n        return {\n            name: input.name,\n            value: input.value,\n        };\n    }\n\n    /**\n     * Get the CSS class for a question based on its state.\n     *\n     * @param name Question's state name.\n     * @returns State class.\n     */\n    getQuestionStateClass(name: string): string {\n        const state = CoreQuestion.getState(name);\n\n        return state ? state.class : '';\n    }\n\n    /**\n     * Return the files of a certain response file area.\n     *\n     * @param question Question.\n     * @param areaName Name of the area, e.g. 'attachments'.\n     * @returns List of files.\n     */\n    getResponseFileAreaFiles(question: CoreQuestionQuestion, areaName: string): CoreWSFile[] {\n        if (!question.responsefileareas) {\n            return [];\n        }\n\n        const area = question.responsefileareas.find((area) => area.area == areaName);\n\n        return area?.files || [];\n    }\n\n    /**\n     * Get files stored for a question.\n     *\n     * @param question Question.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the files.\n     */\n    getStoredQuestionFiles(\n        question: CoreQuestionQuestion,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<(FileEntry | DirectoryEntry)[]> {\n        const questionComponentId = CoreQuestion.getQuestionComponentId(question, componentId);\n        const folderPath = CoreQuestion.getQuestionFolder(question.type, component, questionComponentId, siteId);\n\n        return CoreFile.getDirectoryContents(folderPath);\n    }\n\n    /**\n     * Get the validation error message from a question HTML if it's there.\n     *\n     * @param html Question's HTML.\n     * @returns Validation error message if present.\n     */\n    getValidationErrorFromHtml(html: string): string | undefined {\n        const element = CoreDomUtils.convertToElement(html);\n\n        return CoreDomUtils.getContentsOfElement(element, '.validationerror');\n    }\n\n    /**\n     * Check if some HTML contains draft file URLs for the current site.\n     *\n     * @param html Question's HTML.\n     * @returns Whether it contains draft files URLs.\n     */\n    hasDraftFileUrls(html: string): boolean {\n        let url = CoreSites.getCurrentSite()?.getURL();\n        if (!url) {\n            return false;\n        }\n\n        if (url.slice(-1) != '/') {\n            url = url += '/';\n        }\n        url += 'draftfile.php';\n\n        return html.indexOf(url) != -1;\n    }\n\n    /**\n     * Load local answers of a question.\n     *\n     * @param question Question.\n     * @param component Component.\n     * @param attemptId Attempt ID.\n     * @returns Promise resolved when done.\n     */\n    async loadLocalAnswers(question: CoreQuestionQuestion, component: string, attemptId: number): Promise<void> {\n        const answers = await CoreUtils.ignoreErrors(\n            CoreQuestion.getQuestionAnswers(component, attemptId, question.slot),\n        );\n\n        if (answers) {\n            question.localAnswers = CoreQuestion.convertAnswersArrayToObject(answers, true);\n        } else {\n            question.localAnswers = {};\n        }\n    }\n\n    /**\n     * For each input element found in the HTML, search if there's a local answer stored and\n     * override the HTML's value with the local one.\n     *\n     * @param question Question.\n     */\n    loadLocalAnswersInHtml(question: CoreQuestionQuestion): void {\n        const element = CoreDomUtils.convertToElement('<form>' + question.html + '</form>');\n        const form = <HTMLFormElement> element.children[0];\n\n        // Search all input elements.\n        Array.from(form.elements).forEach((element: HTMLInputElement | HTMLButtonElement) => {\n            let name = element.name || '';\n            // Ignore flag and submit inputs.\n            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON' ||\n                    !question.localAnswers) {\n                return;\n            }\n\n            // Search if there's a local answer.\n            name = CoreQuestion.removeQuestionPrefix(name);\n            if (question.localAnswers[name] === undefined) {\n                if (Object.keys(question.localAnswers).length && element.type == 'radio') {\n                    // No answer stored, but there is a sequencecheck or similar. This means the user cleared his choice.\n                    element.removeAttribute('checked');\n                }\n\n                return;\n            }\n\n            if (element.tagName == 'TEXTAREA') {\n                // Just put the answer inside the textarea.\n                element.innerHTML = question.localAnswers[name];\n            } else if (element.tagName == 'SELECT') {\n                // Search the selected option and select it.\n                const selected = element.querySelector('option[value=\"' + question.localAnswers[name] + '\"]');\n                if (selected) {\n                    selected.setAttribute('selected', 'selected');\n                }\n            } else if (element.type == 'radio') {\n                // Check if this radio is selected.\n                if (element.value == question.localAnswers[name]) {\n                    element.setAttribute('checked', 'checked');\n                } else {\n                    element.removeAttribute('checked');\n                }\n            } else if (element.type == 'checkbox') {\n                // Check if this checkbox is checked.\n                if (CoreUtils.isTrueOrOne(question.localAnswers[name])) {\n                    element.setAttribute('checked', 'checked');\n                } else {\n                    element.removeAttribute('checked');\n                }\n            } else {\n                // Put the answer in the value.\n                element.setAttribute('value', question.localAnswers[name]);\n            }\n        });\n\n        // Update the question HTML.\n        question.html = form.innerHTML;\n    }\n\n    /**\n     * Prefetch the files in a question HTML.\n     *\n     * @param question Question.\n     * @param component The component to link the files to. If not defined, question component.\n     * @param componentId An ID to use in conjunction with the component. If not defined, question ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param usageId Usage ID. Required in Moodle 3.7+.\n     * @returns Promise resolved when all the files have been downloaded.\n     */\n    async prefetchQuestionFiles(\n        question: CoreQuestionQuestion,\n        component?: string,\n        componentId?: string | number,\n        siteId?: string,\n        usageId?: number,\n    ): Promise<void> {\n        if (!component) {\n            component = CoreQuestionProvider.COMPONENT;\n            componentId = question.questionnumber;\n        }\n\n        const files = CoreQuestionDelegate.getAdditionalDownloadableFiles(question, usageId) || [];\n\n        files.push(...CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(question.html));\n\n        const site = await CoreSites.getSite(siteId);\n\n        const treated: Record<string, boolean> = {};\n\n        await Promise.all(files.map(async (file) => {\n            const timemodified = file.timemodified || 0;\n            const fileUrl = CoreFileHelper.getFileUrl(file);\n\n            if (treated[fileUrl]) {\n                return;\n            }\n            treated[fileUrl] = true;\n\n            if (!site.canDownloadFiles() && site.isSitePluginFileUrl(fileUrl)) {\n                return;\n            }\n\n            if (CoreUrlUtils.isThemeImageUrl(fileUrl) && fileUrl.indexOf('flagged') > -1) {\n                // Ignore flag images.\n                return;\n            }\n\n            await CoreFilepool.addToQueueByUrl(site.getId(), fileUrl, component, componentId, timemodified);\n        }));\n    }\n\n    /**\n     * Prepare and return the answers.\n     *\n     * @param questions The list of questions.\n     * @param answers The input data.\n     * @param offline True if data should be saved in offline.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with answers to send to server.\n     */\n    async prepareAnswers(\n        questions: CoreQuestionQuestion[],\n        answers: CoreQuestionsAnswers,\n        offline: boolean,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<CoreQuestionsAnswers> {\n        await CoreUtils.allPromises(questions.map(async (question) => {\n            await CoreQuestionDelegate.prepareAnswersForQuestion(\n                question,\n                answers,\n                offline,\n                component,\n                componentId,\n                siteId,\n            );\n        }));\n\n        return answers;\n    }\n\n    /**\n     * Replace Moodle's correct/incorrect classes with the Mobile ones.\n     *\n     * @param element DOM element.\n     */\n    replaceCorrectnessClasses(element: HTMLElement): void {\n        CoreDomUtils.replaceClassesInElement(element, {\n            correct: 'core-question-answer-correct',\n            incorrect: 'core-question-answer-incorrect',\n        });\n    }\n\n    /**\n     * Replace Moodle's feedback classes with the Mobile ones.\n     *\n     * @param element DOM element.\n     */\n    replaceFeedbackClasses(element: HTMLElement): void {\n        CoreDomUtils.replaceClassesInElement(element, {\n            outcome: 'core-question-feedback-container core-question-feedback-padding',\n            specificfeedback: 'core-question-feedback-container core-question-feedback-inline',\n        });\n    }\n\n    /**\n     * Search a behaviour button in a certain question property containing HTML.\n     *\n     * @param question Question.\n     * @param htmlProperty The name of the property containing the HTML to search.\n     * @param selector The selector to find the button.\n     * @returns Whether the button is found.\n     */\n    protected searchBehaviourButton(question: CoreQuestionQuestion, htmlProperty: string, selector: string): boolean {\n        const element = CoreDomUtils.convertToElement(question[htmlProperty]);\n\n        const button = element.querySelector<HTMLElement>(selector);\n        if (!button) {\n            return false;\n        }\n\n        // Add a behaviour button to the question's \"behaviourButtons\" property.\n        this.addBehaviourButton(question, button);\n\n        // Remove the button from the HTML.\n        button.parentElement?.removeChild(button);\n\n        // Update the question's html.\n        question[htmlProperty] = element.innerHTML;\n\n        return true;\n    }\n\n    /**\n     * Convenience function to show a parsing error and abort.\n     *\n     * @param onAbort If supplied, will emit an event.\n     * @param error Error to show.\n     */\n    showComponentError(onAbort: EventEmitter<void>, error?: string): void {\n        // Prevent consecutive errors.\n        const now = Date.now();\n        if (now - this.lastErrorShown > 500) {\n            this.lastErrorShown = now;\n            CoreDomUtils.showErrorModalDefault(error || '', 'addon.mod_quiz.errorparsequestions', true);\n        }\n\n        onAbort?.emit();\n    }\n\n    /**\n     * Treat correctness icons, replacing them with local icons and setting click events to show the feedback if needed.\n     *\n     * @param element DOM element.\n     */\n    treatCorrectnessIcons(element: HTMLElement): void {\n        const icons = <HTMLElement[]> Array.from(element.querySelectorAll('img.icon, img.questioncorrectnessicon, i.icon'));\n        icons.forEach((icon) => {\n            let correct = false;\n\n            if ('src' in icon) {\n                if ((icon as HTMLImageElement).src.indexOf('correct') >= 0) {\n                    correct = true;\n                } else if ((icon as HTMLImageElement).src.indexOf('incorrect') < 0 ) {\n                    return;\n                }\n            } else {\n                const classList = icon.classList.toString();\n                if (classList.indexOf('fa-check') >= 0) {\n                    correct = true;\n                } else if (classList.indexOf('fa-xmark') < 0 && classList.indexOf('fa-remove') < 0) {\n                    return;\n                }\n            }\n\n            // Replace the icon with the font version.\n            const newIcon: HTMLIonIconElement = document.createElement('ion-icon');\n\n            if (correct) {\n                const iconName = 'check';\n                newIcon.setAttribute('name', `fas-${iconName}`);\n                newIcon.setAttribute('src', CoreIcons.getIconSrc('font-awesome', 'solid', iconName));\n                newIcon.className = 'core-correct-icon ion-color ion-color-success questioncorrectnessicon';\n            } else {\n                const iconName = 'xmark';\n                newIcon.setAttribute('name', `fas-${iconName}`);\n                newIcon.setAttribute('src', CoreIcons.getIconSrc('font-awesome', 'solid', iconName));\n                newIcon.className = 'core-correct-icon ion-color ion-color-danger questioncorrectnessicon';\n            }\n\n            newIcon.title = icon.title;\n            newIcon.setAttribute('aria-label', icon.title);\n            icon.parentNode?.replaceChild(newIcon, icon);\n        });\n\n        // Treat legacy markup used before MDL-77856 (4.2).\n        const spans = Array.from(element.querySelectorAll('.feedbackspan.accesshide'));\n        spans.forEach((span) => {\n            // Search if there's a hidden feedback for this element.\n            const icon = <HTMLElement> span.previousSibling;\n            if (!icon || !icon.classList.contains('icon') && !icon.classList.contains('questioncorrectnessicon')) {\n                return;\n            }\n\n            icon.classList.add('questioncorrectnessicon');\n\n            if (span.innerHTML) {\n                // There's a hidden feedback. Mark the icon as tappable.\n                // The click listener is only added if treatCorrectnessIconsClicks is called.\n                icon.setAttribute('tappable', '');\n            }\n        });\n    }\n\n    /**\n     * Add click listeners to all tappable correctness icons.\n     *\n     * @param element DOM element.\n     * @param component The component to use when viewing the feedback.\n     * @param componentId An ID to use in conjunction with the component.\n     * @param contextLevel The context level.\n     * @param contextInstanceId Instance ID related to the context.\n     * @param courseId Course ID the text belongs to. It can be used to improve performance with filters.\n     */\n    treatCorrectnessIconsClicks(\n        element: HTMLElement,\n        component?: string,\n        componentId?: number,\n        contextLevel?: string,\n        contextInstanceId?: number,\n        courseId?: number,\n    ): void {\n        const icons = <HTMLElement[]> Array.from(element.querySelectorAll('ion-icon.questioncorrectnessicon'));\n        const title = Translate.instant('core.question.feedback');\n        const getClickableFeedback = (icon: HTMLElement) => {\n            const parentElement = icon.parentElement;\n            const parentIsClickable = parentElement instanceof HTMLButtonElement || parentElement instanceof HTMLAnchorElement;\n\n            if (parentElement && parentIsClickable && parentElement.dataset.toggle === 'popover') {\n                return {\n                    element: parentElement,\n                    html: parentElement?.dataset.content,\n                };\n            }\n\n            // Support legacy icons used before MDL-77856 (4.2).\n            if (icon.hasAttribute('tappable')) {\n                return {\n                    element: icon,\n                    html: parentElement?.querySelector('.feedbackspan.accesshide')?.innerHTML,\n                };\n            }\n\n            return null;\n        };\n\n        icons.forEach(icon => {\n            const target = getClickableFeedback(icon);\n\n            if (!target || !target.html) {\n                return;\n            }\n\n            // There's a hidden feedback, show it when the icon is clicked.\n            target.element.dataset.disabledA11yClicks = 'true';\n            target.element.addEventListener('click', event => {\n                event.preventDefault();\n                event.stopPropagation();\n\n                CoreTextUtils.viewText(title, target.html ?? '', {\n                    component: component,\n                    componentId: componentId,\n                    filter: true,\n                    contextLevel: contextLevel,\n                    instanceId: contextInstanceId,\n                    courseId: courseId,\n                });\n            });\n        });\n    }\n\n}\n\nexport const CoreQuestionHelper = makeSingleton(CoreQuestionHelperProvider);\n\n/**\n * Question with calculated data.\n */\nexport type CoreQuestionQuestion = CoreQuestionQuestionParsed & {\n    localAnswers?: Record<string, string>;\n    commentHtml?: string;\n    feedbackHtml?: string;\n    infoHtml?: string;\n    behaviourButtons?: CoreQuestionBehaviourButton[];\n    behaviourCertaintyOptions?: CoreQuestionBehaviourCertaintyOption[];\n    behaviourCertaintySelected?: string;\n    behaviourSeenInput?: { name: string; value: string };\n    scriptsCode?: string;\n    initObjects?: Record<string, unknown> | null;\n    amdArgs?: unknown[] | null;\n};\n\n/**\n * Question behaviour button.\n */\nexport type CoreQuestionBehaviourButton = {\n    id: string;\n    name: string;\n    value: string;\n    disabled: boolean;\n};\n\n/**\n * Question behaviour certainty option.\n */\nexport type CoreQuestionBehaviourCertaintyOption = CoreQuestionBehaviourButton & {\n    text: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}