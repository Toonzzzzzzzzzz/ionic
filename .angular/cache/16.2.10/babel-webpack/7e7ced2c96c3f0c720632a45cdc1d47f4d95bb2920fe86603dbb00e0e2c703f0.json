{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBaseProvider, CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetwork } from '@services/network';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { AddonCalendar, AddonCalendarProvider } from './calendar';\nimport { AddonCalendarOffline } from './calendar-offline';\nimport { AddonCalendarHelper } from './calendar-helper';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreSync } from '@services/sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync calendar.\n */\nexport class AddonCalendarSyncProvider extends CoreSyncBaseProvider {\n  constructor() {\n    super('AddonCalendarSync');\n    this.componentTranslatableString = 'addon.calendar.calendarevent';\n  }\n  /**\n   * Try to synchronize all events in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllEvents(siteId, force = false) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this.syncOnSites('all calendar events', siteId => _this.syncAllEventsFunc(force, siteId), siteId);\n    })();\n  }\n  /**\n   * Sync all events on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllEventsFunc(force = false, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const result = force ? yield _this2.syncEvents(siteId) : yield _this2.syncEventsIfNeeded(siteId);\n      if (result !== null && result !== void 0 && result.updated) {\n        // Sync successful, send event.\n        CoreEvents.trigger(AddonCalendarSyncProvider.AUTO_SYNCED, result, siteId);\n      }\n    })();\n  }\n  /**\n   * Sync a site events only if a certain time has passed since the last time.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the events are synced or if it doesn't need to be synced.\n   */\n  syncEventsIfNeeded(siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const needed = yield _this3.isSyncNeeded(AddonCalendarSyncProvider.SYNC_ID, siteId);\n      if (needed) {\n        return _this3.syncEvents(siteId);\n      }\n    })();\n  }\n  /**\n   * Synchronize all offline events of a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncEvents(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const currentSyncPromise = _this4.getOngoingSync(AddonCalendarSyncProvider.SYNC_ID, siteId);\n      if (currentSyncPromise) {\n        // There's already a sync ongoing for this site, return the promise.\n        return currentSyncPromise;\n      }\n      _this4.logger.debug('Try to sync calendar events for site ' + siteId);\n      // Get offline events.\n      const syncPromise = _this4.performSyncEvents(siteId);\n      return _this4.addOngoingSync(AddonCalendarSyncProvider.SYNC_ID, syncPromise, siteId);\n    })();\n  }\n  /**\n   * Sync user preferences of a site.\n   *\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  performSyncEvents(siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        events: [],\n        offlineIdMap: {},\n        deleted: [],\n        toinvalidate: [],\n        updated: false\n      };\n      const eventIds = yield CoreUtils.ignoreErrors(AddonCalendarOffline.getAllEventsIds(siteId), []);\n      if (eventIds.length > 0) {\n        if (!CoreNetwork.isOnline()) {\n          // Cannot sync in offline.\n          throw new CoreNetworkError();\n        }\n        const promises = eventIds.map(eventId => _this5.syncOfflineEvent(eventId, result, siteId));\n        yield CoreUtils.allPromises(promises);\n        if (result.updated) {\n          // Data has been sent to server. Now invalidate the WS calls.\n          const promises = [AddonCalendar.invalidateEventsList(siteId), AddonCalendarHelper.refreshAfterChangeEvents(result.toinvalidate, siteId)];\n          yield CoreUtils.ignoreErrors(Promise.all(promises));\n        }\n      }\n      // Sync finished, set sync time.\n      yield CoreUtils.ignoreErrors(_this5.setSyncTime(AddonCalendarSyncProvider.SYNC_ID, siteId));\n      // All done, return the result.\n      return result;\n    })();\n  }\n  /**\n   * Synchronize an offline event.\n   *\n   * @param eventId The event ID to sync.\n   * @param result Object where to store the result of the sync.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncOfflineEvent(eventId, result, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // Verify that event isn't blocked.\n      if (CoreSync.isBlocked(AddonCalendarProvider.COMPONENT, eventId, siteId)) {\n        _this6.logger.debug('Cannot sync event ' + eventId + ' because it is blocked.');\n        throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', {\n          $a: Translate.instant('addon.calendar.calendarevent')\n        }));\n      }\n      // First of all, check if the event has been deleted.\n      try {\n        const data = yield AddonCalendarOffline.getDeletedEvent(eventId, siteId);\n        // Delete the event.\n        try {\n          yield AddonCalendar.deleteEventOnline(data.id, !!data.repeat, siteId);\n          result.updated = true;\n          result.deleted.push(eventId);\n          // Event sent, delete the offline data.\n          const promises = [];\n          promises.push(AddonCalendarOffline.unmarkDeleted(eventId, siteId));\n          promises.push(AddonCalendarOffline.deleteEvent(eventId, siteId).catch(() => {\n            // Ignore errors, maybe there was no edit data.\n          }));\n          // We need the event data to invalidate it. Get it from local DB.\n          promises.push(AddonCalendar.getEventFromLocalDb(eventId, siteId).then(event => {\n            result.toinvalidate.push({\n              id: event.id,\n              repeatid: event.repeatid,\n              timestart: event.timestart,\n              repeated: data !== null && data !== void 0 && data.repeat ? event.eventcount || 1 : 1\n            });\n            return;\n          }).catch(() => {\n            // Ignore errors.\n          }));\n          yield Promise.all(promises);\n        } catch (error) {\n          if (!CoreUtils.isWebServiceError(error)) {\n            // Local error, reject.\n            throw error;\n          }\n          // The WebService has thrown an error, this means that the event cannot be created. Delete it.\n          result.updated = true;\n          const promises = [];\n          promises.push(AddonCalendarOffline.unmarkDeleted(eventId, siteId));\n          promises.push(AddonCalendarOffline.deleteEvent(eventId, siteId).catch(() => {\n            // Ignore errors, maybe there was no edit data.\n          }));\n          yield Promise.all(promises);\n          // Event deleted, add a warning.\n          _this6.addOfflineDataDeletedWarning(result.warnings, data.name, error);\n        }\n        return;\n      } catch (_unused) {\n        // Not deleted.\n      }\n      // Not deleted. Now get the event data.\n      const event = yield AddonCalendarOffline.getEvent(eventId, siteId);\n      // Try to send the data.\n      const data = Object.assign(CoreUtils.clone(event), {\n        description: {\n          text: event.description || '',\n          format: 1,\n          itemid: 0 // Files not supported yet.\n        }\n      }); // Clone the object because it will be modified in the submit function.\n      try {\n        const newEvent = yield AddonCalendar.submitEventOnline(eventId, data, siteId);\n        result.updated = true;\n        result.events.push(newEvent);\n        if (eventId < 0) {\n          result.offlineIdMap[eventId] = newEvent.id;\n        }\n        // Add data to invalidate.\n        const numberOfRepetitions = data.repeat ? data.repeats : data.repeateditall && newEvent.repeatid ? newEvent.eventcount : 1;\n        result.toinvalidate.push({\n          id: newEvent.id,\n          repeatid: newEvent.repeatid,\n          timestart: newEvent.timestart,\n          repeated: numberOfRepetitions || 1\n        });\n        // Event sent, delete the offline data.\n        return AddonCalendarOffline.deleteEvent(event.id, siteId);\n      } catch (error) {\n        if (!CoreUtils.isWebServiceError(error)) {\n          // Local error, reject.\n          throw error;\n        }\n        // The WebService has thrown an error, this means that the event cannot be created. Delete it.\n        result.updated = true;\n        yield AddonCalendarOffline.deleteEvent(event.id, siteId);\n        // Event deleted, add a warning.\n        _this6.addOfflineDataDeletedWarning(result.warnings, event.name, error);\n      }\n    })();\n  }\n}\n_class = AddonCalendarSyncProvider;\n_class.AUTO_SYNCED = 'addon_calendar_autom_synced';\n_class.MANUAL_SYNCED = 'addon_calendar_manual_synced';\n_class.SYNC_ID = 'calendar';\n_class.ɵfac = function AddonCalendarSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonCalendarSync = makeSingleton(AddonCalendarSyncProvider);","map":{"version":3,"names":["CoreSyncBaseProvider","CoreSyncBlockedError","CoreNetwork","CoreEvents","CoreSites","CoreUtils","AddonCalendar","AddonCalendarProvider","AddonCalendarOffline","AddonCalendarHelper","makeSingleton","Translate","CoreSync","CoreNetworkError","AddonCalendarSyncProvider","constructor","componentTranslatableString","syncAllEvents","siteId","force","_this","_asyncToGenerator","syncOnSites","syncAllEventsFunc","_this2","result","syncEvents","syncEventsIfNeeded","updated","trigger","AUTO_SYNCED","_this3","getCurrentSiteId","needed","isSyncNeeded","SYNC_ID","_this4","currentSyncPromise","getOngoingSync","logger","debug","syncPromise","performSyncEvents","addOngoingSync","_this5","warnings","events","offlineIdMap","deleted","toinvalidate","eventIds","ignoreErrors","getAllEventsIds","length","isOnline","promises","map","eventId","syncOfflineEvent","allPromises","invalidateEventsList","refreshAfterChangeEvents","Promise","all","setSyncTime","_this6","isBlocked","COMPONENT","instant","$a","data","getDeletedEvent","deleteEventOnline","id","repeat","push","unmarkDeleted","deleteEvent","catch","getEventFromLocalDb","then","event","repeatid","timestart","repeated","eventcount","error","isWebServiceError","addOfflineDataDeletedWarning","name","_unused","getEvent","Object","assign","clone","description","text","format","itemid","newEvent","submitEventOnline","numberOfRepetitions","repeats","repeateditall","_class","MANUAL_SYNCED","factory","ɵfac","providedIn","AddonCalendarSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/calendar/services/calendar-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSyncBaseProvider, CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetwork } from '@services/network';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport {\n    AddonCalendar,\n    AddonCalendarEvent,\n    AddonCalendarProvider,\n    AddonCalendarSubmitCreateUpdateFormDataWSParams,\n} from './calendar';\nimport { AddonCalendarOffline } from './calendar-offline';\nimport { AddonCalendarHelper } from './calendar-helper';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport moment from 'moment-timezone';\n\n/**\n * Service to sync calendar.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonCalendarSyncProvider extends CoreSyncBaseProvider<AddonCalendarSyncEvents> {\n\n    static readonly AUTO_SYNCED = 'addon_calendar_autom_synced';\n    static readonly MANUAL_SYNCED = 'addon_calendar_manual_synced';\n    static readonly SYNC_ID = 'calendar';\n\n    protected componentTranslatableString = 'addon.calendar.calendarevent';\n\n    constructor() {\n        super('AddonCalendarSync');\n    }\n\n    /**\n     * Try to synchronize all events in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    async syncAllEvents(siteId?: string, force = false): Promise<void> {\n        await this.syncOnSites('all calendar events', (siteId) => this.syncAllEventsFunc(force, siteId), siteId);\n    }\n\n    /**\n     * Sync all events on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllEventsFunc(force = false, siteId?: string): Promise<void> {\n        const result = force\n            ? await this.syncEvents(siteId)\n            : await this.syncEventsIfNeeded(siteId);\n\n        if (result?.updated) {\n            // Sync successful, send event.\n            CoreEvents.trigger(AddonCalendarSyncProvider.AUTO_SYNCED, result, siteId);\n        }\n    }\n\n    /**\n     * Sync a site events only if a certain time has passed since the last time.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the events are synced or if it doesn't need to be synced.\n     */\n    async syncEventsIfNeeded(siteId?: string): Promise<AddonCalendarSyncEvents | undefined> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const needed = await this.isSyncNeeded(AddonCalendarSyncProvider.SYNC_ID, siteId);\n\n        if (needed) {\n            return this.syncEvents(siteId);\n        }\n    }\n\n    /**\n     * Synchronize all offline events of a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    async syncEvents(siteId?: string): Promise<AddonCalendarSyncEvents> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(AddonCalendarSyncProvider.SYNC_ID, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this site, return the promise.\n            return currentSyncPromise;\n        }\n\n        this.logger.debug('Try to sync calendar events for site ' + siteId);\n\n        // Get offline events.\n        const syncPromise = this.performSyncEvents(siteId);\n\n        return this.addOngoingSync(AddonCalendarSyncProvider.SYNC_ID, syncPromise, siteId);\n    }\n\n    /**\n     * Sync user preferences of a site.\n     *\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async performSyncEvents(siteId: string): Promise<AddonCalendarSyncEvents> {\n        const result: AddonCalendarSyncEvents = {\n            warnings: [],\n            events: [],\n            offlineIdMap: {},\n            deleted: [],\n            toinvalidate: [],\n            updated: false,\n        };\n\n        const eventIds: number[] = await CoreUtils.ignoreErrors(AddonCalendarOffline.getAllEventsIds(siteId), []);\n\n        if (eventIds.length > 0) {\n            if (!CoreNetwork.isOnline()) {\n                // Cannot sync in offline.\n                throw new CoreNetworkError();\n            }\n\n            const promises = eventIds.map((eventId) => this.syncOfflineEvent(eventId, result, siteId));\n\n            await CoreUtils.allPromises(promises);\n\n            if (result.updated) {\n\n                // Data has been sent to server. Now invalidate the WS calls.\n                const promises = [\n                    AddonCalendar.invalidateEventsList(siteId),\n                    AddonCalendarHelper.refreshAfterChangeEvents(result.toinvalidate, siteId),\n                ];\n\n                await CoreUtils.ignoreErrors(Promise.all(promises));\n            }\n        }\n\n        // Sync finished, set sync time.\n        await CoreUtils.ignoreErrors(this.setSyncTime(AddonCalendarSyncProvider.SYNC_ID, siteId));\n\n        // All done, return the result.\n        return result;\n    }\n\n    /**\n     * Synchronize an offline event.\n     *\n     * @param eventId The event ID to sync.\n     * @param result Object where to store the result of the sync.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    protected async syncOfflineEvent(eventId: number, result: AddonCalendarSyncEvents, siteId?: string): Promise<void> {\n\n        // Verify that event isn't blocked.\n        if (CoreSync.isBlocked(AddonCalendarProvider.COMPONENT, eventId, siteId)) {\n            this.logger.debug('Cannot sync event ' + eventId + ' because it is blocked.');\n\n            throw new CoreSyncBlockedError(Translate.instant(\n                'core.errorsyncblocked',\n                { $a: Translate.instant('addon.calendar.calendarevent') },\n            ));\n        }\n\n        // First of all, check if the event has been deleted.\n        try {\n            const data = await AddonCalendarOffline.getDeletedEvent(eventId, siteId);\n            // Delete the event.\n            try {\n                await AddonCalendar.deleteEventOnline(data.id, !!data.repeat, siteId);\n\n                result.updated = true;\n                result.deleted.push(eventId);\n\n                // Event sent, delete the offline data.\n                const promises: Promise<void>[] = [];\n\n                promises.push(AddonCalendarOffline.unmarkDeleted(eventId, siteId));\n                promises.push(AddonCalendarOffline.deleteEvent(eventId, siteId).catch(() => {\n                    // Ignore errors, maybe there was no edit data.\n                }));\n\n                // We need the event data to invalidate it. Get it from local DB.\n                promises.push(AddonCalendar.getEventFromLocalDb(eventId, siteId).then((event) => {\n                    result.toinvalidate.push({\n                        id: event.id,\n                        repeatid: event.repeatid,\n                        timestart: event.timestart,\n                        repeated: data?.repeat ? (event as AddonCalendarEvent).eventcount || 1 : 1,\n                    });\n\n                    return;\n                }).catch(() => {\n                    // Ignore errors.\n                }));\n\n                await Promise.all(promises);\n            } catch (error) {\n\n                if (!CoreUtils.isWebServiceError(error)) {\n                    // Local error, reject.\n                    throw error;\n                }\n\n                // The WebService has thrown an error, this means that the event cannot be created. Delete it.\n                result.updated = true;\n\n                const promises: Promise<void>[] = [];\n\n                promises.push(AddonCalendarOffline.unmarkDeleted(eventId, siteId));\n                promises.push(AddonCalendarOffline.deleteEvent(eventId, siteId).catch(() => {\n                    // Ignore errors, maybe there was no edit data.\n                }));\n\n                await Promise.all(promises);\n\n                // Event deleted, add a warning.\n                this.addOfflineDataDeletedWarning(result.warnings, data.name, error);\n            }\n\n            return;\n        } catch {\n            // Not deleted.\n        }\n\n        // Not deleted. Now get the event data.\n        const event = await AddonCalendarOffline.getEvent(eventId, siteId);\n\n        // Try to send the data.\n        const data: AddonCalendarSubmitCreateUpdateFormDataWSParams = Object.assign(\n            CoreUtils.clone(event),\n            {\n                description: {\n                    text: event.description || '',\n                    format: 1,\n                    itemid: 0, // Files not supported yet.\n                },\n            },\n        ); // Clone the object because it will be modified in the submit function.\n\n        try {\n            const newEvent = await AddonCalendar.submitEventOnline(eventId, data, siteId);\n\n            result.updated = true;\n            result.events.push(newEvent);\n            if (eventId < 0) {\n                result.offlineIdMap[eventId] = newEvent.id;\n            }\n\n            // Add data to invalidate.\n            const numberOfRepetitions = data.repeat ? data.repeats :\n                (data.repeateditall && newEvent.repeatid ? newEvent.eventcount : 1);\n\n            result.toinvalidate.push({\n                id: newEvent.id,\n                repeatid: newEvent.repeatid,\n                timestart: newEvent.timestart,\n                repeated: numberOfRepetitions || 1,\n            });\n\n            // Event sent, delete the offline data.\n            return AddonCalendarOffline.deleteEvent(event.id, siteId);\n\n        } catch (error) {\n            if (!CoreUtils.isWebServiceError(error)) {\n                // Local error, reject.\n                throw error;\n            }\n\n            // The WebService has thrown an error, this means that the event cannot be created. Delete it.\n            result.updated = true;\n\n            await AddonCalendarOffline.deleteEvent(event.id, siteId);\n\n            // Event deleted, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, event.name, error);\n        }\n    }\n\n}\n\nexport const AddonCalendarSync = makeSingleton(AddonCalendarSyncProvider);\n\nexport type AddonCalendarSyncEvents = CoreSyncResult & {\n    events: AddonCalendarEvent[];\n    offlineIdMap: Record<number, number>; // Map offline ID with online ID for created events.\n    deleted: number[];\n    toinvalidate: AddonCalendarSyncInvalidateEvent[];\n    source?: string; // Added on pages.\n    moment?: moment.Moment; // Added on day page.\n};\n\nexport type AddonCalendarSyncInvalidateEvent = {\n    id: number;\n    repeatid?: number;\n    timestart: number;\n    repeated: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}