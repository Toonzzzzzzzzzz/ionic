{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModFeedback, AddonModFeedbackProvider } from './feedback';\nimport { AddonModFeedbackOffline } from './feedback-offline';\nimport { AddonModFeedbackPrefetchHandler } from './handlers/prefetch';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync feedbacks.\n */\nexport class AddonModFeedbackSyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModFeedbackSyncProvider');\n    this.componentTranslatableString = 'feedback';\n  }\n  /**\n   * @inheritdoc\n   */\n  prefetchAfterUpdate(prefetchHandler, module, courseId, regex, siteId) {\n    regex = regex || /^.*files$|^timers/;\n    return super.prefetchAfterUpdate(prefetchHandler, module, courseId, regex, siteId);\n  }\n  /**\n   * Try to synchronize all the feedbacks in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllFeedbacks(siteId, force) {\n    return this.syncOnSites('all feedbacks', siteId => this.syncAllFeedbacksFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all pending feedbacks on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllFeedbacksFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Sync all new responses.\n      const responses = yield AddonModFeedbackOffline.getAllFeedbackResponses(siteId);\n      // Do not sync same feedback twice.\n      const treated = {};\n      yield Promise.all(responses.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (response) {\n          if (treated[response.feedbackid]) {\n            return;\n          }\n          treated[response.feedbackid] = true;\n          const result = force ? yield _this.syncFeedback(response.feedbackid, siteId) : yield _this.syncFeedbackIfNeeded(response.feedbackid, siteId);\n          if (result !== null && result !== void 0 && result.updated) {\n            // Sync successful, send event.\n            CoreEvents.trigger(AddonModFeedbackSyncProvider.AUTO_SYNCED, {\n              feedbackId: response.feedbackid,\n              warnings: result.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Sync a feedback only if a certain time has passed since the last time.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the feedback is synced or if it doesn't need to be synced.\n   */\n  syncFeedbackIfNeeded(feedbackId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const needed = yield _this2.isSyncNeeded(feedbackId, siteId);\n      if (needed) {\n        return _this2.syncFeedback(feedbackId, siteId);\n      }\n    })();\n  }\n  /**\n   * Synchronize all offline responses of a feedback.\n   *\n   * @param feedbackId Feedback ID to be synced.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncFeedback(feedbackId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const currentSyncPromise = this.getOngoingSync(feedbackId, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for this feedback, return the promise.\n      return currentSyncPromise;\n    }\n    // Verify that feedback isn't blocked.\n    if (CoreSync.isBlocked(AddonModFeedbackProvider.COMPONENT, feedbackId, siteId)) {\n      this.logger.debug(`Cannot sync feedback '${feedbackId}' because it is blocked.`);\n      throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', {\n        $a: this.componentTranslate\n      }));\n    }\n    this.logger.debug(`Try to sync feedback '${feedbackId}' in site ${siteId}'`);\n    return this.addOngoingSync(feedbackId, this.performSyncFeedback(feedbackId, siteId), siteId);\n  }\n  /**\n   * Perform the feedback sync.\n   *\n   * @param feedbackId Feedback ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved in success.\n   */\n  performSyncFeedback(feedbackId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModFeedbackProvider.COMPONENT, feedbackId, siteId));\n      // Get offline responses to be sent.\n      const responses = yield CoreUtils.ignoreErrors(AddonModFeedbackOffline.getFeedbackResponses(feedbackId, siteId));\n      if (!responses || !responses.length) {\n        // Nothing to sync.\n        yield CoreUtils.ignoreErrors(_this3.setSyncTime(feedbackId, siteId));\n        return result;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      const courseId = responses[0].courseid;\n      const feedback = yield AddonModFeedback.getFeedbackById(courseId, feedbackId, {\n        siteId\n      });\n      if (!feedback.multiple_submit) {\n        // If it does not admit multiple submits, check if it is completed to know if we can submit.\n        const isCompleted = yield AddonModFeedback.isCompleted(feedbackId, {\n          cmId: feedback.coursemodule,\n          siteId\n        });\n        if (isCompleted) {\n          // Cannot submit again, delete resposes.\n          yield Promise.all(responses.map(data => AddonModFeedbackOffline.deleteFeedbackPageResponses(feedbackId, data.page, siteId)));\n          result.updated = true;\n          _this3.addOfflineDataDeletedWarning(result.warnings, feedback.name, Translate.instant('addon.mod_feedback.this_feedback_is_already_submitted'));\n          yield CoreUtils.ignoreErrors(_this3.setSyncTime(feedbackId, siteId));\n          return result;\n        }\n      }\n      const timemodified = yield AddonModFeedback.getCurrentCompletedTimeModified(feedbackId, {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      });\n      // Sort by page.\n      responses.sort((a, b) => a.page - b.page);\n      const orderedData = responses.map(data => ({\n        function: () => _this3.processPage(feedback, data, siteId, timemodified, result),\n        blocking: true\n      }));\n      // Execute all the processes in order to solve dependencies.\n      yield CoreUtils.executeOrderedPromises(orderedData);\n      if (result.updated) {\n        // Data has been sent to server, update data.\n        try {\n          const module = yield CoreCourse.getModuleBasicInfoByInstance(feedbackId, 'feedback', {\n            siteId\n          });\n          yield _this3.prefetchAfterUpdate(AddonModFeedbackPrefetchHandler.instance, module, courseId, undefined, siteId);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n      }\n      // Sync finished, set sync time.\n      yield CoreUtils.ignoreErrors(_this3.setSyncTime(feedbackId, siteId));\n      return result;\n    })();\n  }\n  /**\n   * Convenience function to sync process page calls.\n   *\n   * @param feedback Feedback object.\n   * @param data Response data.\n   * @param siteId Site Id.\n   * @param timemodified Current completed modification time.\n   * @param result Result object to be modified.\n   * @returns Resolve when done or rejected with error.\n   */\n  processPage(feedback, data, siteId, timemodified, result) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Delete all pages that are submitted before changing website.\n      if (timemodified > data.timemodified) {\n        return AddonModFeedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId);\n      }\n      try {\n        yield AddonModFeedback.processPageOnline(feedback.id, data.page, data.responses, false, siteId);\n        result.updated = true;\n        yield AddonModFeedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId);\n      } catch (error) {\n        if (!CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server, reject.\n          throw error;\n        }\n        // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.\n        result.updated = true;\n        yield AddonModFeedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId);\n        // Responses deleted, add a warning.\n        _this4.addOfflineDataDeletedWarning(result.warnings, feedback.name, error);\n      }\n    })();\n  }\n}\n_class = AddonModFeedbackSyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_feedback_autom_synced';\n_class.ɵfac = function AddonModFeedbackSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModFeedbackSync = makeSingleton(AddonModFeedbackSyncProvider);","map":{"version":3,"names":["CoreSyncBlockedError","CoreNetworkError","CoreCourseActivitySyncBaseProvider","CoreCourse","CoreCourseLogHelper","CoreNetwork","CoreSites","CoreSync","CoreUtils","makeSingleton","Translate","CoreEvents","AddonModFeedback","AddonModFeedbackProvider","AddonModFeedbackOffline","AddonModFeedbackPrefetchHandler","AddonModFeedbackSyncProvider","constructor","componentTranslatableString","prefetchAfterUpdate","prefetchHandler","module","courseId","regex","siteId","syncAllFeedbacks","force","syncOnSites","syncAllFeedbacksFunc","_this","_asyncToGenerator","responses","getAllFeedbackResponses","treated","Promise","all","map","_ref","response","feedbackid","result","syncFeedback","syncFeedbackIfNeeded","updated","trigger","AUTO_SYNCED","feedbackId","warnings","_x","apply","arguments","_this2","getCurrentSiteId","needed","isSyncNeeded","currentSyncPromise","getOngoingSync","isBlocked","COMPONENT","logger","debug","instant","$a","componentTranslate","addOngoingSync","performSyncFeedback","_this3","ignoreErrors","syncActivity","getFeedbackResponses","length","setSyncTime","isOnline","courseid","feedback","getFeedbackById","multiple_submit","isCompleted","cmId","coursemodule","data","deleteFeedbackPageResponses","page","addOfflineDataDeletedWarning","name","timemodified","getCurrentCompletedTimeModified","readingStrategy","sort","a","b","orderedData","function","processPage","blocking","executeOrderedPromises","getModuleBasicInfoByInstance","instance","undefined","_unused","_this4","id","processPageOnline","error","isWebServiceError","_class","factory","ɵfac","providedIn","AddonModFeedbackSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/feedback/services/feedback-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSyncBlockedError } from '@classes/base-sync';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse, CoreCourseAnyModuleData } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModFeedback, AddonModFeedbackProvider, AddonModFeedbackWSFeedback } from './feedback';\nimport { AddonModFeedbackOffline, AddonModFeedbackOfflineResponse } from './feedback-offline';\nimport { AddonModFeedbackPrefetchHandler, AddonModFeedbackPrefetchHandlerService } from './handlers/prefetch';\n\n/**\n * Service to sync feedbacks.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModFeedbackSyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModFeedbackSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_feedback_autom_synced';\n\n    protected componentTranslatableString = 'feedback';\n\n    constructor() {\n        super('AddonModFeedbackSyncProvider');\n    }\n\n    /**\n     * @inheritdoc\n     */\n    prefetchAfterUpdate(\n        prefetchHandler: AddonModFeedbackPrefetchHandlerService,\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        regex?: RegExp,\n        siteId?: string,\n    ): Promise<boolean> {\n        regex = regex || /^.*files$|^timers/;\n\n        return super.prefetchAfterUpdate(prefetchHandler, module, courseId, regex, siteId);\n    }\n\n    /**\n     * Try to synchronize all the feedbacks in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllFeedbacks(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all feedbacks', (siteId) => this.syncAllFeedbacksFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all pending feedbacks on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllFeedbacksFunc(force: boolean, siteId?: string): Promise<void> {\n        // Sync all new responses.\n        const responses = await AddonModFeedbackOffline.getAllFeedbackResponses(siteId);\n\n        // Do not sync same feedback twice.\n        const treated: Record<number, boolean> = {};\n\n        await Promise.all(responses.map(async (response) => {\n            if (treated[response.feedbackid]) {\n                return;\n            }\n\n            treated[response.feedbackid] = true;\n\n            const result = force ?\n                await this.syncFeedback(response.feedbackid, siteId) :\n                await this.syncFeedbackIfNeeded(response.feedbackid, siteId);\n\n            if (result?.updated) {\n                // Sync successful, send event.\n                CoreEvents.trigger(AddonModFeedbackSyncProvider.AUTO_SYNCED, {\n                    feedbackId: response.feedbackid,\n                    warnings: result.warnings,\n                }, siteId);\n            }\n        }));\n    }\n\n    /**\n     * Sync a feedback only if a certain time has passed since the last time.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the feedback is synced or if it doesn't need to be synced.\n     */\n    async syncFeedbackIfNeeded(feedbackId: number, siteId?: string): Promise<AddonModFeedbackSyncResult | undefined> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const needed = await this.isSyncNeeded(feedbackId, siteId);\n\n        if (needed) {\n            return this.syncFeedback(feedbackId, siteId);\n        }\n    }\n\n    /**\n     * Synchronize all offline responses of a feedback.\n     *\n     * @param feedbackId Feedback ID to be synced.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    syncFeedback(feedbackId: number, siteId?: string): Promise<AddonModFeedbackSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(feedbackId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this feedback, return the promise.\n            return currentSyncPromise;\n        }\n\n        // Verify that feedback isn't blocked.\n        if (CoreSync.isBlocked(AddonModFeedbackProvider.COMPONENT, feedbackId, siteId)) {\n            this.logger.debug(`Cannot sync feedback '${feedbackId}' because it is blocked.`);\n\n            throw new CoreSyncBlockedError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));\n        }\n\n        this.logger.debug(`Try to sync feedback '${feedbackId}' in site ${siteId}'`);\n\n        return this.addOngoingSync(feedbackId, this.performSyncFeedback(feedbackId, siteId), siteId);\n    }\n\n    /**\n     * Perform the feedback sync.\n     *\n     * @param feedbackId Feedback ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved in success.\n     */\n    protected async performSyncFeedback(feedbackId: number, siteId: string): Promise<AddonModFeedbackSyncResult> {\n        const result: AddonModFeedbackSyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModFeedbackProvider.COMPONENT, feedbackId, siteId));\n\n        // Get offline responses to be sent.\n        const responses = await CoreUtils.ignoreErrors(AddonModFeedbackOffline.getFeedbackResponses(feedbackId, siteId));\n\n        if (!responses || !responses.length) {\n            // Nothing to sync.\n            await CoreUtils.ignoreErrors(this.setSyncTime(feedbackId, siteId));\n\n            return result;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        const courseId = responses[0].courseid;\n\n        const feedback = await AddonModFeedback.getFeedbackById(courseId, feedbackId, { siteId });\n\n        if (!feedback.multiple_submit) {\n            // If it does not admit multiple submits, check if it is completed to know if we can submit.\n            const isCompleted = await AddonModFeedback.isCompleted(feedbackId, { cmId: feedback.coursemodule, siteId });\n\n            if (isCompleted) {\n                // Cannot submit again, delete resposes.\n                await Promise.all(responses.map((data) =>\n                    AddonModFeedbackOffline.deleteFeedbackPageResponses(feedbackId, data.page, siteId)));\n\n                result.updated = true;\n                this.addOfflineDataDeletedWarning(\n                    result.warnings,\n                    feedback.name,\n                    Translate.instant('addon.mod_feedback.this_feedback_is_already_submitted'),\n                );\n\n                await CoreUtils.ignoreErrors(this.setSyncTime(feedbackId, siteId));\n\n                return result;\n            }\n        }\n\n        const timemodified = await AddonModFeedback.getCurrentCompletedTimeModified(feedbackId, {\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        });\n        // Sort by page.\n        responses.sort((a, b) => a.page - b.page);\n\n        const orderedData = responses.map((data) => ({\n            function: () => this.processPage(feedback, data, siteId, timemodified, result),\n            blocking: true,\n        }));\n\n        // Execute all the processes in order to solve dependencies.\n        await CoreUtils.executeOrderedPromises(orderedData);\n\n        if (result.updated) {\n            // Data has been sent to server, update data.\n            try {\n                const module = await CoreCourse.getModuleBasicInfoByInstance(feedbackId, 'feedback', { siteId });\n\n                await this.prefetchAfterUpdate(AddonModFeedbackPrefetchHandler.instance, module, courseId, undefined, siteId);\n            } catch {\n                // Ignore errors.\n            }\n        }\n\n        // Sync finished, set sync time.\n        await CoreUtils.ignoreErrors(this.setSyncTime(feedbackId, siteId));\n\n        return result;\n    }\n\n    /**\n     * Convenience function to sync process page calls.\n     *\n     * @param feedback Feedback object.\n     * @param data Response data.\n     * @param siteId Site Id.\n     * @param timemodified Current completed modification time.\n     * @param result Result object to be modified.\n     * @returns Resolve when done or rejected with error.\n     */\n    protected async processPage(\n        feedback: AddonModFeedbackWSFeedback,\n        data: AddonModFeedbackOfflineResponse,\n        siteId: string,\n        timemodified: number,\n        result: AddonModFeedbackSyncResult,\n    ): Promise<void> {\n        // Delete all pages that are submitted before changing website.\n        if (timemodified > data.timemodified) {\n            return AddonModFeedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId);\n        }\n\n        try {\n            await AddonModFeedback.processPageOnline(feedback.id, data.page, data.responses, false, siteId);\n\n            result.updated = true;\n\n            await AddonModFeedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId);\n        } catch (error) {\n            if (!CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server, reject.\n                throw error;\n            }\n\n            // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.\n            result.updated = true;\n\n            await AddonModFeedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId);\n\n            // Responses deleted, add a warning.\n            this.addOfflineDataDeletedWarning(\n                result.warnings,\n                feedback.name,\n                error,\n            );\n        }\n    }\n\n}\n\nexport const AddonModFeedbackSync = makeSingleton(AddonModFeedbackSyncProvider);\n\n/**\n * Data returned by a feedback sync.\n */\nexport type AddonModFeedbackSyncResult = CoreSyncResult;\n\n/**\n * Data passed to AUTO_SYNCED event.\n */\nexport type AddonModFeedbackAutoSyncData = {\n    feedbackId: number;\n    warnings: string[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}