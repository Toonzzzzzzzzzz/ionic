{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreSites } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModScormPrefetchHandler } from './handlers/prefetch';\nimport { AddonModScorm, AddonModScormProvider } from './scorm';\nimport { AddonModScormOffline } from './scorm-offline';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync SCORMs.\n */\nexport class AddonModScormSyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModScormSyncProvider');\n    this.componentTranslatableString = 'scorm';\n  }\n  /**\n   * Add an offline attempt to the right of the new attempts array if possible.\n   * If the attempt cannot be created as a new attempt then it will be deleted.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt The offline attempt to treat.\n   * @param lastOffline Last offline attempt number.\n   * @param newAttemptsSameOrder Attempts that'll be created as new attempts but keeping the current order.\n   * @param newAttemptsAtEnd Object with attempts that'll be created at the end of the list (should be max 1).\n   * @param lastOfflineCreated Time when the last offline attempt was created.\n   * @param lastOfflineIncomplete Whether the last offline attempt is incomplete.\n   * @param warnings Array where to add the warnings.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  addToNewOrDelete(scormId, attempt, lastOffline, newAttemptsSameOrder, newAttemptsAtEnd, lastOfflineCreated, lastOfflineIncomplete, warnings, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (attempt == lastOffline) {\n        newAttemptsSameOrder.push(attempt);\n        return;\n      }\n      // Check if the attempt can be created.\n      const time = yield AddonModScormOffline.getAttemptCreationTime(scormId, attempt, siteId);\n      if (!time || time <= lastOfflineCreated) {\n        newAttemptsSameOrder.push(attempt);\n        return;\n      }\n      // This attempt was created after the last offline attempt, we'll add it to the end of the list if possible.\n      if (lastOfflineIncomplete) {\n        // It can't be added because the last offline attempt is incomplete, delete it.\n        _this.logger.debug(`Try to delete attempt ${attempt} because it cannot be created as a new attempt.`);\n        yield CoreUtils.ignoreErrors(AddonModScormOffline.deleteAttempt(scormId, attempt, siteId));\n        // eslint-disable-next-line id-blacklist\n        warnings.push(Translate.instant('addon.mod_scorm.warningofflinedatadeleted', {\n          number: attempt\n        }));\n      } else {\n        // Add the attempt at the end.\n        newAttemptsAtEnd[time] = attempt;\n      }\n    })();\n  }\n  /**\n   * Check if can retry an attempt synchronization.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param lastOnline Last online attempt number.\n   * @param cmId Module ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved if can retry the synchronization, rejected otherwise.\n   */\n  canRetrySync(scormId, attempt, lastOnline, cmId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // If it's the last attempt we don't need to ignore cache because we already did it.\n      const refresh = lastOnline != attempt;\n      const siteData = yield AddonModScorm.getScormUserData(scormId, attempt, {\n        cmId,\n        readingStrategy: refresh ? 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */ : undefined,\n        siteId\n      });\n      // Get synchronization snapshot (if sync fails it should store a snapshot).\n      const snapshot = yield AddonModScormOffline.getAttemptSnapshot(scormId, attempt, siteId);\n      if (!snapshot || !Object.keys(snapshot).length || !_this2.snapshotEquals(snapshot, siteData)) {\n        // No snapshot or it doesn't match, we can't retry the synchronization.\n        return false;\n      }\n      return true;\n    })();\n  }\n  /**\n   * Create new attempts at the end of the offline attempts list.\n   *\n   * @param scormId SCORM ID.\n   * @param newAttempts Object with the attempts to create. The keys are the timecreated, the values are the attempt number.\n   * @param lastOffline Number of last offline attempt.\n   * @param siteId Site ID.\n   * @returns Promise resolved when done.\n   */\n  createNewAttemptsAtEnd(scormId, newAttempts, lastOffline, siteId) {\n    return _asyncToGenerator(function* () {\n      const times = Object.keys(newAttempts).sort(); // Sort in ASC order.\n      if (!times.length) {\n        return;\n      }\n      yield CoreUtils.allPromises(times.map((time, index) => {\n        const attempt = newAttempts[time];\n        return AddonModScormOffline.changeAttemptNumber(scormId, attempt, lastOffline + index + 1, siteId);\n      }));\n    })();\n  }\n  /**\n   * Finish a sync process: remove offline data if needed, prefetch SCORM data, set sync time and return the result.\n   *\n   * @param siteId Site ID.\n   * @param scorm SCORM.\n   * @param warnings List of warnings generated by the sync.\n   * @param lastOnline Last online attempt number before the sync.\n   * @param lastOnlineWasFinished Whether the last online attempt was finished before the sync.\n   * @param initialCount Attempt count before the sync.\n   * @param updated Whether some data was sent to the site.\n   * @returns Promise resolved on success.\n   */\n  finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, updated) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: warnings,\n        attemptFinished: false,\n        updated: !!updated\n      };\n      if (updated) {\n        try {\n          // Update downloaded data.\n          const module = yield CoreCourse.getModuleBasicInfoByInstance(scorm.id, 'scorm', {\n            siteId\n          });\n          yield _this3.prefetchAfterUpdate(AddonModScormPrefetchHandler.instance, module, scorm.course, undefined, siteId);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n      }\n      yield CoreUtils.ignoreErrors(_this3.setSyncTime(scorm.id, siteId));\n      if (!initialCount) {\n        return result;\n      }\n      // Check if an attempt was finished in Moodle.\n      // Get attempt count again to check if an attempt was finished.\n      const attemptsData = yield AddonModScorm.getAttemptCount(scorm.id, {\n        cmId: scorm.coursemodule,\n        siteId\n      });\n      if (attemptsData.online.length > initialCount.online.length) {\n        result.attemptFinished = true;\n      } else if (!lastOnlineWasFinished && lastOnline) {\n        // Last online attempt wasn't finished, let's check if it is now.\n        const incomplete = yield AddonModScorm.isAttemptIncomplete(scorm.id, lastOnline, {\n          cmId: scorm.coursemodule,\n          readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n          siteId\n        });\n        result.attemptFinished = !incomplete;\n      }\n      return result;\n    })();\n  }\n  /**\n   * Get the creation time and the status (complete/incomplete) of an offline attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param cmId Module ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved with the data.\n   */\n  getOfflineAttemptData(scormId, attempt, cmId, siteId) {\n    return _asyncToGenerator(function* () {\n      // Check if last offline attempt is incomplete.\n      const incomplete = yield AddonModScorm.isAttemptIncomplete(scormId, attempt, {\n        offline: true,\n        cmId,\n        siteId\n      });\n      const timecreated = yield AddonModScormOffline.getAttemptCreationTime(scormId, attempt, siteId);\n      return {\n        incomplete,\n        timecreated\n      };\n    })();\n  }\n  /**\n   * Change the number of some offline attempts. We need to move all offline attempts after the collisions\n   * too, otherwise we would overwrite data.\n   * Example: We have offline attempts 1, 2 and 3. #1 and #2 have collisions. #1 can be synced, but #2 needs\n   * to be a new attempt. #3 will now be #4, and #2 will now be #3.\n   *\n   * @param scormId SCORM ID.\n   * @param newAttempts Attempts that need to be converted into new attempts.\n   * @param lastOnline Last online attempt.\n   * @param lastCollision Last attempt with collision (exists in online and offline).\n   * @param offlineAttempts Numbers of offline attempts.\n   * @param siteId Site ID.\n   * @returns Promise resolved when attempts have been moved.\n   */\n  moveNewAttempts(scormId, newAttempts, lastOnline, lastCollision, offlineAttempts, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!newAttempts.length) {\n        return;\n      }\n      let lastSuccessful;\n      try {\n        // Sort offline attempts in DESC order.\n        offlineAttempts = offlineAttempts.sort((a, b) => Number(a) <= Number(b) ? 1 : -1);\n        // First move the offline attempts after the collisions. Move them 1 by 1 in order.\n        for (const i in offlineAttempts) {\n          const attempt = offlineAttempts[i];\n          if (attempt > lastCollision) {\n            const newNumber = attempt + newAttempts.length;\n            yield AddonModScormOffline.changeAttemptNumber(scormId, attempt, newNumber, siteId);\n            lastSuccessful = attempt;\n          }\n        }\n        const successful = [];\n        try {\n          // Sort newAttempts in ASC order.\n          newAttempts = newAttempts.sort((a, b) => Number(a) >= Number(b) ? 1 : -1);\n          // Now move the attempts in newAttempts.\n          yield Promise.all(newAttempts.map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (attempt, index) {\n              // No need to use chain of promises.\n              const newNumber = lastOnline + index + 1;\n              yield AddonModScormOffline.changeAttemptNumber(scormId, attempt, newNumber, siteId);\n              successful.push(attempt);\n            });\n            return function (_x, _x2) {\n              return _ref.apply(this, arguments);\n            };\n          }()));\n        } catch (error) {\n          // Moving the new attempts failed (it shouldn't happen). Let's undo the new attempts move.\n          yield CoreUtils.allPromises(successful.map(attempt => {\n            const newNumber = lastOnline + newAttempts.indexOf(attempt) + 1;\n            return AddonModScormOffline.changeAttemptNumber(scormId, newNumber, attempt, siteId);\n          }));\n          throw error; // It will now enter the catch that moves offline attempts after collisions.\n        }\n      } catch (error) {\n        // Moving offline attempts after collisions failed (it shouldn't happen). Let's undo the changes.\n        if (!lastSuccessful) {\n          throw error;\n        }\n        for (let attempt = lastSuccessful; offlineAttempts.indexOf(attempt) != -1; attempt++) {\n          // Move it back.\n          yield AddonModScormOffline.changeAttemptNumber(scormId, attempt + newAttempts.length, attempt, siteId);\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Save a snapshot from a synchronization.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attemot number.\n   * @param cmId Module ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved when the snapshot is stored.\n   */\n  saveSyncSnapshot(scormId, attempt, cmId, siteId) {\n    return _asyncToGenerator(function* () {\n      // Try to get current state from the site.\n      let userData;\n      try {\n        userData = yield AddonModScorm.getScormUserData(scormId, attempt, {\n          cmId,\n          readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n          siteId\n        });\n      } catch (_unused2) {\n        // Error getting user data from the site. We'll have to build it ourselves.\n        // Let's try to get cached data about the attempt.\n        userData = yield CoreUtils.ignoreErrors(AddonModScorm.getScormUserData(scormId, attempt, {\n          cmId,\n          siteId\n        }), {});\n        // We need to add the synced data to the snapshot.\n        const syncedData = yield AddonModScormOffline.getScormStoredData(scormId, attempt, false, true, siteId);\n        syncedData.forEach(entry => {\n          if (!userData[entry.scoid]) {\n            userData[entry.scoid] = {\n              scoid: entry.scoid,\n              userdata: {},\n              defaultdata: {}\n            };\n          }\n          userData[entry.scoid].userdata[entry.element] = entry.value || '';\n        });\n      }\n      return AddonModScormOffline.setAttemptSnapshot(scormId, attempt, userData, siteId);\n    })();\n  }\n  /**\n   * Compares an attempt's snapshot with the data retrieved from the site.\n   * It only compares elements with dot notation. This means that, if some SCO has been added to Moodle web\n   * but the user hasn't generated data for it, then the snapshot will be detected as equal.\n   *\n   * @param snapshot Attempt's snapshot.\n   * @param userData Data retrieved from the site.\n   * @returns True if snapshot is equal to the user data, false otherwise.\n   */\n  snapshotEquals(snapshot, userData) {\n    // Check that snapshot contains the data from the site.\n    for (const scoId in userData) {\n      const siteSco = userData[scoId];\n      const snapshotSco = snapshot[scoId];\n      for (const element in siteSco.userdata) {\n        if (element.indexOf('.') > -1) {\n          if (!snapshotSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {\n            return false;\n          }\n        }\n      }\n    }\n    // Now check the opposite way: site userData contains the data from the snapshot.\n    for (const scoId in snapshot) {\n      const siteSco = userData[scoId];\n      const snapshotSco = snapshot[scoId];\n      for (const element in snapshotSco.userdata) {\n        if (element.indexOf('.') > -1) {\n          if (!siteSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Try to synchronize all the SCORMs in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllScorms(siteId, force) {\n    return this.syncOnSites('all SCORMs', siteId => this.syncAllScormsFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all SCORMs on a site.\n   *\n   * @param force Wether to force sync or not.\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllScormsFunc(force, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Get all offline attempts.\n      const attempts = yield AddonModScormOffline.getAllAttempts(siteId);\n      const treated = {}; // To prevent duplicates.\n      // Sync all SCORMs that haven't been synced for a while and that aren't attempted right now.\n      yield Promise.all(attempts.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (attempt) {\n          if (treated[attempt.scormid] || CoreSync.isBlocked(AddonModScormProvider.COMPONENT, attempt.scormid, siteId)) {\n            return;\n          }\n          treated[attempt.scormid] = true;\n          const scorm = yield AddonModScorm.getScormById(attempt.courseid, attempt.scormid, {\n            siteId\n          });\n          const data = force ? yield _this4.syncScorm(scorm, siteId) : yield _this4.syncScormIfNeeded(scorm, siteId);\n          if (data !== undefined) {\n            // We tried to sync. Send event.\n            CoreEvents.trigger(AddonModScormSyncProvider.AUTO_SYNCED, {\n              scormId: scorm.id,\n              attemptFinished: data.attemptFinished,\n              warnings: data.warnings,\n              updated: data.updated\n            }, siteId);\n          }\n        });\n        return function (_x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Send data from a SCORM offline attempt to the site.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param cmId Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the attempt is successfully synced.\n   */\n  syncAttempt(scormId, attempt, cmId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      _this5.logger.debug(`Try to sync attempt ${attempt} in SCORM ${scormId} and site ${siteId}`);\n      // Get only not synced entries.\n      const tracks = yield AddonModScormOffline.getScormStoredData(scormId, attempt, true, false, siteId);\n      const scos = {};\n      let somethingSynced = false;\n      // Get data to send (only elements with dots like cmi.core.exit, in Mobile we store more data to make offline work).\n      tracks.forEach(track => {\n        if (track.element.indexOf('.') > -1) {\n          if (!scos[track.scoid]) {\n            scos[track.scoid] = [];\n          }\n          scos[track.scoid].push({\n            element: track.element,\n            value: track.value || ''\n          });\n        }\n      });\n      try {\n        // Send the data in each SCO.\n        const promises = Object.entries(scos).map( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* ([key, tracks]) {\n            const scoId = Number(key);\n            yield AddonModScorm.saveTracksOnline(scormId, scoId, attempt, tracks, siteId);\n            // Sco data successfully sent. Mark them as synced. This is needed because some SCOs sync might fail.\n            yield CoreUtils.ignoreErrors(AddonModScormOffline.markAsSynced(scormId, attempt, scoId, siteId));\n            somethingSynced = true;\n          });\n          return function (_x4) {\n            return _ref3.apply(this, arguments);\n          };\n        }());\n        yield CoreUtils.allPromises(promises);\n      } catch (error) {\n        if (somethingSynced) {\n          // Some SCOs have been synced and some not.\n          // Try to store a snapshot of the current state to be able to re-try the synchronization later.\n          _this5.logger.error(`Error synchronizing some SCOs for attempt ${attempt} in SCORM ${scormId}. Saving snapshot.`);\n          yield _this5.saveSyncSnapshot(scormId, attempt, cmId, siteId);\n        } else {\n          _this5.logger.error(`Error synchronizing attempt ${attempt} in SCORM ${scormId}`);\n        }\n        throw error;\n      }\n      // Attempt has been sent. Let's delete it from local.\n      yield CoreUtils.ignoreErrors(AddonModScormOffline.deleteAttempt(scormId, attempt, siteId));\n    })();\n  }\n  /**\n   * Sync a SCORM only if a certain time has passed since the last time.\n   *\n   * @param scorm SCORM.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the SCORM is synced or if it doesn't need to be synced.\n   */\n  syncScormIfNeeded(scorm, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const needed = yield _this6.isSyncNeeded(scorm.id, siteId);\n      if (needed) {\n        return _this6.syncScorm(scorm, siteId);\n      }\n    })();\n  }\n  /**\n   * Try to synchronize a SCORM.\n   *\n   * @param scorm SCORM.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success.\n   */\n  syncScorm(scorm, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const currentSyncPromise = this.getOngoingSync(scorm.id, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for this SCORM, return the promise.\n      return currentSyncPromise;\n    }\n    // Verify that SCORM isn't blocked.\n    if (CoreSync.isBlocked(AddonModScormProvider.COMPONENT, scorm.id, siteId)) {\n      this.logger.debug('Cannot sync SCORM ' + scorm.id + ' because it is blocked.');\n      throw new CoreError(Translate.instant('core.errorsyncblocked', {\n        $a: this.componentTranslate\n      }));\n    }\n    this.logger.debug(`Try to sync SCORM ${scorm.id} in site ${siteId}`);\n    const syncPromise = this.performSyncScorm(scorm, siteId);\n    return this.addOngoingSync(scorm.id, syncPromise, siteId);\n  }\n  /**\n   * Try to synchronize a SCORM.\n   *\n   * @param scorm SCORM.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved in success.\n   */\n  performSyncScorm(scorm, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      let warnings = [];\n      let lastOnline = 0;\n      let lastOnlineWasFinished = false;\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModScormProvider.COMPONENT, scorm.id, siteId));\n      // Get attempts data. We ignore cache for online attempts, so this call will fail if offline or server down.\n      const attemptsData = yield AddonModScorm.getAttemptCount(scorm.id, {\n        cmId: scorm.coursemodule,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      });\n      if (!attemptsData.offline || !attemptsData.offline.length) {\n        // Nothing to sync.\n        return _this7.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished);\n      }\n      const initialCount = attemptsData;\n      const collisions = [];\n      // Check if there are collisions between offline and online attempts (same number).\n      attemptsData.online.forEach(attempt => {\n        lastOnline = Math.max(lastOnline, attempt);\n        if (attemptsData.offline.indexOf(attempt) > -1) {\n          collisions.push(attempt);\n        }\n      });\n      // Check if last online attempt is finished. Ignore cache.\n      let incomplete = lastOnline <= 0 ? false : yield AddonModScorm.isAttemptIncomplete(scorm.id, lastOnline, {\n        cmId: scorm.coursemodule,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId\n      });\n      lastOnlineWasFinished = !incomplete;\n      if (!collisions.length) {\n        if (incomplete) {\n          // No collisions, but last online attempt is incomplete so we can't send offline attempts.\n          warnings.push(Translate.instant('addon.mod_scorm.warningsynconlineincomplete'));\n          return _this7.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, false);\n        }\n        // No collisions and last attempt is complete. Send offline attempts to Moodle.\n        yield Promise.all(attemptsData.offline.map( /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (attempt) {\n            if (!scorm.maxattempt || attempt <= scorm.maxattempt) {\n              yield _this7.syncAttempt(scorm.id, attempt, scorm.coursemodule, siteId);\n            }\n          });\n          return function (_x5) {\n            return _ref4.apply(this, arguments);\n          };\n        }()));\n        // All data synced, finish.\n        return _this7.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, true);\n      }\n      // We have collisions, treat them.\n      warnings = yield _this7.treatCollisions(scorm.id, collisions, lastOnline, attemptsData.offline, scorm.coursemodule, siteId);\n      // The offline attempts might have changed since some collisions can be converted to new attempts.\n      const entries = yield AddonModScormOffline.getAttempts(scorm.id, siteId);\n      let cannotSyncSome = false;\n      // Get only the attempt number.\n      const attempts = entries.map(entry => entry.attempt);\n      if (incomplete && attempts.indexOf(lastOnline) > -1) {\n        // Last online was incomplete, but it was continued in offline.\n        incomplete = false;\n      }\n      yield Promise.all(attempts.map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (attempt) {\n          // We'll always sync attempts previous to lastOnline (failed sync or continued in offline).\n          // We'll only sync new attemps if last online attempt is completed.\n          if (!incomplete || attempt <= lastOnline) {\n            if (!scorm.maxattempt || attempt <= scorm.maxattempt) {\n              yield _this7.syncAttempt(scorm.id, attempt, scorm.coursemodule, siteId);\n            }\n          } else {\n            cannotSyncSome = true;\n          }\n        });\n        return function (_x6) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n      if (cannotSyncSome) {\n        warnings.push(Translate.instant('addon.mod_scorm.warningsynconlineincomplete'));\n      }\n      return _this7.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, true);\n    })();\n  }\n  /**\n   * Treat collisions found in a SCORM synchronization process.\n   *\n   * @param scormId SCORM ID.\n   * @param collisions Numbers of attempts that exist both in online and offline.\n   * @param lastOnline Last online attempt.\n   * @param offlineAttempts Numbers of offline attempts.\n   * @param cmId Module ID.\n   * @param siteId Site ID.\n   * @returns Promise resolved when the collisions have been treated. It returns warnings array.\n   * @description\n   *\n   * Treat collisions found in a SCORM synchronization process. A collision is when an attempt exists both in offline\n   * and online. A collision can be:\n   *\n   * - Two different attempts.\n   * - An online attempt continued in offline.\n   * - A failure in a previous sync.\n   *\n   * This function will move into new attempts the collisions that can't be merged. It will usually keep the order of the\n   * offline attempts EXCEPT if the offline attempt was created after the last offline attempt (edge case).\n   *\n   * Edge case: A user creates offline attempts and when he syncs we retrieve an incomplete online attempt, so the offline\n   * attempts cannot be synced. Then the user continues that online attempt and goes offline, so a collision is created.\n   * When we perform the next sync we detect that this collision cannot be merged, so this offline attempt needs to be\n   * created as a new attempt. Since this attempt was created after the last offline attempt, it will be added ot the end\n   * of the list if the last attempt is completed. If the last attempt is not completed then the offline data will de deleted\n   * because we can't create a new attempt.\n   */\n  treatCollisions(scormId, collisions, lastOnline, offlineAttempts, cmId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const warnings = [];\n      const newAttemptsSameOrder = []; // Attempts that will be created as new attempts but keeping the current order.\n      const newAttemptsAtEnd = {}; // Attempts that'll be created at the end of list (should be max 1).\n      const lastCollision = Math.max.apply(Math, collisions);\n      let lastOffline = Math.max.apply(Math, offlineAttempts);\n      // Get needed data from the last offline attempt.\n      const lastOfflineData = yield _this8.getOfflineAttemptData(scormId, lastOffline, cmId, siteId);\n      const promises = collisions.map( /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* (attempt) {\n          // First get synced entries to detect if it was a failed synchronization.\n          const synced = yield AddonModScormOffline.getScormStoredData(scormId, attempt, false, true, siteId);\n          if (synced.length) {\n            // The attempt has synced entries, it seems to be a failed synchronization.\n            // Let's get the entries that haven't been synced, maybe it just failed to delete the attempt.\n            const tracks = yield AddonModScormOffline.getScormStoredData(scormId, attempt, true, false, siteId);\n            // Check if there are elements to sync.\n            const hasDataToSend = tracks.find(track => track.element.indexOf('.') > -1);\n            if (!hasDataToSend) {\n              // Nothing to sync, delete the attempt.\n              return CoreUtils.ignoreErrors(AddonModScormOffline.deleteAttempt(scormId, attempt, siteId));\n            }\n            // There are elements to sync. We need to check if it's possible to sync them or not.\n            const canRetry = yield _this8.canRetrySync(scormId, attempt, lastOnline, cmId, siteId);\n            if (!canRetry) {\n              var _lastOfflineData$time;\n              // Cannot retry sync, we'll create a new offline attempt if possible.\n              return _this8.addToNewOrDelete(scormId, attempt, lastOffline, newAttemptsSameOrder, newAttemptsAtEnd, (_lastOfflineData$time = lastOfflineData.timecreated) !== null && _lastOfflineData$time !== void 0 ? _lastOfflineData$time : 0, lastOfflineData.incomplete, warnings, siteId);\n            }\n          } else {\n            // It's not a failed synchronization. Check if it's an attempt continued in offline.\n            const snapshot = yield AddonModScormOffline.getAttemptSnapshot(scormId, attempt, siteId);\n            if (!snapshot || !Object.keys(snapshot).length) {\n              // No snapshot, it's a different attempt.\n              newAttemptsSameOrder.push(attempt);\n              return;\n            }\n            // It has a snapshot, it means it continued an online attempt. We need to check if they've diverged.\n            // If it's the last attempt we don't need to ignore cache because we already did it.\n            const refresh = lastOnline != attempt;\n            const userData = yield AddonModScorm.getScormUserData(scormId, attempt, {\n              cmId,\n              readingStrategy: refresh ? 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */ : undefined,\n              siteId\n            });\n            if (!_this8.snapshotEquals(snapshot, userData)) {\n              var _lastOfflineData$time2;\n              // Snapshot has diverged, it will be converted into a new attempt if possible.\n              return _this8.addToNewOrDelete(scormId, attempt, lastOffline, newAttemptsSameOrder, newAttemptsAtEnd, (_lastOfflineData$time2 = lastOfflineData.timecreated) !== null && _lastOfflineData$time2 !== void 0 ? _lastOfflineData$time2 : 0, lastOfflineData.incomplete, warnings, siteId);\n            }\n          }\n        });\n        return function (_x7) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n      yield Promise.all(promises);\n      yield _this8.moveNewAttempts(scormId, newAttemptsSameOrder, lastOnline, lastCollision, offlineAttempts, siteId);\n      // The new attempts that need to keep the order have been created.\n      // Now create the new attempts at the end of the list of offline attempts. It should only be 1 attempt max.\n      lastOffline = lastOffline + newAttemptsSameOrder.length;\n      yield _this8.createNewAttemptsAtEnd(scormId, newAttemptsAtEnd, lastOffline, siteId);\n      return warnings;\n    })();\n  }\n}\n_class = AddonModScormSyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_scorm_autom_synced';\n_class.ɵfac = function AddonModScormSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModScormSync = makeSingleton(AddonModScormSyncProvider);","map":{"version":3,"names":["CoreError","CoreCourseActivitySyncBaseProvider","CoreCourse","CoreCourseLogHelper","CoreSites","CoreSync","CoreUtils","makeSingleton","Translate","CoreEvents","AddonModScormPrefetchHandler","AddonModScorm","AddonModScormProvider","AddonModScormOffline","AddonModScormSyncProvider","constructor","componentTranslatableString","addToNewOrDelete","scormId","attempt","lastOffline","newAttemptsSameOrder","newAttemptsAtEnd","lastOfflineCreated","lastOfflineIncomplete","warnings","siteId","_this","_asyncToGenerator","push","time","getAttemptCreationTime","logger","debug","ignoreErrors","deleteAttempt","instant","number","canRetrySync","lastOnline","cmId","_this2","refresh","siteData","getScormUserData","readingStrategy","undefined","snapshot","getAttemptSnapshot","Object","keys","length","snapshotEquals","createNewAttemptsAtEnd","newAttempts","times","sort","allPromises","map","index","changeAttemptNumber","finishSync","scorm","lastOnlineWasFinished","initialCount","updated","_this3","result","attemptFinished","module","getModuleBasicInfoByInstance","id","prefetchAfterUpdate","instance","course","_unused","setSyncTime","attemptsData","getAttemptCount","coursemodule","online","incomplete","isAttemptIncomplete","getOfflineAttemptData","offline","timecreated","moveNewAttempts","lastCollision","offlineAttempts","lastSuccessful","a","b","Number","i","newNumber","successful","Promise","all","_ref","_x","_x2","apply","arguments","error","indexOf","saveSyncSnapshot","userData","_unused2","syncedData","getScormStoredData","forEach","entry","scoid","userdata","defaultdata","element","value","setAttemptSnapshot","scoId","siteSco","snapshotSco","syncAllScorms","force","syncOnSites","syncAllScormsFunc","_this4","attempts","getAllAttempts","treated","_ref2","scormid","isBlocked","COMPONENT","getScormById","courseid","data","syncScorm","syncScormIfNeeded","trigger","AUTO_SYNCED","_x3","syncAttempt","_this5","getCurrentSiteId","tracks","scos","somethingSynced","track","promises","entries","_ref3","key","saveTracksOnline","markAsSynced","_x4","_this6","needed","isSyncNeeded","currentSyncPromise","getOngoingSync","$a","componentTranslate","syncPromise","performSyncScorm","addOngoingSync","_this7","syncActivity","collisions","Math","max","_ref4","maxattempt","_x5","treatCollisions","getAttempts","cannotSyncSome","_ref5","_x6","_this8","lastOfflineData","_ref6","synced","hasDataToSend","find","canRetry","_lastOfflineData$time","_lastOfflineData$time2","_x7","_class","factory","ɵfac","providedIn","AddonModScormSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/scorm/services/scorm-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSync, CoreSyncResult } from '@services/sync';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModScormPrefetchHandler } from './handlers/prefetch';\nimport {\n    AddonModScorm,\n    AddonModScormAttemptCountResult,\n    AddonModScormDataEntry,\n    AddonModScormProvider,\n    AddonModScormScorm,\n    AddonModScormUserDataMap,\n} from './scorm';\nimport { AddonModScormOffline } from './scorm-offline';\n\n/**\n * Service to sync SCORMs.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModScormSyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModScormSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_scorm_autom_synced';\n\n    protected componentTranslatableString = 'scorm';\n\n    constructor() {\n        super('AddonModScormSyncProvider');\n    }\n\n    /**\n     * Add an offline attempt to the right of the new attempts array if possible.\n     * If the attempt cannot be created as a new attempt then it will be deleted.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt The offline attempt to treat.\n     * @param lastOffline Last offline attempt number.\n     * @param newAttemptsSameOrder Attempts that'll be created as new attempts but keeping the current order.\n     * @param newAttemptsAtEnd Object with attempts that'll be created at the end of the list (should be max 1).\n     * @param lastOfflineCreated Time when the last offline attempt was created.\n     * @param lastOfflineIncomplete Whether the last offline attempt is incomplete.\n     * @param warnings Array where to add the warnings.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async addToNewOrDelete(\n        scormId: number,\n        attempt: number,\n        lastOffline: number,\n        newAttemptsSameOrder: number[],\n        newAttemptsAtEnd: Record<number, number>,\n        lastOfflineCreated: number,\n        lastOfflineIncomplete: boolean,\n        warnings: string[],\n        siteId: string,\n    ): Promise<void> {\n        if (attempt == lastOffline) {\n            newAttemptsSameOrder.push(attempt);\n\n            return;\n        }\n\n        // Check if the attempt can be created.\n        const time = await AddonModScormOffline.getAttemptCreationTime(scormId, attempt, siteId);\n\n        if (!time || time <= lastOfflineCreated) {\n            newAttemptsSameOrder.push(attempt);\n\n            return;\n        }\n\n        // This attempt was created after the last offline attempt, we'll add it to the end of the list if possible.\n        if (lastOfflineIncomplete) {\n            // It can't be added because the last offline attempt is incomplete, delete it.\n            this.logger.debug(`Try to delete attempt ${attempt} because it cannot be created as a new attempt.`);\n\n            await CoreUtils.ignoreErrors(AddonModScormOffline.deleteAttempt(scormId, attempt, siteId));\n\n            // eslint-disable-next-line id-blacklist\n            warnings.push(Translate.instant('addon.mod_scorm.warningofflinedatadeleted', { number: attempt }));\n        } else {\n            // Add the attempt at the end.\n            newAttemptsAtEnd[time] = attempt;\n        }\n    }\n\n    /**\n     * Check if can retry an attempt synchronization.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param lastOnline Last online attempt number.\n     * @param cmId Module ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved if can retry the synchronization, rejected otherwise.\n     */\n    protected async canRetrySync(\n        scormId: number,\n        attempt: number,\n        lastOnline: number,\n        cmId: number,\n        siteId: string,\n    ): Promise<boolean> {\n        // If it's the last attempt we don't need to ignore cache because we already did it.\n        const refresh = lastOnline != attempt;\n\n        const siteData = await AddonModScorm.getScormUserData(scormId, attempt, {\n            cmId,\n            readingStrategy: refresh ? CoreSitesReadingStrategy.ONLY_NETWORK : undefined,\n            siteId,\n        });\n\n        // Get synchronization snapshot (if sync fails it should store a snapshot).\n        const snapshot = await AddonModScormOffline.getAttemptSnapshot(scormId, attempt, siteId);\n\n        if (!snapshot || !Object.keys(snapshot).length || !this.snapshotEquals(snapshot, siteData)) {\n            // No snapshot or it doesn't match, we can't retry the synchronization.\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Create new attempts at the end of the offline attempts list.\n     *\n     * @param scormId SCORM ID.\n     * @param newAttempts Object with the attempts to create. The keys are the timecreated, the values are the attempt number.\n     * @param lastOffline Number of last offline attempt.\n     * @param siteId Site ID.\n     * @returns Promise resolved when done.\n     */\n    protected async createNewAttemptsAtEnd(\n        scormId: number,\n        newAttempts: Record<number, number>,\n        lastOffline: number,\n        siteId: string,\n    ): Promise<void> {\n        const times = Object.keys(newAttempts).sort(); // Sort in ASC order.\n\n        if (!times.length) {\n            return;\n        }\n\n        await CoreUtils.allPromises(times.map((time, index) => {\n            const attempt = newAttempts[time];\n\n            return AddonModScormOffline.changeAttemptNumber(scormId, attempt, lastOffline + index + 1, siteId);\n        }));\n    }\n\n    /**\n     * Finish a sync process: remove offline data if needed, prefetch SCORM data, set sync time and return the result.\n     *\n     * @param siteId Site ID.\n     * @param scorm SCORM.\n     * @param warnings List of warnings generated by the sync.\n     * @param lastOnline Last online attempt number before the sync.\n     * @param lastOnlineWasFinished Whether the last online attempt was finished before the sync.\n     * @param initialCount Attempt count before the sync.\n     * @param updated Whether some data was sent to the site.\n     * @returns Promise resolved on success.\n     */\n    protected async finishSync(\n        siteId: string,\n        scorm: AddonModScormScorm,\n        warnings: string[],\n        lastOnline?: number,\n        lastOnlineWasFinished?: boolean,\n        initialCount?: AddonModScormAttemptCountResult,\n        updated?: boolean,\n    ): Promise<AddonModScormSyncResult> {\n        const result: AddonModScormSyncResult = {\n            warnings: warnings,\n            attemptFinished: false,\n            updated: !!updated,\n        };\n\n        if (updated) {\n            try {\n                // Update downloaded data.\n                const module = await CoreCourse.getModuleBasicInfoByInstance(scorm.id, 'scorm', { siteId });\n\n                await this.prefetchAfterUpdate(AddonModScormPrefetchHandler.instance, module, scorm.course, undefined, siteId);\n            } catch {\n                // Ignore errors.\n            }\n        }\n\n        await CoreUtils.ignoreErrors(this.setSyncTime(scorm.id, siteId));\n\n        if (!initialCount) {\n            return result;\n        }\n\n        // Check if an attempt was finished in Moodle.\n        // Get attempt count again to check if an attempt was finished.\n        const attemptsData = await AddonModScorm.getAttemptCount(scorm.id, { cmId: scorm.coursemodule, siteId });\n\n        if (attemptsData.online.length > initialCount.online.length) {\n            result.attemptFinished = true;\n        } else if (!lastOnlineWasFinished && lastOnline) {\n            // Last online attempt wasn't finished, let's check if it is now.\n            const incomplete = await AddonModScorm.isAttemptIncomplete(scorm.id, lastOnline, {\n                cmId: scorm.coursemodule,\n                readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n                siteId,\n            });\n\n            result.attemptFinished = !incomplete;\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the creation time and the status (complete/incomplete) of an offline attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param cmId Module ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved with the data.\n     */\n    protected async getOfflineAttemptData(\n        scormId: number,\n        attempt: number,\n        cmId: number,\n        siteId: string,\n    ): Promise<{incomplete: boolean; timecreated?: number}> {\n\n        // Check if last offline attempt is incomplete.\n        const incomplete = await AddonModScorm.isAttemptIncomplete(scormId, attempt, {\n            offline: true,\n            cmId,\n            siteId,\n        });\n\n        const timecreated = await AddonModScormOffline.getAttemptCreationTime(scormId, attempt, siteId);\n\n        return {\n            incomplete,\n            timecreated,\n        };\n    }\n\n    /**\n     * Change the number of some offline attempts. We need to move all offline attempts after the collisions\n     * too, otherwise we would overwrite data.\n     * Example: We have offline attempts 1, 2 and 3. #1 and #2 have collisions. #1 can be synced, but #2 needs\n     * to be a new attempt. #3 will now be #4, and #2 will now be #3.\n     *\n     * @param scormId SCORM ID.\n     * @param newAttempts Attempts that need to be converted into new attempts.\n     * @param lastOnline Last online attempt.\n     * @param lastCollision Last attempt with collision (exists in online and offline).\n     * @param offlineAttempts Numbers of offline attempts.\n     * @param siteId Site ID.\n     * @returns Promise resolved when attempts have been moved.\n     */\n    protected async moveNewAttempts(\n        scormId: number,\n        newAttempts: number[],\n        lastOnline: number,\n        lastCollision: number,\n        offlineAttempts: number[],\n        siteId: string,\n    ): Promise<void> {\n        if (!newAttempts.length) {\n            return;\n        }\n\n        let lastSuccessful: number | undefined;\n\n        try {\n            // Sort offline attempts in DESC order.\n            offlineAttempts = offlineAttempts.sort((a, b) => Number(a) <= Number(b) ? 1 : -1);\n\n            // First move the offline attempts after the collisions. Move them 1 by 1 in order.\n            for (const i in offlineAttempts) {\n                const attempt = offlineAttempts[i];\n\n                if (attempt > lastCollision) {\n                    const newNumber = attempt + newAttempts.length;\n\n                    await AddonModScormOffline.changeAttemptNumber(scormId, attempt, newNumber, siteId);\n\n                    lastSuccessful = attempt;\n                }\n            }\n\n            const successful: number[] = [];\n\n            try {\n                // Sort newAttempts in ASC order.\n                newAttempts = newAttempts.sort((a, b) => Number(a) >= Number(b) ? 1 : -1);\n\n                // Now move the attempts in newAttempts.\n                await Promise.all(newAttempts.map(async (attempt, index) => {\n                    // No need to use chain of promises.\n                    const newNumber = lastOnline + index + 1;\n\n                    await AddonModScormOffline.changeAttemptNumber(scormId, attempt, newNumber, siteId);\n\n                    successful.push(attempt);\n                }));\n\n            } catch (error) {\n                // Moving the new attempts failed (it shouldn't happen). Let's undo the new attempts move.\n                await CoreUtils.allPromises(successful.map((attempt) => {\n                    const newNumber = lastOnline + newAttempts.indexOf(attempt) + 1;\n\n                    return AddonModScormOffline.changeAttemptNumber(scormId, newNumber, attempt, siteId);\n                }));\n\n                throw error; // It will now enter the catch that moves offline attempts after collisions.\n            }\n        } catch (error) {\n            // Moving offline attempts after collisions failed (it shouldn't happen). Let's undo the changes.\n            if (!lastSuccessful) {\n                throw error;\n            }\n\n            for (let attempt = lastSuccessful; offlineAttempts.indexOf(attempt) != -1; attempt++) {\n                // Move it back.\n                await AddonModScormOffline.changeAttemptNumber(scormId, attempt + newAttempts.length, attempt, siteId);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Save a snapshot from a synchronization.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attemot number.\n     * @param cmId Module ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved when the snapshot is stored.\n     */\n    protected async saveSyncSnapshot(scormId: number, attempt: number, cmId: number, siteId: string): Promise<void> {\n        // Try to get current state from the site.\n        let userData: AddonModScormUserDataMap;\n\n        try {\n            userData = await AddonModScorm.getScormUserData(scormId, attempt, {\n                cmId,\n                readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n                siteId,\n            });\n        } catch {\n            // Error getting user data from the site. We'll have to build it ourselves.\n            // Let's try to get cached data about the attempt.\n            userData = await CoreUtils.ignoreErrors(\n                AddonModScorm.getScormUserData(scormId, attempt, { cmId, siteId }),\n                <AddonModScormUserDataMap> {},\n            );\n\n            // We need to add the synced data to the snapshot.\n            const syncedData = await AddonModScormOffline.getScormStoredData(scormId, attempt, false, true, siteId);\n\n            syncedData.forEach((entry) => {\n                if (!userData[entry.scoid]) {\n                    userData[entry.scoid] = {\n                        scoid: entry.scoid,\n                        userdata: {},\n                        defaultdata: {},\n                    };\n                }\n                userData[entry.scoid].userdata[entry.element] = entry.value || '';\n            });\n\n        }\n\n        return AddonModScormOffline.setAttemptSnapshot(scormId, attempt, userData, siteId);\n\n    }\n\n    /**\n     * Compares an attempt's snapshot with the data retrieved from the site.\n     * It only compares elements with dot notation. This means that, if some SCO has been added to Moodle web\n     * but the user hasn't generated data for it, then the snapshot will be detected as equal.\n     *\n     * @param snapshot Attempt's snapshot.\n     * @param userData Data retrieved from the site.\n     * @returns True if snapshot is equal to the user data, false otherwise.\n     */\n    protected snapshotEquals(snapshot: AddonModScormUserDataMap, userData: AddonModScormUserDataMap): boolean {\n        // Check that snapshot contains the data from the site.\n        for (const scoId in userData) {\n            const siteSco = userData[scoId];\n            const snapshotSco = snapshot[scoId];\n\n            for (const element in siteSco.userdata) {\n                if (element.indexOf('.') > -1) {\n                    if (!snapshotSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        // Now check the opposite way: site userData contains the data from the snapshot.\n        for (const scoId in snapshot) {\n            const siteSco = userData[scoId];\n            const snapshotSco = snapshot[scoId];\n\n            for (const element in snapshotSco.userdata) {\n                if (element.indexOf('.') > -1) {\n                    if (!siteSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Try to synchronize all the SCORMs in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllScorms(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all SCORMs', (siteId) => this.syncAllScormsFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all SCORMs on a site.\n     *\n     * @param force Wether to force sync or not.\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllScormsFunc(force: boolean, siteId: string): Promise<void> {\n\n        // Get all offline attempts.\n        const attempts = await AddonModScormOffline.getAllAttempts(siteId);\n\n        const treated: Record<number, boolean> = {}; // To prevent duplicates.\n\n        // Sync all SCORMs that haven't been synced for a while and that aren't attempted right now.\n        await Promise.all(attempts.map(async (attempt) => {\n            if (treated[attempt.scormid] || CoreSync.isBlocked(AddonModScormProvider.COMPONENT, attempt.scormid, siteId)) {\n                return;\n            }\n\n            treated[attempt.scormid] = true;\n\n            const scorm = await AddonModScorm.getScormById(attempt.courseid, attempt.scormid, { siteId });\n\n            const data = force ?\n                await this.syncScorm(scorm, siteId) :\n                await this.syncScormIfNeeded(scorm, siteId);\n\n            if (data !== undefined) {\n                // We tried to sync. Send event.\n                CoreEvents.trigger(AddonModScormSyncProvider.AUTO_SYNCED, {\n                    scormId: scorm.id,\n                    attemptFinished: data.attemptFinished,\n                    warnings: data.warnings,\n                    updated: data.updated,\n                }, siteId);\n            }\n        }));\n    }\n\n    /**\n     * Send data from a SCORM offline attempt to the site.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param cmId Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the attempt is successfully synced.\n     */\n    protected async syncAttempt(scormId: number, attempt: number, cmId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        this.logger.debug(`Try to sync attempt ${attempt} in SCORM ${scormId} and site ${siteId}`);\n\n        // Get only not synced entries.\n        const tracks = await AddonModScormOffline.getScormStoredData(scormId, attempt, true, false, siteId);\n\n        const scos: Record<number, AddonModScormDataEntry[]> = {};\n        let somethingSynced = false;\n\n        // Get data to send (only elements with dots like cmi.core.exit, in Mobile we store more data to make offline work).\n        tracks.forEach((track) => {\n            if (track.element.indexOf('.') > -1) {\n                if (!scos[track.scoid]) {\n                    scos[track.scoid] = [];\n                }\n\n                scos[track.scoid].push({\n                    element: track.element,\n                    value: track.value || '',\n                });\n            }\n        });\n\n        try {\n            // Send the data in each SCO.\n            const promises = Object.entries(scos).map(async ([key, tracks]) => {\n                const scoId = Number(key);\n\n                await AddonModScorm.saveTracksOnline(scormId, scoId, attempt, tracks, siteId);\n\n                // Sco data successfully sent. Mark them as synced. This is needed because some SCOs sync might fail.\n                await CoreUtils.ignoreErrors(AddonModScormOffline.markAsSynced(scormId, attempt, scoId, siteId));\n\n                somethingSynced = true;\n            });\n\n            await CoreUtils.allPromises(promises);\n        } catch (error) {\n            if (somethingSynced) {\n                // Some SCOs have been synced and some not.\n                // Try to store a snapshot of the current state to be able to re-try the synchronization later.\n                this.logger.error(`Error synchronizing some SCOs for attempt ${attempt} in SCORM ${scormId}. Saving snapshot.`);\n\n                await this.saveSyncSnapshot(scormId, attempt, cmId, siteId);\n            } else {\n                this.logger.error(`Error synchronizing attempt ${attempt} in SCORM ${scormId}`);\n            }\n\n            throw error;\n        }\n\n        // Attempt has been sent. Let's delete it from local.\n        await CoreUtils.ignoreErrors(AddonModScormOffline.deleteAttempt(scormId, attempt, siteId));\n    }\n\n    /**\n     * Sync a SCORM only if a certain time has passed since the last time.\n     *\n     * @param scorm SCORM.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the SCORM is synced or if it doesn't need to be synced.\n     */\n    async syncScormIfNeeded(scorm: AddonModScormScorm, siteId?: string): Promise<AddonModScormSyncResult | undefined> {\n        const needed = await this.isSyncNeeded(scorm.id, siteId);\n\n        if (needed) {\n            return this.syncScorm(scorm, siteId);\n        }\n    }\n\n    /**\n     * Try to synchronize a SCORM.\n     *\n     * @param scorm SCORM.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success.\n     */\n    syncScorm(scorm: AddonModScormScorm, siteId?: string): Promise<AddonModScormSyncResult> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const currentSyncPromise = this.getOngoingSync(scorm.id, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this SCORM, return the promise.\n            return currentSyncPromise;\n        }\n\n        // Verify that SCORM isn't blocked.\n        if (CoreSync.isBlocked(AddonModScormProvider.COMPONENT, scorm.id, siteId)) {\n            this.logger.debug('Cannot sync SCORM ' + scorm.id + ' because it is blocked.');\n\n            throw new CoreError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));\n        }\n\n        this.logger.debug(`Try to sync SCORM ${scorm.id} in site ${siteId}`);\n\n        const syncPromise = this.performSyncScorm(scorm, siteId);\n\n        return this.addOngoingSync(scorm.id, syncPromise, siteId);\n    }\n\n    /**\n     * Try to synchronize a SCORM.\n     *\n     * @param scorm SCORM.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved in success.\n     */\n    protected async performSyncScorm(scorm: AddonModScormScorm, siteId: string): Promise<AddonModScormSyncResult> {\n        let warnings: string[] = [];\n        let lastOnline = 0;\n        let lastOnlineWasFinished = false;\n\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModScormProvider.COMPONENT, scorm.id, siteId));\n\n        // Get attempts data. We ignore cache for online attempts, so this call will fail if offline or server down.\n        const attemptsData = await AddonModScorm.getAttemptCount(scorm.id, {\n            cmId: scorm.coursemodule,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId,\n        });\n\n        if (!attemptsData.offline || !attemptsData.offline.length) {\n            // Nothing to sync.\n            return this.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished);\n        }\n\n        const initialCount = attemptsData;\n        const collisions: number[] = [];\n\n        // Check if there are collisions between offline and online attempts (same number).\n        attemptsData.online.forEach((attempt) => {\n            lastOnline = Math.max(lastOnline, attempt);\n            if (attemptsData.offline.indexOf(attempt) > -1) {\n                collisions.push(attempt);\n            }\n        });\n\n        // Check if last online attempt is finished. Ignore cache.\n        let incomplete = lastOnline <= 0 ?\n            false :\n            await AddonModScorm.isAttemptIncomplete(scorm.id, lastOnline, {\n                cmId: scorm.coursemodule,\n                readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n                siteId,\n            });\n\n        lastOnlineWasFinished = !incomplete;\n\n        if (!collisions.length) {\n            if (incomplete) {\n                // No collisions, but last online attempt is incomplete so we can't send offline attempts.\n                warnings.push(Translate.instant('addon.mod_scorm.warningsynconlineincomplete'));\n\n                return this.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, false);\n            }\n\n            // No collisions and last attempt is complete. Send offline attempts to Moodle.\n            await Promise.all(attemptsData.offline.map(async (attempt) => {\n                if (!scorm.maxattempt || attempt <= scorm.maxattempt) {\n                    await this.syncAttempt(scorm.id, attempt, scorm.coursemodule, siteId);\n                }\n            }));\n\n            // All data synced, finish.\n            return this.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, true);\n        }\n\n        // We have collisions, treat them.\n        warnings = await this.treatCollisions(scorm.id, collisions, lastOnline, attemptsData.offline, scorm.coursemodule, siteId);\n\n        // The offline attempts might have changed since some collisions can be converted to new attempts.\n        const entries = await AddonModScormOffline.getAttempts(scorm.id, siteId);\n\n        let cannotSyncSome = false;\n\n        // Get only the attempt number.\n        const attempts = entries.map((entry) => entry.attempt);\n\n        if (incomplete && attempts.indexOf(lastOnline) > -1) {\n            // Last online was incomplete, but it was continued in offline.\n            incomplete = false;\n        }\n\n        await Promise.all(attempts.map(async (attempt) => {\n            // We'll always sync attempts previous to lastOnline (failed sync or continued in offline).\n            // We'll only sync new attemps if last online attempt is completed.\n            if (!incomplete || attempt <= lastOnline) {\n                if (!scorm.maxattempt || attempt <= scorm.maxattempt) {\n                    await this.syncAttempt(scorm.id, attempt, scorm.coursemodule, siteId);\n                }\n            } else {\n                cannotSyncSome = true;\n            }\n        }));\n\n        if (cannotSyncSome) {\n            warnings.push(Translate.instant('addon.mod_scorm.warningsynconlineincomplete'));\n        }\n\n        return this.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, true);\n    }\n\n    /**\n     * Treat collisions found in a SCORM synchronization process.\n     *\n     * @param scormId SCORM ID.\n     * @param collisions Numbers of attempts that exist both in online and offline.\n     * @param lastOnline Last online attempt.\n     * @param offlineAttempts Numbers of offline attempts.\n     * @param cmId Module ID.\n     * @param siteId Site ID.\n     * @returns Promise resolved when the collisions have been treated. It returns warnings array.\n     * @description\n     *\n     * Treat collisions found in a SCORM synchronization process. A collision is when an attempt exists both in offline\n     * and online. A collision can be:\n     *\n     * - Two different attempts.\n     * - An online attempt continued in offline.\n     * - A failure in a previous sync.\n     *\n     * This function will move into new attempts the collisions that can't be merged. It will usually keep the order of the\n     * offline attempts EXCEPT if the offline attempt was created after the last offline attempt (edge case).\n     *\n     * Edge case: A user creates offline attempts and when he syncs we retrieve an incomplete online attempt, so the offline\n     * attempts cannot be synced. Then the user continues that online attempt and goes offline, so a collision is created.\n     * When we perform the next sync we detect that this collision cannot be merged, so this offline attempt needs to be\n     * created as a new attempt. Since this attempt was created after the last offline attempt, it will be added ot the end\n     * of the list if the last attempt is completed. If the last attempt is not completed then the offline data will de deleted\n     * because we can't create a new attempt.\n     */\n    protected async treatCollisions(\n        scormId: number,\n        collisions: number[],\n        lastOnline: number,\n        offlineAttempts: number[],\n        cmId: number,\n        siteId: string,\n    ): Promise<string[]> {\n\n        const warnings: string[] = [];\n        const newAttemptsSameOrder: number[] = []; // Attempts that will be created as new attempts but keeping the current order.\n        const newAttemptsAtEnd: Record<number, number> = {}; // Attempts that'll be created at the end of list (should be max 1).\n        const lastCollision = Math.max.apply(Math, collisions);\n        let lastOffline = Math.max.apply(Math, offlineAttempts);\n\n        // Get needed data from the last offline attempt.\n        const lastOfflineData = await this.getOfflineAttemptData(scormId, lastOffline, cmId, siteId);\n\n        const promises = collisions.map(async (attempt) => {\n            // First get synced entries to detect if it was a failed synchronization.\n            const synced = await AddonModScormOffline.getScormStoredData(scormId, attempt, false, true, siteId);\n\n            if (synced.length) {\n                // The attempt has synced entries, it seems to be a failed synchronization.\n                // Let's get the entries that haven't been synced, maybe it just failed to delete the attempt.\n                const tracks = await AddonModScormOffline.getScormStoredData(scormId, attempt, true, false, siteId);\n\n                // Check if there are elements to sync.\n                const hasDataToSend = tracks.find(track => track.element.indexOf('.') > -1);\n\n                if (!hasDataToSend) {\n                    // Nothing to sync, delete the attempt.\n                    return CoreUtils.ignoreErrors(AddonModScormOffline.deleteAttempt(scormId, attempt, siteId));\n                }\n\n                // There are elements to sync. We need to check if it's possible to sync them or not.\n                const canRetry = await this.canRetrySync(scormId, attempt, lastOnline, cmId, siteId);\n\n                if (!canRetry) {\n                    // Cannot retry sync, we'll create a new offline attempt if possible.\n                    return this.addToNewOrDelete(\n                        scormId,\n                        attempt,\n                        lastOffline,\n                        newAttemptsSameOrder,\n                        newAttemptsAtEnd,\n                        lastOfflineData.timecreated ?? 0,\n                        lastOfflineData.incomplete,\n                        warnings,\n                        siteId,\n                    );\n                }\n            } else {\n                // It's not a failed synchronization. Check if it's an attempt continued in offline.\n                const snapshot = await AddonModScormOffline.getAttemptSnapshot(scormId, attempt, siteId);\n\n                if (!snapshot || !Object.keys(snapshot).length) {\n                    // No snapshot, it's a different attempt.\n                    newAttemptsSameOrder.push(attempt);\n\n                    return;\n                }\n\n                // It has a snapshot, it means it continued an online attempt. We need to check if they've diverged.\n                // If it's the last attempt we don't need to ignore cache because we already did it.\n                const refresh = lastOnline != attempt;\n\n                const userData = await AddonModScorm.getScormUserData(scormId, attempt, {\n                    cmId,\n                    readingStrategy: refresh ? CoreSitesReadingStrategy.ONLY_NETWORK : undefined,\n                    siteId,\n                });\n\n                if (!this.snapshotEquals(snapshot, userData)) {\n                    // Snapshot has diverged, it will be converted into a new attempt if possible.\n                    return this.addToNewOrDelete(\n                        scormId,\n                        attempt,\n                        lastOffline,\n                        newAttemptsSameOrder,\n                        newAttemptsAtEnd,\n                        lastOfflineData.timecreated ?? 0,\n                        lastOfflineData.incomplete,\n                        warnings,\n                        siteId,\n                    );\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        await this.moveNewAttempts(scormId, newAttemptsSameOrder, lastOnline, lastCollision, offlineAttempts, siteId);\n\n        // The new attempts that need to keep the order have been created.\n        // Now create the new attempts at the end of the list of offline attempts. It should only be 1 attempt max.\n        lastOffline = lastOffline + newAttemptsSameOrder.length;\n\n        await this.createNewAttemptsAtEnd(scormId, newAttemptsAtEnd, lastOffline, siteId);\n\n        return warnings;\n    }\n\n}\n\nexport const AddonModScormSync = makeSingleton(AddonModScormSyncProvider);\n\n/**\n * Data returned by a SCORM sync.\n */\nexport type AddonModScormSyncResult = CoreSyncResult & {\n    attemptFinished: boolean; // Whether an attempt was finished in the site due to the sync,\n};\n\n/**\n * Auto sync event data.\n */\nexport type AddonModScormAutoSyncEventData = CoreSyncResult & {\n    scormId: number;\n    attemptFinished: boolean;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}