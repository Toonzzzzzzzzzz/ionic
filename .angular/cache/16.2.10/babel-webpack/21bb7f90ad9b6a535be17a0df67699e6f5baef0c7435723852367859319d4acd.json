{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreCourse } from '@features/course/services/course';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\n/**\n * Log cron handler. It will update last access of the user while app is open.\n */\nexport class CoreCourseLogCronHandlerService {\n  constructor() {\n    this.name = 'CoreCourseLogCronHandler';\n  }\n  /**\n   * Execute the process.\n   * Receives the ID of the site affected, undefined for all sites.\n   *\n   * @param siteId ID of the site affected, undefined for all sites.\n   * @param force Wether the execution is forced (manual sync).\n   * @returns Promise resolved when done, rejected if failure.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  execute(siteId, force) {\n    return _asyncToGenerator(function* () {\n      if (!siteId && !CoreSites.isLoggedIn()) {\n        // No current site, stop.\n        return;\n      }\n      const site = yield CoreSites.getSite(siteId);\n      return CoreCourse.logView(site.getSiteHomeId(), undefined, site.getId());\n    })();\n  }\n  /**\n   * Check whether it's a synchronization process or not.\n   *\n   * @returns Whether it's a synchronization process or not.\n   */\n  isSync() {\n    return false;\n  }\n  /**\n   * Get the time between consecutive executions.\n   *\n   * @returns Time between consecutive executions (in ms).\n   */\n  getInterval() {\n    return 240000; // 4 minutes. By default platform will see the user as online if lastaccess is less than 5 minutes.\n  }\n}\n_class = CoreCourseLogCronHandlerService;\n_class.ɵfac = function CoreCourseLogCronHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCourseLogCronHandler = makeSingleton(CoreCourseLogCronHandlerService);","map":{"version":3,"names":["CoreSites","CoreCourse","makeSingleton","CoreCourseLogCronHandlerService","constructor","name","execute","siteId","force","_asyncToGenerator","isLoggedIn","site","getSite","logView","getSiteHomeId","undefined","getId","isSync","getInterval","factory","ɵfac","providedIn","CoreCourseLogCronHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/services/handlers/log-cron.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreCronHandler } from '@services/cron';\nimport { CoreSites } from '@services/sites';\nimport { CoreCourse } from '@features/course/services/course';\nimport { makeSingleton } from '@singletons';\n\n/**\n * Log cron handler. It will update last access of the user while app is open.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCourseLogCronHandlerService implements CoreCronHandler {\n\n    name = 'CoreCourseLogCronHandler';\n\n    /**\n     * Execute the process.\n     * Receives the ID of the site affected, undefined for all sites.\n     *\n     * @param siteId ID of the site affected, undefined for all sites.\n     * @param force Wether the execution is forced (manual sync).\n     * @returns Promise resolved when done, rejected if failure.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async execute(siteId?: string, force?: boolean): Promise<void> {\n        if (!siteId && !CoreSites.isLoggedIn()) {\n            // No current site, stop.\n            return;\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        return CoreCourse.logView(site.getSiteHomeId(), undefined, site.getId());\n    }\n\n    /**\n     * Check whether it's a synchronization process or not.\n     *\n     * @returns Whether it's a synchronization process or not.\n     */\n    isSync(): boolean {\n        return false;\n    }\n\n    /**\n     * Get the time between consecutive executions.\n     *\n     * @returns Time between consecutive executions (in ms).\n     */\n    getInterval(): number {\n        return 240000; // 4 minutes. By default platform will see the user as online if lastaccess is less than 5 minutes.\n    }\n\n}\n\nexport const CoreCourseLogCronHandler = makeSingleton(CoreCourseLogCronHandlerService);\n"],"mappings":";;AAiBA,SAASA,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,UAAU,QAAQ,kCAAkC;AAC7D,SAASC,aAAa,QAAQ,aAAa;;AAE3C;;;AAIA,OAAM,MAAOC,+BAA+B;EAD5CC,YAAA;IAGI,KAAAC,IAAI,GAAG,0BAA0B;;EAEjC;;;;;;;;EAQA;EACMC,OAAOA,CAACC,MAAe,EAAEC,KAAe;IAAA,OAAAC,iBAAA;MAC1C,IAAI,CAACF,MAAM,IAAI,CAACP,SAAS,CAACU,UAAU,EAAE,EAAE;QACpC;QACA;;MAGJ,MAAMC,IAAI,SAASX,SAAS,CAACY,OAAO,CAACL,MAAM,CAAC;MAE5C,OAAON,UAAU,CAACY,OAAO,CAACF,IAAI,CAACG,aAAa,EAAE,EAAEC,SAAS,EAAEJ,IAAI,CAACK,KAAK,EAAE,CAAC;IAAC;EAC7E;EAEA;;;;;EAKAC,MAAMA,CAAA;IACF,OAAO,KAAK;EAChB;EAEA;;;;;EAKAC,WAAWA,CAAA;IACP,OAAO,MAAM,CAAC,CAAC;EACnB;;SAxCSf,+BAA+B;;mBAA/BA,MAA+B;AAAA;;SAA/BA,MAA+B;EAAAgB,OAAA,EAA/BhB,MAA+B,CAAAiB,IAAA;EAAAC,UAAA,EADlB;AAAM;AA6ChC,OAAO,MAAMC,wBAAwB,GAAGpB,aAAa,CAACC,+BAA+B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}