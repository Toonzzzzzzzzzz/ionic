{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreRefreshButtonModalComponent } from '@components/refresh-button-modal/refresh-button-modal';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { Subject } from 'rxjs';\nimport { PageLoadWatcher } from './page-load-watcher';\n/**\n * Class to manage requests in a page and its components.\n */\nexport class PageLoadsManager {\n  constructor() {\n    this.onRefreshPage = new Subject();\n    this.ongoingLoadWatchers = new Set();\n  }\n  /**\n   * Start a page load, creating a new load watcher and watching the page.\n   *\n   * @param page Page instance.\n   * @param staleWhileRevalidate Whether to use stale while revalidate strategy.\n   * @returns Load watcher to use.\n   */\n  startPageLoad(page, staleWhileRevalidate) {\n    var _this$initialPath;\n    this.initialPath = (_this$initialPath = this.initialPath) !== null && _this$initialPath !== void 0 ? _this$initialPath : CoreNavigator.getCurrentPath();\n    this.currentLoadWatcher = new PageLoadWatcher(this, staleWhileRevalidate);\n    this.ongoingLoadWatchers.add(this.currentLoadWatcher);\n    this.currentLoadWatcher.watchComponent(page);\n    return this.currentLoadWatcher;\n  }\n  /**\n   * Start a component load, adding it to currrent load watcher (if it exists) and watching the component.\n   *\n   * @param component Component instance.\n   * @returns Load watcher to use.\n   */\n  startComponentLoad(component) {\n    var _this$currentLoadWatc;\n    // If a component is loading data without the page loading data, probably the component is reloading/refreshing.\n    // In that case, create a load watcher instance but don't store it in currentLoadWatcher because it's not a page load.\n    const loadWatcher = (_this$currentLoadWatc = this.currentLoadWatcher) !== null && _this$currentLoadWatc !== void 0 ? _this$currentLoadWatc : new PageLoadWatcher(this, false);\n    loadWatcher.watchComponent(component);\n    return loadWatcher;\n  }\n  /**\n   * A load has finished, remove its watcher from ongoing watchers and notify if needed.\n   *\n   * @param loadWatcher Load watcher related to the load that finished.\n   */\n  onPageLoaded(loadWatcher) {\n    if (!this.ongoingLoadWatchers.has(loadWatcher)) {\n      // Watcher not in list, it probably finished already.\n      return;\n    }\n    this.removeLoadWatcher(loadWatcher);\n    if (!loadWatcher.hasMeaningfulChanges()) {\n      // No need to notify.\n      return;\n    }\n    // Check if there is another ongoing load watcher using update in background.\n    // If so, wait for the other one to finish before notifying to prevent being notified twice.\n    const ongoingLoadWatcher = this.getAnotherOngoingUpdateInBackgroundWatcher(loadWatcher);\n    if (ongoingLoadWatcher) {\n      ongoingLoadWatcher.markMeaningfulChanges();\n      return;\n    }\n    if (this.initialPath === CoreNavigator.getCurrentPath()) {\n      // User hasn't changed page, notify them.\n      this.notifyUser();\n    } else {\n      // User left the page, just update the data.\n      this.onRefreshPage.next();\n    }\n  }\n  /**\n   * Get an ongoing load watcher that supports updating in background and is not the one passed as a parameter.\n   *\n   * @param loadWatcher Load watcher to ignore.\n   * @returns Ongoing load watcher, undefined if none found.\n   */\n  getAnotherOngoingUpdateInBackgroundWatcher(loadWatcher) {\n    for (const ongoingLoadWatcher of this.ongoingLoadWatchers) {\n      if (ongoingLoadWatcher.canUpdateInBackground() && loadWatcher !== ongoingLoadWatcher) {\n        return ongoingLoadWatcher;\n      }\n    }\n  }\n  /**\n   * Remove a load watcher from the list.\n   *\n   * @param loadWatcher Load watcher to remove.\n   */\n  removeLoadWatcher(loadWatcher) {\n    this.ongoingLoadWatchers.delete(loadWatcher);\n    if (loadWatcher === this.currentLoadWatcher) {\n      delete this.currentLoadWatcher;\n    }\n  }\n  /**\n   * Notify the user, asking him if he wants to update the data.\n   */\n  notifyUser() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield CoreDomUtils.openModal({\n        component: CoreRefreshButtonModalComponent,\n        cssClass: 'core-modal-no-background core-modal-fullscreen',\n        closeOnNavigate: true\n      });\n      _this.onRefreshPage.next();\n    })();\n  }\n}","map":{"version":3,"names":["CoreRefreshButtonModalComponent","CoreNavigator","CoreDomUtils","Subject","PageLoadWatcher","PageLoadsManager","constructor","onRefreshPage","ongoingLoadWatchers","Set","startPageLoad","page","staleWhileRevalidate","_this$initialPath","initialPath","getCurrentPath","currentLoadWatcher","add","watchComponent","startComponentLoad","component","_this$currentLoadWatc","loadWatcher","onPageLoaded","has","removeLoadWatcher","hasMeaningfulChanges","ongoingLoadWatcher","getAnotherOngoingUpdateInBackgroundWatcher","markMeaningfulChanges","notifyUser","next","canUpdateInBackground","delete","_this","_asyncToGenerator","openModal","cssClass","closeOnNavigate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/page-loads-manager.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreRefreshButtonModalComponent } from '@components/refresh-button-modal/refresh-button-modal';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { Subject } from 'rxjs';\nimport { AsyncDirective } from './async-directive';\nimport { PageLoadWatcher } from './page-load-watcher';\n\n/**\n * Class to manage requests in a page and its components.\n */\nexport class PageLoadsManager {\n\n    onRefreshPage = new Subject<void>();\n\n    protected initialPath?: string;\n    protected currentLoadWatcher?: PageLoadWatcher;\n    protected ongoingLoadWatchers = new Set<PageLoadWatcher>();\n\n    /**\n     * Start a page load, creating a new load watcher and watching the page.\n     *\n     * @param page Page instance.\n     * @param staleWhileRevalidate Whether to use stale while revalidate strategy.\n     * @returns Load watcher to use.\n     */\n    startPageLoad(page: AsyncDirective, staleWhileRevalidate: boolean): PageLoadWatcher {\n        this.initialPath = this.initialPath ?? CoreNavigator.getCurrentPath();\n        this.currentLoadWatcher = new PageLoadWatcher(this, staleWhileRevalidate);\n        this.ongoingLoadWatchers.add(this.currentLoadWatcher);\n\n        this.currentLoadWatcher.watchComponent(page);\n\n        return this.currentLoadWatcher;\n    }\n\n    /**\n     * Start a component load, adding it to currrent load watcher (if it exists) and watching the component.\n     *\n     * @param component Component instance.\n     * @returns Load watcher to use.\n     */\n    startComponentLoad(component: AsyncDirective): PageLoadWatcher {\n        // If a component is loading data without the page loading data, probably the component is reloading/refreshing.\n        // In that case, create a load watcher instance but don't store it in currentLoadWatcher because it's not a page load.\n        const loadWatcher = this.currentLoadWatcher ?? new PageLoadWatcher(this, false);\n\n        loadWatcher.watchComponent(component);\n\n        return loadWatcher;\n    }\n\n    /**\n     * A load has finished, remove its watcher from ongoing watchers and notify if needed.\n     *\n     * @param loadWatcher Load watcher related to the load that finished.\n     */\n    onPageLoaded(loadWatcher: PageLoadWatcher): void {\n        if (!this.ongoingLoadWatchers.has(loadWatcher)) {\n            // Watcher not in list, it probably finished already.\n            return;\n        }\n\n        this.removeLoadWatcher(loadWatcher);\n\n        if (!loadWatcher.hasMeaningfulChanges()) {\n            // No need to notify.\n            return;\n        }\n\n        // Check if there is another ongoing load watcher using update in background.\n        // If so, wait for the other one to finish before notifying to prevent being notified twice.\n        const ongoingLoadWatcher = this.getAnotherOngoingUpdateInBackgroundWatcher(loadWatcher);\n        if (ongoingLoadWatcher) {\n            ongoingLoadWatcher.markMeaningfulChanges();\n\n            return;\n        }\n\n        if (this.initialPath === CoreNavigator.getCurrentPath()) {\n            // User hasn't changed page, notify them.\n            this.notifyUser();\n        } else {\n            // User left the page, just update the data.\n            this.onRefreshPage.next();\n        }\n    }\n\n    /**\n     * Get an ongoing load watcher that supports updating in background and is not the one passed as a parameter.\n     *\n     * @param loadWatcher Load watcher to ignore.\n     * @returns Ongoing load watcher, undefined if none found.\n     */\n    protected getAnotherOngoingUpdateInBackgroundWatcher(loadWatcher: PageLoadWatcher): PageLoadWatcher | undefined {\n        for (const ongoingLoadWatcher of this.ongoingLoadWatchers) {\n            if (ongoingLoadWatcher.canUpdateInBackground() && loadWatcher !== ongoingLoadWatcher) {\n                return ongoingLoadWatcher;\n            }\n        }\n    }\n\n    /**\n     * Remove a load watcher from the list.\n     *\n     * @param loadWatcher Load watcher to remove.\n     */\n    protected removeLoadWatcher(loadWatcher: PageLoadWatcher): void {\n        this.ongoingLoadWatchers.delete(loadWatcher);\n        if (loadWatcher === this.currentLoadWatcher) {\n            delete this.currentLoadWatcher;\n        }\n    }\n\n    /**\n     * Notify the user, asking him if he wants to update the data.\n     */\n    protected async notifyUser(): Promise<void> {\n        await CoreDomUtils.openModal<boolean>({\n            component: CoreRefreshButtonModalComponent,\n            cssClass: 'core-modal-no-background core-modal-fullscreen',\n            closeOnNavigate: true,\n        });\n\n        this.onRefreshPage.next();\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}