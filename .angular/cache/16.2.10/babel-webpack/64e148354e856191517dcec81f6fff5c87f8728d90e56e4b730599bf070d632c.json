{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { asyncObservable } from '@/core/utils/rxjs';\nimport { map } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaCourseCompletion:';\n/**\n * Service to handle course completion.\n */\nexport class AddonCourseCompletionProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('AddonCourseCompletion');\n  }\n  /**\n   * Returns whether or not the user can mark a course as self completed.\n   * It can if it's configured in the course and it hasn't been completed yet.\n   *\n   * @param userId User ID.\n   * @param completion Course completion.\n   * @returns True if user can mark course as self completed, false otherwise.\n   */\n  canMarkSelfCompleted(userId, completion) {\n    if (CoreSites.getCurrentSiteUserId() != userId) {\n      return false;\n    }\n    let selfCompletionActive = false;\n    let alreadyMarked = false;\n    completion.completions.forEach(criteria => {\n      if (criteria.type === 1) {\n        // Self completion criteria found.\n        selfCompletionActive = true;\n        alreadyMarked = criteria.complete;\n      }\n    });\n    return selfCompletionActive && !alreadyMarked;\n  }\n  /**\n   * Get completed status text. The language code returned is meant to be translated.\n   *\n   * @param completion Course completion.\n   * @returns Language code of the text to show.\n   */\n  getCompletedStatusText(completion) {\n    if (completion.completed) {\n      return 'addon.coursecompletion.completed';\n    }\n    // Let's calculate status.\n    const hasStarted = completion.completions.some(criteria => criteria.timecompleted || criteria.complete);\n    if (hasStarted) {\n      return 'addon.coursecompletion.inprogress';\n    }\n    return 'addon.coursecompletion.notyetstarted';\n  }\n  /**\n   * Get course completion status for a certain course and user.\n   *\n   * @param courseId Course ID.\n   * @param userId User ID. If not defined, use current user.\n   * @param preSets Presets to use when calling the WebService.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise to be resolved when the completion is retrieved.\n   */\n  getCompletion(courseId, userId, preSets = {}, siteId) {\n    return firstValueFrom(this.getCompletionObservable(courseId, {\n      userId,\n      preSets,\n      siteId\n    }));\n  }\n  /**\n   * Get course completion status for a certain course and user.\n   *\n   * @param courseId Course ID.\n   * @param options Options.\n   * @returns Observable returning the completion.\n   */\n  getCompletionObservable(courseId, options = {}) {\n    var _this = this;\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _options$preSets;\n      const site = yield CoreSites.getSite(options.siteId);\n      const userId = options.userId || site.getUserId();\n      _this.logger.debug('Get completion for course ' + courseId + ' and user ' + userId);\n      const data = {\n        courseid: courseId,\n        userid: userId\n      };\n      const preSets = _objectSpread(_objectSpread({}, (_options$preSets = options.preSets) !== null && _options$preSets !== void 0 ? _options$preSets : {}), {}, {\n        cacheKey: _this.getCompletionCacheKey(courseId, userId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        cacheErrors: ['notenroled']\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.readObservable('core_completion_get_course_completion_status', data, preSets).pipe(map(result => result.completionstatus));\n    }));\n  }\n  /**\n   * Get cache key for get completion WS calls.\n   *\n   * @param courseId Course ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getCompletionCacheKey(courseId, userId) {\n    return ROOT_CACHE_KEY + 'view:' + courseId + ':' + userId;\n  }\n  /**\n   * Invalidates view course completion WS call.\n   *\n   * @param courseId Course ID.\n   * @param userId User ID. If not defined, use current user.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved when the list is invalidated.\n   */\n  invalidateCourseCompletion(courseId, userId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this2.getCompletionCacheKey(courseId, userId));\n    })();\n  }\n  /**\n   * Returns whether or not the view course completion plugin is enabled for the current site.\n   *\n   * @returns True if plugin enabled, false otherwise.\n   */\n  isPluginViewEnabled() {\n    return CoreSites.isLoggedIn();\n  }\n  /**\n   * Returns whether or not the view course completion plugin is enabled for a certain course.\n   *\n   * @param courseId Course ID.\n   * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n   * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n   */\n  isPluginViewEnabledForCourse(courseId, preferCache = true) {\n    return _asyncToGenerator(function* () {\n      if (!courseId) {\n        return false;\n      }\n      const course = yield CoreCourses.getUserCourse(courseId, preferCache);\n      if (course) {\n        if (course.enablecompletion !== undefined && !course.enablecompletion) {\n          // Completion not enabled for the course.\n          return false;\n        }\n        if (course.completionhascriteria !== undefined && !course.completionhascriteria) {\n          // No criteria, cannot view completion.\n          return false;\n        }\n      }\n      return true;\n    })();\n  }\n  /**\n   * Returns whether or not the view course completion plugin is enabled for a certain user.\n   *\n   * @param courseId Course ID.\n   * @param userId User ID. If not defined, use current user.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n   */\n  isPluginViewEnabledForUser(courseId, userId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const currentUserId = site.getUserId();\n      // Check if user wants to view his own completion.\n      try {\n        if (!userId || userId === currentUserId) {\n          // Viewing own completion. Get the course to check if it has completion criteria.\n          const course = yield CoreCourses.getUserCourse(courseId, true);\n          // If the site is returning the completionhascriteria then the user can view his own completion.\n          // We already checked the value in isPluginViewEnabledForCourse.\n          if (course && course.completionhascriteria !== undefined) {\n            return true;\n          }\n        }\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      // User not viewing own completion or the site doesn't tell us if the course has criteria.\n      // The only way to know if completion can be viewed is to call the WS.\n      // Disable emergency cache to be able to detect that the plugin has been disabled (WS will fail).\n      const preSets = {\n        emergencyCache: false\n      };\n      try {\n        yield _this3.getCompletion(courseId, userId, preSets);\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WS returned an error, plugin is not enabled.\n          return false;\n        }\n      }\n      try {\n        // Not a WS error. Check if we have a cached value.\n        preSets.omitExpires = true;\n        yield _this3.getCompletion(courseId, userId, preSets);\n        return true;\n      } catch (_unused2) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Mark a course as self completed.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved on success.\n   */\n  markCourseAsSelfCompleted(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        courseid: courseId\n      };\n      const response = yield site.write('core_completion_mark_course_self_completed', params);\n      if (!response.status) {\n        throw new CoreError('Cannot mark course as self completed');\n      }\n    })();\n  }\n}\n_class = AddonCourseCompletionProvider;\n_class.ɵfac = function AddonCourseCompletionProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonCourseCompletion = makeSingleton(AddonCourseCompletionProvider);","map":{"version":3,"names":["CoreLogger","CoreSites","CoreUtils","CoreCourses","CoreSite","makeSingleton","CoreError","asyncObservable","map","firstValueFrom","ROOT_CACHE_KEY","AddonCourseCompletionProvider","constructor","logger","getInstance","canMarkSelfCompleted","userId","completion","getCurrentSiteUserId","selfCompletionActive","alreadyMarked","completions","forEach","criteria","type","complete","getCompletedStatusText","completed","hasStarted","some","timecompleted","getCompletion","courseId","preSets","siteId","getCompletionObservable","options","_this","_asyncToGenerator","_options$preSets","site","getSite","getUserId","debug","data","courseid","userid","_objectSpread","cacheKey","getCompletionCacheKey","updateFrequency","FREQUENCY_SOMETIMES","cacheErrors","getReadingStrategyPreSets","readingStrategy","readObservable","pipe","result","completionstatus","invalidateCourseCompletion","_this2","invalidateWsCacheForKey","isPluginViewEnabled","isLoggedIn","isPluginViewEnabledForCourse","preferCache","course","getUserCourse","enablecompletion","undefined","completionhascriteria","isPluginViewEnabledForUser","_this3","currentUserId","_unused","emergencyCache","error","isWebServiceError","omitExpires","_unused2","markCourseAsSelfCompleted","params","response","write","status","factory","ɵfac","providedIn","AddonCourseCompletion"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/coursecompletion/services/coursecompletion.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSites, CoreSitesCommonWSOptions } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourses } from '@features/courses/services/courses';\nimport { CoreSite  } from '@classes/sites/site';\nimport { CoreStatusWithWarningsWSResponse, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { asyncObservable } from '@/core/utils/rxjs';\nimport { map } from 'rxjs/operators';\nimport { CoreSiteWSPreSets, WSObservable } from '@classes/sites/authenticated-site';\nimport { firstValueFrom } from 'rxjs';\n\nconst ROOT_CACHE_KEY = 'mmaCourseCompletion:';\n\n/**\n * Service to handle course completion.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonCourseCompletionProvider {\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('AddonCourseCompletion');\n    }\n\n    /**\n     * Returns whether or not the user can mark a course as self completed.\n     * It can if it's configured in the course and it hasn't been completed yet.\n     *\n     * @param userId User ID.\n     * @param completion Course completion.\n     * @returns True if user can mark course as self completed, false otherwise.\n     */\n    canMarkSelfCompleted(userId: number, completion: AddonCourseCompletionCourseCompletionStatus): boolean {\n        if (CoreSites.getCurrentSiteUserId() != userId) {\n            return false;\n        }\n\n        let selfCompletionActive = false;\n        let alreadyMarked = false;\n\n        completion.completions.forEach((criteria) => {\n            if (criteria.type === 1) {\n                // Self completion criteria found.\n                selfCompletionActive = true;\n                alreadyMarked = criteria.complete;\n            }\n        });\n\n        return selfCompletionActive && !alreadyMarked;\n    }\n\n    /**\n     * Get completed status text. The language code returned is meant to be translated.\n     *\n     * @param completion Course completion.\n     * @returns Language code of the text to show.\n     */\n    getCompletedStatusText(completion: AddonCourseCompletionCourseCompletionStatus): string {\n        if (completion.completed) {\n            return 'addon.coursecompletion.completed';\n        }\n\n        // Let's calculate status.\n        const hasStarted = completion.completions.some((criteria) => criteria.timecompleted || criteria.complete);\n\n        if (hasStarted) {\n            return 'addon.coursecompletion.inprogress';\n        }\n\n        return 'addon.coursecompletion.notyetstarted';\n    }\n\n    /**\n     * Get course completion status for a certain course and user.\n     *\n     * @param courseId Course ID.\n     * @param userId User ID. If not defined, use current user.\n     * @param preSets Presets to use when calling the WebService.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise to be resolved when the completion is retrieved.\n     */\n    getCompletion(\n        courseId: number,\n        userId?: number,\n        preSets: CoreSiteWSPreSets = {},\n        siteId?: string,\n    ): Promise<AddonCourseCompletionCourseCompletionStatus> {\n        return firstValueFrom(this.getCompletionObservable(courseId, {\n            userId,\n            preSets,\n            siteId,\n        }));\n    }\n\n    /**\n     * Get course completion status for a certain course and user.\n     *\n     * @param courseId Course ID.\n     * @param options Options.\n     * @returns Observable returning the completion.\n     */\n    getCompletionObservable(\n        courseId: number,\n        options: AddonCourseCompletionGetCompletionOptions = {},\n    ): WSObservable<AddonCourseCompletionCourseCompletionStatus> {\n        return asyncObservable(async () => {\n            const site = await CoreSites.getSite(options.siteId);\n\n            const userId = options.userId || site.getUserId();\n            this.logger.debug('Get completion for course ' + courseId + ' and user ' + userId);\n\n            const data: AddonCourseCompletionGetCourseCompletionStatusWSParams = {\n                courseid: courseId,\n                userid: userId,\n            };\n\n            const preSets = {\n                ...(options.preSets ?? {}),\n                cacheKey: this.getCompletionCacheKey(courseId, userId),\n                updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n                cacheErrors: ['notenroled'],\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n            };\n\n            return site.readObservable<AddonCourseCompletionGetCourseCompletionStatusWSResponse>(\n                'core_completion_get_course_completion_status',\n                data,\n                preSets,\n            ).pipe(map(result => result.completionstatus));\n        });\n    }\n\n    /**\n     * Get cache key for get completion WS calls.\n     *\n     * @param courseId Course ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getCompletionCacheKey(courseId: number, userId: number): string {\n        return ROOT_CACHE_KEY + 'view:' + courseId + ':' + userId;\n    }\n\n    /**\n     * Invalidates view course completion WS call.\n     *\n     * @param courseId Course ID.\n     * @param userId User ID. If not defined, use current user.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved when the list is invalidated.\n     */\n    async invalidateCourseCompletion(courseId: number, userId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getCompletionCacheKey(courseId, userId));\n    }\n\n    /**\n     * Returns whether or not the view course completion plugin is enabled for the current site.\n     *\n     * @returns True if plugin enabled, false otherwise.\n     */\n    isPluginViewEnabled(): boolean {\n        return CoreSites.isLoggedIn();\n    }\n\n    /**\n     * Returns whether or not the view course completion plugin is enabled for a certain course.\n     *\n     * @param courseId Course ID.\n     * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n     * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n     */\n    async isPluginViewEnabledForCourse(courseId?: number, preferCache: boolean = true): Promise<boolean> {\n        if (!courseId) {\n            return false;\n        }\n\n        const course = await CoreCourses.getUserCourse(courseId, preferCache);\n\n        if (course) {\n            if (course.enablecompletion !== undefined && !course.enablecompletion) {\n                // Completion not enabled for the course.\n                return false;\n            }\n\n            if (course.completionhascriteria !== undefined && !course.completionhascriteria) {\n                // No criteria, cannot view completion.\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns whether or not the view course completion plugin is enabled for a certain user.\n     *\n     * @param courseId Course ID.\n     * @param userId User ID. If not defined, use current user.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.\n     */\n    async isPluginViewEnabledForUser(courseId: number, userId?: number, siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n        const currentUserId = site.getUserId();\n\n        // Check if user wants to view his own completion.\n        try {\n            if (!userId || userId === currentUserId) {\n                // Viewing own completion. Get the course to check if it has completion criteria.\n                const course = await CoreCourses.getUserCourse(courseId, true);\n\n                // If the site is returning the completionhascriteria then the user can view his own completion.\n                // We already checked the value in isPluginViewEnabledForCourse.\n                if (course && course.completionhascriteria !== undefined) {\n                    return true;\n                }\n            }\n        } catch {\n            // Ignore errors.\n        }\n\n        // User not viewing own completion or the site doesn't tell us if the course has criteria.\n        // The only way to know if completion can be viewed is to call the WS.\n        // Disable emergency cache to be able to detect that the plugin has been disabled (WS will fail).\n        const preSets: CoreSiteWSPreSets = {\n            emergencyCache: false,\n        };\n\n        try {\n            await this.getCompletion(courseId, userId, preSets);\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WS returned an error, plugin is not enabled.\n                return false;\n            }\n        }\n\n        try {\n            // Not a WS error. Check if we have a cached value.\n            preSets.omitExpires = true;\n\n            await this.getCompletion(courseId, userId, preSets);\n\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Mark a course as self completed.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved on success.\n     */\n    async markCourseAsSelfCompleted(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonCourseCompletionMarkCourseSelfCompletedWSParams = {\n            courseid: courseId,\n        };\n\n        const response = await site.write<CoreStatusWithWarningsWSResponse>('core_completion_mark_course_self_completed', params);\n\n        if (!response.status) {\n            throw new CoreError('Cannot mark course as self completed');\n        }\n    }\n\n}\n\nexport const AddonCourseCompletion = makeSingleton(AddonCourseCompletionProvider);\n\n/**\n * Completion status returned by core_completion_get_course_completion_status.\n */\nexport type AddonCourseCompletionCourseCompletionStatus = {\n    completed: boolean; // True if the course is complete, false otherwise.\n    aggregation: number; // Aggregation method 1 means all, 2 means any.\n    completions: {\n        type: number; // Completion criteria type.\n        title: string; // Completion criteria Title.\n        status: string; // Completion status (Yes/No) a % or number.\n        complete: boolean; // Completion status (true/false).\n        timecompleted: number; // Timestamp for criteria completetion.\n        details: {\n            type: string; // Type description.\n            criteria: string; // Criteria description.\n            requirement: string; // Requirement description.\n            status: string; // Status description, can be anything.\n        }; // Details.\n    }[];\n};\n\n/**\n * Params of core_completion_get_course_completion_status WS.\n */\nexport type AddonCourseCompletionGetCourseCompletionStatusWSParams = {\n    courseid: number; // Course ID.\n    userid: number; // User ID.\n};\n\n/**\n * Data returned by core_completion_get_course_completion_status WS.\n */\nexport type AddonCourseCompletionGetCourseCompletionStatusWSResponse = {\n    completionstatus: AddonCourseCompletionCourseCompletionStatus; // Course status.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of core_completion_mark_course_self_completed WS.\n */\nexport type AddonCourseCompletionMarkCourseSelfCompletedWSParams = {\n    courseid: number; // Course ID.\n};\n\n/**\n * Options for getCompletionObservable.\n */\nexport type AddonCourseCompletionGetCompletionOptions = CoreSitesCommonWSOptions & {\n    userId?: number; // Id of the user, default to current user.\n    preSets?: CoreSiteWSPreSets; // Presets to use when calling the WebService.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}