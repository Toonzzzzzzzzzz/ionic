{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton } from '@singletons';\nimport { RESPONSES_TABLE_NAME } from './database/choice';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline choices.\n */\nexport class AddonModChoiceOfflineProvider {\n  /**\n   * Delete a response.\n   *\n   * @param choiceId Choice ID to remove.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the responses belong to. If not defined, current user in site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  deleteResponse(choiceId, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.getDb().deleteRecords(RESPONSES_TABLE_NAME, {\n        choiceid: choiceId,\n        userid: userId\n      });\n    })();\n  }\n  /**\n   * Get all offline responses.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promi[se resolved with responses.\n   */\n  getResponses(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const records = yield site.getDb().getRecords(RESPONSES_TABLE_NAME);\n      return records.map(record => _this.parseResponse(record));\n    })();\n  }\n  /**\n   * Check if there are offline responses to send.\n   *\n   * @param choiceId Choice ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the responses belong to. If not defined, current user in site.\n   * @returns Promise resolved with boolean: true if has offline answers, false otherwise.\n   */\n  hasResponse(choiceId, siteId, userId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const response = yield _this2.getResponse(choiceId, siteId, userId);\n        return !!response.choiceid;\n      } catch (error) {\n        // No offline data found, return false.\n        return false;\n      }\n    })();\n  }\n  /**\n   * Get response to be synced.\n   *\n   * @param choiceId Choice ID to get.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the responses belong to. If not defined, current user in site.\n   * @returns Promise resolved with the object to be synced.\n   */\n  getResponse(choiceId, siteId, userId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const record = yield site.getDb().getRecord(RESPONSES_TABLE_NAME, {\n        choiceid: choiceId,\n        userid: userId\n      });\n      return _this3.parseResponse(record);\n    })();\n  }\n  /**\n   * Parse responses.\n   *\n   * @param entry Entry to parse.\n   * @returns Parsed entry.\n   */\n  parseResponse(entry) {\n    return _objectSpread(_objectSpread({}, entry), {}, {\n      responses: CoreTextUtils.parseJSON(entry.responses, [])\n    });\n  }\n  /**\n   * Offline version for sending a response to a choice to Moodle.\n   *\n   * @param choiceId Choice ID.\n   * @param name Choice name.\n   * @param courseId Course ID the choice belongs to.\n   * @param responses IDs of selected options.\n   * @param deleting If true, the user is deleting responses, if false, submitting.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User the responses belong to. If not defined, current user in site.\n   * @returns Promise resolved when results are successfully submitted.\n   */\n  saveResponse(choiceId, name, courseId, responses, deleting, siteId, userId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        choiceid: choiceId,\n        name: name,\n        courseid: courseId,\n        userid: userId || site.getUserId(),\n        responses: JSON.stringify(responses),\n        deleting: deleting ? 1 : 0,\n        timecreated: Date.now()\n      };\n      yield site.getDb().insertRecord(RESPONSES_TABLE_NAME, entry);\n    })();\n  }\n}\n_class = AddonModChoiceOfflineProvider;\n_class.ɵfac = function AddonModChoiceOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModChoiceOffline = makeSingleton(AddonModChoiceOfflineProvider);","map":{"version":3,"names":["CoreSites","CoreTextUtils","makeSingleton","RESPONSES_TABLE_NAME","AddonModChoiceOfflineProvider","deleteResponse","choiceId","siteId","userId","_asyncToGenerator","site","getSite","getUserId","getDb","deleteRecords","choiceid","userid","getResponses","_this","records","getRecords","map","record","parseResponse","hasResponse","_this2","response","getResponse","error","_this3","getRecord","entry","_objectSpread","responses","parseJSON","saveResponse","name","courseId","deleting","courseid","JSON","stringify","timecreated","Date","now","insertRecord","factory","ɵfac","providedIn","AddonModChoiceOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/choice/services/choice-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton } from '@singletons';\nimport { AddonModChoiceResponsesDBRecord, RESPONSES_TABLE_NAME } from './database/choice';\n\n/**\n * Service to handle offline choices.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModChoiceOfflineProvider {\n\n    /**\n     * Delete a response.\n     *\n     * @param choiceId Choice ID to remove.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the responses belong to. If not defined, current user in site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async deleteResponse(choiceId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.getDb().deleteRecords(RESPONSES_TABLE_NAME, { choiceid: choiceId, userid: userId });\n    }\n\n    /**\n     * Get all offline responses.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promi[se resolved with responses.\n     */\n    async getResponses(siteId?: string): Promise<AddonModChoiceOfflineResponses[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const records = await site.getDb().getRecords<AddonModChoiceResponsesDBRecord>(RESPONSES_TABLE_NAME);\n\n        return records.map((record) => this.parseResponse(record));\n    }\n\n    /**\n     * Check if there are offline responses to send.\n     *\n     * @param choiceId Choice ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the responses belong to. If not defined, current user in site.\n     * @returns Promise resolved with boolean: true if has offline answers, false otherwise.\n     */\n    async hasResponse(choiceId: number, siteId?: string, userId?: number): Promise<boolean> {\n        try {\n            const response = await this.getResponse(choiceId, siteId, userId);\n\n            return !!response.choiceid;\n        } catch (error) {\n            // No offline data found, return false.\n            return false;\n        }\n    }\n\n    /**\n     * Get response to be synced.\n     *\n     * @param choiceId Choice ID to get.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the responses belong to. If not defined, current user in site.\n     * @returns Promise resolved with the object to be synced.\n     */\n    async getResponse(choiceId: number, siteId?: string, userId?: number): Promise<AddonModChoiceOfflineResponses> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const record = await site.getDb().getRecord<AddonModChoiceResponsesDBRecord>(RESPONSES_TABLE_NAME, {\n            choiceid: choiceId,\n            userid: userId,\n        });\n\n        return this.parseResponse(record);\n    }\n\n    /**\n     * Parse responses.\n     *\n     * @param entry Entry to parse.\n     * @returns Parsed entry.\n     */\n    protected parseResponse(entry: AddonModChoiceResponsesDBRecord): AddonModChoiceOfflineResponses {\n        return {\n            ...entry,\n            responses: CoreTextUtils.parseJSON(entry.responses, <number[]> []),\n        };\n    }\n\n    /**\n     * Offline version for sending a response to a choice to Moodle.\n     *\n     * @param choiceId Choice ID.\n     * @param name Choice name.\n     * @param courseId Course ID the choice belongs to.\n     * @param responses IDs of selected options.\n     * @param deleting If true, the user is deleting responses, if false, submitting.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User the responses belong to. If not defined, current user in site.\n     * @returns Promise resolved when results are successfully submitted.\n     */\n    async saveResponse(\n        choiceId: number,\n        name: string,\n        courseId: number,\n        responses: number[],\n        deleting: boolean,\n        siteId?: string,\n        userId?: number,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const entry: AddonModChoiceResponsesDBRecord = {\n            choiceid: choiceId,\n            name: name,\n            courseid: courseId,\n            userid: userId || site.getUserId(),\n            responses: JSON.stringify(responses),\n            deleting: deleting ? 1 : 0,\n            timecreated: Date.now(),\n        };\n\n        await site.getDb().insertRecord(RESPONSES_TABLE_NAME, entry);\n    }\n\n}\n\nexport const AddonModChoiceOffline = makeSingleton(AddonModChoiceOfflineProvider);\n\nexport type AddonModChoiceOfflineResponses = Omit<AddonModChoiceResponsesDBRecord, 'responses'> & {\n    responses: number[];\n};\n"],"mappings":";;;AAeA,SAASA,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,aAAa,QAAQ,aAAa;AAC3C,SAA0CC,oBAAoB,QAAQ,mBAAmB;;AAEzF;;;AAIA,OAAM,MAAOC,6BAA6B;EAEtC;;;;;;;;EAQMC,cAAcA,CAACC,QAAgB,EAAEC,MAAe,EAAEC,MAAe;IAAA,OAAAC,iBAAA;MACnE,MAAMC,IAAI,SAASV,SAAS,CAACW,OAAO,CAACJ,MAAM,CAAC;MAC5CC,MAAM,GAAGA,MAAM,IAAIE,IAAI,CAACE,SAAS,EAAE;MAEnC,MAAMF,IAAI,CAACG,KAAK,EAAE,CAACC,aAAa,CAACX,oBAAoB,EAAE;QAAEY,QAAQ,EAAET,QAAQ;QAAEU,MAAM,EAAER;MAAM,CAAE,CAAC;IAAC;EACnG;EAEA;;;;;;EAMMS,YAAYA,CAACV,MAAe;IAAA,IAAAW,KAAA;IAAA,OAAAT,iBAAA;MAC9B,MAAMC,IAAI,SAASV,SAAS,CAACW,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMY,OAAO,SAAST,IAAI,CAACG,KAAK,EAAE,CAACO,UAAU,CAAkCjB,oBAAoB,CAAC;MAEpG,OAAOgB,OAAO,CAACE,GAAG,CAAEC,MAAM,IAAKJ,KAAI,CAACK,aAAa,CAACD,MAAM,CAAC,CAAC;IAAC;EAC/D;EAEA;;;;;;;;EAQME,WAAWA,CAAClB,QAAgB,EAAEC,MAAe,EAAEC,MAAe;IAAA,IAAAiB,MAAA;IAAA,OAAAhB,iBAAA;MAChE,IAAI;QACA,MAAMiB,QAAQ,SAASD,MAAI,CAACE,WAAW,CAACrB,QAAQ,EAAEC,MAAM,EAAEC,MAAM,CAAC;QAEjE,OAAO,CAAC,CAACkB,QAAQ,CAACX,QAAQ;OAC7B,CAAC,OAAOa,KAAK,EAAE;QACZ;QACA,OAAO,KAAK;;IACf;EACL;EAEA;;;;;;;;EAQMD,WAAWA,CAACrB,QAAgB,EAAEC,MAAe,EAAEC,MAAe;IAAA,IAAAqB,MAAA;IAAA,OAAApB,iBAAA;MAChE,MAAMC,IAAI,SAASV,SAAS,CAACW,OAAO,CAACJ,MAAM,CAAC;MAC5CC,MAAM,GAAGA,MAAM,IAAIE,IAAI,CAACE,SAAS,EAAE;MAEnC,MAAMU,MAAM,SAASZ,IAAI,CAACG,KAAK,EAAE,CAACiB,SAAS,CAAkC3B,oBAAoB,EAAE;QAC/FY,QAAQ,EAAET,QAAQ;QAClBU,MAAM,EAAER;OACX,CAAC;MAEF,OAAOqB,MAAI,CAACN,aAAa,CAACD,MAAM,CAAC;IAAC;EACtC;EAEA;;;;;;EAMUC,aAAaA,CAACQ,KAAsC;IAC1D,OAAAC,aAAA,CAAAA,aAAA,KACOD,KAAK;MACRE,SAAS,EAAEhC,aAAa,CAACiC,SAAS,CAACH,KAAK,CAACE,SAAS,EAAa,EAAE;IAAC;EAE1E;EAEA;;;;;;;;;;;;EAYME,YAAYA,CACd7B,QAAgB,EAChB8B,IAAY,EACZC,QAAgB,EAChBJ,SAAmB,EACnBK,QAAiB,EACjB/B,MAAe,EACfC,MAAe;IAAA,OAAAC,iBAAA;MAEf,MAAMC,IAAI,SAASV,SAAS,CAACW,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMwB,KAAK,GAAoC;QAC3ChB,QAAQ,EAAET,QAAQ;QAClB8B,IAAI,EAAEA,IAAI;QACVG,QAAQ,EAAEF,QAAQ;QAClBrB,MAAM,EAAER,MAAM,IAAIE,IAAI,CAACE,SAAS,EAAE;QAClCqB,SAAS,EAAEO,IAAI,CAACC,SAAS,CAACR,SAAS,CAAC;QACpCK,QAAQ,EAAEA,QAAQ,GAAG,CAAC,GAAG,CAAC;QAC1BI,WAAW,EAAEC,IAAI,CAACC,GAAG;OACxB;MAED,MAAMlC,IAAI,CAACG,KAAK,EAAE,CAACgC,YAAY,CAAC1C,oBAAoB,EAAE4B,KAAK,CAAC;IAAC;EACjE;;SArHS3B,6BAA6B;;mBAA7BA,MAA6B;AAAA;;SAA7BA,MAA6B;EAAA0C,OAAA,EAA7B1C,MAA6B,CAAA2C,IAAA;EAAAC,UAAA,EADhB;AAAM;AA0HhC,OAAO,MAAMC,qBAAqB,GAAG/C,aAAa,CAACE,6BAA6B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}