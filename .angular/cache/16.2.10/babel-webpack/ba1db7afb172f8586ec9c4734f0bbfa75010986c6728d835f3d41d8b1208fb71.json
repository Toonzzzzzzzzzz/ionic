{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { makeSingleton } from '@singletons';\nimport { NEW_PAGES_TABLE_NAME } from './database/wiki';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle offline wiki.\n */\nexport class AddonModWikiOfflineProvider {\n  /**\n   * Convert a value to a positive number. If not a number or less than 0, 0 will be returned.\n   *\n   * @param value Value to convert.\n   * @returns Converted value.\n   */\n  convertToPositiveNumber(value) {\n    value = Number(value);\n    return value > 0 ? value : 0;\n  }\n  /**\n   * Delete a new page.\n   *\n   * @param title Title of the page.\n   * @param subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n   * @param wikiId Wiki ID. Optional, will be used create subwiki if not informed.\n   * @param userId User ID. Optional, will be used create subwiki if not informed.\n   * @param groupId Group ID. Optional, will be used create subwiki if not informed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if deleted, rejected if failure.\n   */\n  deleteNewPage(title, subwikiId, wikiId, userId, groupId, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      subwikiId = _this.convertToPositiveNumber(subwikiId);\n      wikiId = _this.convertToPositiveNumber(wikiId);\n      userId = _this.convertToPositiveNumber(userId);\n      groupId = _this.convertToPositiveNumber(groupId);\n      yield site.getDb().deleteRecords(NEW_PAGES_TABLE_NAME, {\n        subwikiid: subwikiId,\n        wikiid: wikiId,\n        userid: userId,\n        groupid: groupId,\n        title: title\n      });\n    })();\n  }\n  /**\n   * Get all the stored new pages from all the wikis.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with pages.\n   */\n  getAllNewPages(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getAllRecords(NEW_PAGES_TABLE_NAME);\n    })();\n  }\n  /**\n   * Get a stored new page.\n   *\n   * @param title Title of the page.\n   * @param subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n   * @param wikiId Wiki ID. Optional, will be used create subwiki if not informed.\n   * @param userId User ID. Optional, will be used create subwiki if not informed.\n   * @param groupId Group ID. Optional, will be used create subwiki if not informed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with page.\n   */\n  getNewPage(title, subwikiId, wikiId, userId, groupId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      subwikiId = _this2.convertToPositiveNumber(subwikiId);\n      wikiId = _this2.convertToPositiveNumber(wikiId);\n      userId = _this2.convertToPositiveNumber(userId);\n      groupId = _this2.convertToPositiveNumber(groupId);\n      return site.getDb().getRecord(NEW_PAGES_TABLE_NAME, {\n        subwikiid: subwikiId,\n        wikiid: wikiId,\n        userid: userId,\n        groupid: groupId,\n        title: title\n      });\n    })();\n  }\n  /**\n   * Get all the stored new pages from a certain subwiki.\n   *\n   * @param subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n   * @param wikiId Wiki ID. Optional, will be used create subwiki if not informed.\n   * @param userId User ID. Optional, will be used create subwiki if not informed.\n   * @param groupId Group ID. Optional, will be used create subwiki if not informed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with pages.\n   */\n  getSubwikiNewPages(subwikiId, wikiId, userId, groupId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      subwikiId = _this3.convertToPositiveNumber(subwikiId);\n      wikiId = _this3.convertToPositiveNumber(wikiId);\n      userId = _this3.convertToPositiveNumber(userId);\n      groupId = _this3.convertToPositiveNumber(groupId);\n      return site.getDb().getRecords(NEW_PAGES_TABLE_NAME, {\n        subwikiid: subwikiId,\n        wikiid: wikiId,\n        userid: userId,\n        groupid: groupId\n      });\n    })();\n  }\n  /**\n   * Get all the stored new pages from a list of subwikis.\n   *\n   * @param subwikis List of subwiki.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with pages.\n   */\n  getSubwikisNewPages(subwikis, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let pages = [];\n      yield Promise.all(subwikis.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (subwiki) {\n          const subwikiPages = yield _this4.getSubwikiNewPages(subwiki.id, subwiki.wikiid, subwiki.userid, subwiki.groupid, siteId);\n          pages = pages.concat(subwikiPages);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return pages;\n    })();\n  }\n  /**\n   * Save a new page to be sent later.\n   *\n   * @param title Title of the page.\n   * @param content Content of the page.\n   * @param subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n   * @param wikiId Wiki ID. Optional, will be used create subwiki if not informed.\n   * @param userId User ID. Optional, will be used create subwiki if not informed.\n   * @param groupId Group ID. Optional, will be used create subwiki if not informed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if stored, rejected if failure.\n   */\n  saveNewPage(title, content, subwikiId, wikiId, userId, groupId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const now = Date.now();\n      const entry = {\n        title: title,\n        cachedcontent: content,\n        subwikiid: _this5.convertToPositiveNumber(subwikiId),\n        wikiid: _this5.convertToPositiveNumber(wikiId),\n        userid: _this5.convertToPositiveNumber(userId),\n        groupid: _this5.convertToPositiveNumber(groupId),\n        contentformat: 'html',\n        timecreated: now,\n        timemodified: now,\n        caneditpage: 1\n      };\n      yield site.getDb().insertRecord(NEW_PAGES_TABLE_NAME, entry);\n    })();\n  }\n  /**\n   * Check if a list of subwikis have offline data stored.\n   *\n   * @param subwikis List of subwikis.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether it has offline data.\n   */\n  subwikisHaveOfflineData(subwikis, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const pages = yield _this6.getSubwikisNewPages(subwikis, siteId);\n        return !!pages.length;\n      } catch (_unused) {\n        // Error, return false.\n        return false;\n      }\n    })();\n  }\n}\n_class = AddonModWikiOfflineProvider;\n_class.ɵfac = function AddonModWikiOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModWikiOffline = makeSingleton(AddonModWikiOfflineProvider);","map":{"version":3,"names":["CoreSites","makeSingleton","NEW_PAGES_TABLE_NAME","AddonModWikiOfflineProvider","convertToPositiveNumber","value","Number","deleteNewPage","title","subwikiId","wikiId","userId","groupId","siteId","_this","_asyncToGenerator","site","getSite","getDb","deleteRecords","subwikiid","wikiid","userid","groupid","getAllNewPages","getAllRecords","getNewPage","_this2","getRecord","getSubwikiNewPages","_this3","getRecords","getSubwikisNewPages","subwikis","_this4","pages","Promise","all","map","_ref","subwiki","subwikiPages","id","concat","_x","apply","arguments","saveNewPage","content","_this5","now","Date","entry","cachedcontent","contentformat","timecreated","timemodified","caneditpage","insertRecord","subwikisHaveOfflineData","_this6","length","_unused","factory","ɵfac","providedIn","AddonModWikiOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/wiki/services/wiki-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { makeSingleton } from '@singletons';\nimport { AddonModWikiPageDBRecord, NEW_PAGES_TABLE_NAME } from './database/wiki';\nimport { AddonModWikiSubwiki } from './wiki';\n\n/**\n * Service to handle offline wiki.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModWikiOfflineProvider {\n\n    /**\n     * Convert a value to a positive number. If not a number or less than 0, 0 will be returned.\n     *\n     * @param value Value to convert.\n     * @returns Converted value.\n     */\n    convertToPositiveNumber(value: string | number | undefined): number {\n        value = Number(value);\n\n        return value > 0 ? value : 0;\n    }\n\n    /**\n     * Delete a new page.\n     *\n     * @param title Title of the page.\n     * @param subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n     * @param wikiId Wiki ID. Optional, will be used create subwiki if not informed.\n     * @param userId User ID. Optional, will be used create subwiki if not informed.\n     * @param groupId Group ID. Optional, will be used create subwiki if not informed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if deleted, rejected if failure.\n     */\n    async deleteNewPage(\n        title: string,\n        subwikiId?: number,\n        wikiId?: number,\n        userId?: number,\n        groupId?: number,\n        siteId?: string,\n    ): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n\n        subwikiId = this.convertToPositiveNumber(subwikiId);\n        wikiId = this.convertToPositiveNumber(wikiId);\n        userId = this.convertToPositiveNumber(userId);\n        groupId = this.convertToPositiveNumber(groupId);\n\n        await site.getDb().deleteRecords(NEW_PAGES_TABLE_NAME, <Partial<AddonModWikiPageDBRecord>> {\n            subwikiid: subwikiId,\n            wikiid: wikiId,\n            userid: userId,\n            groupid: groupId,\n            title: title,\n        });\n    }\n\n    /**\n     * Get all the stored new pages from all the wikis.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with pages.\n     */\n    async getAllNewPages(siteId?: string): Promise<AddonModWikiPageDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getAllRecords(NEW_PAGES_TABLE_NAME);\n    }\n\n    /**\n     * Get a stored new page.\n     *\n     * @param title Title of the page.\n     * @param subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n     * @param wikiId Wiki ID. Optional, will be used create subwiki if not informed.\n     * @param userId User ID. Optional, will be used create subwiki if not informed.\n     * @param groupId Group ID. Optional, will be used create subwiki if not informed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with page.\n     */\n    async getNewPage(\n        title: string,\n        subwikiId?: number,\n        wikiId?: number,\n        userId?: number,\n        groupId?: number,\n        siteId?: string,\n    ): Promise<AddonModWikiPageDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        subwikiId = this.convertToPositiveNumber(subwikiId);\n        wikiId = this.convertToPositiveNumber(wikiId);\n        userId = this.convertToPositiveNumber(userId);\n        groupId = this.convertToPositiveNumber(groupId);\n\n        return site.getDb().getRecord(NEW_PAGES_TABLE_NAME, <Partial<AddonModWikiPageDBRecord>> {\n            subwikiid: subwikiId,\n            wikiid: wikiId,\n            userid: userId,\n            groupid: groupId,\n            title: title,\n        });\n    }\n\n    /**\n     * Get all the stored new pages from a certain subwiki.\n     *\n     * @param subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n     * @param wikiId Wiki ID. Optional, will be used create subwiki if not informed.\n     * @param userId User ID. Optional, will be used create subwiki if not informed.\n     * @param groupId Group ID. Optional, will be used create subwiki if not informed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with pages.\n     */\n    async getSubwikiNewPages(\n        subwikiId?: number,\n        wikiId?: number,\n        userId?: number,\n        groupId?: number,\n        siteId?: string,\n    ): Promise<AddonModWikiPageDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        subwikiId = this.convertToPositiveNumber(subwikiId);\n        wikiId = this.convertToPositiveNumber(wikiId);\n        userId = this.convertToPositiveNumber(userId);\n        groupId = this.convertToPositiveNumber(groupId);\n\n        return site.getDb().getRecords(NEW_PAGES_TABLE_NAME, <Partial<AddonModWikiPageDBRecord>> {\n            subwikiid: subwikiId,\n            wikiid: wikiId,\n            userid: userId,\n            groupid: groupId,\n        });\n    }\n\n    /**\n     * Get all the stored new pages from a list of subwikis.\n     *\n     * @param subwikis List of subwiki.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with pages.\n     */\n    async getSubwikisNewPages(subwikis: AddonModWikiSubwiki[], siteId?: string): Promise<AddonModWikiPageDBRecord[]> {\n        let pages: AddonModWikiPageDBRecord[] = [];\n\n        await Promise.all(subwikis.map(async (subwiki) => {\n            const subwikiPages = await this.getSubwikiNewPages(subwiki.id, subwiki.wikiid, subwiki.userid, subwiki.groupid, siteId);\n\n            pages = pages.concat(subwikiPages);\n        }));\n\n        return pages;\n    }\n\n    /**\n     * Save a new page to be sent later.\n     *\n     * @param title Title of the page.\n     * @param content Content of the page.\n     * @param subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.\n     * @param wikiId Wiki ID. Optional, will be used create subwiki if not informed.\n     * @param userId User ID. Optional, will be used create subwiki if not informed.\n     * @param groupId Group ID. Optional, will be used create subwiki if not informed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if stored, rejected if failure.\n     */\n    async saveNewPage(\n        title: string,\n        content: string,\n        subwikiId?: number,\n        wikiId?: number,\n        userId?: number,\n        groupId?: number,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const now = Date.now();\n        const entry: AddonModWikiPageDBRecord = {\n            title: title,\n            cachedcontent: content,\n            subwikiid: this.convertToPositiveNumber(subwikiId),\n            wikiid: this.convertToPositiveNumber(wikiId),\n            userid: this.convertToPositiveNumber(userId),\n            groupid: this.convertToPositiveNumber(groupId),\n            contentformat: 'html',\n            timecreated: now,\n            timemodified: now,\n            caneditpage: 1,\n        };\n\n        await site.getDb().insertRecord(NEW_PAGES_TABLE_NAME, entry);\n    }\n\n    /**\n     * Check if a list of subwikis have offline data stored.\n     *\n     * @param subwikis List of subwikis.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether it has offline data.\n     */\n    async subwikisHaveOfflineData(subwikis: AddonModWikiSubwiki[], siteId?: string): Promise<boolean> {\n        try {\n            const pages = await this.getSubwikisNewPages(subwikis, siteId);\n\n            return !!pages.length;\n        } catch {\n            // Error, return false.\n            return false;\n        }\n    }\n\n}\n\nexport const AddonModWikiOffline = makeSingleton(AddonModWikiOfflineProvider);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}