{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreContentLinksDelegate } from './contentlinks-delegate';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreContentLinksChooseSiteModalComponent } from '../components/choose-site-modal/choose-site-modal';\nimport { CoreCustomURLSchemes } from '@services/urlschemes';\nimport * as i0 from \"@angular/core\";\n/**\n * Service that provides some features regarding content links.\n */\nexport class CoreContentLinksHelperProvider {\n  /**\n   * Check whether a link can be handled by the app.\n   *\n   * @param url URL to handle.\n   * @param courseId Unused param: Course ID related to the URL.\n   * @param username Username to use to filter sites.\n   * @param checkRoot Whether to check if the URL is the root URL of a site.\n   * @returns Promise resolved with a boolean: whether the URL can be handled.\n   */\n  canHandleLink(url, courseId, username, checkRoot) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (checkRoot) {\n          const data = yield CoreSites.isStoredRootURL(url, username);\n          if (data.site) {\n            // URL is the root of the site, can handle it.\n            return true;\n          }\n        }\n        const action = yield _this.getFirstValidActionFor(url, undefined, username);\n        return !!action;\n      } catch (_unused) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Get the first valid action for a URL.\n   *\n   * @param url URL to handle.\n   * @param courseId Course ID related to the URL. Optional but recommended.\n   * @param username Username to use to filter sites.\n   * @param data Extra data to handle the URL.\n   * @returns Promise resolved with the first valid action. Returns undefined if no valid action found..\n   */\n  getFirstValidActionFor(url, courseId, username, data) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const actions = yield CoreContentLinksDelegate.getActionsFor(url, courseId, username, data);\n      if (!actions) {\n        return;\n      }\n      return _this2.getFirstValidAction(actions);\n    })();\n  }\n  /**\n   * Get the first valid action in a list of possible actions.\n   *\n   * @param actions Actions.\n   * @returns First valid action if any.\n   */\n  getFirstValidAction(actions) {\n    return actions.find(action => action && action.sites && action.sites.length);\n  }\n  /**\n   * Go to the page to choose a site.\n   *\n   * @param url URL to treat.\n   * @todo set correct root.\n   */\n  goToChooseSite(url) {\n    return _asyncToGenerator(function* () {\n      yield CoreDomUtils.openModal({\n        component: CoreContentLinksChooseSiteModalComponent,\n        componentProps: {\n          url: url\n        },\n        cssClass: 'core-modal-fullscreen'\n      });\n    })();\n  }\n  /**\n   * Handle a link.\n   *\n   * @param url URL to handle.\n   * @param username Username related with the URL. E.g. in 'http://myuser@m.com', url would be 'http://m.com' and\n   *                 the username 'myuser'. Don't use it if you don't want to filter by username.\n   * @param checkRoot Whether to check if the URL is the root URL of a site.\n   * @param openBrowserRoot Whether to open in browser if it's root URL and it belongs to current site.\n   * @returns Promise resolved with a boolean: true if URL was treated, false otherwise.\n   */\n  handleLink(url, username, checkRoot, openBrowserRoot) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        var _action$sites2;\n        if (CoreCustomURLSchemes.isCustomURL(url)) {\n          yield CoreCustomURLSchemes.handleCustomURL(url);\n          return true;\n        }\n        if (checkRoot) {\n          const data = yield CoreSites.isStoredRootURL(url, username);\n          if (data.site) {\n            // URL is the root of the site.\n            _this3.handleRootURL(data.site, openBrowserRoot);\n            return true;\n          }\n        }\n        // Check if the link should be treated by some component/addon.\n        const action = yield _this3.getFirstValidActionFor(url, undefined, username);\n        if (!action) {\n          return false;\n        }\n        if (!CoreSites.isLoggedIn()) {\n          var _action$sites;\n          // No current site. Perform the action if only 1 site found, choose the site otherwise.\n          if (((_action$sites = action.sites) === null || _action$sites === void 0 ? void 0 : _action$sites.length) == 1) {\n            action.action(action.sites[0]);\n          } else {\n            _this3.goToChooseSite(url);\n          }\n        } else if (((_action$sites2 = action.sites) === null || _action$sites2 === void 0 ? void 0 : _action$sites2.length) == 1 && action.sites[0] == CoreSites.getCurrentSiteId()) {\n          // Current site.\n          action.action(action.sites[0]);\n        } else {\n          try {\n            var _action$sites3;\n            // Not current site or more than one site. Ask for confirmation.\n            yield CoreDomUtils.showConfirm(Translate.instant('core.contentlinks.confirmurlothersite'));\n            if (((_action$sites3 = action.sites) === null || _action$sites3 === void 0 ? void 0 : _action$sites3.length) == 1) {\n              action.action(action.sites[0]);\n            } else {\n              _this3.goToChooseSite(url);\n            }\n          } catch (_unused2) {\n            // User canceled.\n          }\n        }\n        return true;\n      } catch (_unused3) {\n        // Ignore errors.\n      }\n      return false;\n    })();\n  }\n  /**\n   * Handle a root URL of a site.\n   *\n   * @param site Site to handle.\n   * @param openBrowserRoot Whether to open in browser if it's root URL and it belongs to current site.\n   * @param checkToken Whether to check that token is the same to verify it's current site. If false or not defined,\n   *                   only the URL will be checked.\n   * @returns Promise resolved when done.\n   */\n  handleRootURL(site, openBrowserRoot, checkToken) {\n    return _asyncToGenerator(function* () {\n      const currentSite = CoreSites.getCurrentSite();\n      if (currentSite && currentSite.getURL() == site.getURL() && (!checkToken || currentSite.getToken() == site.getToken())) {\n        // Already logged in.\n        if (openBrowserRoot) {\n          return site.openInBrowserWithAutoLogin(site.getURL());\n        }\n      } else {\n        // Login in the site.\n        yield CoreNavigator.navigateToSiteHome({\n          siteId: site.getId()\n        });\n      }\n    })();\n  }\n}\n_class = CoreContentLinksHelperProvider;\n_class.ɵfac = function CoreContentLinksHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreContentLinksHelper = makeSingleton(CoreContentLinksHelperProvider);","map":{"version":3,"names":["CoreSites","CoreDomUtils","CoreContentLinksDelegate","makeSingleton","Translate","CoreNavigator","CoreContentLinksChooseSiteModalComponent","CoreCustomURLSchemes","CoreContentLinksHelperProvider","canHandleLink","url","courseId","username","checkRoot","_this","_asyncToGenerator","data","isStoredRootURL","site","action","getFirstValidActionFor","undefined","_unused","_this2","actions","getActionsFor","getFirstValidAction","find","sites","length","goToChooseSite","openModal","component","componentProps","cssClass","handleLink","openBrowserRoot","_this3","_action$sites2","isCustomURL","handleCustomURL","handleRootURL","isLoggedIn","_action$sites","getCurrentSiteId","_action$sites3","showConfirm","instant","_unused2","_unused3","checkToken","currentSite","getCurrentSite","getURL","getToken","openInBrowserWithAutoLogin","navigateToSiteHome","siteId","getId","factory","ɵfac","providedIn","CoreContentLinksHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/contentlinks/services/contentlinks-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreContentLinksDelegate, CoreContentLinksAction } from './contentlinks-delegate';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreContentLinksChooseSiteModalComponent } from '../components/choose-site-modal/choose-site-modal';\nimport { CoreCustomURLSchemes } from '@services/urlschemes';\n\n/**\n * Service that provides some features regarding content links.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreContentLinksHelperProvider {\n\n    /**\n     * Check whether a link can be handled by the app.\n     *\n     * @param url URL to handle.\n     * @param courseId Unused param: Course ID related to the URL.\n     * @param username Username to use to filter sites.\n     * @param checkRoot Whether to check if the URL is the root URL of a site.\n     * @returns Promise resolved with a boolean: whether the URL can be handled.\n     */\n    async canHandleLink(url: string, courseId?: number, username?: string, checkRoot?: boolean): Promise<boolean> {\n        try {\n            if (checkRoot) {\n                const data = await CoreSites.isStoredRootURL(url, username);\n\n                if (data.site) {\n                    // URL is the root of the site, can handle it.\n                    return true;\n                }\n            }\n\n            const action = await this.getFirstValidActionFor(url, undefined, username);\n\n            return !!action;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Get the first valid action for a URL.\n     *\n     * @param url URL to handle.\n     * @param courseId Course ID related to the URL. Optional but recommended.\n     * @param username Username to use to filter sites.\n     * @param data Extra data to handle the URL.\n     * @returns Promise resolved with the first valid action. Returns undefined if no valid action found..\n     */\n    async getFirstValidActionFor(\n        url: string,\n        courseId?: number,\n        username?: string,\n        data?: unknown,\n    ): Promise<CoreContentLinksAction | undefined> {\n        const actions = await CoreContentLinksDelegate.getActionsFor(url, courseId, username, data);\n        if (!actions) {\n            return;\n        }\n\n        return this.getFirstValidAction(actions);\n    }\n\n    /**\n     * Get the first valid action in a list of possible actions.\n     *\n     * @param actions Actions.\n     * @returns First valid action if any.\n     */\n    getFirstValidAction(actions: CoreContentLinksAction[]): CoreContentLinksAction | undefined {\n        return actions.find((action) => action && action.sites && action.sites.length);\n    }\n\n    /**\n     * Go to the page to choose a site.\n     *\n     * @param url URL to treat.\n     * @todo set correct root.\n     */\n    async goToChooseSite(url: string): Promise<void> {\n        await CoreDomUtils.openModal({\n            component: CoreContentLinksChooseSiteModalComponent,\n            componentProps: {\n                url: url,\n            },\n            cssClass: 'core-modal-fullscreen',\n        });\n    }\n\n    /**\n     * Handle a link.\n     *\n     * @param url URL to handle.\n     * @param username Username related with the URL. E.g. in 'http://myuser@m.com', url would be 'http://m.com' and\n     *                 the username 'myuser'. Don't use it if you don't want to filter by username.\n     * @param checkRoot Whether to check if the URL is the root URL of a site.\n     * @param openBrowserRoot Whether to open in browser if it's root URL and it belongs to current site.\n     * @returns Promise resolved with a boolean: true if URL was treated, false otherwise.\n     */\n    async handleLink(\n        url: string,\n        username?: string,\n        checkRoot?: boolean,\n        openBrowserRoot?: boolean,\n    ): Promise<boolean> {\n        try {\n            if (CoreCustomURLSchemes.isCustomURL(url)) {\n                await CoreCustomURLSchemes.handleCustomURL(url);\n\n                return true;\n            }\n\n            if (checkRoot) {\n                const data = await CoreSites.isStoredRootURL(url, username);\n\n                if (data.site) {\n                    // URL is the root of the site.\n                    this.handleRootURL(data.site, openBrowserRoot);\n\n                    return true;\n                }\n            }\n\n            // Check if the link should be treated by some component/addon.\n            const action = await this.getFirstValidActionFor(url, undefined, username);\n            if (!action) {\n                return false;\n            }\n            if (!CoreSites.isLoggedIn()) {\n                // No current site. Perform the action if only 1 site found, choose the site otherwise.\n                if (action.sites?.length == 1) {\n                    action.action(action.sites[0]);\n                } else {\n                    this.goToChooseSite(url);\n                }\n            } else if (action.sites?.length == 1 && action.sites[0] == CoreSites.getCurrentSiteId()) {\n                // Current site.\n                action.action(action.sites[0]);\n            } else {\n                try {\n                    // Not current site or more than one site. Ask for confirmation.\n                    await CoreDomUtils.showConfirm(Translate.instant('core.contentlinks.confirmurlothersite'));\n                    if (action.sites?.length == 1) {\n                        action.action(action.sites[0]);\n                    } else {\n                        this.goToChooseSite(url);\n                    }\n                } catch {\n                    // User canceled.\n                }\n            }\n\n            return true;\n        } catch {\n            // Ignore errors.\n        }\n\n        return false;\n    }\n\n    /**\n     * Handle a root URL of a site.\n     *\n     * @param site Site to handle.\n     * @param openBrowserRoot Whether to open in browser if it's root URL and it belongs to current site.\n     * @param checkToken Whether to check that token is the same to verify it's current site. If false or not defined,\n     *                   only the URL will be checked.\n     * @returns Promise resolved when done.\n     */\n    async handleRootURL(site: CoreSite, openBrowserRoot?: boolean, checkToken?: boolean): Promise<void> {\n        const currentSite = CoreSites.getCurrentSite();\n\n        if (currentSite && currentSite.getURL() == site.getURL() && (!checkToken || currentSite.getToken() == site.getToken())) {\n            // Already logged in.\n            if (openBrowserRoot) {\n                return site.openInBrowserWithAutoLogin(site.getURL());\n            }\n        } else {\n            // Login in the site.\n            await CoreNavigator.navigateToSiteHome({ siteId: site.getId() });\n        }\n    }\n\n}\n\nexport const CoreContentLinksHelper = makeSingleton(CoreContentLinksHelperProvider);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}