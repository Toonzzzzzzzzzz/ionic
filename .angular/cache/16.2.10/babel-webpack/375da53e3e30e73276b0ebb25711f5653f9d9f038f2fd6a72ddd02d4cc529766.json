{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetwork } from '@services/network';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreConstants } from '@/core/constants';\nimport { makeSingleton, Translate } from '@singletons';\nimport { COURSE_STATUS_TABLE, COURSE_VIEWED_MODULES_TABLE } from './database/course';\nimport { CoreCourseOffline } from './course-offline';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourses, CoreCoursesProvider } from '../../courses/services/courses';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreCourseHelper } from './course-helper';\nimport { CoreCourseFormatDelegate } from './format-delegate';\nimport { CoreCronDelegate } from '@services/cron';\nimport { CoreCourseLogCronHandler } from './handlers/log-cron';\nimport { CoreSitePlugins } from '@features/siteplugins/services/siteplugins';\nimport { CoreCourseSyncProvider } from './sync';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreCourseModuleDelegate } from './module-delegate';\nimport { lazyMap } from '@/core/utils/lazy-map';\nimport { asyncInstance } from '@/core/utils/async-instance';\nimport { CoreDatabaseCachingStrategy } from '@classes/database/database-table-proxy';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CorePlatform } from '@services/platform';\nimport { asyncObservable } from '@/core/utils/rxjs';\nimport { firstValueFrom } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmCourse:';\n/**\n * Course Module completion status enumeration.\n */\nexport var CoreCourseModuleCompletionStatus;\n(function (CoreCourseModuleCompletionStatus) {\n  CoreCourseModuleCompletionStatus[CoreCourseModuleCompletionStatus[\"COMPLETION_INCOMPLETE\"] = 0] = \"COMPLETION_INCOMPLETE\";\n  CoreCourseModuleCompletionStatus[CoreCourseModuleCompletionStatus[\"COMPLETION_COMPLETE\"] = 1] = \"COMPLETION_COMPLETE\";\n  CoreCourseModuleCompletionStatus[CoreCourseModuleCompletionStatus[\"COMPLETION_COMPLETE_PASS\"] = 2] = \"COMPLETION_COMPLETE_PASS\";\n  CoreCourseModuleCompletionStatus[CoreCourseModuleCompletionStatus[\"COMPLETION_COMPLETE_FAIL\"] = 3] = \"COMPLETION_COMPLETE_FAIL\";\n})(CoreCourseModuleCompletionStatus || (CoreCourseModuleCompletionStatus = {}));\n/**\n * @deprecated since 4.3 Not used anymore.\n */\nexport var CoreCourseCompletionMode;\n(function (CoreCourseCompletionMode) {\n  CoreCourseCompletionMode[\"FULL\"] = \"full\";\n  CoreCourseCompletionMode[\"BASIC\"] = \"basic\";\n})(CoreCourseCompletionMode || (CoreCourseCompletionMode = {}));\n/**\n * Completion tracking valid values.\n */\nexport var CoreCourseModuleCompletionTracking;\n(function (CoreCourseModuleCompletionTracking) {\n  CoreCourseModuleCompletionTracking[CoreCourseModuleCompletionTracking[\"COMPLETION_TRACKING_NONE\"] = 0] = \"COMPLETION_TRACKING_NONE\";\n  CoreCourseModuleCompletionTracking[CoreCourseModuleCompletionTracking[\"COMPLETION_TRACKING_MANUAL\"] = 1] = \"COMPLETION_TRACKING_MANUAL\";\n  CoreCourseModuleCompletionTracking[CoreCourseModuleCompletionTracking[\"COMPLETION_TRACKING_AUTOMATIC\"] = 2] = \"COMPLETION_TRACKING_AUTOMATIC\";\n})(CoreCourseModuleCompletionTracking || (CoreCourseModuleCompletionTracking = {}));\n/**\n * Service that provides some features regarding a course.\n */\nexport class CoreCourseProvider {\n  constructor() {\n    this.CORE_MODULES = ['assign', 'bigbluebuttonbn', 'book', 'chat', 'choice', 'data', 'feedback', 'folder', 'forum', 'glossary', 'h5pactivity', 'imscp', 'label', 'lesson', 'lti', 'page', 'quiz', 'resource', 'scorm', 'survey', 'url', 'wiki', 'workshop'];\n    this.logger = CoreLogger.getInstance('CoreCourseProvider');\n    this.statusTables = lazyMap(siteId => asyncInstance(() => CoreSites.getSiteTable(COURSE_STATUS_TABLE, {\n      siteId,\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.Eager\n      },\n      onDestroy: () => delete this.statusTables[siteId]\n    })));\n    this.viewedModulesTables = lazyMap(siteId => asyncInstance(() => CoreSites.getSiteTable(COURSE_VIEWED_MODULES_TABLE, {\n      siteId,\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.None\n      },\n      primaryKeyColumns: ['courseId', 'cmId'],\n      onDestroy: () => delete this.viewedModulesTables[siteId]\n    })));\n  }\n  /**\n   * Initialize.\n   */\n  initialize() {\n    CorePlatform.resume.subscribe(() => {\n      // Run the handler the app is open to keep user in online status.\n      setTimeout(() => {\n        CoreUtils.ignoreErrors(CoreCronDelegate.forceCronHandlerExecution(CoreCourseLogCronHandler.name));\n      }, 1000);\n    });\n    CoreEvents.on(CoreEvents.LOGIN, () => {\n      setTimeout(() => {\n        // Ignore errors here, since probably login is not complete: it happens on token invalid.\n        CoreUtils.ignoreErrors(CoreCronDelegate.forceCronHandlerExecution(CoreCourseLogCronHandler.name));\n      }, 1000);\n    });\n  }\n  /**\n   * Check if the get course blocks WS is available in current site.\n   *\n   * @param site Site to check. If not defined, current site.\n   * @returns Whether it's available.\n   * @since 3.7\n   */\n  canGetCourseBlocks(site) {\n    site = site || CoreSites.getCurrentSite();\n    return !!site && site.isVersionGreaterEqualThan('3.7');\n  }\n  /**\n   * Check whether the site supports requesting stealth modules.\n   *\n   * @param site Site. If not defined, current site.\n   * @returns Whether the site supports requesting stealth modules.\n   * @since 3.5.3, 3.6\n   */\n  canRequestStealthModules(site) {\n    site = site || CoreSites.getCurrentSite();\n    return !!site && site.isVersionGreaterEqualThan('3.5.3');\n  }\n  /**\n   * Check if module completion could have changed. If it could have, trigger event. This function must be used,\n   * for example, after calling a \"module_view\" WS since it can change the module completion.\n   *\n   * @param courseId Course ID.\n   * @param completion Completion status of the module.\n   */\n  checkModuleCompletion(courseId, completion) {\n    if (completion && this.isIncompleteAutomaticCompletion(completion)) {\n      this.invalidateSections(courseId).finally(() => {\n        CoreEvents.trigger(CoreEvents.COMPLETION_MODULE_VIEWED, {\n          courseId: courseId,\n          cmId: completion.cmid\n        });\n      });\n    }\n  }\n  /**\n   * Given some completion data, return whether it's an automatic completion that hasn't been completed yet.\n   *\n   * @param completion Completion data.\n   * @returns Whether it's an automatic completion that hasn't been completed yet.\n   */\n  isIncompleteAutomaticCompletion(completion) {\n    return completion.tracking === CoreCourseModuleCompletionTracking.COMPLETION_TRACKING_AUTOMATIC && completion.state === CoreCourseModuleCompletionStatus.COMPLETION_INCOMPLETE;\n  }\n  /**\n   * Check whether a course has indentation enabled.\n   *\n   * @param site Site.\n   * @param courseId Course id.\n   * @returns Whether indentation is enabled.\n   */\n  isCourseIndentationEnabled(site, courseId) {\n    return _asyncToGenerator(function* () {\n      var _course$courseformato;\n      if (!site.isVersionGreaterEqualThan('4.0')) {\n        return false;\n      }\n      const course = yield CoreCourses.getCourseByField('id', courseId, site.id);\n      const formatOptions = CoreUtils.objectToKeyValueMap((_course$courseformato = course.courseformatoptions) !== null && _course$courseformato !== void 0 ? _course$courseformato : [], 'name', 'value');\n      return formatOptions.indentation === '1';\n    })();\n  }\n  /**\n   * Clear all courses status in a site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when all status are cleared.\n   */\n  clearAllCoursesStatus(siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      _this.logger.debug('Clear all course status for site ' + site.id);\n      yield _this.statusTables[site.getId()].delete();\n      _this.triggerCourseStatusChanged(CoreCourseProvider.ALL_COURSES_CLEARED, CoreConstants.NOT_DOWNLOADED, site.id);\n    })();\n  }\n  /**\n   * Check if the current view is a certain course initial page.\n   *\n   * @param courseId Course ID.\n   * @returns Whether the current view is a certain course.\n   */\n  currentViewIsCourse(courseId) {\n    const route = CoreNavigator.getCurrentRoute({\n      routeData: {\n        isCourseIndex: true\n      }\n    });\n    if (!route) {\n      return false;\n    }\n    return Number(route.snapshot.params.courseId) == courseId;\n  }\n  /**\n   * Get completion status of all the activities in a course for a certain user.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user.\n   * @param forceCache True if it should return cached data. Has priority over ignoreCache.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param includeOffline True if it should load offline data in the completion status.\n   * @returns Promise resolved with the completion statuses: object where the key is module ID.\n   */\n  getActivitiesCompletionStatus(courseId, siteId, userId, forceCache = false, ignoreCache = false, includeOffline = true) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      _this2.logger.debug(`Getting completion status for user ${userId} in course ${courseId}`);\n      const params = {\n        courseid: courseId,\n        userid: userId\n      };\n      const preSets = {\n        cacheKey: _this2.getActivitiesCompletionCacheKey(courseId, userId)\n      };\n      if (forceCache) {\n        preSets.omitExpires = true;\n      } else if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const data = yield site.read('core_completion_get_activities_completion_status', params, preSets);\n      if (!data || !data.statuses) {\n        throw Error('WS core_completion_get_activities_completion_status failed');\n      }\n      const completionStatus = CoreUtils.arrayToObject(data.statuses, 'cmid');\n      if (!includeOffline) {\n        return completionStatus;\n      }\n      try {\n        // Now get the offline completion (if any).\n        const offlineCompletions = yield CoreCourseOffline.getCourseManualCompletions(courseId, site.id);\n        offlineCompletions.forEach(offlineCompletion => {\n          if (offlineCompletion && completionStatus[offlineCompletion.cmid] !== undefined) {\n            const onlineCompletion = completionStatus[offlineCompletion.cmid];\n            // If the activity uses manual completion, override the value with the offline one.\n            if (onlineCompletion.tracking === CoreCourseModuleCompletionTracking.COMPLETION_TRACKING_MANUAL) {\n              onlineCompletion.state = offlineCompletion.completed;\n              onlineCompletion.offline = true;\n            }\n          }\n        });\n        return completionStatus;\n      } catch (_unused) {\n        // Ignore errors.\n        return completionStatus;\n      }\n    })();\n  }\n  /**\n   * Get cache key for activities completion WS calls.\n   *\n   * @param courseId Course ID.\n   * @param userId User ID.\n   * @returns Cache key.\n   */\n  getActivitiesCompletionCacheKey(courseId, userId) {\n    return ROOT_CACHE_KEY + 'activitiescompletion:' + courseId + ':' + userId;\n  }\n  /**\n   * Get certain module viewed records in the app.\n   *\n   * @param ids Module IDs.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with map of last module viewed data.\n   */\n  getCertainModulesViewed(ids = [], siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!ids.length) {\n        return {};\n      }\n      const site = yield CoreSites.getSite(siteId);\n      const whereAndParams = SQLiteDB.getInOrEqual(ids);\n      const entries = yield _this3.viewedModulesTables[site.getId()].getManyWhere({\n        sql: 'cmId ' + whereAndParams.sql,\n        sqlParams: whereAndParams.params,\n        js: record => ids.includes(record.cmId)\n      });\n      return CoreUtils.arrayToObject(entries, 'cmId');\n    })();\n  }\n  /**\n   * Get course blocks.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the list of blocks.\n   * @since 3.7\n   */\n  getCourseBlocks(courseId, siteId) {\n    return firstValueFrom(this.getCourseBlocksObservable(courseId, {\n      siteId\n    }));\n  }\n  /**\n   * Get course blocks.\n   *\n   * @param courseId Course ID.\n   * @param options Options.\n   * @returns Observable that returns the blocks.\n   * @since 3.7\n   */\n  getCourseBlocksObservable(courseId, options = {}) {\n    var _this4 = this;\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseid: courseId,\n        returncontents: true\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this4.getCourseBlocksCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.readObservable('core_block_get_course_blocks', params, preSets).pipe(map(result => result.blocks));\n    }));\n  }\n  /**\n   * Get cache key for course blocks WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getCourseBlocksCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'courseblocks:' + courseId;\n  }\n  /**\n   * Get the data stored for a course.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the data.\n   */\n  getCourseStatusData(courseId, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = yield _this5.statusTables[site.getId()].getOneByPrimaryKey({\n        id: courseId\n      });\n      if (!entry) {\n        throw Error('No entry found on course status table');\n      }\n      return entry;\n    })();\n  }\n  /**\n   * Get a course status.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the status.\n   */\n  getCourseStatus(courseId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const entry = yield _this6.getCourseStatusData(courseId, siteId);\n        return entry.status || CoreConstants.NOT_DOWNLOADED;\n      } catch (_unused2) {\n        return CoreConstants.NOT_DOWNLOADED;\n      }\n    })();\n  }\n  /**\n   * Obtain ids of downloaded courses.\n   *\n   * @param siteId Site id.\n   * @returns Resolves with an array containing downloaded course ids.\n   */\n  getDownloadedCourseIds(siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const downloadedStatuses = [CoreConstants.DOWNLOADED, CoreConstants.DOWNLOADING, CoreConstants.OUTDATED];\n      const site = yield CoreSites.getSite(siteId);\n      const entries = yield _this7.statusTables[site.getId()].getManyWhere({\n        sql: 'status IN (?,?,?)',\n        sqlParams: downloadedStatuses,\n        js: ({\n          status\n        }) => downloadedStatuses.includes(status)\n      });\n      return entries.map(entry => entry.id);\n    })();\n  }\n  /**\n   * Get last module viewed in the app for a course.\n   *\n   * @param id Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with last module viewed data, undefined if none.\n   */\n  getLastModuleViewed(id, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const viewedModules = yield _this8.getViewedModules(id, siteId);\n      return viewedModules[0];\n    })();\n  }\n  /**\n   * Get a module from Moodle.\n   *\n   * @param moduleId The module ID.\n   * @param courseId The course ID. Recommended to speed up the process and minimize data usage.\n   * @param sectionId The section ID.\n   * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, current site.\n   * @param modName If set, the app will retrieve all modules of this type with a single WS call. This reduces the\n   *                number of WS calls, but it isn't recommended for modules that can return a lot of contents.\n   * @returns Promise resolved with the module.\n   */\n  getModule(moduleId, courseId, sectionId, preferCache = false, ignoreCache = false, siteId, modName) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Helper function to do the WS request without processing the result.\n      const doRequest = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (site, courseId, moduleId, modName, includeStealth, preferCache) {\n          const params = {\n            courseid: courseId\n          };\n          params.options = [];\n          const preSets = {\n            omitExpires: preferCache,\n            updateFrequency: CoreSite.FREQUENCY_RARELY\n          };\n          if (includeStealth) {\n            params.options.push({\n              name: 'includestealthmodules',\n              value: true\n            });\n          }\n          // If modName is set, retrieve all modules of that type. Otherwise get only the module.\n          if (modName) {\n            params.options.push({\n              name: 'modname',\n              value: modName\n            });\n            preSets.cacheKey = _this9.getModuleByModNameCacheKey(modName);\n          } else {\n            params.options.push({\n              name: 'cmid',\n              value: moduleId\n            });\n            preSets.cacheKey = _this9.getModuleCacheKey(moduleId);\n          }\n          if (!preferCache && ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n          }\n          try {\n            const sections = yield site.read('core_course_get_contents', params, preSets);\n            return sections;\n          } catch (_unused3) {\n            // The module might still be cached by a request with different parameters.\n            if (!ignoreCache && !CoreNetwork.isOnline()) {\n              if (includeStealth) {\n                // Older versions didn't include the includestealthmodules option.\n                return doRequest(site, courseId, moduleId, modName, false, true);\n              } else if (modName) {\n                // Falback to the request for the given moduleId only.\n                return doRequest(site, courseId, moduleId, undefined, _this9.canRequestStealthModules(site), true);\n              }\n            }\n            throw Error('WS core_course_get_contents failed, cache ignored');\n          }\n        });\n        return function doRequest(_x, _x2, _x3, _x4, _x5, _x6) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      if (!courseId) {\n        // No courseId passed, try to retrieve it.\n        const module = yield _this9.getModuleBasicInfo(moduleId, {\n          siteId,\n          readingStrategy: 1 /* CoreSitesReadingStrategy.PREFER_CACHE */\n        });\n        courseId = module.course;\n        sectionId = module.section;\n      }\n      let sections;\n      try {\n        const site = yield CoreSites.getSite(siteId);\n        // We have courseId, we can use core_course_get_contents for compatibility.\n        _this9.logger.debug(`Getting module ${moduleId} in course ${courseId}`);\n        sections = yield doRequest(site, courseId, moduleId, modName, _this9.canRequestStealthModules(site), preferCache);\n      } catch (_unused4) {\n        // Error getting the module. Try to get all contents (without filtering by module).\n        const preSets = {\n          omitExpires: preferCache\n        };\n        if (!preferCache && ignoreCache) {\n          preSets.getFromCache = false;\n          preSets.emergencyCache = false;\n        }\n        sections = yield _this9.getSections(courseId, false, false, preSets, siteId);\n      }\n      let foundModule;\n      const foundSection = sections.find(section => {\n        if (section.id != CoreCourseProvider.STEALTH_MODULES_SECTION_ID && sectionId !== undefined && sectionId != section.id) {\n          return false;\n        }\n        foundModule = section.modules.find(module => module.id == moduleId);\n        return !!foundModule;\n      });\n      if (foundSection && foundModule) {\n        return _this9.addAdditionalModuleData(foundModule, courseId, foundSection.id);\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Add some additional info to course module.\n   *\n   * @param module Module.\n   * @param courseId Course ID of the module.\n   * @param sectionId Section ID of the module.\n   * @returns Module with additional info.\n   */\n  addAdditionalModuleData(module, courseId, sectionId) {\n    let completionData = undefined;\n    if (module.completiondata && module.completion) {\n      completionData = _objectSpread(_objectSpread({}, module.completiondata), {}, {\n        tracking: module.completion,\n        cmid: module.id,\n        courseId\n      });\n    }\n    return _objectSpread(_objectSpread({}, module), {}, {\n      course: courseId,\n      section: sectionId,\n      completiondata: completionData,\n      availabilityinfo: this.treatAvailablityInfo(module.availabilityinfo)\n    });\n  }\n  /**\n   * Gets a module basic info by module ID.\n   *\n   * @param moduleId Module ID.\n   * @param options Comon site WS options.\n   * @returns Promise resolved with the module's info.\n   */\n  getModuleBasicInfo(moduleId, options = {}) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        cmid: moduleId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this10.getModuleCacheKey(moduleId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('core_course_get_course_module', params, preSets);\n      if (response.warnings && response.warnings.length) {\n        throw new CoreWSError(response.warnings[0]);\n      }\n      return response.cm;\n    })();\n  }\n  /**\n   * Gets a module basic grade info by module ID.\n   *\n   * @param moduleId Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the module's grade info.\n   */\n  getModuleBasicGradeInfo(moduleId, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const info = yield _this11.getModuleBasicInfo(moduleId, {\n        siteId\n      });\n      if (info.grade !== undefined || info.advancedgrading !== undefined || info.outcomes !== undefined) {\n        return {\n          advancedgrading: info.advancedgrading,\n          grade: info.grade,\n          gradecat: info.gradecat,\n          gradepass: info.gradepass,\n          outcomes: info.outcomes,\n          scale: info.scale\n        };\n      }\n    })();\n  }\n  /**\n   * Gets a module basic info by instance.\n   *\n   * @param instanceId Instance ID.\n   * @param moduleName Name of the module. E.g. 'glossary'.\n   * @param options Comon site WS options.\n   * @returns Promise resolved with the module's info.\n   */\n  getModuleBasicInfoByInstance(instanceId, moduleName, options = {}) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        instance: instanceId,\n        module: moduleName\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this12.getModuleBasicInfoByInstanceCacheKey(instanceId, moduleName),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('core_course_get_course_module_by_instance', params, preSets);\n      if (response.warnings && response.warnings.length) {\n        throw new CoreWSError(response.warnings[0]);\n      } else if (response.cm) {\n        return response.cm;\n      }\n      throw Error('WS core_course_get_course_module_by_instance failed');\n    })();\n  }\n  /**\n   * Get cache key for get module by instance WS calls.\n   *\n   * @param instanceId Instance ID.\n   * @param moduleName Name of the module. E.g. 'glossary'.\n   * @returns Cache key.\n   */\n  getModuleBasicInfoByInstanceCacheKey(instanceId, moduleName) {\n    return ROOT_CACHE_KEY + 'moduleByInstance:' + moduleName + ':' + instanceId;\n  }\n  /**\n   * Get cache key for module WS calls.\n   *\n   * @param moduleId Module ID.\n   * @returns Cache key.\n   */\n  getModuleCacheKey(moduleId) {\n    return ROOT_CACHE_KEY + 'module:' + moduleId;\n  }\n  /**\n   * Get cache key for module by modname WS calls.\n   *\n   * @param modName Name of the module.\n   * @returns Cache key.\n   */\n  getModuleByModNameCacheKey(modName) {\n    return ROOT_CACHE_KEY + 'module:modName:' + modName;\n  }\n  /**\n   * Returns the source to a module icon.\n   *\n   * @param moduleName The module name.\n   * @param modicon The mod icon string to use in case we are not using a core activity.\n   * @returns The IMG src.\n   */\n  getModuleIconSrc(moduleName, modicon, mimetypeIcon = '') {\n    var _CoreSites$getCurrent;\n    if (mimetypeIcon) {\n      return mimetypeIcon;\n    }\n    if (this.CORE_MODULES.indexOf(moduleName) < 0) {\n      if (modicon) {\n        return modicon;\n      }\n      moduleName = 'external-tool';\n    }\n    let path = 'assets/img/mod/';\n    if (!((_CoreSites$getCurrent = CoreSites.getCurrentSite()) !== null && _CoreSites$getCurrent !== void 0 && _CoreSites$getCurrent.isVersionGreaterEqualThan('4.0'))) {\n      // @deprecatedonmoodle since 3.11.\n      path = 'assets/img/mod_legacy/';\n    }\n    // Use default icon on core modules.\n    return path + moduleName + '.svg';\n  }\n  /**\n   * Return a specific section.\n   *\n   * @param courseId The course ID.\n   * @param sectionId The section ID.\n   * @param excludeModules Do not return modules, return only the sections structure.\n   * @param excludeContents Do not return module contents (i.e: files inside a resource).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the section.\n   */\n  getSection(courseId, sectionId, excludeModules, excludeContents, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (sectionId < 0) {\n        throw new CoreError('Invalid section ID');\n      }\n      const sections = yield _this13.getSections(courseId, excludeModules, excludeContents, undefined, siteId);\n      const section = sections.find(section => section.id == sectionId);\n      if (section) {\n        return section;\n      }\n      throw new CoreError('Unknown section');\n    })();\n  }\n  /**\n   * Get the course sections.\n   *\n   * @param courseId The course ID.\n   * @param excludeModules Do not return modules, return only the sections structure.\n   * @param excludeContents Do not return module contents (i.e: files inside a resource).\n   * @param preSets Presets to use.\n   * @param siteId Site ID. If not defined, current site.\n   * @param includeStealthModules Whether to include stealth modules. Defaults to true.\n   * @returns The reject contains the error message, else contains the sections.\n   */\n  getSections(courseId, excludeModules = false, excludeContents = false, preSets, siteId, includeStealthModules = true) {\n    return firstValueFrom(this.getSectionsObservable(courseId, {\n      excludeModules,\n      excludeContents,\n      includeStealthModules,\n      preSets,\n      siteId\n    }));\n  }\n  /**\n   * Get the course sections.\n   *\n   * @param courseId The course ID.\n   * @param options Options.\n   * @returns Observable that returns the sections.\n   */\n  getSectionsObservable(courseId, options = {}) {\n    var _options$includeSteal,\n      _this14 = this;\n    options.includeStealthModules = (_options$includeSteal = options.includeStealthModules) !== null && _options$includeSteal !== void 0 ? _options$includeSteal : true;\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const preSets = _objectSpread(_objectSpread({}, options.preSets), {}, {\n        cacheKey: _this14.getSectionsCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const params = {\n        courseid: courseId\n      };\n      params.options = [{\n        name: 'excludemodules',\n        value: !!options.excludeModules\n      }, {\n        name: 'excludecontents',\n        value: !!options.excludeContents\n      }];\n      if (_this14.canRequestStealthModules(site)) {\n        params.options.push({\n          name: 'includestealthmodules',\n          value: !!options.includeStealthModules\n        });\n      }\n      return site.readObservable('core_course_get_contents', params, preSets).pipe(map(sections => {\n        const siteHomeId = site.getSiteHomeId();\n        let showSections = true;\n        if (courseId == siteHomeId) {\n          const storedNumSections = site.getStoredConfig('numsections');\n          showSections = storedNumSections !== undefined && !!storedNumSections;\n        }\n        if (showSections !== undefined && !showSections && sections.length > 0) {\n          // Get only the last section (Main menu block section).\n          sections.pop();\n        }\n        // Add course to all modules.\n        return sections.map(section => _objectSpread(_objectSpread({}, section), {}, {\n          availabilityinfo: _this14.treatAvailablityInfo(section.availabilityinfo),\n          modules: section.modules.map(module => _this14.addAdditionalModuleData(module, courseId, section.id))\n        }));\n      }));\n    }));\n  }\n  /**\n   * Get cache key for section WS call.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getSectionsCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'sections:' + courseId;\n  }\n  /**\n   * Given a list of sections, returns the list of modules in the sections.\n   *\n   * @param sections Sections.\n   * @returns Modules.\n   */\n  getSectionsModules(sections) {\n    if (!sections || !sections.length) {\n      return [];\n    }\n    return sections.reduce((previous, section) => previous.concat(section.modules || []), []);\n  }\n  /**\n   * Get all viewed modules in a course, ordered by timeaccess in descending order.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the list of viewed modules.\n   */\n  getViewedModules(courseId, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this15.viewedModulesTables[site.getId()].getMany({\n        courseId\n      }, {\n        sorting: [{\n          timeaccess: 'desc'\n        }]\n      });\n    })();\n  }\n  /**\n   * Invalidates course blocks WS call.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateCourseBlocks(courseId, siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this16.getCourseBlocksCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidates module WS call.\n   *\n   * @param moduleId Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param modName Module name. E.g. 'label', 'url', ...\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateModule(moduleId, siteId, modName) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const promises = [];\n      if (modName) {\n        promises.push(site.invalidateWsCacheForKey(_this17.getModuleByModNameCacheKey(modName)));\n      }\n      promises.push(site.invalidateWsCacheForKey(_this17.getModuleCacheKey(moduleId)));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidates module WS call.\n   *\n   * @param id Instance ID.\n   * @param module Name of the module. E.g. 'glossary'.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateModuleByInstance(id, module, siteId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this18.getModuleBasicInfoByInstanceCacheKey(id, module));\n    })();\n  }\n  /**\n   * Invalidates sections WS call.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined, current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateSections(courseId, siteId, userId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const promises = [];\n      const siteHomeId = site.getSiteHomeId();\n      userId = userId || site.getUserId();\n      promises.push(site.invalidateWsCacheForKey(_this19.getSectionsCacheKey(courseId)));\n      promises.push(site.invalidateWsCacheForKey(_this19.getActivitiesCompletionCacheKey(courseId, userId)));\n      if (courseId == siteHomeId) {\n        promises.push(site.invalidateConfig());\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Load module contents into module.contents if they aren't loaded already.\n   *\n   * @param module Module to load the contents.\n   * @param courseId Not used since 4.0.\n   * @param sectionId The section ID.\n   * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, current site.\n   * @param modName If set, the app will retrieve all modules of this type with a single WS call. This reduces the\n   *                number of WS calls, but it isn't recommended for modules that can return a lot of contents.\n   * @returns Promise resolved when loaded.\n   */\n  loadModuleContents(module, courseId, sectionId, preferCache, ignoreCache, siteId, modName) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      if (!ignoreCache && module.contents && module.contents.length) {\n        // Already loaded.\n        return;\n      }\n      const mod = yield _this20.getModule(module.id, module.course, sectionId, preferCache, ignoreCache, siteId, modName);\n      if (!mod.contents) {\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n      }\n      module.contents = mod.contents;\n    })();\n  }\n  /**\n   * Get module contents. If not present, this function will try to load them into module.contents.\n   * It will throw an error if contents cannot be loaded.\n   *\n   * @param module Module to get its contents.\n   * @param courseId Not used since 4.0.\n   * @param sectionId The section ID.\n   * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @param siteId Site ID. If not defined, current site.\n   * @param modName If set, the app will retrieve all modules of this type with a single WS call. This reduces the\n   *                number of WS calls, but it isn't recommended for modules that can return a lot of contents.\n   * @returns Promise resolved when loaded.\n   */\n  getModuleContents(module, courseId, sectionId, preferCache, ignoreCache, siteId, modName) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      // Make sure contents are loaded.\n      yield _this21.loadModuleContents(module, undefined, sectionId, preferCache, ignoreCache, siteId, modName);\n      if (!module.contents) {\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n      }\n      return module.contents;\n    })();\n  }\n  /**\n   * Report a course and section as being viewed.\n   *\n   * @param courseId Course ID.\n   * @param sectionNumber Section number.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(courseId, sectionNumber, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        courseid: courseId\n      };\n      if (sectionNumber !== undefined) {\n        params.sectionnumber = sectionNumber;\n      }\n      const site = yield CoreSites.getSite(siteId);\n      const response = yield site.write('core_course_view_course', params);\n      if (!response.status) {\n        throw Error('WS core_course_view_course failed.');\n      } else {\n        CoreEvents.trigger(CoreCoursesProvider.EVENT_MY_COURSES_UPDATED, {\n          courseId: courseId,\n          action: CoreCoursesProvider.ACTION_VIEW\n        }, site.getId());\n      }\n    })();\n  }\n  /**\n   * Offline version for manually marking a module as completed.\n   *\n   * @param cmId The module ID.\n   * @param completed Whether the module is completed or not.\n   * @param courseId Course ID the module belongs to.\n   * @param courseName Not used since 4.0.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when completion is successfully sent or stored.\n   */\n  markCompletedManually(cmId, completed, courseId, courseName, siteId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a completion to be synchronized later.\n      const storeOffline = () => CoreCourseOffline.markCompletedManually(cmId, completed, courseId, undefined, siteId);\n      // The offline function requires a courseId and it could be missing because it's a calculated field.\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      // Try to send it to server.\n      try {\n        const result = yield _this22.markCompletedManuallyOnline(cmId, completed, siteId);\n        // Data sent to server, if there is some offline data delete it now.\n        yield CoreUtils.ignoreErrors(CoreCourseOffline.deleteManualCompletion(cmId, siteId));\n        // Invalidate module now, completion has changed.\n        yield _this22.invalidateModule(cmId, siteId);\n        return result;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // The WebService has thrown an error, this means that responses cannot be submitted.\n          throw error;\n        } else {\n          // Couldn't connect to server, store it offline.\n          return storeOffline();\n        }\n      }\n    })();\n  }\n  /**\n   * Offline version for manually marking a module as completed.\n   *\n   * @param cmId The module ID.\n   * @param completed Whether the module is completed or not.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when completion is successfully sent.\n   */\n  markCompletedManuallyOnline(cmId, completed, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        cmid: cmId,\n        completed: completed\n      };\n      const result = yield site.write('core_completion_update_activity_completion_status_manually', params);\n      if (!result.status) {\n        if (result.warnings && result.warnings.length) {\n          throw new CoreWSError(result.warnings[0]);\n        }\n        throw new CoreError('Cannot change completion.');\n      }\n      return result;\n    })();\n  }\n  /**\n   * Check if a module has a view page. E.g. labels don't have a view page.\n   *\n   * @param module The module object.\n   * @returns Whether the module has a view page.\n   */\n  moduleHasView(module) {\n    if ('modname' in module) {\n      // noviewlink was introduced in 3.8.5, use supports feature as a fallback.\n      if (module.noviewlink || CoreCourseModuleDelegate.supportsFeature(module.modname, CoreConstants.FEATURE_NO_VIEW_LINK, false)) {\n        return false;\n      }\n    }\n    return !!module.url;\n  }\n  /**\n   * Wait for any course format plugin to load, and open the course page.\n   *\n   * If the plugin's promise is resolved, the course page will be opened. If it is rejected, they will see an error.\n   * If the promise for the plugin is still in progress when the user tries to open the course, a loader\n   * will be displayed until it is complete, before the course page is opened. If the promise is already complete,\n   * they will see the result immediately.\n   *\n   * This function must be in here instead of course helper to prevent circular dependencies.\n   *\n   * @param course Course to open\n   * @param navOptions Navigation options that includes params to pass to the page.\n   * @returns Promise resolved when done.\n   */\n  openCourse(course, navOptions) {\n    return _asyncToGenerator(function* () {\n      var _CoreSites$getCurrent2;\n      if (course.id === ((_CoreSites$getCurrent2 = CoreSites.getCurrentSite()) === null || _CoreSites$getCurrent2 === void 0 ? void 0 : _CoreSites$getCurrent2.getSiteHomeId())) {\n        // Open site home.\n        yield CoreNavigator.navigate('/main/home/site', navOptions);\n        return;\n      }\n      const loading = yield CoreDomUtils.showModalLoading();\n      // Wait for site plugins to be fetched.\n      yield CoreUtils.ignoreErrors(CoreSitePlugins.waitFetchPlugins());\n      if (!('format' in course) || course.format === undefined) {\n        const result = yield CoreCourseHelper.getCourse(course.id);\n        course = result.course;\n      }\n      const format = 'format' in course && `format_${course.format}`;\n      if (!format || !CoreSitePlugins.sitePluginPromiseExists(`format_${format}`)) {\n        // No custom format plugin. We don't need to wait for anything.\n        loading.dismiss();\n        yield CoreCourseFormatDelegate.openCourse(course, navOptions);\n        return;\n      }\n      // This course uses a custom format plugin, wait for the format plugin to finish loading.\n      try {\n        yield CoreSitePlugins.sitePluginLoaded(format);\n        // The format loaded successfully, but the handlers wont be registered until all site plugins have loaded.\n        if (CoreSitePlugins.sitePluginsFinishedLoading) {\n          return CoreCourseFormatDelegate.openCourse(course, navOptions);\n        }\n        // Wait for plugins to be loaded.\n        yield new Promise((resolve, reject) => {\n          const observer = CoreEvents.on(CoreEvents.SITE_PLUGINS_LOADED, () => {\n            observer === null || observer === void 0 || observer.off();\n            CoreCourseFormatDelegate.openCourse(course, navOptions).then(resolve).catch(reject);\n          });\n        });\n        return;\n      } catch (error) {\n        // The site plugin failed to load. The user needs to restart the app to try loading it again.\n        const message = Translate.instant('core.courses.errorloadplugins');\n        const reload = Translate.instant('core.courses.reload');\n        const ignore = Translate.instant('core.courses.ignore');\n        yield CoreDomUtils.showConfirm(message, '', reload, ignore);\n        window.location.reload();\n      } finally {\n        loading.dismiss();\n      }\n    })();\n  }\n  /**\n   * Select a certain tab in the course. Please use currentViewIsCourse() first to verify user is viewing the course.\n   *\n   * @param name Name of the tab. If not provided, course contents.\n   * @param params Other params.\n   */\n  selectCourseTab(name, params) {\n    params = params || {};\n    params.name = name || '';\n    CoreEvents.trigger(CoreEvents.SELECT_COURSE_TAB, params);\n  }\n  /**\n   * Change the course status, setting it to the previous status.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the status is changed. Resolve param: new status.\n   */\n  setCoursePreviousStatus(courseId, siteId) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      _this23.logger.debug(`Set previous status for course ${courseId} in site ${siteId}`);\n      const site = yield CoreSites.getSite(siteId);\n      const entry = yield _this23.getCourseStatusData(courseId, siteId);\n      _this23.logger.debug(`Set previous status '${entry.status}' for course ${courseId}`);\n      const newData = {\n        id: courseId,\n        status: entry.previous || CoreConstants.NOT_DOWNLOADED,\n        updated: Date.now(),\n        // Going back from downloading to previous status, restore previous download time.\n        downloadTime: entry.status == CoreConstants.DOWNLOADING ? entry.previousDownloadTime : entry.downloadTime\n      };\n      yield _this23.statusTables[site.getId()].update(newData, {\n        id: courseId\n      });\n      // Success updating, trigger event.\n      _this23.triggerCourseStatusChanged(courseId, newData.status, siteId);\n      return newData.status;\n    })();\n  }\n  /**\n   * Store course status.\n   *\n   * @param courseId Course ID.\n   * @param status New course status.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the status is stored.\n   */\n  setCourseStatus(courseId, status, siteId) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      _this24.logger.debug(`Set status '${status}' for course ${courseId} in site ${siteId}`);\n      const site = yield CoreSites.getSite(siteId);\n      let downloadTime = 0;\n      let previousDownloadTime = 0;\n      let previousStatus = '';\n      if (status == CoreConstants.DOWNLOADING) {\n        // Set download time if course is now downloading.\n        downloadTime = CoreTimeUtils.timestamp();\n      }\n      try {\n        const entry = yield _this24.getCourseStatusData(courseId, siteId);\n        if (downloadTime === undefined) {\n          // Keep previous download time.\n          downloadTime = entry.downloadTime;\n          previousDownloadTime = entry.previousDownloadTime;\n        } else {\n          // The downloadTime will be updated, store current time as previous.\n          previousDownloadTime = entry.downloadTime;\n        }\n        previousStatus = entry.status;\n      } catch (_unused5) {\n        // New entry.\n      }\n      if (previousStatus != status) {\n        // Status has changed, update it.\n        yield _this24.statusTables[site.getId()].insert({\n          id: courseId,\n          status: status,\n          previous: previousStatus,\n          updated: Date.now(),\n          downloadTime: downloadTime,\n          previousDownloadTime: previousDownloadTime\n        });\n      }\n      // Success inserting, trigger event.\n      _this24.triggerCourseStatusChanged(courseId, status, siteId);\n    })();\n  }\n  /**\n   * Store activity as viewed.\n   *\n   * @param courseId Chapter ID.\n   * @param cmId Module ID.\n   * @param options Other options.\n   * @returns Promise resolved with last chapter viewed, undefined if none.\n   */\n  storeModuleViewed(courseId, cmId, options = {}) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      var _options$timeaccess;\n      const site = yield CoreSites.getSite(options.siteId);\n      const timeaccess = (_options$timeaccess = options.timeaccess) !== null && _options$timeaccess !== void 0 ? _options$timeaccess : Date.now();\n      yield _this25.viewedModulesTables[site.getId()].insert({\n        courseId,\n        cmId,\n        sectionId: options.sectionId,\n        timeaccess\n      });\n      CoreEvents.trigger(CoreEvents.COURSE_MODULE_VIEWED, {\n        courseId,\n        cmId,\n        timeaccess,\n        sectionId: options.sectionId\n      }, site.getId());\n    })();\n  }\n  /**\n   * Translate a module name to current language.\n   *\n   * @param moduleName The module name.\n   * @param fallback Fallback text to use if not translated. Will use moduleName otherwise.\n   *\n   * @returns Translated name.\n   */\n  translateModuleName(moduleName, fallback) {\n    const langKey = 'core.mod_' + moduleName;\n    const translated = Translate.instant(langKey);\n    return translated !== langKey ? translated : fallback || moduleName;\n  }\n  /**\n   * Trigger COURSE_STATUS_CHANGED with the right data.\n   *\n   * @param courseId Course ID.\n   * @param status New course status.\n   * @param siteId Site ID. If not defined, current site.\n   */\n  triggerCourseStatusChanged(courseId, status, siteId) {\n    CoreEvents.trigger(CoreEvents.COURSE_STATUS_CHANGED, {\n      courseId: courseId,\n      status: status\n    }, siteId);\n  }\n  /**\n   * Treat availability info HTML.\n   *\n   * @param availabilityInfo HTML to treat.\n   * @returns Treated HTML.\n   */\n  treatAvailablityInfo(availabilityInfo) {\n    if (!availabilityInfo) {\n      return availabilityInfo;\n    }\n    // Remove \"Show more\" option in 4.2 or older sites.\n    return CoreDomUtils.removeElementFromHtml(availabilityInfo, 'li[data-action=\"showmore\"]');\n  }\n}\n_class = CoreCourseProvider;\n_class.ALL_SECTIONS_ID = -2;\n_class.STEALTH_MODULES_SECTION_ID = -1;\n_class.ACCESS_GUEST = 'courses_access_guest';\n_class.ACCESS_DEFAULT = 'courses_access_default';\n_class.ALL_COURSES_CLEARED = -1;\n_class.COMPONENT = 'CoreCourse';\n_class.ɵfac = function CoreCourseProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCourse = makeSingleton(CoreCourseProvider);","map":{"version":3,"names":["CoreNetwork","CoreEvents","CoreLogger","CoreSites","CoreSitesReadingStrategy","CoreTimeUtils","CoreUtils","CoreSite","CoreConstants","makeSingleton","Translate","COURSE_STATUS_TABLE","COURSE_VIEWED_MODULES_TABLE","CoreCourseOffline","CoreError","CoreCourses","CoreCoursesProvider","CoreDomUtils","CoreWSError","CoreCourseHelper","CoreCourseFormatDelegate","CoreCronDelegate","CoreCourseLogCronHandler","CoreSitePlugins","CoreCourseSyncProvider","CoreNavigator","CoreCourseModuleDelegate","lazyMap","asyncInstance","CoreDatabaseCachingStrategy","SQLiteDB","CorePlatform","asyncObservable","firstValueFrom","map","ROOT_CACHE_KEY","CoreCourseModuleCompletionStatus","CoreCourseCompletionMode","CoreCourseModuleCompletionTracking","CoreCourseProvider","constructor","CORE_MODULES","logger","getInstance","statusTables","siteId","getSiteTable","config","cachingStrategy","Eager","onDestroy","viewedModulesTables","None","primaryKeyColumns","initialize","resume","subscribe","setTimeout","ignoreErrors","forceCronHandlerExecution","name","on","LOGIN","canGetCourseBlocks","site","getCurrentSite","isVersionGreaterEqualThan","canRequestStealthModules","checkModuleCompletion","courseId","completion","isIncompleteAutomaticCompletion","invalidateSections","finally","trigger","COMPLETION_MODULE_VIEWED","cmId","cmid","tracking","COMPLETION_TRACKING_AUTOMATIC","state","COMPLETION_INCOMPLETE","isCourseIndentationEnabled","_asyncToGenerator","_course$courseformato","course","getCourseByField","id","formatOptions","objectToKeyValueMap","courseformatoptions","indentation","clearAllCoursesStatus","_this","getSite","debug","getId","delete","triggerCourseStatusChanged","ALL_COURSES_CLEARED","NOT_DOWNLOADED","currentViewIsCourse","route","getCurrentRoute","routeData","isCourseIndex","Number","snapshot","params","getActivitiesCompletionStatus","userId","forceCache","ignoreCache","includeOffline","_this2","getUserId","courseid","userid","preSets","cacheKey","getActivitiesCompletionCacheKey","omitExpires","getFromCache","emergencyCache","data","read","statuses","Error","completionStatus","arrayToObject","offlineCompletions","getCourseManualCompletions","forEach","offlineCompletion","undefined","onlineCompletion","COMPLETION_TRACKING_MANUAL","completed","offline","_unused","getCertainModulesViewed","ids","_this3","length","whereAndParams","getInOrEqual","entries","getManyWhere","sql","sqlParams","js","record","includes","getCourseBlocks","getCourseBlocksObservable","options","_this4","returncontents","_objectSpread","getCourseBlocksCacheKey","updateFrequency","FREQUENCY_RARELY","getReadingStrategyPreSets","readingStrategy","readObservable","pipe","result","blocks","getCourseStatusData","_this5","entry","getOneByPrimaryKey","getCourseStatus","_this6","status","_unused2","getDownloadedCourseIds","_this7","downloadedStatuses","DOWNLOADED","DOWNLOADING","OUTDATED","getLastModuleViewed","_this8","viewedModules","getViewedModules","getModule","moduleId","sectionId","preferCache","modName","_this9","getCurrentSiteId","doRequest","_ref2","includeStealth","push","value","getModuleByModNameCacheKey","getModuleCacheKey","sections","_unused3","isOnline","_x","_x2","_x3","_x4","_x5","_x6","apply","arguments","module","getModuleBasicInfo","section","_unused4","getSections","foundModule","foundSection","find","STEALTH_MODULES_SECTION_ID","modules","addAdditionalModuleData","instant","completionData","completiondata","availabilityinfo","treatAvailablityInfo","_this10","response","warnings","cm","getModuleBasicGradeInfo","_this11","info","grade","advancedgrading","outcomes","gradecat","gradepass","scale","getModuleBasicInfoByInstance","instanceId","moduleName","_this12","instance","getModuleBasicInfoByInstanceCacheKey","getModuleIconSrc","modicon","mimetypeIcon","_CoreSites$getCurrent","indexOf","path","getSection","excludeModules","excludeContents","_this13","includeStealthModules","getSectionsObservable","_options$includeSteal","_this14","getSectionsCacheKey","siteHomeId","getSiteHomeId","showSections","storedNumSections","getStoredConfig","pop","getSectionsModules","reduce","previous","concat","_this15","getMany","sorting","timeaccess","invalidateCourseBlocks","_this16","invalidateWsCacheForKey","invalidateModule","_this17","promises","Promise","all","invalidateModuleByInstance","_this18","_this19","invalidateConfig","loadModuleContents","_this20","contents","mod","getModuleContents","_this21","logView","sectionNumber","sectionnumber","write","EVENT_MY_COURSES_UPDATED","action","ACTION_VIEW","markCompletedManually","courseName","_this22","storeOffline","markCompletedManuallyOnline","deleteManualCompletion","error","isWebServiceError","moduleHasView","noviewlink","supportsFeature","modname","FEATURE_NO_VIEW_LINK","url","openCourse","navOptions","_CoreSites$getCurrent2","navigate","loading","showModalLoading","waitFetchPlugins","format","getCourse","sitePluginPromiseExists","dismiss","sitePluginLoaded","sitePluginsFinishedLoading","resolve","reject","observer","SITE_PLUGINS_LOADED","off","then","catch","message","reload","ignore","showConfirm","window","location","selectCourseTab","SELECT_COURSE_TAB","setCoursePreviousStatus","_this23","newData","updated","Date","now","downloadTime","previousDownloadTime","update","setCourseStatus","_this24","previousStatus","timestamp","_unused5","insert","storeModuleViewed","_this25","_options$timeaccess","COURSE_MODULE_VIEWED","translateModuleName","fallback","langKey","translated","COURSE_STATUS_CHANGED","availabilityInfo","removeElementFromHtml","_class","ALL_SECTIONS_ID","ACCESS_GUEST","ACCESS_DEFAULT","COMPONENT","factory","ɵfac","providedIn","CoreCourse"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/services/course.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { Params } from '@angular/router';\n\nimport { CoreNetwork } from '@services/network';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreSitesCommonWSOptions, CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreConstants } from '@/core/constants';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreStatusWithWarningsWSResponse, CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\n\nimport {\n    CoreCourseStatusDBRecord, CoreCourseViewedModulesDBRecord, COURSE_STATUS_TABLE, COURSE_VIEWED_MODULES_TABLE ,\n} from './database/course';\nimport { CoreCourseOffline } from './course-offline';\nimport { CoreError } from '@classes/errors/error';\nimport {\n    CoreCourseAnyCourseData,\n    CoreCourses,\n    CoreCoursesProvider,\n} from '../../courses/services/courses';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreCourseHelper, CoreCourseModuleData, CoreCourseModuleCompletionData } from './course-helper';\nimport { CoreCourseFormatDelegate } from './format-delegate';\nimport { CoreCronDelegate } from '@services/cron';\nimport { CoreCourseLogCronHandler } from './handlers/log-cron';\nimport { CoreSitePlugins } from '@features/siteplugins/services/siteplugins';\nimport { CoreCourseAutoSyncData, CoreCourseSyncProvider } from './sync';\nimport { CoreTagItem } from '@features/tag/services/tag';\nimport { CoreNavigationOptions, CoreNavigator } from '@services/navigator';\nimport { CoreCourseModuleDelegate } from './module-delegate';\nimport { lazyMap, LazyMap } from '@/core/utils/lazy-map';\nimport { asyncInstance, AsyncInstance } from '@/core/utils/async-instance';\nimport { CoreDatabaseTable } from '@classes/database/database-table';\nimport { CoreDatabaseCachingStrategy } from '@classes/database/database-table-proxy';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CorePlatform } from '@services/platform';\nimport { asyncObservable } from '@/core/utils/rxjs';\nimport { firstValueFrom } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { CoreSiteWSPreSets, WSObservable } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmCourse:';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [CoreCourseSyncProvider.AUTO_SYNCED]: CoreCourseAutoSyncData;\n    }\n\n}\n\n/**\n * Course Module completion status enumeration.\n */\nexport enum CoreCourseModuleCompletionStatus {\n    COMPLETION_INCOMPLETE = 0,\n    COMPLETION_COMPLETE = 1,\n    COMPLETION_COMPLETE_PASS = 2,\n    COMPLETION_COMPLETE_FAIL = 3,\n}\n\n/**\n * @deprecated since 4.3 Not used anymore.\n */\nexport enum CoreCourseCompletionMode {\n    FULL = 'full',\n    BASIC = 'basic',\n}\n\n/**\n * Completion tracking valid values.\n */\nexport enum CoreCourseModuleCompletionTracking {\n    COMPLETION_TRACKING_NONE = 0,\n    COMPLETION_TRACKING_MANUAL = 1,\n    COMPLETION_TRACKING_AUTOMATIC = 2,\n}\n\n/**\n * Service that provides some features regarding a course.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCourseProvider {\n\n    static readonly ALL_SECTIONS_ID = -2;\n    static readonly STEALTH_MODULES_SECTION_ID = -1;\n    static readonly ACCESS_GUEST = 'courses_access_guest';\n    static readonly ACCESS_DEFAULT = 'courses_access_default';\n    static readonly ALL_COURSES_CLEARED = -1;\n\n    static readonly COMPONENT = 'CoreCourse';\n\n    readonly CORE_MODULES = [\n        'assign', 'bigbluebuttonbn', 'book', 'chat', 'choice', 'data', 'feedback', 'folder', 'forum', 'glossary', 'h5pactivity',\n        'imscp', 'label', 'lesson', 'lti', 'page', 'quiz', 'resource', 'scorm', 'survey', 'url', 'wiki', 'workshop',\n    ];\n\n    protected logger: CoreLogger;\n    protected statusTables: LazyMap<AsyncInstance<CoreDatabaseTable<CoreCourseStatusDBRecord>>>;\n    protected viewedModulesTables: LazyMap<AsyncInstance<CoreDatabaseTable<CoreCourseViewedModulesDBRecord, 'courseId' | 'cmId'>>>;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreCourseProvider');\n        this.statusTables = lazyMap(\n            siteId => asyncInstance(\n                () => CoreSites.getSiteTable(COURSE_STATUS_TABLE, {\n                    siteId,\n                    config: { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n                    onDestroy: () => delete this.statusTables[siteId],\n                }),\n            ),\n        );\n\n        this.viewedModulesTables = lazyMap(\n            siteId => asyncInstance(\n                () => CoreSites.getSiteTable<CoreCourseViewedModulesDBRecord, 'courseId' | 'cmId'>(COURSE_VIEWED_MODULES_TABLE, {\n                    siteId,\n                    config: { cachingStrategy: CoreDatabaseCachingStrategy.None },\n                    primaryKeyColumns: ['courseId', 'cmId'],\n                    onDestroy: () => delete this.viewedModulesTables[siteId],\n                }),\n            ),\n        );\n    }\n\n    /**\n     * Initialize.\n     */\n    initialize(): void {\n        CorePlatform.resume.subscribe(() => {\n            // Run the handler the app is open to keep user in online status.\n            setTimeout(() => {\n                CoreUtils.ignoreErrors(\n                    CoreCronDelegate.forceCronHandlerExecution(CoreCourseLogCronHandler.name),\n                );\n            }, 1000);\n        });\n\n        CoreEvents.on(CoreEvents.LOGIN, () => {\n            setTimeout(() => {\n                // Ignore errors here, since probably login is not complete: it happens on token invalid.\n                CoreUtils.ignoreErrors(\n                    CoreCronDelegate.forceCronHandlerExecution(CoreCourseLogCronHandler.name),\n                );\n            }, 1000);\n        });\n    }\n\n    /**\n     * Check if the get course blocks WS is available in current site.\n     *\n     * @param site Site to check. If not defined, current site.\n     * @returns Whether it's available.\n     * @since 3.7\n     */\n    canGetCourseBlocks(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site && site.isVersionGreaterEqualThan('3.7');\n    }\n\n    /**\n     * Check whether the site supports requesting stealth modules.\n     *\n     * @param site Site. If not defined, current site.\n     * @returns Whether the site supports requesting stealth modules.\n     * @since 3.5.3, 3.6\n     */\n    canRequestStealthModules(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site && site.isVersionGreaterEqualThan('3.5.3');\n    }\n\n    /**\n     * Check if module completion could have changed. If it could have, trigger event. This function must be used,\n     * for example, after calling a \"module_view\" WS since it can change the module completion.\n     *\n     * @param courseId Course ID.\n     * @param completion Completion status of the module.\n     */\n    checkModuleCompletion(courseId: number, completion?: CoreCourseModuleCompletionData): void {\n        if (completion && this.isIncompleteAutomaticCompletion(completion)) {\n            this.invalidateSections(courseId).finally(() => {\n                CoreEvents.trigger(CoreEvents.COMPLETION_MODULE_VIEWED, {\n                    courseId: courseId,\n                    cmId: completion.cmid,\n                });\n            });\n        }\n    }\n\n    /**\n     * Given some completion data, return whether it's an automatic completion that hasn't been completed yet.\n     *\n     * @param completion Completion data.\n     * @returns Whether it's an automatic completion that hasn't been completed yet.\n     */\n    isIncompleteAutomaticCompletion(completion: CoreCourseModuleCompletionData): boolean {\n        return completion.tracking === CoreCourseModuleCompletionTracking.COMPLETION_TRACKING_AUTOMATIC &&\n            completion.state === CoreCourseModuleCompletionStatus.COMPLETION_INCOMPLETE;\n    }\n\n    /**\n     * Check whether a course has indentation enabled.\n     *\n     * @param site Site.\n     * @param courseId Course id.\n     * @returns Whether indentation is enabled.\n     */\n    async isCourseIndentationEnabled(site: CoreSite, courseId: number): Promise<boolean> {\n        if (!site.isVersionGreaterEqualThan('4.0')) {\n            return false;\n        }\n\n        const course = await CoreCourses.getCourseByField('id', courseId, site.id);\n        const formatOptions = CoreUtils.objectToKeyValueMap(\n            course.courseformatoptions ?? [],\n            'name',\n            'value',\n        ) as { indentation?: string };\n\n        return formatOptions.indentation === '1';\n    }\n\n    /**\n     * Clear all courses status in a site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when all status are cleared.\n     */\n    async clearAllCoursesStatus(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        this.logger.debug('Clear all course status for site ' + site.id);\n\n        await this.statusTables[site.getId()].delete();\n        this.triggerCourseStatusChanged(CoreCourseProvider.ALL_COURSES_CLEARED, CoreConstants.NOT_DOWNLOADED, site.id);\n    }\n\n    /**\n     * Check if the current view is a certain course initial page.\n     *\n     * @param courseId Course ID.\n     * @returns Whether the current view is a certain course.\n     */\n    currentViewIsCourse(courseId: number): boolean {\n        const route = CoreNavigator.getCurrentRoute({ routeData: { isCourseIndex: true } });\n\n        if (!route) {\n            return false;\n        }\n\n        return Number(route.snapshot.params.courseId) == courseId;\n    }\n\n    /**\n     * Get completion status of all the activities in a course for a certain user.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user.\n     * @param forceCache True if it should return cached data. Has priority over ignoreCache.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param includeOffline True if it should load offline data in the completion status.\n     * @returns Promise resolved with the completion statuses: object where the key is module ID.\n     */\n    async getActivitiesCompletionStatus(\n        courseId: number,\n        siteId?: string,\n        userId?: number,\n        forceCache: boolean = false,\n        ignoreCache: boolean = false,\n        includeOffline: boolean = true,\n    ): Promise<Record<string, CoreCourseCompletionActivityStatus>> {\n\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        this.logger.debug(`Getting completion status for user ${userId} in course ${courseId}`);\n\n        const params: CoreCompletionGetActivitiesCompletionStatusWSParams = {\n            courseid: courseId,\n            userid: userId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getActivitiesCompletionCacheKey(courseId, userId),\n        };\n\n        if (forceCache) {\n            preSets.omitExpires = true;\n        } else if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        const data = await site.read<CoreCourseCompletionActivityStatusWSResponse>(\n            'core_completion_get_activities_completion_status',\n            params,\n            preSets,\n        );\n\n        if (!data || !data.statuses) {\n            throw Error('WS core_completion_get_activities_completion_status failed');\n        }\n\n        const completionStatus = CoreUtils.arrayToObject(data.statuses, 'cmid');\n        if (!includeOffline) {\n            return completionStatus;\n        }\n\n        try {\n            // Now get the offline completion (if any).\n            const offlineCompletions = await CoreCourseOffline.getCourseManualCompletions(courseId, site.id);\n\n            offlineCompletions.forEach((offlineCompletion) => {\n\n                if (offlineCompletion && completionStatus[offlineCompletion.cmid] !== undefined) {\n                    const onlineCompletion = completionStatus[offlineCompletion.cmid];\n\n                    // If the activity uses manual completion, override the value with the offline one.\n                    if (onlineCompletion.tracking === CoreCourseModuleCompletionTracking.COMPLETION_TRACKING_MANUAL) {\n                        onlineCompletion.state = offlineCompletion.completed;\n                        onlineCompletion.offline = true;\n                    }\n                }\n            });\n\n            return completionStatus;\n        } catch {\n            // Ignore errors.\n            return completionStatus;\n        }\n    }\n\n    /**\n     * Get cache key for activities completion WS calls.\n     *\n     * @param courseId Course ID.\n     * @param userId User ID.\n     * @returns Cache key.\n     */\n    protected getActivitiesCompletionCacheKey(courseId: number, userId: number): string {\n        return ROOT_CACHE_KEY + 'activitiescompletion:' + courseId + ':' + userId;\n    }\n\n    /**\n     * Get certain module viewed records in the app.\n     *\n     * @param ids Module IDs.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with map of last module viewed data.\n     */\n    async getCertainModulesViewed(ids: number[] = [], siteId?: string): Promise<Record<number, CoreCourseViewedModulesDBRecord>> {\n        if (!ids.length) {\n            return {};\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        const whereAndParams = SQLiteDB.getInOrEqual(ids);\n\n        const entries = await this.viewedModulesTables[site.getId()].getManyWhere({\n            sql: 'cmId ' + whereAndParams.sql,\n            sqlParams: whereAndParams.params,\n            js: (record) => ids.includes(record.cmId),\n        });\n\n        return CoreUtils.arrayToObject(entries, 'cmId');\n    }\n\n    /**\n     * Get course blocks.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the list of blocks.\n     * @since 3.7\n     */\n    getCourseBlocks(courseId: number, siteId?: string): Promise<CoreCourseBlock[]> {\n        return firstValueFrom(this.getCourseBlocksObservable(courseId, { siteId }));\n    }\n\n    /**\n     * Get course blocks.\n     *\n     * @param courseId Course ID.\n     * @param options Options.\n     * @returns Observable that returns the blocks.\n     * @since 3.7\n     */\n    getCourseBlocksObservable(courseId: number, options: CoreSitesCommonWSOptions = {}): WSObservable<CoreCourseBlock[]> {\n        return asyncObservable(async () => {\n            const site = await CoreSites.getSite(options.siteId);\n\n            const params: CoreBlockGetCourseBlocksWSParams = {\n                courseid: courseId,\n                returncontents: true,\n            };\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getCourseBlocksCacheKey(courseId),\n                updateFrequency: CoreSite.FREQUENCY_RARELY,\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n            };\n\n            return site.readObservable<CoreCourseBlocksWSResponse>('core_block_get_course_blocks', params, preSets).pipe(\n                map(result => result.blocks),\n            );\n        });\n    }\n\n    /**\n     * Get cache key for course blocks WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getCourseBlocksCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'courseblocks:' + courseId;\n    }\n\n    /**\n     * Get the data stored for a course.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the data.\n     */\n    async getCourseStatusData(courseId: number, siteId?: string): Promise<CoreCourseStatusDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n        const entry = await this.statusTables[site.getId()].getOneByPrimaryKey({ id: courseId });\n        if (!entry) {\n            throw Error('No entry found on course status table');\n        }\n\n        return entry;\n    }\n\n    /**\n     * Get a course status.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the status.\n     */\n    async getCourseStatus(courseId: number, siteId?: string): Promise<string> {\n        try {\n            const entry = await this.getCourseStatusData(courseId, siteId);\n\n            return entry.status || CoreConstants.NOT_DOWNLOADED;\n        } catch {\n            return CoreConstants.NOT_DOWNLOADED;\n        }\n    }\n\n    /**\n     * Obtain ids of downloaded courses.\n     *\n     * @param siteId Site id.\n     * @returns Resolves with an array containing downloaded course ids.\n     */\n    async getDownloadedCourseIds(siteId?: string): Promise<number[]> {\n        const downloadedStatuses = [CoreConstants.DOWNLOADED, CoreConstants.DOWNLOADING, CoreConstants.OUTDATED];\n        const site = await CoreSites.getSite(siteId);\n        const entries = await this.statusTables[site.getId()].getManyWhere({\n            sql: 'status IN (?,?,?)',\n            sqlParams: downloadedStatuses,\n            js: ({ status }) => downloadedStatuses.includes(status),\n        });\n\n        return entries.map((entry) => entry.id);\n    }\n\n    /**\n     * Get last module viewed in the app for a course.\n     *\n     * @param id Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with last module viewed data, undefined if none.\n     */\n    async getLastModuleViewed(id: number, siteId?: string): Promise<CoreCourseViewedModulesDBRecord | undefined> {\n        const viewedModules = await this.getViewedModules(id, siteId);\n\n        return viewedModules[0];\n    }\n\n    /**\n     * Get a module from Moodle.\n     *\n     * @param moduleId The module ID.\n     * @param courseId The course ID. Recommended to speed up the process and minimize data usage.\n     * @param sectionId The section ID.\n     * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, current site.\n     * @param modName If set, the app will retrieve all modules of this type with a single WS call. This reduces the\n     *                number of WS calls, but it isn't recommended for modules that can return a lot of contents.\n     * @returns Promise resolved with the module.\n     */\n    async getModule(\n        moduleId: number,\n        courseId?: number,\n        sectionId?: number,\n        preferCache: boolean = false,\n        ignoreCache: boolean = false,\n        siteId?: string,\n        modName?: string,\n    ): Promise<CoreCourseModuleData> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Helper function to do the WS request without processing the result.\n        const doRequest = async (\n            site: CoreSite,\n            courseId: number,\n            moduleId: number,\n            modName: string | undefined,\n            includeStealth: boolean,\n            preferCache: boolean,\n        ): Promise<CoreCourseGetContentsWSSection[]> => {\n            const params: CoreCourseGetContentsParams = {\n                courseid: courseId,\n            };\n            params.options = [];\n\n            const preSets: CoreSiteWSPreSets = {\n                omitExpires: preferCache,\n                updateFrequency: CoreSite.FREQUENCY_RARELY,\n            };\n\n            if (includeStealth) {\n                params.options.push({\n                    name: 'includestealthmodules',\n                    value: true,\n                });\n            }\n\n            // If modName is set, retrieve all modules of that type. Otherwise get only the module.\n            if (modName) {\n                params.options.push({\n                    name: 'modname',\n                    value: modName,\n                });\n                preSets.cacheKey = this.getModuleByModNameCacheKey(modName);\n            } else {\n                params.options.push({\n                    name: 'cmid',\n                    value: moduleId,\n                });\n                preSets.cacheKey = this.getModuleCacheKey(moduleId);\n            }\n\n            if (!preferCache && ignoreCache) {\n                preSets.getFromCache = false;\n                preSets.emergencyCache = false;\n            }\n\n            try {\n                const sections = await site.read<CoreCourseGetContentsWSResponse>('core_course_get_contents', params, preSets);\n\n                return sections;\n            } catch {\n                // The module might still be cached by a request with different parameters.\n                if (!ignoreCache && !CoreNetwork.isOnline()) {\n                    if (includeStealth) {\n                        // Older versions didn't include the includestealthmodules option.\n                        return doRequest(site, courseId, moduleId, modName, false, true);\n                    } else if (modName) {\n                        // Falback to the request for the given moduleId only.\n                        return doRequest(site, courseId, moduleId, undefined, this.canRequestStealthModules(site), true);\n                    }\n                }\n\n                throw Error('WS core_course_get_contents failed, cache ignored');\n            }\n        };\n\n        if (!courseId) {\n            // No courseId passed, try to retrieve it.\n            const module = await this.getModuleBasicInfo(\n                moduleId,\n                { siteId, readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE },\n            );\n            courseId = module.course;\n            sectionId = module.section;\n        }\n\n        let sections: CoreCourseGetContentsWSSection[];\n        try {\n            const site = await CoreSites.getSite(siteId);\n            // We have courseId, we can use core_course_get_contents for compatibility.\n            this.logger.debug(`Getting module ${moduleId} in course ${courseId}`);\n\n            sections = await doRequest(site, courseId, moduleId, modName, this.canRequestStealthModules(site), preferCache);\n        } catch {\n            // Error getting the module. Try to get all contents (without filtering by module).\n            const preSets: CoreSiteWSPreSets = {\n                omitExpires: preferCache,\n            };\n\n            if (!preferCache && ignoreCache) {\n                preSets.getFromCache = false;\n                preSets.emergencyCache = false;\n            }\n\n            sections = await this.getSections(courseId, false, false, preSets, siteId);\n        }\n\n        let foundModule: CoreCourseGetContentsWSModule | undefined;\n\n        const foundSection = sections.find((section) => {\n            if (section.id != CoreCourseProvider.STEALTH_MODULES_SECTION_ID &&\n                sectionId !== undefined &&\n                sectionId != section.id\n            ) {\n                return false;\n            }\n\n            foundModule = section.modules.find((module) => module.id == moduleId);\n\n            return !!foundModule;\n        });\n\n        if (foundSection && foundModule) {\n            return this.addAdditionalModuleData(foundModule, courseId, foundSection.id);\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Add some additional info to course module.\n     *\n     * @param module Module.\n     * @param courseId Course ID of the module.\n     * @param sectionId Section ID of the module.\n     * @returns Module with additional info.\n     */\n    protected addAdditionalModuleData(\n        module: CoreCourseGetContentsWSModule,\n        courseId: number,\n        sectionId: number,\n    ): CoreCourseModuleData {\n        let completionData: CoreCourseModuleCompletionData | undefined = undefined;\n\n        if (module.completiondata && module.completion) {\n            completionData = {\n                ...module.completiondata,\n                tracking: module.completion,\n                cmid: module.id,\n                courseId,\n            };\n        }\n\n        return  {\n            ...module,\n            course: courseId,\n            section: sectionId,\n            completiondata: completionData,\n            availabilityinfo: this.treatAvailablityInfo(module.availabilityinfo),\n        };\n    }\n\n    /**\n     * Gets a module basic info by module ID.\n     *\n     * @param moduleId Module ID.\n     * @param options Comon site WS options.\n     * @returns Promise resolved with the module's info.\n     */\n    async getModuleBasicInfo(moduleId: number, options: CoreSitesCommonWSOptions = {}): Promise<CoreCourseModuleBasicInfo> {\n        const site = await CoreSites.getSite(options.siteId);\n        const params: CoreCourseGetCourseModuleWSParams = {\n            cmid: moduleId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getModuleCacheKey(moduleId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n        const response = await site.read<CoreCourseGetCourseModuleWSResponse>('core_course_get_course_module', params, preSets);\n\n        if (response.warnings && response.warnings.length) {\n            throw new CoreWSError(response.warnings[0]);\n        }\n\n        return response.cm;\n    }\n\n    /**\n     * Gets a module basic grade info by module ID.\n     *\n     * @param moduleId Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the module's grade info.\n     */\n    async getModuleBasicGradeInfo(moduleId: number, siteId?: string): Promise<CoreCourseModuleGradeInfo | undefined> {\n        const info = await this.getModuleBasicInfo(moduleId, { siteId });\n\n        if (\n            info.grade !== undefined ||\n            info.advancedgrading !== undefined ||\n            info.outcomes !== undefined\n        ) {\n            return {\n                advancedgrading: info.advancedgrading,\n                grade: info.grade,\n                gradecat: info.gradecat,\n                gradepass: info.gradepass,\n                outcomes: info.outcomes,\n                scale: info.scale,\n            };\n        }\n\n    }\n\n    /**\n     * Gets a module basic info by instance.\n     *\n     * @param instanceId Instance ID.\n     * @param moduleName Name of the module. E.g. 'glossary'.\n     * @param options Comon site WS options.\n     * @returns Promise resolved with the module's info.\n     */\n    async getModuleBasicInfoByInstance(\n        instanceId: number,\n        moduleName: string,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<CoreCourseModuleBasicInfo> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: CoreCourseGetCourseModuleByInstanceWSParams = {\n            instance: instanceId,\n            module: moduleName,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getModuleBasicInfoByInstanceCacheKey(instanceId, moduleName),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response: CoreCourseGetCourseModuleWSResponse =\n            await site.read('core_course_get_course_module_by_instance', params, preSets);\n\n        if (response.warnings && response.warnings.length) {\n            throw new CoreWSError(response.warnings[0]);\n        } else if (response.cm) {\n            return response.cm;\n        }\n\n        throw Error('WS core_course_get_course_module_by_instance failed');\n    }\n\n    /**\n     * Get cache key for get module by instance WS calls.\n     *\n     * @param instanceId Instance ID.\n     * @param moduleName Name of the module. E.g. 'glossary'.\n     * @returns Cache key.\n     */\n    protected getModuleBasicInfoByInstanceCacheKey(instanceId: number, moduleName: string): string {\n        return ROOT_CACHE_KEY + 'moduleByInstance:' + moduleName + ':' + instanceId;\n    }\n\n    /**\n     * Get cache key for module WS calls.\n     *\n     * @param moduleId Module ID.\n     * @returns Cache key.\n     */\n    protected getModuleCacheKey(moduleId: number): string {\n        return ROOT_CACHE_KEY + 'module:' + moduleId;\n    }\n\n    /**\n     * Get cache key for module by modname WS calls.\n     *\n     * @param modName Name of the module.\n     * @returns Cache key.\n     */\n    protected getModuleByModNameCacheKey(modName: string): string {\n        return ROOT_CACHE_KEY + 'module:modName:' + modName;\n    }\n\n    /**\n     * Returns the source to a module icon.\n     *\n     * @param moduleName The module name.\n     * @param modicon The mod icon string to use in case we are not using a core activity.\n     * @returns The IMG src.\n     */\n    getModuleIconSrc(moduleName: string, modicon?: string, mimetypeIcon = ''): string {\n        if (mimetypeIcon) {\n            return mimetypeIcon;\n        }\n\n        if (this.CORE_MODULES.indexOf(moduleName) < 0) {\n            if (modicon) {\n                return modicon;\n            }\n\n            moduleName = 'external-tool';\n        }\n\n        let path = 'assets/img/mod/';\n        if (!CoreSites.getCurrentSite()?.isVersionGreaterEqualThan('4.0')) {\n            // @deprecatedonmoodle since 3.11.\n            path = 'assets/img/mod_legacy/';\n        }\n\n        // Use default icon on core modules.\n        return path + moduleName + '.svg';\n    }\n\n    /**\n     * Return a specific section.\n     *\n     * @param courseId The course ID.\n     * @param sectionId The section ID.\n     * @param excludeModules Do not return modules, return only the sections structure.\n     * @param excludeContents Do not return module contents (i.e: files inside a resource).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the section.\n     */\n    async getSection(\n        courseId: number,\n        sectionId: number,\n        excludeModules?: boolean,\n        excludeContents?: boolean,\n        siteId?: string,\n    ): Promise<CoreCourseWSSection> {\n\n        if (sectionId < 0) {\n            throw new CoreError('Invalid section ID');\n        }\n\n        const sections = await this.getSections(courseId, excludeModules, excludeContents, undefined, siteId);\n        const section = sections.find((section) => section.id == sectionId);\n\n        if (section) {\n            return section;\n        }\n\n        throw new CoreError('Unknown section');\n    }\n\n    /**\n     * Get the course sections.\n     *\n     * @param courseId The course ID.\n     * @param excludeModules Do not return modules, return only the sections structure.\n     * @param excludeContents Do not return module contents (i.e: files inside a resource).\n     * @param preSets Presets to use.\n     * @param siteId Site ID. If not defined, current site.\n     * @param includeStealthModules Whether to include stealth modules. Defaults to true.\n     * @returns The reject contains the error message, else contains the sections.\n     */\n    getSections(\n        courseId: number,\n        excludeModules: boolean = false,\n        excludeContents: boolean = false,\n        preSets?: CoreSiteWSPreSets,\n        siteId?: string,\n        includeStealthModules: boolean = true,\n    ): Promise<CoreCourseWSSection[]> {\n        return firstValueFrom(this.getSectionsObservable(courseId, {\n            excludeModules,\n            excludeContents,\n            includeStealthModules,\n            preSets,\n            siteId,\n        }));\n    }\n\n    /**\n     * Get the course sections.\n     *\n     * @param courseId The course ID.\n     * @param options Options.\n     * @returns Observable that returns the sections.\n     */\n    getSectionsObservable(\n        courseId: number,\n        options: CoreCourseGetSectionsOptions = {},\n    ): WSObservable<CoreCourseWSSection[]> {\n        options.includeStealthModules = options.includeStealthModules ?? true;\n\n        return asyncObservable(async () => {\n            const site = await CoreSites.getSite(options.siteId);\n\n            const preSets: CoreSiteWSPreSets = {\n                ...options.preSets,\n                cacheKey: this.getSectionsCacheKey(courseId),\n                updateFrequency: CoreSite.FREQUENCY_RARELY,\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n            };\n\n            const params: CoreCourseGetContentsParams = {\n                courseid: courseId,\n            };\n            params.options = [\n                {\n                    name: 'excludemodules',\n                    value: !!options.excludeModules,\n                },\n                {\n                    name: 'excludecontents',\n                    value: !!options.excludeContents,\n                },\n            ];\n\n            if (this.canRequestStealthModules(site)) {\n                params.options.push({\n                    name: 'includestealthmodules',\n                    value: !!options.includeStealthModules,\n                });\n            }\n\n            return site.readObservable<CoreCourseGetContentsWSSection[]>('core_course_get_contents', params, preSets).pipe(\n                map(sections => {\n                    const siteHomeId = site.getSiteHomeId();\n                    let showSections = true;\n                    if (courseId == siteHomeId) {\n                        const storedNumSections = site.getStoredConfig('numsections');\n                        showSections = storedNumSections !== undefined && !!storedNumSections;\n                    }\n\n                    if (showSections !== undefined && !showSections && sections.length > 0) {\n                        // Get only the last section (Main menu block section).\n                        sections.pop();\n                    }\n\n                    // Add course to all modules.\n                    return sections.map((section) => ({\n                        ...section,\n                        availabilityinfo: this.treatAvailablityInfo(section.availabilityinfo),\n                        modules: section.modules.map((module) => this.addAdditionalModuleData(module, courseId, section.id)),\n                    }));\n                }),\n            );\n        });\n    }\n\n    /**\n     * Get cache key for section WS call.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getSectionsCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'sections:' + courseId;\n    }\n\n    /**\n     * Given a list of sections, returns the list of modules in the sections.\n     *\n     * @param sections Sections.\n     * @returns Modules.\n     */\n    getSectionsModules(sections: CoreCourseWSSection[]): CoreCourseModuleData[] {\n        if (!sections || !sections.length) {\n            return [];\n        }\n\n        return sections.reduce((previous: CoreCourseModuleData[], section) => previous.concat(section.modules || []), []);\n    }\n\n    /**\n     * Get all viewed modules in a course, ordered by timeaccess in descending order.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the list of viewed modules.\n     */\n    async getViewedModules(courseId: number, siteId?: string): Promise<CoreCourseViewedModulesDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.viewedModulesTables[site.getId()].getMany({ courseId }, {\n            sorting: [\n                { timeaccess: 'desc' },\n            ],\n        });\n    }\n\n    /**\n     * Invalidates course blocks WS call.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateCourseBlocks(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getCourseBlocksCacheKey(courseId));\n    }\n\n    /**\n     * Invalidates module WS call.\n     *\n     * @param moduleId Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param modName Module name. E.g. 'label', 'url', ...\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateModule(moduleId: number, siteId?: string, modName?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const promises: Promise<void>[] = [];\n        if (modName) {\n            promises.push(site.invalidateWsCacheForKey(this.getModuleByModNameCacheKey(modName)));\n        }\n        promises.push(site.invalidateWsCacheForKey(this.getModuleCacheKey(moduleId)));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidates module WS call.\n     *\n     * @param id Instance ID.\n     * @param module Name of the module. E.g. 'glossary'.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateModuleByInstance(id: number, module: string, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getModuleBasicInfoByInstanceCacheKey(id, module));\n    }\n\n    /**\n     * Invalidates sections WS call.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined, current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateSections(courseId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const promises: Promise<void>[] = [];\n        const siteHomeId = site.getSiteHomeId();\n        userId = userId || site.getUserId();\n        promises.push(site.invalidateWsCacheForKey(this.getSectionsCacheKey(courseId)));\n        promises.push(site.invalidateWsCacheForKey(this.getActivitiesCompletionCacheKey(courseId, userId)));\n        if (courseId == siteHomeId) {\n            promises.push(site.invalidateConfig());\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Load module contents into module.contents if they aren't loaded already.\n     *\n     * @param module Module to load the contents.\n     * @param courseId Not used since 4.0.\n     * @param sectionId The section ID.\n     * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, current site.\n     * @param modName If set, the app will retrieve all modules of this type with a single WS call. This reduces the\n     *                number of WS calls, but it isn't recommended for modules that can return a lot of contents.\n     * @returns Promise resolved when loaded.\n     */\n    async loadModuleContents(\n        module: CoreCourseAnyModuleData,\n        courseId?: number,\n        sectionId?: number,\n        preferCache?: boolean,\n        ignoreCache?: boolean,\n        siteId?: string,\n        modName?: string,\n    ): Promise<void> {\n\n        if (!ignoreCache && module.contents && module.contents.length) {\n            // Already loaded.\n            return;\n        }\n\n        const mod = await this.getModule(module.id, module.course, sectionId, preferCache, ignoreCache, siteId, modName);\n\n        if (!mod.contents) {\n            throw new CoreError(Translate.instant('core.course.modulenotfound'));\n        }\n\n        module.contents = mod.contents;\n    }\n\n    /**\n     * Get module contents. If not present, this function will try to load them into module.contents.\n     * It will throw an error if contents cannot be loaded.\n     *\n     * @param module Module to get its contents.\n     * @param courseId Not used since 4.0.\n     * @param sectionId The section ID.\n     * @param preferCache True if shouldn't call WS if data is cached, false otherwise.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @param siteId Site ID. If not defined, current site.\n     * @param modName If set, the app will retrieve all modules of this type with a single WS call. This reduces the\n     *                number of WS calls, but it isn't recommended for modules that can return a lot of contents.\n     * @returns Promise resolved when loaded.\n     */\n    async getModuleContents(\n        module: CoreCourseModuleData,\n        courseId?: number,\n        sectionId?: number,\n        preferCache?: boolean,\n        ignoreCache?: boolean,\n        siteId?: string,\n        modName?: string,\n    ): Promise<CoreCourseModuleContentFile[]> {\n        // Make sure contents are loaded.\n        await this.loadModuleContents(module, undefined, sectionId, preferCache, ignoreCache, siteId, modName);\n\n        if (!module.contents) {\n            throw new CoreError(Translate.instant('core.course.modulenotfound'));\n        }\n\n        return module.contents;\n    }\n\n    /**\n     * Report a course and section as being viewed.\n     *\n     * @param courseId Course ID.\n     * @param sectionNumber Section number.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logView(courseId: number, sectionNumber?: number, siteId?: string): Promise<void> {\n        const params: CoreCourseViewCourseWSParams = {\n            courseid: courseId,\n        };\n\n        if (sectionNumber !== undefined) {\n            params.sectionnumber = sectionNumber;\n        }\n\n        const site = await CoreSites.getSite(siteId);\n        const response: CoreStatusWithWarningsWSResponse = await site.write('core_course_view_course', params);\n\n        if (!response.status) {\n            throw Error('WS core_course_view_course failed.');\n        } else {\n            CoreEvents.trigger(CoreCoursesProvider.EVENT_MY_COURSES_UPDATED, {\n                courseId: courseId,\n                action: CoreCoursesProvider.ACTION_VIEW,\n            }, site.getId());\n        }\n    }\n\n    /**\n     * Offline version for manually marking a module as completed.\n     *\n     * @param cmId The module ID.\n     * @param completed Whether the module is completed or not.\n     * @param courseId Course ID the module belongs to.\n     * @param courseName Not used since 4.0.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when completion is successfully sent or stored.\n     */\n    async markCompletedManually(\n        cmId: number,\n        completed: boolean,\n        courseId: number,\n        courseName?: string,\n        siteId?: string,\n    ): Promise<CoreStatusWithWarningsWSResponse> {\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a completion to be synchronized later.\n        const storeOffline = (): Promise<CoreStatusWithWarningsWSResponse> =>\n            CoreCourseOffline.markCompletedManually(cmId, completed, courseId, undefined, siteId);\n\n        // The offline function requires a courseId and it could be missing because it's a calculated field.\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        // Try to send it to server.\n        try {\n            const result = await this.markCompletedManuallyOnline(cmId, completed, siteId);\n\n            // Data sent to server, if there is some offline data delete it now.\n            await CoreUtils.ignoreErrors(CoreCourseOffline.deleteManualCompletion(cmId, siteId));\n\n            // Invalidate module now, completion has changed.\n            await this.invalidateModule(cmId, siteId);\n\n            return result;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // The WebService has thrown an error, this means that responses cannot be submitted.\n                throw error;\n            } else {\n                // Couldn't connect to server, store it offline.\n                return storeOffline();\n            }\n        }\n    }\n\n    /**\n     * Offline version for manually marking a module as completed.\n     *\n     * @param cmId The module ID.\n     * @param completed Whether the module is completed or not.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when completion is successfully sent.\n     */\n    async markCompletedManuallyOnline(\n        cmId: number,\n        completed: boolean,\n        siteId?: string,\n    ): Promise<CoreStatusWithWarningsWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n        const params: CoreCompletionUpdateActivityCompletionStatusManuallyWSParams = {\n            cmid: cmId,\n            completed: completed,\n        };\n\n        const result = await site.write<CoreStatusWithWarningsWSResponse>(\n            'core_completion_update_activity_completion_status_manually',\n            params,\n        );\n\n        if (!result.status) {\n            if (result.warnings && result.warnings.length) {\n                throw new CoreWSError(result.warnings[0]);\n            }\n\n            throw new CoreError('Cannot change completion.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Check if a module has a view page. E.g. labels don't have a view page.\n     *\n     * @param module The module object.\n     * @returns Whether the module has a view page.\n     */\n    moduleHasView(module: CoreCourseModuleSummary | CoreCourseModuleData): boolean {\n        if ('modname' in module) {\n            // noviewlink was introduced in 3.8.5, use supports feature as a fallback.\n            if (module.noviewlink ||\n                CoreCourseModuleDelegate.supportsFeature(module.modname, CoreConstants.FEATURE_NO_VIEW_LINK, false)) {\n                return false;\n            }\n        }\n\n        return !!module.url;\n    }\n\n    /**\n     * Wait for any course format plugin to load, and open the course page.\n     *\n     * If the plugin's promise is resolved, the course page will be opened. If it is rejected, they will see an error.\n     * If the promise for the plugin is still in progress when the user tries to open the course, a loader\n     * will be displayed until it is complete, before the course page is opened. If the promise is already complete,\n     * they will see the result immediately.\n     *\n     * This function must be in here instead of course helper to prevent circular dependencies.\n     *\n     * @param course Course to open\n     * @param navOptions Navigation options that includes params to pass to the page.\n     * @returns Promise resolved when done.\n     */\n    async openCourse(\n        course: CoreCourseAnyCourseData | { id: number },\n        navOptions?: CoreNavigationOptions,\n    ): Promise<void> {\n        if (course.id === CoreSites.getCurrentSite()?.getSiteHomeId()) {\n            // Open site home.\n            await CoreNavigator.navigate('/main/home/site', navOptions);\n\n            return;\n        }\n\n        const loading = await CoreDomUtils.showModalLoading();\n\n        // Wait for site plugins to be fetched.\n        await CoreUtils.ignoreErrors(CoreSitePlugins.waitFetchPlugins());\n\n        if (!('format' in course) || course.format === undefined) {\n            const result = await CoreCourseHelper.getCourse(course.id);\n\n            course = result.course;\n        }\n\n        const format = 'format' in course && `format_${course.format}`;\n\n        if (!format || !CoreSitePlugins.sitePluginPromiseExists(`format_${format}`)) {\n            // No custom format plugin. We don't need to wait for anything.\n            loading.dismiss();\n            await CoreCourseFormatDelegate.openCourse(<CoreCourseAnyCourseData> course, navOptions);\n\n            return;\n        }\n\n        // This course uses a custom format plugin, wait for the format plugin to finish loading.\n        try {\n            await CoreSitePlugins.sitePluginLoaded(format);\n\n            // The format loaded successfully, but the handlers wont be registered until all site plugins have loaded.\n            if (CoreSitePlugins.sitePluginsFinishedLoading) {\n                return CoreCourseFormatDelegate.openCourse(<CoreCourseAnyCourseData> course, navOptions);\n            }\n\n            // Wait for plugins to be loaded.\n            await new Promise((resolve, reject) => {\n                const observer = CoreEvents.on(CoreEvents.SITE_PLUGINS_LOADED, () => {\n                    observer?.off();\n\n                    CoreCourseFormatDelegate.openCourse(<CoreCourseAnyCourseData> course, navOptions).then(resolve).catch(reject);\n                });\n            });\n\n            return;\n        } catch (error) {\n            // The site plugin failed to load. The user needs to restart the app to try loading it again.\n            const message = Translate.instant('core.courses.errorloadplugins');\n            const reload = Translate.instant('core.courses.reload');\n            const ignore = Translate.instant('core.courses.ignore');\n\n            await CoreDomUtils.showConfirm(message, '', reload, ignore);\n            window.location.reload();\n        } finally {\n            loading.dismiss();\n        }\n    }\n\n    /**\n     * Select a certain tab in the course. Please use currentViewIsCourse() first to verify user is viewing the course.\n     *\n     * @param name Name of the tab. If not provided, course contents.\n     * @param params Other params.\n     */\n    selectCourseTab(name?: string, params?: Params): void {\n        params = params || {};\n        params.name = name || '';\n\n        CoreEvents.trigger(CoreEvents.SELECT_COURSE_TAB, params);\n    }\n\n    /**\n     * Change the course status, setting it to the previous status.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the status is changed. Resolve param: new status.\n     */\n    async setCoursePreviousStatus(courseId: number, siteId?: string): Promise<string> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        this.logger.debug(`Set previous status for course ${courseId} in site ${siteId}`);\n\n        const site = await CoreSites.getSite(siteId);\n        const entry = await this.getCourseStatusData(courseId, siteId);\n\n        this.logger.debug(`Set previous status '${entry.status}' for course ${courseId}`);\n\n        const newData = {\n            id: courseId,\n            status: entry.previous || CoreConstants.NOT_DOWNLOADED,\n            updated: Date.now(),\n            // Going back from downloading to previous status, restore previous download time.\n            downloadTime: entry.status == CoreConstants.DOWNLOADING ? entry.previousDownloadTime : entry.downloadTime,\n        };\n\n        await this.statusTables[site.getId()].update(newData, { id: courseId });\n        // Success updating, trigger event.\n        this.triggerCourseStatusChanged(courseId, newData.status, siteId);\n\n        return newData.status;\n    }\n\n    /**\n     * Store course status.\n     *\n     * @param courseId Course ID.\n     * @param status New course status.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the status is stored.\n     */\n    async setCourseStatus(courseId: number, status: string, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        this.logger.debug(`Set status '${status}' for course ${courseId} in site ${siteId}`);\n\n        const site = await CoreSites.getSite(siteId);\n        let downloadTime = 0;\n        let previousDownloadTime = 0;\n        let previousStatus = '';\n\n        if (status == CoreConstants.DOWNLOADING) {\n            // Set download time if course is now downloading.\n            downloadTime = CoreTimeUtils.timestamp();\n        }\n\n        try {\n            const entry = await this.getCourseStatusData(courseId, siteId);\n            if (downloadTime === undefined) {\n                // Keep previous download time.\n                downloadTime = entry.downloadTime;\n                previousDownloadTime = entry.previousDownloadTime;\n            } else {\n                // The downloadTime will be updated, store current time as previous.\n                previousDownloadTime = entry.downloadTime;\n            }\n            previousStatus = entry.status;\n        } catch {\n            // New entry.\n        }\n\n        if (previousStatus != status) {\n            // Status has changed, update it.\n            await this.statusTables[site.getId()].insert({\n                id: courseId,\n                status: status,\n                previous: previousStatus,\n                updated: Date.now(),\n                downloadTime: downloadTime,\n                previousDownloadTime: previousDownloadTime,\n            });\n        }\n\n        // Success inserting, trigger event.\n        this.triggerCourseStatusChanged(courseId, status, siteId);\n    }\n\n    /**\n     * Store activity as viewed.\n     *\n     * @param courseId Chapter ID.\n     * @param cmId Module ID.\n     * @param options Other options.\n     * @returns Promise resolved with last chapter viewed, undefined if none.\n     */\n    async storeModuleViewed(courseId: number, cmId: number, options: CoreCourseStoreModuleViewedOptions = {}): Promise<void> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const timeaccess = options.timeaccess ?? Date.now();\n\n        await this.viewedModulesTables[site.getId()].insert({\n            courseId,\n            cmId,\n            sectionId: options.sectionId,\n            timeaccess,\n        });\n\n        CoreEvents.trigger(CoreEvents.COURSE_MODULE_VIEWED, {\n            courseId,\n            cmId,\n            timeaccess,\n            sectionId: options.sectionId,\n        }, site.getId());\n    }\n\n    /**\n     * Translate a module name to current language.\n     *\n     * @param moduleName The module name.\n     * @param fallback Fallback text to use if not translated. Will use moduleName otherwise.\n     *\n     * @returns Translated name.\n     */\n    translateModuleName(moduleName: string, fallback?: string): string {\n        const langKey = 'core.mod_' + moduleName;\n        const translated = Translate.instant(langKey);\n\n        return translated !== langKey ?\n            translated :\n            (fallback || moduleName);\n    }\n\n    /**\n     * Trigger COURSE_STATUS_CHANGED with the right data.\n     *\n     * @param courseId Course ID.\n     * @param status New course status.\n     * @param siteId Site ID. If not defined, current site.\n     */\n    protected triggerCourseStatusChanged(courseId: number, status: string, siteId?: string): void {\n        CoreEvents.trigger(CoreEvents.COURSE_STATUS_CHANGED, {\n            courseId: courseId,\n            status: status,\n        }, siteId);\n    }\n\n    /**\n     * Treat availability info HTML.\n     *\n     * @param availabilityInfo HTML to treat.\n     * @returns Treated HTML.\n     */\n    protected treatAvailablityInfo(availabilityInfo?: string): string | undefined {\n        if (!availabilityInfo) {\n            return availabilityInfo;\n        }\n\n        // Remove \"Show more\" option in 4.2 or older sites.\n        return CoreDomUtils.removeElementFromHtml(availabilityInfo, 'li[data-action=\"showmore\"]');\n    }\n\n}\n\nexport const CoreCourse = makeSingleton(CoreCourseProvider);\n\n/**\n * Common options used by modules when calling a WS through CoreSite.\n */\nexport type CoreCourseCommonModWSOptions = CoreSitesCommonWSOptions & {\n    cmId?: number; // Module ID.\n};\n\n/**\n * Data returned by course_summary_exporter.\n */\nexport type CoreCourseSummary = {\n    id: number; // Id.\n    fullname: string; // Fullname.\n    shortname: string; // Shortname.\n    idnumber: string; // Idnumber.\n    summary: string; // Summary.\n    summaryformat: number; // Summary format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    startdate: number; // Startdate.\n    enddate: number; // Enddate.\n    visible: boolean; // @since 3.8. Visible.\n    fullnamedisplay: string; // Fullnamedisplay.\n    viewurl: string; // Viewurl.\n    courseimage: string; // @since 3.6. Courseimage.\n    progress?: number; // @since 3.6. Progress.\n    hasprogress: boolean; // @since 3.6. Hasprogress.\n    isfavourite: boolean; // @since 3.6. Isfavourite.\n    hidden: boolean; // @since 3.6. Hidden.\n    timeaccess?: number; // @since 3.6. Timeaccess.\n    showshortname: boolean; // @since 3.6. Showshortname.\n    coursecategory: string; // @since 3.7. Coursecategory.\n    showactivitydates: boolean | null; // @since 3.11. Whether the activity dates are shown or not.\n    showcompletionconditions: boolean | null; // @since 3.11. Whether the activity completion conditions are shown or not.\n    timemodified?: number; // @since 4.0. Last time course settings were updated (timestamp).\n};\n\n/**\n * Data returned by course_module_summary_exporter.\n */\nexport type CoreCourseModuleSummary = {\n    id: number; // Id.\n    name: string; // Name.\n    url?: string; // Url.\n    iconurl: string; // Iconurl.\n};\n\n/**\n * Params of core_completion_get_activities_completion_status WS.\n */\ntype CoreCompletionGetActivitiesCompletionStatusWSParams = {\n    courseid: number; // Course ID.\n    userid: number; // User ID.\n};\n\n/**\n * Data returned by core_completion_get_activities_completion_status WS.\n */\nexport type CoreCourseCompletionActivityStatusWSResponse = {\n    statuses: CoreCourseCompletionActivityStatus[]; // List of activities status.\n    warnings?: CoreStatusWithWarningsWSResponse[];\n};\n\n/**\n * Activity status.\n */\nexport type CoreCourseCompletionActivityStatus = {\n    cmid: number; // Course module ID.\n    modname: string; // Activity module name.\n    instance: number; // Instance ID.\n    state: number; // Completion state value: 0 means incomplete, 1 complete, 2 complete pass, 3 complete fail.\n    timecompleted: number; // Timestamp for completed activity.\n    tracking: CoreCourseModuleCompletionTracking; // Type of tracking: 0 means none, 1 manual, 2 automatic.\n    overrideby?: number | null; // The user id who has overriden the status, or null.\n    valueused?: boolean; // Whether the completion status affects the availability of another activity.\n    hascompletion?: boolean; // @since 3.11. Whether this activity module has completion enabled.\n    isautomatic?: boolean; // @since 3.11. Whether this activity module instance tracks completion automatically.\n    istrackeduser?: boolean; // @since 3.11. Whether completion is being tracked for this user.\n    uservisible?: boolean; // @since 3.11. Whether this activity is visible to the user.\n    details?: { // @since 3.11. An array of completion details containing the description and status.\n        rulename: string; // Rule name.\n        rulevalue: {\n            status: number; // Completion status.\n            description: string; // Completion description.\n        };\n    }[];\n    offline?: boolean; // Whether the completions is offline and not yet synced.\n};\n\n/**\n * Params of core_block_get_course_blocks WS.\n */\ntype CoreBlockGetCourseBlocksWSParams = {\n    courseid: number; // Course id.\n    returncontents?: boolean; // Whether to return the block contents.\n};\n\n/**\n * Data returned by core_block_get_course_blocks WS.\n */\nexport type CoreCourseBlocksWSResponse = {\n    blocks: CoreCourseBlock[]; // List of blocks in the course.\n    warnings?: CoreStatusWithWarningsWSResponse[];\n};\n\n/**\n * Block data type.\n */\nexport type CoreCourseBlock = {\n    instanceid: number; // Block instance id.\n    name: string; // Block name.\n    region: string; // Block region.\n    positionid: number; // Position id.\n    collapsible: boolean; // Whether the block is collapsible.\n    dockable: boolean; // Whether the block is dockable.\n    weight?: number; // Used to order blocks within a region.\n    visible?: boolean; // Whether the block is visible.\n    contents?: {\n        title: string; // Block title.\n        content: string; // Block contents.\n        contentformat: number; // Content format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n        footer: string; // Block footer.\n        files: CoreWSExternalFile[];\n    }; // Block contents (if required).\n    configs?: { // Block instance and plugin configuration settings.\n        name: string; // Name.\n        value: string; // JSON encoded representation of the config value.\n        type: string; // Type (instance or plugin).\n    }[];\n    configsRecord?: Record<string, { // Block instance and plugin configuration settings.\n        name: string; // Name.\n        value: string; // JSON encoded representation of the config value.\n        type: string; // Type (instance or plugin).\n    }>;\n};\n\n/**\n * Params of core_course_get_contents WS.\n */\nexport type CoreCourseGetContentsParams = {\n    courseid: number; // Course id.\n    options?: { // Options, used since Moodle 2.9.\n        /**\n         * The expected keys (value format) are:\n         *\n         * excludemodules (bool) Do not return modules, return only the sections structure\n         * excludecontents (bool) Do not return module contents (i.e: files inside a resource)\n         * includestealthmodules (bool) Return stealth modules for students in a special\n         * section (with id -1)\n         * sectionid (int) Return only this section\n         * sectionnumber (int) Return only this section with number (order)\n         * cmid (int) Return only this module information (among the whole sections structure)\n         * modname (string) Return only modules with this name \"label, forum, etc...\"\n         * modid (int) Return only the module with this id (to be used with modname.\n         */\n        name: string;\n        value: string | number | boolean; // The value of the option, this param is personaly validated in the external function.\n    }[];\n};\n\n/**\n * Data returned by core_course_get_contents WS.\n */\ntype CoreCourseGetContentsWSResponse = CoreCourseGetContentsWSSection[];\n\n/**\n * Section data returned by core_course_get_contents WS.\n */\ntype CoreCourseGetContentsWSSection = {\n    id: number; // Section ID.\n    name: string; // Section name.\n    visible?: number; // Is the section visible.\n    summary: string; // Section description.\n    summaryformat: number; // Summary format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    section?: number; // Section number inside the course.\n    hiddenbynumsections?: number; // Whether is a section hidden in the course format.\n    uservisible?: boolean; // Is the section visible for the user?.\n    availabilityinfo?: string; // Availability information.\n    modules: CoreCourseGetContentsWSModule[]; // List of module.\n};\n\n/**\n * Module data returned by core_course_get_contents WS.\n */\nexport type CoreCourseGetContentsWSModule = {\n    id: number; // Activity id.\n    url?: string; // Activity url.\n    name: string; // Activity module name.\n    instance: number; // Instance id. Cannot be undefined.\n    contextid?: number; // @since 3.10. Activity context id.\n    description?: string; // Activity description.\n    visible: number; // Is the module visible. Cannot be undefined.\n    uservisible: boolean; // Is the module visible for the user?. Cannot be undefined.\n    availabilityinfo?: string; // Availability information.\n    visibleoncoursepage: number; // Is the module visible on course page. Cannot be undefined.\n    modicon: string; // Activity icon url.\n    modname: string; // Activity module type.\n    modplural: string; // Activity module plural name.\n    availability?: string; // Module availability settings.\n    indent: number; // Number of identation in the site.\n    onclick?: string; // Onclick action.\n    afterlink?: string; // After link info to be displayed.\n    customdata?: string; // Custom data (JSON encoded).\n    noviewlink?: boolean; // Whether the module has no view page.\n    completion?: CoreCourseModuleCompletionTracking; // Type of completion tracking: 0 means none, 1 manual, 2 automatic.\n    completiondata?: CoreCourseModuleWSCompletionData; // Module completion data.\n    contents?: CoreCourseModuleContentFile[];\n    groupmode?: number; // @since 4.3. Group mode value\n    downloadcontent?: number; // @since 4.0 The download content value.\n    dates?: {\n        label: string;\n        timestamp: number;\n    }[]; // @since 3.11. Activity dates.\n    contentsinfo?: { // @since v3.7.6 Contents summary information.\n        filescount: number; // Total number of files.\n        filessize: number; // Total files size.\n        lastmodified: number; // Last time files were modified.\n        mimetypes: string[]; // Files mime types.\n        repositorytype?: string; // The repository type for the main file.\n    };\n};\n\n/**\n * Data returned by core_course_get_contents WS.\n */\nexport type CoreCourseWSSection = Omit<CoreCourseGetContentsWSSection, 'modules'> & {\n    modules: CoreCourseModuleData[]; // List of module.\n};\n\n/**\n * Params of core_course_get_course_module WS.\n */\ntype CoreCourseGetCourseModuleWSParams = {\n    cmid: number; // The course module id.\n};\n\n/**\n * Params of core_course_get_course_module_by_instance WS.\n */\ntype CoreCourseGetCourseModuleByInstanceWSParams = {\n    module: string; // The module name.\n    instance: number; // The module instance id.\n};\n\n/**\n * Data returned by core_course_get_course_module and core_course_get_course_module_by_instance WS.\n */\ntype CoreCourseGetCourseModuleWSResponse = {\n    cm: CoreCourseModuleBasicInfo;\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Module completion data.\n */\nexport type CoreCourseModuleWSCompletionData = {\n    state: CoreCourseModuleCompletionStatus; // Completion state value.\n    timecompleted: number; // Timestamp for completion status.\n    overrideby: number | null; // The user id who has overriden the status.\n    valueused?: boolean; // Whether the completion status affects the availability of another activity.\n    hascompletion?: boolean; // @since 3.11. Whether this activity module has completion enabled.\n    isautomatic?: boolean; // @since 3.11. Whether this activity module instance tracks completion automatically.\n    istrackeduser?: boolean; // @since 3.11. Whether completion is being tracked for this user.\n    uservisible?: boolean; // @since 3.11. Whether this activity is visible to the user.\n    details?: CoreCourseModuleWSRuleDetails[]; // @since 3.11. An array of completion details.\n};\n\n/**\n * Module completion rule details.\n */\nexport type CoreCourseModuleWSRuleDetails = {\n    rulename: string; // Rule name.\n    rulevalue: {\n        status: number; // Completion status.\n        description: string; // Completion description.\n    };\n};\n\nexport type CoreCourseModuleContentFile = {\n    // Common properties with CoreWSExternalFile.\n    filename: string; // Filename.\n    filepath: string; // Filepath.\n    filesize: number; // Filesize.\n    fileurl: string; // Downloadable file url.\n    timemodified: number; // Time modified.\n    mimetype?: string; // File mime type.\n    isexternalfile?: number; // Whether is an external file.\n    repositorytype?: string; // The repository type for external files.\n\n    type: string; // A file or a folder or external link.\n    content?: string; // Raw content, will be used when type is content.\n    timecreated: number; // Time created.\n    sortorder: number; // Content sort order.\n    userid: number; // User who added this content to moodle.\n    author: string; // Content owner.\n    license: string; // Content license.\n    tags?: CoreTagItem[]; // Tags.\n};\n\n/**\n * Course module basic info type.\n */\nexport type CoreCourseModuleGradeInfo = {\n    grade?: number; // Grade (max value or scale id).\n    scale?: string; // Scale items (if used).\n    gradepass?: string; // Grade to pass (float).\n    gradecat?: number; // Grade category.\n    advancedgrading?: CoreCourseModuleAdvancedGradingSetting[]; // Advanced grading settings.\n    outcomes?: CoreCourseModuleGradeOutcome[];\n};\n\n/**\n * Advanced grading settings.\n */\nexport type CoreCourseModuleAdvancedGradingSetting = {\n    area: string; // Gradable area name.\n    method: string; // Grading method.\n};\n\n/**\n * Grade outcome information.\n */\nexport type CoreCourseModuleGradeOutcome = {\n    id: string; // Outcome id.\n    name: string; // Outcome full name.\n    scale: string; // Scale items.\n};\n\n/**\n * Course module basic info type.\n */\nexport type CoreCourseModuleBasicInfo = CoreCourseModuleGradeInfo & {\n    id: number; // The course module id.\n    course: number; // The course id.\n    module: number; // The module type id.\n    name: string; // The activity name.\n    modname: string; // The module component name (forum, assign, etc..).\n    instance: number; // The activity instance id.\n    section: number; // The module section id.\n    sectionnum: number; // The module section number.\n    groupmode: number; // Group mode.\n    groupingid: number; // Grouping id.\n    completion: number; // If completion is enabled.\n    idnumber?: string; // Module id number.\n    added?: number; // Time added.\n    score?: number; // Score.\n    indent?: number; // Indentation.\n    visible?: number; // If visible.\n    visibleoncoursepage?: number; // If visible on course page.\n    visibleold?: number; // Visible old.\n    completiongradeitemnumber?: number; // Completion grade item.\n    completionpassgrade?: number; // @since 4.0. Completion pass grade setting.\n    completionview?: number; // Completion view setting.\n    completionexpected?: number; // Completion time expected.\n    showdescription?: number; // If the description is showed.\n    downloadcontent?: number; // @since 4.0. The download content value.\n    availability?: string; // Availability settings.\n};\n\n/**\n * Params of core_course_view_course WS.\n */\ntype CoreCourseViewCourseWSParams = {\n    courseid: number; // Id of the course.\n    sectionnumber?: number; // Section number.\n};\n\n/**\n * Params of core_completion_update_activity_completion_status_manually WS.\n */\ntype CoreCompletionUpdateActivityCompletionStatusManuallyWSParams = {\n    cmid: number; // Course module id.\n    completed: boolean; // Activity completed or not.\n};\n\n/**\n * Any of the possible module WS data.\n */\nexport type CoreCourseAnyModuleData = CoreCourseModuleData | CoreCourseModuleBasicInfo & {\n    contents?: CoreCourseModuleContentFile[]; // If needed, calculated in the app in loadModuleContents.\n};\n\n/**\n * Options for storeModuleViewed.\n */\nexport type CoreCourseStoreModuleViewedOptions = {\n    sectionId?: number;\n    timeaccess?: number;\n    siteId?: string;\n};\n\n/**\n * Options for getSections.\n */\nexport type CoreCourseGetSectionsOptions = CoreSitesCommonWSOptions & {\n    excludeModules?: boolean;\n    excludeContents?: boolean;\n    includeStealthModules?: boolean; // Defaults to true.\n    preSets?: CoreSiteWSPreSets;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}