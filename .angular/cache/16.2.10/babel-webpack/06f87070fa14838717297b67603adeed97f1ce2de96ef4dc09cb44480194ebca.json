{"ast":null,"code":"var _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { EventEmitter } from '@angular/core';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreIonicColorNames } from '@singletons/colors';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreQuestionHelper } from '../services/question-helper';\nimport * as i0 from \"@angular/core\";\n/**\n * Base class for components to render a question.\n */\nexport class CoreQuestionBaseComponent {\n  constructor(logName, elementRef) {\n    this.buttonClicked = new EventEmitter(); // Will emit when a behaviour button is clicked.\n    this.onAbort = new EventEmitter(); // Should emit an event if the question should be aborted.\n    this.logger = CoreLogger.getInstance(logName);\n    this.hostElement = elementRef.nativeElement;\n  }\n  /**\n   * @inheritdoc\n   */\n  ngOnInit() {\n    if (!this.question) {\n      this.logger.warn('Aborting because of no question received.');\n      return CoreQuestionHelper.showComponentError(this.onAbort);\n    }\n    this.init();\n  }\n  /**\n   * Initialize the question component, override it if needed.\n   */\n  init() {\n    this.initComponent();\n  }\n  /**\n   * Initialize the component and the question text.\n   *\n   * @returns Element containing the question HTML, void if the data is not valid.\n   */\n  initComponent() {\n    if (!this.question) {\n      return;\n    }\n    this.hostElement.classList.add('core-question-container');\n    const questionElement = CoreDomUtils.convertToElement(this.question.html);\n    // Extract question text.\n    this.question.text = CoreDomUtils.getContentsOfElement(questionElement, '.qtext');\n    if (this.question.text === undefined) {\n      this.logger.warn('Aborting because of an error parsing question.', this.question.slot);\n      return CoreQuestionHelper.showComponentError(this.onAbort);\n    }\n    return questionElement;\n  }\n  /**\n   * Initialize a question component of type calculated or calculated simple.\n   *\n   * @returns Element containing the question HTML, void if the data is not valid.\n   */\n  initCalculatedComponent() {\n    // Treat the input text first.\n    const questionEl = this.initInputTextComponent();\n    if (!questionEl) {\n      return;\n    }\n    // Check if the question has a select for units.\n    if (this.treatCalculatedSelectUnits(questionEl)) {\n      return questionEl;\n    }\n    // Check if the question has radio buttons for units.\n    if (this.treatCalculatedRadioUnits(questionEl)) {\n      return questionEl;\n    }\n    return questionEl;\n  }\n  /**\n   * Treat a calculated question units in case they use radio buttons.\n   *\n   * @param questionEl Question HTML element.\n   * @returns True if question has units using radio buttons.\n   */\n  treatCalculatedRadioUnits(questionEl) {\n    // Check if the question has radio buttons for units.\n    const radios = Array.from(questionEl.querySelectorAll('input[type=\"radio\"]'));\n    if (!radios.length || !this.question) {\n      return false;\n    }\n    const question = this.question;\n    question.options = [];\n    for (const i in radios) {\n      const radioEl = radios[i];\n      const option = {\n        id: radioEl.id,\n        class: '',\n        name: radioEl.name,\n        value: radioEl.value,\n        checked: radioEl.checked,\n        disabled: radioEl.disabled\n      };\n      // Get the label with the question text.\n      const label = questionEl.querySelector('label[for=\"' + option.id + '\"]');\n      question.optionsName = option.name;\n      if (!label || option.name === undefined || option.value === undefined) {\n        // Something went wrong when extracting the questions data. Abort.\n        this.logger.warn('Aborting because of an error parsing options.', question.slot, option.name);\n        CoreQuestionHelper.showComponentError(this.onAbort);\n        return true;\n      }\n      option.text = label.innerText;\n      if (radioEl.checked) {\n        // If the option is checked we use the model to select the one.\n        question.unit = option.value;\n      }\n      question.options.push(option);\n    }\n    // Check which one should be displayed first: the options or the input.\n    if (question.parsedSettings && question.parsedSettings.unitsleft !== null) {\n      question.optionsFirst = question.parsedSettings.unitsleft == '1';\n    } else {\n      const input = questionEl.querySelector('input[type=\"text\"][name*=answer]');\n      question.optionsFirst = questionEl.innerHTML.indexOf((input === null || input === void 0 ? void 0 : input.outerHTML) || '') > questionEl.innerHTML.indexOf(radios[0].outerHTML);\n    }\n    return true;\n  }\n  /**\n   * Treat a calculated question units in case they use a select.\n   *\n   * @param questionEl Question HTML element.\n   * @returns True if question has units using a select.\n   */\n  treatCalculatedSelectUnits(questionEl) {\n    // Check if the question has a select for units.\n    const select = questionEl.querySelector('select[name*=unit]');\n    const options = select && Array.from(select.querySelectorAll('option'));\n    if (!select || !(options !== null && options !== void 0 && options.length) || !this.question) {\n      return false;\n    }\n    const question = this.question;\n    const selectModel = {\n      id: select.id,\n      name: select.name,\n      disabled: select.disabled,\n      options: []\n    };\n    // Treat each option.\n    for (const i in options) {\n      const optionEl = options[i];\n      if (optionEl.value === undefined) {\n        var _this$question;\n        this.logger.warn('Aborting because couldn\\'t find input.', (_this$question = this.question) === null || _this$question === void 0 ? void 0 : _this$question.slot);\n        CoreQuestionHelper.showComponentError(this.onAbort);\n        return true;\n      }\n      const option = {\n        value: optionEl.value,\n        label: optionEl.innerHTML,\n        selected: optionEl.selected\n      };\n      if (optionEl.selected) {\n        selectModel.selected = option.value;\n      }\n      selectModel.options.push(option);\n    }\n    if (!selectModel.selected) {\n      // No selected option, select the first one.\n      selectModel.selected = selectModel.options[0].value;\n    }\n    // Get the accessibility label.\n    const accessibilityLabel = questionEl.querySelector('label[for=\"' + select.id + '\"]');\n    selectModel.accessibilityLabel = accessibilityLabel === null || accessibilityLabel === void 0 ? void 0 : accessibilityLabel.innerHTML;\n    question.select = selectModel;\n    // Check which one should be displayed first: the select or the input.\n    if (question.parsedSettings && question.parsedSettings.unitsleft !== null) {\n      question.selectFirst = question.parsedSettings.unitsleft == '1';\n    } else {\n      const input = questionEl.querySelector('input[type=\"text\"][name*=answer]');\n      question.selectFirst = questionEl.innerHTML.indexOf((input === null || input === void 0 ? void 0 : input.outerHTML) || '') > questionEl.innerHTML.indexOf(select.outerHTML);\n    }\n    return true;\n  }\n  /**\n   * Initialize a question component of type essay.\n   *\n   * @param review Whether we're in review mode.\n   * @returns Element containing the question HTML, void if the data is not valid.\n   */\n  initEssayComponent(review) {\n    const questionEl = this.initComponent();\n    if (!questionEl || !this.question) {\n      return;\n    }\n    const question = this.question;\n    const answerDraftIdInput = questionEl.querySelector('input[name*=\"_answer:itemid\"]');\n    if (question.parsedSettings) {\n      question.allowsAttachments = question.parsedSettings.attachments != '0';\n      question.allowsAnswerFiles = question.parsedSettings.responseformat == 'editorfilepicker';\n      question.isMonospaced = question.parsedSettings.responseformat == 'monospaced';\n      question.isPlainText = question.isMonospaced || question.parsedSettings.responseformat == 'plain';\n      question.hasInlineText = question.parsedSettings.responseformat != 'noinline';\n    } else {\n      question.allowsAttachments = !!questionEl.querySelector('div[id*=filemanager]');\n      question.allowsAnswerFiles = !!answerDraftIdInput;\n      question.isMonospaced = !!questionEl.querySelector('.qtype_essay_monospaced');\n      question.isPlainText = question.isMonospaced || !!questionEl.querySelector('.qtype_essay_plain');\n    }\n    if (review) {\n      var _questionEl$querySele;\n      // Search the answer and the attachments.\n      question.answer = CoreDomUtils.getContentsOfElement(questionEl, '.qtype_essay_response');\n      question.wordCountInfo = (_questionEl$querySele = questionEl.querySelector('.answer > p')) === null || _questionEl$querySele === void 0 ? void 0 : _questionEl$querySele.innerHTML;\n      if (question.parsedSettings) {\n        question.attachments = Array.from(CoreQuestionHelper.getResponseFileAreaFiles(question, 'attachments'));\n      } else {\n        question.attachments = CoreQuestionHelper.getQuestionAttachmentsFromHtml(CoreDomUtils.getContentsOfElement(questionEl, '.attachments') || '');\n      }\n      // Treat plagiarism.\n      this.handleEssayPlagiarism(questionEl);\n      return questionEl;\n    }\n    const textarea = questionEl.querySelector('textarea[name*=_answer]');\n    question.hasDraftFiles = question.allowsAnswerFiles && CoreQuestionHelper.hasDraftFileUrls(questionEl.innerHTML);\n    if (!textarea && (question.hasInlineText || !question.allowsAttachments)) {\n      // Textarea not found, we might be in review. Search the answer and the attachments.\n      question.answer = CoreDomUtils.getContentsOfElement(questionEl, '.qtype_essay_response');\n      question.attachments = CoreQuestionHelper.getQuestionAttachmentsFromHtml(CoreDomUtils.getContentsOfElement(questionEl, '.attachments') || '');\n      return questionEl;\n    }\n    if (textarea) {\n      const input = questionEl.querySelector('input[type=\"hidden\"][name*=answerformat]');\n      let content = CoreTextUtils.decodeHTML(textarea.innerHTML || '');\n      if (question.hasDraftFiles && question.responsefileareas) {\n        content = CoreTextUtils.replaceDraftfileUrls(CoreSites.getRequiredCurrentSite().getURL(), content, CoreQuestionHelper.getResponseFileAreaFiles(question, 'answer')).text;\n      }\n      question.textarea = {\n        id: textarea.id,\n        name: textarea.name,\n        text: content\n      };\n      if (input) {\n        question.formatInput = {\n          name: input.name,\n          value: input.value\n        };\n      }\n    }\n    if (answerDraftIdInput) {\n      question.answerDraftIdInput = {\n        name: answerDraftIdInput.name,\n        value: Number(answerDraftIdInput.value)\n      };\n    }\n    if (question.allowsAttachments) {\n      const attachmentsInput = questionEl.querySelector('.attachments input[name*=_attachments]');\n      const objectElement = questionEl.querySelector('.attachments object');\n      const fileManagerUrl = objectElement && objectElement.data;\n      if (attachmentsInput) {\n        question.attachmentsDraftIdInput = {\n          name: attachmentsInput.name,\n          value: Number(attachmentsInput.value)\n        };\n      }\n      if (question.parsedSettings) {\n        var _question$parsedSetti;\n        question.attachmentsMaxFiles = Number(question.parsedSettings.attachments);\n        question.attachmentsAcceptedTypes = (_question$parsedSetti = question.parsedSettings.filetypeslist) === null || _question$parsedSetti === void 0 ? void 0 : _question$parsedSetti.join(',');\n      }\n      if (fileManagerUrl) {\n        const params = CoreUrlUtils.extractUrlParams(fileManagerUrl);\n        const maxBytes = Number(params.maxbytes);\n        const areaMaxBytes = Number(params.areamaxbytes);\n        question.attachmentsMaxBytes = maxBytes === -1 || areaMaxBytes === -1 ? Math.max(maxBytes, areaMaxBytes) : Math.min(maxBytes, areaMaxBytes);\n      }\n    }\n    return questionEl;\n  }\n  /**\n   * Handle plagiarism in an essay question.\n   *\n   * @param questionEl Element with the question html.\n   */\n  handleEssayPlagiarism(questionEl) {\n    if (!this.question) {\n      return;\n    }\n    const question = this.question;\n    const answerPlagiarism = questionEl.querySelector('.answer .core_plagiarism_links');\n    if (answerPlagiarism) {\n      question.answerPlagiarism = answerPlagiarism.innerHTML;\n    }\n    const attachments = question.attachments;\n    if (!(attachments !== null && attachments !== void 0 && attachments.length)) {\n      return;\n    }\n    const attachmentsPlagiarisms = Array.from(questionEl.querySelectorAll('.attachments .core_plagiarism_links'));\n    const questionAttachmentsPlagiarisms = [];\n    attachmentsPlagiarisms.forEach(plagiarism => {\n      var _plagiarism$parentEle;\n      // Search the URL of the attachment it affects.\n      const attachmentUrl = (_plagiarism$parentEle = plagiarism.parentElement) === null || _plagiarism$parentEle === void 0 || (_plagiarism$parentEle = _plagiarism$parentEle.querySelector('a')) === null || _plagiarism$parentEle === void 0 ? void 0 : _plagiarism$parentEle.href;\n      if (!attachmentUrl) {\n        return;\n      }\n      const position = attachments.findIndex(file => CoreFileHelper.getFileUrl(file) === attachmentUrl);\n      if (position >= 0) {\n        questionAttachmentsPlagiarisms[position] = plagiarism.innerHTML;\n      }\n    });\n    question.attachmentsPlagiarisms = questionAttachmentsPlagiarisms;\n  }\n  /**\n   * Initialize a question component that uses the original question text with some basic treatment.\n   *\n   * @param contentSelector The selector to find the question content (text).\n   * @returns Element containing the question HTML, void if the data is not valid.\n   */\n  initOriginalTextComponent(contentSelector) {\n    if (!this.question) {\n      return;\n    }\n    const element = CoreDomUtils.convertToElement(this.question.html);\n    // Get question content.\n    const content = element.querySelector(contentSelector);\n    if (!content) {\n      this.logger.warn('Aborting because of an error parsing question.', this.question.slot);\n      return CoreQuestionHelper.showComponentError(this.onAbort);\n    }\n    // Remove sequencecheck and validation error.\n    CoreDomUtils.removeElement(content, 'input[name*=sequencecheck]');\n    CoreDomUtils.removeElement(content, '.validationerror');\n    // Replace Moodle's correct/incorrect and feedback classes with our own.\n    CoreQuestionHelper.replaceCorrectnessClasses(element);\n    CoreQuestionHelper.replaceFeedbackClasses(element);\n    // Treat the correct/incorrect icons.\n    CoreQuestionHelper.treatCorrectnessIcons(element);\n    // Set the question text.\n    this.question.text = content.innerHTML;\n    return element;\n  }\n  /**\n   * Initialize a question component that has an input of type \"text\".\n   *\n   * @returns Element containing the question HTML, void if the data is not valid.\n   */\n  initInputTextComponent() {\n    const questionEl = this.initComponent();\n    if (!questionEl || !this.question) {\n      return;\n    }\n    // Get the input element.\n    const question = this.question;\n    const input = questionEl.querySelector('input[type=\"text\"][name*=answer]');\n    if (!input) {\n      this.logger.warn('Aborting because couldn\\'t find input.', this.question.slot);\n      return CoreQuestionHelper.showComponentError(this.onAbort);\n    }\n    question.input = {\n      id: input.id,\n      name: input.name,\n      value: input.value,\n      readOnly: input.readOnly,\n      isInline: !!input.closest('.qtext') // The answer can be inside the question text.\n    };\n    // Check if question is marked as correct.\n    if (input.classList.contains('incorrect')) {\n      question.input.correctClass = 'core-question-incorrect';\n      question.input.correctIcon = 'fas-xmark';\n      question.input.correctIconColor = CoreIonicColorNames.DANGER;\n    } else if (input.classList.contains('correct')) {\n      question.input.correctClass = 'core-question-correct';\n      question.input.correctIcon = 'fas-check';\n      question.input.correctIconColor = CoreIonicColorNames.SUCCESS;\n    } else if (input.classList.contains('partiallycorrect')) {\n      question.input.correctClass = 'core-question-partiallycorrect';\n      question.input.correctIcon = 'fas-square-check';\n      question.input.correctIconColor = CoreIonicColorNames.WARNING;\n    } else {\n      question.input.correctClass = '';\n      question.input.correctIcon = '';\n      question.input.correctIconColor = '';\n    }\n    if (question.input.isInline) {\n      // Handle correct/incorrect classes and icons.\n      const content = questionEl.querySelector('.qtext');\n      if (content) {\n        CoreQuestionHelper.replaceCorrectnessClasses(content);\n        CoreQuestionHelper.treatCorrectnessIcons(content);\n        question.text = content.innerHTML;\n      }\n    }\n    return questionEl;\n  }\n  /**\n   * Initialize a question component with a \"match\" behaviour.\n   *\n   * @returns Element containing the question HTML, void if the data is not valid.\n   */\n  initMatchComponent() {\n    const questionEl = this.initComponent();\n    if (!questionEl || !this.question) {\n      return;\n    }\n    // Find rows.\n    const question = this.question;\n    const rows = Array.from(questionEl.querySelectorAll('table.answer tr'));\n    if (!rows || !rows.length) {\n      this.logger.warn('Aborting because couldn\\'t find any row.', question.slot);\n      return CoreQuestionHelper.showComponentError(this.onAbort);\n    }\n    question.rows = [];\n    for (const i in rows) {\n      const row = rows[i];\n      const columns = Array.from(row.querySelectorAll('td'));\n      if (!columns || columns.length < 2) {\n        this.logger.warn('Aborting because couldn\\'t the right columns.', question.slot);\n        return CoreQuestionHelper.showComponentError(this.onAbort);\n      }\n      // Get the select and the options.\n      const select = columns[1].querySelector('select');\n      const options = Array.from(columns[1].querySelectorAll('option'));\n      if (!select || !options || !options.length) {\n        this.logger.warn('Aborting because couldn\\'t find select or options.', question.slot);\n        return CoreQuestionHelper.showComponentError(this.onAbort);\n      }\n      const rowModel = {\n        id: select.id.replace(/:/g, '\\\\:'),\n        name: select.name,\n        disabled: select.disabled,\n        options: [],\n        text: columns[0].innerHTML // Row's text should be in the first column.\n      };\n      // Check if answer is correct.\n      if (columns[1].className.indexOf('incorrect') >= 0) {\n        rowModel.isCorrect = 0;\n      } else if (columns[1].className.indexOf('correct') >= 0) {\n        rowModel.isCorrect = 1;\n      }\n      // Treat each option.\n      for (const j in options) {\n        const optionEl = options[j];\n        if (optionEl.value === undefined) {\n          this.logger.warn('Aborting because couldn\\'t find the value of an option.', question.slot);\n          return CoreQuestionHelper.showComponentError(this.onAbort);\n        }\n        const option = {\n          value: optionEl.value,\n          label: optionEl.innerHTML,\n          selected: optionEl.selected\n        };\n        if (option.selected) {\n          rowModel.selected = option.value;\n        }\n        rowModel.options.push(option);\n      }\n      // Get the accessibility label.\n      const accessibilityLabel = columns[1].querySelector('label.accesshide');\n      rowModel.accessibilityLabel = accessibilityLabel === null || accessibilityLabel === void 0 ? void 0 : accessibilityLabel.innerHTML;\n      question.rows.push(rowModel);\n    }\n    question.loaded = true;\n    return questionEl;\n  }\n  /**\n   * Initialize a question component with a multiple choice (checkbox) or single choice (radio).\n   *\n   * @returns Element containing the question HTML, void if the data is not valid.\n   */\n  initMultichoiceComponent() {\n    const questionEl = this.initComponent();\n    if (!questionEl || !this.question) {\n      return;\n    }\n    // Get the prompt.\n    const question = this.question;\n    question.prompt = CoreDomUtils.getContentsOfElement(questionEl, '.prompt');\n    // Search radio buttons first (single choice).\n    let options = Array.from(questionEl.querySelectorAll('input[type=\"radio\"]'));\n    if (!options || !options.length) {\n      // Radio buttons not found, it should be a multi answer. Search for checkbox.\n      question.multi = true;\n      options = Array.from(questionEl.querySelectorAll('input[type=\"checkbox\"]'));\n      if (!options || !options.length) {\n        // No checkbox found either. Abort.\n        this.logger.warn('Aborting because of no radio and checkbox found.', question.slot);\n        return CoreQuestionHelper.showComponentError(this.onAbort);\n      }\n    }\n    question.options = [];\n    question.disabled = true;\n    for (const i in options) {\n      var _label;\n      const element = options[i];\n      const option = {\n        id: element.id,\n        class: '',\n        name: element.name,\n        value: element.value,\n        checked: element.checked,\n        disabled: element.disabled\n      };\n      const parent = element.parentElement;\n      if (option.value == '-1') {\n        // It's the clear choice option, ignore it.\n        continue;\n      }\n      question.optionsName = option.name;\n      question.disabled = question.disabled && element.disabled;\n      // Get the label with the question text. Try the new format first.\n      const labelId = element.getAttribute('aria-labelledby');\n      let label = labelId ? questionEl.querySelector('#' + labelId.replace(/:/g, '\\\\:')) : undefined;\n      if (!label) {\n        // Not found, use the old format.\n        label = questionEl.querySelector('label[for=\"' + option.id + '\"]');\n      }\n      option.class = ((_label = label) === null || _label === void 0 ? void 0 : _label.className) || option.class;\n      // Check that we were able to successfully extract options required data.\n      if (!label || option.name === undefined || option.value === undefined) {\n        // Something went wrong when extracting the questions data. Abort.\n        this.logger.warn('Aborting because of an error parsing options.', question.slot, option.name);\n        return CoreQuestionHelper.showComponentError(this.onAbort);\n      }\n      option.text = label.innerHTML;\n      if (element.checked) {\n        // If the option is checked and it's a single choice we use the model to select the one.\n        if (!question.multi) {\n          question.singleChoiceModel = option.value;\n        }\n        if (parent) {\n          // Check if answer is correct.\n          if (parent && parent.className.indexOf('incorrect') >= 0) {\n            option.isCorrect = 0;\n          } else if (parent && parent.className.indexOf('correct') >= 0) {\n            option.isCorrect = 1;\n          }\n          // Search the feedback.\n          const feedback = parent.querySelector('.specificfeedback');\n          if (feedback) {\n            option.feedback = feedback.innerHTML;\n          }\n        }\n      }\n      question.options.push(option);\n    }\n    return questionEl;\n  }\n}\n_class = CoreQuestionBaseComponent;\n_class.ɵfac = function CoreQuestionBaseComponent_Factory(t) {\n  return new (t || _class)(i0.ɵɵdirectiveInject('', 8), i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n_class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: _class,\n  selectors: [[\"ng-component\"]],\n  inputs: {\n    question: \"question\",\n    component: \"component\",\n    componentId: \"componentId\",\n    attemptId: \"attemptId\",\n    offlineEnabled: \"offlineEnabled\",\n    contextLevel: \"contextLevel\",\n    contextInstanceId: \"contextInstanceId\",\n    courseId: \"courseId\",\n    review: \"review\",\n    preferredBehaviour: \"preferredBehaviour\"\n  },\n  outputs: {\n    buttonClicked: \"buttonClicked\",\n    onAbort: \"onAbort\"\n  },\n  decls: 0,\n  vars: 0,\n  template: function CoreQuestionBaseComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});","map":{"version":3,"names":["EventEmitter","CoreFileHelper","CoreSites","CoreDomUtils","CoreTextUtils","CoreUrlUtils","CoreIonicColorNames","CoreLogger","CoreQuestionHelper","CoreQuestionBaseComponent","constructor","logName","elementRef","buttonClicked","onAbort","logger","getInstance","hostElement","nativeElement","ngOnInit","question","warn","showComponentError","init","initComponent","classList","add","questionElement","convertToElement","html","text","getContentsOfElement","undefined","slot","initCalculatedComponent","questionEl","initInputTextComponent","treatCalculatedSelectUnits","treatCalculatedRadioUnits","radios","Array","from","querySelectorAll","length","options","i","radioEl","option","id","class","name","value","checked","disabled","label","querySelector","optionsName","innerText","unit","push","parsedSettings","unitsleft","optionsFirst","input","innerHTML","indexOf","outerHTML","select","selectModel","optionEl","_this$question","selected","accessibilityLabel","selectFirst","initEssayComponent","review","answerDraftIdInput","allowsAttachments","attachments","allowsAnswerFiles","responseformat","isMonospaced","isPlainText","hasInlineText","_questionEl$querySele","answer","wordCountInfo","getResponseFileAreaFiles","getQuestionAttachmentsFromHtml","handleEssayPlagiarism","textarea","hasDraftFiles","hasDraftFileUrls","content","decodeHTML","responsefileareas","replaceDraftfileUrls","getRequiredCurrentSite","getURL","formatInput","Number","attachmentsInput","objectElement","fileManagerUrl","data","attachmentsDraftIdInput","_question$parsedSetti","attachmentsMaxFiles","attachmentsAcceptedTypes","filetypeslist","join","params","extractUrlParams","maxBytes","maxbytes","areaMaxBytes","areamaxbytes","attachmentsMaxBytes","Math","max","min","answerPlagiarism","attachmentsPlagiarisms","questionAttachmentsPlagiarisms","forEach","plagiarism","_plagiarism$parentEle","attachmentUrl","parentElement","href","position","findIndex","file","getFileUrl","initOriginalTextComponent","contentSelector","element","removeElement","replaceCorrectnessClasses","replaceFeedbackClasses","treatCorrectnessIcons","readOnly","isInline","closest","contains","correctClass","correctIcon","correctIconColor","DANGER","SUCCESS","WARNING","initMatchComponent","rows","row","columns","rowModel","replace","className","isCorrect","j","loaded","initMultichoiceComponent","prompt","multi","_label","parent","labelId","getAttribute","singleChoiceModel","feedback","i0","ɵɵdirectiveInject","ElementRef","selectors","inputs","component","componentId","attemptId","offlineEnabled","contextLevel","contextInstanceId","courseId","preferredBehaviour","outputs","decls","vars","template","CoreQuestionBaseComponent_Template","rf","ctx","encapsulation"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/question/classes/base-question-component.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Input, Output, EventEmitter, Component, Optional, Inject, ElementRef, OnInit } from '@angular/core';\nimport { CoreFileHelper } from '@services/file-helper';\n\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreWSFile } from '@services/ws';\nimport { CoreIonicColorNames } from '@singletons/colors';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreQuestionBehaviourButton, CoreQuestionHelper, CoreQuestionQuestion } from '../services/question-helper';\n\n/**\n * Base class for components to render a question.\n */\n@Component({\n    template: '',\n})\nexport class CoreQuestionBaseComponent<T extends AddonModQuizQuestion = AddonModQuizQuestion> implements OnInit {\n\n    @Input() question?: T; // The question to render.\n    @Input() component?: string; // The component the question belongs to.\n    @Input() componentId?: number; // ID of the component the question belongs to.\n    @Input() attemptId?: number; // Attempt ID.\n    @Input() offlineEnabled?: boolean | string; // Whether the question can be answered in offline.\n    @Input() contextLevel?: string; // The context level.\n    @Input() contextInstanceId?: number; // The instance ID related to the context.\n    @Input() courseId?: number; // The course the question belongs to (if any).\n    @Input() review?: boolean; // Whether the user is in review mode.\n    @Input() preferredBehaviour?: string; // Preferred behaviour.\n    @Output() buttonClicked = new EventEmitter<CoreQuestionBehaviourButton>(); // Will emit when a behaviour button is clicked.\n    @Output() onAbort = new EventEmitter<void>(); // Should emit an event if the question should be aborted.\n\n    protected logger: CoreLogger;\n    protected hostElement: HTMLElement;\n\n    constructor(@Optional() @Inject('') logName: string, elementRef: ElementRef) {\n        this.logger = CoreLogger.getInstance(logName);\n        this.hostElement = elementRef.nativeElement;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    ngOnInit(): void {\n        if (!this.question) {\n            this.logger.warn('Aborting because of no question received.');\n\n            return CoreQuestionHelper.showComponentError(this.onAbort);\n        }\n\n        this.init();\n    }\n\n    /**\n     * Initialize the question component, override it if needed.\n     */\n    init(): void {\n        this.initComponent();\n    }\n\n    /**\n     * Initialize the component and the question text.\n     *\n     * @returns Element containing the question HTML, void if the data is not valid.\n     */\n    initComponent(): void | HTMLElement {\n        if (!this.question) {\n            return;\n        }\n\n        this.hostElement.classList.add('core-question-container');\n\n        const questionElement = CoreDomUtils.convertToElement(this.question.html);\n\n        // Extract question text.\n        this.question.text = CoreDomUtils.getContentsOfElement(questionElement, '.qtext');\n        if (this.question.text === undefined) {\n            this.logger.warn('Aborting because of an error parsing question.', this.question.slot);\n\n            return CoreQuestionHelper.showComponentError(this.onAbort);\n        }\n\n        return questionElement;\n    }\n\n    /**\n     * Initialize a question component of type calculated or calculated simple.\n     *\n     * @returns Element containing the question HTML, void if the data is not valid.\n     */\n    initCalculatedComponent(): void | HTMLElement {\n        // Treat the input text first.\n        const questionEl = this.initInputTextComponent();\n        if (!questionEl) {\n            return;\n        }\n\n        // Check if the question has a select for units.\n        if (this.treatCalculatedSelectUnits(questionEl)) {\n            return questionEl;\n        }\n\n        // Check if the question has radio buttons for units.\n        if (this.treatCalculatedRadioUnits(questionEl)) {\n            return questionEl;\n        }\n\n        return questionEl;\n    }\n\n    /**\n     * Treat a calculated question units in case they use radio buttons.\n     *\n     * @param questionEl Question HTML element.\n     * @returns True if question has units using radio buttons.\n     */\n    protected treatCalculatedRadioUnits(questionEl: HTMLElement): boolean {\n        // Check if the question has radio buttons for units.\n        const radios = Array.from(questionEl.querySelectorAll<HTMLInputElement>('input[type=\"radio\"]'));\n        if (!radios.length || !this.question) {\n            return false;\n        }\n\n        const question: AddonModQuizCalculatedQuestion = this.question;\n        question.options = [];\n\n        for (const i in radios) {\n            const radioEl = radios[i];\n            const option: AddonModQuizQuestionRadioOption = {\n                id: radioEl.id,\n                class: '',\n                name: radioEl.name,\n                value: radioEl.value,\n                checked: radioEl.checked,\n                disabled: radioEl.disabled,\n            };\n            // Get the label with the question text.\n            const label = questionEl.querySelector<HTMLLabelElement>('label[for=\"' + option.id + '\"]');\n\n            question.optionsName = option.name;\n\n            if (!label || option.name === undefined || option.value === undefined) {\n                // Something went wrong when extracting the questions data. Abort.\n                this.logger.warn('Aborting because of an error parsing options.', question.slot, option.name);\n                CoreQuestionHelper.showComponentError(this.onAbort);\n\n                return true;\n            }\n\n            option.text = label.innerText;\n            if (radioEl.checked) {\n                // If the option is checked we use the model to select the one.\n                question.unit = option.value;\n            }\n\n            question.options.push(option);\n        }\n\n        // Check which one should be displayed first: the options or the input.\n        if (question.parsedSettings && question.parsedSettings.unitsleft !== null) {\n            question.optionsFirst = question.parsedSettings.unitsleft == '1';\n        } else {\n            const input = questionEl.querySelector<HTMLInputElement>('input[type=\"text\"][name*=answer]');\n            question.optionsFirst =\n                    questionEl.innerHTML.indexOf(input?.outerHTML || '') > questionEl.innerHTML.indexOf(radios[0].outerHTML);\n        }\n\n        return true;\n    }\n\n    /**\n     * Treat a calculated question units in case they use a select.\n     *\n     * @param questionEl Question HTML element.\n     * @returns True if question has units using a select.\n     */\n    protected treatCalculatedSelectUnits(questionEl: HTMLElement): boolean {\n        // Check if the question has a select for units.\n        const select = questionEl.querySelector<HTMLSelectElement>('select[name*=unit]');\n        const options = select && Array.from(select.querySelectorAll('option'));\n\n        if (!select || !options?.length || !this.question) {\n            return false;\n        }\n\n        const question: AddonModQuizCalculatedQuestion = this.question;\n        const selectModel: AddonModQuizQuestionSelect = {\n            id: select.id,\n            name: select.name,\n            disabled: select.disabled,\n            options: [],\n        };\n\n        // Treat each option.\n        for (const i in options) {\n            const optionEl = options[i];\n\n            if (optionEl.value === undefined) {\n                this.logger.warn('Aborting because couldn\\'t find input.', this.question?.slot);\n                CoreQuestionHelper.showComponentError(this.onAbort);\n\n                return true;\n            }\n\n            const option: AddonModQuizQuestionSelectOption = {\n                value: optionEl.value,\n                label: optionEl.innerHTML,\n                selected: optionEl.selected,\n            };\n\n            if (optionEl.selected) {\n                selectModel.selected = option.value;\n            }\n\n            selectModel.options.push(option);\n        }\n\n        if (!selectModel.selected) {\n            // No selected option, select the first one.\n            selectModel.selected = selectModel.options[0].value;\n        }\n\n        // Get the accessibility label.\n        const accessibilityLabel = questionEl.querySelector<HTMLLabelElement>('label[for=\"' + select.id + '\"]');\n        selectModel.accessibilityLabel = accessibilityLabel?.innerHTML;\n\n        question.select = selectModel;\n\n        // Check which one should be displayed first: the select or the input.\n        if (question.parsedSettings && question.parsedSettings.unitsleft !== null) {\n            question.selectFirst = question.parsedSettings.unitsleft == '1';\n        } else {\n            const input = questionEl.querySelector<HTMLInputElement>('input[type=\"text\"][name*=answer]');\n            question.selectFirst =\n                    questionEl.innerHTML.indexOf(input?.outerHTML || '') > questionEl.innerHTML.indexOf(select.outerHTML);\n        }\n\n        return true;\n    }\n\n    /**\n     * Initialize a question component of type essay.\n     *\n     * @param review Whether we're in review mode.\n     * @returns Element containing the question HTML, void if the data is not valid.\n     */\n    initEssayComponent(review?: boolean): void | HTMLElement {\n        const questionEl = this.initComponent();\n        if (!questionEl || !this.question) {\n            return;\n        }\n\n        const question: AddonModQuizEssayQuestion = this.question;\n        const answerDraftIdInput = questionEl.querySelector<HTMLInputElement>('input[name*=\"_answer:itemid\"]');\n\n        if (question.parsedSettings) {\n            question.allowsAttachments = question.parsedSettings.attachments != '0';\n            question.allowsAnswerFiles = question.parsedSettings.responseformat == 'editorfilepicker';\n            question.isMonospaced = question.parsedSettings.responseformat == 'monospaced';\n            question.isPlainText = question.isMonospaced || question.parsedSettings.responseformat == 'plain';\n            question.hasInlineText = question.parsedSettings.responseformat != 'noinline';\n        } else {\n            question.allowsAttachments = !!questionEl.querySelector('div[id*=filemanager]');\n            question.allowsAnswerFiles = !!answerDraftIdInput;\n            question.isMonospaced = !!questionEl.querySelector('.qtype_essay_monospaced');\n            question.isPlainText = question.isMonospaced || !!questionEl.querySelector('.qtype_essay_plain');\n        }\n\n        if (review) {\n            // Search the answer and the attachments.\n            question.answer = CoreDomUtils.getContentsOfElement(questionEl, '.qtype_essay_response');\n            question.wordCountInfo = questionEl.querySelector('.answer > p')?.innerHTML;\n\n            if (question.parsedSettings) {\n                question.attachments = Array.from(\n                    CoreQuestionHelper.getResponseFileAreaFiles(question, 'attachments'),\n                );\n            } else {\n                question.attachments = CoreQuestionHelper.getQuestionAttachmentsFromHtml(\n                    CoreDomUtils.getContentsOfElement(questionEl, '.attachments') || '',\n                );\n            }\n\n            // Treat plagiarism.\n            this.handleEssayPlagiarism(questionEl);\n\n            return questionEl;\n        }\n\n        const textarea = questionEl.querySelector<HTMLTextAreaElement>('textarea[name*=_answer]');\n        question.hasDraftFiles = question.allowsAnswerFiles && CoreQuestionHelper.hasDraftFileUrls(questionEl.innerHTML);\n\n        if (!textarea && (question.hasInlineText || !question.allowsAttachments)) {\n            // Textarea not found, we might be in review. Search the answer and the attachments.\n            question.answer = CoreDomUtils.getContentsOfElement(questionEl, '.qtype_essay_response');\n            question.attachments = CoreQuestionHelper.getQuestionAttachmentsFromHtml(\n                CoreDomUtils.getContentsOfElement(questionEl, '.attachments') || '',\n            );\n\n            return questionEl;\n        }\n\n        if (textarea) {\n            const input = questionEl.querySelector<HTMLInputElement>('input[type=\"hidden\"][name*=answerformat]');\n            let content = CoreTextUtils.decodeHTML(textarea.innerHTML || '');\n\n            if (question.hasDraftFiles && question.responsefileareas) {\n                content = CoreTextUtils.replaceDraftfileUrls(\n                    CoreSites.getRequiredCurrentSite().getURL(),\n                    content,\n                    CoreQuestionHelper.getResponseFileAreaFiles(question, 'answer'),\n                ).text;\n            }\n\n            question.textarea = {\n                id: textarea.id,\n                name: textarea.name,\n                text: content,\n            };\n\n            if (input) {\n                question.formatInput = {\n                    name: input.name,\n                    value: input.value,\n                };\n            }\n        }\n\n        if (answerDraftIdInput) {\n            question.answerDraftIdInput = {\n                name: answerDraftIdInput.name,\n                value: Number(answerDraftIdInput.value),\n            };\n        }\n\n        if (question.allowsAttachments) {\n            const attachmentsInput = questionEl.querySelector<HTMLInputElement>('.attachments input[name*=_attachments]');\n            const objectElement = questionEl.querySelector<HTMLObjectElement>('.attachments object');\n            const fileManagerUrl = objectElement && objectElement.data;\n\n            if (attachmentsInput) {\n                question.attachmentsDraftIdInput = {\n                    name: attachmentsInput.name,\n                    value: Number(attachmentsInput.value),\n                };\n            }\n\n            if (question.parsedSettings) {\n                question.attachmentsMaxFiles = Number(question.parsedSettings.attachments);\n                question.attachmentsAcceptedTypes = (<string[] | undefined> question.parsedSettings.filetypeslist)?.join(',');\n            }\n\n            if (fileManagerUrl) {\n                const params = CoreUrlUtils.extractUrlParams(fileManagerUrl);\n                const maxBytes = Number(params.maxbytes);\n                const areaMaxBytes = Number(params.areamaxbytes);\n\n                question.attachmentsMaxBytes = maxBytes === -1 || areaMaxBytes === -1 ?\n                    Math.max(maxBytes, areaMaxBytes) : Math.min(maxBytes, areaMaxBytes);\n            }\n        }\n\n        return questionEl;\n    }\n\n    /**\n     * Handle plagiarism in an essay question.\n     *\n     * @param questionEl Element with the question html.\n     */\n    protected handleEssayPlagiarism(questionEl: HTMLElement): void {\n        if (!this.question) {\n            return;\n        }\n\n        const question: AddonModQuizEssayQuestion = this.question;\n        const answerPlagiarism = questionEl.querySelector<HTMLSpanElement>('.answer .core_plagiarism_links');\n        if (answerPlagiarism) {\n            question.answerPlagiarism = answerPlagiarism.innerHTML;\n        }\n\n        const attachments = question.attachments;\n        if (!attachments?.length) {\n            return;\n        }\n\n        const attachmentsPlagiarisms = Array.from(\n            questionEl.querySelectorAll<HTMLSpanElement>('.attachments .core_plagiarism_links'),\n        );\n        const questionAttachmentsPlagiarisms: string[] = [];\n\n        attachmentsPlagiarisms.forEach((plagiarism) => {\n            // Search the URL of the attachment it affects.\n            const attachmentUrl = plagiarism.parentElement?.querySelector('a')?.href;\n            if (!attachmentUrl) {\n                return;\n            }\n\n            const position = attachments.findIndex((file) => CoreFileHelper.getFileUrl(file) === attachmentUrl);\n            if (position >= 0) {\n                questionAttachmentsPlagiarisms[position] = plagiarism.innerHTML;\n            }\n        });\n\n        question.attachmentsPlagiarisms = questionAttachmentsPlagiarisms;\n    }\n\n    /**\n     * Initialize a question component that uses the original question text with some basic treatment.\n     *\n     * @param contentSelector The selector to find the question content (text).\n     * @returns Element containing the question HTML, void if the data is not valid.\n     */\n    initOriginalTextComponent(contentSelector: string): void | HTMLElement {\n        if (!this.question) {\n            return;\n        }\n\n        const element = CoreDomUtils.convertToElement(this.question.html);\n\n        // Get question content.\n        const content = element.querySelector<HTMLElement>(contentSelector);\n        if (!content) {\n            this.logger.warn('Aborting because of an error parsing question.', this.question.slot);\n\n            return CoreQuestionHelper.showComponentError(this.onAbort);\n        }\n\n        // Remove sequencecheck and validation error.\n        CoreDomUtils.removeElement(content, 'input[name*=sequencecheck]');\n        CoreDomUtils.removeElement(content, '.validationerror');\n\n        // Replace Moodle's correct/incorrect and feedback classes with our own.\n        CoreQuestionHelper.replaceCorrectnessClasses(element);\n        CoreQuestionHelper.replaceFeedbackClasses(element);\n\n        // Treat the correct/incorrect icons.\n        CoreQuestionHelper.treatCorrectnessIcons(element);\n\n        // Set the question text.\n        this.question.text = content.innerHTML;\n\n        return element;\n    }\n\n    /**\n     * Initialize a question component that has an input of type \"text\".\n     *\n     * @returns Element containing the question HTML, void if the data is not valid.\n     */\n    initInputTextComponent(): void | HTMLElement {\n        const questionEl = this.initComponent();\n        if (!questionEl || !this.question) {\n            return;\n        }\n\n        // Get the input element.\n        const question: AddonModQuizTextQuestion = this.question;\n        const input = questionEl.querySelector<HTMLInputElement>('input[type=\"text\"][name*=answer]');\n        if (!input) {\n            this.logger.warn('Aborting because couldn\\'t find input.', this.question.slot);\n\n            return CoreQuestionHelper.showComponentError(this.onAbort);\n        }\n\n        question.input = {\n            id: input.id,\n            name: input.name,\n            value: input.value,\n            readOnly: input.readOnly,\n            isInline: !!input.closest('.qtext'), // The answer can be inside the question text.\n        };\n\n        // Check if question is marked as correct.\n        if (input.classList.contains('incorrect')) {\n            question.input.correctClass = 'core-question-incorrect';\n            question.input.correctIcon = 'fas-xmark';\n            question.input.correctIconColor = CoreIonicColorNames.DANGER;\n        } else if (input.classList.contains('correct')) {\n            question.input.correctClass = 'core-question-correct';\n            question.input.correctIcon = 'fas-check';\n            question.input.correctIconColor = CoreIonicColorNames.SUCCESS;\n        } else if (input.classList.contains('partiallycorrect')) {\n            question.input.correctClass = 'core-question-partiallycorrect';\n            question.input.correctIcon = 'fas-square-check';\n            question.input.correctIconColor = CoreIonicColorNames.WARNING;\n        } else {\n            question.input.correctClass = '';\n            question.input.correctIcon = '';\n            question.input.correctIconColor = '';\n        }\n\n        if (question.input.isInline) {\n            // Handle correct/incorrect classes and icons.\n            const content = questionEl.querySelector<HTMLElement>('.qtext');\n            if (content) {\n                CoreQuestionHelper.replaceCorrectnessClasses(content);\n                CoreQuestionHelper.treatCorrectnessIcons(content);\n\n                question.text = content.innerHTML;\n            }\n        }\n\n        return questionEl;\n    }\n\n    /**\n     * Initialize a question component with a \"match\" behaviour.\n     *\n     * @returns Element containing the question HTML, void if the data is not valid.\n     */\n    initMatchComponent(): void | HTMLElement {\n        const questionEl = this.initComponent();\n        if (!questionEl || !this.question) {\n            return;\n        }\n\n        // Find rows.\n        const question: AddonModQuizMatchQuestion = this.question;\n        const rows = Array.from(questionEl.querySelectorAll<HTMLTableRowElement>('table.answer tr'));\n        if (!rows || !rows.length) {\n            this.logger.warn('Aborting because couldn\\'t find any row.', question.slot);\n\n            return CoreQuestionHelper.showComponentError(this.onAbort);\n        }\n\n        question.rows = [];\n\n        for (const i in rows) {\n            const row = rows[i];\n            const columns = Array.from(row.querySelectorAll<HTMLTableCellElement>('td'));\n\n            if (!columns || columns.length < 2) {\n                this.logger.warn('Aborting because couldn\\'t the right columns.', question.slot);\n\n                return CoreQuestionHelper.showComponentError(this.onAbort);\n            }\n\n            // Get the select and the options.\n            const select = columns[1].querySelector<HTMLSelectElement>('select');\n            const options = Array.from(columns[1].querySelectorAll<HTMLOptionElement>('option'));\n\n            if (!select || !options || !options.length) {\n                this.logger.warn('Aborting because couldn\\'t find select or options.', question.slot);\n\n                return CoreQuestionHelper.showComponentError(this.onAbort);\n            }\n\n            const rowModel: AddonModQuizQuestionMatchSelect = {\n                id: select.id.replace(/:/g, '\\\\:'),\n                name: select.name,\n                disabled: select.disabled,\n                options: [],\n                text: columns[0].innerHTML, // Row's text should be in the first column.\n            };\n\n            // Check if answer is correct.\n            if (columns[1].className.indexOf('incorrect') >= 0) {\n                rowModel.isCorrect = 0;\n            } else if (columns[1].className.indexOf('correct') >= 0) {\n                rowModel.isCorrect = 1;\n            }\n\n            // Treat each option.\n            for (const j in options) {\n                const optionEl = options[j];\n\n                if (optionEl.value === undefined) {\n                    this.logger.warn('Aborting because couldn\\'t find the value of an option.', question.slot);\n\n                    return CoreQuestionHelper.showComponentError(this.onAbort);\n                }\n\n                const option: AddonModQuizQuestionSelectOption = {\n                    value: optionEl.value,\n                    label: optionEl.innerHTML,\n                    selected: optionEl.selected,\n                };\n\n                if (option.selected) {\n                    rowModel.selected = option.value;\n                }\n\n                rowModel.options.push(option);\n            }\n\n            // Get the accessibility label.\n            const accessibilityLabel = columns[1].querySelector<HTMLLabelElement>('label.accesshide');\n            rowModel.accessibilityLabel = accessibilityLabel?.innerHTML;\n\n            question.rows.push(rowModel);\n        }\n\n        question.loaded = true;\n\n        return questionEl;\n    }\n\n    /**\n     * Initialize a question component with a multiple choice (checkbox) or single choice (radio).\n     *\n     * @returns Element containing the question HTML, void if the data is not valid.\n     */\n    initMultichoiceComponent(): void | HTMLElement {\n        const questionEl = this.initComponent();\n        if (!questionEl || !this.question) {\n            return;\n        }\n\n        // Get the prompt.\n        const question: AddonModQuizMultichoiceQuestion = this.question;\n        question.prompt = CoreDomUtils.getContentsOfElement(questionEl, '.prompt');\n\n        // Search radio buttons first (single choice).\n        let options = Array.from(questionEl.querySelectorAll<HTMLInputElement>('input[type=\"radio\"]'));\n        if (!options || !options.length) {\n            // Radio buttons not found, it should be a multi answer. Search for checkbox.\n            question.multi = true;\n            options = Array.from(questionEl.querySelectorAll<HTMLInputElement>('input[type=\"checkbox\"]'));\n\n            if (!options || !options.length) {\n                // No checkbox found either. Abort.\n                this.logger.warn('Aborting because of no radio and checkbox found.', question.slot);\n\n                return CoreQuestionHelper.showComponentError(this.onAbort);\n            }\n        }\n\n        question.options = [];\n        question.disabled = true;\n\n        for (const i in options) {\n            const element = options[i];\n            const option: AddonModQuizQuestionRadioOption = {\n                id: element.id,\n                class: '',\n                name: element.name,\n                value: element.value,\n                checked: element.checked,\n                disabled: element.disabled,\n            };\n            const parent = element.parentElement;\n\n            if (option.value == '-1') {\n                // It's the clear choice option, ignore it.\n                continue;\n            }\n\n            question.optionsName = option.name;\n            question.disabled = question.disabled && element.disabled;\n\n            // Get the label with the question text. Try the new format first.\n            const labelId = element.getAttribute('aria-labelledby');\n            let label = labelId ? questionEl.querySelector('#' + labelId.replace(/:/g, '\\\\:')) : undefined;\n            if (!label) {\n                // Not found, use the old format.\n                label = questionEl.querySelector('label[for=\"' + option.id + '\"]');\n            }\n            option.class = label?.className || option.class;\n\n            // Check that we were able to successfully extract options required data.\n            if (!label || option.name === undefined || option.value === undefined) {\n                // Something went wrong when extracting the questions data. Abort.\n                this.logger.warn('Aborting because of an error parsing options.', question.slot, option.name);\n\n                return CoreQuestionHelper.showComponentError(this.onAbort);\n            }\n\n            option.text = label.innerHTML;\n\n            if (element.checked) {\n                // If the option is checked and it's a single choice we use the model to select the one.\n                if (!question.multi) {\n                    question.singleChoiceModel = option.value;\n                }\n\n                if (parent) {\n                    // Check if answer is correct.\n                    if (parent && parent.className.indexOf('incorrect') >= 0) {\n                        option.isCorrect = 0;\n                    } else if (parent && parent.className.indexOf('correct') >= 0) {\n                        option.isCorrect = 1;\n                    }\n\n                    // Search the feedback.\n                    const feedback = parent.querySelector('.specificfeedback');\n                    if (feedback) {\n                        option.feedback = feedback.innerHTML;\n                    }\n                }\n            }\n\n            question.options.push(option);\n        }\n\n        return questionEl;\n    }\n\n}\n\n/**\n * Any possible types of question.\n */\nexport type AddonModQuizQuestion = AddonModQuizCalculatedQuestion | AddonModQuizEssayQuestion | AddonModQuizTextQuestion |\nAddonModQuizMatchQuestion | AddonModQuizMultichoiceQuestion;\n\n/**\n * Basic data for question.\n */\nexport type AddonModQuizQuestionBasicData = CoreQuestionQuestion & {\n    text?: string;\n};\n\n/**\n * Data for calculated question.\n */\nexport type AddonModQuizCalculatedQuestion = AddonModQuizTextQuestion & {\n    select?: AddonModQuizQuestionSelect; // Select data if units use a select.\n    selectFirst?: boolean; // Whether the select is first or after the input.\n    options?: AddonModQuizQuestionRadioOption[]; // Options if units use radio buttons.\n    optionsName?: string; // Options name (for radio buttons).\n    unit?: string; // Option selected (for radio buttons).\n    optionsFirst?: boolean; // Whether the radio buttons are first or after the input.\n};\n\n/**\n * Data for a select.\n */\nexport type AddonModQuizQuestionSelect = {\n    id: string;\n    name: string;\n    disabled: boolean;\n    options: AddonModQuizQuestionSelectOption[];\n    selected?: string;\n    accessibilityLabel?: string;\n};\n\n/**\n * Data for each option in a select.\n */\nexport type AddonModQuizQuestionSelectOption = {\n    value: string;\n    label: string;\n    selected: boolean;\n};\n\n/**\n * Data for radio button.\n */\nexport type AddonModQuizQuestionRadioOption = {\n    id: string;\n    name: string;\n    class: string;\n    value: string;\n    disabled: boolean;\n    checked: boolean;\n    text?: string;\n    isCorrect?: number;\n    feedback?: string;\n};\n\n/**\n * Data for essay question.\n */\nexport type AddonModQuizEssayQuestion = AddonModQuizQuestionBasicData & {\n    allowsAttachments?: boolean; // Whether the question allows attachments.\n    allowsAnswerFiles?: boolean; // Whether the question allows adding files in the answer.\n    isMonospaced?: boolean; // Whether the answer is monospaced.\n    isPlainText?: boolean; // Whether the answer is plain text.\n    hasInlineText?: boolean; // // Whether the answer has inline text\n    answer?: string; // Question answer text.\n    attachments?: CoreWSFile[]; // Question answer attachments.\n    hasDraftFiles?: boolean; // Whether the question has draft files.\n    textarea?: AddonModQuizQuestionTextarea; // Textarea data.\n    formatInput?: { name: string; value: string }; // Format input data.\n    answerDraftIdInput?: { name: string; value: number }; // Answer draft id input data.\n    attachmentsDraftIdInput?: { name: string; value: number }; // Attachments draft id input data.\n    attachmentsMaxFiles?: number; // Max number of attachments.\n    attachmentsAcceptedTypes?: string; // Attachments accepted file types.\n    attachmentsMaxBytes?: number; // Max bytes for attachments.\n    answerPlagiarism?: string; // Plagiarism HTML for the answer.\n    attachmentsPlagiarisms?: string[]; // Plagiarism HTML for each attachment.\n    wordCountInfo?: string; // Info about word count.\n};\n\n/**\n * Data for textarea.\n */\nexport type AddonModQuizQuestionTextarea = {\n    id: string;\n    name: string;\n    text: string;\n};\n\n/**\n * Data for text question.\n */\nexport type AddonModQuizTextQuestion = AddonModQuizQuestionBasicData & {\n    input?: AddonModQuizQuestionTextInput;\n};\n\n/**\n * Data for text input.\n */\nexport type AddonModQuizQuestionTextInput = {\n    id: string;\n    name: string;\n    value: string;\n    readOnly: boolean;\n    isInline: boolean;\n    correctClass?: string;\n    correctIcon?: string;\n    correctIconColor?: string;\n};\n\n/**\n * Data for match question.\n */\nexport type AddonModQuizMatchQuestion = AddonModQuizQuestionBasicData & {\n    loaded?: boolean; // Whether the question is loaded.\n    rows?: AddonModQuizQuestionMatchSelect[]; // Data for each row.\n};\n\n/**\n * Each select data for match questions.\n */\nexport type AddonModQuizQuestionMatchSelect = AddonModQuizQuestionSelect & {\n    text: string;\n    isCorrect?: number;\n};\n\n/**\n * Data for multichoice question.\n */\nexport type AddonModQuizMultichoiceQuestion = AddonModQuizQuestionBasicData & {\n    prompt?: string; // Question prompt.\n    multi?: boolean; // Whether the question allows more than one selected answer.\n    options?: AddonModQuizQuestionRadioOption[]; // List of options.\n    disabled?: boolean; // Whether the question is disabled.\n    optionsName?: string; // Name to use for the options in single choice.\n    singleChoiceModel?: string; // Model for single choice.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}