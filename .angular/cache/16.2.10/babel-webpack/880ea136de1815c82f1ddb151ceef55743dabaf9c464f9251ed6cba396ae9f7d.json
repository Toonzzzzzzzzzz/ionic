{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreFilepool } from '@services/filepool';\nimport { CorePluginFileDelegate } from '@services/plugin-file-delegate';\nimport { CoreSites } from '@services/sites';\nimport { CoreCourse } from '../services/course';\n/**\n * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. Prefetch handlers should inherit either\n * from CoreCourseModuleActivityPrefetchHandlerBase or CoreCourseModuleResourcePrefetchHandlerBase, depending on whether\n * they are an activity or a resource. It's not recommended to inherit from this class directly.\n */\nexport class CoreCourseModulePrefetchHandlerBase {\n  constructor() {\n    /**\n     * Name of the handler.\n     */\n    this.name = 'CoreCourseModulePrefetchHandler';\n    /**\n     * Name of the module. It should match the \"modname\" of the module returned in core_course_get_contents.\n     */\n    this.modName = 'default';\n    /**\n     * The handler's component.\n     */\n    this.component = 'core_module';\n    /**\n     * The RegExp to check updates. If a module has an update whose name matches this RegExp, the module will be marked\n     * as outdated. This RegExp is ignored if hasUpdates function is defined.\n     */\n    this.updatesNames = /^.*files$/;\n    /**\n     * List of download promises to prevent downloading the module twice at the same time.\n     */\n    this.downloadPromises = {};\n  }\n  /**\n   * Add an ongoing download to the downloadPromises list. When the promise finishes it will be removed.\n   *\n   * @param id Unique identifier per component.\n   * @param promise Promise to add.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise of the current download.\n   */\n  addOngoingDownload(id, promise, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const uniqueId = _this.getUniqueId(id);\n      if (!_this.downloadPromises[siteId]) {\n        _this.downloadPromises[siteId] = {};\n      }\n      _this.downloadPromises[siteId][uniqueId] = promise;\n      try {\n        return yield _this.downloadPromises[siteId][uniqueId];\n      } finally {\n        delete _this.downloadPromises[siteId][uniqueId];\n      }\n    })();\n  }\n  /**\n   * Download the module.\n   *\n   * @param module The module object returned by WS.\n   * @param courseId Course ID.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @returns Promise resolved when all content is downloaded.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  download(module, courseId, dirPath) {\n    return _asyncToGenerator(function* () {\n      // To be overridden.\n      return;\n    })();\n  }\n  /**\n   * Returns a list of content files that can be downloaded.\n   *\n   * @param module The module object returned by WS.\n   * @returns List of files.\n   */\n  getContentDownloadableFiles(module) {\n    var _module$contents;\n    if (!((_module$contents = module.contents) !== null && _module$contents !== void 0 && _module$contents.length)) {\n      return [];\n    }\n    return module.contents.filter(content => this.isFileDownloadable(content));\n  }\n  /**\n   * Get the download size of a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @returns Promise resolved with the size.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getDownloadSize(module, courseId, single) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const files = yield _this2.getFiles(module, courseId);\n        return yield CorePluginFileDelegate.getFilesDownloadSize(files);\n      } catch (_unused) {\n        return {\n          size: -1,\n          total: false\n        };\n      }\n    })();\n  }\n  /**\n   * Get the downloaded size of a module. If not defined, we'll use getFiles to calculate it (it can be slow).\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Size, or promise resolved with the size.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getDownloadedSize(module, courseId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const siteId = CoreSites.getCurrentSiteId();\n      return CoreFilepool.getFilesSizeByComponent(siteId, _this3.component, module.id);\n    })();\n  }\n  /**\n   * Get list of files. If not defined, we'll assume they're in module.contents.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @returns Promise resolved with the list of files.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getFiles(module, courseId, single) {\n    return _asyncToGenerator(function* () {\n      // To be overridden.\n      return [];\n    })();\n  }\n  /**\n   * Returns module intro files.\n   *\n   * @param module The module object returned by WS.\n   * @param courseId Course ID.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved with list of intro files.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getIntroFiles(module, courseId, ignoreCache) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4.getIntroFilesFromInstance(module);\n    })();\n  }\n  /**\n   * Returns module intro files from instance.\n   *\n   * @param module The module object returned by WS.\n   * @param instance The instance to get the intro files (book, assign, ...). If not defined, module will be used.\n   * @returns List of intro files.\n   */\n  getIntroFilesFromInstance(module, instance) {\n    if (instance) {\n      if (instance.introfiles !== undefined) {\n        return instance.introfiles;\n      } else if (instance.intro) {\n        return CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(instance.intro);\n      }\n    }\n    if ('description' in module && module.description) {\n      return CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(module.description);\n    }\n    return [];\n  }\n  /**\n   * If there's an ongoing download for a certain identifier return it.\n   *\n   * @param id Unique identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise of the current download.\n   */\n  getOngoingDownload(id, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (_this5.isDownloading(id, siteId)) {\n        // There's already a download ongoing, return the promise.\n        return _this5.downloadPromises[siteId][_this5.getUniqueId(id)];\n      }\n    })();\n  }\n  /**\n   * Create unique identifier using component and id.\n   *\n   * @param id Unique ID inside component.\n   * @returns Unique ID.\n   */\n  getUniqueId(id) {\n    return this.component + '#' + id;\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId The course ID the module belongs to.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  invalidateContent(moduleId, courseId) {\n    return _asyncToGenerator(function* () {\n      // To be overridden.\n      return;\n    })();\n  }\n  /**\n   * Invalidate WS calls needed to determine module status (usually, to check if module is downloadable).\n   * It doesn't need to invalidate check updates. It should NOT invalidate files nor all the prefetched data.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when invalidated.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  invalidateModule(module, courseId) {\n    return CoreCourse.invalidateModule(module.id);\n  }\n  /**\n   * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Whether the module can be downloaded. The promise should never be rejected.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isDownloadable(module, courseId) {\n    return _asyncToGenerator(function* () {\n      // By default, mark all instances as downloadable.\n      return true;\n    })();\n  }\n  /**\n   * Check if a there's an ongoing download for the given identifier.\n   *\n   * @param id Unique identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns True if downloading, false otherwise.\n   */\n  isDownloading(id, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    return !!(this.downloadPromises[siteId] && this.downloadPromises[siteId][this.getUniqueId(id)]);\n  }\n  /**\n   * Whether or not the handler is enabled on a site level.\n   *\n   * @returns A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  /**\n   * Check if a file is downloadable.\n   *\n   * @param file File to check.\n   * @returns Whether the file is downloadable.\n   */\n  isFileDownloadable(file) {\n    return file.type === 'file';\n  }\n  /**\n   * Load module contents into module.contents if they aren't loaded already.\n   *\n   * @param module Module to load the contents.\n   * @param courseId The course ID. Recommended to speed up the process and minimize data usage.\n   * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n   * @returns Promise resolved when loaded.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  loadContents(module, courseId, ignoreCache) {\n    return _asyncToGenerator(function* () {\n      // To be overridden.\n      return;\n    })();\n  }\n  /**\n   * Prefetch a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @returns Promise resolved when done.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  prefetch(module, courseId, single, dirPath) {\n    return _asyncToGenerator(function* () {\n      // To be overridden.\n      return;\n    })();\n  }\n  /**\n   * Remove module downloaded files. If not defined, we'll use getFiles to remove them (slow).\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @returns Promise resolved when done.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  removeFiles(module, courseId) {\n    return CoreFilepool.removeFilesByComponent(CoreSites.getCurrentSiteId(), this.component, module.id);\n  }\n}","map":{"version":3,"names":["CoreFilepool","CorePluginFileDelegate","CoreSites","CoreCourse","CoreCourseModulePrefetchHandlerBase","constructor","name","modName","component","updatesNames","downloadPromises","addOngoingDownload","id","promise","siteId","_this","_asyncToGenerator","getCurrentSiteId","uniqueId","getUniqueId","download","module","courseId","dirPath","getContentDownloadableFiles","_module$contents","contents","length","filter","content","isFileDownloadable","getDownloadSize","single","_this2","files","getFiles","getFilesDownloadSize","_unused","size","total","getDownloadedSize","_this3","getFilesSizeByComponent","getIntroFiles","ignoreCache","_this4","getIntroFilesFromInstance","instance","introfiles","undefined","intro","extractDownloadableFilesFromHtmlAsFakeFileObjects","description","getOngoingDownload","_this5","isDownloading","invalidateContent","moduleId","invalidateModule","isDownloadable","isEnabled","file","type","loadContents","prefetch","removeFiles","removeFilesByComponent"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/classes/module-prefetch-handler.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreFileSizeSum, CorePluginFileDelegate } from '@services/plugin-file-delegate';\nimport { CoreSites } from '@services/sites';\nimport { CoreWSFile } from '@services/ws';\nimport { CoreCourse, CoreCourseAnyModuleData, CoreCourseModuleContentFile } from '../services/course';\nimport { CoreCourseModulePrefetchHandler } from '../services/module-prefetch-delegate';\n\n/**\n * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. Prefetch handlers should inherit either\n * from CoreCourseModuleActivityPrefetchHandlerBase or CoreCourseModuleResourcePrefetchHandlerBase, depending on whether\n * they are an activity or a resource. It's not recommended to inherit from this class directly.\n */\nexport class CoreCourseModulePrefetchHandlerBase implements CoreCourseModulePrefetchHandler {\n\n    /**\n     * Name of the handler.\n     */\n    name = 'CoreCourseModulePrefetchHandler';\n\n    /**\n     * Name of the module. It should match the \"modname\" of the module returned in core_course_get_contents.\n     */\n    modName = 'default';\n\n    /**\n     * The handler's component.\n     */\n    component = 'core_module';\n\n    /**\n     * The RegExp to check updates. If a module has an update whose name matches this RegExp, the module will be marked\n     * as outdated. This RegExp is ignored if hasUpdates function is defined.\n     */\n    updatesNames = /^.*files$/;\n\n    /**\n     * List of download promises to prevent downloading the module twice at the same time.\n     */\n    protected downloadPromises: { [s: string]: { [s: string]: Promise<void> } } = {};\n\n    /**\n     * Add an ongoing download to the downloadPromises list. When the promise finishes it will be removed.\n     *\n     * @param id Unique identifier per component.\n     * @param promise Promise to add.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise of the current download.\n     */\n    async addOngoingDownload(id: number, promise: Promise<void>, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const uniqueId = this.getUniqueId(id);\n\n        if (!this.downloadPromises[siteId]) {\n            this.downloadPromises[siteId] = {};\n        }\n\n        this.downloadPromises[siteId][uniqueId] = promise;\n\n        try {\n            return await this.downloadPromises[siteId][uniqueId];\n        } finally {\n            delete this.downloadPromises[siteId][uniqueId];\n        }\n    }\n\n    /**\n     * Download the module.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when all content is downloaded.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async download(module: CoreCourseAnyModuleData, courseId: number, dirPath?: string): Promise<void> {\n        // To be overridden.\n        return;\n    }\n\n    /**\n     * Returns a list of content files that can be downloaded.\n     *\n     * @param module The module object returned by WS.\n     * @returns List of files.\n     */\n    getContentDownloadableFiles(module: CoreCourseAnyModuleData): CoreCourseModuleContentFile[] {\n        if (!module.contents?.length) {\n            return [];\n        }\n\n        return module.contents.filter((content) => this.isFileDownloadable(content));\n    }\n\n    /**\n     * Get the download size of a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @returns Promise resolved with the size.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getDownloadSize(module: CoreCourseAnyModuleData, courseId: number, single?: boolean): Promise<CoreFileSizeSum> {\n        try {\n            const files = await this.getFiles(module, courseId);\n\n            return await CorePluginFileDelegate.getFilesDownloadSize(files);\n        } catch {\n            return { size: -1, total: false };\n        }\n    }\n\n    /**\n     * Get the downloaded size of a module. If not defined, we'll use getFiles to calculate it (it can be slow).\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Size, or promise resolved with the size.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getDownloadedSize(module: CoreCourseAnyModuleData, courseId: number): Promise<number> {\n        const siteId = CoreSites.getCurrentSiteId();\n\n        return CoreFilepool.getFilesSizeByComponent(siteId, this.component, module.id);\n    }\n\n    /**\n     * Get list of files. If not defined, we'll assume they're in module.contents.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @returns Promise resolved with the list of files.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getFiles(module: CoreCourseAnyModuleData, courseId: number, single?: boolean): Promise<CoreWSFile[]> {\n        // To be overridden.\n        return [];\n    }\n\n    /**\n     * Returns module intro files.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved with list of intro files.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getIntroFiles(module: CoreCourseAnyModuleData, courseId: number, ignoreCache?: boolean): Promise<CoreWSFile[]> {\n        return this.getIntroFilesFromInstance(module);\n    }\n\n    /**\n     * Returns module intro files from instance.\n     *\n     * @param module The module object returned by WS.\n     * @param instance The instance to get the intro files (book, assign, ...). If not defined, module will be used.\n     * @returns List of intro files.\n     */\n    getIntroFilesFromInstance(module: CoreCourseAnyModuleData, instance?: ModuleInstance): CoreWSFile[] {\n        if (instance) {\n            if (instance.introfiles !== undefined) {\n                return instance.introfiles;\n            } else if (instance.intro) {\n                return CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(instance.intro);\n            }\n        }\n\n        if ('description' in module && module.description) {\n            return CoreFilepool.extractDownloadableFilesFromHtmlAsFakeFileObjects(module.description);\n        }\n\n        return [];\n    }\n\n    /**\n     * If there's an ongoing download for a certain identifier return it.\n     *\n     * @param id Unique identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise of the current download.\n     */\n    async getOngoingDownload(id: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (this.isDownloading(id, siteId)) {\n            // There's already a download ongoing, return the promise.\n            return this.downloadPromises[siteId][this.getUniqueId(id)];\n        }\n    }\n\n    /**\n     * Create unique identifier using component and id.\n     *\n     * @param id Unique ID inside component.\n     * @returns Unique ID.\n     */\n    getUniqueId(id: number): string {\n        return this.component + '#' + id;\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId The course ID the module belongs to.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async invalidateContent(moduleId: number, courseId: number): Promise<void> {\n        // To be overridden.\n        return;\n    }\n\n    /**\n     * Invalidate WS calls needed to determine module status (usually, to check if module is downloadable).\n     * It doesn't need to invalidate check updates. It should NOT invalidate files nor all the prefetched data.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when invalidated.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    invalidateModule(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        return CoreCourse.invalidateModule(module.id);\n    }\n\n    /**\n     * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Whether the module can be downloaded. The promise should never be rejected.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async isDownloadable(module: CoreCourseAnyModuleData, courseId: number): Promise<boolean> {\n        // By default, mark all instances as downloadable.\n        return true;\n    }\n\n    /**\n     * Check if a there's an ongoing download for the given identifier.\n     *\n     * @param id Unique identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns True if downloading, false otherwise.\n     */\n    isDownloading(id: number, siteId?: string): boolean {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        return !!(this.downloadPromises[siteId] && this.downloadPromises[siteId][this.getUniqueId(id)]);\n    }\n\n    /**\n     * Whether or not the handler is enabled on a site level.\n     *\n     * @returns A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * Check if a file is downloadable.\n     *\n     * @param file File to check.\n     * @returns Whether the file is downloadable.\n     */\n    isFileDownloadable(file: CoreCourseModuleContentFile): boolean {\n        return file.type === 'file';\n    }\n\n    /**\n     * Load module contents into module.contents if they aren't loaded already.\n     *\n     * @param module Module to load the contents.\n     * @param courseId The course ID. Recommended to speed up the process and minimize data usage.\n     * @param ignoreCache True if it should ignore cached data (it will always fail in offline or server down).\n     * @returns Promise resolved when loaded.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async loadContents(module: CoreCourseAnyModuleData, courseId: number, ignoreCache?: boolean): Promise<void> {\n        // To be overridden.\n        return;\n    }\n\n    /**\n     * Prefetch a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when done.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async prefetch(module: CoreCourseAnyModuleData, courseId?: number, single?: boolean, dirPath?: string): Promise<void> {\n        // To be overridden.\n        return;\n    }\n\n    /**\n     * Remove module downloaded files. If not defined, we'll use getFiles to remove them (slow).\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @returns Promise resolved when done.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    removeFiles(module: CoreCourseAnyModuleData, courseId: number): Promise<void> {\n        return CoreFilepool.removeFilesByComponent(CoreSites.getCurrentSiteId(), this.component, module.id);\n    }\n\n}\n\n/**\n * Properties a module instance should have to be able to retrieve its intro files.\n */\ntype ModuleInstance = {\n    introfiles?: CoreWSFile[];\n    intro?: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}