{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { Subject } from 'rxjs';\nimport { CoreApp } from '@services/app';\nimport { CoreConfig } from '@services/config';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreQueueRunner } from '@classes/queue-runner';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreConstants } from '@/core/constants';\nimport { makeSingleton, NgZone, Translate, LocalNotifications } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { APP_SCHEMA, TRIGGERED_TABLE_NAME, COMPONENTS_TABLE_NAME, SITES_TABLE_NAME } from '@services/database/local-notifications';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { Push } from '@features/native/plugins';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle local notifications.\n */\nexport class CoreLocalNotificationsProvider {\n  constructor() {\n    this.codes = {};\n    this.codeRequestsQueue = {};\n    this.observables = {};\n    this.appDB = new Promise(resolve => this.resolveAppDB = resolve);\n    this.logger = CoreLogger.getInstance('CoreLocalNotificationsProvider');\n    this.queueRunner = new CoreQueueRunner(10);\n  }\n  /**\n   * Init some properties.\n   */\n  initialize() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield CorePlatform.ready();\n      // Request permission when the app starts.\n      LocalNotifications.requestPermission();\n      // Listen to events.\n      _this.triggerSubscription = LocalNotifications.on('trigger').subscribe(notification => {\n        _this.trigger(notification);\n        _this.handleEvent('trigger', notification);\n      });\n      _this.clickSubscription = LocalNotifications.on('click').subscribe(notification => {\n        _this.handleEvent('click', notification);\n      });\n      _this.clearSubscription = LocalNotifications.on('clear').subscribe(notification => {\n        _this.handleEvent('clear', notification);\n      });\n      _this.cancelSubscription = LocalNotifications.on('cancel').subscribe(notification => {\n        _this.handleEvent('cancel', notification);\n      });\n      _this.addSubscription = LocalNotifications.on('schedule').subscribe(notification => {\n        _this.handleEvent('schedule', notification);\n      });\n      _this.updateSubscription = LocalNotifications.on('update').subscribe(notification => {\n        _this.handleEvent('update', notification);\n      });\n      // Create the default channel for local notifications.\n      _this.createDefaultChannel();\n      Translate.onLangChange.subscribe(() => {\n        // Update the channel name.\n        _this.createDefaultChannel();\n      });\n      CoreEvents.on(CoreEvents.SITE_DELETED, site => {\n        if (site !== null && site !== void 0 && site.id) {\n          _this.cancelSiteNotifications(site.id);\n        }\n      });\n    })();\n  }\n  /**\n   * Initialize database.\n   */\n  initializeDatabase() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield CoreApp.createTablesFromSchema(APP_SCHEMA);\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      _this2.resolveAppDB(CoreApp.getDB());\n    })();\n  }\n  /**\n   * Cancel a local notification.\n   *\n   * @param id Notification id.\n   * @param component Component of the notification.\n   * @param siteId Site ID.\n   * @returns Promise resolved when the notification is cancelled.\n   */\n  cancel(id, component, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const uniqueId = yield _this3.getUniqueNotificationId(id, component, siteId);\n      const queueId = 'cancel-' + uniqueId;\n      yield _this3.queueRunner.run(queueId, () => LocalNotifications.cancel(uniqueId), {\n        allowRepeated: true\n      });\n    })();\n  }\n  /**\n   * Cancel all the scheduled notifications belonging to a certain site.\n   *\n   * @param siteId Site ID.\n   * @returns Promise resolved when the notifications are cancelled.\n   */\n  cancelSiteNotifications(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!siteId) {\n        throw new Error('No site ID supplied.');\n      }\n      const scheduled = yield _this4.getAllScheduled();\n      const ids = [];\n      const queueId = 'cancelSiteNotifications-' + siteId;\n      scheduled.forEach(notif => {\n        notif.data = _this4.parseNotificationData(notif.data);\n        if (notif.id && typeof notif.data == 'object' && notif.data.siteId === siteId) {\n          ids.push(notif.id);\n        }\n      });\n      yield _this4.queueRunner.run(queueId, () => LocalNotifications.cancel(ids), {\n        allowRepeated: true\n      });\n    })();\n  }\n  /**\n   * Check whether sound can be disabled for notifications.\n   *\n   * @returns Whether sound can be disabled for notifications.\n   */\n  canDisableSound() {\n    // Only allow disabling sound in Android 7 or lower. In iOS and Android 8+ it can easily be done with system settings.\n    return CorePlatform.isAndroid() && CorePlatform.getPlatformMajorVersion() < 8;\n  }\n  /**\n   * Create the default channel. It is used to change the name.\n   *\n   * @returns Promise resolved when done.\n   */\n  createDefaultChannel() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!CorePlatform.isAndroid()) {\n        return;\n      }\n      yield Push.createChannel({\n        id: 'default-channel-id',\n        description: Translate.instant('addon.calendar.calendarreminders'),\n        importance: 4\n      }).catch(error => {\n        _this5.logger.error('Error changing channel name', error);\n      });\n    })();\n  }\n  /**\n   * Get all scheduled notifications.\n   *\n   * @returns Promise resolved with the notifications.\n   */\n  getAllScheduled() {\n    return this.queueRunner.run('allScheduled', () => LocalNotifications.getAllScheduled());\n  }\n  /**\n   * Get a code to create unique notifications. If there's no code assigned, create a new one.\n   *\n   * @param table Table to search in local DB.\n   * @param id ID of the element to get its code.\n   * @returns Promise resolved when the code is retrieved.\n   */\n  getCode(table, id) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const key = table + '#' + id;\n      // Check if the code is already in memory.\n      if (_this6.codes[key] !== undefined) {\n        return _this6.codes[key];\n      }\n      const db = yield _this6.appDB;\n      try {\n        // Check if we already have a code stored for that ID.\n        const entry = yield db.getRecord(table, {\n          id: id\n        });\n        _this6.codes[key] = entry.code;\n        return entry.code;\n      } catch (err) {\n        // No code stored for that ID. Create a new code for it.\n        const entries = yield db.getRecords(table, undefined, 'code DESC');\n        let newCode = 0;\n        if (entries.length > 0) {\n          newCode = entries[0].code + 1;\n        }\n        yield db.insertRecord(table, {\n          id: id,\n          code: newCode\n        });\n        _this6.codes[key] = newCode;\n        return newCode;\n      }\n    })();\n  }\n  /**\n   * Get a notification component code to be used.\n   * If it's the first time this component is used to send notifications, create a new code for it.\n   *\n   * @param component Component name.\n   * @returns Promise resolved when the component code is retrieved.\n   */\n  getComponentCode(component) {\n    return this.requestCode(COMPONENTS_TABLE_NAME, component);\n  }\n  /**\n   * Get a site code to be used.\n   * If it's the first time this site is used to send notifications, create a new code for it.\n   *\n   * @param siteId Site ID.\n   * @returns Promise resolved when the site code is retrieved.\n   */\n  getSiteCode(siteId) {\n    return this.requestCode(SITES_TABLE_NAME, siteId);\n  }\n  /**\n   * Create a unique notification ID, trying to prevent collisions. Generated ID must be a Number (Android).\n   * The generated ID shouldn't be higher than 2147483647 or it's going to cause problems in Android.\n   * This function will prevent collisions and keep the number under Android limit if:\n   *     - User has used less than 21 sites.\n   *     - There are less than 11 components.\n   *     - The notificationId passed as parameter is lower than 10000000.\n   *\n   * @param notificationId Notification ID.\n   * @param component Component triggering the notification.\n   * @param siteId Site ID.\n   * @returns Promise resolved when the notification ID is generated.\n   */\n  getUniqueNotificationId(notificationId, component, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!siteId || !component) {\n        return Promise.reject(new CoreError('Site ID or component not supplied.'));\n      }\n      const siteCode = yield _this7.getSiteCode(siteId);\n      const componentCode = yield _this7.getComponentCode(component);\n      // We use the % operation to keep the number under Android's limit.\n      return (siteCode * 100000000 + componentCode * 10000000 + notificationId) % 2147483647;\n    })();\n  }\n  /**\n   * Handle an event triggered by the local notifications plugin.\n   *\n   * @param eventName Name of the event.\n   * @param notification Notification.\n   */\n  handleEvent(eventName, notification) {\n    if (notification && notification.data) {\n      this.logger.debug('Notification event: ' + eventName + '. Data:', notification.data);\n      this.notifyEvent(eventName, notification.data);\n    }\n  }\n  /**\n   * Returns whether local notifications are available.\n   *\n   * @returns Whether local notifications are available.\n   * @deprecated since 4.1. It will always return true.\n   */\n  isAvailable() {\n    return true;\n  }\n  /**\n   * Returns whether local notifications plugin is available.\n   *\n   * @returns Whether local notifications plugin is available.\n   */\n  isPluginAvailable() {\n    var _win$cordova;\n    const win = window; // eslint-disable-line @typescript-eslint/no-explicit-any\n    const enabled = !!((_win$cordova = win.cordova) !== null && _win$cordova !== void 0 && (_win$cordova = _win$cordova.plugins) !== null && _win$cordova !== void 0 && (_win$cordova = _win$cordova.notification) !== null && _win$cordova !== void 0 && _win$cordova.local);\n    return enabled && CorePlatform.is('cordova');\n  }\n  /**\n   * Check if a notification has been triggered with the same trigger time.\n   *\n   * @param notification Notification to check.\n   * @param useQueue Whether to add the call to the queue.\n   * @returns Promise resolved with a boolean indicating if promise is triggered (true) or not.\n   */\n  isTriggered(notification, useQueue = true) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield _this8.appDB;\n      try {\n        const stored = yield db.getRecord(TRIGGERED_TABLE_NAME, {\n          id: notification.id\n        });\n        let triggered = notification.trigger && notification.trigger.at || 0;\n        if (typeof triggered != 'number') {\n          triggered = triggered.getTime();\n        }\n        return stored.at === triggered;\n      } catch (_unused2) {\n        const notificationId = notification.id || 0;\n        if (useQueue) {\n          const queueId = 'isTriggered-' + notificationId;\n          return _this8.queueRunner.run(queueId, () => LocalNotifications.isTriggered(notificationId), {\n            allowRepeated: true\n          });\n        } else {\n          return LocalNotifications.isTriggered(notificationId);\n        }\n      }\n    })();\n  }\n  /**\n   * Notify notification click to observers. Only the observers with the same component as the notification will be notified.\n   *\n   * @param data Data received by the notification.\n   */\n  notifyClick(data) {\n    this.notifyEvent('click', data);\n  }\n  /**\n   * Notify a certain event to observers. Only the observers with the same component as the notification will be notified.\n   *\n   * @param eventName Name of the event to notify.\n   * @param data Data received by the notification.\n   */\n  notifyEvent(eventName, data) {\n    // Execute the code in the Angular zone, so change detection doesn't stop working.\n    NgZone.run(() => {\n      const component = data.component;\n      if (component) {\n        if (this.observables[eventName] && this.observables[eventName][component]) {\n          this.observables[eventName][component].next(data);\n        }\n      }\n    });\n  }\n  /**\n   * Parse some notification data.\n   *\n   * @param data Notification data.\n   * @returns Parsed data.\n   */\n  parseNotificationData(data) {\n    if (!data) {\n      return {};\n    } else if (typeof data == 'string') {\n      return CoreTextUtils.parseJSON(data, {});\n    } else {\n      return data;\n    }\n  }\n  /**\n   * Process the next request in queue.\n   */\n  processNextRequest() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const nextKey = Object.keys(_this9.codeRequestsQueue)[0];\n      if (nextKey === undefined) {\n        // No more requests in queue, stop.\n        return;\n      }\n      const request = _this9.codeRequestsQueue[nextKey];\n      try {\n        // Check if request is valid.\n        if (typeof request != 'object' || request.table === undefined || request.id === undefined) {\n          return;\n        }\n        // Get the code and resolve/reject all the promises of this request.\n        const code = yield _this9.getCode(request.table, request.id);\n        request.deferreds.forEach(p => {\n          p.resolve(code);\n        });\n      } catch (error) {\n        request.deferreds.forEach(p => {\n          p.reject(error);\n        });\n      } finally {\n        // Once this item is treated, remove it and process next.\n        delete _this9.codeRequestsQueue[nextKey];\n        _this9.processNextRequest();\n      }\n    })();\n  }\n  /**\n   * Register an observer to be notified when a notification belonging to a certain component is clicked.\n   *\n   * @param component Component to listen notifications for.\n   * @param callback Function to call with the data received by the notification.\n   * @returns Object with an \"off\" property to stop listening for clicks.\n   */\n  registerClick(component, callback) {\n    return this.registerObserver('click', component, callback);\n  }\n  /**\n   * Register an observer to be notified when a certain event is fired for a notification belonging to a certain component.\n   *\n   * @param eventName Name of the event to listen to.\n   * @param component Component to listen notifications for.\n   * @param callback Function to call with the data received by the notification.\n   * @returns Object with an \"off\" property to stop listening for events.\n   */\n  registerObserver(eventName, component, callback) {\n    this.logger.debug(`Register observer '${component}' for event '${eventName}'.`);\n    if (this.observables[eventName] === undefined) {\n      this.observables[eventName] = {};\n    }\n    if (this.observables[eventName][component] === undefined) {\n      // No observable for this component, create a new one.\n      this.observables[eventName][component] = new Subject();\n    }\n    this.observables[eventName][component].subscribe(callback);\n    return {\n      off: () => {\n        this.observables[eventName][component].unsubscribe();\n      }\n    };\n  }\n  /**\n   * Remove a notification from triggered store.\n   *\n   * @param id Notification ID.\n   * @returns Promise resolved when it is removed.\n   */\n  removeTriggered(id) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield _this10.appDB;\n      yield db.deleteRecords(TRIGGERED_TABLE_NAME, {\n        id: id\n      });\n    })();\n  }\n  /**\n   * Request a unique code. The request will be added to the queue and the queue is going to be started if it's paused.\n   *\n   * @param table Table to search in local DB.\n   * @param id ID of the element to get its code.\n   * @returns Promise resolved when the code is retrieved.\n   */\n  requestCode(table, id) {\n    const deferred = new CorePromisedValue();\n    const key = table + '#' + id;\n    const isQueueEmpty = Object.keys(this.codeRequestsQueue).length == 0;\n    if (this.codeRequestsQueue[key] !== undefined) {\n      // There's already a pending request for this store and ID, add the promise to it.\n      this.codeRequestsQueue[key].deferreds.push(deferred);\n    } else {\n      // Add a pending request to the queue.\n      this.codeRequestsQueue[key] = {\n        table: table,\n        id: id,\n        deferreds: [deferred]\n      };\n    }\n    if (isQueueEmpty) {\n      this.processNextRequest();\n    }\n    return deferred;\n  }\n  /**\n   * Reschedule all notifications that are already scheduled.\n   *\n   * @returns Promise resolved when all notifications have been rescheduled.\n   */\n  rescheduleAll() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      // Get all the scheduled notifications.\n      const notifications = yield _this11.getAllScheduled();\n      yield Promise.all(notifications.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (notification) {\n          // Convert some properties to the needed types.\n          notification.data = _this11.parseNotificationData(notification.data);\n          const queueId = 'schedule-' + notification.id;\n          yield _this11.queueRunner.run(queueId, () => _this11.scheduleNotification(notification), {\n            allowRepeated: true\n          });\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Schedule a local notification.\n   *\n   * @param notification Notification to schedule. Its ID should be lower than 10000000 and it should\n   *                     be unique inside its component and site.\n   * @param component Component triggering the notification. It is used to generate unique IDs.\n   * @param siteId Site ID.\n   * @param alreadyUnique Whether the ID is already unique.\n   * @returns Promise resolved when the notification is scheduled.\n   */\n  schedule(notification, component, siteId, alreadyUnique) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      if (!alreadyUnique) {\n        notification.id = yield _this12.getUniqueNotificationId(notification.id || 0, component, siteId);\n      }\n      notification.data = notification.data || {};\n      notification.data.component = component;\n      notification.data.siteId = siteId;\n      if (CorePlatform.isAndroid()) {\n        notification.icon = notification.icon || 'res://icon';\n        notification.smallIcon = notification.smallIcon || 'res://smallicon';\n        notification.color = notification.color || CoreConstants.CONFIG.notificoncolor;\n        if (notification.led !== false) {\n          let ledColor = 'FF9900';\n          let ledOn = 1000;\n          let ledOff = 1000;\n          if (typeof notification.led === 'string') {\n            ledColor = notification.led;\n          } else if (Array.isArray(notification.led)) {\n            ledColor = notification.led[0] || ledColor;\n            ledOn = notification.led[1] || ledOn;\n            ledOff = notification.led[2] || ledOff;\n          } else if (typeof notification.led === 'object') {\n            ledColor = notification.led.color || ledColor;\n            ledOn = notification.led.on || ledOn;\n            ledOff = notification.led.off || ledOff;\n          }\n          notification.led = {\n            color: ledColor,\n            on: ledOn,\n            off: ledOff\n          };\n        }\n      }\n      const queueId = 'schedule-' + notification.id;\n      yield _this12.queueRunner.run(queueId, () => _this12.scheduleNotification(notification), {\n        allowRepeated: true\n      });\n    })();\n  }\n  /**\n   * Helper function to schedule a notification object if it hasn't been triggered already.\n   *\n   * @param notification Notification to schedule.\n   * @returns Promise resolved when scheduled.\n   */\n  scheduleNotification(notification) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      // Check if the notification has been triggered already.\n      const triggered = yield _this13.isTriggered(notification, false);\n      // Cancel the current notification in case it gets scheduled twice.\n      LocalNotifications.cancel(notification.id).finally( /*#__PURE__*/_asyncToGenerator(function* () {\n        if (!triggered) {\n          let soundEnabled;\n          // Check if sound is enabled for notifications.\n          if (!_this13.canDisableSound()) {\n            soundEnabled = true;\n          } else {\n            soundEnabled = yield CoreConfig.get(CoreConstants.SETTINGS_NOTIFICATION_SOUND, true);\n          }\n          if (!soundEnabled) {\n            notification.sound = undefined;\n          } else {\n            delete notification.sound; // Use default value.\n          }\n\n          notification.foreground = true;\n          // Remove from triggered, since the notification could be in there with a different time.\n          _this13.removeTriggered(notification.id || 0);\n          LocalNotifications.schedule(notification);\n        }\n      }));\n    })();\n  }\n  /**\n   * Function to call when a notification is triggered. Stores the notification so it's not scheduled again unless the\n   * time is changed.\n   *\n   * @param notification Triggered notification.\n   * @returns Promise resolved when stored, rejected otherwise.\n   */\n  trigger(notification) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      var _notification$trigger;\n      const db = yield _this14.appDB;\n      let time = Date.now();\n      if ((_notification$trigger = notification.trigger) !== null && _notification$trigger !== void 0 && _notification$trigger.at) {\n        // The type says \"at\" is a Date, but in Android we can receive timestamps instead.\n        if (typeof notification.trigger.at === 'number') {\n          time = notification.trigger.at;\n        } else {\n          time = notification.trigger.at.getTime();\n        }\n      }\n      const entry = {\n        id: notification.id,\n        at: time\n      };\n      return db.insertRecord(TRIGGERED_TABLE_NAME, entry);\n    })();\n  }\n  /**\n   * Update a component name.\n   *\n   * @param oldName The old name.\n   * @param newName The new name.\n   * @returns Promise resolved when done.\n   */\n  updateComponentName(oldName, newName) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield _this15.appDB;\n      const oldId = COMPONENTS_TABLE_NAME + '#' + oldName;\n      const newId = COMPONENTS_TABLE_NAME + '#' + newName;\n      yield db.updateRecords(COMPONENTS_TABLE_NAME, {\n        id: newId\n      }, {\n        id: oldId\n      });\n    })();\n  }\n}\n_class = CoreLocalNotificationsProvider;\n_class.ɵfac = function CoreLocalNotificationsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreLocalNotifications = makeSingleton(CoreLocalNotificationsProvider);","map":{"version":3,"names":["Subject","CoreApp","CoreConfig","CoreEvents","CoreTextUtils","CoreQueueRunner","CoreError","CoreConstants","makeSingleton","NgZone","Translate","LocalNotifications","CoreLogger","APP_SCHEMA","TRIGGERED_TABLE_NAME","COMPONENTS_TABLE_NAME","SITES_TABLE_NAME","CorePromisedValue","CorePlatform","Push","CoreLocalNotificationsProvider","constructor","codes","codeRequestsQueue","observables","appDB","Promise","resolve","resolveAppDB","logger","getInstance","queueRunner","initialize","_this","_asyncToGenerator","ready","requestPermission","triggerSubscription","on","subscribe","notification","trigger","handleEvent","clickSubscription","clearSubscription","cancelSubscription","addSubscription","updateSubscription","createDefaultChannel","onLangChange","SITE_DELETED","site","id","cancelSiteNotifications","initializeDatabase","_this2","createTablesFromSchema","_unused","getDB","cancel","component","siteId","_this3","uniqueId","getUniqueNotificationId","queueId","run","allowRepeated","_this4","Error","scheduled","getAllScheduled","ids","forEach","notif","data","parseNotificationData","push","canDisableSound","isAndroid","getPlatformMajorVersion","_this5","createChannel","description","instant","importance","catch","error","getCode","table","_this6","key","undefined","db","entry","getRecord","code","err","entries","getRecords","newCode","length","insertRecord","getComponentCode","requestCode","getSiteCode","notificationId","_this7","reject","siteCode","componentCode","eventName","debug","notifyEvent","isAvailable","isPluginAvailable","_win$cordova","win","window","enabled","cordova","plugins","local","is","isTriggered","useQueue","_this8","stored","triggered","at","getTime","_unused2","notifyClick","next","parseJSON","processNextRequest","_this9","nextKey","Object","keys","request","deferreds","p","registerClick","callback","registerObserver","off","unsubscribe","removeTriggered","_this10","deleteRecords","deferred","isQueueEmpty","rescheduleAll","_this11","notifications","all","map","_ref","scheduleNotification","_x","apply","arguments","schedule","alreadyUnique","_this12","icon","smallIcon","color","CONFIG","notificoncolor","led","ledColor","ledOn","ledOff","Array","isArray","_this13","finally","soundEnabled","get","SETTINGS_NOTIFICATION_SOUND","sound","foreground","_this14","_notification$trigger","time","Date","now","updateComponentName","oldName","newName","_this15","oldId","newId","updateRecords","factory","ɵfac","providedIn","CoreLocalNotifications"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/local-notifications.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { Subject, Subscription } from 'rxjs';\nimport { ILocalNotification } from '@awesome-cordova-plugins/local-notifications';\n\nimport { CoreApp } from '@services/app';\nimport { CoreConfig } from '@services/config';\nimport { CoreEventObserver, CoreEvents } from '@singletons/events';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreQueueRunner } from '@classes/queue-runner';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreConstants } from '@/core/constants';\nimport { makeSingleton, NgZone, Translate, LocalNotifications } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport {\n    APP_SCHEMA,\n    TRIGGERED_TABLE_NAME,\n    COMPONENTS_TABLE_NAME,\n    SITES_TABLE_NAME,\n    CodeRequestsQueueItem,\n} from '@services/database/local-notifications';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CorePlatform } from '@services/platform';\nimport { Push } from '@features/native/plugins';\n\n/**\n * Service to handle local notifications.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreLocalNotificationsProvider {\n\n    protected logger: CoreLogger;\n    protected codes: { [s: string]: number } = {};\n    protected codeRequestsQueue: {[key: string]: CodeRequestsQueueItem} = {};\n    protected observables: {[eventName: string]: {[component: string]: Subject<unknown>}} = {};\n\n    protected triggerSubscription?: Subscription;\n    protected clickSubscription?: Subscription;\n    protected clearSubscription?: Subscription;\n    protected cancelSubscription?: Subscription;\n    protected addSubscription?: Subscription;\n    protected updateSubscription?: Subscription;\n    protected queueRunner: CoreQueueRunner; // Queue to decrease the number of concurrent calls to the plugin (see MOBILE-3477).\n\n    // Variables for DB.\n    protected appDB: Promise<SQLiteDB>;\n    protected resolveAppDB!: (appDB: SQLiteDB) => void;\n\n    constructor() {\n        this.appDB = new Promise(resolve => this.resolveAppDB = resolve);\n        this.logger = CoreLogger.getInstance('CoreLocalNotificationsProvider');\n        this.queueRunner = new CoreQueueRunner(10);\n    }\n\n    /**\n     * Init some properties.\n     */\n    async initialize(): Promise<void> {\n        await CorePlatform.ready();\n\n        // Request permission when the app starts.\n        LocalNotifications.requestPermission();\n\n        // Listen to events.\n        this.triggerSubscription = LocalNotifications.on('trigger').subscribe((notification: ILocalNotification) => {\n            this.trigger(notification);\n\n            this.handleEvent('trigger', notification);\n        });\n\n        this.clickSubscription = LocalNotifications.on('click').subscribe((notification: ILocalNotification) => {\n            this.handleEvent('click', notification);\n        });\n\n        this.clearSubscription = LocalNotifications.on('clear').subscribe((notification: ILocalNotification) => {\n            this.handleEvent('clear', notification);\n        });\n\n        this.cancelSubscription = LocalNotifications.on('cancel').subscribe((notification: ILocalNotification) => {\n            this.handleEvent('cancel', notification);\n        });\n\n        this.addSubscription = LocalNotifications.on('schedule').subscribe((notification: ILocalNotification) => {\n            this.handleEvent('schedule', notification);\n        });\n\n        this.updateSubscription = LocalNotifications.on('update').subscribe((notification: ILocalNotification) => {\n            this.handleEvent('update', notification);\n        });\n\n        // Create the default channel for local notifications.\n        this.createDefaultChannel();\n\n        Translate.onLangChange.subscribe(() => {\n            // Update the channel name.\n            this.createDefaultChannel();\n        });\n\n        CoreEvents.on(CoreEvents.SITE_DELETED, (site) => {\n            if (site?.id) {\n                this.cancelSiteNotifications(site.id);\n            }\n        });\n    }\n\n    /**\n     * Initialize database.\n     */\n    async initializeDatabase(): Promise<void> {\n        try {\n            await CoreApp.createTablesFromSchema(APP_SCHEMA);\n        } catch {\n            // Ignore errors.\n        }\n\n        this.resolveAppDB(CoreApp.getDB());\n    }\n\n    /**\n     * Cancel a local notification.\n     *\n     * @param id Notification id.\n     * @param component Component of the notification.\n     * @param siteId Site ID.\n     * @returns Promise resolved when the notification is cancelled.\n     */\n    async cancel(id: number, component: string, siteId: string): Promise<void> {\n        const uniqueId = await this.getUniqueNotificationId(id, component, siteId);\n\n        const queueId = 'cancel-' + uniqueId;\n\n        await this.queueRunner.run(queueId, () => LocalNotifications.cancel(uniqueId), {\n            allowRepeated: true,\n        });\n    }\n\n    /**\n     * Cancel all the scheduled notifications belonging to a certain site.\n     *\n     * @param siteId Site ID.\n     * @returns Promise resolved when the notifications are cancelled.\n     */\n    async cancelSiteNotifications(siteId: string): Promise<void> {\n        if (!siteId) {\n            throw new Error('No site ID supplied.');\n        }\n\n        const scheduled = await this.getAllScheduled();\n\n        const ids: number[] = [];\n        const queueId = 'cancelSiteNotifications-' + siteId;\n\n        scheduled.forEach((notif) => {\n            notif.data = this.parseNotificationData(notif.data);\n\n            if (notif.id && typeof notif.data == 'object' && notif.data.siteId === siteId) {\n                ids.push(notif.id);\n            }\n        });\n\n        await this.queueRunner.run(queueId, () => LocalNotifications.cancel(ids), {\n            allowRepeated: true,\n        });\n    }\n\n    /**\n     * Check whether sound can be disabled for notifications.\n     *\n     * @returns Whether sound can be disabled for notifications.\n     */\n    canDisableSound(): boolean {\n        // Only allow disabling sound in Android 7 or lower. In iOS and Android 8+ it can easily be done with system settings.\n        return CorePlatform.isAndroid() && CorePlatform.getPlatformMajorVersion() < 8;\n    }\n\n    /**\n     * Create the default channel. It is used to change the name.\n     *\n     * @returns Promise resolved when done.\n     */\n    protected async createDefaultChannel(): Promise<void> {\n        if (!CorePlatform.isAndroid()) {\n            return;\n        }\n\n        await Push.createChannel({\n            id: 'default-channel-id',\n            description: Translate.instant('addon.calendar.calendarreminders'),\n            importance: 4,\n        }).catch((error) => {\n            this.logger.error('Error changing channel name', error);\n        });\n    }\n\n    /**\n     * Get all scheduled notifications.\n     *\n     * @returns Promise resolved with the notifications.\n     */\n    protected getAllScheduled(): Promise<ILocalNotification[]> {\n        return this.queueRunner.run('allScheduled', () => LocalNotifications.getAllScheduled());\n    }\n\n    /**\n     * Get a code to create unique notifications. If there's no code assigned, create a new one.\n     *\n     * @param table Table to search in local DB.\n     * @param id ID of the element to get its code.\n     * @returns Promise resolved when the code is retrieved.\n     */\n    protected async getCode(table: string, id: string): Promise<number> {\n        const key = table + '#' + id;\n\n        // Check if the code is already in memory.\n        if (this.codes[key] !== undefined) {\n            return this.codes[key];\n        }\n\n        const db = await this.appDB;\n\n        try {\n            // Check if we already have a code stored for that ID.\n            const entry = await db.getRecord<{id: string; code: number}>(table, { id: id });\n\n            this.codes[key] = entry.code;\n\n            return entry.code;\n        } catch (err) {\n            // No code stored for that ID. Create a new code for it.\n            const entries = await db.getRecords<{id: string; code: number}>(table, undefined, 'code DESC');\n\n            let newCode = 0;\n            if (entries.length > 0) {\n                newCode = entries[0].code + 1;\n            }\n\n            await db.insertRecord(table, { id: id, code: newCode });\n            this.codes[key] = newCode;\n\n            return newCode;\n        }\n    }\n\n    /**\n     * Get a notification component code to be used.\n     * If it's the first time this component is used to send notifications, create a new code for it.\n     *\n     * @param component Component name.\n     * @returns Promise resolved when the component code is retrieved.\n     */\n    protected getComponentCode(component: string): Promise<number> {\n        return this.requestCode(COMPONENTS_TABLE_NAME, component);\n    }\n\n    /**\n     * Get a site code to be used.\n     * If it's the first time this site is used to send notifications, create a new code for it.\n     *\n     * @param siteId Site ID.\n     * @returns Promise resolved when the site code is retrieved.\n     */\n    protected getSiteCode(siteId: string): Promise<number> {\n        return this.requestCode(SITES_TABLE_NAME, siteId);\n    }\n\n    /**\n     * Create a unique notification ID, trying to prevent collisions. Generated ID must be a Number (Android).\n     * The generated ID shouldn't be higher than 2147483647 or it's going to cause problems in Android.\n     * This function will prevent collisions and keep the number under Android limit if:\n     *     - User has used less than 21 sites.\n     *     - There are less than 11 components.\n     *     - The notificationId passed as parameter is lower than 10000000.\n     *\n     * @param notificationId Notification ID.\n     * @param component Component triggering the notification.\n     * @param siteId Site ID.\n     * @returns Promise resolved when the notification ID is generated.\n     */\n    protected async getUniqueNotificationId(notificationId: number, component: string, siteId: string): Promise<number> {\n        if (!siteId || !component) {\n            return Promise.reject(new CoreError('Site ID or component not supplied.'));\n        }\n\n        const siteCode = await this.getSiteCode(siteId);\n        const componentCode = await this.getComponentCode(component);\n\n        // We use the % operation to keep the number under Android's limit.\n        return (siteCode * 100000000 + componentCode * 10000000 + notificationId) % 2147483647;\n    }\n\n    /**\n     * Handle an event triggered by the local notifications plugin.\n     *\n     * @param eventName Name of the event.\n     * @param notification Notification.\n     */\n    protected handleEvent(eventName: string, notification: ILocalNotification): void {\n        if (notification && notification.data) {\n            this.logger.debug('Notification event: ' + eventName + '. Data:', notification.data);\n\n            this.notifyEvent(eventName, notification.data);\n        }\n    }\n\n    /**\n     * Returns whether local notifications are available.\n     *\n     * @returns Whether local notifications are available.\n     * @deprecated since 4.1. It will always return true.\n     */\n    isAvailable(): boolean {\n        return true;\n    }\n\n    /**\n     * Returns whether local notifications plugin is available.\n     *\n     * @returns Whether local notifications plugin is available.\n     */\n    isPluginAvailable(): boolean {\n        const win = <any> window; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n        const enabled = !!win.cordova?.plugins?.notification?.local;\n\n        return enabled && CorePlatform.is('cordova');\n    }\n\n    /**\n     * Check if a notification has been triggered with the same trigger time.\n     *\n     * @param notification Notification to check.\n     * @param useQueue Whether to add the call to the queue.\n     * @returns Promise resolved with a boolean indicating if promise is triggered (true) or not.\n     */\n    async isTriggered(notification: ILocalNotification, useQueue: boolean = true): Promise<boolean> {\n        const db = await this.appDB;\n\n        try {\n            const stored = await db.getRecord<{ id: number; at: number }>(\n                TRIGGERED_TABLE_NAME,\n                { id: notification.id },\n            );\n\n            let triggered = (notification.trigger && notification.trigger.at) || 0;\n\n            if (typeof triggered != 'number') {\n                triggered = triggered.getTime();\n            }\n\n            return stored.at === triggered;\n        } catch {\n            const notificationId = notification.id || 0;\n            if (useQueue) {\n                const queueId = 'isTriggered-' + notificationId;\n\n                return this.queueRunner.run(queueId, () => LocalNotifications.isTriggered(notificationId), {\n                    allowRepeated: true,\n                });\n            } else {\n                return LocalNotifications.isTriggered(notificationId);\n            }\n        }\n    }\n\n    /**\n     * Notify notification click to observers. Only the observers with the same component as the notification will be notified.\n     *\n     * @param data Data received by the notification.\n     */\n    notifyClick(data: Record<string, unknown>): void {\n        this.notifyEvent('click', data);\n    }\n\n    /**\n     * Notify a certain event to observers. Only the observers with the same component as the notification will be notified.\n     *\n     * @param eventName Name of the event to notify.\n     * @param data Data received by the notification.\n     */\n    notifyEvent(eventName: string, data: Record<string, unknown>): void {\n        // Execute the code in the Angular zone, so change detection doesn't stop working.\n        NgZone.run(() => {\n            const component = <string> data.component;\n            if (component) {\n                if (this.observables[eventName] && this.observables[eventName][component]) {\n                    this.observables[eventName][component].next(data);\n                }\n            }\n        });\n    }\n\n    /**\n     * Parse some notification data.\n     *\n     * @param data Notification data.\n     * @returns Parsed data.\n     */\n    protected parseNotificationData(data: unknown): unknown {\n        if (!data) {\n            return {};\n        } else if (typeof data == 'string') {\n            return CoreTextUtils.parseJSON(data, {});\n        } else {\n            return data;\n        }\n    }\n\n    /**\n     * Process the next request in queue.\n     */\n    protected async processNextRequest(): Promise<void> {\n        const nextKey = Object.keys(this.codeRequestsQueue)[0];\n\n        if (nextKey === undefined) {\n            // No more requests in queue, stop.\n            return;\n        }\n\n        const request = this.codeRequestsQueue[nextKey];\n\n        try {\n            // Check if request is valid.\n            if (typeof request != 'object' || request.table === undefined || request.id === undefined) {\n                return;\n            }\n\n            // Get the code and resolve/reject all the promises of this request.\n            const code = await this.getCode(request.table, request.id);\n\n            request.deferreds.forEach((p) => {\n                p.resolve(code);\n            });\n        } catch (error) {\n            request.deferreds.forEach((p) => {\n                p.reject(error);\n            });\n        } finally {\n            // Once this item is treated, remove it and process next.\n            delete this.codeRequestsQueue[nextKey];\n            this.processNextRequest();\n        }\n    }\n\n    /**\n     * Register an observer to be notified when a notification belonging to a certain component is clicked.\n     *\n     * @param component Component to listen notifications for.\n     * @param callback Function to call with the data received by the notification.\n     * @returns Object with an \"off\" property to stop listening for clicks.\n     */\n    registerClick<T = unknown>(component: string, callback: CoreLocalNotificationsClickCallback<T>): CoreEventObserver {\n        return this.registerObserver<T>('click', component, callback);\n    }\n\n    /**\n     * Register an observer to be notified when a certain event is fired for a notification belonging to a certain component.\n     *\n     * @param eventName Name of the event to listen to.\n     * @param component Component to listen notifications for.\n     * @param callback Function to call with the data received by the notification.\n     * @returns Object with an \"off\" property to stop listening for events.\n     */\n    registerObserver<T = unknown>(\n        eventName: string,\n        component: string,\n        callback: CoreLocalNotificationsClickCallback<T>,\n    ): CoreEventObserver {\n        this.logger.debug(`Register observer '${component}' for event '${eventName}'.`);\n\n        if (this.observables[eventName] === undefined) {\n            this.observables[eventName] = {};\n        }\n\n        if (this.observables[eventName][component] === undefined) {\n            // No observable for this component, create a new one.\n            this.observables[eventName][component] = new Subject<T>();\n        }\n\n        this.observables[eventName][component].subscribe(callback);\n\n        return {\n            off: (): void => {\n                this.observables[eventName][component].unsubscribe();\n            },\n        };\n    }\n\n    /**\n     * Remove a notification from triggered store.\n     *\n     * @param id Notification ID.\n     * @returns Promise resolved when it is removed.\n     */\n    async removeTriggered(id: number): Promise<void> {\n        const db = await this.appDB;\n\n        await db.deleteRecords(TRIGGERED_TABLE_NAME, { id: id });\n    }\n\n    /**\n     * Request a unique code. The request will be added to the queue and the queue is going to be started if it's paused.\n     *\n     * @param table Table to search in local DB.\n     * @param id ID of the element to get its code.\n     * @returns Promise resolved when the code is retrieved.\n     */\n    protected requestCode(table: string, id: string): Promise<number> {\n        const deferred = new CorePromisedValue<number>();\n        const key = table + '#' + id;\n        const isQueueEmpty = Object.keys(this.codeRequestsQueue).length == 0;\n\n        if (this.codeRequestsQueue[key] !== undefined) {\n            // There's already a pending request for this store and ID, add the promise to it.\n            this.codeRequestsQueue[key].deferreds.push(deferred);\n        } else {\n            // Add a pending request to the queue.\n            this.codeRequestsQueue[key] = {\n                table: table,\n                id: id,\n                deferreds: [deferred],\n            };\n        }\n\n        if (isQueueEmpty) {\n            this.processNextRequest();\n        }\n\n        return deferred;\n    }\n\n    /**\n     * Reschedule all notifications that are already scheduled.\n     *\n     * @returns Promise resolved when all notifications have been rescheduled.\n     */\n    async rescheduleAll(): Promise<void> {\n        // Get all the scheduled notifications.\n        const notifications = await this.getAllScheduled();\n\n        await Promise.all(notifications.map(async (notification) => {\n            // Convert some properties to the needed types.\n            notification.data = this.parseNotificationData(notification.data);\n\n            const queueId = 'schedule-' + notification.id;\n\n            await this.queueRunner.run(queueId, () => this.scheduleNotification(notification), {\n                allowRepeated: true,\n            });\n        }));\n    }\n\n    /**\n     * Schedule a local notification.\n     *\n     * @param notification Notification to schedule. Its ID should be lower than 10000000 and it should\n     *                     be unique inside its component and site.\n     * @param component Component triggering the notification. It is used to generate unique IDs.\n     * @param siteId Site ID.\n     * @param alreadyUnique Whether the ID is already unique.\n     * @returns Promise resolved when the notification is scheduled.\n     */\n    async schedule(notification: ILocalNotification, component: string, siteId: string, alreadyUnique?: boolean): Promise<void> {\n        if (!alreadyUnique) {\n            notification.id = await this.getUniqueNotificationId(notification.id || 0, component, siteId);\n        }\n\n        notification.data = notification.data || {};\n        notification.data.component = component;\n        notification.data.siteId = siteId;\n\n        if (CorePlatform.isAndroid()) {\n            notification.icon = notification.icon || 'res://icon';\n            notification.smallIcon = notification.smallIcon || 'res://smallicon';\n            notification.color = notification.color || CoreConstants.CONFIG.notificoncolor;\n\n            if (notification.led !== false) {\n                let ledColor = 'FF9900';\n                let ledOn = 1000;\n                let ledOff = 1000;\n\n                if (typeof notification.led === 'string') {\n                    ledColor = notification.led;\n                } else if (Array.isArray(notification.led)) {\n                    ledColor = notification.led[0] || ledColor;\n                    ledOn = notification.led[1] || ledOn;\n                    ledOff = notification.led[2] || ledOff;\n                } else if (typeof notification.led === 'object') {\n                    ledColor = notification.led.color || ledColor;\n                    ledOn = notification.led.on || ledOn;\n                    ledOff = notification.led.off || ledOff;\n                }\n\n                notification.led = {\n                    color: ledColor,\n                    on: ledOn,\n                    off: ledOff,\n                };\n            }\n        }\n\n        const queueId = 'schedule-' + notification.id;\n\n        await this.queueRunner.run(queueId, () => this.scheduleNotification(notification), {\n            allowRepeated: true,\n        });\n    }\n\n    /**\n     * Helper function to schedule a notification object if it hasn't been triggered already.\n     *\n     * @param notification Notification to schedule.\n     * @returns Promise resolved when scheduled.\n     */\n    protected async scheduleNotification(notification: ILocalNotification): Promise<void> {\n        // Check if the notification has been triggered already.\n        const triggered = await this.isTriggered(notification, false);\n\n        // Cancel the current notification in case it gets scheduled twice.\n        LocalNotifications.cancel(notification.id).finally(async () => {\n            if (!triggered) {\n                let soundEnabled: boolean;\n\n                // Check if sound is enabled for notifications.\n                if (!this.canDisableSound()) {\n                    soundEnabled = true;\n                } else {\n                    soundEnabled = await CoreConfig.get(CoreConstants.SETTINGS_NOTIFICATION_SOUND, true);\n                }\n\n                if (!soundEnabled) {\n                    notification.sound = undefined;\n                } else {\n                    delete notification.sound; // Use default value.\n                }\n\n                notification.foreground = true;\n\n                // Remove from triggered, since the notification could be in there with a different time.\n                this.removeTriggered(notification.id || 0);\n                LocalNotifications.schedule(notification);\n            }\n        });\n    }\n\n    /**\n     * Function to call when a notification is triggered. Stores the notification so it's not scheduled again unless the\n     * time is changed.\n     *\n     * @param notification Triggered notification.\n     * @returns Promise resolved when stored, rejected otherwise.\n     */\n    async trigger(notification: ILocalNotification): Promise<number> {\n        const db = await this.appDB;\n        let time = Date.now();\n        if (notification.trigger?.at) {\n            // The type says \"at\" is a Date, but in Android we can receive timestamps instead.\n            if (typeof notification.trigger.at === 'number') {\n                time = <number> notification.trigger.at;\n            } else {\n                time = notification.trigger.at.getTime();\n            }\n        }\n\n        const entry = {\n            id: notification.id,\n            at: time,\n        };\n\n        return db.insertRecord(TRIGGERED_TABLE_NAME, entry);\n    }\n\n    /**\n     * Update a component name.\n     *\n     * @param oldName The old name.\n     * @param newName The new name.\n     * @returns Promise resolved when done.\n     */\n    async updateComponentName(oldName: string, newName: string): Promise<void> {\n        const db = await this.appDB;\n\n        const oldId = COMPONENTS_TABLE_NAME + '#' + oldName;\n        const newId = COMPONENTS_TABLE_NAME + '#' + newName;\n\n        await db.updateRecords(COMPONENTS_TABLE_NAME, { id: newId }, { id: oldId });\n    }\n\n}\n\nexport const CoreLocalNotifications = makeSingleton(CoreLocalNotificationsProvider);\n\nexport type CoreLocalNotificationsClickCallback<T = unknown> = (value: T) => void;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}