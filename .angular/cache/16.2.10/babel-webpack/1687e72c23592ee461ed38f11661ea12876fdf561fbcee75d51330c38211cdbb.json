{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreDelegate } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./handlers/default-question\";\n/**\n * Delegate to register question handlers.\n */\nexport class CoreQuestionDelegateService extends CoreDelegate {\n  constructor(defaultHandler) {\n    super('CoreQuestionDelegate', true);\n    this.defaultHandler = defaultHandler;\n    this.handlerNameProperty = 'type';\n  }\n  /**\n   * Get the behaviour to use for a certain question type.\n   * E.g. 'qtype_essay' uses 'manualgraded'.\n   *\n   * @param question The question.\n   * @param behaviour The default behaviour.\n   * @returns The behaviour to use.\n   */\n  getBehaviourForQuestion(question, behaviour) {\n    const type = this.getTypeName(question);\n    const questionBehaviour = this.executeFunctionOnEnabled(type, 'getBehaviour', [question, behaviour]);\n    return questionBehaviour || behaviour;\n  }\n  /**\n   * Get the directive to use for a certain question type.\n   *\n   * @param question The question to render.\n   * @returns Promise resolved with component to use, undefined if not found.\n   */\n  getComponentForQuestion(question) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const type = _this.getTypeName(question);\n      return _this.executeFunctionOnEnabled(type, 'getComponent', [question]);\n    })();\n  }\n  /**\n   * Check if a question can be submitted.\n   * If a question cannot be submitted it should return a message explaining why (translated or not).\n   *\n   * @param question Question.\n   * @returns Prevent submit message. Undefined or empty if can be submitted.\n   */\n  getPreventSubmitMessage(question) {\n    const type = this.getTypeName(question);\n    return this.executeFunctionOnEnabled(type, 'getPreventSubmitMessage', [question]);\n  }\n  /**\n   * Given a type name, return the full name of that type. E.g. 'calculated' -> 'qtype_calculated'.\n   *\n   * @param type Type to treat.\n   * @returns Type full name.\n   */\n  getFullTypeName(type) {\n    return 'qtype_' + type;\n  }\n  /**\n   * Given a question, return the full name of its question type.\n   *\n   * @param question Question.\n   * @returns Type name.\n   */\n  getTypeName(question) {\n    return this.getFullTypeName(question.type);\n  }\n  /**\n   * Check if a response is complete.\n   *\n   * @param question The question.\n   * @param answers Object with the question answers (without prefix).\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @returns 1 if complete, 0 if not complete, -1 if cannot determine.\n   */\n  isCompleteResponse(question, answers, component, componentId) {\n    const type = this.getTypeName(question);\n    const isComplete = this.executeFunctionOnEnabled(type, 'isCompleteResponse', [question, answers, component, componentId]);\n    return isComplete !== null && isComplete !== void 0 ? isComplete : -1;\n  }\n  /**\n   * Check if a student has provided enough of an answer for the question to be graded automatically,\n   * or whether it must be considered aborted.\n   *\n   * @param question The question.\n   * @param answers Object with the question answers (without prefix).\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @returns 1 if gradable, 0 if not gradable, -1 if cannot determine.\n   */\n  isGradableResponse(question, answers, component, componentId) {\n    const type = this.getTypeName(question);\n    const isGradable = this.executeFunctionOnEnabled(type, 'isGradableResponse', [question, answers, component, componentId]);\n    return isGradable !== null && isGradable !== void 0 ? isGradable : -1;\n  }\n  /**\n   * Check if two responses are the same.\n   *\n   * @param question Question.\n   * @param prevAnswers Object with the previous question answers.\n   * @param newAnswers Object with the new question answers.\n   * @returns Whether they're the same.\n   */\n  isSameResponse(question, prevAnswers, newAnswers, component, componentId) {\n    const type = this.getTypeName(question);\n    return !!this.executeFunctionOnEnabled(type, 'isSameResponse', [question, prevAnswers, newAnswers, component, componentId]);\n  }\n  /**\n   * Check if a question type is supported.\n   *\n   * @param type Question type.\n   * @returns Whether it's supported.\n   */\n  isQuestionSupported(type) {\n    return this.hasHandler(this.getFullTypeName(type), true);\n  }\n  /**\n   * Prepare the answers for a certain question.\n   *\n   * @param question Question.\n   * @param answers The answers retrieved from the form. Prepared answers must be stored in this object.\n   * @param offline Whether the data should be saved in offline.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data has been prepared.\n   */\n  prepareAnswersForQuestion(question, answers, offline, component, componentId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const type = _this2.getTypeName(question);\n      yield _this2.executeFunctionOnEnabled(type, 'prepareAnswers', [question, answers, offline, component, componentId, siteId]);\n    })();\n  }\n  /**\n   * Validate if an offline sequencecheck is valid compared with the online one.\n   *\n   * @param question The question.\n   * @param offlineSequenceCheck Sequence check stored in offline.\n   * @returns Whether sequencecheck is valid.\n   */\n  validateSequenceCheck(question, offlineSequenceCheck) {\n    const type = this.getTypeName(question);\n    return !!this.executeFunctionOnEnabled(type, 'validateSequenceCheck', [question, offlineSequenceCheck]);\n  }\n  /**\n   * Get the list of files that needs to be downloaded in addition to the files embedded in the HTML.\n   *\n   * @param question Question.\n   * @param usageId Usage ID.\n   * @returns List of files or URLs.\n   */\n  getAdditionalDownloadableFiles(question, usageId) {\n    const type = this.getTypeName(question);\n    return this.executeFunctionOnEnabled(type, 'getAdditionalDownloadableFiles', [question, usageId]) || [];\n  }\n  /**\n   * Clear temporary data after the data has been saved.\n   *\n   * @param question Question.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @returns If async, promise resolved when done.\n   */\n  clearTmpData(question, component, componentId) {\n    const type = this.getTypeName(question);\n    return this.executeFunctionOnEnabled(type, 'clearTmpData', [question, component, componentId]);\n  }\n  /**\n   * Clear temporary data after the data has been saved.\n   *\n   * @param question Question.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns If async, promise resolved when done.\n   */\n  deleteOfflineData(question, component, componentId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const type = _this3.getTypeName(question);\n      yield _this3.executeFunctionOnEnabled(type, 'deleteOfflineData', [question, component, componentId, siteId]);\n    })();\n  }\n  /**\n   * Prepare data to send when performing a synchronization.\n   *\n   * @param question Question.\n   * @param answers Answers of the question, without the prefix.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns If async, promise resolved when done.\n   */\n  prepareSyncData(question, answers, component, componentId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const type = _this4.getTypeName(question);\n      yield _this4.executeFunctionOnEnabled(type, 'prepareSyncData', [question, answers, component, componentId, siteId]);\n    })();\n  }\n  /**\n   * Check if there's a validation error with the offline data.\n   *\n   * @param question The question.\n   * @param answers Object with the question offline answers (without prefix).\n   * @param onlineError Online validation error.\n   * @param component The component the question is related to.\n   * @param componentId Component ID.\n   * @returns Error message if there's a validation error, undefined otherwise.\n   */\n  getValidationError(question, answers, onlineError, component, componentId) {\n    const type = this.getTypeName(question);\n    return this.executeFunctionOnEnabled(type, 'getValidationError', [question, answers, onlineError, component, componentId]);\n  }\n}\n_class = CoreQuestionDelegateService;\n_class.ɵfac = function CoreQuestionDelegateService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.CoreQuestionDefaultHandler));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreQuestionDelegate = makeSingleton(CoreQuestionDelegateService);","map":{"version":3,"names":["CoreDelegate","makeSingleton","CoreQuestionDelegateService","constructor","defaultHandler","handlerNameProperty","getBehaviourForQuestion","question","behaviour","type","getTypeName","questionBehaviour","executeFunctionOnEnabled","getComponentForQuestion","_this","_asyncToGenerator","getPreventSubmitMessage","getFullTypeName","isCompleteResponse","answers","component","componentId","isComplete","isGradableResponse","isGradable","isSameResponse","prevAnswers","newAnswers","isQuestionSupported","hasHandler","prepareAnswersForQuestion","offline","siteId","_this2","validateSequenceCheck","offlineSequenceCheck","getAdditionalDownloadableFiles","usageId","clearTmpData","deleteOfflineData","_this3","prepareSyncData","_this4","getValidationError","onlineError","i0","ɵɵinject","i1","CoreQuestionDefaultHandler","factory","ɵfac","providedIn","CoreQuestionDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/question/services/question-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\n\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { CoreWSFile } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { CoreQuestionDefaultHandler } from './handlers/default-question';\nimport { CoreQuestionQuestionParsed, CoreQuestionsAnswers } from './question';\n\n/**\n * Interface that all question type handlers must implement.\n */\nexport interface CoreQuestionHandler extends CoreDelegateHandler {\n    /**\n     * Type of the question the handler supports. E.g. 'qtype_calculated'.\n     */\n    type: string;\n\n    /**\n     * Return the Component to use to display the question.\n     * It's recommended to return the class of the component, but you can also return an instance of the component.\n     *\n     * @param question The question to render.\n     * @returns The component (or promise resolved with component) to use, undefined if not found.\n     */\n    getComponent(question: CoreQuestionQuestionParsed): undefined | Type<unknown> | Promise<Type<unknown>>;\n\n    /**\n     * Return the name of the behaviour to use for the question.\n     * If the question should use the default behaviour you shouldn't implement this function.\n     *\n     * @param question The question.\n     * @param behaviour The default behaviour.\n     * @returns The behaviour to use.\n     */\n    getBehaviour?(question: CoreQuestionQuestionParsed, behaviour: string): string;\n\n    /**\n     * Check if a question can be submitted.\n     * If a question cannot be submitted it should return a message explaining why (translated or not).\n     *\n     * @param question The question.\n     * @returns Prevent submit message. Undefined or empty if can be submitted.\n     */\n    getPreventSubmitMessage?(question: CoreQuestionQuestionParsed): string | undefined;\n\n    /**\n     * Check if there's a validation error with the offline data.\n     *\n     * @param question The question.\n     * @param answers Object with the question offline answers (without prefix).\n     * @param onlineError Online validation error.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns Error message if there's a validation error, undefined otherwise.\n     */\n    getValidationError?(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        onlineError: string | undefined,\n        component: string,\n        componentId: string | number,\n    ): string | undefined;\n\n    /**\n     * Check if a response is complete.\n     *\n     * @param question The question.\n     * @param answers Object with the question answers (without prefix).\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns 1 if complete, 0 if not complete, -1 if cannot determine.\n     */\n    isCompleteResponse?(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): number;\n\n    /**\n     * Check if a student has provided enough of an answer for the question to be graded automatically,\n     * or whether it must be considered aborted.\n     *\n     * @param question The question.\n     * @param answers Object with the question answers (without prefix).\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns 1 if gradable, 0 if not gradable, -1 if cannot determine.\n     */\n    isGradableResponse?(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): number;\n\n    /**\n     * Check if two responses are the same.\n     *\n     * @param question Question.\n     * @param prevAnswers Object with the previous question answers.\n     * @param newAnswers Object with the new question answers.\n     * @returns Whether they're the same.\n     */\n    isSameResponse?(\n        question: CoreQuestionQuestionParsed,\n        prevAnswers: CoreQuestionsAnswers,\n        newAnswers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): boolean;\n\n    /**\n     * Prepare and add to answers the data to send to server based in the input. Return promise if async.\n     *\n     * @param question Question.\n     * @param answers The answers retrieved from the form. Prepared answers must be stored in this object.\n     * @param offline Whether the data should be saved in offline.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Return a promise resolved when done if async, void if sync.\n     */\n    prepareAnswers?(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        offline: boolean,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): void | Promise<void>;\n\n    /**\n     * Validate if an offline sequencecheck is valid compared with the online one.\n     * This function only needs to be implemented if a specific compare is required.\n     *\n     * @param question The question.\n     * @param offlineSequenceCheck Sequence check stored in offline.\n     * @returns Whether sequencecheck is valid.\n     */\n    validateSequenceCheck?(question: CoreQuestionQuestionParsed, offlineSequenceCheck: string): boolean;\n\n    /**\n     * Get the list of files that needs to be downloaded in addition to the files embedded in the HTML.\n     *\n     * @param question Question.\n     * @param usageId Usage ID.\n     * @returns List of files or URLs.\n     */\n    getAdditionalDownloadableFiles?(question: CoreQuestionQuestionParsed, usageId?: number): CoreWSFile[];\n\n    /**\n     * Clear temporary data after the data has been saved.\n     *\n     * @param question Question.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns If async, promise resolved when done.\n     */\n    clearTmpData?(question: CoreQuestionQuestionParsed, component: string, componentId: string | number): void | Promise<void>;\n\n    /**\n     * Delete any stored data for the question.\n     *\n     * @param question Question.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns If async, promise resolved when done.\n     */\n    deleteOfflineData?(\n        question: CoreQuestionQuestionParsed,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): void | Promise<void>;\n\n    /**\n     * Prepare data to send when performing a synchronization.\n     *\n     * @param question Question.\n     * @param answers Answers of the question, without the prefix.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns If async, promise resolved when done.\n     */\n    prepareSyncData?(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): void | Promise<void>;\n}\n\n/**\n * Delegate to register question handlers.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreQuestionDelegateService extends CoreDelegate<CoreQuestionHandler> {\n\n    protected handlerNameProperty = 'type';\n\n    constructor(protected defaultHandler: CoreQuestionDefaultHandler) {\n        super('CoreQuestionDelegate', true);\n    }\n\n    /**\n     * Get the behaviour to use for a certain question type.\n     * E.g. 'qtype_essay' uses 'manualgraded'.\n     *\n     * @param question The question.\n     * @param behaviour The default behaviour.\n     * @returns The behaviour to use.\n     */\n    getBehaviourForQuestion(question: CoreQuestionQuestionParsed, behaviour: string): string {\n        const type = this.getTypeName(question);\n        const questionBehaviour = this.executeFunctionOnEnabled<string>(type, 'getBehaviour', [question, behaviour]);\n\n        return questionBehaviour || behaviour;\n    }\n\n    /**\n     * Get the directive to use for a certain question type.\n     *\n     * @param question The question to render.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    async getComponentForQuestion(question: CoreQuestionQuestionParsed): Promise<Type<unknown> | undefined> {\n        const type = this.getTypeName(question);\n\n        return this.executeFunctionOnEnabled(type, 'getComponent', [question]);\n    }\n\n    /**\n     * Check if a question can be submitted.\n     * If a question cannot be submitted it should return a message explaining why (translated or not).\n     *\n     * @param question Question.\n     * @returns Prevent submit message. Undefined or empty if can be submitted.\n     */\n    getPreventSubmitMessage(question: CoreQuestionQuestionParsed): string | undefined {\n        const type = this.getTypeName(question);\n\n        return this.executeFunctionOnEnabled<string>(type, 'getPreventSubmitMessage', [question]);\n    }\n\n    /**\n     * Given a type name, return the full name of that type. E.g. 'calculated' -> 'qtype_calculated'.\n     *\n     * @param type Type to treat.\n     * @returns Type full name.\n     */\n    protected getFullTypeName(type: string): string {\n        return 'qtype_' + type;\n    }\n\n    /**\n     * Given a question, return the full name of its question type.\n     *\n     * @param question Question.\n     * @returns Type name.\n     */\n    protected getTypeName(question: CoreQuestionQuestionParsed): string {\n        return this.getFullTypeName(question.type);\n    }\n\n    /**\n     * Check if a response is complete.\n     *\n     * @param question The question.\n     * @param answers Object with the question answers (without prefix).\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns 1 if complete, 0 if not complete, -1 if cannot determine.\n     */\n    isCompleteResponse(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): number {\n        const type = this.getTypeName(question);\n\n        const isComplete = this.executeFunctionOnEnabled<number>(\n            type,\n            'isCompleteResponse',\n            [question, answers, component, componentId],\n        );\n\n        return isComplete ?? -1;\n    }\n\n    /**\n     * Check if a student has provided enough of an answer for the question to be graded automatically,\n     * or whether it must be considered aborted.\n     *\n     * @param question The question.\n     * @param answers Object with the question answers (without prefix).\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns 1 if gradable, 0 if not gradable, -1 if cannot determine.\n     */\n    isGradableResponse(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): number {\n        const type = this.getTypeName(question);\n\n        const isGradable = this.executeFunctionOnEnabled<number>(\n            type,\n            'isGradableResponse',\n            [question, answers, component, componentId],\n        );\n\n        return isGradable ?? -1;\n    }\n\n    /**\n     * Check if two responses are the same.\n     *\n     * @param question Question.\n     * @param prevAnswers Object with the previous question answers.\n     * @param newAnswers Object with the new question answers.\n     * @returns Whether they're the same.\n     */\n    isSameResponse(\n        question: CoreQuestionQuestionParsed,\n        prevAnswers: CoreQuestionsAnswers,\n        newAnswers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n    ): boolean {\n        const type = this.getTypeName(question);\n\n        return !!this.executeFunctionOnEnabled(type, 'isSameResponse', [question, prevAnswers, newAnswers, component, componentId]);\n    }\n\n    /**\n     * Check if a question type is supported.\n     *\n     * @param type Question type.\n     * @returns Whether it's supported.\n     */\n    isQuestionSupported(type: string): boolean {\n        return this.hasHandler(this.getFullTypeName(type), true);\n    }\n\n    /**\n     * Prepare the answers for a certain question.\n     *\n     * @param question Question.\n     * @param answers The answers retrieved from the form. Prepared answers must be stored in this object.\n     * @param offline Whether the data should be saved in offline.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data has been prepared.\n     */\n    async prepareAnswersForQuestion(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        offline: boolean,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<void> {\n        const type = this.getTypeName(question);\n\n        await this.executeFunctionOnEnabled(\n            type,\n            'prepareAnswers',\n            [question, answers, offline, component, componentId, siteId],\n        );\n    }\n\n    /**\n     * Validate if an offline sequencecheck is valid compared with the online one.\n     *\n     * @param question The question.\n     * @param offlineSequenceCheck Sequence check stored in offline.\n     * @returns Whether sequencecheck is valid.\n     */\n    validateSequenceCheck(question: CoreQuestionQuestionParsed, offlineSequenceCheck: string): boolean {\n        const type = this.getTypeName(question);\n\n        return !!this.executeFunctionOnEnabled(type, 'validateSequenceCheck', [question, offlineSequenceCheck]);\n    }\n\n    /**\n     * Get the list of files that needs to be downloaded in addition to the files embedded in the HTML.\n     *\n     * @param question Question.\n     * @param usageId Usage ID.\n     * @returns List of files or URLs.\n     */\n    getAdditionalDownloadableFiles(question: CoreQuestionQuestionParsed, usageId?: number): CoreWSFile[] {\n        const type = this.getTypeName(question);\n\n        return this.executeFunctionOnEnabled(type, 'getAdditionalDownloadableFiles', [question, usageId]) || [];\n    }\n\n    /**\n     * Clear temporary data after the data has been saved.\n     *\n     * @param question Question.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns If async, promise resolved when done.\n     */\n    clearTmpData(question: CoreQuestionQuestionParsed, component: string, componentId: string | number): void | Promise<void> {\n        const type = this.getTypeName(question);\n\n        return this.executeFunctionOnEnabled(type, 'clearTmpData', [question, component, componentId]);\n    }\n\n    /**\n     * Clear temporary data after the data has been saved.\n     *\n     * @param question Question.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns If async, promise resolved when done.\n     */\n    async deleteOfflineData(\n        question: CoreQuestionQuestionParsed,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<void> {\n        const type = this.getTypeName(question);\n\n        await this.executeFunctionOnEnabled(type, 'deleteOfflineData', [question, component, componentId, siteId]);\n    }\n\n    /**\n     * Prepare data to send when performing a synchronization.\n     *\n     * @param question Question.\n     * @param answers Answers of the question, without the prefix.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns If async, promise resolved when done.\n     */\n    async prepareSyncData(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        component: string,\n        componentId: string | number,\n        siteId?: string,\n    ): Promise<void> {\n        const type = this.getTypeName(question);\n\n        await this.executeFunctionOnEnabled(type, 'prepareSyncData', [question, answers, component, componentId, siteId]);\n    }\n\n    /**\n     * Check if there's a validation error with the offline data.\n     *\n     * @param question The question.\n     * @param answers Object with the question offline answers (without prefix).\n     * @param onlineError Online validation error.\n     * @param component The component the question is related to.\n     * @param componentId Component ID.\n     * @returns Error message if there's a validation error, undefined otherwise.\n     */\n    getValidationError(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n        onlineError: string | undefined,\n        component: string,\n        componentId: string | number,\n    ): string | undefined {\n        const type = this.getTypeName(question);\n\n        return this.executeFunctionOnEnabled(type, 'getValidationError', [question, answers, onlineError, component, componentId]);\n    }\n\n}\n\nexport const CoreQuestionDelegate = makeSingleton(CoreQuestionDelegateService);\n"],"mappings":";;AAgBA,SAASA,YAAY,QAA6B,mBAAmB;AAErE,SAASC,aAAa,QAAQ,aAAa;;;AAgM3C;;;AAIA,OAAM,MAAOC,2BAA4B,SAAQF,YAAiC;EAI9EG,YAAsBC,cAA0C;IAC5D,KAAK,CAAC,sBAAsB,EAAE,IAAI,CAAC;IADjB,KAAAA,cAAc,GAAdA,cAAc;IAF1B,KAAAC,mBAAmB,GAAG,MAAM;EAItC;EAEA;;;;;;;;EAQAC,uBAAuBA,CAACC,QAAoC,EAAEC,SAAiB;IAC3E,MAAMC,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IACvC,MAAMI,iBAAiB,GAAG,IAAI,CAACC,wBAAwB,CAASH,IAAI,EAAE,cAAc,EAAE,CAACF,QAAQ,EAAEC,SAAS,CAAC,CAAC;IAE5G,OAAOG,iBAAiB,IAAIH,SAAS;EACzC;EAEA;;;;;;EAMMK,uBAAuBA,CAACN,QAAoC;IAAA,IAAAO,KAAA;IAAA,OAAAC,iBAAA;MAC9D,MAAMN,IAAI,GAAGK,KAAI,CAACJ,WAAW,CAACH,QAAQ,CAAC;MAEvC,OAAOO,KAAI,CAACF,wBAAwB,CAACH,IAAI,EAAE,cAAc,EAAE,CAACF,QAAQ,CAAC,CAAC;IAAC;EAC3E;EAEA;;;;;;;EAOAS,uBAAuBA,CAACT,QAAoC;IACxD,MAAME,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAEvC,OAAO,IAAI,CAACK,wBAAwB,CAASH,IAAI,EAAE,yBAAyB,EAAE,CAACF,QAAQ,CAAC,CAAC;EAC7F;EAEA;;;;;;EAMUU,eAAeA,CAACR,IAAY;IAClC,OAAO,QAAQ,GAAGA,IAAI;EAC1B;EAEA;;;;;;EAMUC,WAAWA,CAACH,QAAoC;IACtD,OAAO,IAAI,CAACU,eAAe,CAACV,QAAQ,CAACE,IAAI,CAAC;EAC9C;EAEA;;;;;;;;;EASAS,kBAAkBA,CACdX,QAAoC,EACpCY,OAA6B,EAC7BC,SAAiB,EACjBC,WAA4B;IAE5B,MAAMZ,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAEvC,MAAMe,UAAU,GAAG,IAAI,CAACV,wBAAwB,CAC5CH,IAAI,EACJ,oBAAoB,EACpB,CAACF,QAAQ,EAAEY,OAAO,EAAEC,SAAS,EAAEC,WAAW,CAAC,CAC9C;IAED,OAAOC,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAI,CAAC,CAAC;EAC3B;EAEA;;;;;;;;;;EAUAC,kBAAkBA,CACdhB,QAAoC,EACpCY,OAA6B,EAC7BC,SAAiB,EACjBC,WAA4B;IAE5B,MAAMZ,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAEvC,MAAMiB,UAAU,GAAG,IAAI,CAACZ,wBAAwB,CAC5CH,IAAI,EACJ,oBAAoB,EACpB,CAACF,QAAQ,EAAEY,OAAO,EAAEC,SAAS,EAAEC,WAAW,CAAC,CAC9C;IAED,OAAOG,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAI,CAAC,CAAC;EAC3B;EAEA;;;;;;;;EAQAC,cAAcA,CACVlB,QAAoC,EACpCmB,WAAiC,EACjCC,UAAgC,EAChCP,SAAiB,EACjBC,WAA4B;IAE5B,MAAMZ,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAEvC,OAAO,CAAC,CAAC,IAAI,CAACK,wBAAwB,CAACH,IAAI,EAAE,gBAAgB,EAAE,CAACF,QAAQ,EAAEmB,WAAW,EAAEC,UAAU,EAAEP,SAAS,EAAEC,WAAW,CAAC,CAAC;EAC/H;EAEA;;;;;;EAMAO,mBAAmBA,CAACnB,IAAY;IAC5B,OAAO,IAAI,CAACoB,UAAU,CAAC,IAAI,CAACZ,eAAe,CAACR,IAAI,CAAC,EAAE,IAAI,CAAC;EAC5D;EAEA;;;;;;;;;;;EAWMqB,yBAAyBA,CAC3BvB,QAAoC,EACpCY,OAA6B,EAC7BY,OAAgB,EAChBX,SAAiB,EACjBC,WAA4B,EAC5BW,MAAe;IAAA,IAAAC,MAAA;IAAA,OAAAlB,iBAAA;MAEf,MAAMN,IAAI,GAAGwB,MAAI,CAACvB,WAAW,CAACH,QAAQ,CAAC;MAEvC,MAAM0B,MAAI,CAACrB,wBAAwB,CAC/BH,IAAI,EACJ,gBAAgB,EAChB,CAACF,QAAQ,EAAEY,OAAO,EAAEY,OAAO,EAAEX,SAAS,EAAEC,WAAW,EAAEW,MAAM,CAAC,CAC/D;IAAC;EACN;EAEA;;;;;;;EAOAE,qBAAqBA,CAAC3B,QAAoC,EAAE4B,oBAA4B;IACpF,MAAM1B,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAEvC,OAAO,CAAC,CAAC,IAAI,CAACK,wBAAwB,CAACH,IAAI,EAAE,uBAAuB,EAAE,CAACF,QAAQ,EAAE4B,oBAAoB,CAAC,CAAC;EAC3G;EAEA;;;;;;;EAOAC,8BAA8BA,CAAC7B,QAAoC,EAAE8B,OAAgB;IACjF,MAAM5B,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAEvC,OAAO,IAAI,CAACK,wBAAwB,CAACH,IAAI,EAAE,gCAAgC,EAAE,CAACF,QAAQ,EAAE8B,OAAO,CAAC,CAAC,IAAI,EAAE;EAC3G;EAEA;;;;;;;;EAQAC,YAAYA,CAAC/B,QAAoC,EAAEa,SAAiB,EAAEC,WAA4B;IAC9F,MAAMZ,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAEvC,OAAO,IAAI,CAACK,wBAAwB,CAACH,IAAI,EAAE,cAAc,EAAE,CAACF,QAAQ,EAAEa,SAAS,EAAEC,WAAW,CAAC,CAAC;EAClG;EAEA;;;;;;;;;EASMkB,iBAAiBA,CACnBhC,QAAoC,EACpCa,SAAiB,EACjBC,WAA4B,EAC5BW,MAAe;IAAA,IAAAQ,MAAA;IAAA,OAAAzB,iBAAA;MAEf,MAAMN,IAAI,GAAG+B,MAAI,CAAC9B,WAAW,CAACH,QAAQ,CAAC;MAEvC,MAAMiC,MAAI,CAAC5B,wBAAwB,CAACH,IAAI,EAAE,mBAAmB,EAAE,CAACF,QAAQ,EAAEa,SAAS,EAAEC,WAAW,EAAEW,MAAM,CAAC,CAAC;IAAC;EAC/G;EAEA;;;;;;;;;;EAUMS,eAAeA,CACjBlC,QAAoC,EACpCY,OAA6B,EAC7BC,SAAiB,EACjBC,WAA4B,EAC5BW,MAAe;IAAA,IAAAU,MAAA;IAAA,OAAA3B,iBAAA;MAEf,MAAMN,IAAI,GAAGiC,MAAI,CAAChC,WAAW,CAACH,QAAQ,CAAC;MAEvC,MAAMmC,MAAI,CAAC9B,wBAAwB,CAACH,IAAI,EAAE,iBAAiB,EAAE,CAACF,QAAQ,EAAEY,OAAO,EAAEC,SAAS,EAAEC,WAAW,EAAEW,MAAM,CAAC,CAAC;IAAC;EACtH;EAEA;;;;;;;;;;EAUAW,kBAAkBA,CACdpC,QAAoC,EACpCY,OAA6B,EAC7ByB,WAA+B,EAC/BxB,SAAiB,EACjBC,WAA4B;IAE5B,MAAMZ,IAAI,GAAG,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAEvC,OAAO,IAAI,CAACK,wBAAwB,CAACH,IAAI,EAAE,oBAAoB,EAAE,CAACF,QAAQ,EAAEY,OAAO,EAAEyB,WAAW,EAAExB,SAAS,EAAEC,WAAW,CAAC,CAAC;EAC9H;;SAzRSnB,2BAA4B;;mBAA5BA,MAA2B,EAAA2C,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,0BAAA;AAAA;;SAA3B9C,MAA2B;EAAA+C,OAAA,EAA3B/C,MAA2B,CAAAgD,IAAA;EAAAC,UAAA,EADd;AAAM;AA8RhC,OAAO,MAAMC,oBAAoB,GAAGnD,aAAa,CAACC,2BAA2B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}