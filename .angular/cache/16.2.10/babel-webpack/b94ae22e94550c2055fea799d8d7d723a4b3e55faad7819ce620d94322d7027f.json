{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport { QUESTION_ANSWERS_TABLE_NAME, QUESTION_TABLE_NAME } from './database/question';\nimport * as i0 from \"@angular/core\";\nconst QUESTION_PREFIX_REGEX = /q\\d+:(\\d+)_/;\nconst STATES = {\n  todo: {\n    name: 'todo',\n    class: 'core-question-notyetanswered',\n    status: 'notyetanswered',\n    active: true,\n    finished: false\n  },\n  invalid: {\n    name: 'invalid',\n    class: 'core-question-invalidanswer',\n    status: 'invalidanswer',\n    active: true,\n    finished: false\n  },\n  complete: {\n    name: 'complete',\n    class: 'core-question-answersaved',\n    status: 'answersaved',\n    active: true,\n    finished: false\n  },\n  needsgrading: {\n    name: 'needsgrading',\n    class: 'core-question-requiresgrading',\n    status: 'requiresgrading',\n    active: false,\n    finished: true\n  },\n  finished: {\n    name: 'finished',\n    class: 'core-question-complete',\n    status: 'complete',\n    active: false,\n    finished: true\n  },\n  gaveup: {\n    name: 'gaveup',\n    class: 'core-question-notanswered',\n    status: 'notanswered',\n    active: false,\n    finished: true\n  },\n  gradedwrong: {\n    name: 'gradedwrong',\n    class: 'core-question-incorrect',\n    status: 'incorrect',\n    active: false,\n    finished: true\n  },\n  gradedpartial: {\n    name: 'gradedpartial',\n    class: 'core-question-partiallycorrect',\n    status: 'partiallycorrect',\n    active: false,\n    finished: true\n  },\n  gradedright: {\n    name: 'gradedright',\n    class: 'core-question-correct',\n    status: 'correct',\n    active: false,\n    finished: true\n  },\n  mangrwrong: {\n    name: 'mangrwrong',\n    class: 'core-question-incorrect',\n    status: 'incorrect',\n    active: false,\n    finished: true\n  },\n  mangrpartial: {\n    name: 'mangrpartial',\n    class: 'core-question-partiallycorrect',\n    status: 'partiallycorrect',\n    active: false,\n    finished: true\n  },\n  mangrright: {\n    name: 'mangrright',\n    class: 'core-question-correct',\n    status: 'correct',\n    active: false,\n    finished: true\n  },\n  cannotdeterminestatus: {\n    name: 'cannotdeterminestatus',\n    class: 'core-question-unknown',\n    status: 'cannotdeterminestatus',\n    active: true,\n    finished: false\n  }\n};\n/**\n * Service to handle questions.\n */\nexport class CoreQuestionProvider {\n  /**\n   * Compare that all the answers in two objects are equal, except some extra data like sequencecheck or certainty.\n   *\n   * @param prevAnswers Object with previous answers.\n   * @param newAnswers Object with new answers.\n   * @returns Whether all answers are equal.\n   */\n  compareAllAnswers(prevAnswers, newAnswers) {\n    // Get all the keys.\n    const keys = CoreUtils.mergeArraysWithoutDuplicates(Object.keys(prevAnswers), Object.keys(newAnswers));\n    // Check that all the keys have the same value on both objects.\n    for (const i in keys) {\n      const key = keys[i];\n      // Ignore extra answers like sequencecheck or certainty.\n      if (!this.isExtraAnswer(key[0])) {\n        if (!CoreUtils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, key)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Convert a list of answers retrieved from local DB to an object with name - value.\n   *\n   * @param answers List of answers.\n   * @param removePrefix Whether to remove the prefix in the answer's name.\n   * @returns Object with name -> value.\n   */\n  convertAnswersArrayToObject(answers, removePrefix) {\n    const result = {};\n    answers.forEach(answer => {\n      if (removePrefix) {\n        const nameWithoutPrefix = this.removeQuestionPrefix(answer.name);\n        result[nameWithoutPrefix] = answer.value;\n      } else {\n        result[answer.name] = answer.value;\n      }\n    });\n    return result;\n  }\n  /**\n   * Retrieve an answer from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param name Answer's name.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the answer.\n   */\n  getAnswer(component, attemptId, name, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecord(QUESTION_ANSWERS_TABLE_NAME, {\n        component,\n        attemptid: attemptId,\n        name\n      });\n    })();\n  }\n  /**\n   * Retrieve an attempt answers from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the answers.\n   */\n  getAttemptAnswers(component, attemptId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecords(QUESTION_ANSWERS_TABLE_NAME, {\n        component,\n        attemptid: attemptId\n      });\n    })();\n  }\n  /**\n   * Retrieve an attempt questions from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the questions.\n   */\n  getAttemptQuestions(component, attemptId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecords(QUESTION_TABLE_NAME, {\n        component,\n        attemptid: attemptId\n      });\n    })();\n  }\n  /**\n   * Get all the answers that aren't \"extra\" (sequencecheck, certainty, ...).\n   *\n   * @param answers Object with all the answers.\n   * @returns Object with the basic answers.\n   */\n  getBasicAnswers(answers) {\n    const result = {};\n    for (const name in answers) {\n      if (!this.isExtraAnswer(name)) {\n        result[name] = answers[name];\n      }\n    }\n    return result;\n  }\n  /**\n   * Get all the answers that aren't \"extra\" (sequencecheck, certainty, ...).\n   *\n   * @param answers List of answers.\n   * @returns List with the basic answers.\n   */\n  getBasicAnswersFromArray(answers) {\n    const result = [];\n    answers.forEach(answer => {\n      if (this.isExtraAnswer(answer.name)) {\n        result.push(answer);\n      }\n    });\n    return result;\n  }\n  /**\n   * Retrieve a question from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param slot Question slot.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the question.\n   */\n  getQuestion(component, attemptId, slot, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.getDb().getRecord(QUESTION_TABLE_NAME, {\n        component,\n        attemptid: attemptId,\n        slot\n      });\n    })();\n  }\n  /**\n   * Retrieve a question answers from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param slot Question slot.\n   * @param filter Whether it should ignore \"extra\" answers like sequencecheck or certainty.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the answers.\n   */\n  getQuestionAnswers(component, attemptId, slot, filter, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      const answers = yield db.getRecords(QUESTION_ANSWERS_TABLE_NAME, {\n        component,\n        attemptid: attemptId,\n        questionslot: slot\n      });\n      if (filter) {\n        // Get only answers that isn't \"extra\" data like sequencecheck or certainty.\n        return _this.getBasicAnswersFromArray(answers);\n      } else {\n        return answers;\n      }\n    })();\n  }\n  /**\n   * Given a question and a componentId, return a componentId that is unique for the question.\n   *\n   * @param question Question.\n   * @param componentId Component ID.\n   * @returns Question component ID.\n   */\n  getQuestionComponentId(question, componentId) {\n    return componentId + '_' + question.questionnumber;\n  }\n  /**\n   * Get the path to the folder where to store files for an offline question.\n   *\n   * @param type Question type.\n   * @param component Component the question is related to.\n   * @param componentId Question component ID, returned by getQuestionComponentId.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Folder path.\n   */\n  getQuestionFolder(type, component, componentId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const siteFolderPath = CoreFile.getSiteFolder(siteId);\n    const questionFolderPath = 'offlinequestion/' + type + '/' + component + '/' + componentId;\n    return CorePath.concatenatePaths(siteFolderPath, questionFolderPath);\n  }\n  /**\n   * Extract the question slot from a question name.\n   *\n   * @param name Question name.\n   * @returns Question slot.\n   */\n  getQuestionSlotFromName(name) {\n    if (name) {\n      const match = name.match(QUESTION_PREFIX_REGEX);\n      if (match && match[1]) {\n        return parseInt(match[1], 10);\n      }\n    }\n    return -1;\n  }\n  /**\n   * Get question state based on state name.\n   *\n   * @param name State name.\n   * @returns State.\n   */\n  getState(name) {\n    return STATES[name || 'cannotdeterminestatus'];\n  }\n  /**\n   * Check if an answer is extra data like sequencecheck or certainty.\n   *\n   * @param name Answer name.\n   * @returns Whether it's extra data.\n   */\n  isExtraAnswer(name) {\n    // Maybe the name still has the prefix.\n    name = this.removeQuestionPrefix(name);\n    return name[0] == '-' || name[0] == ':';\n  }\n  /**\n   * Parse questions of a WS response.\n   *\n   * @param questions Questions to parse.\n   * @returns Parsed questions.\n   */\n  parseQuestions(questions) {\n    const parsedQuestions = questions;\n    parsedQuestions.forEach(question => {\n      if (question.questionnumber === undefined && typeof question.number === 'number') {\n        question.questionnumber = String(question.number);\n      }\n      if (!question.settings) {\n        return;\n      }\n      question.parsedSettings = CoreTextUtils.parseJSON(question.settings, null);\n    });\n    return parsedQuestions;\n  }\n  /**\n   * Remove an attempt answers from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  removeAttemptAnswers(component, attemptId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(QUESTION_ANSWERS_TABLE_NAME, {\n        component,\n        attemptid: attemptId\n      });\n    })();\n  }\n  /**\n   * Remove an attempt questions from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  removeAttemptQuestions(component, attemptId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(QUESTION_TABLE_NAME, {\n        component,\n        attemptid: attemptId\n      });\n    })();\n  }\n  /**\n   * Remove an answer from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param name Answer's name.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  removeAnswer(component, attemptId, name, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(QUESTION_ANSWERS_TABLE_NAME, {\n        component,\n        attemptid: attemptId,\n        name\n      });\n    })();\n  }\n  /**\n   * Remove a question from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param slot Question slot.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  removeQuestion(component, attemptId, slot, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(QUESTION_TABLE_NAME, {\n        component,\n        attemptid: attemptId,\n        slot\n      });\n    })();\n  }\n  /**\n   * Remove a question answers from site DB.\n   *\n   * @param component Component the attempt belongs to.\n   * @param attemptId Attempt ID.\n   * @param slot Question slot.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  removeQuestionAnswers(component, attemptId, slot, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.getDb().deleteRecords(QUESTION_ANSWERS_TABLE_NAME, {\n        component,\n        attemptid: attemptId,\n        questionslot: slot\n      });\n    })();\n  }\n  /**\n   * Remove the prefix from a question answer name.\n   *\n   * @param name Question name.\n   * @returns Name without prefix.\n   */\n  removeQuestionPrefix(name) {\n    if (name) {\n      return name.replace(QUESTION_PREFIX_REGEX, '');\n    }\n    return '';\n  }\n  /**\n   * Save answers in local DB.\n   *\n   * @param component Component the answers belong to. E.g. 'mmaModQuiz'.\n   * @param componentId ID of the component the answers belong to.\n   * @param attemptId Attempt ID.\n   * @param userId User ID.\n   * @param answers Object with the answers to save.\n   * @param timemodified Time modified to set in the answers. If not defined, current time.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  saveAnswers(component, componentId, attemptId, userId, answers, timemodified, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      timemodified = timemodified || CoreTimeUtils.timestamp();\n      const db = yield CoreSites.getSiteDb(siteId);\n      const promises = [];\n      for (const name in answers) {\n        const entry = {\n          component,\n          componentid: componentId,\n          attemptid: attemptId,\n          userid: userId,\n          questionslot: _this2.getQuestionSlotFromName(name),\n          name,\n          value: String(answers[name]),\n          timemodified\n        };\n        promises.push(db.insertRecord(QUESTION_ANSWERS_TABLE_NAME, entry));\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Save a question in local DB.\n   *\n   * @param component Component the question belongs to. E.g. 'mmaModQuiz'.\n   * @param componentId ID of the component the question belongs to.\n   * @param attemptId Attempt ID.\n   * @param userId User ID.\n   * @param question The question to save.\n   * @param state Question's state.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  saveQuestion(component, componentId, attemptId, userId, question, state, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const entry = {\n        component,\n        componentid: componentId,\n        attemptid: attemptId,\n        slot: question.slot,\n        state: state\n      };\n      yield site.getDb().insertRecord(QUESTION_TABLE_NAME, entry);\n    })();\n  }\n}\n_class = CoreQuestionProvider;\n_class.COMPONENT = 'mmQuestion';\n_class.ɵfac = function CoreQuestionProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreQuestion = makeSingleton(CoreQuestionProvider);","map":{"version":3,"names":["CoreFile","CoreSites","CoreTextUtils","CoreTimeUtils","CoreUtils","makeSingleton","CorePath","QUESTION_ANSWERS_TABLE_NAME","QUESTION_TABLE_NAME","QUESTION_PREFIX_REGEX","STATES","todo","name","class","status","active","finished","invalid","complete","needsgrading","gaveup","gradedwrong","gradedpartial","gradedright","mangrwrong","mangrpartial","mangrright","cannotdeterminestatus","CoreQuestionProvider","compareAllAnswers","prevAnswers","newAnswers","keys","mergeArraysWithoutDuplicates","Object","i","key","isExtraAnswer","sameAtKeyMissingIsBlank","convertAnswersArrayToObject","answers","removePrefix","result","forEach","answer","nameWithoutPrefix","removeQuestionPrefix","value","getAnswer","component","attemptId","siteId","_asyncToGenerator","site","getSite","getDb","getRecord","attemptid","getAttemptAnswers","getRecords","getAttemptQuestions","getBasicAnswers","getBasicAnswersFromArray","push","getQuestion","slot","getQuestionAnswers","filter","_this","db","getSiteDb","questionslot","getQuestionComponentId","question","componentId","questionnumber","getQuestionFolder","type","getCurrentSiteId","siteFolderPath","getSiteFolder","questionFolderPath","concatenatePaths","getQuestionSlotFromName","match","parseInt","getState","parseQuestions","questions","parsedQuestions","undefined","number","String","settings","parsedSettings","parseJSON","removeAttemptAnswers","deleteRecords","removeAttemptQuestions","removeAnswer","removeQuestion","removeQuestionAnswers","replace","saveAnswers","userId","timemodified","_this2","timestamp","promises","entry","componentid","userid","insertRecord","Promise","all","saveQuestion","state","_class","COMPONENT","factory","ɵfac","providedIn","CoreQuestion"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/question/services/question.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreFile } from '@services/file';\nimport { CoreSites } from '@services/sites';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalFile } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { CorePath } from '@singletons/path';\nimport {\n    CoreQuestionAnswerDBRecord,\n    CoreQuestionDBRecord,\n    QUESTION_ANSWERS_TABLE_NAME,\n    QUESTION_TABLE_NAME,\n} from './database/question';\n\nconst QUESTION_PREFIX_REGEX = /q\\d+:(\\d+)_/;\nconst STATES: Record<string, CoreQuestionState> = {\n    todo: {\n        name: 'todo',\n        class: 'core-question-notyetanswered',\n        status: 'notyetanswered',\n        active: true,\n        finished: false,\n    },\n    invalid: {\n        name: 'invalid',\n        class: 'core-question-invalidanswer',\n        status: 'invalidanswer',\n        active: true,\n        finished: false,\n    },\n    complete: {\n        name: 'complete',\n        class: 'core-question-answersaved',\n        status: 'answersaved',\n        active: true,\n        finished: false,\n    },\n    needsgrading: {\n        name: 'needsgrading',\n        class: 'core-question-requiresgrading',\n        status: 'requiresgrading',\n        active: false,\n        finished: true,\n    },\n    finished: {\n        name: 'finished',\n        class: 'core-question-complete',\n        status: 'complete',\n        active: false,\n        finished: true,\n    },\n    gaveup: {\n        name: 'gaveup',\n        class: 'core-question-notanswered',\n        status: 'notanswered',\n        active: false,\n        finished: true,\n    },\n    gradedwrong: {\n        name: 'gradedwrong',\n        class: 'core-question-incorrect',\n        status: 'incorrect',\n        active: false,\n        finished: true,\n    },\n    gradedpartial: {\n        name: 'gradedpartial',\n        class: 'core-question-partiallycorrect',\n        status: 'partiallycorrect',\n        active: false,\n        finished: true,\n    },\n    gradedright: {\n        name: 'gradedright',\n        class: 'core-question-correct',\n        status: 'correct',\n        active: false,\n        finished: true,\n    },\n    mangrwrong: {\n        name: 'mangrwrong',\n        class: 'core-question-incorrect',\n        status: 'incorrect',\n        active: false,\n        finished: true,\n    },\n    mangrpartial: {\n        name: 'mangrpartial',\n        class: 'core-question-partiallycorrect',\n        status: 'partiallycorrect',\n        active: false,\n        finished: true,\n    },\n    mangrright: {\n        name: 'mangrright',\n        class: 'core-question-correct',\n        status: 'correct',\n        active: false,\n        finished: true,\n    },\n    cannotdeterminestatus: { // Special state for Mobile, sometimes we won't have enough data to detemrine the state.\n        name: 'cannotdeterminestatus',\n        class: 'core-question-unknown',\n        status: 'cannotdeterminestatus',\n        active: true,\n        finished: false,\n    },\n};\n\n/**\n * Service to handle questions.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreQuestionProvider {\n\n    static readonly COMPONENT = 'mmQuestion';\n\n    /**\n     * Compare that all the answers in two objects are equal, except some extra data like sequencecheck or certainty.\n     *\n     * @param prevAnswers Object with previous answers.\n     * @param newAnswers Object with new answers.\n     * @returns Whether all answers are equal.\n     */\n    compareAllAnswers(prevAnswers: Record<string, unknown>, newAnswers: Record<string, unknown>): boolean {\n        // Get all the keys.\n        const keys = CoreUtils.mergeArraysWithoutDuplicates(Object.keys(prevAnswers), Object.keys(newAnswers));\n\n        // Check that all the keys have the same value on both objects.\n        for (const i in keys) {\n            const key = keys[i];\n\n            // Ignore extra answers like sequencecheck or certainty.\n            if (!this.isExtraAnswer(key[0])) {\n                if (!CoreUtils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, key)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Convert a list of answers retrieved from local DB to an object with name - value.\n     *\n     * @param answers List of answers.\n     * @param removePrefix Whether to remove the prefix in the answer's name.\n     * @returns Object with name -> value.\n     */\n    convertAnswersArrayToObject(answers: CoreQuestionAnswerDBRecord[], removePrefix?: boolean): Record<string, string> {\n        const result: Record<string, string> = {};\n\n        answers.forEach((answer) => {\n            if (removePrefix) {\n                const nameWithoutPrefix = this.removeQuestionPrefix(answer.name);\n                result[nameWithoutPrefix] = answer.value;\n            } else {\n                result[answer.name] = answer.value;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Retrieve an answer from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param name Answer's name.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the answer.\n     */\n    async getAnswer(component: string, attemptId: number, name: string, siteId?: string): Promise<CoreQuestionAnswerDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecord(QUESTION_ANSWERS_TABLE_NAME, { component, attemptid: attemptId, name });\n    }\n\n    /**\n     * Retrieve an attempt answers from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the answers.\n     */\n    async getAttemptAnswers(component: string, attemptId: number, siteId?: string): Promise<CoreQuestionAnswerDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecords(QUESTION_ANSWERS_TABLE_NAME, { component, attemptid: attemptId });\n    }\n\n    /**\n     * Retrieve an attempt questions from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the questions.\n     */\n    async getAttemptQuestions(component: string, attemptId: number, siteId?: string): Promise<CoreQuestionDBRecord[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecords(QUESTION_TABLE_NAME, { component, attemptid: attemptId });\n    }\n\n    /**\n     * Get all the answers that aren't \"extra\" (sequencecheck, certainty, ...).\n     *\n     * @param answers Object with all the answers.\n     * @returns Object with the basic answers.\n     */\n    getBasicAnswers<T = string>(answers: Record<string, T>): Record<string, T> {\n        const result: Record<string, T> = {};\n\n        for (const name in answers) {\n            if (!this.isExtraAnswer(name)) {\n                result[name] = answers[name];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get all the answers that aren't \"extra\" (sequencecheck, certainty, ...).\n     *\n     * @param answers List of answers.\n     * @returns List with the basic answers.\n     */\n    protected getBasicAnswersFromArray(answers: CoreQuestionAnswerDBRecord[]): CoreQuestionAnswerDBRecord[] {\n        const result: CoreQuestionAnswerDBRecord[] = [];\n\n        answers.forEach((answer) => {\n            if (this.isExtraAnswer(answer.name)) {\n                result.push(answer);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Retrieve a question from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param slot Question slot.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the question.\n     */\n    async getQuestion(component: string, attemptId: number, slot: number, siteId?: string): Promise<CoreQuestionDBRecord> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.getDb().getRecord(QUESTION_TABLE_NAME, { component, attemptid: attemptId, slot });\n    }\n\n    /**\n     * Retrieve a question answers from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param slot Question slot.\n     * @param filter Whether it should ignore \"extra\" answers like sequencecheck or certainty.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the answers.\n     */\n    async getQuestionAnswers(\n        component: string,\n        attemptId: number,\n        slot: number,\n        filter?: boolean,\n        siteId?: string,\n    ): Promise<CoreQuestionAnswerDBRecord[]> {\n        const db = await CoreSites.getSiteDb(siteId);\n\n        const answers = await db.getRecords<CoreQuestionAnswerDBRecord>(\n            QUESTION_ANSWERS_TABLE_NAME,\n            { component, attemptid: attemptId, questionslot: slot },\n        );\n\n        if (filter) {\n            // Get only answers that isn't \"extra\" data like sequencecheck or certainty.\n            return this.getBasicAnswersFromArray(answers);\n        } else {\n            return answers;\n        }\n    }\n\n    /**\n     * Given a question and a componentId, return a componentId that is unique for the question.\n     *\n     * @param question Question.\n     * @param componentId Component ID.\n     * @returns Question component ID.\n     */\n    getQuestionComponentId(question: CoreQuestionQuestionParsed, componentId: string | number): string {\n        return componentId + '_' + question.questionnumber;\n    }\n\n    /**\n     * Get the path to the folder where to store files for an offline question.\n     *\n     * @param type Question type.\n     * @param component Component the question is related to.\n     * @param componentId Question component ID, returned by getQuestionComponentId.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Folder path.\n     */\n    getQuestionFolder(type: string, component: string, componentId: string, siteId?: string): string {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const siteFolderPath = CoreFile.getSiteFolder(siteId);\n        const questionFolderPath = 'offlinequestion/' + type + '/' + component + '/' + componentId;\n\n        return CorePath.concatenatePaths(siteFolderPath, questionFolderPath);\n    }\n\n    /**\n     * Extract the question slot from a question name.\n     *\n     * @param name Question name.\n     * @returns Question slot.\n     */\n    getQuestionSlotFromName(name: string): number {\n        if (name) {\n            const match = name.match(QUESTION_PREFIX_REGEX);\n            if (match && match[1]) {\n                return parseInt(match[1], 10);\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Get question state based on state name.\n     *\n     * @param name State name.\n     * @returns State.\n     */\n    getState(name?: string): CoreQuestionState {\n        return STATES[name || 'cannotdeterminestatus'];\n    }\n\n    /**\n     * Check if an answer is extra data like sequencecheck or certainty.\n     *\n     * @param name Answer name.\n     * @returns Whether it's extra data.\n     */\n    isExtraAnswer(name: string): boolean {\n        // Maybe the name still has the prefix.\n        name = this.removeQuestionPrefix(name);\n\n        return name[0] == '-' || name[0] == ':';\n    }\n\n    /**\n     * Parse questions of a WS response.\n     *\n     * @param questions Questions to parse.\n     * @returns Parsed questions.\n     */\n    parseQuestions(questions: CoreQuestionQuestionWSData[]): CoreQuestionQuestionParsed[] {\n        const parsedQuestions: CoreQuestionQuestionParsed[] = questions;\n\n        parsedQuestions.forEach((question) => {\n            if (question.questionnumber === undefined && typeof question.number === 'number') {\n                question.questionnumber = String(question.number);\n            }\n\n            if (!question.settings) {\n                return;\n            }\n\n            question.parsedSettings = CoreTextUtils.parseJSON(question.settings, null);\n        });\n\n        return parsedQuestions;\n    }\n\n    /**\n     * Remove an attempt answers from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async removeAttemptAnswers(component: string, attemptId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(QUESTION_ANSWERS_TABLE_NAME, { component, attemptid: attemptId });\n    }\n\n    /**\n     * Remove an attempt questions from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async removeAttemptQuestions(component: string, attemptId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(QUESTION_TABLE_NAME, { component, attemptid: attemptId });\n    }\n\n    /**\n     * Remove an answer from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param name Answer's name.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async removeAnswer(component: string, attemptId: number, name: string, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(QUESTION_ANSWERS_TABLE_NAME, { component, attemptid: attemptId, name });\n    }\n\n    /**\n     * Remove a question from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param slot Question slot.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async removeQuestion(component: string, attemptId: number, slot: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(QUESTION_TABLE_NAME, { component, attemptid: attemptId, slot });\n    }\n\n    /**\n     * Remove a question answers from site DB.\n     *\n     * @param component Component the attempt belongs to.\n     * @param attemptId Attempt ID.\n     * @param slot Question slot.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async removeQuestionAnswers(component: string, attemptId: number, slot: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.getDb().deleteRecords(QUESTION_ANSWERS_TABLE_NAME, { component, attemptid: attemptId, questionslot: slot });\n    }\n\n    /**\n     * Remove the prefix from a question answer name.\n     *\n     * @param name Question name.\n     * @returns Name without prefix.\n     */\n    removeQuestionPrefix(name: string): string {\n        if (name) {\n            return name.replace(QUESTION_PREFIX_REGEX, '');\n        }\n\n        return '';\n    }\n\n    /**\n     * Save answers in local DB.\n     *\n     * @param component Component the answers belong to. E.g. 'mmaModQuiz'.\n     * @param componentId ID of the component the answers belong to.\n     * @param attemptId Attempt ID.\n     * @param userId User ID.\n     * @param answers Object with the answers to save.\n     * @param timemodified Time modified to set in the answers. If not defined, current time.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async saveAnswers(\n        component: string,\n        componentId: number,\n        attemptId: number,\n        userId: number,\n        answers: CoreQuestionsAnswers,\n        timemodified?: number,\n        siteId?: string,\n    ): Promise<void> {\n        timemodified = timemodified || CoreTimeUtils.timestamp();\n\n        const db = await CoreSites.getSiteDb(siteId);\n        const promises: Promise<unknown>[] = [];\n\n        for (const name in answers) {\n            const entry: CoreQuestionAnswerDBRecord = {\n                component,\n                componentid: componentId,\n                attemptid: attemptId,\n                userid: userId,\n                questionslot: this.getQuestionSlotFromName(name),\n                name,\n                value: String(answers[name]),\n                timemodified,\n            };\n\n            promises.push(db.insertRecord(QUESTION_ANSWERS_TABLE_NAME, entry));\n        }\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Save a question in local DB.\n     *\n     * @param component Component the question belongs to. E.g. 'mmaModQuiz'.\n     * @param componentId ID of the component the question belongs to.\n     * @param attemptId Attempt ID.\n     * @param userId User ID.\n     * @param question The question to save.\n     * @param state Question's state.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async saveQuestion(\n        component: string,\n        componentId: number,\n        attemptId: number,\n        userId: number,\n        question: CoreQuestionQuestionParsed,\n        state: string,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const entry: CoreQuestionDBRecord = {\n            component,\n            componentid: componentId,\n            attemptid: attemptId,\n            slot: question.slot,\n            state: state,\n        };\n\n        await site.getDb().insertRecord(QUESTION_TABLE_NAME, entry);\n    }\n\n}\n\nexport const CoreQuestion = makeSingleton(CoreQuestionProvider);\n\n/**\n * Question state.\n */\nexport type CoreQuestionState = {\n    name: string; // Name of the state.\n    class: string; // Class to style the state.\n    status: string; // The string key to translate the state.\n    active: boolean; // Whether the question with this state is active.\n    finished: boolean; // Whether the question with this state is finished.\n};\n\n/**\n * Data returned by WS for a question.\n * Currently this specification is based on quiz WS because they're the only ones returning questions.\n */\nexport type CoreQuestionQuestionWSData = {\n    slot: number; // Slot number.\n    type: string; // Question type, i.e: multichoice.\n    page: number; // Page of the quiz this question appears on.\n    html: string; // The question rendered.\n    responsefileareas?: { // Response file areas including files.\n        area: string; // File area name.\n        files?: CoreWSExternalFile[];\n    }[];\n    sequencecheck?: number; // The number of real steps in this attempt.\n    lastactiontime?: number; // The timestamp of the most recent step in this question attempt.\n    hasautosavedstep?: boolean; // Whether this question attempt has autosaved data.\n    flagged: boolean; // Whether the question is flagged or not.\n    questionnumber?: string; // @since 4.2. Question ordering number in the quiz.\n    state?: string; // The state where the question is in. It won't be returned if the user cannot see it.\n    status?: string; // Current formatted state of the question.\n    blockedbyprevious?: boolean; // Whether the question is blocked by the previous question.\n    mark?: string; // The mark awarded. It will be returned only if the user is allowed to see it.\n    maxmark?: number; // The maximum mark possible for this question attempt.\n    settings?: string; // Question settings (JSON encoded).\n\n    /** @deprecatedonmoodle since 4.2. Use questionnumber instead. */\n    number?: number; // eslint-disable-line id-blacklist\n};\n/**\n * Question data with parsed data.\n */\nexport type CoreQuestionQuestionParsed = CoreQuestionQuestionWSData & {\n    parsedSettings?: Record<string, unknown> | null;\n};\n\n/**\n * List of answers to a set of questions.\n */\nexport type CoreQuestionsAnswers = Record<string, string | boolean>;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}