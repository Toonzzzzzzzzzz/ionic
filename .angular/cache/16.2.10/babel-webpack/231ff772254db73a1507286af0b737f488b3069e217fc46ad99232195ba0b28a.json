{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreQuestion } from '@features/question/services/question';\nimport { CoreQuestionHelper } from '@features/question/services/question-helper';\nimport { makeSingleton } from '@singletons';\nimport { AddonQtypeMultiAnswerComponent } from '../../component/multianswer';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to support multianswer question type.\n */\nexport class AddonQtypeMultiAnswerHandlerService {\n  constructor() {\n    this.name = 'AddonQtypeMultiAnswer';\n    this.type = 'qtype_multianswer';\n  }\n  /**\n   * @inheritdoc\n   */\n  getBehaviour(question, behaviour) {\n    if (behaviour === 'interactive') {\n      return 'interactivecountback';\n    }\n    return behaviour;\n  }\n  /**\n   * @inheritdoc\n   */\n  getComponent() {\n    return AddonQtypeMultiAnswerComponent;\n  }\n  /**\n   * @inheritdoc\n   */\n  isCompleteResponse(question, answers) {\n    // Get all the inputs in the question to check if they've all been answered.\n    const names = CoreQuestion.getBasicAnswers(CoreQuestionHelper.getAllInputNamesFromHtml(question.html || ''));\n    for (const name in names) {\n      const value = answers[name];\n      if (!value) {\n        return 0;\n      }\n    }\n    return 1;\n  }\n  /**\n   * @inheritdoc\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  isGradableResponse(question, answers) {\n    // We should always get a value for each select so we can assume we receive all the possible answers.\n    for (const name in answers) {\n      const value = answers[name];\n      if (value || value === false) {\n        return 1;\n      }\n    }\n    return 0;\n  }\n  /**\n   * @inheritdoc\n   */\n  isSameResponse(question, prevAnswers, newAnswers) {\n    return CoreQuestion.compareAllAnswers(prevAnswers, newAnswers);\n  }\n  /**\n   * @inheritdoc\n   */\n  validateSequenceCheck(question, offlineSequenceCheck) {\n    if (question.sequencecheck == Number(offlineSequenceCheck)) {\n      return true;\n    }\n    // For some reason, viewing a multianswer for the first time without answering it creates a new step \"todo\".\n    // We'll treat this case as valid.\n    if (question.sequencecheck == 2 && question.state == 'todo' && offlineSequenceCheck == '1') {\n      return true;\n    }\n    return false;\n  }\n}\n_class = AddonQtypeMultiAnswerHandlerService;\n_class.ɵfac = function AddonQtypeMultiAnswerHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonQtypeMultiAnswerHandler = makeSingleton(AddonQtypeMultiAnswerHandlerService);","map":{"version":3,"names":["CoreQuestion","CoreQuestionHelper","makeSingleton","AddonQtypeMultiAnswerComponent","AddonQtypeMultiAnswerHandlerService","constructor","name","type","getBehaviour","question","behaviour","getComponent","isCompleteResponse","answers","names","getBasicAnswers","getAllInputNamesFromHtml","html","value","isEnabled","_asyncToGenerator","isGradableResponse","isSameResponse","prevAnswers","newAnswers","compareAllAnswers","validateSequenceCheck","offlineSequenceCheck","sequencecheck","Number","state","factory","ɵfac","providedIn","AddonQtypeMultiAnswerHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/qtype/multianswer/services/handlers/multianswer.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\n\nimport { CoreQuestion, CoreQuestionQuestionParsed, CoreQuestionsAnswers } from '@features/question/services/question';\nimport { CoreQuestionHandler } from '@features/question/services/question-delegate';\nimport { CoreQuestionHelper } from '@features/question/services/question-helper';\nimport { makeSingleton } from '@singletons';\nimport { AddonQtypeMultiAnswerComponent } from '../../component/multianswer';\n\n/**\n * Handler to support multianswer question type.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonQtypeMultiAnswerHandlerService implements CoreQuestionHandler {\n\n    name = 'AddonQtypeMultiAnswer';\n    type = 'qtype_multianswer';\n\n    /**\n     * @inheritdoc\n     */\n    getBehaviour(question: CoreQuestionQuestionParsed, behaviour: string): string {\n        if (behaviour === 'interactive') {\n            return 'interactivecountback';\n        }\n\n        return behaviour;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getComponent(): Type<unknown> {\n        return AddonQtypeMultiAnswerComponent;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isCompleteResponse(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n    ): number {\n        // Get all the inputs in the question to check if they've all been answered.\n        const names = CoreQuestion.getBasicAnswers<boolean>(\n            CoreQuestionHelper.getAllInputNamesFromHtml(question.html || ''),\n        );\n        for (const name in names) {\n            const value = answers[name];\n            if (!value) {\n                return 0;\n            }\n        }\n\n        return 1;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isGradableResponse(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n    ): number {\n        // We should always get a value for each select so we can assume we receive all the possible answers.\n        for (const name in answers) {\n            const value = answers[name];\n            if (value || value === false) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isSameResponse(\n        question: CoreQuestionQuestionParsed,\n        prevAnswers: CoreQuestionsAnswers,\n        newAnswers: CoreQuestionsAnswers,\n    ): boolean {\n        return CoreQuestion.compareAllAnswers(prevAnswers, newAnswers);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    validateSequenceCheck(question: CoreQuestionQuestionParsed, offlineSequenceCheck: string): boolean {\n        if (question.sequencecheck == Number(offlineSequenceCheck)) {\n            return true;\n        }\n\n        // For some reason, viewing a multianswer for the first time without answering it creates a new step \"todo\".\n        // We'll treat this case as valid.\n        if (question.sequencecheck == 2 && question.state == 'todo' && offlineSequenceCheck == '1') {\n            return true;\n        }\n\n        return false;\n    }\n\n}\n\nexport const AddonQtypeMultiAnswerHandler = makeSingleton(AddonQtypeMultiAnswerHandlerService);\n"],"mappings":";;AAgBA,SAASA,YAAY,QAA0D,sCAAsC;AAErH,SAASC,kBAAkB,QAAQ,6CAA6C;AAChF,SAASC,aAAa,QAAQ,aAAa;AAC3C,SAASC,8BAA8B,QAAQ,6BAA6B;;AAE5E;;;AAIA,OAAM,MAAOC,mCAAmC;EADhDC,YAAA;IAGI,KAAAC,IAAI,GAAG,uBAAuB;IAC9B,KAAAC,IAAI,GAAG,mBAAmB;;EAE1B;;;EAGAC,YAAYA,CAACC,QAAoC,EAAEC,SAAiB;IAChE,IAAIA,SAAS,KAAK,aAAa,EAAE;MAC7B,OAAO,sBAAsB;;IAGjC,OAAOA,SAAS;EACpB;EAEA;;;EAGAC,YAAYA,CAAA;IACR,OAAOR,8BAA8B;EACzC;EAEA;;;EAGAS,kBAAkBA,CACdH,QAAoC,EACpCI,OAA6B;IAE7B;IACA,MAAMC,KAAK,GAAGd,YAAY,CAACe,eAAe,CACtCd,kBAAkB,CAACe,wBAAwB,CAACP,QAAQ,CAACQ,IAAI,IAAI,EAAE,CAAC,CACnE;IACD,KAAK,MAAMX,IAAI,IAAIQ,KAAK,EAAE;MACtB,MAAMI,KAAK,GAAGL,OAAO,CAACP,IAAI,CAAC;MAC3B,IAAI,CAACY,KAAK,EAAE;QACR,OAAO,CAAC;;;IAIhB,OAAO,CAAC;EACZ;EAEA;;;EAGMC,SAASA,CAAA;IAAA,OAAAC,iBAAA;MACX,OAAO,IAAI;IAAC;EAChB;EAEA;;;EAGAC,kBAAkBA,CACdZ,QAAoC,EACpCI,OAA6B;IAE7B;IACA,KAAK,MAAMP,IAAI,IAAIO,OAAO,EAAE;MACxB,MAAMK,KAAK,GAAGL,OAAO,CAACP,IAAI,CAAC;MAC3B,IAAIY,KAAK,IAAIA,KAAK,KAAK,KAAK,EAAE;QAC1B,OAAO,CAAC;;;IAIhB,OAAO,CAAC;EACZ;EAEA;;;EAGAI,cAAcA,CACVb,QAAoC,EACpCc,WAAiC,EACjCC,UAAgC;IAEhC,OAAOxB,YAAY,CAACyB,iBAAiB,CAACF,WAAW,EAAEC,UAAU,CAAC;EAClE;EAEA;;;EAGAE,qBAAqBA,CAACjB,QAAoC,EAAEkB,oBAA4B;IACpF,IAAIlB,QAAQ,CAACmB,aAAa,IAAIC,MAAM,CAACF,oBAAoB,CAAC,EAAE;MACxD,OAAO,IAAI;;IAGf;IACA;IACA,IAAIlB,QAAQ,CAACmB,aAAa,IAAI,CAAC,IAAInB,QAAQ,CAACqB,KAAK,IAAI,MAAM,IAAIH,oBAAoB,IAAI,GAAG,EAAE;MACxF,OAAO,IAAI;;IAGf,OAAO,KAAK;EAChB;;SA/FSvB,mCAAmC;;mBAAnCA,MAAmC;AAAA;;SAAnCA,MAAmC;EAAA2B,OAAA,EAAnC3B,MAAmC,CAAA4B,IAAA;EAAAC,UAAA,EADtB;AAAM;AAoGhC,OAAO,MAAMC,4BAA4B,GAAGhC,aAAa,CAACE,mCAAmC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}