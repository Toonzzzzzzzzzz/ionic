{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { DRAFT_TABLE } from './database/editor';\nimport * as i0 from \"@angular/core\";\n/**\n * Service with features regarding rich text editor in offline.\n */\nexport class CoreEditorOfflineProvider {\n  constructor() {\n    this.logger = CoreLogger.getInstance('CoreEditorOfflineProvider');\n  }\n  /**\n   * Delete a draft from DB.\n   *\n   * @param contextLevel Context level.\n   * @param contextInstanceId The instance ID related to the context.\n   * @param elementId Element ID.\n   * @param extraParams Object with extra params to identify the draft.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  deleteDraft(contextLevel, contextInstanceId, elementId, extraParams, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const db = yield CoreSites.getSiteDb(siteId);\n        const params = _this.fixDraftPrimaryData(contextLevel, contextInstanceId, elementId, extraParams);\n        yield db.deleteRecords(DRAFT_TABLE, params);\n      } catch (_unused) {\n        // Ignore errors, probably no draft stored.\n      }\n    })();\n  }\n  /**\n   * Return an object with the draft primary data converted to the right format.\n   *\n   * @param contextLevel Context level.\n   * @param contextInstanceId The instance ID related to the context.\n   * @param elementId Element ID.\n   * @param extraParams Object with extra params to identify the draft.\n   * @returns Object with the fixed primary data.\n   */\n  fixDraftPrimaryData(contextLevel, contextInstanceId, elementId, extraParams) {\n    return {\n      contextlevel: contextLevel,\n      contextinstanceid: contextInstanceId,\n      elementid: elementId,\n      extraparams: CoreUtils.sortAndStringify(extraParams || {})\n    };\n  }\n  /**\n   * Get a draft from DB.\n   *\n   * @param contextLevel Context level.\n   * @param contextInstanceId The instance ID related to the context.\n   * @param elementId Element ID.\n   * @param extraParams Object with extra params to identify the draft.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the draft data. Undefined if no draft stored.\n   */\n  getDraft(contextLevel, contextInstanceId, elementId, extraParams, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const db = yield CoreSites.getSiteDb(siteId);\n      const params = _this2.fixDraftPrimaryData(contextLevel, contextInstanceId, elementId, extraParams);\n      return db.getRecord(DRAFT_TABLE, params);\n    })();\n  }\n  /**\n   * Get draft to resume it.\n   *\n   * @param contextLevel Context level.\n   * @param contextInstanceId The instance ID related to the context.\n   * @param elementId Element ID.\n   * @param extraParams Object with extra params to identify the draft.\n   * @param pageInstance Unique identifier to prevent storing data from several sources at the same time.\n   * @param originalContent Original content of the editor.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the draft data. Undefined if no draft stored.\n   */\n  resumeDraft(contextLevel, contextInstanceId, elementId, extraParams, pageInstance, originalContent, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // Check if there is a draft stored.\n        const entry = yield _this3.getDraft(contextLevel, contextInstanceId, elementId, extraParams, siteId);\n        // There is a draft stored. Update its page instance.\n        try {\n          const db = yield CoreSites.getSiteDb(siteId);\n          entry.pageinstance = pageInstance;\n          entry.timemodified = Date.now();\n          if (originalContent && entry.originalcontent != originalContent) {\n            entry.originalcontent = originalContent;\n            entry.drafttext = ''; // \"Discard\" the draft.\n          }\n\n          yield db.insertRecord(DRAFT_TABLE, entry);\n        } catch (_unused2) {\n          // Ignore errors saving the draft. It shouldn't happen.\n        }\n        return entry;\n      } catch (_unused3) {\n        // No draft stored. Store an empty draft to save the pageinstance.\n        yield _this3.saveDraft(contextLevel, contextInstanceId, elementId, extraParams, pageInstance, '', originalContent, siteId);\n      }\n    })();\n  }\n  /**\n   * Save a draft in DB.\n   *\n   * @param contextLevel Context level.\n   * @param contextInstanceId The instance ID related to the context.\n   * @param elementId Element ID.\n   * @param extraParams Object with extra params to identify the draft.\n   * @param pageInstance Unique identifier to prevent storing data from several sources at the same time.\n   * @param draftText The text to store.\n   * @param originalContent Original content of the editor.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  saveDraft(contextLevel, contextInstanceId, elementId, extraParams, pageInstance, draftText, originalContent, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let timecreated = Date.now();\n      let entry;\n      // Check if there is a draft already stored.\n      try {\n        entry = yield _this4.getDraft(contextLevel, contextInstanceId, elementId, extraParams, siteId);\n        timecreated = entry.timecreated || timecreated;\n      } catch (error) {\n        // No draft already stored.\n      }\n      if (entry) {\n        if (entry.pageinstance != pageInstance) {\n          _this4.logger.warn(`Discarding draft because of pageinstance. Context '${contextLevel}' '${contextInstanceId}', ` + `element '${elementId}'`);\n          throw new CoreError('Draft was discarded because it was modified in another page.');\n        }\n        if (!originalContent) {\n          // Original content not set, use the one in the entry.\n          originalContent = entry.originalcontent;\n        }\n      }\n      const db = yield CoreSites.getSiteDb(siteId);\n      const data = _this4.fixDraftPrimaryData(contextLevel, contextInstanceId, elementId, extraParams);\n      data.drafttext = (draftText || '').trim();\n      data.pageinstance = pageInstance;\n      data.timecreated = timecreated;\n      data.timemodified = Date.now();\n      if (originalContent) {\n        data.originalcontent = originalContent;\n      }\n      yield db.insertRecord(DRAFT_TABLE, data);\n    })();\n  }\n}\n_class = CoreEditorOfflineProvider;\n_class.ɵfac = function CoreEditorOfflineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreEditorOffline = makeSingleton(CoreEditorOfflineProvider);","map":{"version":3,"names":["CoreError","CoreSites","CoreUtils","makeSingleton","CoreLogger","DRAFT_TABLE","CoreEditorOfflineProvider","constructor","logger","getInstance","deleteDraft","contextLevel","contextInstanceId","elementId","extraParams","siteId","_this","_asyncToGenerator","db","getSiteDb","params","fixDraftPrimaryData","deleteRecords","_unused","contextlevel","contextinstanceid","elementid","extraparams","sortAndStringify","getDraft","_this2","getRecord","resumeDraft","pageInstance","originalContent","_this3","entry","pageinstance","timemodified","Date","now","originalcontent","drafttext","insertRecord","_unused2","_unused3","saveDraft","draftText","_this4","timecreated","error","warn","data","trim","factory","ɵfac","providedIn","CoreEditorOffline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/editor/services/editor-offline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\n\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreEditorDraft, CoreEditorDraftPrimaryData, DRAFT_TABLE } from './database/editor';\n\n/**\n * Service with features regarding rich text editor in offline.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreEditorOfflineProvider {\n\n    protected logger: CoreLogger;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreEditorOfflineProvider');\n    }\n\n    /**\n     * Delete a draft from DB.\n     *\n     * @param contextLevel Context level.\n     * @param contextInstanceId The instance ID related to the context.\n     * @param elementId Element ID.\n     * @param extraParams Object with extra params to identify the draft.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async deleteDraft(\n        contextLevel: string,\n        contextInstanceId: number,\n        elementId: string,\n        extraParams: Record<string, unknown>,\n        siteId?: string,\n    ): Promise<void> {\n        try {\n            const db = await CoreSites.getSiteDb(siteId);\n\n            const params = this.fixDraftPrimaryData(contextLevel, contextInstanceId, elementId, extraParams);\n\n            await db.deleteRecords(DRAFT_TABLE, params);\n        } catch {\n            // Ignore errors, probably no draft stored.\n        }\n    }\n\n    /**\n     * Return an object with the draft primary data converted to the right format.\n     *\n     * @param contextLevel Context level.\n     * @param contextInstanceId The instance ID related to the context.\n     * @param elementId Element ID.\n     * @param extraParams Object with extra params to identify the draft.\n     * @returns Object with the fixed primary data.\n     */\n    protected fixDraftPrimaryData(\n        contextLevel: string,\n        contextInstanceId: number,\n        elementId: string,\n        extraParams: Record<string, unknown>,\n    ): CoreEditorDraftPrimaryData {\n\n        return {\n            contextlevel: contextLevel,\n            contextinstanceid: contextInstanceId,\n            elementid: elementId,\n            extraparams: CoreUtils.sortAndStringify(extraParams || {}),\n        };\n    }\n\n    /**\n     * Get a draft from DB.\n     *\n     * @param contextLevel Context level.\n     * @param contextInstanceId The instance ID related to the context.\n     * @param elementId Element ID.\n     * @param extraParams Object with extra params to identify the draft.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the draft data. Undefined if no draft stored.\n     */\n    async getDraft(\n        contextLevel: string,\n        contextInstanceId: number,\n        elementId: string,\n        extraParams: Record<string, unknown>,\n        siteId?: string,\n    ): Promise<CoreEditorDraft> {\n\n        const db = await CoreSites.getSiteDb(siteId);\n\n        const params = this.fixDraftPrimaryData(contextLevel, contextInstanceId, elementId, extraParams);\n\n        return db.getRecord(DRAFT_TABLE, params);\n    }\n\n    /**\n     * Get draft to resume it.\n     *\n     * @param contextLevel Context level.\n     * @param contextInstanceId The instance ID related to the context.\n     * @param elementId Element ID.\n     * @param extraParams Object with extra params to identify the draft.\n     * @param pageInstance Unique identifier to prevent storing data from several sources at the same time.\n     * @param originalContent Original content of the editor.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the draft data. Undefined if no draft stored.\n     */\n    async resumeDraft(\n        contextLevel: string,\n        contextInstanceId: number,\n        elementId: string,\n        extraParams: Record<string, unknown>,\n        pageInstance: string,\n        originalContent?: string,\n        siteId?: string,\n    ): Promise<CoreEditorDraft | undefined> {\n\n        try {\n            // Check if there is a draft stored.\n            const entry = await this.getDraft(contextLevel, contextInstanceId, elementId, extraParams, siteId);\n\n            // There is a draft stored. Update its page instance.\n            try {\n                const db = await CoreSites.getSiteDb(siteId);\n\n                entry.pageinstance = pageInstance;\n                entry.timemodified = Date.now();\n\n                if (originalContent && entry.originalcontent != originalContent) {\n                    entry.originalcontent = originalContent;\n                    entry.drafttext = ''; // \"Discard\" the draft.\n                }\n\n                await db.insertRecord(DRAFT_TABLE, entry);\n            } catch {\n                // Ignore errors saving the draft. It shouldn't happen.\n            }\n\n            return entry;\n        } catch {\n            // No draft stored. Store an empty draft to save the pageinstance.\n            await this.saveDraft(\n                contextLevel,\n                contextInstanceId,\n                elementId,\n                extraParams,\n                pageInstance,\n                '',\n                originalContent,\n                siteId,\n            );\n        }\n    }\n\n    /**\n     * Save a draft in DB.\n     *\n     * @param contextLevel Context level.\n     * @param contextInstanceId The instance ID related to the context.\n     * @param elementId Element ID.\n     * @param extraParams Object with extra params to identify the draft.\n     * @param pageInstance Unique identifier to prevent storing data from several sources at the same time.\n     * @param draftText The text to store.\n     * @param originalContent Original content of the editor.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async saveDraft(\n        contextLevel: string,\n        contextInstanceId: number,\n        elementId: string,\n        extraParams: Record<string, unknown>,\n        pageInstance: string,\n        draftText: string,\n        originalContent?: string,\n        siteId?: string,\n    ): Promise<void> {\n\n        let timecreated = Date.now();\n        let entry: CoreEditorDraft | undefined;\n\n        // Check if there is a draft already stored.\n        try {\n            entry = await this.getDraft(contextLevel, contextInstanceId, elementId, extraParams, siteId);\n\n            timecreated = entry.timecreated || timecreated;\n        } catch (error) {\n            // No draft already stored.\n        }\n\n        if (entry) {\n            if (entry.pageinstance != pageInstance) {\n                this.logger.warn(`Discarding draft because of pageinstance. Context '${contextLevel}' '${contextInstanceId}', ` +\n                    `element '${elementId}'`);\n\n                throw new CoreError('Draft was discarded because it was modified in another page.');\n            }\n\n            if (!originalContent) {\n                // Original content not set, use the one in the entry.\n                originalContent = entry.originalcontent;\n            }\n        }\n\n        const db = await CoreSites.getSiteDb(siteId);\n\n        const data: CoreEditorDraft = this.fixDraftPrimaryData(contextLevel, contextInstanceId, elementId, extraParams);\n\n        data.drafttext = (draftText || '').trim();\n        data.pageinstance = pageInstance;\n        data.timecreated = timecreated;\n        data.timemodified = Date.now();\n        if (originalContent) {\n            data.originalcontent = originalContent;\n        }\n\n        await db.insertRecord(DRAFT_TABLE, data);\n    }\n\n}\n\nexport const CoreEditorOffline = makeSingleton(CoreEditorOfflineProvider);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}