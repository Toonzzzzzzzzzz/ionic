{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreApp } from '@services/app';\nimport { CoreSites } from '@services/sites';\nimport { CorePushNotificationsDelegate } from './push-delegate';\nimport { CoreLocalNotifications } from '@services/local-notifications';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreConfig } from '@services/config';\nimport { CoreConstants } from '@/core/constants';\nimport { makeSingleton, Badge, Device, Translate, ApplicationInit, NgZone } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreEvents } from '@singletons/events';\nimport { APP_SCHEMA, BADGE_TABLE_NAME, PENDING_UNREGISTER_TABLE_NAME, REGISTERED_DEVICES_TABLE_NAME } from './database/pushnotifications';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSitesFactory } from '@services/sites-factory';\nimport { CoreMainMenuProvider } from '@features/mainmenu/services/mainmenu';\nimport { asyncInstance } from '@/core/utils/async-instance';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport { CoreObject } from '@singletons/object';\nimport { lazyMap } from '@/core/utils/lazy-map';\nimport { CorePlatform } from '@services/platform';\nimport { CoreAnalytics, CoreAnalyticsEventType } from '@services/analytics';\nimport { Push } from '@features/native/plugins';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to handle push notifications.\n */\nexport class CorePushNotificationsProvider {\n  constructor() {\n    this.badgesTable = asyncInstance();\n    this.pendingUnregistersTable = asyncInstance();\n    this.logger = CoreLogger.getInstance('CorePushNotificationsProvider');\n    this.registeredDevicesTables = lazyMap(siteId => asyncInstance(() => CoreSites.getSiteTable(REGISTERED_DEVICES_TABLE_NAME, {\n      siteId,\n      config: {\n        cachingStrategy: CoreDatabaseCachingStrategy.None\n      },\n      primaryKeyColumns: ['appid', 'uuid'],\n      onDestroy: () => delete this.registeredDevicesTables[siteId]\n    })));\n  }\n  /**\n   * Initialize the service.\n   *\n   * @returns Promise resolved when done.\n   */\n  initialize() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all([_this.initializeDatabase(), _this.initializeDefaultChannel()]);\n      // Now register the device to receive push notifications. Don't block for this.\n      _this.registerDevice();\n      CoreEvents.on(CoreEvents.NOTIFICATION_SOUND_CHANGED, () => {\n        // Notification sound has changed, register the device again to update the sound setting.\n        _this.registerDevice();\n      });\n      // Register device on Moodle site when login.\n      CoreEvents.on(CoreEvents.LOGIN, /*#__PURE__*/_asyncToGenerator(function* () {\n        if (!_this.canRegisterOnMoodle()) {\n          return;\n        }\n        try {\n          yield _this.registerDeviceOnMoodle();\n        } catch (error) {\n          _this.logger.error('Can\\'t register device', error);\n        }\n      }));\n      CoreEvents.on(CoreEvents.SITE_DELETED, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (site) {\n          try {\n            yield Promise.all([_this.unregisterDeviceOnMoodle(site), _this.cleanSiteCounters(site.getId())]);\n          } catch (error) {\n            _this.logger.warn('Can\\'t unregister device', error);\n          }\n        });\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      CoreEvents.on(CoreMainMenuProvider.MAIN_MENU_HANDLER_BADGE_UPDATED, data => {\n        _this.updateAddonCounter(data.handler, data.value, data.siteId);\n      });\n      // Listen for local notification clicks (generated by the app).\n      CoreLocalNotifications.registerClick(CorePushNotificationsProvider.COMPONENT, notification => {\n        CoreAnalytics.logEvent({\n          eventName: 'moodle_notification_open',\n          type: CoreAnalyticsEventType.PUSH_NOTIFICATION,\n          data: notification\n        });\n        _this.notificationClicked(notification);\n      });\n      // Listen for local notification dismissed events.\n      CoreLocalNotifications.registerObserver('clear', CorePushNotificationsProvider.COMPONENT, notification => {\n        CoreAnalytics.logEvent({\n          eventName: 'moodle_notification_dismiss',\n          type: CoreAnalyticsEventType.PUSH_NOTIFICATION,\n          data: notification\n        });\n      });\n    })();\n  }\n  /**\n   * Initialize the default channel for Android.\n   *\n   * @returns Promise resolved when done.\n   */\n  initializeDefaultChannel() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield CorePlatform.ready();\n      // Create the default channel.\n      _this2.createDefaultChannel();\n      Translate.onLangChange.subscribe(() => {\n        // Update the channel name.\n        _this2.createDefaultChannel();\n      });\n    })();\n  }\n  /**\n   * Initialize database.\n   *\n   * @returns Promise resolved when done.\n   */\n  initializeDatabase() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield CoreApp.createTablesFromSchema(APP_SCHEMA);\n      } catch (e) {\n        // Ignore errors.\n      }\n      const database = CoreApp.getDB();\n      const badgesTable = new CoreDatabaseTableProxy({\n        cachingStrategy: CoreDatabaseCachingStrategy.Eager\n      }, database, BADGE_TABLE_NAME, ['siteid', 'addon']);\n      const pendingUnregistersTable = new CoreDatabaseTableProxy({\n        cachingStrategy: CoreDatabaseCachingStrategy.Eager\n      }, database, PENDING_UNREGISTER_TABLE_NAME, ['siteid']);\n      yield Promise.all([badgesTable.initialize(), pendingUnregistersTable.initialize()]);\n      _this3.badgesTable.setInstance(badgesTable);\n      _this3.pendingUnregistersTable.setInstance(pendingUnregistersTable);\n    })();\n  }\n  /**\n   * Check whether the device can be registered in Moodle to receive push notifications.\n   *\n   * @returns Whether the device can be registered in Moodle.\n   */\n  canRegisterOnMoodle() {\n    return !!this.pushID && CorePlatform.isMobile();\n  }\n  /**\n   * Delete all badge records for a given site.\n   *\n   * @param siteId Site ID.\n   * @returns Resolved when done.\n   */\n  cleanSiteCounters(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this4.badgesTable.delete({\n          siteid: siteId\n        });\n      } finally {\n        _this4.updateAppCounter();\n      }\n    })();\n  }\n  /**\n   * Create the default push channel. It is used to change the name.\n   *\n   * @returns Promise resolved when done.\n   */\n  createDefaultChannel() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!CorePlatform.isAndroid()) {\n        return;\n      }\n      try {\n        yield Push.createChannel({\n          id: 'PushPluginChannel',\n          description: Translate.instant('core.misc'),\n          importance: 4\n        });\n      } catch (error) {\n        _this5.logger.error('Error changing push channel name', error);\n      }\n    })();\n  }\n  /**\n   * Enable or disable analytics.\n   *\n   * @param enable Whether to enable or disable.\n   * @returns Promise resolved when done.\n   * @deprecated since 4.3. Use CoreAnalytics.enableAnalytics instead.\n   */\n  enableAnalytics(enable) {\n    return _asyncToGenerator(function* () {\n      return CoreAnalytics.enableAnalytics(enable);\n    })();\n  }\n  /**\n   * Returns options for push notifications based on device.\n   *\n   * @returns Promise with the push options resolved when done.\n   */\n  getOptions() {\n    return _asyncToGenerator(function* () {\n      let soundEnabled = true;\n      if (CoreLocalNotifications.canDisableSound()) {\n        soundEnabled = yield CoreConfig.get(CoreConstants.SETTINGS_NOTIFICATION_SOUND, true);\n      }\n      return {\n        android: {\n          sound: !!soundEnabled,\n          icon: 'smallicon',\n          iconColor: CoreConstants.CONFIG.notificoncolor\n        },\n        ios: {\n          alert: 'true',\n          badge: true,\n          sound: !!soundEnabled\n        },\n        windows: {\n          sound: !!soundEnabled\n        }\n      };\n    })();\n  }\n  /**\n   * Get the pushID for this device.\n   *\n   * @returns Push ID.\n   */\n  getPushId() {\n    return this.pushID;\n  }\n  /**\n   * Get required data to register the device in Moodle.\n   *\n   * @returns Data.\n   */\n  getRequiredRegisterData() {\n    if (!this.pushID) {\n      throw new CoreError('Cannot get register data because pushID is not set.');\n    }\n    return {\n      appid: CoreConstants.CONFIG.app_id,\n      name: Device.manufacturer || '',\n      model: Device.model,\n      platform: Device.platform + '-fcm',\n      version: Device.version,\n      pushid: this.pushID,\n      uuid: Device.uuid\n    };\n  }\n  /**\n   * Get Sitebadge counter from the database.\n   *\n   * @param siteId Site ID.\n   * @returns Promise resolved with the stored badge counter for the site.\n   */\n  getSiteCounter(siteId) {\n    return this.getAddonBadge(siteId);\n  }\n  /**\n   * Log an analytics event.\n   *\n   * @param eventName Name of the event.\n   * @param data Data of the event.\n   * @returns Promise resolved when done. This promise is never rejected.\n   * @deprecated since 4.3. Use CoreAnalytics.logEvent instead.\n   */\n  logEvent(eventName, data) {\n    return _asyncToGenerator(function* () {\n      var _data$moodleaction;\n      if (eventName !== 'view_item' && eventName !== 'view_item_list') {\n        return CoreAnalytics.logEvent({\n          type: CoreAnalyticsEventType.PUSH_NOTIFICATION,\n          eventName,\n          data\n        });\n      }\n      const name = data.name ? String(data.name) : '';\n      delete data.name;\n      return CoreAnalytics.logEvent({\n        type: eventName === 'view_item' ? CoreAnalyticsEventType.VIEW_ITEM : CoreAnalyticsEventType.VIEW_ITEM_LIST,\n        ws: (_data$moodleaction = data.moodleaction) !== null && _data$moodleaction !== void 0 ? _data$moodleaction : '',\n        name,\n        data\n      });\n    })();\n  }\n  /**\n   * Log an analytics VIEW_ITEM_LIST event.\n   *\n   * @param itemId The item ID.\n   * @param itemName The item name.\n   * @param itemCategory The item category.\n   * @param wsName Name of the WS.\n   * @param data Other data to pass to the event.\n   * @returns Promise resolved when done. This promise is never rejected.\n   * @deprecated since 4.3. Use CoreAnalytics.logEvent instead.\n   */\n  logViewEvent(itemId, itemName, itemCategory, wsName, data) {\n    data = data || {};\n    data.id = itemId;\n    data.name = itemName;\n    data.category = itemCategory;\n    data.moodleaction = wsName;\n    // eslint-disable-next-line deprecation/deprecation\n    return this.logEvent('view_item', data);\n  }\n  /**\n   * Log an analytics view item list event.\n   *\n   * @param itemCategory The item category.\n   * @param wsName Name of the WS.\n   * @param data Other data to pass to the event.\n   * @returns Promise resolved when done. This promise is never rejected.\n   * @deprecated since 4.3. Use CoreAnalytics.logEvent instead.\n   */\n  logViewListEvent(itemCategory, wsName, data) {\n    data = data || {};\n    data.moodleaction = wsName;\n    data.category = itemCategory;\n    // eslint-disable-next-line deprecation/deprecation\n    return this.logEvent('view_item_list', data);\n  }\n  /**\n   * Function called when a push notification is clicked. Redirect the user to the right state.\n   *\n   * @param data Notification data.\n   * @returns Promise resolved when done.\n   */\n  notificationClicked(data) {\n    return _asyncToGenerator(function* () {\n      yield ApplicationInit.donePromise;\n      CorePushNotificationsDelegate.clicked(data);\n    })();\n  }\n  /**\n   * This function is called when we receive a Notification from APNS or a message notification from GCM.\n   * The app can be in foreground or background,\n   * if we are in background this code is executed when we open the app clicking in the notification bar.\n   *\n   * @param notification Notification received.\n   * @returns Promise resolved when done.\n   */\n  onMessageReceived(notification) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      var _site;\n      const rawData = notification ? notification.additionalData : {};\n      // Parse some fields and add some extra data.\n      const data = Object.assign(rawData, {\n        title: notification.title,\n        message: notification.message,\n        customdata: typeof rawData.customdata == 'string' ? CoreTextUtils.parseJSON(rawData.customdata, {}) : rawData.customdata\n      });\n      let site;\n      if (data.site) {\n        site = yield CoreSites.getSite(data.site);\n      } else if (data.siteurl) {\n        site = yield CoreSites.getSiteByUrl(data.siteurl);\n      }\n      data.site = (_site = site) === null || _site === void 0 ? void 0 : _site.getId();\n      if (!CoreUtils.isTrueOrOne(data.foreground)) {\n        // The notification was clicked.\n        return _this6.notificationClicked(data);\n      }\n      const localNotif = {\n        id: Number(data.notId) || 1,\n        data: data,\n        title: notification.title,\n        text: notification.message,\n        channel: 'PushPluginChannel'\n      };\n      const isAndroid = CorePlatform.isAndroid();\n      const extraFeatures = CoreUtils.isTrueOrOne(data.extrafeatures);\n      if (extraFeatures && isAndroid && CoreUtils.isFalseOrZero(data.notif)) {\n        var _data$sender;\n        // It's a message, use messaging style. Ionic Native doesn't specify this option.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        localNotif.text = [{\n          message: notification.message,\n          person: (_data$sender = data.sender) !== null && _data$sender !== void 0 ? _data$sender : data.conversationtype == '2' ? data.userfromfullname : '',\n          personIcon: data.senderImage\n        }];\n      }\n      if (extraFeatures && isAndroid) {\n        // Use a different icon if needed.\n        localNotif.icon = notification.image;\n        // This feature isn't supported by the official plugin, we use a fork.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        localNotif.iconType = data['image-type'];\n        localNotif.summary = data.summaryText;\n        if (data.picture) {\n          localNotif.attachments = [data.picture];\n        }\n      }\n      CoreLocalNotifications.schedule(localNotif, CorePushNotificationsProvider.COMPONENT, data.site || '', true);\n      yield _this6.notifyReceived(notification, data);\n    })();\n  }\n  /**\n   * Notify that a notification was received.\n   *\n   * @param notification Notification.\n   * @param data Notification data.\n   * @returns Promise resolved when done.\n   */\n  notifyReceived(notification, data) {\n    return _asyncToGenerator(function* () {\n      yield ApplicationInit.donePromise;\n      CorePushNotificationsDelegate.received(data);\n    })();\n  }\n  /**\n   * Unregisters a device from a certain Moodle site.\n   *\n   * @param site Site to unregister from.\n   * @returns Promise resolved when device is unregistered.\n   */\n  unregisterDeviceOnMoodle(site) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!site || !CorePlatform.isMobile()) {\n        throw new CoreError('Cannot unregister device');\n      }\n      _this7.logger.debug(`Unregister device on Moodle: '${site.getId()}'`);\n      const data = {\n        appid: CoreConstants.CONFIG.app_id,\n        uuid: Device.uuid\n      };\n      let response;\n      try {\n        response = yield site.write('core_user_remove_user_device', data);\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error) || CoreUtils.isExpiredTokenError(error)) {\n          // Cannot unregister. Don't try again.\n          yield CoreUtils.ignoreErrors(_this7.pendingUnregistersTable.delete({\n            token: site.getToken(),\n            siteid: site.getId()\n          }));\n          throw error;\n        }\n        // Store the pending unregister so it's retried again later.\n        yield _this7.pendingUnregistersTable.insert({\n          siteid: site.getId(),\n          siteurl: site.getURL(),\n          token: site.getToken(),\n          info: JSON.stringify(site.getInfo())\n        });\n        return;\n      }\n      if (!response.removed) {\n        throw new CoreError('Cannot unregister device');\n      }\n      yield CoreUtils.ignoreErrors(Promise.all([\n      // Remove the device from the local DB.\n      _this7.registeredDevicesTables[site.getId()].delete(_this7.getRequiredRegisterData()),\n      // Remove pending unregisters for this site.\n      _this7.pendingUnregistersTable.deleteByPrimaryKey({\n        siteid: site.getId()\n      })]));\n    })();\n  }\n  /**\n   * Update Counter for an addon. It will update the refered siteId counter and the total badge.\n   * It will return the updated addon counter.\n   *\n   * @param addon Registered addon name to set the badge number.\n   * @param value The number to be stored.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved with the stored badge counter for the addon on the site.\n   */\n  updateAddonCounter(addon, value, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (!CorePushNotificationsDelegate.isCounterHandlerRegistered(addon)) {\n        return 0;\n      }\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield _this8.saveAddonBadge(value, siteId, addon);\n      yield _this8.updateSiteCounter(siteId);\n      return value;\n    })();\n  }\n  /**\n   * Update total badge counter of the app.\n   *\n   * @returns Promise resolved with the stored badge counter for the site.\n   */\n  updateAppCounter() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const sitesIds = yield CoreSites.getSitesIds();\n      const counters = yield Promise.all(sitesIds.map(siteId => _this9.getAddonBadge(siteId)));\n      const total = counters.reduce((previous, counter) => previous + counter, 0);\n      if (CorePlatform.isMobile()) {\n        // Set the app badge on mobile.\n        yield Badge.set(total);\n      }\n      return total;\n    })();\n  }\n  /**\n   * Update counter for a site using the stored addon data. It will update the total badge application number.\n   * It will return the updated site counter.\n   *\n   * @param siteId Site ID.\n   * @returns Promise resolved with the stored badge counter for the site.\n   */\n  updateSiteCounter(siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const addons = CorePushNotificationsDelegate.getCounterHandlers();\n      const counters = yield Promise.all(Object.values(addons).map(addon => _this10.getAddonBadge(siteId, addon)));\n      const total = counters.reduce((previous, counter) => previous + counter, 0);\n      // Save the counter on site.\n      yield _this10.saveAddonBadge(total, siteId);\n      yield _this10.updateAppCounter();\n      return total;\n    })();\n  }\n  /**\n   * Register a device in Apple APNS or Google GCM.\n   *\n   * @returns Promise resolved when the device is registered.\n   */\n  registerDevice() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // Check if sound is enabled for notifications.\n        const options = yield _this11.getOptions();\n        const pushObject = Push.init(options);\n        pushObject.on('notification').subscribe(notification => {\n          // Execute the callback in the Angular zone, so change detection doesn't stop working.\n          NgZone.run(() => {\n            if ('registrationType' in notification) {\n              // Not a valid notification, ignore.\n              return;\n            }\n            _this11.logger.log('Received a notification', notification);\n            _this11.onMessageReceived(notification);\n          });\n        });\n        pushObject.on('registration').subscribe(data => {\n          // Execute the callback in the Angular zone, so change detection doesn't stop working.\n          NgZone.run(() => {\n            _this11.pushID = data.registrationId;\n            if (!CoreSites.isLoggedIn() || !_this11.canRegisterOnMoodle()) {\n              return;\n            }\n            _this11.registerDeviceOnMoodle().catch(error => {\n              _this11.logger.error('Can\\'t register device', error);\n            });\n          });\n        });\n        pushObject.on('error').subscribe(error => {\n          // Execute the callback in the Angular zone, so change detection doesn't stop working.\n          NgZone.run(() => {\n            _this11.logger.warn('Error with Push plugin', error);\n          });\n        });\n      } catch (error) {\n        _this11.logger.warn(error);\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Registers a device on a Moodle site if needed.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @param forceUnregister Whether to force unregister and register.\n   * @returns Promise resolved when device is registered.\n   */\n  registerDeviceOnMoodle(siteId, forceUnregister) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      _this12.logger.debug('Register device on Moodle.');\n      if (!_this12.canRegisterOnMoodle()) {\n        return Promise.reject(null);\n      }\n      const site = yield CoreSites.getSite(siteId);\n      try {\n        const data = _this12.getRequiredRegisterData();\n        data.publickey = yield _this12.getPublicKeyForSite(site);\n        const neededActions = yield _this12.getRegisterDeviceActions(data, site, forceUnregister);\n        if (neededActions.unregister) {\n          // Unregister the device first.\n          yield CoreUtils.ignoreErrors(_this12.unregisterDeviceOnMoodle(site));\n        }\n        if (neededActions.register) {\n          // Now register the device.\n          const addDeviceResponse = yield site.write('core_user_add_user_device', CoreUtils.clone(data));\n          const deviceAlreadyRegistered = addDeviceResponse[0] && addDeviceResponse[0].find(warning => warning.warningcode === 'existingkeyforthisuser');\n          if (deviceAlreadyRegistered && data.publickey) {\n            // Device already registered, make sure the public key is up to date.\n            yield _this12.updatePublicKeyOnMoodle(site, data);\n          }\n          CoreEvents.trigger(CoreEvents.DEVICE_REGISTERED_IN_MOODLE, {}, site.getId());\n          // Insert the device in the local DB.\n          yield CoreUtils.ignoreErrors(_this12.registeredDevicesTables[site.getId()].insert(data));\n        } else if (neededActions.updatePublicKey) {\n          var _response$warnings;\n          // Device already registered, make sure the public key is up to date.\n          const response = yield _this12.updatePublicKeyOnMoodle(site, data);\n          if (response !== null && response !== void 0 && (_response$warnings = response.warnings) !== null && _response$warnings !== void 0 && _response$warnings.find(warning => warning.warningcode === 'devicedoesnotexist')) {\n            // The device doesn't exist in the server. Remove the device from the local DB and try again.\n            yield _this12.registeredDevicesTables[site.getId()].delete({\n              appid: data.appid,\n              uuid: data.uuid,\n              name: data.name,\n              model: data.model,\n              platform: data.platform\n            });\n            yield _this12.registerDeviceOnMoodle(siteId, false);\n          }\n        }\n      } finally {\n        // Remove pending unregisters for this site.\n        yield CoreUtils.ignoreErrors(_this12.pendingUnregistersTable.deleteByPrimaryKey({\n          siteid: site.getId()\n        }));\n      }\n    })();\n  }\n  /**\n   * Get the public key to register in a site.\n   *\n   * @param site Site to register\n   * @returns Public key, undefined if the site or the device doesn't support encryption.\n   */\n  getPublicKeyForSite(site) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (!site.wsAvailable('core_user_update_user_device_public_key')) {\n        return;\n      }\n      return yield _this13.getPublicKey();\n    })();\n  }\n  /**\n   * Get the device public key.\n   *\n   * @returns Public key, undefined if the device doesn't support encryption.\n   */\n  getPublicKey() {\n    return _asyncToGenerator(function* () {\n      if (!CorePlatform.isMobile()) {\n        return;\n      }\n      const publicKey = yield Push.getPublicKey();\n      return publicKey !== null && publicKey !== void 0 ? publicKey : undefined;\n    })();\n  }\n  /**\n   * Update a public key on a Moodle site.\n   *\n   * @param site Site.\n   * @param data Device data.\n   * @returns WS response, undefined if no public key.\n   */\n  updatePublicKeyOnMoodle(site, data) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (!data.publickey) {\n        return;\n      }\n      _this14.logger.debug('Update public key on Moodle.');\n      const params = {\n        uuid: data.uuid,\n        appid: data.appid,\n        publickey: data.publickey\n      };\n      return yield site.write('core_user_update_user_device_public_key', params);\n    })();\n  }\n  /**\n   * Get the addon/site badge counter from the database.\n   *\n   * @param siteId Site ID.\n   * @param addon Registered addon name. If not defined it will store the site total.\n   * @returns Promise resolved with the stored badge counter for the addon or site or 0 if none.\n   */\n  getAddonBadge(siteId, addon = 'site') {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const entry = yield _this15.badgesTable.getOne({\n          siteid: siteId,\n          addon\n        });\n        return (entry === null || entry === void 0 ? void 0 : entry.number) || 0;\n      } catch (err) {\n        return 0;\n      }\n    })();\n  }\n  /**\n   * Retry pending unregisters.\n   *\n   * @param siteId If defined, retry only for that site if needed. Otherwise, retry all pending unregisters.\n   * @returns Promise resolved when done.\n   */\n  retryUnregisters(siteId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const results = yield _this16.pendingUnregistersTable.getMany(CoreObject.withoutEmpty({\n        siteid: siteId\n      }));\n      yield Promise.all(results.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (result) {\n          // Create a temporary site to unregister.\n          const tmpSite = CoreSitesFactory.makeSite(result.siteid, result.siteurl, result.token, {\n            info: CoreTextUtils.parseJSON(result.info, null) || undefined\n          });\n          yield _this16.unregisterDeviceOnMoodle(tmpSite);\n        });\n        return function (_x2) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Save the addon/site badgecounter on the database.\n   *\n   * @param value The number to be stored.\n   * @param siteId Site ID. If not defined, use current site.\n   * @param addon Registered addon name. If not defined it will store the site total.\n   * @returns Promise resolved with the stored badge counter for the addon or site.\n   */\n  saveAddonBadge(value, siteId, addon = 'site') {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield _this17.badgesTable.insert({\n        siteid: siteId,\n        addon,\n        number: value // eslint-disable-line id-blacklist\n      });\n\n      return value;\n    })();\n  }\n  /**\n   * Get the needed actions to perform to register a device.\n   *\n   * @param data Data of the device.\n   * @param site Site to use.\n   * @param forceUnregister Whether to force unregister and register.\n   * @returns Whether each action needs to be performed or not.\n   */\n  getRegisterDeviceActions(data, site, forceUnregister) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (forceUnregister) {\n        // No need to check if device is stored, always unregister and register the device.\n        return {\n          unregister: true,\n          register: true,\n          updatePublicKey: false\n        };\n      }\n      // Check if the device is already registered.\n      const records = yield CoreUtils.ignoreErrors(_this18.registeredDevicesTables[site.getId()].getMany({\n        appid: data.appid,\n        uuid: data.uuid,\n        name: data.name,\n        model: data.model,\n        platform: data.platform\n      }));\n      let isStored = false;\n      let versionOrPushChanged = false;\n      let updatePublicKey = false;\n      (records || []).forEach(record => {\n        if (record.version == data.version && record.pushid == data.pushid) {\n          // The device is already stored.\n          isStored = true;\n          updatePublicKey = !!data.publickey && record.publickey !== data.publickey;\n        } else {\n          // The version or pushid has changed.\n          versionOrPushChanged = true;\n        }\n      });\n      return {\n        register: !isStored,\n        unregister: !isStored && !versionOrPushChanged,\n        updatePublicKey\n      };\n    })();\n  }\n}\n_class = CorePushNotificationsProvider;\n_class.COMPONENT = 'CorePushNotificationsProvider';\n_class.ɵfac = function CorePushNotificationsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CorePushNotifications = makeSingleton(CorePushNotificationsProvider);","map":{"version":3,"names":["CoreApp","CoreSites","CorePushNotificationsDelegate","CoreLocalNotifications","CoreUtils","CoreTextUtils","CoreConfig","CoreConstants","makeSingleton","Badge","Device","Translate","ApplicationInit","NgZone","CoreLogger","CoreEvents","APP_SCHEMA","BADGE_TABLE_NAME","PENDING_UNREGISTER_TABLE_NAME","REGISTERED_DEVICES_TABLE_NAME","CoreError","CoreSitesFactory","CoreMainMenuProvider","asyncInstance","CoreDatabaseCachingStrategy","CoreDatabaseTableProxy","CoreObject","lazyMap","CorePlatform","CoreAnalytics","CoreAnalyticsEventType","Push","CorePushNotificationsProvider","constructor","badgesTable","pendingUnregistersTable","logger","getInstance","registeredDevicesTables","siteId","getSiteTable","config","cachingStrategy","None","primaryKeyColumns","onDestroy","initialize","_this","_asyncToGenerator","Promise","all","initializeDatabase","initializeDefaultChannel","registerDevice","on","NOTIFICATION_SOUND_CHANGED","LOGIN","canRegisterOnMoodle","registerDeviceOnMoodle","error","SITE_DELETED","_ref2","site","unregisterDeviceOnMoodle","cleanSiteCounters","getId","warn","_x","apply","arguments","MAIN_MENU_HANDLER_BADGE_UPDATED","data","updateAddonCounter","handler","value","registerClick","COMPONENT","notification","logEvent","eventName","type","PUSH_NOTIFICATION","notificationClicked","registerObserver","_this2","ready","createDefaultChannel","onLangChange","subscribe","_this3","createTablesFromSchema","e","database","getDB","Eager","setInstance","pushID","isMobile","_this4","delete","siteid","updateAppCounter","_this5","isAndroid","createChannel","id","description","instant","importance","enableAnalytics","enable","getOptions","soundEnabled","canDisableSound","get","SETTINGS_NOTIFICATION_SOUND","android","sound","icon","iconColor","CONFIG","notificoncolor","ios","alert","badge","windows","getPushId","getRequiredRegisterData","appid","app_id","name","manufacturer","model","platform","version","pushid","uuid","getSiteCounter","getAddonBadge","_data$moodleaction","String","VIEW_ITEM","VIEW_ITEM_LIST","ws","moodleaction","logViewEvent","itemId","itemName","itemCategory","wsName","category","logViewListEvent","donePromise","clicked","onMessageReceived","_this6","_site","rawData","additionalData","Object","assign","title","message","customdata","parseJSON","getSite","siteurl","getSiteByUrl","isTrueOrOne","foreground","localNotif","Number","notId","text","channel","extraFeatures","extrafeatures","isFalseOrZero","notif","_data$sender","person","sender","conversationtype","userfromfullname","personIcon","senderImage","image","iconType","summary","summaryText","picture","attachments","schedule","notifyReceived","received","_this7","debug","response","write","isWebServiceError","isExpiredTokenError","ignoreErrors","token","getToken","insert","getURL","info","JSON","stringify","getInfo","removed","deleteByPrimaryKey","addon","_this8","isCounterHandlerRegistered","getCurrentSiteId","saveAddonBadge","updateSiteCounter","_this9","sitesIds","getSitesIds","counters","map","total","reduce","previous","counter","set","_this10","addons","getCounterHandlers","values","_this11","options","pushObject","init","run","log","registrationId","isLoggedIn","catch","forceUnregister","_this12","reject","publickey","getPublicKeyForSite","neededActions","getRegisterDeviceActions","unregister","register","addDeviceResponse","clone","deviceAlreadyRegistered","find","warning","warningcode","updatePublicKeyOnMoodle","trigger","DEVICE_REGISTERED_IN_MOODLE","updatePublicKey","_response$warnings","warnings","_this13","wsAvailable","getPublicKey","publicKey","undefined","_this14","params","_this15","entry","getOne","number","err","retryUnregisters","_this16","results","getMany","withoutEmpty","_ref3","result","tmpSite","makeSite","_x2","_this17","_this18","records","isStored","versionOrPushChanged","forEach","record","_class","factory","ɵfac","providedIn","CorePushNotifications"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/pushnotifications/services/pushnotifications.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { ILocalNotification } from '@awesome-cordova-plugins/local-notifications';\nimport { NotificationEventResponse, PushOptions, RegistrationEventResponse } from '@awesome-cordova-plugins/push/ngx';\n\nimport { CoreApp } from '@services/app';\nimport { CoreSites } from '@services/sites';\nimport { CorePushNotificationsDelegate } from './push-delegate';\nimport { CoreLocalNotifications } from '@services/local-notifications';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreConfig } from '@services/config';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton, Badge, Device, Translate, ApplicationInit, NgZone } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreEvents } from '@singletons/events';\nimport {\n    APP_SCHEMA,\n    BADGE_TABLE_NAME,\n    PENDING_UNREGISTER_TABLE_NAME,\n    REGISTERED_DEVICES_TABLE_NAME,\n    CorePushNotificationsPendingUnregisterDBRecord,\n    CorePushNotificationsRegisteredDeviceDBRecord,\n    CorePushNotificationsBadgeDBRecord,\n} from './database/pushnotifications';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { CoreSitesFactory } from '@services/sites-factory';\nimport { CoreMainMenuProvider } from '@features/mainmenu/services/mainmenu';\nimport { AsyncInstance, asyncInstance } from '@/core/utils/async-instance';\nimport { CoreDatabaseTable } from '@classes/database/database-table';\nimport { CoreDatabaseCachingStrategy, CoreDatabaseTableProxy } from '@classes/database/database-table-proxy';\nimport { CoreObject } from '@singletons/object';\nimport { lazyMap, LazyMap } from '@/core/utils/lazy-map';\nimport { CorePlatform } from '@services/platform';\nimport { CoreAnalytics, CoreAnalyticsEventType } from '@services/analytics';\nimport { CoreSiteInfo } from '@classes/sites/unauthenticated-site';\nimport { Push } from '@features/native/plugins';\n\n/**\n * Service to handle push notifications.\n */\n@Injectable({ providedIn: 'root' })\nexport class CorePushNotificationsProvider {\n\n    static readonly COMPONENT = 'CorePushNotificationsProvider';\n\n    protected logger: CoreLogger;\n    protected pushID?: string;\n    protected badgesTable = asyncInstance<CoreDatabaseTable<CorePushNotificationsBadgeDBRecord, 'siteid' | 'addon'>>();\n    protected pendingUnregistersTable =\n        asyncInstance<CoreDatabaseTable<CorePushNotificationsPendingUnregisterDBRecord, 'siteid'>>();\n\n    protected registeredDevicesTables:\n        LazyMap<AsyncInstance<CoreDatabaseTable<CorePushNotificationsRegisteredDeviceDBRecord, 'appid' | 'uuid'>>>;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CorePushNotificationsProvider');\n        this.registeredDevicesTables = lazyMap(\n            siteId => asyncInstance(\n                () => CoreSites.getSiteTable<CorePushNotificationsRegisteredDeviceDBRecord, 'appid' | 'uuid'>(\n                    REGISTERED_DEVICES_TABLE_NAME,\n                    {\n                        siteId,\n                        config: { cachingStrategy: CoreDatabaseCachingStrategy.None },\n                        primaryKeyColumns: ['appid', 'uuid'],\n                        onDestroy: () => delete this.registeredDevicesTables[siteId],\n                    },\n                ),\n            ),\n        );\n    }\n\n    /**\n     * Initialize the service.\n     *\n     * @returns Promise resolved when done.\n     */\n    async initialize(): Promise<void> {\n        await Promise.all([\n            this.initializeDatabase(),\n            this.initializeDefaultChannel(),\n        ]);\n\n        // Now register the device to receive push notifications. Don't block for this.\n        this.registerDevice();\n\n        CoreEvents.on(CoreEvents.NOTIFICATION_SOUND_CHANGED, () => {\n            // Notification sound has changed, register the device again to update the sound setting.\n            this.registerDevice();\n        });\n\n        // Register device on Moodle site when login.\n        CoreEvents.on(CoreEvents.LOGIN, async () => {\n            if (!this.canRegisterOnMoodle()) {\n                return;\n            }\n\n            try {\n                await this.registerDeviceOnMoodle();\n            } catch (error) {\n                this.logger.error('Can\\'t register device', error);\n            }\n        });\n\n        CoreEvents.on(CoreEvents.SITE_DELETED, async (site) => {\n            try {\n                await Promise.all([\n                    this.unregisterDeviceOnMoodle(site),\n                    this.cleanSiteCounters(site.getId()),\n                ]);\n            } catch (error) {\n                this.logger.warn('Can\\'t unregister device', error);\n            }\n        });\n\n        CoreEvents.on(CoreMainMenuProvider.MAIN_MENU_HANDLER_BADGE_UPDATED, (data) => {\n            this.updateAddonCounter(data.handler, data.value, data.siteId);\n        });\n\n        // Listen for local notification clicks (generated by the app).\n        CoreLocalNotifications.registerClick<CorePushNotificationsNotificationBasicData>(\n            CorePushNotificationsProvider.COMPONENT,\n            (notification) => {\n                CoreAnalytics.logEvent({\n                    eventName: 'moodle_notification_open',\n                    type: CoreAnalyticsEventType.PUSH_NOTIFICATION,\n                    data: notification,\n                });\n\n                this.notificationClicked(notification);\n            },\n        );\n\n        // Listen for local notification dismissed events.\n        CoreLocalNotifications.registerObserver<CorePushNotificationsNotificationBasicData>(\n            'clear',\n            CorePushNotificationsProvider.COMPONENT,\n            (notification) => {\n                CoreAnalytics.logEvent({\n                    eventName: 'moodle_notification_dismiss',\n                    type: CoreAnalyticsEventType.PUSH_NOTIFICATION,\n                    data: notification,\n                });\n            },\n        );\n    }\n\n    /**\n     * Initialize the default channel for Android.\n     *\n     * @returns Promise resolved when done.\n     */\n    protected async initializeDefaultChannel(): Promise<void> {\n        await CorePlatform.ready();\n\n        // Create the default channel.\n        this.createDefaultChannel();\n\n        Translate.onLangChange.subscribe(() => {\n            // Update the channel name.\n            this.createDefaultChannel();\n        });\n    }\n\n    /**\n     * Initialize database.\n     *\n     * @returns Promise resolved when done.\n     */\n    protected async initializeDatabase(): Promise<void> {\n        try {\n            await CoreApp.createTablesFromSchema(APP_SCHEMA);\n        } catch (e) {\n            // Ignore errors.\n        }\n\n        const database = CoreApp.getDB();\n        const badgesTable = new CoreDatabaseTableProxy<CorePushNotificationsBadgeDBRecord, 'siteid' | 'addon'>(\n            { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            database,\n            BADGE_TABLE_NAME,\n            ['siteid', 'addon'],\n        );\n        const pendingUnregistersTable = new CoreDatabaseTableProxy<CorePushNotificationsPendingUnregisterDBRecord, 'siteid'>(\n            { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            database,\n            PENDING_UNREGISTER_TABLE_NAME,\n            ['siteid'],\n        );\n\n        await Promise.all([\n            badgesTable.initialize(),\n            pendingUnregistersTable.initialize(),\n        ]);\n\n        this.badgesTable.setInstance(badgesTable);\n        this.pendingUnregistersTable.setInstance(pendingUnregistersTable);\n    }\n\n    /**\n     * Check whether the device can be registered in Moodle to receive push notifications.\n     *\n     * @returns Whether the device can be registered in Moodle.\n     */\n    canRegisterOnMoodle(): boolean {\n        return !!this.pushID && CorePlatform.isMobile();\n    }\n\n    /**\n     * Delete all badge records for a given site.\n     *\n     * @param siteId Site ID.\n     * @returns Resolved when done.\n     */\n    async cleanSiteCounters(siteId: string): Promise<void> {\n        try {\n            await this.badgesTable.delete({ siteid: siteId });\n        } finally {\n            this.updateAppCounter();\n        }\n    }\n\n    /**\n     * Create the default push channel. It is used to change the name.\n     *\n     * @returns Promise resolved when done.\n     */\n    protected async createDefaultChannel(): Promise<void> {\n        if (!CorePlatform.isAndroid()) {\n            return;\n        }\n\n        try {\n            await Push.createChannel({\n                id: 'PushPluginChannel',\n                description: Translate.instant('core.misc'),\n                importance: 4,\n            });\n        } catch (error) {\n            this.logger.error('Error changing push channel name', error);\n        }\n    }\n\n    /**\n     * Enable or disable analytics.\n     *\n     * @param enable Whether to enable or disable.\n     * @returns Promise resolved when done.\n     * @deprecated since 4.3. Use CoreAnalytics.enableAnalytics instead.\n     */\n    async enableAnalytics(enable: boolean): Promise<void> {\n        return CoreAnalytics.enableAnalytics(enable);\n    }\n\n    /**\n     * Returns options for push notifications based on device.\n     *\n     * @returns Promise with the push options resolved when done.\n     */\n    protected async getOptions(): Promise<PushOptions> {\n        let soundEnabled = true;\n\n        if (CoreLocalNotifications.canDisableSound()) {\n            soundEnabled = await CoreConfig.get<boolean>(CoreConstants.SETTINGS_NOTIFICATION_SOUND, true);\n        }\n\n        return {\n            android: {\n                sound: !!soundEnabled,\n                icon: 'smallicon',\n                iconColor: CoreConstants.CONFIG.notificoncolor,\n            },\n            ios: {\n                alert: 'true',\n                badge: true,\n                sound: !!soundEnabled,\n            },\n            windows: {\n                sound: !!soundEnabled,\n            },\n        };\n    }\n\n    /**\n     * Get the pushID for this device.\n     *\n     * @returns Push ID.\n     */\n    getPushId(): string | undefined {\n        return this.pushID;\n    }\n\n    /**\n     * Get required data to register the device in Moodle.\n     *\n     * @returns Data.\n     */\n    protected getRequiredRegisterData(): CoreUserAddUserDeviceWSParams {\n        if (!this.pushID) {\n            throw new CoreError('Cannot get register data because pushID is not set.');\n        }\n\n        return {\n            appid:      CoreConstants.CONFIG.app_id,\n            name:       Device.manufacturer || '',\n            model:      Device.model,\n            platform:   Device.platform + '-fcm',\n            version:    Device.version,\n            pushid:     this.pushID,\n            uuid:       Device.uuid,\n        };\n    }\n\n    /**\n     * Get Sitebadge counter from the database.\n     *\n     * @param siteId Site ID.\n     * @returns Promise resolved with the stored badge counter for the site.\n     */\n    getSiteCounter(siteId: string): Promise<number> {\n        return this.getAddonBadge(siteId);\n    }\n\n    /**\n     * Log an analytics event.\n     *\n     * @param eventName Name of the event.\n     * @param data Data of the event.\n     * @returns Promise resolved when done. This promise is never rejected.\n     * @deprecated since 4.3. Use CoreAnalytics.logEvent instead.\n     */\n    async logEvent(eventName: string, data: Record<string, string | number | boolean | undefined>): Promise<void> {\n        if (eventName !== 'view_item' && eventName !== 'view_item_list') {\n            return CoreAnalytics.logEvent({\n                type: CoreAnalyticsEventType.PUSH_NOTIFICATION,\n                eventName,\n                data,\n            });\n        }\n\n        const name = data.name ? String(data.name) : '';\n        delete data.name;\n\n        return CoreAnalytics.logEvent({\n            type: eventName === 'view_item' ? CoreAnalyticsEventType.VIEW_ITEM : CoreAnalyticsEventType.VIEW_ITEM_LIST,\n            ws: <string> data.moodleaction ?? '',\n            name,\n            data,\n        });\n    }\n\n    /**\n     * Log an analytics VIEW_ITEM_LIST event.\n     *\n     * @param itemId The item ID.\n     * @param itemName The item name.\n     * @param itemCategory The item category.\n     * @param wsName Name of the WS.\n     * @param data Other data to pass to the event.\n     * @returns Promise resolved when done. This promise is never rejected.\n     * @deprecated since 4.3. Use CoreAnalytics.logEvent instead.\n     */\n    logViewEvent(\n        itemId: number | string | undefined,\n        itemName: string | undefined,\n        itemCategory: string | undefined,\n        wsName: string,\n        data?: Record<string, string | number | boolean | undefined>,\n    ): Promise<void> {\n        data = data || {};\n        data.id = itemId;\n        data.name = itemName;\n        data.category = itemCategory;\n        data.moodleaction = wsName;\n\n        // eslint-disable-next-line deprecation/deprecation\n        return this.logEvent('view_item', data);\n    }\n\n    /**\n     * Log an analytics view item list event.\n     *\n     * @param itemCategory The item category.\n     * @param wsName Name of the WS.\n     * @param data Other data to pass to the event.\n     * @returns Promise resolved when done. This promise is never rejected.\n     * @deprecated since 4.3. Use CoreAnalytics.logEvent instead.\n     */\n    logViewListEvent(\n        itemCategory: string,\n        wsName: string,\n        data?: Record<string, string | number | boolean | undefined>,\n    ): Promise<void> {\n        data = data || {};\n        data.moodleaction = wsName;\n        data.category = itemCategory;\n\n        // eslint-disable-next-line deprecation/deprecation\n        return this.logEvent('view_item_list', data);\n    }\n\n    /**\n     * Function called when a push notification is clicked. Redirect the user to the right state.\n     *\n     * @param data Notification data.\n     * @returns Promise resolved when done.\n     */\n    async notificationClicked(data: CorePushNotificationsNotificationBasicData): Promise<void> {\n        await ApplicationInit.donePromise;\n\n        CorePushNotificationsDelegate.clicked(data);\n    }\n\n    /**\n     * This function is called when we receive a Notification from APNS or a message notification from GCM.\n     * The app can be in foreground or background,\n     * if we are in background this code is executed when we open the app clicking in the notification bar.\n     *\n     * @param notification Notification received.\n     * @returns Promise resolved when done.\n     */\n    async onMessageReceived(notification: NotificationEventResponse): Promise<void> {\n        const rawData: CorePushNotificationsNotificationBasicRawData = notification ? notification.additionalData : {};\n\n        // Parse some fields and add some extra data.\n        const data: CorePushNotificationsNotificationBasicData = Object.assign(rawData, {\n            title: notification.title,\n            message: notification.message,\n            customdata: typeof rawData.customdata == 'string' ?\n                CoreTextUtils.parseJSON<Record<string, string|number>>(rawData.customdata, {}) : rawData.customdata,\n        });\n\n        let site: CoreSite | undefined;\n\n        if (data.site) {\n            site = await CoreSites.getSite(data.site);\n        } else if (data.siteurl) {\n            site = await CoreSites.getSiteByUrl(data.siteurl);\n        }\n\n        data.site = site?.getId();\n\n        if (!CoreUtils.isTrueOrOne(data.foreground)) {\n            // The notification was clicked.\n            return this.notificationClicked(data);\n        }\n\n        const localNotif: ILocalNotification = {\n            id: Number(data.notId) || 1,\n            data: data,\n            title: notification.title,\n            text: notification.message,\n            channel: 'PushPluginChannel',\n        };\n        const isAndroid = CorePlatform.isAndroid();\n        const extraFeatures = CoreUtils.isTrueOrOne(data.extrafeatures);\n\n        if (extraFeatures && isAndroid && CoreUtils.isFalseOrZero(data.notif)) {\n            // It's a message, use messaging style. Ionic Native doesn't specify this option.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (<any> localNotif).text = [\n                {\n                    message: notification.message,\n                    person: data.sender ?? (data.conversationtype == '2' ? data.userfromfullname : ''),\n                    personIcon: data.senderImage,\n                },\n            ];\n        }\n\n        if (extraFeatures && isAndroid) {\n            // Use a different icon if needed.\n            localNotif.icon = notification.image;\n            // This feature isn't supported by the official plugin, we use a fork.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (<any> localNotif).iconType = data['image-type'];\n\n            localNotif.summary = data.summaryText;\n\n            if (data.picture) {\n                localNotif.attachments = [data.picture];\n            }\n        }\n\n        CoreLocalNotifications.schedule(localNotif, CorePushNotificationsProvider.COMPONENT, data.site || '', true);\n\n        await this.notifyReceived(notification, data);\n\n    }\n\n    /**\n     * Notify that a notification was received.\n     *\n     * @param notification Notification.\n     * @param data Notification data.\n     * @returns Promise resolved when done.\n     */\n    protected async notifyReceived(\n        notification: NotificationEventResponse,\n        data: CorePushNotificationsNotificationBasicData,\n    ): Promise<void> {\n        await ApplicationInit.donePromise;\n\n        CorePushNotificationsDelegate.received(data);\n    }\n\n    /**\n     * Unregisters a device from a certain Moodle site.\n     *\n     * @param site Site to unregister from.\n     * @returns Promise resolved when device is unregistered.\n     */\n    async unregisterDeviceOnMoodle(site: CoreSite): Promise<void> {\n        if (!site || !CorePlatform.isMobile()) {\n            throw new CoreError('Cannot unregister device');\n        }\n\n        this.logger.debug(`Unregister device on Moodle: '${site.getId()}'`);\n\n        const data: CoreUserRemoveUserDeviceWSParams = {\n            appid: CoreConstants.CONFIG.app_id,\n            uuid:  Device.uuid,\n        };\n        let response: CoreUserRemoveUserDeviceWSResponse;\n\n        try {\n            response = await site.write<CoreUserRemoveUserDeviceWSResponse>('core_user_remove_user_device', data);\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error) || CoreUtils.isExpiredTokenError(error)) {\n                // Cannot unregister. Don't try again.\n                await CoreUtils.ignoreErrors(this.pendingUnregistersTable.delete({\n                    token: site.getToken(),\n                    siteid: site.getId(),\n                }));\n\n                throw error;\n            }\n\n            // Store the pending unregister so it's retried again later.\n            await this.pendingUnregistersTable.insert({\n                siteid: site.getId(),\n                siteurl: site.getURL(),\n                token: site.getToken(),\n                info: JSON.stringify(site.getInfo()),\n            });\n\n            return;\n        }\n\n        if (!response.removed) {\n            throw new CoreError('Cannot unregister device');\n        }\n\n        await CoreUtils.ignoreErrors(Promise.all([\n            // Remove the device from the local DB.\n            this.registeredDevicesTables[site.getId()].delete(this.getRequiredRegisterData()),\n            // Remove pending unregisters for this site.\n            this.pendingUnregistersTable.deleteByPrimaryKey({ siteid: site.getId() }),\n        ]));\n    }\n\n    /**\n     * Update Counter for an addon. It will update the refered siteId counter and the total badge.\n     * It will return the updated addon counter.\n     *\n     * @param addon Registered addon name to set the badge number.\n     * @param value The number to be stored.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved with the stored badge counter for the addon on the site.\n     */\n    async updateAddonCounter(addon: string, value: number, siteId?: string): Promise<number> {\n        if (!CorePushNotificationsDelegate.isCounterHandlerRegistered(addon)) {\n            return 0;\n        }\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await this.saveAddonBadge(value, siteId, addon);\n        await this.updateSiteCounter(siteId);\n\n        return value;\n    }\n\n    /**\n     * Update total badge counter of the app.\n     *\n     * @returns Promise resolved with the stored badge counter for the site.\n     */\n    async updateAppCounter(): Promise<number> {\n        const sitesIds = await CoreSites.getSitesIds();\n\n        const counters = await Promise.all(sitesIds.map((siteId) => this.getAddonBadge(siteId)));\n\n        const total = counters.reduce((previous, counter) => previous + counter, 0);\n\n        if (CorePlatform.isMobile()) {\n            // Set the app badge on mobile.\n            await Badge.set(total);\n        }\n\n        return total;\n    }\n\n    /**\n     * Update counter for a site using the stored addon data. It will update the total badge application number.\n     * It will return the updated site counter.\n     *\n     * @param siteId Site ID.\n     * @returns Promise resolved with the stored badge counter for the site.\n     */\n    async updateSiteCounter(siteId: string): Promise<number> {\n        const addons = CorePushNotificationsDelegate.getCounterHandlers();\n\n        const counters = await Promise.all(Object.values(addons).map((addon) => this.getAddonBadge(siteId, addon)));\n\n        const total = counters.reduce((previous, counter) => previous + counter, 0);\n\n        // Save the counter on site.\n        await this.saveAddonBadge(total, siteId);\n\n        await this.updateAppCounter();\n\n        return total;\n    }\n\n    /**\n     * Register a device in Apple APNS or Google GCM.\n     *\n     * @returns Promise resolved when the device is registered.\n     */\n    async registerDevice(): Promise<void> {\n        try {\n            // Check if sound is enabled for notifications.\n            const options = await this.getOptions();\n\n            const pushObject = Push.init(options);\n\n            pushObject.on('notification').subscribe((notification: NotificationEventResponse | {registrationType: string}) => {\n                // Execute the callback in the Angular zone, so change detection doesn't stop working.\n                NgZone.run(() => {\n                    if ('registrationType' in notification) {\n                        // Not a valid notification, ignore.\n                        return;\n                    }\n\n                    this.logger.log('Received a notification', notification);\n                    this.onMessageReceived(notification);\n                });\n            });\n\n            pushObject.on('registration').subscribe((data: RegistrationEventResponse) => {\n                // Execute the callback in the Angular zone, so change detection doesn't stop working.\n                NgZone.run(() => {\n                    this.pushID = data.registrationId;\n                    if (!CoreSites.isLoggedIn() || !this.canRegisterOnMoodle()) {\n                        return;\n                    }\n\n                    this.registerDeviceOnMoodle().catch((error) => {\n                        this.logger.error('Can\\'t register device', error);\n                    });\n                });\n            });\n\n            pushObject.on('error').subscribe((error: Error) => {\n                // Execute the callback in the Angular zone, so change detection doesn't stop working.\n                NgZone.run(() => {\n                    this.logger.warn('Error with Push plugin', error);\n                });\n            });\n        } catch (error) {\n            this.logger.warn(error);\n\n            throw error;\n        }\n    }\n\n    /**\n     * Registers a device on a Moodle site if needed.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @param forceUnregister Whether to force unregister and register.\n     * @returns Promise resolved when device is registered.\n     */\n    async registerDeviceOnMoodle(siteId?: string, forceUnregister?: boolean): Promise<void> {\n        this.logger.debug('Register device on Moodle.');\n\n        if (!this.canRegisterOnMoodle()) {\n            return Promise.reject(null);\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        try {\n\n            const data = this.getRequiredRegisterData();\n            data.publickey = await this.getPublicKeyForSite(site);\n\n            const neededActions = await this.getRegisterDeviceActions(data, site, forceUnregister);\n\n            if (neededActions.unregister) {\n                // Unregister the device first.\n                await CoreUtils.ignoreErrors(this.unregisterDeviceOnMoodle(site));\n            }\n\n            if (neededActions.register) {\n                // Now register the device.\n                const addDeviceResponse =\n                    await site.write<CoreUserAddUserDeviceWSResponse>('core_user_add_user_device', CoreUtils.clone(data));\n\n                const deviceAlreadyRegistered =\n                    addDeviceResponse[0] && addDeviceResponse[0].find(warning => warning.warningcode === 'existingkeyforthisuser');\n                if (deviceAlreadyRegistered && data.publickey) {\n                    // Device already registered, make sure the public key is up to date.\n                    await this.updatePublicKeyOnMoodle(site, data);\n                }\n\n                CoreEvents.trigger(CoreEvents.DEVICE_REGISTERED_IN_MOODLE, {}, site.getId());\n\n                // Insert the device in the local DB.\n                await CoreUtils.ignoreErrors(this.registeredDevicesTables[site.getId()].insert(data));\n            } else if (neededActions.updatePublicKey) {\n                // Device already registered, make sure the public key is up to date.\n                const response = await this.updatePublicKeyOnMoodle(site, data);\n\n                if (response?.warnings?.find(warning => warning.warningcode === 'devicedoesnotexist')) {\n                    // The device doesn't exist in the server. Remove the device from the local DB and try again.\n                    await this.registeredDevicesTables[site.getId()].delete({\n                        appid: data.appid,\n                        uuid: data.uuid,\n                        name: data.name,\n                        model: data.model,\n                        platform: data.platform,\n                    });\n\n                    await this.registerDeviceOnMoodle(siteId, false);\n                }\n            }\n        } finally {\n            // Remove pending unregisters for this site.\n            await CoreUtils.ignoreErrors(this.pendingUnregistersTable.deleteByPrimaryKey({ siteid: site.getId() }));\n        }\n    }\n\n    /**\n     * Get the public key to register in a site.\n     *\n     * @param site Site to register\n     * @returns Public key, undefined if the site or the device doesn't support encryption.\n     */\n    protected async getPublicKeyForSite(site: CoreSite): Promise<string | undefined> {\n        if (!site.wsAvailable('core_user_update_user_device_public_key')) {\n            return;\n        }\n\n        return await this.getPublicKey();\n    }\n\n    /**\n     * Get the device public key.\n     *\n     * @returns Public key, undefined if the device doesn't support encryption.\n     */\n    async getPublicKey(): Promise<string | undefined> {\n        if (!CorePlatform.isMobile()) {\n            return;\n        }\n\n        const publicKey = await Push.getPublicKey();\n\n        return publicKey ?? undefined;\n    }\n\n    /**\n     * Update a public key on a Moodle site.\n     *\n     * @param site Site.\n     * @param data Device data.\n     * @returns WS response, undefined if no public key.\n     */\n    protected async updatePublicKeyOnMoodle(\n        site: CoreSite,\n        data: CoreUserAddUserDeviceWSParams,\n    ): Promise<CoreUserUpdateUserDevicePublicKeyWSResponse | undefined> {\n        if (!data.publickey) {\n            return;\n        }\n\n        this.logger.debug('Update public key on Moodle.');\n\n        const params: CoreUserUpdateUserDevicePublicKeyWSParams = {\n            uuid: data.uuid,\n            appid: data.appid,\n            publickey: data.publickey,\n        };\n\n        return await site.write<CoreUserUpdateUserDevicePublicKeyWSResponse>('core_user_update_user_device_public_key', params);\n    }\n\n    /**\n     * Get the addon/site badge counter from the database.\n     *\n     * @param siteId Site ID.\n     * @param addon Registered addon name. If not defined it will store the site total.\n     * @returns Promise resolved with the stored badge counter for the addon or site or 0 if none.\n     */\n    protected async getAddonBadge(siteId?: string, addon: string = 'site'): Promise<number> {\n        try {\n            const entry = await this.badgesTable.getOne({ siteid: siteId, addon });\n\n            return entry?.number || 0;\n        } catch (err) {\n            return 0;\n        }\n    }\n\n    /**\n     * Retry pending unregisters.\n     *\n     * @param siteId If defined, retry only for that site if needed. Otherwise, retry all pending unregisters.\n     * @returns Promise resolved when done.\n     */\n    async retryUnregisters(siteId?: string): Promise<void> {\n        const results = await this.pendingUnregistersTable.getMany(CoreObject.withoutEmpty({ siteid: siteId }));\n\n        await Promise.all(results.map(async (result) => {\n            // Create a temporary site to unregister.\n            const tmpSite = CoreSitesFactory.makeSite(\n                result.siteid,\n                result.siteurl,\n                result.token,\n                { info: CoreTextUtils.parseJSON<CoreSiteInfo | null>(result.info, null) || undefined },\n            );\n\n            await this.unregisterDeviceOnMoodle(tmpSite);\n        }));\n    }\n\n    /**\n     * Save the addon/site badgecounter on the database.\n     *\n     * @param value The number to be stored.\n     * @param siteId Site ID. If not defined, use current site.\n     * @param addon Registered addon name. If not defined it will store the site total.\n     * @returns Promise resolved with the stored badge counter for the addon or site.\n     */\n    protected async saveAddonBadge(value: number, siteId?: string, addon: string = 'site'): Promise<number> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await this.badgesTable.insert({\n            siteid: siteId,\n            addon,\n            number: value, // eslint-disable-line id-blacklist\n        });\n\n        return value;\n    }\n\n    /**\n     * Get the needed actions to perform to register a device.\n     *\n     * @param data Data of the device.\n     * @param site Site to use.\n     * @param forceUnregister Whether to force unregister and register.\n     * @returns Whether each action needs to be performed or not.\n     */\n    protected async getRegisterDeviceActions(\n        data: CoreUserAddUserDeviceWSParams,\n        site: CoreSite,\n        forceUnregister?: boolean,\n    ): Promise<RegisterDeviceActions> {\n        if (forceUnregister) {\n            // No need to check if device is stored, always unregister and register the device.\n            return {\n                unregister: true,\n                register: true,\n                updatePublicKey: false,\n            };\n        }\n\n        // Check if the device is already registered.\n        const records = await CoreUtils.ignoreErrors(\n            this.registeredDevicesTables[site.getId()].getMany({\n                appid: data.appid,\n                uuid: data.uuid,\n                name: data.name,\n                model: data.model,\n                platform: data.platform,\n            }),\n        );\n\n        let isStored = false;\n        let versionOrPushChanged = false;\n        let updatePublicKey = false;\n\n        (records || []).forEach((record) => {\n            if (record.version == data.version && record.pushid == data.pushid) {\n                // The device is already stored.\n                isStored = true;\n                updatePublicKey = !!data.publickey && record.publickey !== data.publickey;\n            } else {\n                // The version or pushid has changed.\n                versionOrPushChanged = true;\n            }\n        });\n\n        return {\n            register: !isStored, // No need to register if device is already stored.\n            unregister: !isStored && !versionOrPushChanged, // No need to unregister first if only version or push changed.\n            updatePublicKey,\n        };\n    }\n\n}\n\nexport const CorePushNotifications = makeSingleton(CorePushNotificationsProvider);\n\n/**\n * Additional data sent in push notifications.\n */\nexport type CorePushNotificationsNotificationBasicRawData = {\n    customdata?: string; // Custom data.\n    extrafeatures?: string; // \"1\" if the notification uses extrafeatures, \"0\" otherwise.\n    foreground?: boolean; // Whether the app was in foreground.\n    'image-type'?: string; // How to display the notification image.\n    moodlecomponent?: string; // Moodle component that triggered the notification.\n    name?: string; // A name to identify the type of notification.\n    notId?: string; // Notification ID.\n    notif?: string; // \"1\" if it's a notification, \"0\" if it's a Moodle message.\n    site?: string; // ID of the site sending the notification.\n    siteurl?: string; // URL of the site the notification is related to.\n    usertoid?: string; // ID of user receiving the push.\n    conversationtype?: string; // Conversation type. Only if it's a push generated by a Moodle message.\n    userfromfullname?: string; // Fullname of user sending the push. Only if it's a push generated by a Moodle message.\n    userfromid?: string; // ID of user sending the push. Only if it's a push generated by a Moodle message.\n    picture?: string; // Notification big picture. \"Extra\" feature.\n    summaryText?: string; // Notification summary text. \"Extra\" feature.\n    sender?: string; // Name of the user who sent the message. \"Extra\" feature.\n    senderImage?: string; // Image of the user who sent the message. \"Extra\" feature.\n};\n\n/**\n * Additional data sent in push notifications, with some calculated data.\n */\nexport type CorePushNotificationsNotificationBasicData = Omit<CorePushNotificationsNotificationBasicRawData, 'customdata'> & {\n    title?: string; // Notification title.\n    message?: string; // Notification message.\n    customdata?: Record<string, string|number>; // Parsed custom data.\n};\n\n/**\n * Params of core_user_remove_user_device WS.\n */\nexport type CoreUserRemoveUserDeviceWSParams = {\n    uuid: string; // The device UUID.\n    appid?: string; // The app id, if empty devices matching the UUID for the user will be removed.\n};\n\n/**\n * Data returned by core_user_remove_user_device WS.\n */\nexport type CoreUserRemoveUserDeviceWSResponse = {\n    removed: boolean; // True if removed, false if not removed because it doesn't exists.\n    warnings?: CoreWSExternalWarning[];\n};\n/**\n * Params of core_user_add_user_device WS.\n */\nexport type CoreUserAddUserDeviceWSParams = {\n    appid: string; // The app id, usually something like com.moodle.moodlemobile.\n    name: string; // The device name, 'occam' or 'iPhone' etc.\n    model: string; // The device model 'Nexus4' or 'iPad1,1' etc.\n    platform: string; // The device platform 'iOS' or 'Android' etc.\n    version: string; // The device version '6.1.2' or '4.2.2' etc.\n    pushid: string; // The device PUSH token/key/identifier/registration id.\n    uuid: string; // The device UUID.\n    publickey?: string; // @since 4.2. The app generated public key.\n};\n\n/**\n * Data returned by core_user_add_user_device WS.\n */\nexport type CoreUserAddUserDeviceWSResponse = CoreWSExternalWarning[][];\n\n/**\n * Params of core_user_update_user_device_public_key WS.\n */\nexport type CoreUserUpdateUserDevicePublicKeyWSParams = {\n    uuid: string;\n    appid: string;\n    publickey: string;\n};\n\n/**\n * Data returned by core_user_update_user_device_public_key WS.\n */\nexport type CoreUserUpdateUserDevicePublicKeyWSResponse = {\n    status: boolean;\n    warnings?: CoreWSExternalWarning[];\n};\n\ntype RegisterDeviceActions = {\n    register: boolean; // Whether device needs to be registered in LMS.\n    unregister: boolean; // Whether device needs to be unregistered before register in LMS to make sure data is up to date.\n    updatePublicKey: boolean; // Whether only public key needs to be updated.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}