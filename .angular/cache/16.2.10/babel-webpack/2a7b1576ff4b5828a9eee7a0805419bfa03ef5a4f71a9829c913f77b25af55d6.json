{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport moment from 'moment-timezone';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\n// Cache key was maintained from block myoverview when blocks were splitted.\nconst ROOT_CACHE_KEY = 'myoverview:';\n/**\n * Service that provides some features regarding course overview.\n */\nexport class AddonBlockTimelineProvider {\n  /**\n   * Get calendar action events for the given course.\n   *\n   * @param courseId Only events in this course.\n   * @param afterEventId The last seen event id.\n   * @param searchValue The value a user wishes to search against.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getActionEventsByCourse(courseId, afterEventId, searchValue = '', siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const time = _this.getDayStart(-14); // Check two weeks ago.\n      const data = {\n        timesortfrom: time,\n        courseid: courseId,\n        limitnum: AddonBlockTimelineProvider.EVENTS_LIMIT_PER_COURSE\n      };\n      if (afterEventId) {\n        data.aftereventid = afterEventId;\n      }\n      const preSets = {\n        cacheKey: _this.getActionEventsByCourseCacheKey(courseId)\n      };\n      if (searchValue != '') {\n        data.searchvalue = searchValue;\n        preSets.getFromCache = false;\n      }\n      const courseEvents = yield site.read('core_calendar_get_action_events_by_course', data, preSets);\n      return _this.treatCourseEvents(courseEvents, time);\n    })();\n  }\n  /**\n   * Get cache key for get calendar action events for the given course value WS call.\n   *\n   * @param courseId Only events in this course.\n   * @returns Cache key.\n   */\n  getActionEventsByCourseCacheKey(courseId) {\n    return this.getActionEventsByCoursesCacheKey() + ':' + courseId;\n  }\n  /**\n   * Get calendar action events for a given list of courses.\n   *\n   * @param courseIds Course IDs.\n   * @param searchValue The value a user wishes to search against.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getActionEventsByCourses(courseIds, searchValue = '', siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (courseIds.length === 0) {\n        return {};\n      }\n      const site = yield CoreSites.getSite(siteId);\n      const time = _this2.getDayStart(-14); // Check two weeks ago.\n      const data = {\n        timesortfrom: time,\n        courseids: courseIds,\n        limitnum: AddonBlockTimelineProvider.EVENTS_LIMIT_PER_COURSE\n      };\n      const preSets = {\n        cacheKey: _this2.getActionEventsByCoursesCacheKey()\n      };\n      if (searchValue != '') {\n        data.searchvalue = searchValue;\n        preSets.getFromCache = false;\n      }\n      const events = yield site.read('core_calendar_get_action_events_by_courses', data, preSets);\n      const courseEvents = {};\n      events.groupedbycourse.forEach(course => {\n        courseEvents[course.courseid] = _this2.treatCourseEvents(course, time);\n      });\n      return courseEvents;\n    })();\n  }\n  /**\n   * Get cache key for get calendar action events for a given list of courses value WS call.\n   *\n   * @returns Cache key.\n   */\n  getActionEventsByCoursesCacheKey() {\n    return ROOT_CACHE_KEY + 'bycourse';\n  }\n  /**\n   * Get calendar action events based on the timesort value.\n   *\n   * @param afterEventId The last seen event id.\n   * @param searchValue The value a user wishes to search against.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved when the info is retrieved.\n   */\n  getActionEventsByTimesort(afterEventId, searchValue = '', siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const timesortfrom = _this3.getDayStart(-14); // Check two weeks ago.\n      const limitnum = AddonBlockTimelineProvider.EVENTS_LIMIT;\n      const data = {\n        timesortfrom,\n        limitnum,\n        limittononsuspendedevents: true\n      };\n      if (afterEventId) {\n        data.aftereventid = afterEventId;\n      }\n      const preSets = {\n        cacheKey: _this3.getActionEventsByTimesortCacheKey(afterEventId, limitnum),\n        getCacheUsingCacheKey: true,\n        uniqueCacheKey: true\n      };\n      if (searchValue != '') {\n        data.searchvalue = searchValue;\n        preSets.getFromCache = false;\n        preSets.cacheKey += ':' + searchValue;\n      }\n      const result = yield site.read('core_calendar_get_action_events_by_timesort', data, preSets);\n      const canLoadMore = result.events.length >= limitnum ? result.lastid : undefined;\n      // Filter events by time in case it uses cache.\n      const events = result.events.filter(element => element.timesort >= timesortfrom);\n      return {\n        events,\n        canLoadMore\n      };\n    })();\n  }\n  /**\n   * Get prefix cache key for calendar action events based on the timesort value WS calls.\n   *\n   * @returns Cache key.\n   */\n  getActionEventsByTimesortPrefixCacheKey() {\n    return ROOT_CACHE_KEY + 'bytimesort:';\n  }\n  /**\n   * Get cache key for get calendar action events based on the timesort value WS call.\n   *\n   * @param afterEventId The last seen event id.\n   * @param limit Limit num of the call.\n   * @returns Cache key.\n   */\n  getActionEventsByTimesortCacheKey(afterEventId, limit) {\n    afterEventId = afterEventId || 0;\n    limit = limit || 0;\n    return this.getActionEventsByTimesortPrefixCacheKey() + afterEventId + ':' + limit;\n  }\n  /**\n   * Invalidates get calendar action events for a given list of courses WS call.\n   *\n   * @param siteId Site ID to invalidate. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateActionEventsByCourses(siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this4.getActionEventsByCoursesCacheKey());\n    })();\n  }\n  /**\n   * Invalidates get calendar action events based on the timesort value WS call.\n   *\n   * @param siteId Site ID to invalidate. If not defined, use current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateActionEventsByTimesort(siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this5.getActionEventsByTimesortPrefixCacheKey());\n    })();\n  }\n  /**\n   * Handles course events, filtering and treating if more can be loaded.\n   *\n   * @param course Object containing response course events info.\n   * @param timeFrom Current time to filter events from.\n   * @returns Object with course events and last loaded event id if more can be loaded.\n   */\n  treatCourseEvents(course, timeFrom) {\n    const canLoadMore = course.events.length >= AddonBlockTimelineProvider.EVENTS_LIMIT_PER_COURSE ? course.lastid : undefined;\n    // Filter events by time in case it uses cache.\n    course.events = course.events.filter(element => element.timesort >= timeFrom);\n    return {\n      events: course.events,\n      canLoadMore\n    };\n  }\n  /**\n   * Returns the timestamp at the start of the day with an optional offset.\n   *\n   * @param daysOffset Offset days to add or substract.\n   * @returns timestamp.\n   */\n  getDayStart(daysOffset = 0) {\n    return moment().startOf('day').add(daysOffset, 'days').unix();\n  }\n}\n_class = AddonBlockTimelineProvider;\n_class.EVENTS_LIMIT = 20;\n_class.EVENTS_LIMIT_PER_COURSE = 10;\n_class.ɵfac = function AddonBlockTimelineProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonBlockTimeline = makeSingleton(AddonBlockTimelineProvider);","map":{"version":3,"names":["CoreSites","moment","makeSingleton","ROOT_CACHE_KEY","AddonBlockTimelineProvider","getActionEventsByCourse","courseId","afterEventId","searchValue","siteId","_this","_asyncToGenerator","site","getSite","time","getDayStart","data","timesortfrom","courseid","limitnum","EVENTS_LIMIT_PER_COURSE","aftereventid","preSets","cacheKey","getActionEventsByCourseCacheKey","searchvalue","getFromCache","courseEvents","read","treatCourseEvents","getActionEventsByCoursesCacheKey","getActionEventsByCourses","courseIds","_this2","length","courseids","events","groupedbycourse","forEach","course","getActionEventsByTimesort","_this3","EVENTS_LIMIT","limittononsuspendedevents","getActionEventsByTimesortCacheKey","getCacheUsingCacheKey","uniqueCacheKey","result","canLoadMore","lastid","undefined","filter","element","timesort","getActionEventsByTimesortPrefixCacheKey","limit","invalidateActionEventsByCourses","_this4","invalidateWsCacheForKeyStartingWith","invalidateActionEventsByTimesort","_this5","timeFrom","daysOffset","startOf","add","unix","_class","factory","ɵfac","providedIn","AddonBlockTimeline"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/block/timeline/services/timeline.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport {\n    AddonCalendarEvents,\n    AddonCalendarEventsGroupedByCourse,\n    AddonCalendarEvent,\n    AddonCalendarGetActionEventsByCourseWSParams,\n    AddonCalendarGetActionEventsByTimesortWSParams,\n    AddonCalendarGetActionEventsByCoursesWSParams,\n} from '@addons/calendar/services/calendar';\nimport moment from 'moment-timezone';\nimport { makeSingleton } from '@singletons';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\n// Cache key was maintained from block myoverview when blocks were splitted.\nconst ROOT_CACHE_KEY = 'myoverview:';\n\n/**\n * Service that provides some features regarding course overview.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonBlockTimelineProvider {\n\n    static readonly EVENTS_LIMIT = 20;\n    static readonly EVENTS_LIMIT_PER_COURSE = 10;\n\n    /**\n     * Get calendar action events for the given course.\n     *\n     * @param courseId Only events in this course.\n     * @param afterEventId The last seen event id.\n     * @param searchValue The value a user wishes to search against.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getActionEventsByCourse(\n        courseId: number,\n        afterEventId?: number,\n        searchValue = '',\n        siteId?: string,\n    ): Promise<{ events: AddonCalendarEvent[]; canLoadMore?: number }> {\n        const site = await CoreSites.getSite(siteId);\n\n        const time = this.getDayStart(-14); // Check two weeks ago.\n\n        const data: AddonCalendarGetActionEventsByCourseWSParams = {\n            timesortfrom: time,\n            courseid: courseId,\n            limitnum: AddonBlockTimelineProvider.EVENTS_LIMIT_PER_COURSE,\n        };\n        if (afterEventId) {\n            data.aftereventid = afterEventId;\n        }\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getActionEventsByCourseCacheKey(courseId),\n        };\n\n        if (searchValue != '') {\n            data.searchvalue = searchValue;\n            preSets.getFromCache = false;\n        }\n\n        const courseEvents = await site.read<AddonCalendarEvents>(\n            'core_calendar_get_action_events_by_course',\n            data,\n            preSets,\n        );\n\n        return this.treatCourseEvents(courseEvents, time);\n    }\n\n    /**\n     * Get cache key for get calendar action events for the given course value WS call.\n     *\n     * @param courseId Only events in this course.\n     * @returns Cache key.\n     */\n    protected getActionEventsByCourseCacheKey(courseId: number): string {\n        return this.getActionEventsByCoursesCacheKey() + ':' + courseId;\n    }\n\n    /**\n     * Get calendar action events for a given list of courses.\n     *\n     * @param courseIds Course IDs.\n     * @param searchValue The value a user wishes to search against.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getActionEventsByCourses(\n        courseIds: number[],\n        searchValue = '',\n        siteId?: string,\n    ): Promise<{[courseId: string]: { events: AddonCalendarEvent[]; canLoadMore?: number } }> {\n        if (courseIds.length === 0) {\n            return {};\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        const time = this.getDayStart(-14); // Check two weeks ago.\n\n        const data: AddonCalendarGetActionEventsByCoursesWSParams = {\n            timesortfrom: time,\n            courseids: courseIds,\n            limitnum: AddonBlockTimelineProvider.EVENTS_LIMIT_PER_COURSE,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getActionEventsByCoursesCacheKey(),\n        };\n\n        if (searchValue != '') {\n            data.searchvalue = searchValue;\n            preSets.getFromCache = false;\n        }\n\n        const events = await site.read<AddonCalendarEventsGroupedByCourse>(\n            'core_calendar_get_action_events_by_courses',\n            data,\n            preSets,\n        );\n\n        const courseEvents: {[courseId: string]: { events: AddonCalendarEvent[]; canLoadMore?: number } } = {};\n\n        events.groupedbycourse.forEach((course) => {\n            courseEvents[course.courseid] = this.treatCourseEvents(course, time);\n        });\n\n        return courseEvents;\n    }\n\n    /**\n     * Get cache key for get calendar action events for a given list of courses value WS call.\n     *\n     * @returns Cache key.\n     */\n    protected getActionEventsByCoursesCacheKey(): string {\n        return ROOT_CACHE_KEY + 'bycourse';\n    }\n\n    /**\n     * Get calendar action events based on the timesort value.\n     *\n     * @param afterEventId The last seen event id.\n     * @param searchValue The value a user wishes to search against.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved when the info is retrieved.\n     */\n    async getActionEventsByTimesort(\n        afterEventId?: number,\n        searchValue = '',\n        siteId?: string,\n    ): Promise<{ events: AddonCalendarEvent[]; canLoadMore?: number }> {\n        const site = await CoreSites.getSite(siteId);\n\n        const timesortfrom = this.getDayStart(-14); // Check two weeks ago.\n        const limitnum = AddonBlockTimelineProvider.EVENTS_LIMIT;\n\n        const data: AddonCalendarGetActionEventsByTimesortWSParams = {\n            timesortfrom,\n            limitnum,\n            limittononsuspendedevents: true,\n        };\n        if (afterEventId) {\n            data.aftereventid = afterEventId;\n        }\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getActionEventsByTimesortCacheKey(afterEventId, limitnum),\n            getCacheUsingCacheKey: true,\n            uniqueCacheKey: true,\n        };\n\n        if (searchValue != '') {\n            data.searchvalue = searchValue;\n            preSets.getFromCache = false;\n            preSets.cacheKey += ':' + searchValue;\n        }\n\n        const result = await site.read<AddonCalendarEvents>(\n            'core_calendar_get_action_events_by_timesort',\n            data,\n            preSets,\n        );\n\n        const canLoadMore = result.events.length >= limitnum ? result.lastid : undefined;\n\n        // Filter events by time in case it uses cache.\n        const events = result.events.filter((element) => element.timesort >= timesortfrom);\n\n        return {\n            events,\n            canLoadMore,\n        };\n    }\n\n    /**\n     * Get prefix cache key for calendar action events based on the timesort value WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getActionEventsByTimesortPrefixCacheKey(): string {\n        return ROOT_CACHE_KEY + 'bytimesort:';\n    }\n\n    /**\n     * Get cache key for get calendar action events based on the timesort value WS call.\n     *\n     * @param afterEventId The last seen event id.\n     * @param limit Limit num of the call.\n     * @returns Cache key.\n     */\n    protected getActionEventsByTimesortCacheKey(afterEventId?: number, limit?: number): string {\n        afterEventId = afterEventId || 0;\n        limit = limit || 0;\n\n        return this.getActionEventsByTimesortPrefixCacheKey() + afterEventId + ':' + limit;\n    }\n\n    /**\n     * Invalidates get calendar action events for a given list of courses WS call.\n     *\n     * @param siteId Site ID to invalidate. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateActionEventsByCourses(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getActionEventsByCoursesCacheKey());\n    }\n\n    /**\n     * Invalidates get calendar action events based on the timesort value WS call.\n     *\n     * @param siteId Site ID to invalidate. If not defined, use current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateActionEventsByTimesort(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getActionEventsByTimesortPrefixCacheKey());\n    }\n\n    /**\n     * Handles course events, filtering and treating if more can be loaded.\n     *\n     * @param course Object containing response course events info.\n     * @param timeFrom Current time to filter events from.\n     * @returns Object with course events and last loaded event id if more can be loaded.\n     */\n    protected treatCourseEvents(\n        course: AddonCalendarEvents,\n        timeFrom: number,\n    ): { events: AddonCalendarEvent[]; canLoadMore?: number } {\n\n        const canLoadMore: number | undefined =\n            course.events.length >= AddonBlockTimelineProvider.EVENTS_LIMIT_PER_COURSE ? course.lastid : undefined;\n\n        // Filter events by time in case it uses cache.\n        course.events = course.events.filter((element) => element.timesort >= timeFrom);\n\n        return {\n            events: course.events,\n            canLoadMore,\n        };\n    }\n\n    /**\n     * Returns the timestamp at the start of the day with an optional offset.\n     *\n     * @param daysOffset Offset days to add or substract.\n     * @returns timestamp.\n     */\n    getDayStart(daysOffset = 0): number {\n        return moment().startOf('day').add(daysOffset, 'days').unix();\n    }\n\n}\n\nexport const AddonBlockTimeline = makeSingleton(AddonBlockTimelineProvider);\n"],"mappings":";;AAeA,SAASA,SAAS,QAAQ,iBAAiB;AAS3C,OAAOC,MAAM,MAAM,iBAAiB;AACpC,SAASC,aAAa,QAAQ,aAAa;;AAG3C;AACA,MAAMC,cAAc,GAAG,aAAa;AAEpC;;;AAIA,OAAM,MAAOC,0BAA0B;EAKnC;;;;;;;;;EASMC,uBAAuBA,CACzBC,QAAgB,EAChBC,YAAqB,EACrBC,WAAW,GAAG,EAAE,EAChBC,MAAe;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAEf,MAAMC,IAAI,SAASZ,SAAS,CAACa,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMK,IAAI,GAAGJ,KAAI,CAACK,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAEpC,MAAMC,IAAI,GAAiD;QACvDC,YAAY,EAAEH,IAAI;QAClBI,QAAQ,EAAEZ,QAAQ;QAClBa,QAAQ,EAAEf,0BAA0B,CAACgB;OACxC;MACD,IAAIb,YAAY,EAAE;QACdS,IAAI,CAACK,YAAY,GAAGd,YAAY;;MAGpC,MAAMe,OAAO,GAAsB;QAC/BC,QAAQ,EAAEb,KAAI,CAACc,+BAA+B,CAAClB,QAAQ;OAC1D;MAED,IAAIE,WAAW,IAAI,EAAE,EAAE;QACnBQ,IAAI,CAACS,WAAW,GAAGjB,WAAW;QAC9Bc,OAAO,CAACI,YAAY,GAAG,KAAK;;MAGhC,MAAMC,YAAY,SAASf,IAAI,CAACgB,IAAI,CAChC,2CAA2C,EAC3CZ,IAAI,EACJM,OAAO,CACV;MAED,OAAOZ,KAAI,CAACmB,iBAAiB,CAACF,YAAY,EAAEb,IAAI,CAAC;IAAC;EACtD;EAEA;;;;;;EAMUU,+BAA+BA,CAAClB,QAAgB;IACtD,OAAO,IAAI,CAACwB,gCAAgC,EAAE,GAAG,GAAG,GAAGxB,QAAQ;EACnE;EAEA;;;;;;;;EAQMyB,wBAAwBA,CAC1BC,SAAmB,EACnBxB,WAAW,GAAG,EAAE,EAChBC,MAAe;IAAA,IAAAwB,MAAA;IAAA,OAAAtB,iBAAA;MAEf,IAAIqB,SAAS,CAACE,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,EAAE;;MAGb,MAAMtB,IAAI,SAASZ,SAAS,CAACa,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMK,IAAI,GAAGmB,MAAI,CAAClB,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAEpC,MAAMC,IAAI,GAAkD;QACxDC,YAAY,EAAEH,IAAI;QAClBqB,SAAS,EAAEH,SAAS;QACpBb,QAAQ,EAAEf,0BAA0B,CAACgB;OACxC;MACD,MAAME,OAAO,GAAsB;QAC/BC,QAAQ,EAAEU,MAAI,CAACH,gCAAgC;OAClD;MAED,IAAItB,WAAW,IAAI,EAAE,EAAE;QACnBQ,IAAI,CAACS,WAAW,GAAGjB,WAAW;QAC9Bc,OAAO,CAACI,YAAY,GAAG,KAAK;;MAGhC,MAAMU,MAAM,SAASxB,IAAI,CAACgB,IAAI,CAC1B,4CAA4C,EAC5CZ,IAAI,EACJM,OAAO,CACV;MAED,MAAMK,YAAY,GAAkF,EAAE;MAEtGS,MAAM,CAACC,eAAe,CAACC,OAAO,CAAEC,MAAM,IAAI;QACtCZ,YAAY,CAACY,MAAM,CAACrB,QAAQ,CAAC,GAAGe,MAAI,CAACJ,iBAAiB,CAACU,MAAM,EAAEzB,IAAI,CAAC;MACxE,CAAC,CAAC;MAEF,OAAOa,YAAY;IAAC;EACxB;EAEA;;;;;EAKUG,gCAAgCA,CAAA;IACtC,OAAO3B,cAAc,GAAG,UAAU;EACtC;EAEA;;;;;;;;EAQMqC,yBAAyBA,CAC3BjC,YAAqB,EACrBC,WAAW,GAAG,EAAE,EAChBC,MAAe;IAAA,IAAAgC,MAAA;IAAA,OAAA9B,iBAAA;MAEf,MAAMC,IAAI,SAASZ,SAAS,CAACa,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMQ,YAAY,GAAGwB,MAAI,CAAC1B,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC5C,MAAMI,QAAQ,GAAGf,0BAA0B,CAACsC,YAAY;MAExD,MAAM1B,IAAI,GAAmD;QACzDC,YAAY;QACZE,QAAQ;QACRwB,yBAAyB,EAAE;OAC9B;MACD,IAAIpC,YAAY,EAAE;QACdS,IAAI,CAACK,YAAY,GAAGd,YAAY;;MAGpC,MAAMe,OAAO,GAAsB;QAC/BC,QAAQ,EAAEkB,MAAI,CAACG,iCAAiC,CAACrC,YAAY,EAAEY,QAAQ,CAAC;QACxE0B,qBAAqB,EAAE,IAAI;QAC3BC,cAAc,EAAE;OACnB;MAED,IAAItC,WAAW,IAAI,EAAE,EAAE;QACnBQ,IAAI,CAACS,WAAW,GAAGjB,WAAW;QAC9Bc,OAAO,CAACI,YAAY,GAAG,KAAK;QAC5BJ,OAAO,CAACC,QAAQ,IAAI,GAAG,GAAGf,WAAW;;MAGzC,MAAMuC,MAAM,SAASnC,IAAI,CAACgB,IAAI,CAC1B,6CAA6C,EAC7CZ,IAAI,EACJM,OAAO,CACV;MAED,MAAM0B,WAAW,GAAGD,MAAM,CAACX,MAAM,CAACF,MAAM,IAAIf,QAAQ,GAAG4B,MAAM,CAACE,MAAM,GAAGC,SAAS;MAEhF;MACA,MAAMd,MAAM,GAAGW,MAAM,CAACX,MAAM,CAACe,MAAM,CAAEC,OAAO,IAAKA,OAAO,CAACC,QAAQ,IAAIpC,YAAY,CAAC;MAElF,OAAO;QACHmB,MAAM;QACNY;OACH;IAAC;EACN;EAEA;;;;;EAKUM,uCAAuCA,CAAA;IAC7C,OAAOnD,cAAc,GAAG,aAAa;EACzC;EAEA;;;;;;;EAOUyC,iCAAiCA,CAACrC,YAAqB,EAAEgD,KAAc;IAC7EhD,YAAY,GAAGA,YAAY,IAAI,CAAC;IAChCgD,KAAK,GAAGA,KAAK,IAAI,CAAC;IAElB,OAAO,IAAI,CAACD,uCAAuC,EAAE,GAAG/C,YAAY,GAAG,GAAG,GAAGgD,KAAK;EACtF;EAEA;;;;;;EAMMC,+BAA+BA,CAAC/C,MAAe;IAAA,IAAAgD,MAAA;IAAA,OAAA9C,iBAAA;MACjD,MAAMC,IAAI,SAASZ,SAAS,CAACa,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMG,IAAI,CAAC8C,mCAAmC,CAACD,MAAI,CAAC3B,gCAAgC,EAAE,CAAC;IAAC;EAC5F;EAEA;;;;;;EAMM6B,gCAAgCA,CAAClD,MAAe;IAAA,IAAAmD,MAAA;IAAA,OAAAjD,iBAAA;MAClD,MAAMC,IAAI,SAASZ,SAAS,CAACa,OAAO,CAACJ,MAAM,CAAC;MAE5C,MAAMG,IAAI,CAAC8C,mCAAmC,CAACE,MAAI,CAACN,uCAAuC,EAAE,CAAC;IAAC;EACnG;EAEA;;;;;;;EAOUzB,iBAAiBA,CACvBU,MAA2B,EAC3BsB,QAAgB;IAGhB,MAAMb,WAAW,GACbT,MAAM,CAACH,MAAM,CAACF,MAAM,IAAI9B,0BAA0B,CAACgB,uBAAuB,GAAGmB,MAAM,CAACU,MAAM,GAAGC,SAAS;IAE1G;IACAX,MAAM,CAACH,MAAM,GAAGG,MAAM,CAACH,MAAM,CAACe,MAAM,CAAEC,OAAO,IAAKA,OAAO,CAACC,QAAQ,IAAIQ,QAAQ,CAAC;IAE/E,OAAO;MACHzB,MAAM,EAAEG,MAAM,CAACH,MAAM;MACrBY;KACH;EACL;EAEA;;;;;;EAMAjC,WAAWA,CAAC+C,UAAU,GAAG,CAAC;IACtB,OAAO7D,MAAM,EAAE,CAAC8D,OAAO,CAAC,KAAK,CAAC,CAACC,GAAG,CAACF,UAAU,EAAE,MAAM,CAAC,CAACG,IAAI,EAAE;EACjE;;SA/PS7D,0BAA0B;AAEnB8D,MAAA,CAAAxB,YAAY,GAAG,EAAE;AACjBwB,MAAA,CAAA9C,uBAAuB,GAAG,EAAE;;mBAHnChB,MAA0B;AAAA;;SAA1BA,MAA0B;EAAA+D,OAAA,EAA1B/D,MAA0B,CAAAgE,IAAA;EAAAC,UAAA,EADb;AAAM;AAoQhC,OAAO,MAAMC,kBAAkB,GAAGpE,aAAa,CAACE,0BAA0B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}