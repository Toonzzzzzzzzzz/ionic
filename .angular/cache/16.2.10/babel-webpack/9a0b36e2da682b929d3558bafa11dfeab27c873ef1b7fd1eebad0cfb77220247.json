{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { makeSingleton, Translate } from '@singletons';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'AddonModChat:';\n/**\n * Service that provides some features for chats.\n */\nexport class AddonModChatProvider {\n  /**\n   * Get a chat.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the chat is retrieved.\n   */\n  getChat(courseId, cmId, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this.getChatsCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModChatProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_chat_get_chats_by_courses', params, preSets);\n      const chat = response.chats.find(chat => chat.coursemodule == cmId);\n      if (chat) {\n        return chat;\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Log the user into a chat room.\n   *\n   * @param chatId Chat instance ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS is executed.\n   */\n  loginUser(chatId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        chatid: chatId\n      };\n      const response = yield site.write('mod_chat_login_user', params);\n      return response.chatsid;\n    })();\n  }\n  /**\n   * Report a chat as being viewed.\n   *\n   * @param id Chat instance ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(id, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        chatid: id\n      };\n      yield CoreCourseLogHelper.log('mod_chat_view_chat', params, AddonModChatProvider.COMPONENT, id, siteId);\n    })();\n  }\n  /**\n   * Report chat session views.\n   *\n   * @param id Chat instance ID.\n   * @param period Session period if viewing an individual session.\n   * @param period.start Period start.\n   * @param period.end Period end.\n   */\n  logViewSessions(id, period) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        cmid: id\n      };\n      if (period) {\n        params.start = period.start;\n        params.end = period.end;\n      }\n      yield CoreCourseLogHelper.log('mod_chat_view_sessions', params, AddonModChatProvider.COMPONENT, id);\n    })();\n  }\n  /**\n   * Send a message to a chat.\n   *\n   * @param sessionId Chat sessiond ID.\n   * @param message Message text.\n   * @param beepUserId Beep user ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS is executed.\n   */\n  sendMessage(sessionId, message, beepUserId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        chatsid: sessionId,\n        messagetext: message,\n        beepid: String(beepUserId)\n      };\n      const response = yield site.write('mod_chat_send_chat_message', params);\n      return response.messageid;\n    })();\n  }\n  /**\n   * Get the latest messages from a chat session.\n   *\n   * @param sessionId Chat sessiond ID.\n   * @param lastTime Last time when messages were retrieved.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS is executed.\n   */\n  getLatestMessages(sessionId, lastTime, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        chatsid: sessionId,\n        chatlasttime: lastTime\n      };\n      /* We use write to not use cache. It doesn't make sense to store the messages in cache\n         because we won't be able to retireve them if AddonModChatProvider.loginUser fails. */\n      return site.write('mod_chat_get_chat_latest_messages', params);\n    })();\n  }\n  getMessagesUserData(messages, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const formattedMessages = messages;\n      yield Promise.all(formattedMessages.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (message) {\n          try {\n            const user = yield CoreUser.getProfile(message.userid, courseId, true, siteId);\n            message.userfullname = user.fullname;\n            message.userprofileimageurl = user.profileimageurl;\n          } catch (_unused) {\n            // Error getting profile, most probably the user is deleted.\n            message.userfullname = Translate.instant('core.deleteduser') + ' ' + message.userid;\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return formattedMessages;\n    })();\n  }\n  /**\n   * Get the actives users of a current chat.\n   *\n   * @param sessionId Chat sessiond ID.\n   * @param options Other options.\n   * @returns Promise resolved when the WS is executed.\n   */\n  getChatUsers(sessionId, options = {}) {\n    return _asyncToGenerator(function* () {\n      // By default, always try to get the latest data.\n      options.readingStrategy = options.readingStrategy || 3 /* CoreSitesReadingStrategy.PREFER_NETWORK */;\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        chatsid: sessionId\n      };\n      const preSets = _objectSpread({\n        component: AddonModChatProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_chat_get_chat_users', params, preSets);\n    })();\n  }\n  /**\n   * Get chat sessions.\n   *\n   * @param chatId Chat ID.\n   * @param groupId Group ID, 0 means that the function will determine the user group.\n   * @param showAll Whether to include incomplete sessions or not.\n   * @param options Other options.\n   * @returns Promise resolved with the list of sessions.\n   */\n  getSessions(chatId, groupId = 0, showAll = false, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        chatid: chatId,\n        groupid: groupId,\n        showall: showAll\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this2.getSessionsCacheKey(chatId, groupId, showAll),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModChatProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_chat_get_sessions', params, preSets);\n      return response.sessions;\n    })();\n  }\n  /**\n   * Get chat session messages.\n   *\n   * @param chatId Chat ID.\n   * @param sessionStart Session start time.\n   * @param sessionEnd Session end time.\n   * @param groupId Group ID, 0 means that the function will determine the user group.\n   * @param options Other options.\n   * @returns Promise resolved with the list of messages.\n   */\n  getSessionMessages(chatId, sessionStart, sessionEnd, groupId = 0, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        chatid: chatId,\n        sessionstart: sessionStart,\n        sessionend: sessionEnd,\n        groupid: groupId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this3.getSessionMessagesCacheKey(chatId, sessionStart, groupId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModChatProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_chat_get_session_messages', params, preSets);\n      return response.messages;\n    })();\n  }\n  /**\n   * Invalidate chats.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateChats(courseId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this4.getChatsCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidate chat sessions.\n   *\n   * @param chatId Chat ID.\n   * @param groupId Group ID, 0 means that the function will determine the user group.\n   * @param showAll Whether to include incomplete sessions or not.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateSessions(chatId, groupId = 0, showAll = false, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this5.getSessionsCacheKey(chatId, groupId, showAll));\n    })();\n  }\n  /**\n   * Invalidate all chat sessions.\n   *\n   * @param chatId Chat ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllSessions(chatId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this6.getSessionsCacheKeyPrefix(chatId));\n    })();\n  }\n  /**\n   * Invalidate chat session messages.\n   *\n   * @param chatId Chat ID.\n   * @param sessionStart Session start time.\n   * @param groupId Group ID, 0 means that the function will determine the user group.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateSessionMessages(chatId, sessionStart, groupId = 0, siteId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this7.getSessionMessagesCacheKey(chatId, sessionStart, groupId));\n    })();\n  }\n  /**\n   * Invalidate all chat session messages.\n   *\n   * @param chatId Chat ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllSessionMessages(chatId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this8.getSessionMessagesCacheKeyPrefix(chatId));\n    })();\n  }\n  /**\n   * Get cache key for chats WS call.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getChatsCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'chats:' + courseId;\n  }\n  /**\n   * Get cache key for sessions WS call.\n   *\n   * @param chatId Chat ID.\n   * @param groupId Goup ID, 0 means that the function will determine the user group.\n   * @param showAll Whether to include incomplete sessions or not.\n   * @returns Cache key.\n   */\n  getSessionsCacheKey(chatId, groupId, showAll) {\n    return this.getSessionsCacheKeyPrefix(chatId) + groupId + ':' + (showAll ? 1 : 0);\n  }\n  /**\n   * Get cache key prefix for sessions WS call.\n   *\n   * @param chatId Chat ID.\n   * @returns Cache key prefix.\n   */\n  getSessionsCacheKeyPrefix(chatId) {\n    return ROOT_CACHE_KEY + 'sessions:' + chatId + ':';\n  }\n  /**\n   * Get cache key for session messages WS call.\n   *\n   * @param chatId Chat ID.\n   * @param sessionStart Session start time.\n   * @param groupId Group ID, 0 means that the function will determine the user group.\n   * @returns Cache key.\n   */\n  getSessionMessagesCacheKey(chatId, sessionStart, groupId) {\n    return this.getSessionMessagesCacheKeyPrefix(chatId) + sessionStart + ':' + groupId;\n  }\n  /**\n   * Get cache key prefix for session messages WS call.\n   *\n   * @param chatId Chat ID.\n   * @returns Cache key prefix.\n   */\n  getSessionMessagesCacheKeyPrefix(chatId) {\n    return ROOT_CACHE_KEY + 'sessionsMessages:' + chatId + ':';\n  }\n}\n_class = AddonModChatProvider;\n_class.COMPONENT = 'mmaModChat';\n_class.POLL_INTERVAL = 4000;\n_class.ɵfac = function AddonModChatProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModChat = makeSingleton(AddonModChatProvider);","map":{"version":3,"names":["CoreError","CoreSite","CoreCourseLogHelper","CoreUser","CoreSites","CoreSitesReadingStrategy","makeSingleton","Translate","ROOT_CACHE_KEY","AddonModChatProvider","getChat","courseId","cmId","options","_this","_asyncToGenerator","site","getSite","siteId","params","courseids","preSets","_objectSpread","cacheKey","getChatsCacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","response","read","chat","chats","find","coursemodule","instant","loginUser","chatId","chatid","write","chatsid","logView","id","log","logViewSessions","period","cmid","start","end","sendMessage","sessionId","message","beepUserId","messagetext","beepid","String","messageid","getLatestMessages","lastTime","chatlasttime","getMessagesUserData","messages","formattedMessages","Promise","all","map","_ref","user","getProfile","userid","userfullname","fullname","userprofileimageurl","profileimageurl","_unused","_x","apply","arguments","getChatUsers","componentId","getSessions","groupId","showAll","_this2","groupid","showall","getSessionsCacheKey","FREQUENCY_SOMETIMES","sessions","getSessionMessages","sessionStart","sessionEnd","_this3","sessionstart","sessionend","getSessionMessagesCacheKey","invalidateChats","_this4","invalidateWsCacheForKey","invalidateSessions","_this5","invalidateAllSessions","_this6","invalidateWsCacheForKeyStartingWith","getSessionsCacheKeyPrefix","invalidateSessionMessages","_this7","invalidateAllSessionMessages","_this8","getSessionMessagesCacheKeyPrefix","_class","POLL_INTERVAL","factory","ɵfac","providedIn","AddonModChat"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/chat/services/chat.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreWSExternalFile, CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\n\nconst ROOT_CACHE_KEY = 'AddonModChat:';\n\n/**\n * Service that provides some features for chats.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModChatProvider {\n\n    static readonly COMPONENT = 'mmaModChat';\n    static readonly POLL_INTERVAL = 4000;\n\n    /**\n     * Get a chat.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the chat is retrieved.\n     */\n    async getChat(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModChatChat> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModChatGetChatsByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getChatsCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModChatProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModChatGetChatsByCoursesWSResponse>('mod_chat_get_chats_by_courses', params, preSets);\n\n        const chat = response.chats.find((chat) => chat.coursemodule == cmId);\n        if (chat) {\n            return chat;\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Log the user into a chat room.\n     *\n     * @param chatId Chat instance ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS is executed.\n     */\n    async loginUser(chatId: number, siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModChatLoginUserWSParams = {\n            chatid: chatId,\n        };\n\n        const response = await site.write<AddonModChatLoginUserWSResponse>('mod_chat_login_user', params);\n\n        return response.chatsid;\n    }\n\n    /**\n     * Report a chat as being viewed.\n     *\n     * @param id Chat instance ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logView(id: number, siteId?: string): Promise<void> {\n        const params: AddonModChatViewChatWSParams = {\n            chatid: id,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_chat_view_chat',\n            params,\n            AddonModChatProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Report chat session views.\n     *\n     * @param id Chat instance ID.\n     * @param period Session period if viewing an individual session.\n     * @param period.start Period start.\n     * @param period.end Period end.\n     */\n    async logViewSessions(id: number, period?: { start: number; end: number }): Promise<void> {\n        const params: AddonModChatViewSessionsWSParams = {\n            cmid: id,\n        };\n\n        if (period) {\n            params.start = period.start;\n            params.end = period.end;\n        }\n\n        await CoreCourseLogHelper.log(\n            'mod_chat_view_sessions',\n            params,\n            AddonModChatProvider.COMPONENT,\n            id,\n        );\n    }\n\n    /**\n     * Send a message to a chat.\n     *\n     * @param sessionId Chat sessiond ID.\n     * @param message Message text.\n     * @param beepUserId Beep user ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS is executed.\n     */\n    async sendMessage(sessionId: string, message: string, beepUserId: number, siteId?: string): Promise<number> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModChatSendChatMessageWSParams = {\n            chatsid: sessionId,\n            messagetext: message,\n            beepid: String(beepUserId),\n        };\n\n        const response = await site.write<AddonModChatSendChatMessageWSResponse>('mod_chat_send_chat_message', params);\n\n        return response.messageid;\n    }\n\n    /**\n     * Get the latest messages from a chat session.\n     *\n     * @param sessionId Chat sessiond ID.\n     * @param lastTime Last time when messages were retrieved.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS is executed.\n     */\n    async getLatestMessages(\n        sessionId: string,\n        lastTime: number,\n        siteId?: string,\n    ): Promise<AddonModChatGetChatLatestMessagesWSResponse> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModChatGetChatLatestMessagesWSParams = {\n            chatsid: sessionId,\n            chatlasttime: lastTime,\n        };\n\n        /* We use write to not use cache. It doesn't make sense to store the messages in cache\n           because we won't be able to retireve them if AddonModChatProvider.loginUser fails. */\n        return site.write('mod_chat_get_chat_latest_messages', params);\n    }\n\n    /**\n     * Get user data for messages since they only have userid.\n     *\n     * @param messages Messages to get the user data for.\n     * @param courseId ID of the course the messages belong to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise always resolved with the formatted messages.\n     */\n    async getMessagesUserData(messages: AddonModChatWSMessage[], courseId: number, siteId?: string): Promise<AddonModChatMessage[]>;\n    async getMessagesUserData(\n        messages: AddonModChatWSSessionMessage[],\n        courseId: number,\n        siteId?: string,\n    ): Promise<AddonModChatSessionMessage[]>;\n    async getMessagesUserData(\n        messages: (AddonModChatWSMessage | AddonModChatWSSessionMessage)[],\n        courseId: number,\n        siteId?: string,\n    ): Promise<(AddonModChatMessage | AddonModChatSessionMessage)[]> {\n        const formattedMessages: (AddonModChatMessage | AddonModChatSessionMessage)[] = messages;\n\n        await Promise.all(formattedMessages.map(async (message) => {\n            try {\n                const user = await CoreUser.getProfile(message.userid, courseId, true, siteId);\n\n                message.userfullname = user.fullname;\n                message.userprofileimageurl = user.profileimageurl;\n            } catch {\n                // Error getting profile, most probably the user is deleted.\n                message.userfullname = Translate.instant('core.deleteduser') + ' ' + message.userid;\n            }\n        }));\n\n        return formattedMessages;\n    }\n\n    /**\n     * Get the actives users of a current chat.\n     *\n     * @param sessionId Chat sessiond ID.\n     * @param options Other options.\n     * @returns Promise resolved when the WS is executed.\n     */\n    async getChatUsers(sessionId: string, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModChatGetChatUsersWSResponse> {\n        // By default, always try to get the latest data.\n        options.readingStrategy = options.readingStrategy || CoreSitesReadingStrategy.PREFER_NETWORK;\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModChatGetChatUsersWSParams = {\n            chatsid: sessionId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            component: AddonModChatProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_chat_get_chat_users', params, preSets);\n    }\n\n    /**\n     * Get chat sessions.\n     *\n     * @param chatId Chat ID.\n     * @param groupId Group ID, 0 means that the function will determine the user group.\n     * @param showAll Whether to include incomplete sessions or not.\n     * @param options Other options.\n     * @returns Promise resolved with the list of sessions.\n     */\n    async getSessions(\n        chatId: number,\n        groupId: number = 0,\n        showAll: boolean = false,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModChatSession[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModChatGetSessionsWSParams = {\n            chatid: chatId,\n            groupid: groupId,\n            showall: showAll,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getSessionsCacheKey(chatId, groupId, showAll),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModChatProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModChatGetSessionsWSResponse>('mod_chat_get_sessions', params, preSets);\n\n        return response.sessions;\n    }\n\n    /**\n     * Get chat session messages.\n     *\n     * @param chatId Chat ID.\n     * @param sessionStart Session start time.\n     * @param sessionEnd Session end time.\n     * @param groupId Group ID, 0 means that the function will determine the user group.\n     * @param options Other options.\n     * @returns Promise resolved with the list of messages.\n     */\n    async getSessionMessages(\n        chatId: number,\n        sessionStart: number,\n        sessionEnd: number,\n        groupId: number = 0,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModChatWSSessionMessage[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModChatGetSessionMessagesWSParams = {\n            chatid: chatId,\n            sessionstart: sessionStart,\n            sessionend: sessionEnd,\n            groupid: groupId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getSessionMessagesCacheKey(chatId, sessionStart, groupId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModChatProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModChatGetSessionMessagesWSResponse>(\n            'mod_chat_get_session_messages',\n            params,\n            preSets,\n        );\n\n        return response.messages;\n    }\n\n    /**\n     * Invalidate chats.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateChats(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getChatsCacheKey(courseId));\n    }\n\n    /**\n     * Invalidate chat sessions.\n     *\n     * @param chatId Chat ID.\n     * @param groupId Group ID, 0 means that the function will determine the user group.\n     * @param showAll Whether to include incomplete sessions or not.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateSessions(chatId: number, groupId: number = 0, showAll: boolean = false, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getSessionsCacheKey(chatId, groupId, showAll));\n    }\n\n    /**\n     * Invalidate all chat sessions.\n     *\n     * @param chatId Chat ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllSessions(chatId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getSessionsCacheKeyPrefix(chatId));\n    }\n\n    /**\n     * Invalidate chat session messages.\n     *\n     * @param chatId Chat ID.\n     * @param sessionStart Session start time.\n     * @param groupId Group ID, 0 means that the function will determine the user group.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateSessionMessages(chatId: number, sessionStart: number, groupId: number = 0, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getSessionMessagesCacheKey(chatId, sessionStart, groupId));\n    }\n\n    /**\n     * Invalidate all chat session messages.\n     *\n     * @param chatId Chat ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllSessionMessages(chatId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getSessionMessagesCacheKeyPrefix(chatId));\n    }\n\n    /**\n     * Get cache key for chats WS call.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getChatsCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'chats:' + courseId;\n    }\n\n    /**\n     * Get cache key for sessions WS call.\n     *\n     * @param chatId Chat ID.\n     * @param groupId Goup ID, 0 means that the function will determine the user group.\n     * @param showAll Whether to include incomplete sessions or not.\n     * @returns Cache key.\n     */\n    protected getSessionsCacheKey(chatId: number, groupId: number, showAll: boolean): string {\n        return this.getSessionsCacheKeyPrefix(chatId) + groupId + ':' + (showAll ? 1 : 0);\n    }\n\n    /**\n     * Get cache key prefix for sessions WS call.\n     *\n     * @param chatId Chat ID.\n     * @returns Cache key prefix.\n     */\n    protected getSessionsCacheKeyPrefix(chatId: number): string {\n        return ROOT_CACHE_KEY + 'sessions:' + chatId + ':';\n    }\n\n    /**\n     * Get cache key for session messages WS call.\n     *\n     * @param chatId Chat ID.\n     * @param sessionStart Session start time.\n     * @param groupId Group ID, 0 means that the function will determine the user group.\n     * @returns Cache key.\n     */\n    protected getSessionMessagesCacheKey(chatId: number, sessionStart: number, groupId: number): string {\n        return this.getSessionMessagesCacheKeyPrefix(chatId) + sessionStart + ':' + groupId;\n    }\n\n    /**\n     * Get cache key prefix for session messages WS call.\n     *\n     * @param chatId Chat ID.\n     * @returns Cache key prefix.\n     */\n    protected getSessionMessagesCacheKeyPrefix(chatId: number): string {\n        return ROOT_CACHE_KEY + 'sessionsMessages:' + chatId + ':';\n    }\n\n}\n\nexport const AddonModChat = makeSingleton(AddonModChatProvider);\n\n/**\n * Params of mod_chat_get_chats_by_courses WS.\n */\nexport type AddonModChatGetChatsByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_chat_get_chats_by_courses WS.\n */\nexport type AddonModChatGetChatsByCoursesWSResponse = {\n    chats: AddonModChatChat[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Chat returned by mod_chat_get_chats_by_courses.\n */\nexport type AddonModChatChat = {\n    id: number; // Chat id.\n    coursemodule: number; // Course module id.\n    course: number; // Course id.\n    name: string; // Chat name.\n    intro: string; // The Chat intro.\n    introformat: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    chatmethod?: string; // Chat method (sockets, ajax, header_js).\n    keepdays?: number; // Keep days.\n    studentlogs?: number; // Student logs visible to everyone.\n    chattime?: number; // Chat time.\n    schedule?: number; // Schedule type.\n    timemodified?: number; // Time of last modification.\n    section?: number; // Course section id.\n    visible?: boolean; // Visible.\n    groupmode?: number; // Group mode.\n    groupingid?: number; // Group id.\n};\n\n/**\n * Params of mod_chat_login_user WS.\n */\nexport type AddonModChatLoginUserWSParams = {\n    chatid: number; // Chat instance id.\n    groupid?: number; // Group id, 0 means that the function will determine the user group.\n};\n\n/**\n * Data returned by mod_chat_login_user WS.\n */\nexport type AddonModChatLoginUserWSResponse = {\n    chatsid: string; // Unique chat session id.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_chat_view_chat WS.\n */\nexport type AddonModChatViewChatWSParams = {\n    chatid: number; // Chat instance id.\n};\n\n/**\n * Params of mod_chat_view_sessions WS.\n */\nexport type AddonModChatViewSessionsWSParams = {\n    cmid: number; // Course module id.\n    start?: number; // Session start time.\n    end?: number; // Session end time.\n};\n\n/**\n * Params of mod_chat_send_chat_message WS.\n */\nexport type AddonModChatSendChatMessageWSParams = {\n    chatsid: string; // Chat session id (obtained via mod_chat_login_user).\n    messagetext: string; // The message text.\n    beepid?: string; // The beep id.\n};\n\n/**\n * Data returned by mod_chat_send_chat_message WS.\n */\nexport type AddonModChatSendChatMessageWSResponse = {\n    messageid: number; // Message sent id.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_chat_get_chat_latest_messages WS.\n */\nexport type AddonModChatGetChatLatestMessagesWSParams = {\n    chatsid: string; // Chat session id (obtained via mod_chat_login_user).\n    chatlasttime?: number; // Last time messages were retrieved (epoch time).\n};\n\n/**\n * Data returned by mod_chat_get_chat_latest_messages WS.\n */\nexport type AddonModChatGetChatLatestMessagesWSResponse = {\n    messages: AddonModChatWSMessage[];\n    chatnewlasttime: number; // New last time.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_chat_get_chat_users WS.\n */\nexport type AddonModChatGetChatUsersWSParams = {\n    chatsid: string; // Chat session id (obtained via mod_chat_login_user).\n};\n\n/**\n * Data returned by mod_chat_get_chat_users WS.\n */\nexport type AddonModChatGetChatUsersWSResponse = {\n    users: AddonModChatUser[]; // List of users.\n    warnings?: CoreWSExternalWarning[];\n};\n/**\n * Chat user returned by mod_chat_get_chat_users.\n */\nexport type AddonModChatUser = {\n    id: number; // User id.\n    fullname: string; // User full name.\n    profileimageurl: string; // User picture URL.\n};\n\n/**\n * Params of mod_chat_get_sessions WS.\n */\nexport type AddonModChatGetSessionsWSParams = {\n    chatid: number; // Chat instance id.\n    groupid?: number; // Get messages from users in this group. 0 means that the function will determine the user group.\n    showall?: boolean; // Whether to show completed sessions or not.\n};\n\n/**\n * Data returned by mod_chat_get_sessions WS.\n */\nexport type AddonModChatGetSessionsWSResponse = {\n    sessions: AddonModChatSession[]; // List of sessions.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Chat session returned by mod_chat_get_sessions.\n */\nexport type AddonModChatSession = {\n    sessionstart: number; // Session start time.\n    sessionend: number; // Session end time.\n    sessionusers: AddonModChatSessionUser[]; // Session users.\n    iscomplete: boolean; // Whether the session is completed or not.\n};\n\n/**\n * Chat user returned by mod_chat_get_sessions.\n */\nexport type AddonModChatSessionUser = {\n    userid: number; // User id.\n    messagecount: number; // Number of messages in the session.\n};\n\n/**\n * Params of mod_chat_get_session_messages WS.\n */\nexport type AddonModChatGetSessionMessagesWSParams = {\n    chatid: number; // Chat instance id.\n    sessionstart: number; // The session start time (timestamp).\n    sessionend: number; // The session end time (timestamp).\n    groupid?: number; // Get messages from users in this group. 0 means that the function will determine the user group.\n};\n\n/**\n * Data returned by mod_chat_get_session_messages WS.\n */\nexport type AddonModChatGetSessionMessagesWSResponse = {\n    messages: AddonModChatWSSessionMessage[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Meessage returned by mod_chat_get_chat_latest_messages.\n */\nexport type AddonModChatWSMessage = {\n    id: number; // Message id.\n    userid: number; // User id.\n    system: boolean; // True if is a system message (like user joined).\n    message: string; // Message text.\n    timestamp: number; // Timestamp for the message.\n};\n\n/**\n * Message with user data.\n */\nexport type AddonModChatMessage = AddonModChatWSMessage & AddonModChatMessageUserData;\n\n/**\n * Message returned by mod_chat_get_session_messages.\n */\nexport type AddonModChatWSSessionMessage = {\n    id: number; // The message record id.\n    chatid: number; // The chat id.\n    userid: number; // The user who wrote the message.\n    groupid: number; // The group this message belongs to.\n    issystem: boolean; // Whether is a system message or not.\n    message: string; // The message text.\n    timestamp: number; // The message timestamp (indicates when the message was sent).\n};\n\n/**\n * Session message with user data.\n */\nexport type AddonModChatSessionMessage = AddonModChatWSSessionMessage & AddonModChatMessageUserData;\n\n/**\n * User data added to messages.\n */\ntype AddonModChatMessageUserData = {\n    userfullname?: string; // Calculated in the app. Full name of the user who wrote the message.\n    userprofileimageurl?: string; // Calculated in the app. Full name of the user who wrote the message.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}