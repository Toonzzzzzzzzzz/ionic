{"ast":null,"code":"import { Md5 } from './md5';\n// Hashes any blob\nexport class Md5FileHasher {\n  constructor(_callback,\n  // Callback to return the result\n  _async = true,\n  // Async version is not always available in a web worker\n  _partSize = 1048576) {\n    this._callback = _callback;\n    this._async = _async;\n    this._partSize = _partSize;\n    this._configureReader();\n  }\n  /**\n   * Hash a blob of data in the worker\n   * @param blob Data to hash\n   */\n  hash(blob) {\n    const self = this;\n    self._blob = blob;\n    // self._length = Math.ceil(blob.size / self._partSize);\n    self._part = 0;\n    self._md5 = new Md5();\n    self._processPart();\n  }\n  _fail() {\n    this._callback({\n      success: false,\n      result: 'data read failed'\n    });\n  }\n  _hashData(e) {\n    let self = this;\n    self._md5.appendByteArray(new Uint8Array(e.target.result));\n    if (self._part * self._partSize >= self._blob.size) {\n      self._callback({\n        success: true,\n        result: self._md5.end()\n      });\n    } else {\n      self._processPart();\n    }\n  }\n  _processPart() {\n    const self = this;\n    let endbyte = 0;\n    let current_part;\n    self._part += 1;\n    if (self._blob.size > self._partSize) {\n      // If blob bigger then part_size we will slice it up\n      endbyte = self._part * self._partSize;\n      if (endbyte > self._blob.size) {\n        endbyte = self._blob.size;\n      }\n      current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n    } else {\n      current_part = self._blob;\n    }\n    if (self._async) {\n      self._reader.readAsArrayBuffer(current_part);\n    } else {\n      setTimeout(() => {\n        try {\n          self._hashData({\n            target: {\n              result: self._reader.readAsArrayBuffer(current_part)\n            }\n          });\n        } catch (e) {\n          self._fail();\n        }\n      }, 0);\n    }\n  }\n  _configureReader() {\n    const self = this;\n    if (self._async) {\n      self._reader = new FileReader();\n      self._reader.onload = self._hashData.bind(self);\n      self._reader.onerror = self._fail.bind(self);\n      self._reader.onabort = self._fail.bind(self);\n    } else {\n      self._reader = new FileReaderSync();\n    }\n  }\n}","map":{"version":3,"names":["Md5","Md5FileHasher","constructor","_callback","_async","_partSize","_configureReader","hash","blob","self","_blob","_part","_md5","_processPart","_fail","success","result","_hashData","e","appendByteArray","Uint8Array","target","size","end","endbyte","current_part","slice","_reader","readAsArrayBuffer","setTimeout","FileReader","onload","bind","onerror","onabort","FileReaderSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/node_modules/ts-md5/dist/esm/md5_file_hasher.js"],"sourcesContent":["import { Md5 } from './md5';\n// Hashes any blob\nexport class Md5FileHasher {\n    constructor(_callback, // Callback to return the result\n    _async = true, // Async version is not always available in a web worker\n    _partSize = 1048576) {\n        this._callback = _callback;\n        this._async = _async;\n        this._partSize = _partSize;\n        this._configureReader();\n    }\n    /**\n     * Hash a blob of data in the worker\n     * @param blob Data to hash\n     */\n    hash(blob) {\n        const self = this;\n        self._blob = blob;\n        // self._length = Math.ceil(blob.size / self._partSize);\n        self._part = 0;\n        self._md5 = new Md5();\n        self._processPart();\n    }\n    _fail() {\n        this._callback({\n            success: false,\n            result: 'data read failed'\n        });\n    }\n    _hashData(e) {\n        let self = this;\n        self._md5.appendByteArray(new Uint8Array(e.target.result));\n        if (self._part * self._partSize >= self._blob.size) {\n            self._callback({\n                success: true,\n                result: self._md5.end()\n            });\n        }\n        else {\n            self._processPart();\n        }\n    }\n    _processPart() {\n        const self = this;\n        let endbyte = 0;\n        let current_part;\n        self._part += 1;\n        if (self._blob.size > self._partSize) { // If blob bigger then part_size we will slice it up\n            endbyte = self._part * self._partSize;\n            if (endbyte > self._blob.size) {\n                endbyte = self._blob.size;\n            }\n            current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n        }\n        else {\n            current_part = self._blob;\n        }\n        if (self._async) {\n            self._reader.readAsArrayBuffer(current_part);\n        }\n        else {\n            setTimeout(() => {\n                try {\n                    self._hashData({\n                        target: {\n                            result: self._reader.readAsArrayBuffer(current_part)\n                        },\n                    });\n                }\n                catch (e) {\n                    self._fail();\n                }\n            }, 0);\n        }\n    }\n    _configureReader() {\n        const self = this;\n        if (self._async) {\n            self._reader = new FileReader();\n            self._reader.onload = self._hashData.bind(self);\n            self._reader.onerror = self._fail.bind(self);\n            self._reader.onabort = self._fail.bind(self);\n        }\n        else {\n            self._reader = new FileReaderSync();\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}