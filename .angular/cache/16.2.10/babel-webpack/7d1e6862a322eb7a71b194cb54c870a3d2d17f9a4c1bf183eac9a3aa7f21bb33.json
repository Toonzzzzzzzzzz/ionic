{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWS } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CorePath } from '@singletons/path';\nimport { AddonModScormOffline } from './scorm-offline';\nimport { AddonModScormSyncProvider } from './scorm-sync';\nimport * as i0 from \"@angular/core\";\n// Private constants.\nconst VALID_STATUSES = ['notattempted', 'passed', 'completed', 'failed', 'incomplete', 'browsed', 'suspend'];\nconst STATUSES = {\n  'passed': 'passed',\n  'completed': 'completed',\n  'failed': 'failed',\n  'incomplete': 'incomplete',\n  'browsed': 'browsed',\n  'not attempted': 'notattempted',\n  'p': 'passed',\n  'c': 'completed',\n  'f': 'failed',\n  'i': 'incomplete',\n  'b': 'browsed',\n  'n': 'notattempted'\n};\nconst STATUS_TO_ICON = {\n  assetc: 'far-file-zipper',\n  asset: 'far-file-zipper',\n  browsed: 'fas-book',\n  completed: 'far-square-check',\n  failed: 'fas-xmark',\n  incomplete: 'far-pen-to-square',\n  minus: 'fas-minus',\n  notattempted: 'far-square',\n  passed: 'fas-check',\n  plus: 'fas-plus',\n  popdown: 'far-rectangle-xmark',\n  popup: 'fas-window-restore',\n  suspend: 'fas-pause',\n  wait: 'far-clock'\n};\nconst ROOT_CACHE_KEY = 'mmaModScorm:';\n/**\n * Service that provides some features for SCORM.\n */\nexport class AddonModScormProvider {\n  /**\n   * Calculates the SCORM grade based on the grading method and the list of attempts scores.\n   * We only treat online attempts to calculate a SCORM grade.\n   *\n   * @param scorm SCORM.\n   * @param onlineAttempts Object with the online attempts.\n   * @returns Grade. -1 if no grade.\n   */\n  calculateScormGrade(scorm, onlineAttempts) {\n    if (!onlineAttempts || !Object.keys(onlineAttempts).length) {\n      return -1;\n    }\n    switch (scorm.whatgrade) {\n      case AddonModScormProvider.FIRSTATTEMPT:\n        return onlineAttempts[1] ? onlineAttempts[1].score : -1;\n      case AddonModScormProvider.LASTATTEMPT:\n        {\n          // Search the last completed attempt number.\n          let lastCompleted = 0;\n          for (const attemptNumber in onlineAttempts) {\n            if (onlineAttempts[attemptNumber].hasCompletedPassedSCO) {\n              lastCompleted = Math.max(onlineAttempts[attemptNumber].num, lastCompleted);\n            }\n          }\n          if (lastCompleted > 0) {\n            return onlineAttempts[lastCompleted].score;\n          } else if (onlineAttempts[1]) {\n            // If no completed attempt found, use the first attempt for consistency with LMS.\n            return onlineAttempts[1].score;\n          }\n          return -1;\n        }\n      case AddonModScormProvider.HIGHESTATTEMPT:\n        {\n          // Search the highest grade.\n          let grade = 0;\n          for (const attemptNumber in onlineAttempts) {\n            grade = Math.max(onlineAttempts[attemptNumber].score, grade);\n          }\n          return grade;\n        }\n      case AddonModScormProvider.AVERAGEATTEMPT:\n        {\n          // Calculate the average.\n          let sumGrades = 0;\n          let total = 0;\n          for (const attemptNumber in onlineAttempts) {\n            sumGrades += onlineAttempts[attemptNumber].score;\n            total++;\n          }\n          return Math.round(sumGrades / total);\n        }\n      default:\n        return -1;\n    }\n  }\n  /**\n   * Calculates the size of a SCORM.\n   *\n   * @param scorm SCORM.\n   * @returns Promise resolved with the SCORM size.\n   */\n  calculateScormSize(scorm) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (scorm.packagesize) {\n        return scorm.packagesize;\n      }\n      return CoreWS.getRemoteFileSize(_this.getPackageUrl(scorm));\n    })();\n  }\n  /**\n   * Count the attempts left for the given scorm.\n   *\n   * @param scorm SCORM.\n   * @param attemptsCount Number of attempts performed.\n   * @returns Number of attempts left.\n   */\n  countAttemptsLeft(scorm, attemptsCount) {\n    if (!scorm.maxattempt) {\n      return Number.MAX_VALUE; // Unlimited attempts.\n    }\n\n    attemptsCount = Number(attemptsCount); // Make sure it's a number.\n    if (isNaN(attemptsCount)) {\n      return -1;\n    }\n    return Math.max(scorm.maxattempt - attemptsCount, 0);\n  }\n  /**\n   * Returns the mode and attempt number to use based on mode selected and SCORM data.\n   * This function is based on Moodle's scorm_check_mode.\n   *\n   * @param scorm SCORM.\n   * @param mode Selected mode.\n   * @param attempt Current attempt.\n   * @param newAttempt Whether it should start a new attempt.\n   * @param incomplete Whether current attempt is incomplete.\n   * @param canSaveTracks Whether the user can save tracks.\n   * @returns Mode, attempt number and whether to start a new attempt.\n   */\n  determineAttemptAndMode(scorm, mode, attempt, newAttempt, incomplete, canSaveTracks = true) {\n    if (!canSaveTracks) {\n      return {\n        mode: scorm.hidebrowse ? AddonModScormProvider.MODENORMAL : mode,\n        attempt,\n        newAttempt: false\n      };\n    }\n    if (mode == AddonModScormProvider.MODEBROWSE) {\n      if (scorm.hidebrowse) {\n        // Prevent Browse mode if hidebrowse is set.\n        mode = AddonModScormProvider.MODENORMAL;\n      } else {\n        // We don't need to check attempts as browse mode is set.\n        if (attempt == 0) {\n          attempt = 1;\n          newAttempt = true;\n        }\n        return {\n          mode: mode,\n          attempt: attempt,\n          newAttempt: !!newAttempt\n        };\n      }\n    }\n    if (scorm.forcenewattempt == AddonModScormProvider.SCORM_FORCEATTEMPT_ALWAYS) {\n      // This SCORM is configured to force a new attempt on every re-entry.\n      return {\n        mode: AddonModScormProvider.MODENORMAL,\n        attempt: attempt + 1,\n        newAttempt: true\n      };\n    }\n    // Validate user request to start a new attempt.\n    if (attempt == 0) {\n      newAttempt = true;\n    } else if (incomplete) {\n      // The option to start a new attempt should never have been presented. Force false.\n      newAttempt = false;\n    } else if (scorm.forcenewattempt) {\n      // A new attempt should be forced for already completed attempts.\n      newAttempt = true;\n    }\n    if (newAttempt && (!scorm.maxattempt || attempt < scorm.maxattempt)) {\n      // Create a new attempt. Force mode normal.\n      attempt++;\n      mode = AddonModScormProvider.MODENORMAL;\n    } else {\n      if (incomplete) {\n        // We can't review an incomplete attempt.\n        mode = AddonModScormProvider.MODENORMAL;\n      } else {\n        // We aren't starting a new attempt and the current one is complete, force review mode.\n        mode = AddonModScormProvider.MODEREVIEW;\n      }\n    }\n    return {\n      mode: mode,\n      attempt: attempt,\n      newAttempt: !!newAttempt\n    };\n  }\n  /**\n   * Check if TOC should be displayed in the player.\n   *\n   * @param scorm SCORM.\n   * @returns Whether it should display TOC.\n   */\n  displayTocInPlayer(scorm) {\n    return scorm.hidetoc !== 3;\n  }\n  /**\n   * This is a little language parser for AICC_SCRIPT.\n   * Evaluates the expression and returns a boolean answer.\n   * See 2.3.2.5.1. Sequencing/Navigation Today - from the SCORM 1.2 spec (CAM).\n   *\n   * @param prerequisites The AICC_SCRIPT prerequisites expression.\n   * @param trackData The tracked user data of each SCO.\n   * @returns Whether the prerequisites are fulfilled.\n   */\n  evalPrerequisites(prerequisites, trackData) {\n    const stack = []; // List of prerequisites.\n    // Expand the amp entities.\n    prerequisites = prerequisites.replace(/&amp;/gi, '&');\n    // Find all my parsable tokens.\n    prerequisites = prerequisites.replace(/(&|\\||\\(|\\)|~)/gi, '\\t$1\\t');\n    // Expand operators.\n    prerequisites = prerequisites.replace(/&/gi, '&&');\n    prerequisites = prerequisites.replace(/\\|/gi, '||');\n    // Now - grab all the tokens.\n    const elements = prerequisites.trim().split('\\t');\n    // Process each token to build an expression to be evaluated.\n    elements.forEach(element => {\n      element = element.trim();\n      if (!element) {\n        return;\n      }\n      if (!element.match(/^(&&|\\|\\||\\(|\\))$/gi)) {\n        // Create each individual expression.\n        // Search for ~ = <> X*{} .\n        const re = /^(\\d+)\\*\\{(.+)\\}$/; // Sets like 3*{S34, S36, S37, S39}.\n        const reOther = /^(.+)(=|<>)(.+)$/; // Other symbols.\n        const matches = element.match(re);\n        if (matches) {\n          const repeat = Number(matches[1]);\n          const set = matches[2].split(',') || [];\n          let count = 0;\n          set.forEach(setElement => {\n            setElement = setElement.trim();\n            if (trackData[setElement] !== undefined && (trackData[setElement].status == 'completed' || trackData[setElement].status == 'passed')) {\n              count++;\n            }\n          });\n          if (count >= repeat) {\n            element = 'true';\n          } else {\n            element = 'false';\n          }\n        } else if (element == '~') {\n          // Not maps ~.\n          element = '!';\n        } else if (reOther.test(element)) {\n          var _element$match, _otherMatches$;\n          // Other symbols = | <> .\n          const otherMatches = (_element$match = element.match(reOther)) !== null && _element$match !== void 0 ? _element$match : [];\n          element = (_otherMatches$ = otherMatches[1]) === null || _otherMatches$ === void 0 ? void 0 : _otherMatches$.trim();\n          if (trackData[element] !== undefined) {\n            let value = otherMatches[3].trim().replace(/('|\")/gi, '');\n            let oper;\n            if (STATUSES[value] !== undefined) {\n              value = STATUSES[value];\n            }\n            if (otherMatches[2] == '<>') {\n              oper = '!=';\n            } else {\n              oper = '==';\n            }\n            element = '(\\'' + trackData[element].status + '\\' ' + oper + ' \\'' + value + '\\')';\n          } else {\n            element = 'false';\n          }\n        } else {\n          // Everything else must be an element defined like S45 ...\n          if (trackData[element] !== undefined && (trackData[element].status == 'completed' || trackData[element].status == 'passed')) {\n            element = 'true';\n          } else {\n            element = 'false';\n          }\n        }\n      }\n      // Add the element to the list of prerequisites.\n      stack.push(' ' + element + ' ');\n    });\n    // eslint-disable-next-line no-eval\n    return eval(stack.join('') + ';');\n  }\n  /**\n   * Formats a grade to be displayed.\n   *\n   * @param scorm SCORM.\n   * @param grade Grade.\n   * @returns Grade to display.\n   */\n  formatGrade(scorm, grade) {\n    if (grade === undefined || grade == -1) {\n      return Translate.instant('core.none');\n    }\n    if (scorm.grademethod !== AddonModScormProvider.GRADESCOES && scorm.maxgrade) {\n      grade = grade / scorm.maxgrade * 100;\n      return Translate.instant('core.percentagenumber', {\n        $a: CoreTextUtils.roundToDecimals(grade, 2)\n      });\n    }\n    return String(grade);\n  }\n  /**\n   * Formats a tree-like TOC into an array.\n   *\n   * @param toc SCORM's TOC (tree format).\n   * @param level The level of the TOC we're right now. 0 by default.\n   * @returns SCORM's TOC (array format).\n   */\n  formatTocToArray(toc, level = 0) {\n    if (!toc || !toc.length) {\n      return [];\n    }\n    let formatted = [];\n    toc.forEach(node => {\n      const sco = node;\n      sco.level = level;\n      formatted.push(sco);\n      formatted = formatted.concat(this.formatTocToArray(node.children, level + 1));\n    });\n    return formatted;\n  }\n  /**\n   * Get access information for a given SCORM.\n   *\n   * @param scormId SCORM ID.\n   * @param options Other options.\n   * @returns Object with access information.\n   * @since 3.7\n   */\n  getAccessInformation(scormId, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      if (!site.wsAvailable('mod_scorm_get_scorm_access_information')) {\n        // Access information not available for 3.6 or older sites.\n        return {};\n      }\n      const params = {\n        scormid: scormId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this2.getAccessInformationCacheKey(scormId),\n        component: AddonModScormProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_scorm_get_scorm_access_information', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for access information WS calls.\n   *\n   * @param scormId SCORM ID.\n   * @returns Cache key.\n   */\n  getAccessInformationCacheKey(scormId) {\n    return ROOT_CACHE_KEY + 'accessInfo:' + scormId;\n  }\n  /**\n   * Get the number of attempts done by a user in the given SCORM.\n   *\n   * @param scormId SCORM ID.\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  getAttemptCount(scormId, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      const site = yield CoreSites.getSite(options.siteId);\n      const userId = options.userId || site.getUserId();\n      const [onlineCount, offlineAttempts] = yield Promise.all([_this3.getAttemptCountOnline(scormId, options), AddonModScormOffline.getAttempts(scormId, options.siteId, userId)]);\n      const result = {\n        online: [],\n        offline: [],\n        total: onlineCount,\n        lastAttempt: {\n          num: onlineCount,\n          offline: false\n        }\n      };\n      // Fill online attempts array.\n      for (let i = 1; i <= onlineCount; i++) {\n        result.online.push(i);\n      }\n      // Get only attempt numbers for offline attempts.\n      result.offline = offlineAttempts.map(entry => {\n        // Calculate last attempt. We use >= to prioritize offline events if an attempt is both online and offline.\n        if (entry.attempt >= result.lastAttempt.num) {\n          result.lastAttempt.num = entry.attempt;\n          result.lastAttempt.offline = true;\n        }\n        return entry.attempt;\n      });\n      // Calculate the total.\n      result.offline.forEach(attempt => {\n        // Check if this attempt also exists in online, it might have been copied to local.\n        if (result.online.indexOf(attempt) == -1) {\n          result.total++;\n        }\n      });\n      return result;\n    })();\n  }\n  /**\n   * Get cache key for SCORM attempt count WS calls.\n   *\n   * @param scormId SCORM ID.\n   * @param userId User ID. If not defined, current user.\n   * @returns Cache key.\n   */\n  getAttemptCountCacheKey(scormId, userId) {\n    return ROOT_CACHE_KEY + 'attemptcount:' + scormId + ':' + userId;\n  }\n  /**\n   * Get the number of attempts done by a user in the given SCORM in online.\n   *\n   * @param scormId SCORM ID.\n   * @param options Other options.\n   * @returns Promise resolved when the attempt count is retrieved.\n   */\n  getAttemptCountOnline(scormId, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const userId = options.userId || site.getUserId();\n      const params = {\n        scormid: scormId,\n        userid: userId,\n        ignoremissingcompletion: options.ignoreMissing\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this4.getAttemptCountCacheKey(scormId, userId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModScormProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_scorm_get_scorm_attempt_count', params, preSets);\n      return response.attemptscount;\n    })();\n  }\n  /**\n   * Get the grade data for a certain attempt.\n   * Mostly based on Moodle's scorm_grade_user_attempt.\n   *\n   * @param scorm SCORM.\n   * @param attempt Attempt number.\n   * @param offline Whether the attempt is offline.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the grade. If the attempt hasn't reported grade/completion, it will be -1.\n   */\n  getAttemptGrade(scorm, attempt, offline, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const attemptScore = {\n        scos: 0,\n        values: 0,\n        max: 0,\n        sum: 0\n      };\n      // Get the user data and use it to calculate the grade.\n      const data = yield _this5.getScormUserData(scorm.id, attempt, {\n        offline,\n        cmId: scorm.coursemodule,\n        siteId\n      });\n      for (const scoId in data) {\n        const sco = data[scoId];\n        const userData = sco.userdata;\n        if (userData.status == 'completed' || userData.status == 'passed') {\n          attemptScore.scos++;\n        }\n        if (userData.score_raw || scorm.scormtype !== undefined && scorm.scormtype == 'sco' && userData.score_raw !== undefined) {\n          const scoreRaw = parseFloat(userData.score_raw);\n          attemptScore.values++;\n          attemptScore.sum += scoreRaw;\n          attemptScore.max = Math.max(scoreRaw, attemptScore.max);\n        }\n      }\n      let score = 0;\n      switch (scorm.grademethod) {\n        case AddonModScormProvider.GRADEHIGHEST:\n          score = attemptScore.max;\n          break;\n        case AddonModScormProvider.GRADEAVERAGE:\n          if (attemptScore.values > 0) {\n            score = attemptScore.sum / attemptScore.values;\n          } else {\n            score = 0;\n          }\n          break;\n        case AddonModScormProvider.GRADESUM:\n          score = attemptScore.sum;\n          break;\n        case AddonModScormProvider.GRADESCOES:\n          score = attemptScore.scos;\n          break;\n        default:\n          score = attemptScore.max;\n        // Remote Learner GRADEHIGHEST is default.\n      }\n\n      return {\n        num: attempt,\n        score,\n        hasCompletedPassedSCO: attemptScore.scos > 0\n      };\n    })();\n  }\n  /**\n   * Get the list of a organizations defined in a SCORM package.\n   *\n   * @param scormId SCORM ID.\n   * @param options Other options.\n   * @returns Promise resolved with the list of organizations.\n   */\n  getOrganizations(scormId, options = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const scos = yield _this6.getScos(scormId, options);\n      const organizations = [];\n      scos.forEach(sco => {\n        // Is an organization entry?\n        if (sco.organization == '' && sco.parent == '/' && sco.scormtype == '') {\n          organizations.push({\n            identifier: sco.identifier,\n            title: sco.title,\n            sortorder: sco.sortorder\n          });\n        }\n      });\n      return organizations;\n    })();\n  }\n  /**\n   * Get the organization Toc any\n   *\n   * @param scormId SCORM ID.\n   * @param attempt The attempt number (to populate SCO track data).\n   * @param options Other options.\n   * @returns Promise resolved with the toc object.\n   */\n  getOrganizationToc(scormId, attempt, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const scos = yield _this7.getScosWithData(scormId, attempt, options);\n      const map = {};\n      const rootScos = [];\n      scos.forEach((sco, index) => {\n        sco.children = [];\n        map[sco.identifier] = index;\n        if (sco.parent !== '/') {\n          if (sco.parent == options.organization) {\n            // It's a root SCO, add it to the root array.\n            rootScos.push(sco);\n          } else {\n            // Add this sco to the parent.\n            scos[map[sco.parent]].children.push(sco);\n          }\n        }\n      });\n      return rootScos;\n    })();\n  }\n  /**\n   * Get the package URL of a given SCORM.\n   *\n   * @param scorm SCORM.\n   * @returns Package URL.\n   */\n  getPackageUrl(scorm) {\n    if (scorm.packageurl) {\n      return scorm.packageurl;\n    }\n    if (scorm.reference) {\n      return scorm.reference;\n    }\n    return '';\n  }\n  /**\n   * Get the user data for a certain SCORM and attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param options Other options.\n   * @returns Promise resolved when the user data is retrieved.\n   */\n  getScormUserData(scormId, attempt, options = {}) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      if (!options.offline) {\n        return _this8.getScormUserDataOnline(scormId, attempt, options);\n      }\n      // Get SCOs if not provided.\n      if (!options.scos) {\n        options.scos = yield _this8.getScos(scormId, options);\n      }\n      return AddonModScormOffline.getScormUserData(scormId, attempt, options.scos, options.siteId);\n    })();\n  }\n  /**\n   * Get cache key for SCORM user data WS calls.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @returns Cache key.\n   */\n  getScormUserDataCacheKey(scormId, attempt) {\n    return this.getScormUserDataCommonCacheKey(scormId) + ':' + attempt;\n  }\n  /**\n   * Get common cache key for SCORM user data WS calls.\n   *\n   * @param scormId SCORM ID.\n   * @returns Cache key.\n   */\n  getScormUserDataCommonCacheKey(scormId) {\n    return ROOT_CACHE_KEY + 'userdata:' + scormId;\n  }\n  /**\n   * Get the user data for a certain SCORM and attempt in online.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param options Other options.\n   * @returns Promise resolved when the user data is retrieved.\n   */\n  getScormUserDataOnline(scormId, attempt, options = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        scormid: scormId,\n        attempt: attempt\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this9.getScormUserDataCacheKey(scormId, attempt),\n        component: AddonModScormProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_scorm_get_scorm_user_data', params, preSets);\n      // Format the response.\n      const data = {};\n      response.data.forEach(sco => {\n        data[sco.scoid] = {\n          scoid: sco.scoid,\n          defaultdata: CoreUtils.objectToKeyValueMap(sco.defaultdata, 'element', 'value'),\n          userdata: CoreUtils.objectToKeyValueMap(sco.userdata, 'element', 'value')\n        };\n      });\n      return data;\n    })();\n  }\n  /**\n   * Get cache key for get SCORM scos WS calls.\n   *\n   * @param scormId SCORM ID.\n   * @returns Cache key.\n   */\n  getScosCacheKey(scormId) {\n    return ROOT_CACHE_KEY + 'scos:' + scormId;\n  }\n  /**\n   * Retrieves the list of SCO objects for a given SCORM and organization.\n   *\n   * @param scormId SCORM ID.\n   * @param options Other options.\n   * @returns Promise resolved with a list of SCO.\n   */\n  getScos(scormId, options = {}) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      const site = yield CoreSites.getSite(options.siteId);\n      // Don't send the organization to the WS, we'll filter them locally.\n      const params = {\n        scormid: scormId\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this10.getScosCacheKey(scormId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        component: AddonModScormProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_scorm_get_scorm_scoes', params, preSets);\n      if (options.organization) {\n        // Filter SCOs by organization.\n        return response.scoes.filter(sco => sco.organization == options.organization);\n      }\n      return response.scoes;\n    })();\n  }\n  /**\n   * Retrieves the list of SCO objects for a given SCORM and organization, including data about\n   * a certain attempt (status, isvisible, ...).\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param options Other options.\n   * @returns Promise resolved with a list of SCO objects.\n   */\n  getScosWithData(scormId, attempt, options = {}) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      // Get organization SCOs.\n      const scos = yield _this11.getScos(scormId, options);\n      // Get the track data for all the SCOs in the organization for the given attempt.\n      // We'll use this data to set SCO data like isvisible, status and so.\n      const userDataOptions = _objectSpread({\n        scos\n      }, options);\n      const data = yield _this11.getScormUserData(scormId, attempt, userDataOptions);\n      const trackDataBySCO = {};\n      // First populate trackDataBySCO to index by SCO identifier.\n      // We want the full list first because it's needed by evalPrerequisites.\n      scos.forEach(sco => {\n        trackDataBySCO[sco.identifier] = data[sco.id].userdata;\n      });\n      const scosWithData = scos;\n      scosWithData.forEach(sco => {\n        // Add specific SCO information (related to tracked data).\n        const scoData = data[sco.id].userdata;\n        if (!scoData) {\n          return;\n        }\n        // Check isvisible attribute.\n        sco.isvisible = scoData.isvisible === undefined || !!scoData.isvisible && scoData.isvisible !== 'false';\n        // Check pre-requisites status.\n        sco.prereq = scoData.prerequisites === undefined || _this11.evalPrerequisites(scoData.prerequisites, trackDataBySCO);\n        // Add status.\n        sco.status = scoData.status === undefined || scoData.status === '' ? 'notattempted' : scoData.status;\n        // Exit var.\n        sco.exitvar = scoData.exitvar === undefined ? 'cmi.core.exit' : scoData.exitvar;\n        sco.exitvalue = scoData[sco.exitvar];\n        // Copy score.\n        sco.scoreraw = scoData.score_raw;\n      });\n      return scosWithData;\n    })();\n  }\n  /**\n   * Given a SCORM and a SCO, returns the full launch URL for the SCO.\n   *\n   * @param scorm SCORM.\n   * @param sco SCO.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the URL.\n   */\n  getScoSrc(scorm, sco, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      var _sco$extradata, _scorm$moduleurl;\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Build the launch URL. Moodle web checks SCORM version, we don't need to, it's always SCORM 1.2.\n      let launchUrl = sco.launch;\n      const parametersEntry = (_sco$extradata = sco.extradata) === null || _sco$extradata === void 0 ? void 0 : _sco$extradata.find(entry => entry.element == 'parameters');\n      let parameters = parametersEntry === null || parametersEntry === void 0 ? void 0 : parametersEntry.value;\n      if (parameters) {\n        const connector = launchUrl.indexOf('?') > -1 ? '&' : '?';\n        if (parameters.charAt(0) == '?') {\n          parameters = parameters.substring(1);\n        }\n        launchUrl += connector + parameters;\n      }\n      if (_this12.isExternalLink(launchUrl)) {\n        // It's an online URL.\n        return launchUrl;\n      }\n      const dirPath = yield CoreFilepool.getPackageDirUrlByUrl(siteId, (_scorm$moduleurl = scorm.moduleurl) !== null && _scorm$moduleurl !== void 0 ? _scorm$moduleurl : '');\n      return CorePath.concatenatePaths(dirPath, launchUrl);\n    })();\n  }\n  /**\n   * Get the path to the folder where a SCORM is downloaded.\n   *\n   * @param moduleUrl Module URL (returned by get_course_contents).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the folder path.\n   */\n  getScormFolder(moduleUrl, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    return CoreFilepool.getPackageDirPathByUrl(siteId, moduleUrl);\n  }\n  /**\n   * Gets a list of files to downlaod for a SCORM, using a format similar to module.contents from get_course_contents.\n   * It will only return one file: the ZIP package.\n   *\n   * @param scorm SCORM.\n   * @returns File list.\n   */\n  getScormFileList(scorm) {\n    const files = [];\n    if (!this.isScormUnsupported(scorm) && !scorm.warningMessage) {\n      files.push({\n        fileurl: this.getPackageUrl(scorm),\n        filepath: '/',\n        filename: scorm.reference,\n        filesize: scorm.packagesize,\n        timemodified: 0\n      });\n    }\n    return files;\n  }\n  /**\n   * Get the URL and description of the status icon.\n   *\n   * @param sco SCO.\n   * @param incomplete Whether the SCORM is incomplete.\n   * @returns Image URL and description.\n   */\n  getScoStatusIcon(sco, incomplete) {\n    let imageName = '';\n    let descName = '';\n    let suspendedStr = '';\n    const status = sco.status || '';\n    if (sco.isvisible) {\n      if (VALID_STATUSES.indexOf(status) >= 0) {\n        if (sco.scormtype == 'sco') {\n          imageName = status;\n          descName = status;\n        } else {\n          imageName = 'asset';\n          descName = 'assetlaunched';\n        }\n        if (!incomplete) {\n          // Check if SCO is completed or not. If SCORM is incomplete there's no need to check SCO.\n          incomplete = this.isStatusIncomplete(status);\n        }\n        if (incomplete && sco.exitvalue == 'suspend') {\n          imageName = 'suspend';\n          suspendedStr = ' - ' + Translate.instant('addon.mod_scorm.suspended');\n        }\n      } else {\n        incomplete = true;\n        if (sco.scormtype == 'sco') {\n          // Status empty or not valid, use 'notattempted'.\n          imageName = 'notattempted';\n        } else {\n          imageName = 'asset';\n        }\n        descName = imageName;\n      }\n    }\n    if (imageName == '') {\n      imageName = 'notattempted';\n      descName = 'notattempted';\n      suspendedStr = '';\n    }\n    sco.incomplete = incomplete;\n    return {\n      icon: STATUS_TO_ICON[imageName],\n      description: Translate.instant('addon.mod_scorm.' + descName) + suspendedStr\n    };\n  }\n  /**\n   * Get cache key for SCORM data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getScormDataCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'scorm:' + courseId;\n  }\n  /**\n   * Get a SCORM with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the SCORM is retrieved.\n   */\n  getScormByField(courseId, key, value, options = {}) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this13.getScormDataCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModScormProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_scorm_get_scorms_by_courses', params, preSets);\n      const currentScorm = response.scorms.find(scorm => scorm[key] == value);\n      if (!currentScorm) {\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n      }\n      // If the SCORM isn't available the WS returns a warning and it doesn't return timeopen and timeclosed.\n      if (currentScorm.timeopen === undefined) {\n        var _response$warnings;\n        const warning = (_response$warnings = response.warnings) === null || _response$warnings === void 0 ? void 0 : _response$warnings.find(warning => warning.itemid === currentScorm.id);\n        currentScorm.warningMessage = warning === null || warning === void 0 ? void 0 : warning.message;\n      }\n      if (response.options) {\n        const scormOptions = CoreUtils.objectToKeyValueMap(response.options, 'name', 'value');\n        if (scormOptions.scormstandard) {\n          currentScorm.scormStandard = Number(scormOptions.scormstandard);\n        }\n      }\n      currentScorm.moduleurl = options.moduleUrl;\n      return currentScorm;\n    })();\n  }\n  /**\n   * Get a SCORM by module ID.\n   *\n   * @param courseId Course ID.\n   * @param cmId Course module ID.\n   * @param options Other options.\n   * @returns Promise resolved when the SCORM is retrieved.\n   */\n  getScorm(courseId, cmId, options = {}) {\n    return this.getScormByField(courseId, 'coursemodule', cmId, options);\n  }\n  /**\n   * Get a SCORM by SCORM ID.\n   *\n   * @param courseId Course ID.\n   * @param id SCORM ID.\n   * @param options Other options.\n   * @returns Promise resolved when the SCORM is retrieved.\n   */\n  getScormById(courseId, id, options = {}) {\n    return this.getScormByField(courseId, 'id', id, options);\n  }\n  /**\n   * Get a readable SCORM grade method.\n   *\n   * @param scorm SCORM.\n   * @returns Grading method.\n   */\n  getScormGradeMethod(scorm) {\n    if (scorm.maxattempt == 1) {\n      switch (scorm.grademethod) {\n        case AddonModScormProvider.GRADEHIGHEST:\n          return Translate.instant('addon.mod_scorm.gradehighest');\n        case AddonModScormProvider.GRADEAVERAGE:\n          return Translate.instant('addon.mod_scorm.gradeaverage');\n        case AddonModScormProvider.GRADESUM:\n          return Translate.instant('addon.mod_scorm.gradesum');\n        case AddonModScormProvider.GRADESCOES:\n          return Translate.instant('addon.mod_scorm.gradescoes');\n        default:\n          return '';\n      }\n    }\n    switch (scorm.whatgrade) {\n      case AddonModScormProvider.HIGHESTATTEMPT:\n        return Translate.instant('addon.mod_scorm.highestattempt');\n      case AddonModScormProvider.AVERAGEATTEMPT:\n        return Translate.instant('addon.mod_scorm.averageattempt');\n      case AddonModScormProvider.FIRSTATTEMPT:\n        return Translate.instant('addon.mod_scorm.firstattempt');\n      case AddonModScormProvider.LASTATTEMPT:\n        return Translate.instant('addon.mod_scorm.lastattempt');\n      default:\n        return '';\n    }\n  }\n  /**\n   * Invalidates access information.\n   *\n   * @param scormId SCORM ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAccessInformation(scormId, siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this14.getAccessInformationCacheKey(scormId));\n    })();\n  }\n  /**\n   * Invalidates all the data related to a certain SCORM.\n   *\n   * @param scormId SCORM ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllScormData(scormId, siteId, userId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all([_this15.invalidateAttemptCount(scormId, siteId, userId), _this15.invalidateScos(scormId, siteId), _this15.invalidateScormUserData(scormId, siteId), _this15.invalidateAccessInformation(scormId, siteId)]);\n    })();\n  }\n  /**\n   * Invalidates attempt count.\n   *\n   * @param scormId SCORM ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAttemptCount(scormId, siteId, userId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      yield site.invalidateWsCacheForKey(_this16.getAttemptCountCacheKey(scormId, userId));\n    })();\n  }\n  /**\n   * Invalidate the prefetched content.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID of the module.\n   * @param siteId Site ID. If not defined, current site.\n   * @param userId User ID. If not defined use site's current user.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId, userId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const scorm = yield _this17.getScorm(courseId, moduleId, {\n        siteId\n      });\n      yield Promise.all([_this17.invalidateAllScormData(scorm.id, siteId, userId), CoreFilepool.invalidateFilesByComponent(siteId, AddonModScormProvider.COMPONENT, moduleId, true)]);\n    })();\n  }\n  /**\n   * Invalidates SCORM data.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateScormData(courseId, siteId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this18.getScormDataCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidates SCORM user data for all attempts.\n   *\n   * @param scormId SCORM ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateScormUserData(scormId, siteId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this19.getScormUserDataCommonCacheKey(scormId));\n    })();\n  }\n  /**\n   * Invalidates SCORM scos for all organizations.\n   *\n   * @param scormId SCORM ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateScos(scormId, siteId) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this20.getScosCacheKey(scormId));\n    })();\n  }\n  /**\n   * Check if a SCORM's attempt is incomplete.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt.\n   * @param options Other options.\n   * @returns Promise resolved with a boolean: true if incomplete, false otherwise.\n   */\n  isAttemptIncomplete(scormId, attempt, options = {}) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const scos = yield _this21.getScosWithData(scormId, attempt, options);\n      return scos.some(sco => sco.isvisible && sco.launch && _this21.isStatusIncomplete(sco.status));\n    })();\n  }\n  /**\n   * Given a launch URL, check if it's a external link.\n   * Based on Moodle's scorm_external_link.\n   *\n   * @param link Link to check.\n   * @returns Whether it's an external link.\n   */\n  isExternalLink(link) {\n    link = link.toLowerCase();\n    if (link.match(/^https?:\\/\\//i) && !CoreUrlUtils.isLocalFileUrl(link)) {\n      return true;\n    } else if (link.substring(0, 4) == 'www.') {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Check if the given SCORM is closed.\n   *\n   * @param scorm SCORM to check.\n   * @returns Whether the SCORM is closed.\n   */\n  isScormClosed(scorm) {\n    return !!(scorm.timeclose && CoreTimeUtils.timestamp() > scorm.timeclose);\n  }\n  /**\n   * Check if the given SCORM is downloadable.\n   *\n   * @param scorm SCORM to check.\n   * @returns Whether the SCORM is downloadable.\n   */\n  isScormDownloadable(scorm) {\n    return scorm.protectpackagedownloads !== undefined && scorm.protectpackagedownloads === false;\n  }\n  /**\n   * Check if the given SCORM is open.\n   *\n   * @param scorm SCORM to check.\n   * @returns Whether the SCORM is open.\n   */\n  isScormOpen(scorm) {\n    return !!(scorm.timeopen && scorm.timeopen > CoreTimeUtils.timestamp());\n  }\n  /**\n   * Check if a SCORM is unsupported in the app. If it's not, returns the error code to show.\n   *\n   * @param scorm SCORM to check.\n   * @returns String with error code if unsupported, undefined if supported.\n   */\n  isScormUnsupported(scorm) {\n    if (!this.isScormValidVersion(scorm)) {\n      return 'addon.mod_scorm.errorinvalidversion';\n    } else if (!this.isScormDownloadable(scorm)) {\n      return 'addon.mod_scorm.errornotdownloadable';\n    } else if (!this.isValidPackageUrl(this.getPackageUrl(scorm))) {\n      return 'addon.mod_scorm.errorpackagefile';\n    }\n  }\n  /**\n   * Check if it's a valid SCORM 1.2.\n   *\n   * @param scorm SCORM to check.\n   * @returns Whether the SCORM is valid.\n   */\n  isScormValidVersion(scorm) {\n    return scorm.version == 'SCORM_1.2';\n  }\n  /**\n   * Check if a SCO status is incomplete.\n   *\n   * @param status SCO status.\n   * @returns Whether it's incomplete.\n   */\n  isStatusIncomplete(status) {\n    return !status || status == 'notattempted' || status == 'incomplete' || status == 'browsed';\n  }\n  /**\n   * Check if a package URL is valid.\n   *\n   * @param packageUrl Package URL.\n   * @returns Whether it's valid.\n   */\n  isValidPackageUrl(packageUrl) {\n    if (!packageUrl) {\n      return false;\n    }\n    if (packageUrl.indexOf('imsmanifest.xml') > -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Report a SCO as being launched.\n   *\n   * @param scormId SCORM ID.\n   * @param scoId SCO ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logLaunchSco(scormId, scoId, siteId) {\n    const params = {\n      scormid: scormId,\n      scoid: scoId\n    };\n    return CoreCourseLogHelper.log('mod_scorm_launch_sco', params, AddonModScormProvider.COMPONENT, scormId, siteId);\n  }\n  /**\n   * Report a SCORM as being viewed.\n   *\n   * @param id Module ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(id, siteId) {\n    const params = {\n      scormid: id\n    };\n    return CoreCourseLogHelper.log('mod_scorm_view_scorm', params, AddonModScormProvider.COMPONENT, id, siteId);\n  }\n  /**\n   * Saves a SCORM tracking record.\n   *\n   * @param scoId Sco ID.\n   * @param attempt Attempt number.\n   * @param tracks Tracking data to store.\n   * @param scorm SCORM.\n   * @param offline Whether the attempt is offline.\n   * @param userData User data for this attempt and SCO. If not defined, it will be retrieved from DB. Recommended.\n   * @returns Promise resolved when data is saved.\n   */\n  saveTracks(scoId, attempt, tracks, scorm, offline, userData, siteId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (offline) {\n        if (!userData) {\n          userData = yield _this22.getScormUserData(scorm.id, attempt, {\n            offline,\n            cmId: scorm.coursemodule,\n            siteId\n          });\n        }\n        return AddonModScormOffline.saveTracks(scorm, scoId, attempt, tracks, userData, siteId);\n      }\n      yield _this22.saveTracksOnline(scorm.id, scoId, attempt, tracks, siteId);\n      // Tracks have been saved, update cached user data.\n      _this22.updateUserDataAfterSave(scorm.id, attempt, tracks, {\n        cmId: scorm.coursemodule,\n        siteId\n      });\n      CoreEvents.trigger(AddonModScormProvider.DATA_SENT_EVENT, {\n        scormId: scorm.id,\n        scoId: scoId,\n        attempt: attempt\n      }, CoreSites.getCurrentSiteId());\n    })();\n  }\n  /**\n   * Saves a SCORM tracking record.\n   *\n   * @param scormId SCORM ID.\n   * @param scoId Sco ID.\n   * @param attempt Attempt number.\n   * @param tracks Tracking data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data is saved.\n   */\n  saveTracksOnline(scormId, scoId, attempt, tracks, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!tracks || !tracks.length) {\n        return []; // Nothing to save.\n      }\n\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        scoid: scoId,\n        attempt: attempt,\n        tracks: tracks\n      };\n      CoreSync.blockOperation(AddonModScormProvider.COMPONENT, scormId, 'saveTracksOnline', site.id);\n      try {\n        const response = yield site.write('mod_scorm_insert_scorm_tracks', params);\n        return response.trackids;\n      } finally {\n        CoreSync.unblockOperation(AddonModScormProvider.COMPONENT, scormId, 'saveTracksOnline', site.id);\n      }\n    })();\n  }\n  /**\n   * Saves a SCORM tracking record using a synchronous call.\n   * Please use this function only if synchronous is a must. It's recommended to use saveTracks.\n   *\n   * @param scoId Sco ID.\n   * @param attempt Attempt number.\n   * @param tracks Tracking data to store.\n   * @param scorm SCORM.\n   * @param offline Whether the attempt is offline.\n   * @param userData User data for this attempt and SCO. Required if offline=true.\n   * @returns In online returns true if data is inserted, false otherwise.\n   *         In offline returns true if data to insert is valid, false otherwise. True doesn't mean that the\n   *         data has been stored, this function can return true but the insertion can still fail somehow.\n   */\n  saveTracksSync(scoId, attempt, tracks, scorm, offline, userData) {\n    if (offline) {\n      return AddonModScormOffline.saveTracksSync(scorm, scoId, attempt, tracks, userData !== null && userData !== void 0 ? userData : {});\n    } else {\n      const success = this.saveTracksSyncOnline(scoId, attempt, tracks);\n      if (success) {\n        // Tracks have been saved, update cached user data.\n        this.updateUserDataAfterSave(scorm.id, attempt, tracks, {\n          cmId: scorm.coursemodule\n        });\n        CoreEvents.trigger(AddonModScormProvider.DATA_SENT_EVENT, {\n          scormId: scorm.id,\n          scoId: scoId,\n          attempt: attempt\n        }, CoreSites.getCurrentSiteId());\n      }\n      return success;\n    }\n  }\n  /**\n   * Saves a SCORM tracking record using a synchronous call.\n   * Please use this function only if synchronous is a must. It's recommended to use saveTracksOnline.\n   *\n   * @param scoId Sco ID.\n   * @param attempt Attempt number.\n   * @param tracks Tracking data.\n   * @returns True if success, false otherwise.\n   */\n  saveTracksSyncOnline(scoId, attempt, tracks) {\n    if (!tracks || !tracks.length) {\n      return true; // Nothing to save.\n    }\n\n    const params = {\n      scoid: scoId,\n      attempt: attempt,\n      tracks: tracks\n    };\n    const currentSite = CoreSites.getCurrentSite();\n    if (!currentSite) {\n      return false;\n    }\n    const preSets = {\n      siteUrl: currentSite.getURL(),\n      wsToken: currentSite.getToken()\n    };\n    const wsFunction = 'mod_scorm_insert_scorm_tracks';\n    try {\n      const response = CoreWS.syncCall(wsFunction, params, preSets);\n      return !!(response && response.trackids);\n    } catch (_unused) {\n      return false;\n    }\n  }\n  /**\n   * Check if the SCORM main file should be downloaded.\n   * This function should only be called if the SCORM can be downloaded (not downloaded or outdated).\n   *\n   * @param scorm SCORM to check.\n   * @param isOutdated True if package outdated, false if not downloaded, undefined to calculate it.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if it should be downloaded, false otherwise.\n   */\n  shouldDownloadMainFile(scorm, isOutdated, siteId) {\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const component = AddonModScormProvider.COMPONENT;\n      if (isOutdated === undefined) {\n        // Calculate if it's outdated.\n        const data = yield CoreUtils.ignoreErrors(CoreFilepool.getPackageData(siteId, component, scorm.coursemodule));\n        if (!data) {\n          // Package not found, not downloaded.\n          return false;\n        }\n        const isOutdated = data.status == CoreConstants.OUTDATED || data.status == CoreConstants.DOWNLOADING && data.previous == CoreConstants.OUTDATED;\n        // Package needs to be downloaded if it's not outdated (not downloaded) or if the hash has changed.\n        return !isOutdated || data.extra != scorm.sha1hash;\n      } else if (isOutdated) {\n        // The package is outdated, but maybe the file hasn't changed.\n        const extra = yield CoreUtils.ignoreErrors(CoreFilepool.getPackageExtra(siteId, component, scorm.coursemodule));\n        if (!extra) {\n          // Package not found, not downloaded.\n          return true;\n        }\n        return scorm.sha1hash != extra;\n      } else {\n        // Package is not outdated and not downloaded, download the main file.\n        return true;\n      }\n    })();\n  }\n  /**\n   * If needed, updates cached user data after saving tracks in online.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Attempt number.\n   * @param tracks Tracking data saved.\n   * @param options Other options.\n   * @returns Promise resolved when updated.\n   */\n  updateUserDataAfterSave(scormId, attempt, tracks, options) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      if (!tracks || !tracks.length) {\n        return;\n      }\n      // Check if we need to update. We only update if we sent some track with a dot notation.\n      const needsUpdate = tracks.some(track => track.element && track.element.indexOf('.') > -1);\n      if (!needsUpdate) {\n        return;\n      }\n      yield _this23.getScormUserDataOnline(scormId, attempt, {\n        cmId: options.cmId,\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */,\n        siteId: options.siteId\n      });\n    })();\n  }\n}\n_class = AddonModScormProvider;\n_class.COMPONENT = 'mmaModScorm';\n// Public constants.\n_class.GRADESCOES = 0;\n_class.GRADEHIGHEST = 1;\n_class.GRADEAVERAGE = 2;\n_class.GRADESUM = 3;\n_class.HIGHESTATTEMPT = 0;\n_class.AVERAGEATTEMPT = 1;\n_class.FIRSTATTEMPT = 2;\n_class.LASTATTEMPT = 3;\n_class.MODEBROWSE = 'browse';\n_class.MODENORMAL = 'normal';\n_class.MODEREVIEW = 'review';\n_class.SCORM_FORCEATTEMPT_NO = 0;\n_class.SCORM_FORCEATTEMPT_ONCOMPLETE = 1;\n_class.SCORM_FORCEATTEMPT_ALWAYS = 2;\n_class.SKIPVIEW_NEVER = 0;\n_class.SKIPVIEW_FIRST = 1;\n_class.SKIPVIEW_ALWAYS = 2;\n// Events.\n_class.LAUNCH_NEXT_SCO_EVENT = 'addon_mod_scorm_launch_next_sco';\n_class.LAUNCH_PREV_SCO_EVENT = 'addon_mod_scorm_launch_prev_sco';\n_class.UPDATE_TOC_EVENT = 'addon_mod_scorm_update_toc';\n_class.GO_OFFLINE_EVENT = 'addon_mod_scorm_go_offline';\n_class.DATA_SENT_EVENT = 'addon_mod_scorm_data_sent';\n_class.ɵfac = function AddonModScormProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModScorm = makeSingleton(AddonModScormProvider);","map":{"version":3,"names":["CoreConstants","CoreError","CoreSite","CoreCourseLogHelper","CoreFilepool","CoreSites","CoreSitesReadingStrategy","CoreSync","CoreTextUtils","CoreTimeUtils","CoreUrlUtils","CoreUtils","CoreWS","makeSingleton","Translate","CoreEvents","CorePath","AddonModScormOffline","AddonModScormSyncProvider","VALID_STATUSES","STATUSES","STATUS_TO_ICON","assetc","asset","browsed","completed","failed","incomplete","minus","notattempted","passed","plus","popdown","popup","suspend","wait","ROOT_CACHE_KEY","AddonModScormProvider","calculateScormGrade","scorm","onlineAttempts","Object","keys","length","whatgrade","FIRSTATTEMPT","score","LASTATTEMPT","lastCompleted","attemptNumber","hasCompletedPassedSCO","Math","max","num","HIGHESTATTEMPT","grade","AVERAGEATTEMPT","sumGrades","total","round","calculateScormSize","_this","_asyncToGenerator","packagesize","getRemoteFileSize","getPackageUrl","countAttemptsLeft","attemptsCount","maxattempt","Number","MAX_VALUE","isNaN","determineAttemptAndMode","mode","attempt","newAttempt","canSaveTracks","hidebrowse","MODENORMAL","MODEBROWSE","forcenewattempt","SCORM_FORCEATTEMPT_ALWAYS","MODEREVIEW","displayTocInPlayer","hidetoc","evalPrerequisites","prerequisites","trackData","stack","replace","elements","trim","split","forEach","element","match","re","reOther","matches","repeat","set","count","setElement","undefined","status","test","_element$match","_otherMatches$","otherMatches","value","oper","push","eval","join","formatGrade","instant","grademethod","GRADESCOES","maxgrade","$a","roundToDecimals","String","formatTocToArray","toc","level","formatted","node","sco","concat","children","getAccessInformation","scormId","options","_this2","site","getSite","siteId","wsAvailable","params","scormid","preSets","_objectSpread","cacheKey","getAccessInformationCacheKey","component","COMPONENT","componentId","cmId","getReadingStrategyPreSets","readingStrategy","read","getAttemptCount","_this3","getCurrentSiteId","userId","getUserId","onlineCount","offlineAttempts","Promise","all","getAttemptCountOnline","getAttempts","result","online","offline","lastAttempt","i","map","entry","indexOf","getAttemptCountCacheKey","_this4","userid","ignoremissingcompletion","ignoreMissing","updateFrequency","FREQUENCY_SOMETIMES","response","attemptscount","getAttemptGrade","_this5","attemptScore","scos","values","sum","data","getScormUserData","id","coursemodule","scoId","userData","userdata","score_raw","scormtype","scoreRaw","parseFloat","GRADEHIGHEST","GRADEAVERAGE","GRADESUM","getOrganizations","_this6","getScos","organizations","organization","parent","identifier","title","sortorder","getOrganizationToc","_this7","getScosWithData","rootScos","index","packageurl","reference","_this8","getScormUserDataOnline","getScormUserDataCacheKey","getScormUserDataCommonCacheKey","_this9","scoid","defaultdata","objectToKeyValueMap","getScosCacheKey","_this10","scoes","filter","_this11","userDataOptions","trackDataBySCO","scosWithData","scoData","isvisible","prereq","exitvar","exitvalue","scoreraw","getScoSrc","_this12","_sco$extradata","_scorm$moduleurl","launchUrl","launch","parametersEntry","extradata","find","parameters","connector","charAt","substring","isExternalLink","dirPath","getPackageDirUrlByUrl","moduleurl","concatenatePaths","getScormFolder","moduleUrl","getPackageDirPathByUrl","getScormFileList","files","isScormUnsupported","warningMessage","fileurl","filepath","filename","filesize","timemodified","getScoStatusIcon","imageName","descName","suspendedStr","isStatusIncomplete","icon","description","getScormDataCacheKey","courseId","getScormByField","key","_this13","courseids","FREQUENCY_RARELY","currentScorm","scorms","timeopen","_response$warnings","warning","warnings","itemid","message","scormOptions","scormstandard","scormStandard","getScorm","getScormById","getScormGradeMethod","invalidateAccessInformation","_this14","invalidateWsCacheForKey","invalidateAllScormData","_this15","invalidateAttemptCount","invalidateScos","invalidateScormUserData","_this16","invalidateContent","moduleId","_this17","invalidateFilesByComponent","invalidateScormData","_this18","_this19","invalidateWsCacheForKeyStartingWith","_this20","isAttemptIncomplete","_this21","some","link","toLowerCase","isLocalFileUrl","isScormClosed","timeclose","timestamp","isScormDownloadable","protectpackagedownloads","isScormOpen","isScormValidVersion","isValidPackageUrl","version","packageUrl","logLaunchSco","log","logView","saveTracks","tracks","_this22","saveTracksOnline","updateUserDataAfterSave","trigger","DATA_SENT_EVENT","blockOperation","write","trackids","unblockOperation","saveTracksSync","success","saveTracksSyncOnline","currentSite","getCurrentSite","siteUrl","getURL","wsToken","getToken","wsFunction","syncCall","_unused","shouldDownloadMainFile","isOutdated","ignoreErrors","getPackageData","OUTDATED","DOWNLOADING","previous","extra","sha1hash","getPackageExtra","_this23","needsUpdate","track","_class","SCORM_FORCEATTEMPT_NO","SCORM_FORCEATTEMPT_ONCOMPLETE","SKIPVIEW_NEVER","SKIPVIEW_FIRST","SKIPVIEW_ALWAYS","LAUNCH_NEXT_SCO_EVENT","LAUNCH_PREV_SCO_EVENT","UPDATE_TOC_EVENT","GO_OFFLINE_EVENT","factory","ɵfac","providedIn","AddonModScorm"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/scorm/services/scorm.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreConstants } from '@/core/constants';\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSync } from '@services/sync';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWS, CoreWSExternalFile, CoreWSExternalWarning, CoreWSFile, CoreWSPreSets } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { CorePath } from '@singletons/path';\nimport { AddonModScormOffline } from './scorm-offline';\nimport { AddonModScormAutoSyncEventData, AddonModScormSyncProvider } from './scorm-sync';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\n// Private constants.\nconst VALID_STATUSES = ['notattempted', 'passed', 'completed', 'failed', 'incomplete', 'browsed', 'suspend'];\nconst STATUSES = {\n    'passed': 'passed',\n    'completed': 'completed',\n    'failed': 'failed',\n    'incomplete': 'incomplete',\n    'browsed': 'browsed',\n    'not attempted': 'notattempted',\n    'p': 'passed',\n    'c': 'completed',\n    'f': 'failed',\n    'i': 'incomplete',\n    'b': 'browsed',\n    'n': 'notattempted',\n};\nconst STATUS_TO_ICON = {\n    assetc: 'far-file-zipper',\n    asset: 'far-file-zipper',\n    browsed: 'fas-book',\n    completed: 'far-square-check',\n    failed: 'fas-xmark',\n    incomplete: 'far-pen-to-square',\n    minus: 'fas-minus',\n    notattempted: 'far-square',\n    passed: 'fas-check',\n    plus: 'fas-plus',\n    popdown: 'far-rectangle-xmark',\n    popup: 'fas-window-restore',\n    suspend: 'fas-pause',\n    wait: 'far-clock',\n};\nconst ROOT_CACHE_KEY = 'mmaModScorm:';\n\n/**\n * Service that provides some features for SCORM.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModScormProvider {\n\n    static readonly COMPONENT = 'mmaModScorm';\n\n    // Public constants.\n    static readonly GRADESCOES     = 0;\n    static readonly GRADEHIGHEST   = 1;\n    static readonly GRADEAVERAGE   = 2;\n    static readonly GRADESUM       = 3;\n\n    static readonly HIGHESTATTEMPT = 0;\n    static readonly AVERAGEATTEMPT = 1;\n    static readonly FIRSTATTEMPT   = 2;\n    static readonly LASTATTEMPT    = 3;\n\n    static readonly MODEBROWSE = 'browse';\n    static readonly MODENORMAL = 'normal';\n    static readonly MODEREVIEW = 'review';\n\n    static readonly SCORM_FORCEATTEMPT_NO         = 0;\n    static readonly SCORM_FORCEATTEMPT_ONCOMPLETE = 1;\n    static readonly SCORM_FORCEATTEMPT_ALWAYS     = 2;\n\n    static readonly SKIPVIEW_NEVER = 0;\n    static readonly SKIPVIEW_FIRST = 1;\n    static readonly SKIPVIEW_ALWAYS = 2;\n\n    // Events.\n    static readonly LAUNCH_NEXT_SCO_EVENT = 'addon_mod_scorm_launch_next_sco';\n    static readonly LAUNCH_PREV_SCO_EVENT = 'addon_mod_scorm_launch_prev_sco';\n    static readonly UPDATE_TOC_EVENT = 'addon_mod_scorm_update_toc';\n    static readonly GO_OFFLINE_EVENT = 'addon_mod_scorm_go_offline';\n    static readonly DATA_SENT_EVENT = 'addon_mod_scorm_data_sent';\n\n    /**\n     * Calculates the SCORM grade based on the grading method and the list of attempts scores.\n     * We only treat online attempts to calculate a SCORM grade.\n     *\n     * @param scorm SCORM.\n     * @param onlineAttempts Object with the online attempts.\n     * @returns Grade. -1 if no grade.\n     */\n    calculateScormGrade(scorm: AddonModScormScorm, onlineAttempts: Record<number, AddonModScormAttemptGrade>): number {\n        if (!onlineAttempts || !Object.keys(onlineAttempts).length) {\n            return -1;\n        }\n\n        switch (scorm.whatgrade) {\n            case AddonModScormProvider.FIRSTATTEMPT:\n                return onlineAttempts[1] ? onlineAttempts[1].score : -1;\n\n            case AddonModScormProvider.LASTATTEMPT: {\n                // Search the last completed attempt number.\n                let lastCompleted = 0;\n                for (const attemptNumber in onlineAttempts) {\n                    if (onlineAttempts[attemptNumber].hasCompletedPassedSCO) {\n                        lastCompleted = Math.max(onlineAttempts[attemptNumber].num, lastCompleted);\n                    }\n                }\n\n                if (lastCompleted > 0) {\n                    return onlineAttempts[lastCompleted].score;\n                } else if (onlineAttempts[1]) {\n                    // If no completed attempt found, use the first attempt for consistency with LMS.\n                    return onlineAttempts[1].score;\n                }\n\n                return -1;\n            }\n\n            case AddonModScormProvider.HIGHESTATTEMPT: {\n                // Search the highest grade.\n                let grade = 0;\n                for (const attemptNumber in onlineAttempts) {\n                    grade = Math.max(onlineAttempts[attemptNumber].score, grade);\n                }\n\n                return grade;\n            }\n\n            case AddonModScormProvider.AVERAGEATTEMPT: {\n                // Calculate the average.\n                let sumGrades = 0;\n                let total = 0;\n\n                for (const attemptNumber in onlineAttempts) {\n                    sumGrades += onlineAttempts[attemptNumber].score;\n                    total++;\n                }\n\n                return Math.round(sumGrades / total);\n            }\n\n            default:\n                return -1;\n        }\n    }\n\n    /**\n     * Calculates the size of a SCORM.\n     *\n     * @param scorm SCORM.\n     * @returns Promise resolved with the SCORM size.\n     */\n    async calculateScormSize(scorm: AddonModScormScorm): Promise<number> {\n        if (scorm.packagesize) {\n            return scorm.packagesize;\n        }\n\n        return CoreWS.getRemoteFileSize(this.getPackageUrl(scorm));\n    }\n\n    /**\n     * Count the attempts left for the given scorm.\n     *\n     * @param scorm SCORM.\n     * @param attemptsCount Number of attempts performed.\n     * @returns Number of attempts left.\n     */\n    countAttemptsLeft(scorm: AddonModScormScorm, attemptsCount: number): number {\n        if (!scorm.maxattempt) {\n            return Number.MAX_VALUE; // Unlimited attempts.\n        }\n\n        attemptsCount = Number(attemptsCount); // Make sure it's a number.\n        if (isNaN(attemptsCount)) {\n            return -1;\n        }\n\n        return Math.max(scorm.maxattempt - attemptsCount, 0);\n    }\n\n    /**\n     * Returns the mode and attempt number to use based on mode selected and SCORM data.\n     * This function is based on Moodle's scorm_check_mode.\n     *\n     * @param scorm SCORM.\n     * @param mode Selected mode.\n     * @param attempt Current attempt.\n     * @param newAttempt Whether it should start a new attempt.\n     * @param incomplete Whether current attempt is incomplete.\n     * @param canSaveTracks Whether the user can save tracks.\n     * @returns Mode, attempt number and whether to start a new attempt.\n     */\n    determineAttemptAndMode(\n        scorm: AddonModScormScorm,\n        mode: string,\n        attempt: number,\n        newAttempt?: boolean,\n        incomplete?: boolean,\n        canSaveTracks = true,\n    ): {mode: string; attempt: number; newAttempt: boolean} {\n        if (!canSaveTracks) {\n            return {\n                mode: scorm.hidebrowse ? AddonModScormProvider.MODENORMAL : mode,\n                attempt,\n                newAttempt: false,\n            };\n        }\n\n        if (mode == AddonModScormProvider.MODEBROWSE) {\n            if (scorm.hidebrowse) {\n                // Prevent Browse mode if hidebrowse is set.\n                mode = AddonModScormProvider.MODENORMAL;\n            } else {\n                // We don't need to check attempts as browse mode is set.\n                if (attempt == 0) {\n                    attempt = 1;\n                    newAttempt = true;\n                }\n\n                return {\n                    mode: mode,\n                    attempt: attempt,\n                    newAttempt: !!newAttempt,\n                };\n            }\n        }\n\n        if (scorm.forcenewattempt == AddonModScormProvider.SCORM_FORCEATTEMPT_ALWAYS) {\n            // This SCORM is configured to force a new attempt on every re-entry.\n            return {\n                mode: AddonModScormProvider.MODENORMAL,\n                attempt: attempt + 1,\n                newAttempt: true,\n            };\n        }\n\n        // Validate user request to start a new attempt.\n        if (attempt == 0) {\n            newAttempt = true;\n        } else if (incomplete) {\n            // The option to start a new attempt should never have been presented. Force false.\n            newAttempt = false;\n        } else if (scorm.forcenewattempt) {\n            // A new attempt should be forced for already completed attempts.\n            newAttempt = true;\n        }\n\n        if (newAttempt && (!scorm.maxattempt || attempt < scorm.maxattempt)) {\n            // Create a new attempt. Force mode normal.\n            attempt++;\n            mode = AddonModScormProvider.MODENORMAL;\n        } else {\n            if (incomplete) {\n                // We can't review an incomplete attempt.\n                mode = AddonModScormProvider.MODENORMAL;\n            } else {\n                // We aren't starting a new attempt and the current one is complete, force review mode.\n                mode = AddonModScormProvider.MODEREVIEW;\n            }\n        }\n\n        return {\n            mode: mode,\n            attempt: attempt,\n            newAttempt: !!newAttempt,\n        };\n    }\n\n    /**\n     * Check if TOC should be displayed in the player.\n     *\n     * @param scorm SCORM.\n     * @returns Whether it should display TOC.\n     */\n    displayTocInPlayer(scorm: AddonModScormScorm): boolean {\n        return scorm.hidetoc !== 3;\n    }\n\n    /**\n     * This is a little language parser for AICC_SCRIPT.\n     * Evaluates the expression and returns a boolean answer.\n     * See 2.3.2.5.1. Sequencing/Navigation Today - from the SCORM 1.2 spec (CAM).\n     *\n     * @param prerequisites The AICC_SCRIPT prerequisites expression.\n     * @param trackData The tracked user data of each SCO.\n     * @returns Whether the prerequisites are fulfilled.\n     */\n    evalPrerequisites(prerequisites: string, trackData: Record<string, Record<string, AddonModScormDataValue>>): boolean {\n        const stack: string[] = []; // List of prerequisites.\n\n        // Expand the amp entities.\n        prerequisites = prerequisites.replace(/&amp;/gi, '&');\n        // Find all my parsable tokens.\n        prerequisites = prerequisites.replace(/(&|\\||\\(|\\)|~)/gi, '\\t$1\\t');\n        // Expand operators.\n        prerequisites = prerequisites.replace(/&/gi, '&&');\n        prerequisites = prerequisites.replace(/\\|/gi, '||');\n\n        // Now - grab all the tokens.\n        const elements = prerequisites.trim().split('\\t');\n\n        // Process each token to build an expression to be evaluated.\n        elements.forEach((element) => {\n            element = element.trim();\n            if (!element) {\n                return;\n            }\n\n            if (!element.match(/^(&&|\\|\\||\\(|\\))$/gi)) {\n                // Create each individual expression.\n                // Search for ~ = <> X*{} .\n\n                const re = /^(\\d+)\\*\\{(.+)\\}$/; // Sets like 3*{S34, S36, S37, S39}.\n                const reOther = /^(.+)(=|<>)(.+)$/; // Other symbols.\n                const matches = element.match(re);\n\n                if (matches) {\n                    const repeat = Number(matches[1]);\n                    const set = matches[2].split(',') || [];\n                    let count = 0;\n\n                    set.forEach((setElement) => {\n                        setElement = setElement.trim();\n\n                        if (trackData[setElement] !== undefined &&\n                                (trackData[setElement].status == 'completed' || trackData[setElement].status == 'passed')) {\n                            count++;\n                        }\n                    });\n\n                    if (count >= repeat) {\n                        element = 'true';\n                    } else {\n                        element = 'false';\n                    }\n                } else if (element == '~') {\n                    // Not maps ~.\n                    element = '!';\n                } else if (reOther.test(element)) {\n                    // Other symbols = | <> .\n                    const otherMatches = element.match(reOther) ?? [];\n                    element = otherMatches[1]?.trim();\n\n                    if (trackData[element] !== undefined) {\n                        let value = otherMatches[3].trim().replace(/('|\")/gi, '');\n                        let oper: string;\n\n                        if (STATUSES[value] !== undefined) {\n                            value = STATUSES[value];\n                        }\n\n                        if (otherMatches[2] == '<>') {\n                            oper = '!=';\n                        } else {\n                            oper = '==';\n                        }\n\n                        element = '(\\'' + trackData[element].status + '\\' ' + oper + ' \\'' + value + '\\')';\n                    } else {\n                        element = 'false';\n                    }\n                } else {\n                    // Everything else must be an element defined like S45 ...\n                    if (trackData[element] !== undefined &&\n                            (trackData[element].status == 'completed' || trackData[element].status == 'passed')) {\n                        element = 'true';\n                    } else {\n                        element = 'false';\n                    }\n                }\n            }\n\n            // Add the element to the list of prerequisites.\n            stack.push(' ' + element + ' ');\n        });\n\n        // eslint-disable-next-line no-eval\n        return eval(stack.join('') + ';');\n    }\n\n    /**\n     * Formats a grade to be displayed.\n     *\n     * @param scorm SCORM.\n     * @param grade Grade.\n     * @returns Grade to display.\n     */\n    formatGrade(scorm: AddonModScormScorm, grade: number): string {\n        if (grade === undefined || grade == -1) {\n            return Translate.instant('core.none');\n        }\n\n        if (scorm.grademethod !== AddonModScormProvider.GRADESCOES && scorm.maxgrade) {\n            grade = (grade / scorm.maxgrade) * 100;\n\n            return Translate.instant('core.percentagenumber', { $a: CoreTextUtils.roundToDecimals(grade, 2) });\n        }\n\n        return String(grade);\n    }\n\n    /**\n     * Formats a tree-like TOC into an array.\n     *\n     * @param toc SCORM's TOC (tree format).\n     * @param level The level of the TOC we're right now. 0 by default.\n     * @returns SCORM's TOC (array format).\n     */\n    formatTocToArray(toc: AddonModScormTOCTreeSco[], level: number = 0): AddonModScormTOCListSco[] {\n        if (!toc || !toc.length) {\n            return [];\n        }\n\n        let formatted: AddonModScormTOCListSco[] = [];\n\n        toc.forEach((node) => {\n            const sco = <AddonModScormTOCListSco> node;\n            sco.level = level;\n            formatted.push(sco);\n\n            formatted = formatted.concat(this.formatTocToArray(node.children, level + 1));\n        });\n\n        return formatted;\n    }\n\n    /**\n     * Get access information for a given SCORM.\n     *\n     * @param scormId SCORM ID.\n     * @param options Other options.\n     * @returns Object with access information.\n     * @since 3.7\n     */\n    async getAccessInformation(\n        scormId: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModScormGetScormAccessInformationWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        if (!site.wsAvailable('mod_scorm_get_scorm_access_information')) {\n            // Access information not available for 3.6 or older sites.\n            return {};\n        }\n\n        const params: AddonModScormGetScormAccessInformationWSParams = {\n            scormid: scormId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAccessInformationCacheKey(scormId),\n            component: AddonModScormProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        return site.read('mod_scorm_get_scorm_access_information', params, preSets);\n    }\n\n    /**\n     * Get cache key for access information WS calls.\n     *\n     * @param scormId SCORM ID.\n     * @returns Cache key.\n     */\n    protected getAccessInformationCacheKey(scormId: number): string {\n        return ROOT_CACHE_KEY + 'accessInfo:' + scormId;\n    }\n\n    /**\n     * Get the number of attempts done by a user in the given SCORM.\n     *\n     * @param scormId SCORM ID.\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    async getAttemptCount(\n        scormId: number,\n        options: AddonModScormGetAttemptCountOptions = {},\n    ): Promise<AddonModScormAttemptCountResult> {\n\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        const site = await CoreSites.getSite(options.siteId);\n        const userId = options.userId || site.getUserId();\n\n        const [onlineCount, offlineAttempts] = await Promise.all([\n            this.getAttemptCountOnline(scormId, options),\n            AddonModScormOffline.getAttempts(scormId, options.siteId, userId),\n        ]);\n\n        const result: AddonModScormAttemptCountResult = {\n            online: [],\n            offline: [],\n            total: onlineCount,\n            lastAttempt: {\n                num: onlineCount,\n                offline: false,\n            },\n        };\n\n        // Fill online attempts array.\n        for (let i = 1; i <= onlineCount; i++) {\n            result.online.push(i);\n        }\n\n        // Get only attempt numbers for offline attempts.\n        result.offline = offlineAttempts.map((entry) => {\n            // Calculate last attempt. We use >= to prioritize offline events if an attempt is both online and offline.\n            if (entry.attempt >= result.lastAttempt.num) {\n                result.lastAttempt.num = entry.attempt;\n                result.lastAttempt.offline = true;\n            }\n\n            return entry.attempt;\n        });\n\n        // Calculate the total.\n        result.offline.forEach((attempt) => {\n            // Check if this attempt also exists in online, it might have been copied to local.\n            if (result.online.indexOf(attempt) == -1) {\n                result.total++;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Get cache key for SCORM attempt count WS calls.\n     *\n     * @param scormId SCORM ID.\n     * @param userId User ID. If not defined, current user.\n     * @returns Cache key.\n     */\n    protected getAttemptCountCacheKey(scormId: number, userId: number): string {\n        return ROOT_CACHE_KEY + 'attemptcount:' + scormId + ':' + userId;\n    }\n\n    /**\n     * Get the number of attempts done by a user in the given SCORM in online.\n     *\n     * @param scormId SCORM ID.\n     * @param options Other options.\n     * @returns Promise resolved when the attempt count is retrieved.\n     */\n    async getAttemptCountOnline(scormId: number, options: AddonModScormGetAttemptCountOptions = {}): Promise<number> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const userId = options.userId || site.getUserId();\n        const params: AddonModScormGetScormAttemptCountWSParams = {\n            scormid: scormId,\n            userid: userId,\n            ignoremissingcompletion: options.ignoreMissing,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAttemptCountCacheKey(scormId, userId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModScormProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModScormGetScormAttemptCountWSResponse>(\n            'mod_scorm_get_scorm_attempt_count',\n            params,\n            preSets,\n        );\n\n        return response.attemptscount;\n    }\n\n    /**\n     * Get the grade data for a certain attempt.\n     * Mostly based on Moodle's scorm_grade_user_attempt.\n     *\n     * @param scorm SCORM.\n     * @param attempt Attempt number.\n     * @param offline Whether the attempt is offline.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the grade. If the attempt hasn't reported grade/completion, it will be -1.\n     */\n    async getAttemptGrade(\n        scorm: AddonModScormScorm,\n        attempt: number,\n        offline?: boolean,\n        siteId?: string,\n    ): Promise<AddonModScormAttemptGrade> {\n        const attemptScore = {\n            scos: 0,\n            values: 0,\n            max: 0,\n            sum: 0,\n        };\n\n        // Get the user data and use it to calculate the grade.\n        const data = await this.getScormUserData(scorm.id, attempt, { offline, cmId: scorm.coursemodule, siteId });\n\n        for (const scoId in data) {\n            const sco = data[scoId];\n            const userData = sco.userdata;\n\n            if (userData.status == 'completed' || userData.status == 'passed') {\n                attemptScore.scos++;\n            }\n\n            if (userData.score_raw || (scorm.scormtype !== undefined &&\n                        scorm.scormtype == 'sco' && userData.score_raw !== undefined)) {\n\n                const scoreRaw = parseFloat(<string> userData.score_raw);\n                attemptScore.values++;\n                attemptScore.sum += scoreRaw;\n                attemptScore.max = Math.max(scoreRaw, attemptScore.max);\n            }\n        }\n\n        let score = 0;\n\n        switch (scorm.grademethod) {\n            case AddonModScormProvider.GRADEHIGHEST:\n                score = attemptScore.max;\n                break;\n\n            case AddonModScormProvider.GRADEAVERAGE:\n                if (attemptScore.values > 0) {\n                    score = attemptScore.sum / attemptScore.values;\n                } else {\n                    score = 0;\n                }\n                break;\n\n            case AddonModScormProvider.GRADESUM:\n                score = attemptScore.sum;\n                break;\n\n            case AddonModScormProvider.GRADESCOES:\n                score = attemptScore.scos;\n                break;\n\n            default:\n                score = attemptScore.max; // Remote Learner GRADEHIGHEST is default.\n        }\n\n        return {\n            num: attempt,\n            score,\n            hasCompletedPassedSCO: attemptScore.scos > 0,\n        };\n    }\n\n    /**\n     * Get the list of a organizations defined in a SCORM package.\n     *\n     * @param scormId SCORM ID.\n     * @param options Other options.\n     * @returns Promise resolved with the list of organizations.\n     */\n    async getOrganizations(scormId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModScormOrganization[]> {\n        const scos = await this.getScos(scormId, options);\n\n        const organizations: AddonModScormOrganization[] = [];\n\n        scos.forEach((sco) => {\n            // Is an organization entry?\n            if (sco.organization == '' && sco.parent == '/' && sco.scormtype == '') {\n                organizations.push({\n                    identifier: sco.identifier,\n                    title: sco.title,\n                    sortorder: sco.sortorder,\n                });\n            }\n        });\n\n        return organizations;\n    }\n\n    /**\n     * Get the organization Toc any\n     *\n     * @param scormId SCORM ID.\n     * @param attempt The attempt number (to populate SCO track data).\n     * @param options Other options.\n     * @returns Promise resolved with the toc object.\n     */\n    async getOrganizationToc(\n        scormId: number,\n        attempt: number,\n        options: AddonModScormGetScosWithDataOptions = {},\n    ): Promise<AddonModScormTOCTreeSco[]> {\n\n        const scos = <AddonModScormTOCTreeSco[]> await this.getScosWithData(scormId, attempt, options);\n\n        const map: Record<string, number> = {};\n        const rootScos: AddonModScormTOCTreeSco[] = [];\n\n        scos.forEach((sco, index) => {\n            sco.children = [];\n            map[sco.identifier] = index;\n\n            if (sco.parent !== '/') {\n                if (sco.parent == options.organization) {\n                    // It's a root SCO, add it to the root array.\n                    rootScos.push(sco);\n                } else {\n                    // Add this sco to the parent.\n                    scos[map[sco.parent]].children.push(sco);\n                }\n            }\n        });\n\n        return rootScos;\n    }\n\n    /**\n     * Get the package URL of a given SCORM.\n     *\n     * @param scorm SCORM.\n     * @returns Package URL.\n     */\n    getPackageUrl(scorm: AddonModScormScorm): string {\n        if (scorm.packageurl) {\n            return scorm.packageurl;\n        }\n        if (scorm.reference) {\n            return scorm.reference;\n        }\n\n        return '';\n    }\n\n    /**\n     * Get the user data for a certain SCORM and attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param options Other options.\n     * @returns Promise resolved when the user data is retrieved.\n     */\n    async getScormUserData(\n        scormId: number,\n        attempt: number,\n        options: AddonModScormGetUserDataOptions = {},\n    ): Promise<AddonModScormUserDataMap> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        if (!options.offline) {\n            return this.getScormUserDataOnline(scormId, attempt, options);\n        }\n\n        // Get SCOs if not provided.\n        if (!options.scos) {\n            options.scos = await this.getScos(scormId, options);\n        }\n\n        return AddonModScormOffline.getScormUserData(scormId, attempt, options.scos, options.siteId);\n    }\n\n    /**\n     * Get cache key for SCORM user data WS calls.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @returns Cache key.\n     */\n    protected getScormUserDataCacheKey(scormId: number, attempt: number): string {\n        return this.getScormUserDataCommonCacheKey(scormId) + ':' + attempt;\n    }\n\n    /**\n     * Get common cache key for SCORM user data WS calls.\n     *\n     * @param scormId SCORM ID.\n     * @returns Cache key.\n     */\n    protected getScormUserDataCommonCacheKey(scormId: number): string {\n        return ROOT_CACHE_KEY + 'userdata:' + scormId;\n    }\n\n    /**\n     * Get the user data for a certain SCORM and attempt in online.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param options Other options.\n     * @returns Promise resolved when the user data is retrieved.\n     */\n    async getScormUserDataOnline(\n        scormId: number,\n        attempt: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModScormUserDataMap> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModScormGetScormUserDataWSParams = {\n            scormid: scormId,\n            attempt: attempt,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getScormUserDataCacheKey(scormId, attempt),\n            component: AddonModScormProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModScormGetScormUserDataWSResponse>('mod_scorm_get_scorm_user_data', params, preSets);\n\n        // Format the response.\n        const data: AddonModScormUserDataMap = {};\n\n        response.data.forEach((sco) => {\n            data[sco.scoid] = {\n                scoid: sco.scoid,\n                defaultdata: <Record<string, AddonModScormDataValue>> CoreUtils.objectToKeyValueMap(\n                    sco.defaultdata,\n                    'element',\n                    'value',\n                ),\n                userdata: <Record<string, AddonModScormDataValue>> CoreUtils.objectToKeyValueMap(sco.userdata, 'element', 'value'),\n            };\n\n        });\n\n        return data;\n    }\n\n    /**\n     * Get cache key for get SCORM scos WS calls.\n     *\n     * @param scormId SCORM ID.\n     * @returns Cache key.\n     */\n    protected getScosCacheKey(scormId: number): string {\n        return ROOT_CACHE_KEY + 'scos:' + scormId;\n    }\n\n    /**\n     * Retrieves the list of SCO objects for a given SCORM and organization.\n     *\n     * @param scormId SCORM ID.\n     * @param options Other options.\n     * @returns Promise resolved with a list of SCO.\n     */\n    async getScos(scormId: number, options: AddonModScormOrganizationOptions = {}): Promise<AddonModScormWSSco[]> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        // Don't send the organization to the WS, we'll filter them locally.\n        const params: AddonModScormGetScormScoesWSParams = {\n            scormid: scormId,\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getScosCacheKey(scormId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n            component: AddonModScormProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModScormGetScormScoesWSResponse>('mod_scorm_get_scorm_scoes', params, preSets);\n\n        if (options.organization) {\n            // Filter SCOs by organization.\n            return response.scoes.filter((sco) => sco.organization == options.organization);\n        }\n\n        return response.scoes;\n    }\n\n    /**\n     * Retrieves the list of SCO objects for a given SCORM and organization, including data about\n     * a certain attempt (status, isvisible, ...).\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param options Other options.\n     * @returns Promise resolved with a list of SCO objects.\n     */\n    async getScosWithData(\n        scormId: number,\n        attempt: number,\n        options: AddonModScormGetScosWithDataOptions = {},\n    ): Promise<AddonModScormScoWithData[]> {\n\n        // Get organization SCOs.\n        const scos = await this.getScos(scormId, options);\n\n        // Get the track data for all the SCOs in the organization for the given attempt.\n        // We'll use this data to set SCO data like isvisible, status and so.\n        const userDataOptions: AddonModScormGetUserDataOptions = {\n            scos,\n            ...options, // Include all options.\n        };\n\n        const data = await this.getScormUserData(scormId, attempt, userDataOptions);\n\n        const trackDataBySCO: Record<string, Record<string, AddonModScormDataValue>> = {};\n\n        // First populate trackDataBySCO to index by SCO identifier.\n        // We want the full list first because it's needed by evalPrerequisites.\n        scos.forEach((sco) => {\n            trackDataBySCO[sco.identifier] = data[sco.id].userdata;\n        });\n\n        const scosWithData: AddonModScormScoWithData[] = scos;\n\n        scosWithData.forEach((sco) => {\n            // Add specific SCO information (related to tracked data).\n            const scoData = data[sco.id].userdata;\n\n            if (!scoData) {\n                return;\n            }\n\n            // Check isvisible attribute.\n            sco.isvisible = scoData.isvisible === undefined || (!!scoData.isvisible && scoData.isvisible !== 'false');\n            // Check pre-requisites status.\n            sco.prereq = scoData.prerequisites === undefined ||\n                this.evalPrerequisites(<string> scoData.prerequisites, trackDataBySCO);\n            // Add status.\n            sco.status = (scoData.status === undefined || scoData.status === '') ? 'notattempted' : <string> scoData.status;\n            // Exit var.\n            sco.exitvar = scoData.exitvar === undefined ? 'cmi.core.exit' : <string> scoData.exitvar;\n            sco.exitvalue = <string> scoData[sco.exitvar];\n            // Copy score.\n            sco.scoreraw = scoData.score_raw;\n        });\n\n        return scosWithData;\n    }\n\n    /**\n     * Given a SCORM and a SCO, returns the full launch URL for the SCO.\n     *\n     * @param scorm SCORM.\n     * @param sco SCO.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the URL.\n     */\n    async getScoSrc(scorm: AddonModScormScorm, sco: AddonModScormWSSco, siteId?: string): Promise<string> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Build the launch URL. Moodle web checks SCORM version, we don't need to, it's always SCORM 1.2.\n        let launchUrl = sco.launch;\n        const parametersEntry = sco.extradata?.find((entry) => entry.element == 'parameters');\n        let parameters = <string | undefined> parametersEntry?.value;\n\n        if (parameters) {\n            const connector = launchUrl.indexOf('?') > -1 ? '&' : '?';\n            if (parameters.charAt(0) == '?') {\n                parameters = parameters.substring(1);\n            }\n\n            launchUrl += connector + parameters;\n        }\n\n        if (this.isExternalLink(launchUrl)) {\n            // It's an online URL.\n            return launchUrl;\n        }\n\n        const dirPath = await CoreFilepool.getPackageDirUrlByUrl(siteId, scorm.moduleurl ?? '');\n\n        return CorePath.concatenatePaths(dirPath, launchUrl);\n    }\n\n    /**\n     * Get the path to the folder where a SCORM is downloaded.\n     *\n     * @param moduleUrl Module URL (returned by get_course_contents).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the folder path.\n     */\n    getScormFolder(moduleUrl: string, siteId?: string): Promise<string> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        return CoreFilepool.getPackageDirPathByUrl(siteId, moduleUrl);\n    }\n\n    /**\n     * Gets a list of files to downlaod for a SCORM, using a format similar to module.contents from get_course_contents.\n     * It will only return one file: the ZIP package.\n     *\n     * @param scorm SCORM.\n     * @returns File list.\n     */\n    getScormFileList(scorm: AddonModScormScorm): CoreWSFile[] {\n        const files: CoreWSFile[] = [];\n\n        if (!this.isScormUnsupported(scorm) && !scorm.warningMessage) {\n            files.push({\n                fileurl: this.getPackageUrl(scorm),\n                filepath: '/',\n                filename: scorm.reference,\n                filesize: scorm.packagesize,\n                timemodified: 0,\n            });\n        }\n\n        return files;\n    }\n\n    /**\n     * Get the URL and description of the status icon.\n     *\n     * @param sco SCO.\n     * @param incomplete Whether the SCORM is incomplete.\n     * @returns Image URL and description.\n     */\n    getScoStatusIcon(sco: AddonModScormScoWithData, incomplete?: boolean): AddonModScormScoIcon {\n        let imageName = '';\n        let descName = '';\n        let suspendedStr = '';\n\n        const status = sco.status || '';\n\n        if (sco.isvisible) {\n            if (VALID_STATUSES.indexOf(status) >= 0) {\n                if (sco.scormtype == 'sco') {\n                    imageName = status;\n                    descName = status;\n                } else {\n                    imageName = 'asset';\n                    descName = 'assetlaunched';\n                }\n\n                if (!incomplete) {\n                    // Check if SCO is completed or not. If SCORM is incomplete there's no need to check SCO.\n                    incomplete = this.isStatusIncomplete(status);\n                }\n\n                if (incomplete && sco.exitvalue == 'suspend') {\n                    imageName = 'suspend';\n                    suspendedStr = ' - ' + Translate.instant('addon.mod_scorm.suspended');\n                }\n            } else {\n                incomplete = true;\n\n                if (sco.scormtype == 'sco') {\n                    // Status empty or not valid, use 'notattempted'.\n                    imageName = 'notattempted';\n                } else {\n                    imageName = 'asset';\n                }\n                descName = imageName;\n            }\n        }\n\n        if (imageName == '') {\n            imageName = 'notattempted';\n            descName = 'notattempted';\n            suspendedStr = '';\n        }\n\n        sco.incomplete = incomplete;\n\n        return {\n            icon: STATUS_TO_ICON[imageName],\n            description: Translate.instant('addon.mod_scorm.' + descName) + suspendedStr,\n        };\n    }\n\n    /**\n     * Get cache key for SCORM data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getScormDataCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'scorm:' + courseId;\n    }\n\n    /**\n     * Get a SCORM with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the SCORM is retrieved.\n     */\n    protected async getScormByField(\n        courseId: number,\n        key: string,\n        value: unknown,\n        options: AddonModScormGetScormOptions = {},\n    ): Promise<AddonModScormScorm> {\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModScormGetScormsByCoursesWSParams = {\n            courseids: [courseId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getScormDataCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModScormProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        const response = await site.read<AddonModScormGetScormsByCoursesWSResponse>(\n            'mod_scorm_get_scorms_by_courses',\n            params,\n            preSets,\n        );\n\n        const currentScorm = <AddonModScormScorm> response.scorms.find(scorm => scorm[key] == value);\n        if (!currentScorm) {\n            throw new CoreError(Translate.instant('core.course.modulenotfound'));\n        }\n\n        // If the SCORM isn't available the WS returns a warning and it doesn't return timeopen and timeclosed.\n        if (currentScorm.timeopen === undefined) {\n            const warning = response.warnings?.find(warning => warning.itemid === currentScorm.id);\n            currentScorm.warningMessage = warning?.message;\n        }\n\n        if (response.options) {\n            const scormOptions = CoreUtils.objectToKeyValueMap(response.options, 'name', 'value');\n\n            if (scormOptions.scormstandard) {\n                currentScorm.scormStandard = Number(scormOptions.scormstandard);\n            }\n        }\n\n        currentScorm.moduleurl = options.moduleUrl;\n\n        return currentScorm;\n    }\n\n    /**\n     * Get a SCORM by module ID.\n     *\n     * @param courseId Course ID.\n     * @param cmId Course module ID.\n     * @param options Other options.\n     * @returns Promise resolved when the SCORM is retrieved.\n     */\n    getScorm(courseId: number, cmId: number, options: AddonModScormGetScormOptions = {}): Promise<AddonModScormScorm> {\n        return this.getScormByField(courseId, 'coursemodule', cmId, options);\n    }\n\n    /**\n     * Get a SCORM by SCORM ID.\n     *\n     * @param courseId Course ID.\n     * @param id SCORM ID.\n     * @param options Other options.\n     * @returns Promise resolved when the SCORM is retrieved.\n     */\n    getScormById(courseId: number, id: number, options: AddonModScormGetScormOptions = {}): Promise<AddonModScormScorm> {\n        return this.getScormByField(courseId, 'id', id, options);\n    }\n\n    /**\n     * Get a readable SCORM grade method.\n     *\n     * @param scorm SCORM.\n     * @returns Grading method.\n     */\n    getScormGradeMethod(scorm: AddonModScormScorm): string {\n        if (scorm.maxattempt == 1) {\n            switch (scorm.grademethod) {\n                case AddonModScormProvider.GRADEHIGHEST:\n                    return Translate.instant('addon.mod_scorm.gradehighest');\n\n                case AddonModScormProvider.GRADEAVERAGE:\n                    return Translate.instant('addon.mod_scorm.gradeaverage');\n\n                case AddonModScormProvider.GRADESUM:\n                    return Translate.instant('addon.mod_scorm.gradesum');\n\n                case AddonModScormProvider.GRADESCOES:\n                    return Translate.instant('addon.mod_scorm.gradescoes');\n                default:\n                    return '';\n            }\n        }\n\n        switch (scorm.whatgrade) {\n            case AddonModScormProvider.HIGHESTATTEMPT:\n                return Translate.instant('addon.mod_scorm.highestattempt');\n\n            case AddonModScormProvider.AVERAGEATTEMPT:\n                return Translate.instant('addon.mod_scorm.averageattempt');\n\n            case AddonModScormProvider.FIRSTATTEMPT:\n                return Translate.instant('addon.mod_scorm.firstattempt');\n\n            case AddonModScormProvider.LASTATTEMPT:\n                return Translate.instant('addon.mod_scorm.lastattempt');\n            default:\n                return '';\n        }\n    }\n\n    /**\n     * Invalidates access information.\n     *\n     * @param scormId SCORM ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAccessInformation(scormId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAccessInformationCacheKey(scormId));\n    }\n\n    /**\n     * Invalidates all the data related to a certain SCORM.\n     *\n     * @param scormId SCORM ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllScormData(scormId: number, siteId?: string, userId?: number): Promise<void> {\n        await Promise.all([\n            this.invalidateAttemptCount(scormId, siteId, userId),\n            this.invalidateScos(scormId, siteId),\n            this.invalidateScormUserData(scormId, siteId),\n            this.invalidateAccessInformation(scormId, siteId),\n        ]);\n    }\n\n    /**\n     * Invalidates attempt count.\n     *\n     * @param scormId SCORM ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAttemptCount(scormId: number, siteId?: string, userId?: number): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        await site.invalidateWsCacheForKey(this.getAttemptCountCacheKey(scormId, userId));\n    }\n\n    /**\n     * Invalidate the prefetched content.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID of the module.\n     * @param siteId Site ID. If not defined, current site.\n     * @param userId User ID. If not defined use site's current user.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string, userId?: number): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const scorm = await this.getScorm(courseId, moduleId, { siteId });\n\n        await Promise.all([\n            this.invalidateAllScormData(scorm.id, siteId, userId),\n            CoreFilepool.invalidateFilesByComponent(siteId, AddonModScormProvider.COMPONENT, moduleId, true),\n        ]);\n    }\n\n    /**\n     * Invalidates SCORM data.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateScormData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getScormDataCacheKey(courseId));\n    }\n\n    /**\n     * Invalidates SCORM user data for all attempts.\n     *\n     * @param scormId SCORM ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateScormUserData(scormId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getScormUserDataCommonCacheKey(scormId));\n    }\n\n    /**\n     * Invalidates SCORM scos for all organizations.\n     *\n     * @param scormId SCORM ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateScos(scormId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getScosCacheKey(scormId));\n    }\n\n    /**\n     * Check if a SCORM's attempt is incomplete.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt.\n     * @param options Other options.\n     * @returns Promise resolved with a boolean: true if incomplete, false otherwise.\n     */\n    async isAttemptIncomplete(scormId: number, attempt: number, options: AddonModScormOfflineOptions = {}): Promise<boolean> {\n        const scos = await this.getScosWithData(scormId, attempt, options);\n\n        return scos.some(sco => sco.isvisible && sco.launch && this.isStatusIncomplete(sco.status));\n    }\n\n    /**\n     * Given a launch URL, check if it's a external link.\n     * Based on Moodle's scorm_external_link.\n     *\n     * @param link Link to check.\n     * @returns Whether it's an external link.\n     */\n    protected isExternalLink(link: string): boolean {\n        link = link.toLowerCase();\n\n        if (link.match(/^https?:\\/\\//i) && !CoreUrlUtils.isLocalFileUrl(link)) {\n            return true;\n        } else if (link.substring(0, 4) == 'www.') {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if the given SCORM is closed.\n     *\n     * @param scorm SCORM to check.\n     * @returns Whether the SCORM is closed.\n     */\n    isScormClosed(scorm: AddonModScormScorm): boolean {\n        return !!(scorm.timeclose && CoreTimeUtils.timestamp() > scorm.timeclose);\n    }\n\n    /**\n     * Check if the given SCORM is downloadable.\n     *\n     * @param scorm SCORM to check.\n     * @returns Whether the SCORM is downloadable.\n     */\n    isScormDownloadable(scorm: AddonModScormScorm): boolean {\n        return scorm.protectpackagedownloads !== undefined && scorm.protectpackagedownloads === false;\n    }\n\n    /**\n     * Check if the given SCORM is open.\n     *\n     * @param scorm SCORM to check.\n     * @returns Whether the SCORM is open.\n     */\n    isScormOpen(scorm: AddonModScormScorm): boolean {\n        return !!(scorm.timeopen && scorm.timeopen > CoreTimeUtils.timestamp());\n    }\n\n    /**\n     * Check if a SCORM is unsupported in the app. If it's not, returns the error code to show.\n     *\n     * @param scorm SCORM to check.\n     * @returns String with error code if unsupported, undefined if supported.\n     */\n    isScormUnsupported(scorm: AddonModScormScorm): string | undefined {\n        if (!this.isScormValidVersion(scorm)) {\n            return 'addon.mod_scorm.errorinvalidversion';\n        } else if (!this.isScormDownloadable(scorm)) {\n            return 'addon.mod_scorm.errornotdownloadable';\n        } else if (!this.isValidPackageUrl(this.getPackageUrl(scorm))) {\n            return 'addon.mod_scorm.errorpackagefile';\n        }\n    }\n\n    /**\n     * Check if it's a valid SCORM 1.2.\n     *\n     * @param scorm SCORM to check.\n     * @returns Whether the SCORM is valid.\n     */\n    isScormValidVersion(scorm: AddonModScormScorm): boolean {\n        return scorm.version == 'SCORM_1.2';\n    }\n\n    /**\n     * Check if a SCO status is incomplete.\n     *\n     * @param status SCO status.\n     * @returns Whether it's incomplete.\n     */\n    isStatusIncomplete(status?: string): boolean {\n        return !status || status == 'notattempted' || status == 'incomplete' || status == 'browsed';\n    }\n\n    /**\n     * Check if a package URL is valid.\n     *\n     * @param packageUrl Package URL.\n     * @returns Whether it's valid.\n     */\n    isValidPackageUrl(packageUrl: string): boolean {\n        if (!packageUrl) {\n            return false;\n        }\n        if (packageUrl.indexOf('imsmanifest.xml') > -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Report a SCO as being launched.\n     *\n     * @param scormId SCORM ID.\n     * @param scoId SCO ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logLaunchSco(scormId: number, scoId: number, siteId?: string): Promise<void> {\n        const params: AddonModScormLaunchScoWSParams = {\n            scormid: scormId,\n            scoid: scoId,\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_scorm_launch_sco',\n            params,\n            AddonModScormProvider.COMPONENT,\n            scormId,\n            siteId,\n        );\n    }\n\n    /**\n     * Report a SCORM as being viewed.\n     *\n     * @param id Module ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    logView(id: number, siteId?: string): Promise<void> {\n        const params: AddonModScormViewScormWSParams = {\n            scormid: id,\n        };\n\n        return CoreCourseLogHelper.log(\n            'mod_scorm_view_scorm',\n            params,\n            AddonModScormProvider.COMPONENT,\n            id,\n            siteId,\n        );\n    }\n\n    /**\n     * Saves a SCORM tracking record.\n     *\n     * @param scoId Sco ID.\n     * @param attempt Attempt number.\n     * @param tracks Tracking data to store.\n     * @param scorm SCORM.\n     * @param offline Whether the attempt is offline.\n     * @param userData User data for this attempt and SCO. If not defined, it will be retrieved from DB. Recommended.\n     * @returns Promise resolved when data is saved.\n     */\n    async saveTracks(\n        scoId: number,\n        attempt: number,\n        tracks: AddonModScormDataEntry[],\n        scorm: AddonModScormScorm,\n        offline?: boolean,\n        userData?: AddonModScormUserDataMap,\n        siteId?: string,\n    ): Promise<void> {\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (offline) {\n            if (!userData) {\n                userData = await this.getScormUserData(scorm.id, attempt, { offline, cmId: scorm.coursemodule, siteId });\n            }\n\n            return AddonModScormOffline.saveTracks(scorm, scoId, attempt, tracks, userData, siteId);\n        }\n\n        await this.saveTracksOnline(scorm.id, scoId, attempt, tracks, siteId);\n\n        // Tracks have been saved, update cached user data.\n        this.updateUserDataAfterSave(scorm.id, attempt, tracks, { cmId: scorm.coursemodule, siteId });\n\n        CoreEvents.trigger(AddonModScormProvider.DATA_SENT_EVENT, {\n            scormId: scorm.id,\n            scoId: scoId,\n            attempt: attempt,\n        }, CoreSites.getCurrentSiteId());\n    }\n\n    /**\n     * Saves a SCORM tracking record.\n     *\n     * @param scormId SCORM ID.\n     * @param scoId Sco ID.\n     * @param attempt Attempt number.\n     * @param tracks Tracking data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data is saved.\n     */\n    async saveTracksOnline(\n        scormId: number,\n        scoId: number,\n        attempt: number,\n        tracks: AddonModScormDataEntry[],\n        siteId?: string,\n    ): Promise<number[]> {\n        if (!tracks || !tracks.length) {\n            return []; // Nothing to save.\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModScormInsertScormTracksWSParams = {\n            scoid: scoId,\n            attempt: attempt,\n            tracks: tracks,\n        };\n\n        CoreSync.blockOperation(AddonModScormProvider.COMPONENT, scormId, 'saveTracksOnline', site.id);\n\n        try {\n            const response = await site.write<AddonModScormInsertScormTracksWSResponse>('mod_scorm_insert_scorm_tracks', params);\n\n            return response.trackids;\n        } finally {\n            CoreSync.unblockOperation(AddonModScormProvider.COMPONENT, scormId, 'saveTracksOnline', site.id);\n        }\n    }\n\n    /**\n     * Saves a SCORM tracking record using a synchronous call.\n     * Please use this function only if synchronous is a must. It's recommended to use saveTracks.\n     *\n     * @param scoId Sco ID.\n     * @param attempt Attempt number.\n     * @param tracks Tracking data to store.\n     * @param scorm SCORM.\n     * @param offline Whether the attempt is offline.\n     * @param userData User data for this attempt and SCO. Required if offline=true.\n     * @returns In online returns true if data is inserted, false otherwise.\n     *         In offline returns true if data to insert is valid, false otherwise. True doesn't mean that the\n     *         data has been stored, this function can return true but the insertion can still fail somehow.\n     */\n    saveTracksSync(\n        scoId: number,\n        attempt: number,\n        tracks: AddonModScormDataEntry[],\n        scorm: AddonModScormScorm,\n        offline?: boolean,\n        userData?: AddonModScormUserDataMap,\n    ): boolean {\n        if (offline) {\n            return AddonModScormOffline.saveTracksSync(scorm, scoId, attempt, tracks, userData ?? {});\n        } else {\n            const success = this.saveTracksSyncOnline(scoId, attempt, tracks);\n\n            if (success) {\n                // Tracks have been saved, update cached user data.\n                this.updateUserDataAfterSave(scorm.id, attempt, tracks, { cmId: scorm.coursemodule });\n\n                CoreEvents.trigger(AddonModScormProvider.DATA_SENT_EVENT, {\n                    scormId: scorm.id,\n                    scoId: scoId,\n                    attempt: attempt,\n                }, CoreSites.getCurrentSiteId());\n            }\n\n            return success;\n        }\n    }\n\n    /**\n     * Saves a SCORM tracking record using a synchronous call.\n     * Please use this function only if synchronous is a must. It's recommended to use saveTracksOnline.\n     *\n     * @param scoId Sco ID.\n     * @param attempt Attempt number.\n     * @param tracks Tracking data.\n     * @returns True if success, false otherwise.\n     */\n    saveTracksSyncOnline(scoId: number, attempt: number, tracks: AddonModScormDataEntry[]): boolean {\n        if (!tracks || !tracks.length) {\n            return true; // Nothing to save.\n        }\n\n        const params: AddonModScormInsertScormTracksWSParams = {\n            scoid: scoId,\n            attempt: attempt,\n            tracks: tracks,\n        };\n        const currentSite = CoreSites.getCurrentSite();\n        if (!currentSite) {\n            return false;\n        }\n\n        const preSets: CoreWSPreSets = {\n            siteUrl: currentSite.getURL(),\n            wsToken: currentSite.getToken(),\n        };\n        const wsFunction = 'mod_scorm_insert_scorm_tracks';\n\n        try {\n            const response = CoreWS.syncCall<AddonModScormInsertScormTracksWSResponse>(wsFunction, params, preSets);\n\n            return !!(response && response.trackids);\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Check if the SCORM main file should be downloaded.\n     * This function should only be called if the SCORM can be downloaded (not downloaded or outdated).\n     *\n     * @param scorm SCORM to check.\n     * @param isOutdated True if package outdated, false if not downloaded, undefined to calculate it.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if it should be downloaded, false otherwise.\n     */\n    async shouldDownloadMainFile(scorm: AddonModScormScorm, isOutdated?: boolean, siteId?: string): Promise<boolean> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const component = AddonModScormProvider.COMPONENT;\n\n        if (isOutdated === undefined) {\n            // Calculate if it's outdated.\n            const data = await CoreUtils.ignoreErrors(CoreFilepool.getPackageData(siteId, component, scorm.coursemodule));\n\n            if (!data) {\n                // Package not found, not downloaded.\n                return false;\n            }\n\n            const isOutdated = data.status == CoreConstants.OUTDATED ||\n                    (data.status == CoreConstants.DOWNLOADING && data.previous == CoreConstants.OUTDATED);\n\n            // Package needs to be downloaded if it's not outdated (not downloaded) or if the hash has changed.\n            return !isOutdated || data.extra != scorm.sha1hash;\n\n        } else if (isOutdated) {\n            // The package is outdated, but maybe the file hasn't changed.\n            const extra = await CoreUtils.ignoreErrors(CoreFilepool.getPackageExtra(siteId, component, scorm.coursemodule));\n\n            if (!extra) {\n                // Package not found, not downloaded.\n                return true;\n            }\n\n            return scorm.sha1hash != extra;\n        } else {\n            // Package is not outdated and not downloaded, download the main file.\n            return true;\n        }\n    }\n\n    /**\n     * If needed, updates cached user data after saving tracks in online.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Attempt number.\n     * @param tracks Tracking data saved.\n     * @param options Other options.\n     * @returns Promise resolved when updated.\n     */\n    protected async updateUserDataAfterSave(\n        scormId: number,\n        attempt: number,\n        tracks: AddonModScormDataEntry[],\n        options: {cmId?: number; siteId?: string},\n    ): Promise<void> {\n        if (!tracks || !tracks.length) {\n            return;\n        }\n\n        // Check if we need to update. We only update if we sent some track with a dot notation.\n        const needsUpdate = tracks.some(track => track.element && track.element.indexOf('.') > -1);\n\n        if (!needsUpdate) {\n            return;\n        }\n\n        await this.getScormUserDataOnline(scormId, attempt, {\n            cmId: options.cmId,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n            siteId: options.siteId,\n        });\n    }\n\n}\n\nexport const AddonModScorm = makeSingleton(AddonModScormProvider);\n\n/**\n * Params of mod_scorm_get_scorm_access_information WS.\n */\nexport type AddonModScormGetScormAccessInformationWSParams = {\n    scormid: number; // Scorm instance id.\n};\n\n/**\n * Data returned by mod_scorm_get_scorm_access_information WS.\n */\nexport type AddonModScormGetScormAccessInformationWSResponse = {\n    warnings?: CoreWSExternalWarning[];\n    canaddinstance?: boolean; // Whether the user has the capability mod/scorm:addinstance allowed.\n    canviewreport?: boolean; // Whether the user has the capability mod/scorm:viewreport allowed.\n    canskipview?: boolean; // Whether the user has the capability mod/scorm:skipview allowed.\n    cansavetrack?: boolean; // Whether the user has the capability mod/scorm:savetrack allowed.\n    canviewscores?: boolean; // Whether the user has the capability mod/scorm:viewscores allowed.\n    candeleteresponses?: boolean; // Whether the user has the capability mod/scorm:deleteresponses allowed.\n    candeleteownresponses?: boolean; // Whether the user has the capability mod/scorm:deleteownresponses allowed.\n};\n\n/**\n * Params of mod_scorm_get_scorm_attempt_count WS.\n */\nexport type AddonModScormGetScormAttemptCountWSParams = {\n    scormid: number; // SCORM instance id.\n    userid: number; // User id.\n    ignoremissingcompletion?: boolean; // Ignores attempts that haven't reported a grade/completion.\n};\n\n/**\n * Data returned by mod_scorm_get_scorm_attempt_count WS.\n */\nexport type AddonModScormGetScormAttemptCountWSResponse = {\n    attemptscount: number; // Attempts count.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_scorm_get_scorm_user_data WS.\n */\nexport type AddonModScormGetScormUserDataWSParams = {\n    scormid: number; // Scorm instance id.\n    attempt: number; // Attempt number.\n};\n\n/**\n * Data returned by mod_scorm_get_scorm_user_data WS.\n */\nexport type AddonModScormGetScormUserDataWSResponse = {\n    data: AddonModScormWSScoUserData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Each entry returned by mod_scorm_get_scorm_user_data WS.\n */\nexport type AddonModScormWSScoUserData = {\n    scoid: number; // Sco id.\n    userdata: AddonModScormDataEntry[];\n    defaultdata: AddonModScormDataEntry[];\n};\n\n/**\n * Data for each data entry returned by mod_scorm_get_scorm_user_data WS.\n */\nexport type AddonModScormDataEntry = {\n    element: string; // Element name.\n    value: AddonModScormDataValue; // Element value.\n};\n\n/**\n * Possible values for a data value.\n */\nexport type AddonModScormDataValue = string | number;\n\n/**\n * Map of formatted user data, indexed by SCO id.\n */\nexport type AddonModScormUserDataMap = Record<number, AddonModScormScoUserData>;\n\n/**\n * User data returned mod_scorm_get_scorm_user_data, but formatted.\n */\nexport type AddonModScormScoUserData = Omit<AddonModScormWSScoUserData, 'defaultdata'|'userdata'> & {\n    defaultdata: Record<string, AddonModScormDataValue>;\n    userdata: Record<string, AddonModScormDataValue>;\n};\n\n/**\n * Params of mod_scorm_get_scorm_scoes WS.\n */\nexport type AddonModScormGetScormScoesWSParams = {\n    scormid: number; // Scorm instance id.\n    organization?: string; // Organization id.\n};\n\n/**\n * Data returned by mod_scorm_get_scorm_scoes WS.\n */\nexport type AddonModScormGetScormScoesWSResponse = {\n    scoes: AddonModScormWSSco[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * SCO data returned by mod_scorm_get_scorm_scoes WS.\n */\nexport type AddonModScormWSSco = {\n    id: number; // Sco id.\n    scorm: number; // Scorm id.\n    manifest: string; // Manifest id.\n    organization: string; // Organization id.\n    parent: string; // Parent.\n    identifier: string; // Identifier.\n    launch: string; // Launch file.\n    scormtype: string; // Scorm type (asset, sco).\n    title: string; // Sco title.\n    sortorder: number; // Sort order.\n    extradata?: AddonModScormDataEntry[]; // Additional SCO data.\n};\n\n/**\n * SCO data with some calculated data.\n */\nexport type AddonModScormScoWithData = AddonModScormWSSco & {\n    isvisible?: boolean;\n    prereq?: boolean;\n    status?: string;\n    exitvar?: string;\n    exitvalue?: string;\n    scoreraw?: string | number;\n    incomplete?: boolean;\n};\n\n/**\n * SCO data, including children to build the TOC.\n */\nexport type AddonModScormTOCTreeSco = AddonModScormScoWithData & {\n    children: AddonModScormTOCTreeSco[];\n};\n\n/**\n * SCO data, including children to build the TOC.\n */\nexport type AddonModScormTOCListSco = AddonModScormTOCTreeSco & {\n    level: number;\n};\n\n/**\n * Params of mod_scorm_get_scorms_by_courses WS.\n */\nexport type AddonModScormGetScormsByCoursesWSParams = {\n    courseids?: number[]; // Array of course ids.\n};\n\n/**\n * Data returned by mod_scorm_get_scorms_by_courses WS.\n */\nexport type AddonModScormGetScormsByCoursesWSResponse = {\n    options?: AddonModScormOptions[]; // @since v4.3. Scorm options\n    scorms: AddonModScormScormWSData[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Scorm options returned by mod_scorm_get_scorms_by_courses WS.\n */\nexport type AddonModScormOptions = {\n    name: string;\n    value: string;\n};\n\n/**\n * Scorm data returned by mod_scorm_get_scorms_by_courses WS.\n */\nexport type AddonModScormScormWSData = {\n    id: number; // SCORM id.\n    coursemodule: number; // Course module id.\n    course: number; // Course id.\n    name: string; // SCORM name.\n    intro: string; // The SCORM intro.\n    introformat: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    packagesize?: number; // SCORM zip package size.\n    packageurl?: string; // SCORM zip package URL.\n    version?: string; // SCORM version (SCORM_12, SCORM_13, SCORM_AICC).\n    maxgrade?: number; // Max grade.\n    grademethod?: number; // Grade method.\n    whatgrade?: number; // What grade.\n    maxattempt?: number; // Maximum number of attemtps.\n    forcecompleted?: boolean; // Status current attempt is forced to \"completed\".\n    forcenewattempt?: number; // Controls re-entry behaviour.\n    lastattemptlock?: boolean; // Prevents to launch new attempts once finished.\n    displayattemptstatus?: number; // How to display attempt status.\n    displaycoursestructure?: boolean; // Display contents structure.\n    sha1hash?: string; // Package content or ext path hash.\n    md5hash?: string; // MD5 Hash of package file.\n    revision?: number; // Revison number.\n    launch?: number; // First content to launch.\n    skipview?: number; // How to skip the content structure page.\n    hidebrowse?: boolean; // Disable preview mode?.\n    hidetoc?: number; // How to display the SCORM structure in player.\n    nav?: number; // Show navigation buttons.\n    navpositionleft?: number; // Navigation position left.\n    navpositiontop?: number; // Navigation position top.\n    auto?: boolean; // Auto continue?.\n    popup?: number; // Display in current or new window.\n    width?: number; // Frame width.\n    height?: number; // Frame height.\n    timeopen?: number; // Available from.\n    timeclose?: number; // Available to.\n    displayactivityname?: boolean; // Display the activity name above the player?.\n    scormtype?: string; // SCORM type.\n    reference?: string; // Reference to the package.\n    protectpackagedownloads?: boolean; // Protect package downloads?.\n    updatefreq?: number; // Auto-update frequency for remote packages.\n    options?: string; // Additional options.\n    completionstatusrequired?: number; // Status passed/completed required?.\n    completionscorerequired?: number; // Minimum score required.\n    completionstatusallscos?: number; // Require all scos to return completion status.\n    autocommit?: boolean; // Save track data automatically?.\n    timemodified?: number; // Time of last modification.\n    section?: number; // Course section id.\n    visible?: boolean; // Visible.\n    groupmode?: number; // Group mode.\n    groupingid?: number; // Group id.\n};\n\n/**\n * Scorm data with some calculated data\n */\nexport type AddonModScormScorm = AddonModScormScormWSData & {\n    warningMessage?: string;\n    moduleurl?: string;\n    scormStandard?: number;\n};\n\n/**\n * Params of mod_scorm_insert_scorm_tracks WS.\n */\nexport type AddonModScormInsertScormTracksWSParams = {\n    scoid: number; // SCO id.\n    attempt: number; // Attempt number.\n    tracks: AddonModScormDataEntry[];\n};\n\n/**\n * Data returned by mod_scorm_insert_scorm_tracks WS.\n */\nexport type AddonModScormInsertScormTracksWSResponse = {\n    trackids: number[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_scorm_launch_sco WS.\n */\nexport type AddonModScormLaunchScoWSParams = {\n    scormid: number; // SCORM instance id.\n    scoid?: number; // SCO id (empty for launching the first SCO).\n};\n\n/**\n * Params of mod_scorm_view_scorm WS.\n */\nexport type AddonModScormViewScormWSParams = {\n    scormid: number; // Scorm instance id.\n};\n\n/**\n * Options to pass to get SCORM.\n */\nexport type AddonModScormGetScormOptions = CoreSitesCommonWSOptions & {\n    moduleUrl?: string; // Module URL.\n};\n\n/**\n * Common options with an organization ID.\n */\nexport type AddonModScormOrganizationOptions = CoreCourseCommonModWSOptions & {\n    organization?: string; // Organization ID.\n};\n\n/**\n * Common options with offline boolean.\n */\nexport type AddonModScormOfflineOptions = CoreCourseCommonModWSOptions & {\n    offline?: boolean; // Whether the attempt is offline.\n};\n\n/**\n * Options to pass to getAttemptCount.\n */\nexport type AddonModScormGetAttemptCountOptions = CoreCourseCommonModWSOptions & {\n    ignoreMissing?: boolean; // Whether it should ignore attempts that haven't reported a grade/completion.\n    userId?: number; // User ID. If not defined use site's current user.\n};\n\n/**\n * Options to pass to getScormUserData.\n */\nexport type AddonModScormGetUserDataOptions = AddonModScormOfflineOptions & {\n    scos?: AddonModScormWSSco[]; // SCOs returned by getScos. Recommended if offline=true.\n};\n\n/**\n * Options to pass to getScosWithData.\n */\nexport type AddonModScormGetScosWithDataOptions = AddonModScormOfflineOptions & AddonModScormOrganizationOptions;\n\n/**\n * Result of getAttemptCount.\n */\nexport type AddonModScormAttemptCountResult = {\n    online: number[]; // List of online attempts numbers.\n    offline: number[]; // List of offline attempts numbers.\n    total: number; // Total of unique attempts.\n    lastAttempt: AddonModScormAttempt; // Last attempt in the SCORM: the number and whether it's offline.\n};\n\n/**\n * Data for an attempt: number and whether it's offline.\n */\nexport type AddonModScormAttempt = {\n    num: number;\n    offline: boolean;\n};\n\n/**\n * SCORM organization.\n */\nexport type AddonModScormOrganization = {\n    identifier: string;\n    title: string;\n    sortorder: number;\n};\n\n/**\n * Grade data for an attempt.\n */\nexport type AddonModScormAttemptGrade = {\n    num: number;\n    score: number;\n    hasCompletedPassedSCO: boolean; // Whether it has at least 1 SCO with status completed or passed.\n};\n\n/**\n * Grade for an online attempt.\n */\nexport type AddonModScormCommonEventData = {\n    scormId: number;\n    scoId: number;\n    attempt: number;\n};\n\n/**\n * SCO icon data.\n */\nexport type AddonModScormScoIcon = {\n    icon: string;\n    description: string;\n};\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonModScormProvider.LAUNCH_NEXT_SCO_EVENT]: AddonModScormCommonEventData;\n        [AddonModScormProvider.LAUNCH_PREV_SCO_EVENT]: AddonModScormCommonEventData;\n        [AddonModScormProvider.UPDATE_TOC_EVENT]: AddonModScormCommonEventData;\n        [AddonModScormProvider.GO_OFFLINE_EVENT]: AddonModScormCommonEventData;\n        [AddonModScormProvider.DATA_SENT_EVENT]: AddonModScormCommonEventData;\n        [AddonModScormSyncProvider.AUTO_SYNCED]: AddonModScormAutoSyncEventData;\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}