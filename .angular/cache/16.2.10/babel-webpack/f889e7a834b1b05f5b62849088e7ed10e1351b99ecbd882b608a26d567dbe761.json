{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreLang } from '@services/lang';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreConstants } from '@/core/constants';\nimport { makeSingleton } from '@singletons';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreSites } from '@services/sites';\nimport { CorePath } from '@singletons/path';\nimport { CorePlatform } from '@services/platform';\nimport { CoreMedia } from '@singletons/media';\nimport * as i0 from \"@angular/core\";\n/*\n * \"Utils\" service with helper functions for URLs.\n */\nexport class CoreUrlUtilsProvider {\n  /**\n   * Add or remove 'www' from a URL. The url needs to have http or https protocol.\n   *\n   * @param url URL to modify.\n   * @returns Modified URL.\n   */\n  addOrRemoveWWW(url) {\n    if (url) {\n      if (url.match(/http(s)?:\\/\\/www\\./)) {\n        // Already has www. Remove it.\n        url = url.replace('www.', '');\n      } else {\n        url = url.replace('https://', 'https://www.');\n        url = url.replace('http://', 'http://www.');\n      }\n    }\n    return url;\n  }\n  /**\n   * Add params to a URL.\n   *\n   * @param url URL to add the params to.\n   * @param params Object with the params to add.\n   * @param anchor Anchor text if needed.\n   * @param boolToNumber Whether to convert bools to 1 or 0.\n   * @returns URL with params.\n   */\n  addParamsToUrl(url, params, anchor, boolToNumber) {\n    // Remove any existing anchor to add the params before it.\n    const urlAndAnchor = url.split('#');\n    url = urlAndAnchor[0];\n    let separator = url.indexOf('?') !== -1 ? '&' : '?';\n    for (const key in params) {\n      let value = params[key];\n      if (boolToNumber && typeof value === 'boolean') {\n        // Convert booleans to 1 or 0.\n        value = value ? '1' : '0';\n      }\n      // Ignore objects and undefined.\n      if (typeof value !== 'object' && value !== undefined) {\n        url += separator + key + '=' + value;\n        separator = '&';\n      }\n    }\n    // Re-add the anchor if any.\n    if (urlAndAnchor.length > 1) {\n      // Remove the URL from the array.\n      urlAndAnchor.shift();\n      // Use a join in case there is more than one #.\n      url += '#' + urlAndAnchor.join('#');\n    }\n    if (anchor) {\n      url += '#' + anchor;\n    }\n    return url;\n  }\n  /**\n   * Given a URL and a text, return an HTML link.\n   *\n   * @param url URL.\n   * @param text Text of the link.\n   * @returns Link.\n   */\n  buildLink(url, text) {\n    return '<a href=\"' + url + '\">' + text + '</a>';\n  }\n  /**\n   * Check whether we can use tokenpluginfile.php endpoint for a certain URL.\n   *\n   * @param url URL to check.\n   * @param siteUrl The URL of the site the URL belongs to.\n   * @param accessKey User access key for tokenpluginfile.\n   * @returns Whether tokenpluginfile.php can be used.\n   */\n  canUseTokenPluginFile(url, siteUrl, accessKey) {\n    // Do not use tokenpluginfile if site doesn't use slash params, the URL doesn't work.\n    // Also, only use it for \"core\" pluginfile endpoints. Some plugins can implement their own endpoint (like customcert).\n    return !CoreConstants.CONFIG.disableTokenFile && !!accessKey && !url.match(/[&?]file=/) && (url.indexOf(CorePath.concatenatePaths(siteUrl, 'pluginfile.php')) === 0 || url.indexOf(CorePath.concatenatePaths(siteUrl, 'webservice/pluginfile.php')) === 0) && !CoreMedia.sourceUsesJavascriptPlayer({\n      src: url\n    });\n  }\n  /**\n   * Extracts the parameters from a URL and stores them in an object.\n   *\n   * @param url URL to treat.\n   * @returns Object with the params.\n   */\n  extractUrlParams(url) {\n    const regex = /[?&]+([^=&]+)=?([^&]*)?/gi;\n    const subParamsPlaceholder = '@@@SUBPARAMS@@@';\n    const params = {};\n    const urlAndHash = url.split('#');\n    const questionMarkSplit = urlAndHash[0].split('?');\n    let subParams;\n    if (questionMarkSplit.length > 2) {\n      // There is more than one question mark in the URL. This can happen if any of the params is a URL with params.\n      // We only want to treat the first level of params, so we'll remove this second list of params and restore it later.\n      questionMarkSplit.splice(0, 2);\n      subParams = '?' + questionMarkSplit.join('?');\n      urlAndHash[0] = urlAndHash[0].replace(subParams, subParamsPlaceholder);\n    }\n    urlAndHash[0].replace(regex, (match, key, value) => {\n      params[key] = value !== undefined ? CoreTextUtils.decodeURIComponent(value) : '';\n      if (subParams) {\n        params[key] = params[key].replace(subParamsPlaceholder, subParams);\n      }\n      return match;\n    });\n    if (urlAndHash.length > 1) {\n      // Remove the URL from the array.\n      urlAndHash.shift();\n      // Add the hash as a param with a special name. Use a join in case there is more than one #.\n      params.urlHash = urlAndHash.join('#');\n    }\n    return params;\n  }\n  /**\n   * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.\n   * For download remote files from Moodle we need to use the special /webservice/pluginfile passing\n   * the ws token as a get parameter.\n   *\n   * @param url The url to be fixed.\n   * @param token Token to use.\n   * @param siteUrl The URL of the site the URL belongs to.\n   * @param accessKey User access key for tokenpluginfile.\n   * @returns Fixed URL.\n   */\n  fixPluginfileURL(url, token, siteUrl, accessKey) {\n    if (!url) {\n      return '';\n    }\n    url = url.replace(/&amp;/g, '&');\n    const canUseTokenPluginFile = accessKey && this.canUseTokenPluginFile(url, siteUrl, accessKey);\n    // First check if we need to fix this url or is already fixed.\n    if (!canUseTokenPluginFile && url.indexOf('token=') != -1) {\n      return url;\n    }\n    // Check if is a valid URL (contains the pluginfile endpoint) and belongs to the site.\n    if (!this.isPluginFileUrl(url) || url.indexOf(CoreTextUtils.addEndingSlash(siteUrl)) !== 0) {\n      return url;\n    }\n    if (canUseTokenPluginFile) {\n      // Use tokenpluginfile.php.\n      url = url.replace(/(\\/webservice)?\\/pluginfile\\.php/, '/tokenpluginfile.php/' + accessKey);\n    } else {\n      // Use pluginfile.php. Some webservices returns directly the correct download url, others not.\n      if (url.indexOf(CorePath.concatenatePaths(siteUrl, 'pluginfile.php')) === 0) {\n        url = url.replace('/pluginfile', '/webservice/pluginfile');\n      }\n      url = this.addParamsToUrl(url, {\n        token\n      });\n    }\n    return this.addParamsToUrl(url, {\n      offline: '1'\n    }); // Always send offline=1 (it's for external repositories).\n  }\n  /**\n   * Formats a URL, trim, lowercase, etc...\n   *\n   * @param url The url to be formatted.\n   * @returns Fromatted url.\n   */\n  formatURL(url) {\n    url = url.trim();\n    // Check if the URL starts by http or https.\n    if (!/^http(s)?:\\/\\/.*/i.test(url)) {\n      // Test first allways https.\n      url = 'https://' + url;\n    }\n    // http always in lowercase.\n    url = url.replace(/^http/i, 'http');\n    url = url.replace(/^https/i, 'https');\n    // Replace last slash.\n    url = url.replace(/\\/$/, '');\n    return url;\n  }\n  /**\n   * Returns the URL to the documentation of the app, based on Moodle version and current language.\n   *\n   * @param release Moodle release.\n   * @param page Docs page to go to.\n   * @returns Promise resolved with the Moodle docs URL.\n   */\n  getDocsUrl(release, page = 'Mobile_app') {\n    return _asyncToGenerator(function* () {\n      let docsUrl = 'https://docs.moodle.org/en/' + page;\n      if (release !== undefined) {\n        const version = CoreSites.getMajorReleaseNumber(release).replace('.', '');\n        // Check is a valid number.\n        if (Number(version) >= 24) {\n          // Append release number.\n          docsUrl = docsUrl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');\n        }\n      }\n      try {\n        let lang = yield CoreLang.getCurrentLanguage(\"lms\" /* CoreLangFormat.LMS */);\n        lang = CoreLang.getParentLanguage() || lang;\n        return docsUrl.replace('/en/', '/' + lang + '/');\n      } catch (error) {\n        return docsUrl;\n      }\n    })();\n  }\n  /**\n   * Returns the Youtube Embed Video URL or undefined if not found.\n   *\n   * @param url URL\n   * @returns Youtube Embed Video URL or undefined if not found.\n   */\n  getYoutubeEmbedUrl(url) {\n    if (!url) {\n      return;\n    }\n    let videoId = '';\n    const params = {};\n    url = CoreTextUtils.decodeHTML(url);\n    // Get the video ID.\n    let match = url.match(/^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/);\n    if (match && match[2].length === 11) {\n      videoId = match[2];\n    }\n    // No videoId, do not continue.\n    if (!videoId) {\n      return;\n    }\n    // Now get the playlist (if any).\n    match = url.match(/[?&]list=([^#&?]+)/);\n    if (match && match[1]) {\n      params.list = match[1];\n    }\n    // Now get the start time (if any).\n    match = url.match(/[?&]start=(\\d+)/);\n    if (match && match[1]) {\n      params.start = parseInt(match[1], 10).toString();\n    } else {\n      // No start param, but it could have a time param.\n      match = url.match(/[?&]t=(\\d+h)?(\\d+m)?(\\d+s)?/);\n      if (match) {\n        const start = (match[1] ? parseInt(match[1], 10) * 3600 : 0) + (match[2] ? parseInt(match[2], 10) * 60 : 0) + (match[3] ? parseInt(match[3], 10) : 0);\n        params.start = start.toString();\n      }\n    }\n    return this.addParamsToUrl('https://www.youtube.com/embed/' + videoId, params);\n  }\n  /**\n   * Given a URL, returns what's after the last '/' without params.\n   * Example:\n   * http://mysite.com/a/course.html?id=1 -> course.html\n   *\n   * @param url URL to treat.\n   * @returns Last file without params.\n   */\n  getLastFileWithoutParams(url) {\n    var _parsedUrl$path, _path$split$pop;\n    const parsedUrl = CoreUrl.parse(url);\n    if (!parsedUrl) {\n      return '';\n    }\n    const path = (_parsedUrl$path = parsedUrl.path) !== null && _parsedUrl$path !== void 0 ? _parsedUrl$path : '';\n    return (_path$split$pop = path.split('/').pop()) !== null && _path$split$pop !== void 0 ? _path$split$pop : '';\n  }\n  /**\n   * Get the protocol from a URL.\n   * E.g. http://www.google.com returns 'http'.\n   *\n   * @param url URL to treat.\n   * @returns Protocol, undefined if no protocol found.\n   * @todo Use CoreUrl.parse\n   */\n  getUrlProtocol(url) {\n    if (!url) {\n      return;\n    }\n    const matches = url.match(/^([^/:.?]*):\\/\\//);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  /**\n   * Get the scheme from a URL. Please notice that, if a URL has protocol, it will return the protocol.\n   * E.g. javascript:doSomething() returns 'javascript'.\n   *\n   * @param url URL to treat.\n   * @returns Scheme, undefined if no scheme found.\n   */\n  getUrlScheme(url) {\n    if (!url) {\n      return;\n    }\n    const matches = url.match(/^([a-z][a-z0-9+\\-.]*):/);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  /*\n   * Gets a username from a URL like: user@mysite.com.\n   *\n   * @param url URL to treat.\n   * @returns Username. Undefined if no username found.\n   * @todo Use CoreUrl.parse\n   */\n  getUsernameFromUrl(url) {\n    if (url.indexOf('@') > -1) {\n      // Get URL without protocol.\n      const withoutProtocol = url.replace(/^[^?@/]*:\\/\\//, '');\n      const matches = withoutProtocol.match(/[^@]*/);\n      // Make sure that @ is at the start of the URL, not in a param at the end.\n      if (matches && matches.length && !matches[0].match(/[/|?]/)) {\n        return matches[0];\n      }\n    }\n  }\n  /**\n   * Returns if a URL has any protocol (not a relative URL).\n   *\n   * @param url The url to test against the pattern.\n   * @returns Whether the url is absolute.\n   */\n  isAbsoluteURL(url) {\n    return /^[^:]{2,}:\\/\\//i.test(url) || /^(tel:|mailto:|geo:)/.test(url);\n  }\n  /**\n   * Returns if a URL is downloadable: plugin file OR theme/image.php OR gravatar.\n   *\n   * @param url The URL to test.\n   * @returns Whether the URL is downloadable.\n   */\n  isDownloadableUrl(url) {\n    return this.isPluginFileUrl(url) || this.isTokenPluginFileUrl(url) || this.isThemeImageUrl(url) || this.isGravatarUrl(url);\n  }\n  /**\n   * Returns if a URL is a gravatar URL.\n   *\n   * @param url The URL to test.\n   * @returns Whether the URL is a gravatar URL.\n   */\n  isGravatarUrl(url) {\n    return (url === null || url === void 0 ? void 0 : url.indexOf('gravatar.com/avatar')) !== -1;\n  }\n  /**\n   * Check if a URL uses http or https protocol.\n   *\n   * @param url The url to test.\n   * @returns Whether the url uses http or https protocol.\n   * @todo Use CoreUrl.parse\n   */\n  isHttpURL(url) {\n    return /^https?:\\/\\/.+/i.test(url);\n  }\n  /**\n   * Check whether an URL belongs to a local file.\n   *\n   * @param url URL to check.\n   * @returns Whether the URL belongs to a local file.\n   */\n  isLocalFileUrl(url) {\n    const urlParts = CoreUrl.parse(url);\n    return this.isLocalFileUrlScheme((urlParts === null || urlParts === void 0 ? void 0 : urlParts.protocol) || '', (urlParts === null || urlParts === void 0 ? void 0 : urlParts.domain) || '');\n  }\n  /**\n   * Check whether a URL scheme belongs to a local file.\n   *\n   * @param scheme Scheme to check.\n   * @returns Whether the scheme belongs to a local file.\n   */\n  isLocalFileUrlScheme(scheme, domain) {\n    if (!scheme) {\n      return false;\n    }\n    scheme = scheme.toLowerCase();\n    return scheme == 'cdvfile' || scheme == 'file' || scheme == 'filesystem' || scheme == CoreConstants.CONFIG.ioswebviewscheme || CorePlatform.isMobile() && scheme === 'http' && domain === 'localhost'; // @todo Get served domain from ENV.\n  }\n  /**\n   * Returns if a URL is a pluginfile URL.\n   *\n   * @param url The URL to test.\n   * @returns Whether the URL is a pluginfile URL.\n   */\n  isPluginFileUrl(url) {\n    return url.indexOf('/pluginfile.php') !== -1;\n  }\n  /**\n   * Returns if a URL is a tokenpluginfile URL.\n   *\n   * @param url The URL to test.\n   * @returns Whether the URL is a tokenpluginfile URL.\n   */\n  isTokenPluginFileUrl(url) {\n    return url.indexOf('/tokenpluginfile.php') !== -1;\n  }\n  /**\n   * Returns if a URL is a theme image URL.\n   *\n   * @param imageUrl The URL to test.\n   * @param siteUrl The Site Url.\n   * @returns Whether the URL is a theme image URL.\n   */\n  isThemeImageUrl(imageUrl, siteUrl) {\n    if (siteUrl) {\n      return imageUrl.startsWith(`${siteUrl}/theme/image.php`);\n    }\n    return (imageUrl === null || imageUrl === void 0 ? void 0 : imageUrl.indexOf('/theme/image.php')) !== -1;\n  }\n  /**\n   * Remove protocol and www from a URL.\n   *\n   * @param url URL to treat.\n   * @returns Treated URL.\n   */\n  removeProtocolAndWWW(url) {\n    // Remove protocol.\n    url = url.replace(/^.*?:\\/\\//, '');\n    // Remove www.\n    url = url.replace(/^www./, '');\n    return url;\n  }\n  /**\n   * Remove the parameters from a URL, returning the URL without them.\n   *\n   * @param url URL to treat.\n   * @returns URL without params.\n   */\n  removeUrlParams(url) {\n    const matches = url.match(/^[^?]+/);\n    return matches ? matches[0] : '';\n  }\n  /**\n   * Modifies a pluginfile URL to use the default pluginfile script instead of the webservice one.\n   *\n   * @param url The url to be fixed.\n   * @param siteUrl The URL of the site the URL belongs to.\n   * @returns Modified URL.\n   */\n  unfixPluginfileURL(url, siteUrl) {\n    if (!url) {\n      return '';\n    }\n    url = url.replace(/&amp;/g, '&');\n    // It site URL is supplied, check if the URL belongs to the site.\n    if (siteUrl && url.indexOf(CoreTextUtils.addEndingSlash(siteUrl)) !== 0) {\n      return url;\n    }\n    // Check tokenpluginfile first.\n    url = url.replace(/\\/tokenpluginfile\\.php\\/[^/]+\\//, '/pluginfile.php/');\n    // Treat webservice/pluginfile case.\n    url = url.replace(/\\/webservice\\/pluginfile\\.php\\//, '/pluginfile.php/');\n    // Make sure the URL doesn't contain the token.\n    url = url.replace(/([?&])token=[^&]*&?/, '$1');\n    return url;\n  }\n}\n_class = CoreUrlUtilsProvider;\n_class.ɵfac = function CoreUrlUtilsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreUrlUtils = makeSingleton(CoreUrlUtilsProvider);","map":{"version":3,"names":["CoreLang","CoreTextUtils","CoreConstants","makeSingleton","CoreUrl","CoreSites","CorePath","CorePlatform","CoreMedia","CoreUrlUtilsProvider","addOrRemoveWWW","url","match","replace","addParamsToUrl","params","anchor","boolToNumber","urlAndAnchor","split","separator","indexOf","key","value","undefined","length","shift","join","buildLink","text","canUseTokenPluginFile","siteUrl","accessKey","CONFIG","disableTokenFile","concatenatePaths","sourceUsesJavascriptPlayer","src","extractUrlParams","regex","subParamsPlaceholder","urlAndHash","questionMarkSplit","subParams","splice","decodeURIComponent","urlHash","fixPluginfileURL","token","isPluginFileUrl","addEndingSlash","offline","formatURL","trim","test","getDocsUrl","release","page","_asyncToGenerator","docsUrl","version","getMajorReleaseNumber","Number","lang","getCurrentLanguage","getParentLanguage","error","getYoutubeEmbedUrl","videoId","decodeHTML","list","start","parseInt","toString","getLastFileWithoutParams","_parsedUrl$path","_path$split$pop","parsedUrl","parse","path","pop","getUrlProtocol","matches","getUrlScheme","getUsernameFromUrl","withoutProtocol","isAbsoluteURL","isDownloadableUrl","isTokenPluginFileUrl","isThemeImageUrl","isGravatarUrl","isHttpURL","isLocalFileUrl","urlParts","isLocalFileUrlScheme","protocol","domain","scheme","toLowerCase","ioswebviewscheme","isMobile","imageUrl","startsWith","removeProtocolAndWWW","removeUrlParams","unfixPluginfileURL","factory","ɵfac","providedIn","CoreUrlUtils"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/utils/url.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreLang, CoreLangFormat } from '@services/lang';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreConstants } from '@/core/constants';\nimport { makeSingleton } from '@singletons';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreSites } from '@services/sites';\nimport { CorePath } from '@singletons/path';\nimport { CorePlatform } from '@services/platform';\nimport { CoreMedia } from '@singletons/media';\n\n/*\n * \"Utils\" service with helper functions for URLs.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreUrlUtilsProvider {\n\n    /**\n     * Add or remove 'www' from a URL. The url needs to have http or https protocol.\n     *\n     * @param url URL to modify.\n     * @returns Modified URL.\n     */\n    addOrRemoveWWW(url: string): string {\n        if (url) {\n            if (url.match(/http(s)?:\\/\\/www\\./)) {\n                // Already has www. Remove it.\n                url = url.replace('www.', '');\n            } else {\n                url = url.replace('https://', 'https://www.');\n                url = url.replace('http://', 'http://www.');\n            }\n        }\n\n        return url;\n    }\n\n    /**\n     * Add params to a URL.\n     *\n     * @param url URL to add the params to.\n     * @param params Object with the params to add.\n     * @param anchor Anchor text if needed.\n     * @param boolToNumber Whether to convert bools to 1 or 0.\n     * @returns URL with params.\n     */\n    addParamsToUrl(url: string, params?: Record<string, unknown>, anchor?: string, boolToNumber?: boolean): string {\n        // Remove any existing anchor to add the params before it.\n        const urlAndAnchor = url.split('#');\n        url = urlAndAnchor[0];\n\n        let separator = url.indexOf('?') !== -1 ? '&' : '?';\n\n        for (const key in params) {\n            let value = params[key];\n\n            if (boolToNumber && typeof value === 'boolean') {\n                // Convert booleans to 1 or 0.\n                value = value ? '1' : '0';\n            }\n\n            // Ignore objects and undefined.\n            if (typeof value !== 'object' && value !== undefined) {\n                url += separator + key + '=' + value;\n                separator = '&';\n            }\n        }\n\n        // Re-add the anchor if any.\n        if (urlAndAnchor.length > 1) {\n            // Remove the URL from the array.\n            urlAndAnchor.shift();\n\n            // Use a join in case there is more than one #.\n            url += '#' + urlAndAnchor.join('#');\n        }\n\n        if (anchor) {\n            url += '#' + anchor;\n        }\n\n        return url;\n    }\n\n    /**\n     * Given a URL and a text, return an HTML link.\n     *\n     * @param url URL.\n     * @param text Text of the link.\n     * @returns Link.\n     */\n    buildLink(url: string, text: string): string {\n        return '<a href=\"' + url + '\">' + text + '</a>';\n    }\n\n    /**\n     * Check whether we can use tokenpluginfile.php endpoint for a certain URL.\n     *\n     * @param url URL to check.\n     * @param siteUrl The URL of the site the URL belongs to.\n     * @param accessKey User access key for tokenpluginfile.\n     * @returns Whether tokenpluginfile.php can be used.\n     */\n    canUseTokenPluginFile(url: string, siteUrl: string, accessKey?: string): boolean {\n        // Do not use tokenpluginfile if site doesn't use slash params, the URL doesn't work.\n        // Also, only use it for \"core\" pluginfile endpoints. Some plugins can implement their own endpoint (like customcert).\n        return !CoreConstants.CONFIG.disableTokenFile && !!accessKey && !url.match(/[&?]file=/) && (\n            url.indexOf(CorePath.concatenatePaths(siteUrl, 'pluginfile.php')) === 0 ||\n            url.indexOf(CorePath.concatenatePaths(siteUrl, 'webservice/pluginfile.php')) === 0) &&\n            !CoreMedia.sourceUsesJavascriptPlayer({ src: url });\n    }\n\n    /**\n     * Extracts the parameters from a URL and stores them in an object.\n     *\n     * @param url URL to treat.\n     * @returns Object with the params.\n     */\n    extractUrlParams(url: string): CoreUrlParams {\n        const regex = /[?&]+([^=&]+)=?([^&]*)?/gi;\n        const subParamsPlaceholder = '@@@SUBPARAMS@@@';\n        const params: CoreUrlParams = {};\n        const urlAndHash = url.split('#');\n        const questionMarkSplit = urlAndHash[0].split('?');\n        let subParams: string;\n\n        if (questionMarkSplit.length > 2) {\n            // There is more than one question mark in the URL. This can happen if any of the params is a URL with params.\n            // We only want to treat the first level of params, so we'll remove this second list of params and restore it later.\n            questionMarkSplit.splice(0, 2);\n\n            subParams = '?' + questionMarkSplit.join('?');\n            urlAndHash[0] = urlAndHash[0].replace(subParams, subParamsPlaceholder);\n        }\n\n        urlAndHash[0].replace(regex, (match: string, key: string, value: string): string => {\n            params[key] = value !== undefined ? CoreTextUtils.decodeURIComponent(value) : '';\n\n            if (subParams) {\n                params[key] = params[key].replace(subParamsPlaceholder, subParams);\n            }\n\n            return match;\n        });\n\n        if (urlAndHash.length > 1) {\n            // Remove the URL from the array.\n            urlAndHash.shift();\n\n            // Add the hash as a param with a special name. Use a join in case there is more than one #.\n            params.urlHash = urlAndHash.join('#');\n        }\n\n        return params;\n    }\n\n    /**\n     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.\n     * For download remote files from Moodle we need to use the special /webservice/pluginfile passing\n     * the ws token as a get parameter.\n     *\n     * @param url The url to be fixed.\n     * @param token Token to use.\n     * @param siteUrl The URL of the site the URL belongs to.\n     * @param accessKey User access key for tokenpluginfile.\n     * @returns Fixed URL.\n     */\n    fixPluginfileURL(url: string, token: string, siteUrl: string, accessKey?: string): string {\n        if (!url) {\n            return '';\n        }\n\n        url = url.replace(/&amp;/g, '&');\n\n        const canUseTokenPluginFile = accessKey && this.canUseTokenPluginFile(url, siteUrl, accessKey);\n\n        // First check if we need to fix this url or is already fixed.\n        if (!canUseTokenPluginFile && url.indexOf('token=') != -1) {\n            return url;\n        }\n\n        // Check if is a valid URL (contains the pluginfile endpoint) and belongs to the site.\n        if (!this.isPluginFileUrl(url) || url.indexOf(CoreTextUtils.addEndingSlash(siteUrl)) !== 0) {\n            return url;\n        }\n\n        if (canUseTokenPluginFile) {\n            // Use tokenpluginfile.php.\n            url = url.replace(/(\\/webservice)?\\/pluginfile\\.php/, '/tokenpluginfile.php/' + accessKey);\n        } else {\n            // Use pluginfile.php. Some webservices returns directly the correct download url, others not.\n            if (url.indexOf(CorePath.concatenatePaths(siteUrl, 'pluginfile.php')) === 0) {\n                url = url.replace('/pluginfile', '/webservice/pluginfile');\n            }\n\n            url = this.addParamsToUrl(url, { token });\n        }\n\n        return this.addParamsToUrl(url, { offline: '1' }); // Always send offline=1 (it's for external repositories).\n    }\n\n    /**\n     * Formats a URL, trim, lowercase, etc...\n     *\n     * @param url The url to be formatted.\n     * @returns Fromatted url.\n     */\n    formatURL(url: string): string {\n        url = url.trim();\n\n        // Check if the URL starts by http or https.\n        if (! /^http(s)?:\\/\\/.*/i.test(url)) {\n            // Test first allways https.\n            url = 'https://' + url;\n        }\n\n        // http always in lowercase.\n        url = url.replace(/^http/i, 'http');\n        url = url.replace(/^https/i, 'https');\n\n        // Replace last slash.\n        url = url.replace(/\\/$/, '');\n\n        return url;\n    }\n\n    /**\n     * Returns the URL to the documentation of the app, based on Moodle version and current language.\n     *\n     * @param release Moodle release.\n     * @param page Docs page to go to.\n     * @returns Promise resolved with the Moodle docs URL.\n     */\n    async getDocsUrl(release?: string, page: string = 'Mobile_app'): Promise<string> {\n        let docsUrl = 'https://docs.moodle.org/en/' + page;\n\n        if (release !== undefined) {\n            const version = CoreSites.getMajorReleaseNumber(release).replace('.', '');\n\n            // Check is a valid number.\n            if (Number(version) >= 24) {\n                // Append release number.\n                docsUrl = docsUrl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');\n            }\n        }\n\n        try {\n            let lang = await CoreLang.getCurrentLanguage(CoreLangFormat.LMS);\n            lang = CoreLang.getParentLanguage() || lang;\n\n            return docsUrl.replace('/en/', '/' + lang + '/');\n        } catch (error) {\n            return docsUrl;\n        }\n    }\n\n    /**\n     * Returns the Youtube Embed Video URL or undefined if not found.\n     *\n     * @param url URL\n     * @returns Youtube Embed Video URL or undefined if not found.\n     */\n    getYoutubeEmbedUrl(url?: string): string | void {\n        if (!url) {\n            return;\n        }\n\n        let videoId = '';\n        const params: CoreUrlParams = {};\n\n        url = CoreTextUtils.decodeHTML(url);\n\n        // Get the video ID.\n        let match = url.match(/^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/);\n\n        if (match && match[2].length === 11) {\n            videoId = match[2];\n        }\n\n        // No videoId, do not continue.\n        if (!videoId) {\n            return;\n        }\n\n        // Now get the playlist (if any).\n        match = url.match(/[?&]list=([^#&?]+)/);\n\n        if (match && match[1]) {\n            params.list = match[1];\n        }\n\n        // Now get the start time (if any).\n        match = url.match(/[?&]start=(\\d+)/);\n\n        if (match && match[1]) {\n            params.start = parseInt(match[1], 10).toString();\n        } else {\n            // No start param, but it could have a time param.\n            match = url.match(/[?&]t=(\\d+h)?(\\d+m)?(\\d+s)?/);\n            if (match) {\n                const start = (match[1] ? parseInt(match[1], 10) * 3600 : 0) +\n                    (match[2] ? parseInt(match[2], 10) * 60 : 0) +\n                    (match[3] ? parseInt(match[3], 10) : 0);\n                params.start = start.toString();\n            }\n        }\n\n        return this.addParamsToUrl('https://www.youtube.com/embed/' + videoId, params);\n    }\n\n    /**\n     * Given a URL, returns what's after the last '/' without params.\n     * Example:\n     * http://mysite.com/a/course.html?id=1 -> course.html\n     *\n     * @param url URL to treat.\n     * @returns Last file without params.\n     */\n    getLastFileWithoutParams(url: string): string {\n        const parsedUrl = CoreUrl.parse(url);\n        if (!parsedUrl) {\n            return '';\n        }\n        const path = parsedUrl.path ?? '';\n\n        return path.split('/').pop() ?? '';\n    }\n\n    /**\n     * Get the protocol from a URL.\n     * E.g. http://www.google.com returns 'http'.\n     *\n     * @param url URL to treat.\n     * @returns Protocol, undefined if no protocol found.\n     * @todo Use CoreUrl.parse\n     */\n    getUrlProtocol(url: string): string | void {\n        if (!url) {\n            return;\n        }\n\n        const matches = url.match(/^([^/:.?]*):\\/\\//);\n        if (matches && matches[1]) {\n            return matches[1];\n        }\n    }\n\n    /**\n     * Get the scheme from a URL. Please notice that, if a URL has protocol, it will return the protocol.\n     * E.g. javascript:doSomething() returns 'javascript'.\n     *\n     * @param url URL to treat.\n     * @returns Scheme, undefined if no scheme found.\n     */\n    getUrlScheme(url: string): string | void {\n        if (!url) {\n            return;\n        }\n\n        const matches = url.match(/^([a-z][a-z0-9+\\-.]*):/);\n        if (matches && matches[1]) {\n            return matches[1];\n        }\n    }\n\n    /*\n     * Gets a username from a URL like: user@mysite.com.\n     *\n     * @param url URL to treat.\n     * @returns Username. Undefined if no username found.\n     * @todo Use CoreUrl.parse\n     */\n    getUsernameFromUrl(url: string): string | undefined {\n        if (url.indexOf('@') > -1) {\n            // Get URL without protocol.\n            const withoutProtocol = url.replace(/^[^?@/]*:\\/\\//, '');\n            const matches = withoutProtocol.match(/[^@]*/);\n\n            // Make sure that @ is at the start of the URL, not in a param at the end.\n            if (matches && matches.length && !matches[0].match(/[/|?]/)) {\n                return matches[0];\n            }\n        }\n    }\n\n    /**\n     * Returns if a URL has any protocol (not a relative URL).\n     *\n     * @param url The url to test against the pattern.\n     * @returns Whether the url is absolute.\n     */\n    isAbsoluteURL(url: string): boolean {\n        return /^[^:]{2,}:\\/\\//i.test(url) || /^(tel:|mailto:|geo:)/.test(url);\n    }\n\n    /**\n     * Returns if a URL is downloadable: plugin file OR theme/image.php OR gravatar.\n     *\n     * @param url The URL to test.\n     * @returns Whether the URL is downloadable.\n     */\n    isDownloadableUrl(url: string): boolean {\n        return this.isPluginFileUrl(url) || this.isTokenPluginFileUrl(url) || this.isThemeImageUrl(url) || this.isGravatarUrl(url);\n    }\n\n    /**\n     * Returns if a URL is a gravatar URL.\n     *\n     * @param url The URL to test.\n     * @returns Whether the URL is a gravatar URL.\n     */\n    isGravatarUrl(url: string): boolean {\n        return url?.indexOf('gravatar.com/avatar') !== -1;\n    }\n\n    /**\n     * Check if a URL uses http or https protocol.\n     *\n     * @param url The url to test.\n     * @returns Whether the url uses http or https protocol.\n     * @todo Use CoreUrl.parse\n     */\n    isHttpURL(url: string): boolean {\n        return /^https?:\\/\\/.+/i.test(url);\n    }\n\n    /**\n     * Check whether an URL belongs to a local file.\n     *\n     * @param url URL to check.\n     * @returns Whether the URL belongs to a local file.\n     */\n    isLocalFileUrl(url: string): boolean {\n        const urlParts = CoreUrl.parse(url);\n\n        return this.isLocalFileUrlScheme(urlParts?.protocol || '', urlParts?.domain || '');\n    }\n\n    /**\n     * Check whether a URL scheme belongs to a local file.\n     *\n     * @param scheme Scheme to check.\n     * @returns Whether the scheme belongs to a local file.\n     */\n    isLocalFileUrlScheme(scheme: string, domain: string): boolean {\n        if (!scheme) {\n            return false;\n        }\n        scheme = scheme.toLowerCase();\n\n        return scheme == 'cdvfile' ||\n                scheme == 'file' ||\n                scheme == 'filesystem' ||\n                scheme == CoreConstants.CONFIG.ioswebviewscheme ||\n                (CorePlatform.isMobile() && scheme === 'http' && domain === 'localhost'); // @todo Get served domain from ENV.\n    }\n\n    /**\n     * Returns if a URL is a pluginfile URL.\n     *\n     * @param url The URL to test.\n     * @returns Whether the URL is a pluginfile URL.\n     */\n    isPluginFileUrl(url: string): boolean {\n        return url.indexOf('/pluginfile.php') !== -1;\n    }\n\n    /**\n     * Returns if a URL is a tokenpluginfile URL.\n     *\n     * @param url The URL to test.\n     * @returns Whether the URL is a tokenpluginfile URL.\n     */\n    isTokenPluginFileUrl(url: string): boolean {\n        return url.indexOf('/tokenpluginfile.php') !== -1;\n    }\n\n    /**\n     * Returns if a URL is a theme image URL.\n     *\n     * @param imageUrl The URL to test.\n     * @param siteUrl The Site Url.\n     * @returns Whether the URL is a theme image URL.\n     */\n    isThemeImageUrl(imageUrl: string, siteUrl?: string): boolean {\n        if (siteUrl) {\n            return imageUrl.startsWith(`${siteUrl}/theme/image.php`);\n        }\n\n        return imageUrl?.indexOf('/theme/image.php') !== -1;\n    }\n\n    /**\n     * Remove protocol and www from a URL.\n     *\n     * @param url URL to treat.\n     * @returns Treated URL.\n     */\n    removeProtocolAndWWW(url: string): string {\n        // Remove protocol.\n        url = url.replace(/^.*?:\\/\\//, '');\n        // Remove www.\n        url = url.replace(/^www./, '');\n\n        return url;\n    }\n\n    /**\n     * Remove the parameters from a URL, returning the URL without them.\n     *\n     * @param url URL to treat.\n     * @returns URL without params.\n     */\n    removeUrlParams(url: string): string {\n        const matches = url.match(/^[^?]+/);\n\n        return matches ? matches[0] : '';\n    }\n\n    /**\n     * Modifies a pluginfile URL to use the default pluginfile script instead of the webservice one.\n     *\n     * @param url The url to be fixed.\n     * @param siteUrl The URL of the site the URL belongs to.\n     * @returns Modified URL.\n     */\n    unfixPluginfileURL(url: string, siteUrl?: string): string {\n        if (!url) {\n            return '';\n        }\n\n        url = url.replace(/&amp;/g, '&');\n\n        // It site URL is supplied, check if the URL belongs to the site.\n        if (siteUrl && url.indexOf(CoreTextUtils.addEndingSlash(siteUrl)) !== 0) {\n            return url;\n        }\n\n        // Check tokenpluginfile first.\n        url = url.replace(/\\/tokenpluginfile\\.php\\/[^/]+\\//, '/pluginfile.php/');\n\n        // Treat webservice/pluginfile case.\n        url = url.replace(/\\/webservice\\/pluginfile\\.php\\//, '/pluginfile.php/');\n\n        // Make sure the URL doesn't contain the token.\n        url = url.replace(/([?&])token=[^&]*&?/, '$1');\n\n        return url;\n    }\n\n}\n\nexport const CoreUrlUtils = makeSingleton(CoreUrlUtilsProvider);\n\nexport type CoreUrlParams = {[key: string]: string};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}