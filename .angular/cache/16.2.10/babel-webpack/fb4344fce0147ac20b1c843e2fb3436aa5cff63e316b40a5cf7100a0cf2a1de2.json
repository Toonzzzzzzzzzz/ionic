{"ast":null,"code":"var _class;\nimport { CoreFile } from '@services/file';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreUtils } from '@services/utils/utils';\nimport extToMime from '@/assets/exttomime.json';\nimport mimeToExt from '@/assets/mimetoext.json';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreSites } from '@services/sites';\nimport * as i0 from \"@angular/core\";\nconst EXTENSION_REGEX = /^[a-z0-9]+$/;\n/*\n * \"Utils\" service with helper functions for mimetypes and extensions.\n */\nexport class CoreMimetypeUtilsProvider {\n  constructor() {\n    this.extToMime = {};\n    this.mimeToExt = {};\n    this.groupsMimeInfo = {};\n    this.logger = CoreLogger.getInstance('CoreMimetypeUtilsProvider');\n    this.extToMime = extToMime;\n    this.mimeToExt = mimeToExt;\n  }\n  /**\n   * Check if a file extension can be embedded without using iframes.\n   *\n   * @param extension Extension.\n   * @returns Whether it can be embedded.\n   */\n  canBeEmbedded(extension) {\n    return this.isExtensionInGroup(extension, ['web_image', 'web_video', 'web_audio']);\n  }\n  /**\n   * Clean a extension, removing the dot, hash, extra params...\n   *\n   * @param extension Extension to clean.\n   * @returns Clean extension.\n   */\n  cleanExtension(extension) {\n    if (!extension) {\n      return extension;\n    }\n    // If the extension has parameters, remove them.\n    let position = extension.indexOf('?');\n    if (position > -1) {\n      extension = extension.substring(0, position);\n    }\n    // If the extension has an anchor, remove it.\n    position = extension.indexOf('#');\n    if (position > -1) {\n      extension = extension.substring(0, position);\n    }\n    // Remove hash in extension if there's any (added by filepool).\n    extension = extension.replace(/_.{32}$/, '');\n    // Remove dot from the extension if found.\n    if (extension && extension[0] == '.') {\n      extension = extension.substring(1);\n    }\n    return extension;\n  }\n  /**\n   * Fill the mimetypes and extensions info for a certain group.\n   *\n   * @param group Group name.\n   */\n  fillGroupMimeInfo(group) {\n    const mimetypes = {}; // Use an object to prevent duplicates.\n    const extensions = []; // Extensions are unique.\n    for (const extension in this.extToMime) {\n      const data = this.extToMime[extension];\n      if (data.type && data.groups && data.groups.indexOf(group) != -1) {\n        // This extension has the group, add it to the list.\n        mimetypes[data.type] = true;\n        extensions.push(extension);\n      }\n    }\n    this.groupsMimeInfo[group] = {\n      mimetypes: Object.keys(mimetypes),\n      extensions\n    };\n  }\n  /**\n   * Get the extension of a mimetype. Returns undefined if not found.\n   *\n   * @param mimetype Mimetype.\n   * @param url URL of the file. It will be used if there's more than one possible extension.\n   * @returns Extension.\n   */\n  getExtension(mimetype, url) {\n    mimetype = mimetype || '';\n    mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.\n    if (mimetype == 'application/x-forcedownload' || mimetype == 'application/forcedownload') {\n      // Couldn't get the right mimetype, try to guess it.\n      return url && this.guessExtensionFromUrl(url);\n    }\n    const extensions = this.mimeToExt[mimetype];\n    if (extensions && extensions.length) {\n      if (extensions.length > 1 && url) {\n        // There's more than one possible extension. Check if the URL has extension.\n        const candidate = this.guessExtensionFromUrl(url);\n        if (candidate && extensions.indexOf(candidate) != -1) {\n          return candidate;\n        }\n      }\n      return extensions[0];\n    }\n  }\n  /**\n   * Set the embed type to display an embedded file and mimetype if not found.\n   *\n   * @param file File object.\n   * @param path Alternative path that will override fileurl from file object.\n   * @returns The embedded HTML string.\n   */\n  getEmbeddedHtml(file, path) {\n    const filename = CoreUtils.isFileEntry(file) ? file.name : file.filename;\n    const extension = !CoreUtils.isFileEntry(file) && file.mimetype ? this.getExtension(file.mimetype) : filename && this.getFileExtension(filename);\n    const mimeType = !CoreUtils.isFileEntry(file) && file.mimetype ? file.mimetype : extension && this.getMimeType(extension);\n    // @todo linting: See if this can be removed\n    file.mimetype = mimeType;\n    if (extension && this.canBeEmbedded(extension)) {\n      var _path;\n      const embedType = this.getExtensionType(extension);\n      // @todo linting: See if this can be removed\n      file.embedType = embedType;\n      path = (_path = path) !== null && _path !== void 0 ? _path : CoreUtils.isFileEntry(file) ? file.toURL() : CoreFileHelper.getFileUrl(file);\n      path = path && CoreFile.convertFileSrc(path);\n      switch (embedType) {\n        case 'image':\n          return `<img src=\"${path}\">`;\n        case 'audio':\n        case 'video':\n          return [`<${embedType} controls title=\"${filename}\" src=\"${path}\" controlsList=\"nodownload\">`, `<source src=\"${path}\" type=\"${mimeType}\">`, `</${embedType}>`].join('');\n        default:\n          return '';\n      }\n    }\n    return '';\n  }\n  /**\n   * Get the URL of the icon of an extension.\n   *\n   * @param extension Extension.\n   * @returns Icon URL.\n   */\n  getExtensionIcon(extension) {\n    const icon = this.getExtensionIconName(extension) || 'unknown';\n    return this.getFileIconForType(icon);\n  }\n  /**\n   * Get the name of the icon of an extension.\n   *\n   * @param extension Extension.\n   * @returns Icon. Undefined if not found.\n   */\n  getExtensionIconName(extension) {\n    if (this.extToMime[extension]) {\n      if (this.extToMime[extension].icon) {\n        return this.extToMime[extension].icon;\n      } else {\n        const type = this.extToMime[extension].type.split('/')[0];\n        if (type == 'video' || type == 'text' || type == 'image' || type == 'document' || type == 'audio') {\n          return type;\n        }\n      }\n    }\n  }\n  /**\n   * Get the \"type\" (string) of an extension, something like \"image\", \"video\" or \"audio\".\n   *\n   * @param extension Extension.\n   * @returns Type of the extension.\n   */\n  getExtensionType(extension) {\n    extension = this.cleanExtension(extension);\n    if (this.extToMime[extension] && this.extToMime[extension].string) {\n      return this.extToMime[extension].string;\n    }\n  }\n  /**\n   * Get all the possible extensions of a mimetype. Returns empty array if not found.\n   *\n   * @param mimetype Mimetype.\n   * @returns Extensions.\n   */\n  getExtensions(mimetype) {\n    mimetype = mimetype || '';\n    mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.\n    return this.mimeToExt[mimetype] || [];\n  }\n  /**\n   * Get a file icon URL based on its file name.\n   *\n   * @param filename The name of the file.\n   * @returns The path to a file icon.\n   */\n  getFileIcon(filename) {\n    const extension = this.getFileExtension(filename);\n    const icon = extension && this.getExtensionIconName(extension) || 'unknown';\n    return this.getFileIconForType(icon);\n  }\n  /**\n   * Get the folder icon URL.\n   *\n   * @returns The path to a folder icon.\n   */\n  getFolderIcon() {\n    var _CoreSites$getCurrent;\n    if (CoreSites.getCurrentSite() === undefined || (_CoreSites$getCurrent = CoreSites.getCurrentSite()) !== null && _CoreSites$getCurrent !== void 0 && _CoreSites$getCurrent.isVersionGreaterEqualThan('4.0')) {\n      return 'assets/img/files/folder.svg';\n    }\n    return 'assets/img/files_legacy/folder-64.png';\n  }\n  /**\n   * Given a type (audio, video, html, ...), return its file icon path.\n   *\n   * @param type The type to get the icon.\n   * @returns The icon path.\n   */\n  getFileIconForType(type) {\n    var _CoreSites$getCurrent2;\n    if (CoreSites.getCurrentSite() === undefined || (_CoreSites$getCurrent2 = CoreSites.getCurrentSite()) !== null && _CoreSites$getCurrent2 !== void 0 && _CoreSites$getCurrent2.isVersionGreaterEqualThan('4.0')) {\n      return 'assets/img/files/' + type + '.svg';\n    }\n    return 'assets/img/files_legacy/' + type + '-64.png';\n  }\n  /**\n   * Guess the extension of a file from its URL.\n   * This is very weak and unreliable.\n   *\n   * @param fileUrl The file URL.\n   * @returns The lowercased extension without the dot, or undefined.\n   */\n  guessExtensionFromUrl(fileUrl) {\n    const split = CoreUrl.removeUrlAnchor(fileUrl).split('.');\n    let extension;\n    if (split.length > 1) {\n      let candidate = split[split.length - 1].toLowerCase();\n      // Remove params if any.\n      const position = candidate.indexOf('?');\n      if (position > -1) {\n        candidate = candidate.substring(0, position);\n      }\n      if (EXTENSION_REGEX.test(candidate)) {\n        extension = candidate;\n      }\n    }\n    // Check extension corresponds to a mimetype to know if it's valid.\n    if (extension && this.getMimeType(extension) === undefined) {\n      this.logger.warn('Guess file extension: Not valid extension ' + extension);\n      return;\n    }\n    return extension;\n  }\n  /**\n   * Returns the file extension of a file.\n   * When the file does not have an extension, it returns undefined.\n   *\n   * @param filename The file name.\n   * @returns The lowercased extension, or undefined.\n   */\n  getFileExtension(filename) {\n    const dot = filename.lastIndexOf('.');\n    let ext;\n    if (dot > -1) {\n      ext = filename.substring(dot + 1).toLowerCase();\n      ext = this.cleanExtension(ext);\n      // Check extension corresponds to a mimetype to know if it's valid.\n      if (this.getMimeType(ext) === undefined) {\n        this.logger.warn('Get file extension: Not valid extension ' + ext);\n        return;\n      }\n    }\n    return ext;\n  }\n  getGroupMimeInfo(group, field) {\n    if (this.groupsMimeInfo[group] === undefined) {\n      this.fillGroupMimeInfo(group);\n    }\n    if (field) {\n      return this.groupsMimeInfo[group][field];\n    }\n    return this.groupsMimeInfo[group];\n  }\n  /**\n   * Get the mimetype of an extension. Returns undefined if not found.\n   *\n   * @param extension Extension.\n   * @returns Mimetype.\n   */\n  getMimeType(extension) {\n    if (!extension) {\n      return;\n    }\n    extension = this.cleanExtension(extension);\n    if (this.extToMime[extension] && this.extToMime[extension].type) {\n      return this.extToMime[extension].type;\n    }\n  }\n  /**\n   * Get the deprecated mimetype of an extension. Returns undefined if not found or no deprecated mimetype.\n   *\n   * @param extension Extension.\n   * @returns Deprecated mimetype.\n   */\n  getDeprecatedMimeType(extension) {\n    var _this$extToMime$exten;\n    extension = this.cleanExtension(extension);\n    return (_this$extToMime$exten = this.extToMime[extension]) === null || _this$extToMime$exten === void 0 ? void 0 : _this$extToMime$exten.deprecated;\n  }\n  /**\n   * Obtains descriptions for file types (e.g. 'Microsoft Word document') from the language file.\n   * Based on Moodle's get_mimetype_description.\n   *\n   * @param obj Instance of FileEntry OR object with 'filename' and 'mimetype' OR string with mimetype.\n   * @param capitalise If true, capitalises first character of result.\n   * @returns Type description.\n   */\n  getMimetypeDescription(obj, capitalise) {\n    const langPrefix = 'assets.mimetypes.';\n    let filename = '';\n    let mimetype = '';\n    let extension = '';\n    if (typeof obj == 'object' && CoreUtils.isFileEntry(obj)) {\n      // It's a FileEntry. Don't use the file function because it's asynchronous and the type isn't reliable.\n      filename = obj.name;\n    } else if (typeof obj == 'object') {\n      filename = obj.filename || '';\n      mimetype = obj.mimetype || '';\n    } else {\n      mimetype = obj;\n    }\n    if (filename) {\n      extension = this.getFileExtension(filename);\n      if (!mimetype) {\n        // Try to calculate the mimetype using the extension.\n        mimetype = extension && this.getMimeType(extension);\n      }\n    }\n    if (!mimetype) {\n      // Don't have the mimetype, stop.\n      return '';\n    }\n    if (!extension) {\n      extension = this.getExtension(mimetype);\n    }\n    const mimetypeStr = this.getMimetypeType(mimetype) || '';\n    const chunks = mimetype.split('/');\n    const attr = {\n      mimetype,\n      ext: extension || '',\n      mimetype1: chunks[0],\n      mimetype2: chunks[1] || ''\n    };\n    const translateParams = {};\n    for (const key in attr) {\n      const value = attr[key];\n      translateParams[key] = value;\n      translateParams[key.toUpperCase()] = value.toUpperCase();\n      translateParams[CoreTextUtils.ucFirst(key)] = CoreTextUtils.ucFirst(value);\n    }\n    // MIME types may include + symbol but this is not permitted in string ids.\n    const safeMimetype = mimetype.replace(/\\+/g, '_');\n    const safeMimetypeStr = mimetypeStr.replace(/\\+/g, '_');\n    const safeMimetypeTrns = Translate.instant(langPrefix + safeMimetype, {\n      $a: translateParams\n    });\n    const safeMimetypeStrTrns = Translate.instant(langPrefix + safeMimetypeStr, {\n      $a: translateParams\n    });\n    const defaultTrns = Translate.instant(langPrefix + 'default', {\n      $a: translateParams\n    });\n    let result = mimetype;\n    if (safeMimetypeTrns != langPrefix + safeMimetype) {\n      result = safeMimetypeTrns;\n    } else if (safeMimetypeStrTrns != langPrefix + safeMimetypeStr) {\n      result = safeMimetypeStrTrns;\n    } else if (defaultTrns != langPrefix + 'default') {\n      result = defaultTrns;\n    }\n    if (capitalise) {\n      result = CoreTextUtils.ucFirst(result);\n    }\n    return result;\n  }\n  /**\n   * Get the \"type\" (string) of a mimetype, something like \"image\", \"video\" or \"audio\".\n   *\n   * @param mimetype Mimetype.\n   * @returns Type of the mimetype.\n   */\n  getMimetypeType(mimetype) {\n    mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.\n    const extensions = this.mimeToExt[mimetype];\n    if (!extensions) {\n      return;\n    }\n    for (let i = 0; i < extensions.length; i++) {\n      const extension = extensions[i];\n      if (this.extToMime[extension] && this.extToMime[extension].string) {\n        return this.extToMime[extension].string;\n      }\n    }\n  }\n  /**\n   * Get the icon of a mimetype.\n   *\n   * @param mimetype Mimetype.\n   * @returns Type of the mimetype.\n   */\n  getMimetypeIcon(mimetype) {\n    mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.\n    const extensions = this.mimeToExt[mimetype] || [];\n    let icon = 'unknown';\n    for (let i = 0; i < extensions.length; i++) {\n      const iconName = this.getExtensionIconName(extensions[i]);\n      if (iconName) {\n        icon = iconName;\n        break;\n      }\n    }\n    return this.getFileIconForType(icon);\n  }\n  /**\n   * Given a group name, return the translated name.\n   *\n   * @param name Group name.\n   * @returns Translated name.\n   */\n  getTranslatedGroupName(name) {\n    const key = 'assets.mimetypes.group:' + name;\n    const translated = Translate.instant(key);\n    return translated != key ? translated : name;\n  }\n  /**\n   * Check if an extension belongs to at least one of the groups.\n   * Similar to Moodle's file_mimetype_in_typegroup, but using the extension instead of mimetype.\n   *\n   * @param extension Extension.\n   * @param groups List of groups to check.\n   * @returns Whether the extension belongs to any of the groups.\n   */\n  isExtensionInGroup(extension, groups) {\n    if (!extension) {\n      return false;\n    }\n    extension = this.cleanExtension(extension);\n    const extensionGroups = this.extToMime[extension] && this.extToMime[extension].groups;\n    let found = false;\n    if (groups.length && extensionGroups) {\n      found = extensionGroups.some(group => groups.includes(group));\n    }\n    return found;\n  }\n  /**\n   * Check if a mimetype belongs to a file that can be streamed (audio, video).\n   *\n   * @param mimetype Mimetype.\n   * @returns Boolean.\n   */\n  isStreamedMimetype(mimetype) {\n    return mimetype.indexOf('video') != -1 || mimetype.indexOf('audio') != -1;\n  }\n  /**\n   * Remove the extension from a path (if any).\n   *\n   * @param path Path.\n   * @returns Path without extension.\n   */\n  removeExtension(path) {\n    const position = path.lastIndexOf('.');\n    if (position > -1) {\n      // Check extension corresponds to a mimetype to know if it's valid.\n      const extension = path.substring(position + 1).toLowerCase();\n      if (this.getMimeType(extension) !== undefined) {\n        return path.substring(0, position); // Remove extension.\n      }\n    }\n\n    return path;\n  }\n}\n_class = CoreMimetypeUtilsProvider;\n_class.ɵfac = function CoreMimetypeUtilsProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreMimetypeUtils = makeSingleton(CoreMimetypeUtilsProvider);","map":{"version":3,"names":["CoreFile","CoreTextUtils","makeSingleton","Translate","CoreLogger","CoreUtils","extToMime","mimeToExt","CoreFileHelper","CoreUrl","CoreSites","EXTENSION_REGEX","CoreMimetypeUtilsProvider","constructor","groupsMimeInfo","logger","getInstance","canBeEmbedded","extension","isExtensionInGroup","cleanExtension","position","indexOf","substring","replace","fillGroupMimeInfo","group","mimetypes","extensions","data","type","groups","push","Object","keys","getExtension","mimetype","url","split","guessExtensionFromUrl","length","candidate","getEmbeddedHtml","file","path","filename","isFileEntry","name","getFileExtension","mimeType","getMimeType","_path","embedType","getExtensionType","toURL","getFileUrl","convertFileSrc","join","getExtensionIcon","icon","getExtensionIconName","getFileIconForType","string","getExtensions","getFileIcon","getFolderIcon","_CoreSites$getCurrent","getCurrentSite","undefined","isVersionGreaterEqualThan","_CoreSites$getCurrent2","fileUrl","removeUrlAnchor","toLowerCase","test","warn","dot","lastIndexOf","ext","getGroupMimeInfo","field","getDeprecatedMimeType","_this$extToMime$exten","deprecated","getMimetypeDescription","obj","capitalise","langPrefix","mimetypeStr","getMimetypeType","chunks","attr","mimetype1","mimetype2","translateParams","key","value","toUpperCase","ucFirst","safeMimetype","safeMimetypeStr","safeMimetypeTrns","instant","$a","safeMimetypeStrTrns","defaultTrns","result","i","getMimetypeIcon","iconName","getTranslatedGroupName","translated","extensionGroups","found","some","includes","isStreamedMimetype","removeExtension","factory","ɵfac","providedIn","CoreMimetypeUtils"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/utils/mimetype.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { FileEntry } from '@awesome-cordova-plugins/file/ngx';\n\nimport { CoreFile } from '@services/file';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreWSFile } from '@services/ws';\nimport { CoreUtils } from '@services/utils/utils';\n\nimport extToMime from '@/assets/exttomime.json';\nimport mimeToExt from '@/assets/mimetoext.json';\nimport { CoreFileEntry, CoreFileHelper } from '@services/file-helper';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreSites } from '@services/sites';\n\ninterface MimeTypeInfo {\n    type: string;\n    icon?: string;\n    groups?: string[];\n    // eslint-disable-next-line id-blacklist\n    string?: string;\n    deprecated?: string; // Deprecated mimetype name.\n}\n\ninterface MimeTypeGroupInfo {\n    mimetypes: string[];\n    extensions: string[];\n}\n\nconst EXTENSION_REGEX = /^[a-z0-9]+$/;\n\n/*\n * \"Utils\" service with helper functions for mimetypes and extensions.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreMimetypeUtilsProvider {\n\n    protected logger: CoreLogger;\n    protected extToMime: Record<string, MimeTypeInfo> = {};\n    protected mimeToExt: Record<string, string[]> = {};\n    protected groupsMimeInfo: Record<string, MimeTypeGroupInfo> = {};\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreMimetypeUtilsProvider');\n\n        this.extToMime = extToMime;\n        this.mimeToExt = mimeToExt;\n    }\n\n    /**\n     * Check if a file extension can be embedded without using iframes.\n     *\n     * @param extension Extension.\n     * @returns Whether it can be embedded.\n     */\n    canBeEmbedded(extension?: string): boolean {\n        return this.isExtensionInGroup(extension, ['web_image', 'web_video', 'web_audio']);\n    }\n\n    /**\n     * Clean a extension, removing the dot, hash, extra params...\n     *\n     * @param extension Extension to clean.\n     * @returns Clean extension.\n     */\n    cleanExtension(extension: string): string {\n        if (!extension) {\n            return extension;\n        }\n\n        // If the extension has parameters, remove them.\n        let position = extension.indexOf('?');\n        if (position > -1) {\n            extension = extension.substring(0, position);\n        }\n\n        // If the extension has an anchor, remove it.\n        position = extension.indexOf('#');\n        if (position > -1) {\n            extension = extension.substring(0, position);\n        }\n\n        // Remove hash in extension if there's any (added by filepool).\n        extension = extension.replace(/_.{32}$/, '');\n\n        // Remove dot from the extension if found.\n        if (extension && extension[0] == '.') {\n            extension = extension.substring(1);\n        }\n\n        return extension;\n    }\n\n    /**\n     * Fill the mimetypes and extensions info for a certain group.\n     *\n     * @param group Group name.\n     */\n    protected fillGroupMimeInfo(group: string): void {\n        const mimetypes = {}; // Use an object to prevent duplicates.\n        const extensions: string[] = []; // Extensions are unique.\n\n        for (const extension in this.extToMime) {\n            const data = this.extToMime[extension];\n            if (data.type && data.groups && data.groups.indexOf(group) != -1) {\n                // This extension has the group, add it to the list.\n                mimetypes[data.type] = true;\n                extensions.push(extension);\n            }\n        }\n\n        this.groupsMimeInfo[group] = {\n            mimetypes: Object.keys(mimetypes),\n            extensions,\n        };\n    }\n\n    /**\n     * Get the extension of a mimetype. Returns undefined if not found.\n     *\n     * @param mimetype Mimetype.\n     * @param url URL of the file. It will be used if there's more than one possible extension.\n     * @returns Extension.\n     */\n    getExtension(mimetype: string, url?: string): string | undefined {\n        mimetype = mimetype || '';\n        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.\n\n        if (mimetype == 'application/x-forcedownload' || mimetype == 'application/forcedownload') {\n            // Couldn't get the right mimetype, try to guess it.\n            return url && this.guessExtensionFromUrl(url);\n        }\n\n        const extensions = this.mimeToExt[mimetype];\n        if (extensions && extensions.length) {\n            if (extensions.length > 1 && url) {\n                // There's more than one possible extension. Check if the URL has extension.\n                const candidate = this.guessExtensionFromUrl(url);\n                if (candidate && extensions.indexOf(candidate) != -1) {\n                    return candidate;\n                }\n            }\n\n            return extensions[0];\n        }\n    }\n\n    /**\n     * Set the embed type to display an embedded file and mimetype if not found.\n     *\n     * @param file File object.\n     * @param path Alternative path that will override fileurl from file object.\n     * @returns The embedded HTML string.\n     */\n    getEmbeddedHtml(file: CoreFileEntry, path?: string): string {\n        const filename = CoreUtils.isFileEntry(file) ? (file as FileEntry).name : file.filename;\n        const extension = !CoreUtils.isFileEntry(file) && file.mimetype\n            ? this.getExtension(file.mimetype)\n            : (filename && this.getFileExtension(filename));\n        const mimeType = !CoreUtils.isFileEntry(file) && file.mimetype\n            ? file.mimetype\n            : (extension && this.getMimeType(extension));\n\n        // @todo linting: See if this can be removed\n        (file as CoreWSFile).mimetype = mimeType;\n\n        if (extension && this.canBeEmbedded(extension)) {\n            const embedType = this.getExtensionType(extension);\n\n            // @todo linting: See if this can be removed\n            (file as { embedType?: string }).embedType = embedType;\n\n            path = path ?? (CoreUtils.isFileEntry(file) ? file.toURL() : CoreFileHelper.getFileUrl(file));\n            path = path && CoreFile.convertFileSrc(path);\n\n            switch (embedType) {\n                case 'image':\n                    return `<img src=\"${path}\">`;\n                case 'audio':\n                case 'video':\n                    return [\n                        `<${embedType} controls title=\"${filename}\" src=\"${path}\" controlsList=\"nodownload\">`,\n                        `<source src=\"${path}\" type=\"${mimeType}\">`,\n                        `</${embedType}>`,\n                    ].join('');\n                default:\n                    return '';\n            }\n        }\n\n        return '';\n    }\n\n    /**\n     * Get the URL of the icon of an extension.\n     *\n     * @param extension Extension.\n     * @returns Icon URL.\n     */\n    getExtensionIcon(extension: string): string {\n        const icon = this.getExtensionIconName(extension) || 'unknown';\n\n        return this.getFileIconForType(icon);\n    }\n\n    /**\n     * Get the name of the icon of an extension.\n     *\n     * @param extension Extension.\n     * @returns Icon. Undefined if not found.\n     */\n    getExtensionIconName(extension: string): string | undefined {\n        if (this.extToMime[extension]) {\n            if (this.extToMime[extension].icon) {\n                return this.extToMime[extension].icon;\n            } else {\n                const type = this.extToMime[extension].type.split('/')[0];\n                if (type == 'video' || type == 'text' || type == 'image' || type == 'document' || type == 'audio') {\n                    return type;\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the \"type\" (string) of an extension, something like \"image\", \"video\" or \"audio\".\n     *\n     * @param extension Extension.\n     * @returns Type of the extension.\n     */\n    getExtensionType(extension: string): string | undefined {\n        extension = this.cleanExtension(extension);\n\n        if (this.extToMime[extension] && this.extToMime[extension].string) {\n            return this.extToMime[extension].string;\n        }\n    }\n\n    /**\n     * Get all the possible extensions of a mimetype. Returns empty array if not found.\n     *\n     * @param mimetype Mimetype.\n     * @returns Extensions.\n     */\n    getExtensions(mimetype: string): string[] {\n        mimetype = mimetype || '';\n        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.\n\n        return this.mimeToExt[mimetype] || [];\n    }\n\n    /**\n     * Get a file icon URL based on its file name.\n     *\n     * @param filename The name of the file.\n     * @returns The path to a file icon.\n     */\n    getFileIcon(filename: string): string {\n        const extension = this.getFileExtension(filename);\n        const icon = (extension && this.getExtensionIconName(extension)) || 'unknown';\n\n        return this.getFileIconForType(icon);\n    }\n\n    /**\n     * Get the folder icon URL.\n     *\n     * @returns The path to a folder icon.\n     */\n    getFolderIcon(): string {\n        if (CoreSites.getCurrentSite() === undefined || CoreSites.getCurrentSite()?.isVersionGreaterEqualThan('4.0')) {\n            return 'assets/img/files/folder.svg';\n        }\n\n        return 'assets/img/files_legacy/folder-64.png';\n    }\n\n    /**\n     * Given a type (audio, video, html, ...), return its file icon path.\n     *\n     * @param type The type to get the icon.\n     * @returns The icon path.\n     */\n    getFileIconForType(type: string): string {\n        if (CoreSites.getCurrentSite() === undefined || CoreSites.getCurrentSite()?.isVersionGreaterEqualThan('4.0')) {\n            return 'assets/img/files/' + type + '.svg';\n        }\n\n        return 'assets/img/files_legacy/' + type + '-64.png';\n    }\n\n    /**\n     * Guess the extension of a file from its URL.\n     * This is very weak and unreliable.\n     *\n     * @param fileUrl The file URL.\n     * @returns The lowercased extension without the dot, or undefined.\n     */\n    guessExtensionFromUrl(fileUrl: string): string | undefined {\n        const split = CoreUrl.removeUrlAnchor(fileUrl).split('.');\n        let extension: string | undefined;\n\n        if (split.length > 1) {\n            let candidate = split[split.length - 1].toLowerCase();\n            // Remove params if any.\n            const position = candidate.indexOf('?');\n            if (position > -1) {\n                candidate = candidate.substring(0, position);\n            }\n\n            if (EXTENSION_REGEX.test(candidate)) {\n                extension = candidate;\n            }\n        }\n\n        // Check extension corresponds to a mimetype to know if it's valid.\n        if (extension && this.getMimeType(extension) === undefined) {\n            this.logger.warn('Guess file extension: Not valid extension ' + extension);\n\n            return;\n        }\n\n        return extension;\n    }\n\n    /**\n     * Returns the file extension of a file.\n     * When the file does not have an extension, it returns undefined.\n     *\n     * @param filename The file name.\n     * @returns The lowercased extension, or undefined.\n     */\n    getFileExtension(filename: string): string | undefined {\n        const dot = filename.lastIndexOf('.');\n        let ext: string | undefined;\n\n        if (dot > -1) {\n            ext = filename.substring(dot + 1).toLowerCase();\n            ext = this.cleanExtension(ext);\n\n            // Check extension corresponds to a mimetype to know if it's valid.\n            if (this.getMimeType(ext) === undefined) {\n                this.logger.warn('Get file extension: Not valid extension ' + ext);\n\n                return;\n            }\n        }\n\n        return ext;\n    }\n\n    /**\n     * Get the mimetype/extension info belonging to a certain group.\n     *\n     * @param group Group name.\n     * @param field The field to get. If not supplied, all the info will be returned.\n     * @returns Info for the group.\n     */\n    getGroupMimeInfo(group: string): MimeTypeGroupInfo;\n    getGroupMimeInfo(group: string, field: string): string[] | undefined;\n    getGroupMimeInfo(group: string, field?: string): MimeTypeGroupInfo | string[] | undefined {\n        if (this.groupsMimeInfo[group] === undefined) {\n            this.fillGroupMimeInfo(group);\n        }\n\n        if (field) {\n            return this.groupsMimeInfo[group][field];\n        }\n\n        return this.groupsMimeInfo[group];\n    }\n\n    /**\n     * Get the mimetype of an extension. Returns undefined if not found.\n     *\n     * @param extension Extension.\n     * @returns Mimetype.\n     */\n    getMimeType(extension?: string): string | undefined {\n        if (!extension) {\n            return;\n        }\n\n        extension = this.cleanExtension(extension);\n\n        if (this.extToMime[extension] && this.extToMime[extension].type) {\n            return this.extToMime[extension].type;\n        }\n    }\n\n    /**\n     * Get the deprecated mimetype of an extension. Returns undefined if not found or no deprecated mimetype.\n     *\n     * @param extension Extension.\n     * @returns Deprecated mimetype.\n     */\n    getDeprecatedMimeType(extension: string): string | undefined {\n        extension = this.cleanExtension(extension);\n\n        return this.extToMime[extension]?.deprecated;\n    }\n\n    /**\n     * Obtains descriptions for file types (e.g. 'Microsoft Word document') from the language file.\n     * Based on Moodle's get_mimetype_description.\n     *\n     * @param obj Instance of FileEntry OR object with 'filename' and 'mimetype' OR string with mimetype.\n     * @param capitalise If true, capitalises first character of result.\n     * @returns Type description.\n     */\n    getMimetypeDescription(obj: CoreFileEntry | string, capitalise?: boolean): string {\n        const langPrefix = 'assets.mimetypes.';\n        let filename: string | undefined = '';\n        let mimetype: string | undefined = '';\n        let extension: string | undefined = '';\n\n        if (typeof obj == 'object' && CoreUtils.isFileEntry(obj)) {\n            // It's a FileEntry. Don't use the file function because it's asynchronous and the type isn't reliable.\n            filename = obj.name;\n        } else if (typeof obj == 'object') {\n            filename = obj.filename || '';\n            mimetype = obj.mimetype || '';\n        } else {\n            mimetype = obj;\n        }\n\n        if (filename) {\n            extension = this.getFileExtension(filename);\n\n            if (!mimetype) {\n                // Try to calculate the mimetype using the extension.\n                mimetype = extension && this.getMimeType(extension);\n            }\n        }\n\n        if (!mimetype) {\n            // Don't have the mimetype, stop.\n            return '';\n        }\n\n        if (!extension) {\n            extension = this.getExtension(mimetype);\n        }\n\n        const mimetypeStr = this.getMimetypeType(mimetype) || '';\n        const chunks = mimetype.split('/');\n        const attr = {\n            mimetype,\n            ext: extension || '',\n            mimetype1: chunks[0],\n            mimetype2: chunks[1] || '',\n        };\n        const translateParams = {};\n\n        for (const key in attr) {\n            const value = attr[key];\n            translateParams[key] = value;\n            translateParams[key.toUpperCase()] = value.toUpperCase();\n            translateParams[CoreTextUtils.ucFirst(key)] = CoreTextUtils.ucFirst(value);\n        }\n\n        // MIME types may include + symbol but this is not permitted in string ids.\n        const safeMimetype = mimetype.replace(/\\+/g, '_');\n        const safeMimetypeStr = mimetypeStr.replace(/\\+/g, '_');\n        const safeMimetypeTrns = Translate.instant(langPrefix + safeMimetype, { $a: translateParams });\n        const safeMimetypeStrTrns = Translate.instant(langPrefix + safeMimetypeStr, { $a: translateParams });\n        const defaultTrns = Translate.instant(langPrefix + 'default', { $a: translateParams });\n        let result = mimetype;\n\n        if (safeMimetypeTrns != langPrefix + safeMimetype) {\n            result = safeMimetypeTrns;\n        } else if (safeMimetypeStrTrns != langPrefix + safeMimetypeStr) {\n            result = safeMimetypeStrTrns;\n        } else if (defaultTrns != langPrefix + 'default') {\n            result = defaultTrns;\n        }\n\n        if (capitalise) {\n            result = CoreTextUtils.ucFirst(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the \"type\" (string) of a mimetype, something like \"image\", \"video\" or \"audio\".\n     *\n     * @param mimetype Mimetype.\n     * @returns Type of the mimetype.\n     */\n    getMimetypeType(mimetype: string): string | undefined {\n        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.\n\n        const extensions = this.mimeToExt[mimetype];\n        if (!extensions) {\n            return;\n        }\n\n        for (let i = 0; i < extensions.length; i++) {\n            const extension = extensions[i];\n            if (this.extToMime[extension] && this.extToMime[extension].string) {\n                return this.extToMime[extension].string;\n            }\n        }\n    }\n\n    /**\n     * Get the icon of a mimetype.\n     *\n     * @param mimetype Mimetype.\n     * @returns Type of the mimetype.\n     */\n    getMimetypeIcon(mimetype: string): string {\n        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.\n\n        const extensions = this.mimeToExt[mimetype] || [];\n        let icon = 'unknown';\n\n        for (let i = 0; i < extensions.length; i++) {\n            const iconName = this.getExtensionIconName(extensions[i]);\n\n            if (iconName) {\n                icon = iconName;\n                break;\n            }\n        }\n\n        return this.getFileIconForType(icon);\n    }\n\n    /**\n     * Given a group name, return the translated name.\n     *\n     * @param name Group name.\n     * @returns Translated name.\n     */\n    getTranslatedGroupName(name: string): string {\n        const key = 'assets.mimetypes.group:' + name;\n        const translated = Translate.instant(key);\n\n        return translated != key ? translated : name;\n    }\n\n    /**\n     * Check if an extension belongs to at least one of the groups.\n     * Similar to Moodle's file_mimetype_in_typegroup, but using the extension instead of mimetype.\n     *\n     * @param extension Extension.\n     * @param groups List of groups to check.\n     * @returns Whether the extension belongs to any of the groups.\n     */\n    isExtensionInGroup(extension: string | undefined, groups: string[]): boolean {\n        if (!extension) {\n            return false;\n        }\n\n        extension = this.cleanExtension(extension);\n        const extensionGroups = this.extToMime[extension] && this.extToMime[extension].groups;\n        let found = false;\n\n        if (groups.length && extensionGroups) {\n            found = extensionGroups.some((group => groups.includes(group)));\n        }\n\n        return found;\n    }\n\n    /**\n     * Check if a mimetype belongs to a file that can be streamed (audio, video).\n     *\n     * @param mimetype Mimetype.\n     * @returns Boolean.\n     */\n    isStreamedMimetype(mimetype: string): boolean {\n        return mimetype.indexOf('video') != -1 || mimetype.indexOf('audio') != -1;\n    }\n\n    /**\n     * Remove the extension from a path (if any).\n     *\n     * @param path Path.\n     * @returns Path without extension.\n     */\n    removeExtension(path: string): string {\n        const position = path.lastIndexOf('.');\n\n        if (position > -1) {\n            // Check extension corresponds to a mimetype to know if it's valid.\n            const extension = path.substring(position + 1).toLowerCase();\n            if (this.getMimeType(extension) !== undefined) {\n                return path.substring(0, position); // Remove extension.\n            }\n        }\n\n        return path;\n    }\n\n}\n\nexport const CoreMimetypeUtils = makeSingleton(CoreMimetypeUtilsProvider);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}