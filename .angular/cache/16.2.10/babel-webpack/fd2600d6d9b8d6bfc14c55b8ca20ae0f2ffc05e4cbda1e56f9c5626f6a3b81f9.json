{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { makeSingleton } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { map } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\nimport { asyncObservable } from '@/core/utils/rxjs';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'CoreCoursesDashboard:';\n/**\n * Service that provides some features regarding course overview.\n */\nexport class CoreCoursesDashboardProvider {\n  /**\n   * Get cache key for dashboard blocks WS calls.\n   *\n   * @param myPage What my page to return blocks of. Default MY_PAGE_DEFAULT.\n   * @param userId User ID. Default, 0 means current user.\n   * @returns Cache key.\n   */\n  getDashboardBlocksCacheKey(myPage = CoreCoursesDashboardProvider.MY_PAGE_DEFAULT, userId = 0) {\n    return ROOT_CACHE_KEY + 'blocks:' + myPage + ':' + userId;\n  }\n  /**\n   * Get dashboard blocks from WS.\n   *\n   * @param myPage What my page to return blocks of. Default MY_PAGE_DEFAULT.\n   * @param userId User ID. Default, current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the list of blocks.\n   * @since 3.6\n   */\n  getDashboardBlocksFromWS(myPage = CoreCoursesDashboardProvider.MY_PAGE_DEFAULT, userId, siteId) {\n    return firstValueFrom(this.getDashboardBlocksFromWSObservable({\n      myPage,\n      userId,\n      siteId\n    }));\n  }\n  /**\n   * Get dashboard blocks from WS.\n   *\n   * @param options Options.\n   * @returns Observable that returns the list of blocks.\n   * @since 3.6\n   */\n  getDashboardBlocksFromWSObservable(options = {}) {\n    var _this = this;\n    return asyncObservable( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _options$myPage;\n      const site = yield CoreSites.getSite(options.siteId);\n      const myPage = (_options$myPage = options.myPage) !== null && _options$myPage !== void 0 ? _options$myPage : CoreCoursesDashboardProvider.MY_PAGE_DEFAULT;\n      const params = {\n        returncontents: true\n      };\n      if (CoreSites.getRequiredCurrentSite().isVersionGreaterEqualThan('4.0')) {\n        params.mypage = myPage;\n      } else if (myPage != CoreCoursesDashboardProvider.MY_PAGE_DEFAULT) {\n        throw new CoreError('mypage param is no accessible on core_block_get_dashboard_blocks');\n      }\n      const preSets = _objectSpread({\n        cacheKey: _this.getDashboardBlocksCacheKey(myPage, options.userId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      if (options.userId) {\n        params.userid = options.userId;\n      }\n      const observable = site.readObservable('core_block_get_dashboard_blocks', params, preSets);\n      return observable.pipe(map(result => {\n        if (site.isVersionGreaterEqualThan('4.0')) {\n          // Temporary hack to have course overview on 3.9.5 but not on 4.0 onwards.\n          // To be removed in a near future.\n          // Remove myoverview when is forced. See MDL-72092.\n          result.blocks = result.blocks.filter(block => block.instanceid != 0 || block.name != 'myoverview' || block.region != 'forced');\n        }\n        return result.blocks || [];\n      }));\n    }));\n  }\n  /**\n   * Get dashboard blocks.\n   *\n   * @param userId User ID. Default, current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @param myPage What my page to return blocks of. Default MY_PAGE_DEFAULT.\n   * @returns Promise resolved with the list of blocks.\n   */\n  getDashboardBlocks(userId, siteId, myPage = CoreCoursesDashboardProvider.MY_PAGE_DEFAULT) {\n    return firstValueFrom(this.getDashboardBlocksObservable({\n      myPage,\n      userId,\n      siteId\n    }));\n  }\n  /**\n   * Get dashboard blocks.\n   *\n   * @param options Options.\n   * @returns observable that returns the list of blocks.\n   */\n  getDashboardBlocksObservable(options = {}) {\n    return this.getDashboardBlocksFromWSObservable(options).pipe(map(blocks => {\n      let mainBlocks = [];\n      let sideBlocks = [];\n      blocks.forEach(block => {\n        if (block.region == 'content' || block.region == 'main') {\n          mainBlocks.push(block);\n        } else {\n          sideBlocks.push(block);\n        }\n      });\n      if (mainBlocks.length == 0) {\n        mainBlocks = [];\n        sideBlocks = [];\n        blocks.forEach(block => {\n          if (block.region.match('side')) {\n            sideBlocks.push(block);\n          } else {\n            mainBlocks.push(block);\n          }\n        });\n      }\n      return {\n        mainBlocks,\n        sideBlocks\n      };\n    }));\n  }\n  /**\n   * Invalidates dashboard blocks WS call.\n   *\n   * @param myPage What my page to return blocks of. Default MY_PAGE_DEFAULT.\n   * @param userId User ID. Default, current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateDashboardBlocks(myPage = CoreCoursesDashboardProvider.MY_PAGE_DEFAULT, userId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.invalidateWsCacheForKey(_this2.getDashboardBlocksCacheKey(myPage, userId));\n    })();\n  }\n  /**\n   * Returns whether or not block based Dashboard is available for a certain site.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if available, resolved with false or rejected otherwise.\n   * @since 3.6\n   */\n  isAvailable(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.wsAvailable('core_block_get_dashboard_blocks');\n    })();\n  }\n  /**\n   * Check if Site Home is disabled in a certain site.\n   *\n   * @param siteId Site Id. If not defined, use current site.\n   * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n   */\n  isDisabled(siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return _this3.isDisabledInSite(site);\n    })();\n  }\n  /**\n   * Check if Dashboard is disabled in a certain site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns Whether it's disabled.\n   */\n  isDisabledInSite(site) {\n    var _site;\n    site = site || CoreSites.getCurrentSite();\n    return !!((_site = site) !== null && _site !== void 0 && _site.isFeatureDisabled('CoreMainMenuDelegate_CoreCoursesDashboard'));\n  }\n}\n_class = CoreCoursesDashboardProvider;\n_class.MY_PAGE_DEFAULT = '__default';\n_class.MY_PAGE_COURSES = '__courses';\n_class.ɵfac = function CoreCoursesDashboardProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCoursesDashboard = makeSingleton(CoreCoursesDashboardProvider);","map":{"version":3,"names":["CoreSites","CoreSite","makeSingleton","CoreError","map","firstValueFrom","asyncObservable","ROOT_CACHE_KEY","CoreCoursesDashboardProvider","getDashboardBlocksCacheKey","myPage","MY_PAGE_DEFAULT","userId","getDashboardBlocksFromWS","siteId","getDashboardBlocksFromWSObservable","options","_this","_asyncToGenerator","_options$myPage","site","getSite","params","returncontents","getRequiredCurrentSite","isVersionGreaterEqualThan","mypage","preSets","_objectSpread","cacheKey","updateFrequency","FREQUENCY_RARELY","getReadingStrategyPreSets","readingStrategy","userid","observable","readObservable","pipe","result","blocks","filter","block","instanceid","name","region","getDashboardBlocks","getDashboardBlocksObservable","mainBlocks","sideBlocks","forEach","push","length","match","invalidateDashboardBlocks","_this2","invalidateWsCacheForKey","isAvailable","wsAvailable","isDisabled","_this3","isDisabledInSite","_site","getCurrentSite","isFeatureDisabled","_class","MY_PAGE_COURSES","factory","ɵfac","providedIn","CoreCoursesDashboard"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/courses/services/dashboard.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites, CoreSitesCommonWSOptions } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreCourseBlock } from '@features/course/services/course';\nimport { CoreStatusWithWarningsWSResponse } from '@services/ws';\nimport { makeSingleton } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { map } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\nimport { asyncObservable } from '@/core/utils/rxjs';\nimport { CoreSiteWSPreSets, WSObservable } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'CoreCoursesDashboard:';\n\n/**\n * Service that provides some features regarding course overview.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCoursesDashboardProvider {\n\n    static readonly MY_PAGE_DEFAULT = '__default';\n    static readonly MY_PAGE_COURSES = '__courses';\n\n    /**\n     * Get cache key for dashboard blocks WS calls.\n     *\n     * @param myPage What my page to return blocks of. Default MY_PAGE_DEFAULT.\n     * @param userId User ID. Default, 0 means current user.\n     * @returns Cache key.\n     */\n    protected getDashboardBlocksCacheKey(myPage = CoreCoursesDashboardProvider.MY_PAGE_DEFAULT, userId: number = 0): string {\n        return ROOT_CACHE_KEY + 'blocks:' + myPage + ':' + userId;\n    }\n\n    /**\n     * Get dashboard blocks from WS.\n     *\n     * @param myPage What my page to return blocks of. Default MY_PAGE_DEFAULT.\n     * @param userId User ID. Default, current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the list of blocks.\n     * @since 3.6\n     */\n    getDashboardBlocksFromWS(\n        myPage = CoreCoursesDashboardProvider.MY_PAGE_DEFAULT,\n        userId?: number,\n        siteId?: string,\n    ): Promise<CoreCourseBlock[]> {\n        return firstValueFrom(this.getDashboardBlocksFromWSObservable({\n            myPage,\n            userId,\n            siteId,\n        }));\n    }\n\n    /**\n     * Get dashboard blocks from WS.\n     *\n     * @param options Options.\n     * @returns Observable that returns the list of blocks.\n     * @since 3.6\n     */\n    getDashboardBlocksFromWSObservable(options: GetDashboardBlocksOptions = {}): WSObservable<CoreCourseBlock[]> {\n        return asyncObservable(async () => {\n            const site = await CoreSites.getSite(options.siteId);\n\n            const myPage = options.myPage ?? CoreCoursesDashboardProvider.MY_PAGE_DEFAULT;\n            const params: CoreBlockGetDashboardBlocksWSParams = {\n                returncontents: true,\n            };\n            if (CoreSites.getRequiredCurrentSite().isVersionGreaterEqualThan('4.0')) {\n                params.mypage = myPage;\n            } else if (myPage != CoreCoursesDashboardProvider.MY_PAGE_DEFAULT) {\n                throw new CoreError('mypage param is no accessible on core_block_get_dashboard_blocks');\n            }\n\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: this.getDashboardBlocksCacheKey(myPage, options.userId),\n                updateFrequency: CoreSite.FREQUENCY_RARELY,\n                ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n            };\n            if (options.userId) {\n                params.userid = options.userId;\n            }\n\n            const observable = site.readObservable<CoreBlockGetDashboardBlocksWSResponse>(\n                'core_block_get_dashboard_blocks',\n                params,\n                preSets,\n            );\n\n            return observable.pipe(map(result => {\n                if (site.isVersionGreaterEqualThan('4.0')) {\n                    // Temporary hack to have course overview on 3.9.5 but not on 4.0 onwards.\n                    // To be removed in a near future.\n                    // Remove myoverview when is forced. See MDL-72092.\n                    result.blocks = result.blocks.filter((block) =>\n                        block.instanceid != 0 || block.name != 'myoverview' || block.region != 'forced');\n                }\n\n                return result.blocks || [];\n            }));\n        });\n    }\n\n    /**\n     * Get dashboard blocks.\n     *\n     * @param userId User ID. Default, current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @param myPage What my page to return blocks of. Default MY_PAGE_DEFAULT.\n     * @returns Promise resolved with the list of blocks.\n     */\n    getDashboardBlocks(\n        userId?: number,\n        siteId?: string,\n        myPage = CoreCoursesDashboardProvider.MY_PAGE_DEFAULT,\n    ): Promise<CoreCoursesDashboardBlocks> {\n        return firstValueFrom(this.getDashboardBlocksObservable({\n            myPage,\n            userId,\n            siteId,\n        }));\n    }\n\n    /**\n     * Get dashboard blocks.\n     *\n     * @param options Options.\n     * @returns observable that returns the list of blocks.\n     */\n    getDashboardBlocksObservable(options: GetDashboardBlocksOptions = {}): WSObservable<CoreCoursesDashboardBlocks> {\n        return this.getDashboardBlocksFromWSObservable(options).pipe(map(blocks => {\n            let mainBlocks: CoreCourseBlock[] = [];\n            let sideBlocks: CoreCourseBlock[] = [];\n\n            blocks.forEach((block) => {\n                if (block.region == 'content' || block.region == 'main') {\n                    mainBlocks.push(block);\n                } else {\n                    sideBlocks.push(block);\n                }\n            });\n\n            if (mainBlocks.length == 0) {\n                mainBlocks = [];\n                sideBlocks = [];\n\n                blocks.forEach((block) => {\n                    if (block.region.match('side')) {\n                        sideBlocks.push(block);\n                    } else {\n                        mainBlocks.push(block);\n                    }\n                });\n            }\n\n            return { mainBlocks, sideBlocks };\n        }));\n    }\n\n    /**\n     * Invalidates dashboard blocks WS call.\n     *\n     * @param myPage What my page to return blocks of. Default MY_PAGE_DEFAULT.\n     * @param userId User ID. Default, current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateDashboardBlocks(\n        myPage = CoreCoursesDashboardProvider.MY_PAGE_DEFAULT,\n        userId?: number,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.invalidateWsCacheForKey(this.getDashboardBlocksCacheKey(myPage, userId));\n    }\n\n    /**\n     * Returns whether or not block based Dashboard is available for a certain site.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if available, resolved with false or rejected otherwise.\n     * @since 3.6\n     */\n    async isAvailable(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.wsAvailable('core_block_get_dashboard_blocks');\n    }\n\n    /**\n     * Check if Site Home is disabled in a certain site.\n     *\n     * @param siteId Site Id. If not defined, use current site.\n     * @returns Promise resolved with true if disabled, rejected or resolved with false otherwise.\n     */\n    async isDisabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return this.isDisabledInSite(site);\n    }\n\n    /**\n     * Check if Dashboard is disabled in a certain site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns Whether it's disabled.\n     */\n    isDisabledInSite(site?: CoreSite): boolean {\n        site = site || CoreSites.getCurrentSite();\n\n        return !!site?.isFeatureDisabled('CoreMainMenuDelegate_CoreCoursesDashboard');\n    }\n\n}\n\nexport const CoreCoursesDashboard = makeSingleton(CoreCoursesDashboardProvider);\n\nexport type CoreCoursesDashboardBlocks = {\n    mainBlocks: CoreCourseBlock[];\n    sideBlocks: CoreCourseBlock[];\n};\n\n/**\n * Options for some get dashboard blocks calls.\n */\nexport type GetDashboardBlocksOptions = CoreSitesCommonWSOptions & {\n    userId?: number; // User ID. If not defined, current user.\n    myPage?: string; // Page to get. If not defined, CoreCoursesDashboardProvider.MY_PAGE_DEFAULT.\n};\n\n/**\n * Params of core_block_get_dashboard_blocks WS.\n */\ntype CoreBlockGetDashboardBlocksWSParams = {\n    userid?: number; // User id (optional), default is current user.\n    returncontents?: boolean; // Whether to return the block contents.\n    mypage?: string; // @since 4.0. What my page to return blocks of. Default MY_PAGE_DEFAULT.\n};\n\n/**\n * Data returned by core_block_get_dashboard_blocks WS.\n */\ntype CoreBlockGetDashboardBlocksWSResponse = {\n    blocks: CoreCourseBlock[]; // List of blocks in the course.\n    warnings?: CoreStatusWithWarningsWSResponse[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}