{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModChoice, AddonModChoiceProvider } from './choice';\nimport { AddonModChoiceOffline } from './choice-offline';\nimport { AddonModChoicePrefetchHandler } from './handlers/prefetch';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync choices.\n */\nexport class AddonModChoiceSyncProvider extends CoreCourseActivitySyncBaseProvider {\n  constructor() {\n    super('AddonModChoiceSyncProvider');\n    this.componentTranslatableString = 'choice';\n  }\n  /**\n   * Get the ID of a choice sync.\n   *\n   * @param choiceId Choice ID.\n   * @param userId User the responses belong to.\n   * @returns Sync ID.\n   */\n  getSyncId(choiceId, userId) {\n    return choiceId + '#' + userId;\n  }\n  /**\n   * Try to synchronize all the choices in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param force Wether to force sync not depending on last execution.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllChoices(siteId, force) {\n    return this.syncOnSites('all choices', siteId => this.syncAllChoicesFunc(!!force, siteId), siteId);\n  }\n  /**\n   * Sync all pending choices on a site.\n   *\n   * @param force Wether to force sync not depending on last execution.\n   * @param siteId Site ID to sync.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllChoicesFunc(force, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const responses = yield AddonModChoiceOffline.getResponses(siteId);\n      // Sync all responses.\n      yield Promise.all(responses.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (response) {\n          const result = force ? yield _this.syncChoice(response.choiceid, response.userid, siteId) : yield _this.syncChoiceIfNeeded(response.choiceid, response.userid, siteId);\n          if (result !== null && result !== void 0 && result.updated) {\n            // Sync successful, send event.\n            CoreEvents.trigger(AddonModChoiceSyncProvider.AUTO_SYNCED, {\n              choiceId: response.choiceid,\n              userId: response.userid,\n              warnings: result.warnings\n            }, siteId);\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Sync an choice only if a certain time has passed since the last time.\n   *\n   * @param choiceId Choice ID to be synced.\n   * @param userId User the answers belong to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the choice is synced or it doesn't need to be synced.\n   */\n  syncChoiceIfNeeded(choiceId, userId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const syncId = _this2.getSyncId(choiceId, userId);\n      const needed = yield _this2.isSyncNeeded(syncId, siteId);\n      if (needed) {\n        return _this2.syncChoice(choiceId, userId, siteId);\n      }\n    })();\n  }\n  /**\n   * Synchronize a choice.\n   *\n   * @param choiceId Choice ID to be synced.\n   * @param userId User the answers belong to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  syncChoice(choiceId, userId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      siteId = site.getId();\n      const syncId = _this3.getSyncId(choiceId, userId);\n      const currentSyncPromise = _this3.getOngoingSync(syncId, siteId);\n      if (currentSyncPromise) {\n        // There's already a sync ongoing for this discussion, return the promise.\n        return currentSyncPromise;\n      }\n      _this3.logger.debug(`Try to sync choice '${choiceId}' for user '${userId}'`);\n      return _this3.addOngoingSync(syncId, _this3.performSync(choiceId, userId, siteId), siteId);\n    })();\n  }\n  /**\n   * Synchronize a choice.\n   *\n   * @param choiceId Choice ID to be synced.\n   * @param userId User the answers belong to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if sync is successful, rejected otherwise.\n   */\n  performSync(choiceId, userId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const syncId = _this4.getSyncId(choiceId, userId);\n      const result = {\n        warnings: [],\n        updated: false\n      };\n      // Sync offline logs.\n      yield CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModChoiceProvider.COMPONENT, choiceId, siteId));\n      const data = yield CoreUtils.ignoreErrors(AddonModChoiceOffline.getResponse(choiceId, siteId, userId));\n      if (!data || !data.choiceid) {\n        // Nothing to sync. Set sync time.\n        yield _this4.setSyncTime(syncId, siteId);\n        return result;\n      }\n      if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline.\n        throw new CoreNetworkError();\n      }\n      const courseId = data.courseid;\n      try {\n        // Send the responses.\n        if (data.deleting) {\n          // A user has deleted some responses.\n          yield AddonModChoice.deleteResponsesOnline(choiceId, data.responses, siteId);\n        } else {\n          // A user has added some responses.\n          yield AddonModChoice.submitResponseOnline(choiceId, data.responses, siteId);\n        }\n        result.updated = true;\n        yield AddonModChoiceOffline.deleteResponse(choiceId, siteId, userId);\n      } catch (error) {\n        if (!CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server, reject.\n          throw error;\n        }\n        // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.\n        result.updated = true;\n        yield AddonModChoiceOffline.deleteResponse(choiceId, siteId, userId);\n        // Responses deleted, add a warning.\n        _this4.addOfflineDataDeletedWarning(result.warnings, data.name, error);\n      }\n      // Data has been sent to server, prefetch choice if needed.\n      try {\n        const module = yield CoreCourse.getModuleBasicInfoByInstance(choiceId, 'choice', {\n          siteId\n        });\n        yield _this4.prefetchAfterUpdate(AddonModChoicePrefetchHandler.instance, module, courseId, undefined, siteId);\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      // Sync finished, set sync time.\n      yield _this4.setSyncTime(syncId, siteId);\n      return result;\n    })();\n  }\n}\n_class = AddonModChoiceSyncProvider;\n_class.AUTO_SYNCED = 'addon_mod_choice_autom_synced';\n_class.ɵfac = function AddonModChoiceSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModChoiceSync = makeSingleton(AddonModChoiceSyncProvider);","map":{"version":3,"names":["CoreNetworkError","CoreCourseActivitySyncBaseProvider","CoreCourse","CoreCourseLogHelper","CoreNetwork","CoreSites","CoreUtils","makeSingleton","CoreEvents","AddonModChoice","AddonModChoiceProvider","AddonModChoiceOffline","AddonModChoicePrefetchHandler","AddonModChoiceSyncProvider","constructor","componentTranslatableString","getSyncId","choiceId","userId","syncAllChoices","siteId","force","syncOnSites","syncAllChoicesFunc","_this","_asyncToGenerator","responses","getResponses","Promise","all","map","_ref","response","result","syncChoice","choiceid","userid","syncChoiceIfNeeded","updated","trigger","AUTO_SYNCED","warnings","_x","apply","arguments","_this2","syncId","needed","isSyncNeeded","_this3","site","getSite","getUserId","getId","currentSyncPromise","getOngoingSync","logger","debug","addOngoingSync","performSync","_this4","ignoreErrors","syncActivity","COMPONENT","data","getResponse","setSyncTime","isOnline","courseId","courseid","deleting","deleteResponsesOnline","submitResponseOnline","deleteResponse","error","isWebServiceError","addOfflineDataDeletedWarning","name","module","getModuleBasicInfoByInstance","prefetchAfterUpdate","instance","undefined","_unused","_class","factory","ɵfac","providedIn","AddonModChoiceSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/choice/services/choice-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';\nimport { CoreSyncResult } from '@services/sync';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { CoreEvents } from '@singletons/events';\nimport { AddonModChoice, AddonModChoiceProvider } from './choice';\nimport { AddonModChoiceOffline } from './choice-offline';\nimport { AddonModChoicePrefetchHandler } from './handlers/prefetch';\n\n/**\n * Service to sync choices.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModChoiceSyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModChoiceSyncResult> {\n\n    static readonly AUTO_SYNCED = 'addon_mod_choice_autom_synced';\n\n    protected componentTranslatableString = 'choice';\n\n    constructor() {\n        super('AddonModChoiceSyncProvider');\n    }\n\n    /**\n     * Get the ID of a choice sync.\n     *\n     * @param choiceId Choice ID.\n     * @param userId User the responses belong to.\n     * @returns Sync ID.\n     */\n    protected getSyncId(choiceId: number, userId: number): string {\n        return choiceId + '#' + userId;\n    }\n\n    /**\n     * Try to synchronize all the choices in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param force Wether to force sync not depending on last execution.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllChoices(siteId?: string, force?: boolean): Promise<void> {\n        return this.syncOnSites('all choices', (siteId) => this.syncAllChoicesFunc(!!force, siteId), siteId);\n    }\n\n    /**\n     * Sync all pending choices on a site.\n     *\n     * @param force Wether to force sync not depending on last execution.\n     * @param siteId Site ID to sync.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllChoicesFunc(force: boolean, siteId: string): Promise<void> {\n        const responses = await AddonModChoiceOffline.getResponses(siteId);\n\n        // Sync all responses.\n        await Promise.all(responses.map(async (response) => {\n            const result = force ?\n                await this.syncChoice(response.choiceid, response.userid, siteId) :\n                await this.syncChoiceIfNeeded(response.choiceid, response.userid, siteId);\n\n            if (result?.updated) {\n                // Sync successful, send event.\n                CoreEvents.trigger(AddonModChoiceSyncProvider.AUTO_SYNCED, {\n                    choiceId: response.choiceid,\n                    userId: response.userid,\n                    warnings: result.warnings,\n                }, siteId);\n            }\n        }));\n    }\n\n    /**\n     * Sync an choice only if a certain time has passed since the last time.\n     *\n     * @param choiceId Choice ID to be synced.\n     * @param userId User the answers belong to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the choice is synced or it doesn't need to be synced.\n     */\n    async syncChoiceIfNeeded(choiceId: number, userId: number, siteId?: string): Promise<AddonModChoiceSyncResult | undefined> {\n        const syncId = this.getSyncId(choiceId, userId);\n\n        const needed = await this.isSyncNeeded(syncId, siteId);\n\n        if (needed) {\n            return this.syncChoice(choiceId, userId, siteId);\n        }\n    }\n\n    /**\n     * Synchronize a choice.\n     *\n     * @param choiceId Choice ID to be synced.\n     * @param userId User the answers belong to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    async syncChoice(choiceId: number, userId?: number, siteId?: string): Promise<AddonModChoiceSyncResult> {\n        const site = await CoreSites.getSite(siteId);\n\n        userId = userId || site.getUserId();\n        siteId = site.getId();\n\n        const syncId = this.getSyncId(choiceId, userId);\n        const currentSyncPromise = this.getOngoingSync(syncId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this discussion, return the promise.\n            return currentSyncPromise;\n        }\n\n        this.logger.debug(`Try to sync choice '${choiceId}' for user '${userId}'`);\n\n        return this.addOngoingSync(syncId, this.performSync(choiceId, userId, siteId), siteId);\n    }\n\n    /**\n     * Synchronize a choice.\n     *\n     * @param choiceId Choice ID to be synced.\n     * @param userId User the answers belong to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if sync is successful, rejected otherwise.\n     */\n    protected async performSync(choiceId: number, userId: number, siteId?: string): Promise<AddonModChoiceSyncResult> {\n        const syncId = this.getSyncId(choiceId, userId);\n        const result: AddonModChoiceSyncResult = {\n            warnings: [],\n            updated: false,\n        };\n\n        // Sync offline logs.\n        await CoreUtils.ignoreErrors(CoreCourseLogHelper.syncActivity(AddonModChoiceProvider.COMPONENT, choiceId, siteId));\n\n        const data = await CoreUtils.ignoreErrors(AddonModChoiceOffline.getResponse(choiceId, siteId, userId));\n\n        if (!data || !data.choiceid) {\n            // Nothing to sync. Set sync time.\n            await this.setSyncTime(syncId, siteId);\n\n            return result;\n        }\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline.\n            throw new CoreNetworkError();\n        }\n\n        const courseId = data.courseid;\n\n        try {\n            // Send the responses.\n            if (data.deleting) {\n                // A user has deleted some responses.\n                await AddonModChoice.deleteResponsesOnline(choiceId, data.responses, siteId);\n            } else {\n                // A user has added some responses.\n                await AddonModChoice.submitResponseOnline(choiceId, data.responses, siteId);\n            }\n\n            result.updated = true;\n\n            await AddonModChoiceOffline.deleteResponse(choiceId, siteId, userId);\n        } catch (error) {\n            if (!CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server, reject.\n                throw error;\n            }\n\n            // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.\n            result.updated = true;\n\n            await AddonModChoiceOffline.deleteResponse(choiceId, siteId, userId);\n\n            // Responses deleted, add a warning.\n            this.addOfflineDataDeletedWarning(result.warnings, data.name, error);\n        }\n\n        // Data has been sent to server, prefetch choice if needed.\n        try {\n            const module = await CoreCourse.getModuleBasicInfoByInstance(choiceId, 'choice', { siteId });\n\n            await this.prefetchAfterUpdate(AddonModChoicePrefetchHandler.instance, module, courseId, undefined, siteId);\n        } catch {\n            // Ignore errors.\n        }\n\n        // Sync finished, set sync time.\n        await this.setSyncTime(syncId, siteId);\n\n        return result;\n    }\n\n}\n\nexport const AddonModChoiceSync = makeSingleton(AddonModChoiceSyncProvider);\n\n/**\n * Data returned by a choice sync.\n */\nexport type AddonModChoiceSyncResult = CoreSyncResult;\n\n/**\n * Data passed to AUTO_SYNCED event.\n */\nexport type AddonModChoiceAutoSyncData = {\n    choiceId: number;\n    userId: number;\n    warnings: string[];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}