{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { SecurityContext } from '@angular/core';\nimport { Md5 } from 'ts-md5/dist/md5';\nimport { CoreApp } from '@services/app';\nimport { CoreConfig } from '@services/config';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreSites } from '@services/sites';\nimport { CoreWS } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { DomSanitizer, makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreNavigator } from '@services/navigator';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreCustomURLSchemes } from '@services/urlschemes';\nimport { CorePushNotifications } from '@features/pushnotifications/services/pushnotifications';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { CoreSettingsHelper } from '@features/settings/services/settings-helper';\nimport { CoreSiteQRCodeType, TypeOfLogin } from '@classes/sites/unauthenticated-site';\nimport { EMAIL_SIGNUP_FEATURE_NAME, FAQ_QRCODE_IMAGE_HTML, FAQ_QRCODE_INFO_DONE, FORGOTTEN_PASSWORD_FEATURE_NAME, IDENTITY_PROVIDERS_FEATURE_NAME, IDENTITY_PROVIDER_FEATURE_NAME_PREFIX } from '../constants';\nimport * as i0 from \"@angular/core\";\n/**\n * Helper provider that provides some common features regarding authentication.\n */\nexport class CoreLoginHelperProvider {\n  constructor() {\n    this.sessionExpiredCheckingSite = {};\n    this.isOpenEditAlertShown = false;\n    this.logger = CoreLogger.getInstance('CoreLoginHelper');\n  }\n  /**\n   * Initialize service.\n   */\n  initialize() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.cleanUpPasswordResets();\n    })();\n  }\n  /**\n   * Accept site policy.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved if success, rejected if failure.\n   */\n  acceptSitePolicy(siteId) {\n    return _asyncToGenerator(function* () {\n      var _result$warnings;\n      const site = yield CoreSites.getSite(siteId);\n      const result = yield site.write('core_user_agree_site_policy', {});\n      if (result.status) {\n        return;\n      }\n      if (!((_result$warnings = result.warnings) !== null && _result$warnings !== void 0 && _result$warnings.length)) {\n        throw new CoreError('Cannot agree site policy');\n      }\n      // Check if there is a warning 'alreadyagreed'.\n      const found = result.warnings.some(warning => warning.warningcode === 'alreadyagreed');\n      if (found) {\n        // Policy already agreed, treat it as a success.\n        return;\n      }\n      // Another warning, reject.\n      throw new CoreWSError(result.warnings[0]);\n    })();\n  }\n  /**\n   * Check if a site allows requesting a password reset through the app.\n   *\n   * @param siteUrl URL of the site.\n   * @returns Promise resolved with boolean: whether can be done through the app.\n   */\n  canRequestPasswordReset(siteUrl) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this2.requestPasswordReset(siteUrl);\n        return true;\n      } catch (error) {\n        return error.available == 1 || error.errorcode && error.errorcode != 'invalidrecord';\n      }\n    })();\n  }\n  /**\n   * Function called when an SSO InAppBrowser is closed or the app is resumed. Check if user needs to be logged out.\n   */\n  checkLogout() {\n    const currentSite = CoreSites.getCurrentSite();\n    if (!CoreApp.isSSOAuthenticationOngoing() && currentSite !== null && currentSite !== void 0 && currentSite.isLoggedOut() && CoreNavigator.isCurrent('/login/reconnect')) {\n      // User must reauthenticate but he closed the InAppBrowser without doing so, logout him.\n      CoreSites.logout();\n    }\n  }\n  /**\n   * Open a browser to perform SSO login.\n   *\n   * @param siteUrl URL of the site where the SSO login will be performed.\n   * @param typeOfLogin TypeOfLogin.BROWSER or TypeOfLogin.EMBEDDED.\n   * @param service The service to use. If not defined, core service will be used.\n   * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n   * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n   * @returns Promise resolved when done or if user cancelled.\n   * @deprecated since 4.3. Use openBrowserForSSOLogin instead.\n   */\n  confirmAndOpenBrowserForSSOLogin(siteUrl, typeOfLogin, service, launchUrl, redirectData) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.openBrowserForSSOLogin(siteUrl, typeOfLogin, service, launchUrl, redirectData);\n    })();\n  }\n  /**\n   * Helper function to act when the forgotten password is clicked.\n   *\n   * @param siteUrl Site URL.\n   * @param username Username.\n   * @param siteConfig Site config.\n   */\n  forgottenPasswordClicked(siteUrl, username, siteConfig) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (siteConfig && siteConfig.forgottenpasswordurl) {\n        // URL set, open it.\n        CoreUtils.openInApp(siteConfig.forgottenpasswordurl);\n        return;\n      }\n      // Check if password reset can be done through the app.\n      const modal = yield CoreDomUtils.showModalLoading();\n      try {\n        const canReset = yield _this4.canRequestPasswordReset(siteUrl);\n        if (canReset) {\n          yield CoreNavigator.navigate('/login/forgottenpassword', {\n            params: {\n              siteUrl,\n              siteConfig,\n              username\n            }\n          });\n        } else {\n          _this4.openForgottenPassword(siteUrl);\n        }\n      } finally {\n        modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Format profile fields, filtering the ones that shouldn't be shown on signup and classifying them in categories.\n   *\n   * @param profileFields Profile fields to format.\n   * @returns Categories with the fields to show in each one.\n   */\n  formatProfileFieldsForSignup(profileFields) {\n    if (!profileFields) {\n      return [];\n    }\n    const categories = {};\n    profileFields.forEach(field => {\n      if (!field.signup || !field.categoryid) {\n        // Not a signup field, ignore it.\n        return;\n      }\n      if (!categories[field.categoryid]) {\n        categories[field.categoryid] = {\n          id: field.categoryid,\n          name: field.categoryname || '',\n          fields: []\n        };\n      }\n      categories[field.categoryid].fields.push(field);\n    });\n    return Object.keys(categories).map(index => categories[Number(index)]);\n  }\n  /**\n   * Get disabled features from a site public config.\n   *\n   * @param config Site public config.\n   * @returns Disabled features.\n   * @deprecated since 4.4. No longer needed.\n   */\n  getDisabledFeatures(config) {\n    const disabledFeatures = config === null || config === void 0 ? void 0 : config.tool_mobile_disabledfeatures;\n    if (!disabledFeatures) {\n      return '';\n    }\n    return CoreTextUtils.treatDisabledFeatures(disabledFeatures);\n  }\n  /**\n   * Builds an object with error messages for some common errors.\n   * Please notice that this function doesn't support all possible error types.\n   *\n   * @param requiredMsg Code of the string for required error.\n   * @param emailMsg Code of the string for invalid email error.\n   * @param patternMsg Code of the string for pattern not match error.\n   * @param urlMsg Code of the string for invalid url error.\n   * @param minlengthMsg Code of the string for \"too short\" error.\n   * @param maxlengthMsg Code of the string for \"too long\" error.\n   * @param minMsg Code of the string for min value error.\n   * @param maxMsg Code of the string for max value error.\n   * @returns Object with the errors.\n   */\n  getErrorMessages(requiredMsg, emailMsg, patternMsg, urlMsg, minlengthMsg, maxlengthMsg, minMsg, maxMsg) {\n    const errors = {};\n    if (requiredMsg) {\n      errors.required = errors.requiredTrue = Translate.instant(requiredMsg);\n    }\n    if (emailMsg) {\n      errors.email = Translate.instant(emailMsg);\n    }\n    if (patternMsg) {\n      errors.pattern = Translate.instant(patternMsg);\n    }\n    if (urlMsg) {\n      errors.url = Translate.instant(urlMsg);\n    }\n    if (minlengthMsg) {\n      errors.minlength = Translate.instant(minlengthMsg);\n    }\n    if (maxlengthMsg) {\n      errors.maxlength = Translate.instant(maxlengthMsg);\n    }\n    if (minMsg) {\n      errors.min = Translate.instant(minMsg);\n    }\n    if (maxMsg) {\n      errors.max = Translate.instant(maxMsg);\n    }\n    return errors;\n  }\n  /**\n   * Get logo URL from a site public config.\n   *\n   * @param config Site public config.\n   * @returns Logo URL.\n   * @deprecated since 4.4. Please use getLogoUrl in a site instance.\n   */\n  getLogoUrl(config) {\n    return !CoreConstants.CONFIG.forceLoginLogo && config ? config.logourl || config.compactlogourl : undefined;\n  }\n  /**\n   * Returns the logout label of a site.\n   *\n   * @param site Site. If not defined, use current site.\n   * @returns The string key.\n   */\n  getLogoutLabel(site) {\n    var _site;\n    site = site || CoreSites.getCurrentSite();\n    const config = (_site = site) === null || _site === void 0 ? void 0 : _site.getStoredConfig();\n    return 'core.mainmenu.' + (config && config.tool_mobile_forcelogout == '1' ? 'logout' : 'switchaccount');\n  }\n  /**\n   * Get the OAuth ID of some URL params (if it has an OAuth ID).\n   *\n   * @param params Params.\n   * @returns OAuth ID.\n   */\n  getOAuthIdFromParams(params) {\n    return params && params.oauthsso !== undefined ? Number(params.oauthsso) : undefined;\n  }\n  /**\n   * Get the site policy.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the site policy.\n   */\n  getSitePolicy(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      let sitePolicy;\n      try {\n        // Try to get the latest config, maybe the site policy was just added or has changed.\n        sitePolicy = yield site.getConfig('sitepolicy', true);\n      } catch (error) {\n        // Cannot get config, try to get the site policy using auth_email_get_signup_settings.\n        const settings = yield CoreWS.callAjax('auth_email_get_signup_settings', {}, {\n          siteUrl: site.getURL()\n        });\n        sitePolicy = settings.sitepolicy;\n      }\n      if (!sitePolicy) {\n        throw new CoreError('Cannot retrieve site policy');\n      }\n      return sitePolicy;\n    })();\n  }\n  /**\n   * Get fixed site or sites.\n   *\n   * @returns Fixed site or list of fixed sites.\n   * @deprecated since 4.2. Use CoreConstants.CONFIG.sites or getAvailableSites() instead.\n   */\n  getFixedSites() {\n    const notStagingSites = CoreConstants.CONFIG.sites.filter(site => !site.staging);\n    return notStagingSites.length === 1 ? notStagingSites[0].url : notStagingSites;\n  }\n  /**\n   * Get Available sites (includes staging sites if are enabled). It doesn't include demo mode site.\n   *\n   * @returns Available sites.\n   */\n  getAvailableSites() {\n    return _asyncToGenerator(function* () {\n      const hasEnabledStagingSites = yield CoreSettingsHelper.hasEnabledStagingSites();\n      return CoreConstants.CONFIG.sites.filter(site => (!site.staging || hasEnabledStagingSites) && !site.demoMode);\n    })();\n  }\n  /**\n   * Get demo mode site info. This function doesn't check if demo mode is enabled.\n   *\n   * @returns Demo mode site info, undefined if no demo mode site.\n   */\n  getDemoModeSiteInfo() {\n    return CoreConstants.CONFIG.sites.find(site => site.demoMode);\n  }\n  /**\n   * Get the valid identity providers from a site config.\n   *\n   * @param siteConfig Site's public config.\n   * @returns Valid identity providers.\n   * @deprecated since 4.4. Please use getValidIdentityProvidersForSite instead.\n   */\n  getValidIdentityProviders(siteConfig) {\n    if (!siteConfig) {\n      return [];\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.isFeatureDisabled(IDENTITY_PROVIDERS_FEATURE_NAME, siteConfig)) {\n      // Identity providers are disabled, return an empty list.\n      return [];\n    }\n    const validProviders = [];\n    const httpUrl = CorePath.concatenatePaths(siteConfig.wwwroot, 'auth/oauth2/');\n    const httpsUrl = CorePath.concatenatePaths(siteConfig.httpswwwroot, 'auth/oauth2/');\n    if (siteConfig.identityproviders && siteConfig.identityproviders.length) {\n      siteConfig.identityproviders.forEach(provider => {\n        const urlParams = CoreUrlUtils.extractUrlParams(provider.url);\n        if (provider.url && (provider.url.indexOf(httpsUrl) != -1 || provider.url.indexOf(httpUrl) != -1) && !this.isFeatureDisabled(\n        // eslint-disable-line deprecation/deprecation\n        IDENTITY_PROVIDER_FEATURE_NAME_PREFIX + urlParams.id, siteConfig)) {\n          validProviders.push(provider);\n        }\n      });\n    }\n    return validProviders;\n  }\n  /**\n   * Get the valid identity providers from a site config.\n   *\n   * @param site Site instance.\n   * @returns Valid identity providers.\n   */\n  getValidIdentityProvidersForSite(site) {\n    return _asyncToGenerator(function* () {\n      const siteConfig = yield CoreUtils.ignoreErrors(site.getPublicConfig());\n      if (!siteConfig) {\n        return [];\n      }\n      if (site.isFeatureDisabled(IDENTITY_PROVIDERS_FEATURE_NAME)) {\n        // Identity providers are disabled, return an empty list.\n        return [];\n      }\n      const validProviders = [];\n      const httpUrl = CorePath.concatenatePaths(siteConfig.wwwroot, 'auth/oauth2/');\n      const httpsUrl = CorePath.concatenatePaths(siteConfig.httpswwwroot, 'auth/oauth2/');\n      if (siteConfig.identityproviders && siteConfig.identityproviders.length) {\n        siteConfig.identityproviders.forEach(provider => {\n          const urlParams = CoreUrlUtils.extractUrlParams(provider.url);\n          if (provider.url && (provider.url.indexOf(httpsUrl) != -1 || provider.url.indexOf(httpUrl) != -1) && !site.isFeatureDisabled(IDENTITY_PROVIDER_FEATURE_NAME_PREFIX + urlParams.id)) {\n            validProviders.push(provider);\n          }\n        });\n      }\n      return validProviders;\n    })();\n  }\n  /**\n   * Go to the page to add a new site.\n   * If a fixed URL is configured, go to credentials instead.\n   *\n   * @param setRoot True to set the new page as root, false to add it to the stack.\n   * @param showKeyboard Whether to show keyboard in the new page. Only if no fixed URL set.\n   * @returns Promise resolved when done.\n   */\n  goToAddSite(setRoot = false, showKeyboard = false) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      let path = '/login/sites';\n      let params = {\n        openAddSite: true,\n        showKeyboard\n      };\n      if (CoreSites.isLoggedIn()) {\n        const willReload = yield CoreSites.logoutForRedirect(CoreConstants.NO_SITE_ID, {\n          redirectPath: path,\n          redirectOptions: {\n            params\n          }\n        });\n        if (willReload) {\n          return;\n        }\n      } else {\n        [path, params] = yield _this5.getAddSiteRouteInfo(showKeyboard);\n      }\n      yield CoreNavigator.navigate(path, {\n        params,\n        reset: setRoot\n      });\n    })();\n  }\n  /**\n   * Get path and params to visit the route to add site.\n   *\n   * @param showKeyboard Whether to show keyboard in the new page. Only if no fixed URL set.\n   * @returns Path and params.\n   */\n  getAddSiteRouteInfo(showKeyboard) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (CoreConstants.CONFIG.demoMode) {\n        const demoModeSite = _this6.getDemoModeSiteInfo();\n        if (demoModeSite) {\n          return ['/login/credentials', {\n            siteUrl: demoModeSite.url\n          }];\n        }\n      }\n      const sites = yield _this6.getAvailableSites();\n      if (sites.length === 1) {\n        // Fixed URL is set, go to credentials page.\n        return ['/login/credentials', {\n          siteUrl: sites[0].url\n        }];\n      }\n      return ['/login/site', {\n        showKeyboard\n      }];\n    })();\n  }\n  /**\n   * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,\n   * the site is stored and the user is authenticated. If the account already exists, update its token.\n   *\n   * @param siteUrl Site's URL.\n   * @param token User's token.\n   * @param privateToken User's private token.\n   * @param oauthId OAuth ID. Only if the authentication was using an OAuth method.\n   * @returns Promise resolved when the user is authenticated with the token.\n   */\n  handleSSOLoginAuthentication(siteUrl, token, privateToken, oauthId) {\n    // Always create a new site to prevent overriding data if another user credentials were introduced.\n    return CoreSites.newSite(siteUrl, token, privateToken, true, oauthId);\n  }\n  /**\n   * Check if the app is configured to use several fixed URLs.\n   *\n   * @returns Whether there are several fixed URLs.\n   * @deprecated since 4.2. Use CoreConstants.CONFIG.sites.length > 1 instead.\n   */\n  hasSeveralFixedSites() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this7.getAvailableSites();\n      return sites.length > 1;\n    })();\n  }\n  /**\n   * Given a site public config, check if email signup is disabled.\n   *\n   * @param config Site public config.\n   * @returns Whether email signup is disabled.\n   * @deprecated since 4.4. Please use isFeatureDisabled in a site instance.\n   */\n  isEmailSignupDisabled(config) {\n    // eslint-disable-next-line deprecation/deprecation\n    return this.isFeatureDisabled(EMAIL_SIGNUP_FEATURE_NAME, config);\n  }\n  /**\n   * Given a site public config, check if a certian feature is disabled.\n   *\n   * @param feature Feature to check.\n   * @param config Site public config.\n   * @returns Whether email signup is disabled.\n   * @deprecated since 4.4. Please use isFeatureDisabled in a site instance.\n   */\n  isFeatureDisabled(feature, config) {\n    // eslint-disable-next-line deprecation/deprecation\n    return this.isFeatureDisabled(feature, config);\n  }\n  /**\n   * Check if the app is configured to use a fixed URL (only 1).\n   *\n   * @returns Whether there is 1 fixed URL.\n   * @deprecated since 4.2. Use isSingleFixedSite instead.\n   */\n  isFixedUrlSet() {\n    return CoreConstants.CONFIG.sites.filter(site => !site.staging).length === 1;\n  }\n  /**\n   * Check if the app is configured to use a fixed URL (only 1).\n   *\n   * @returns Whether there is 1 fixed URL.\n   */\n  isSingleFixedSite() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this8.getAvailableSites();\n      return sites.length === 1;\n    })();\n  }\n  /**\n   * Given a site public config, check if forgotten password is disabled.\n   *\n   * @param config Site public config.\n   * @returns Whether it's disabled.\n   * @deprecated since 4.4. Please use isFeatureDisabled in a site instance.\n   */\n  isForgottenPasswordDisabled(config) {\n    // eslint-disable-next-line deprecation/deprecation\n    return this.isFeatureDisabled(FORGOTTEN_PASSWORD_FEATURE_NAME, config);\n  }\n  /**\n   * Check if current site is logged out, triggering session expired event if it is.\n   *\n   * @param redirectData Data of the path/url to open once authenticated if logged out. If not defined, site initial page.\n   * @returns True if user is logged out, false otherwise.\n   */\n  isSiteLoggedOut(redirectData) {\n    const site = CoreSites.getCurrentSite();\n    if (!site) {\n      return false;\n    }\n    if (site.isLoggedOut()) {\n      CoreEvents.trigger(CoreEvents.SESSION_EXPIRED, redirectData || {}, site.getId());\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Check if a site URL is \"allowed\". In case the app has fixed sites, only those will be allowed to connect to.\n   *\n   * @param siteUrl Site URL to check.\n   * @param checkSiteFinder Whether to check site finder if needed. Defaults to true.\n   * @returns Promise resolved with boolean: whether is one of the fixed sites.\n   */\n  isSiteUrlAllowed(siteUrl, checkSiteFinder = true) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const sites = yield _this9.getAvailableSites();\n      if (sites.length) {\n        const demoModeSite = _this9.getDemoModeSiteInfo();\n        return sites.some(site => CoreUrl.sameDomainAndPath(siteUrl, site.url)) || !!demoModeSite && CoreUrl.sameDomainAndPath(siteUrl, demoModeSite.url);\n      } else if (CoreConstants.CONFIG.multisitesdisplay == 'sitefinder' && CoreConstants.CONFIG.onlyallowlistedsites && checkSiteFinder) {\n        // Call the sites finder to validate the site.\n        const result = yield CoreSites.findSites(siteUrl.replace(/^https?:\\/\\/|\\.\\w{2,3}\\/?$/g, ''));\n        return result && result.some(site => CoreUrl.sameDomainAndPath(siteUrl, site.url));\n      } else {\n        // No fixed sites or it uses a non-restrictive sites finder. Allow connecting.\n        return true;\n      }\n    })();\n  }\n  /**\n   * Check if SSO login should use an embedded browser.\n   *\n   * @param code Code to check.\n   * @returns True if embedded browser, false othwerise.\n   */\n  isSSOEmbeddedBrowser(code) {\n    return code == TypeOfLogin.EMBEDDED;\n  }\n  /**\n   * Check if SSO login is needed based on code returned by the WS.\n   *\n   * @param code Code to check.\n   * @returns True if SSO login is needed, false othwerise.\n   */\n  isSSOLoginNeeded(code) {\n    return code == TypeOfLogin.BROWSER || code == TypeOfLogin.EMBEDDED;\n  }\n  /**\n   * Open a browser to perform OAuth login (Google, Facebook, Microsoft).\n   *\n   * @param siteUrl URL of the site where the login will be performed.\n   * @param provider The identity provider.\n   * @param launchUrl The URL to open for SSO. If not defined, tool/mobile launch URL will be used.\n   * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n   * @returns True if success, false if error.\n   */\n  openBrowserForOAuthLogin(siteUrl, provider, launchUrl, redirectData) {\n    launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';\n    this.logger.debug('openBrowserForOAuthLogin launchUrl:', launchUrl);\n    if (!provider || !provider.url) {\n      return false;\n    }\n    const params = CoreUrlUtils.extractUrlParams(provider.url);\n    if (!params.id) {\n      return false;\n    }\n    const loginUrl = this.prepareForSSOLogin(siteUrl, undefined, launchUrl, redirectData, {\n      oauthsso: params.id\n    });\n    // Always open it in browser because the user might have the session stored in there.\n    CoreUtils.openInBrowser(loginUrl, {\n      showBrowserWarning: false\n    });\n    CoreApp.closeApp();\n    return true;\n  }\n  /**\n   * Open a browser to perform SSO login.\n   *\n   * @param siteUrl URL of the site where the SSO login will be performed.\n   * @param typeOfLogin TypeOfLogin.BROWSER or TypeOfLogin.EMBEDDED.\n   * @param service The service to use. If not defined, core service will be used.\n   * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n   * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n   */\n  openBrowserForSSOLogin(siteUrl, typeOfLogin, service, launchUrl, redirectData) {\n    const loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, redirectData);\n    this.logger.debug('openBrowserForSSOLogin loginUrl:', loginUrl);\n    if (this.isSSOEmbeddedBrowser(typeOfLogin)) {\n      CoreUtils.openInApp(loginUrl, {\n        clearsessioncache: 'yes',\n        closebuttoncaption: Translate.instant('core.login.cancel')\n      });\n    } else {\n      CoreUtils.openInBrowser(loginUrl, {\n        showBrowserWarning: false\n      });\n      CoreApp.closeApp();\n    }\n  }\n  /**\n   * Convenient helper to open change password page.\n   *\n   * @param siteUrl Site URL to construct change password URL.\n   * @param error Error message.\n   * @returns Promise resolved when done.\n   */\n  openChangePassword(siteUrl, error) {\n    return _asyncToGenerator(function* () {\n      const alert = yield CoreDomUtils.showAlert(Translate.instant('core.notice'), error, undefined, 3000);\n      yield alert.onDidDismiss();\n      CoreUtils.openInApp(siteUrl + '/login/change_password.php');\n    })();\n  }\n  /**\n   * Open forgotten password in inappbrowser.\n   *\n   * @param siteUrl URL of the site.\n   */\n  openForgottenPassword(siteUrl) {\n    CoreUtils.openInApp(siteUrl + '/login/forgot_password.php');\n  }\n  /**\n   * Function to open in app browser to change password or complete user profile.\n   *\n   * @param siteId The site ID.\n   * @param path The relative path of the URL to open.\n   * @param alertMessage The key of the message to display before opening the in app browser.\n   * @param invalidateCache Whether to invalidate site's cache (e.g. when the user is forced to change password).\n   * @returns Promise resolved when done.\n   */\n  openInAppForEdit(siteId, path, alertMessage, invalidateCache) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      if (!siteId || siteId !== CoreSites.getCurrentSiteId()) {\n        // Site that triggered the event is not current site, nothing to do.\n        return;\n      }\n      const currentSite = CoreSites.getCurrentSite();\n      const siteUrl = currentSite === null || currentSite === void 0 ? void 0 : currentSite.getURL();\n      if (!currentSite || !siteUrl) {\n        return;\n      }\n      if (!_this10.isOpenEditAlertShown && !_this10.waitingForBrowser) {\n        _this10.isOpenEditAlertShown = true;\n        if (invalidateCache) {\n          currentSite.invalidateWsCache();\n        }\n        // Open change password.\n        if (alertMessage) {\n          alertMessage = Translate.instant(alertMessage) + '<br>' + Translate.instant('core.redirectingtosite');\n        }\n        try {\n          yield currentSite.openInAppWithAutoLogin(siteUrl + path, undefined, alertMessage);\n        } finally {\n          _this10.isOpenEditAlertShown = false;\n        }\n        yield _this10.waitForBrowser();\n        CoreEvents.trigger(CoreEvents.COMPLETE_REQUIRED_PROFILE_DATA_FINISHED, {\n          path\n        }, siteId);\n      }\n    })();\n  }\n  /**\n   * Function that should be called when password change is forced. Reserved for core use.\n   *\n   * @param siteId The site ID. Undefined for current site.\n   */\n  passwordChangeForced(siteId) {\n    return _asyncToGenerator(function* () {\n      var _siteId;\n      const currentSite = CoreSites.getCurrentSite();\n      siteId = (_siteId = siteId) !== null && _siteId !== void 0 ? _siteId : currentSite === null || currentSite === void 0 ? void 0 : currentSite.getId();\n      if (!currentSite || siteId !== currentSite.getId()) {\n        return; // Site that triggered the event is not current site.\n      }\n      // If current page is already change password, stop.\n      if (CoreNavigator.isCurrent('/login/changepassword')) {\n        return;\n      }\n      yield CoreNavigator.navigate('/login/changepassword', {\n        params: {\n          siteId\n        },\n        reset: true\n      });\n    })();\n  }\n  /**\n   * Prepare the app to perform SSO login.\n   *\n   * @param siteUrl URL of the site where the SSO login will be performed.\n   * @param service The service to use. If not defined, core service will be used.\n   * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n   * @param redirectData Redirect dataof the page to go once authenticated. If not defined, site initial page.\n   * @param urlParams Other params to add to the URL.\n   * @returns Login Url.\n   */\n  prepareForSSOLogin(siteUrl, service, launchUrl, redirectData = {}, urlParams) {\n    service = service || CoreConstants.CONFIG.wsservice;\n    launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';\n    const passport = Math.random() * 1000;\n    let loginUrl = launchUrl + '?service=' + service;\n    loginUrl += '&passport=' + passport;\n    loginUrl += '&urlscheme=' + CoreConstants.CONFIG.customurlscheme;\n    if (urlParams) {\n      loginUrl = CoreUrlUtils.addParamsToUrl(loginUrl, urlParams);\n    }\n    // Store the siteurl and passport in CoreConfigProvider for persistence.\n    // We are \"configuring\" the app to wait for an SSO. CoreConfigProvider shouldn't be used as a temporary storage.\n    CoreConfig.set(CoreConstants.LOGIN_LAUNCH_DATA, JSON.stringify(_objectSpread(_objectSpread({\n      siteUrl: siteUrl,\n      passport: passport\n    }, redirectData), {}, {\n      ssoUrlParams: urlParams || {}\n    })));\n    return loginUrl;\n  }\n  /**\n   * Request a password reset.\n   *\n   * @param siteUrl URL of the site.\n   * @param username Username to search.\n   * @param email Email to search.\n   * @returns Promise resolved when done.\n   */\n  requestPasswordReset(siteUrl, username, email) {\n    const params = {};\n    if (username) {\n      params.username = username;\n    }\n    if (email) {\n      params.email = email;\n    }\n    return CoreWS.callAjax('core_auth_request_password_reset', params, {\n      siteUrl\n    });\n  }\n  /**\n   * Function that should be called when the session expires. Reserved for core use.\n   *\n   * @param data Data received by the SESSION_EXPIRED event.\n   * @returns Promise resolved when done.\n   */\n  sessionExpired(data) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const siteId = data === null || data === void 0 ? void 0 : data.siteId;\n      const currentSite = CoreSites.getCurrentSite();\n      if (!currentSite) {\n        return;\n      }\n      if (siteId && siteId !== currentSite.getId()) {\n        return; // Site that triggered the event is not current site.\n      }\n\n      if (_this11.sessionExpiredCheckingSite[siteId || '']) {\n        return; // Operation pending.\n      }\n\n      _this11.sessionExpiredCheckingSite[siteId || ''] = true;\n      const redirectData = {\n        redirectPath: data.redirectPath,\n        redirectOptions: data.redirectOptions,\n        urlToOpen: data.urlToOpen\n      };\n      try {\n        // Check authentication method.\n        const info = currentSite.getInfo();\n        if (info !== undefined && info.username !== undefined) {\n          // If current page is already reconnect, stop.\n          if (CoreNavigator.isCurrent('/login/reconnect')) {\n            return;\n          }\n          yield CoreUtils.ignoreErrors(CoreNavigator.navigate('/login/reconnect', {\n            params: _objectSpread({\n              siteId\n            }, redirectData),\n            reset: true\n          }));\n        }\n      } catch (error) {\n        // Error checking site.\n        if (currentSite.isLoggedOut()) {\n          // Site is logged out, show error and logout the user.\n          CoreDomUtils.showErrorModalDefault(error, 'core.networkerrormsg', true);\n          CoreSites.logout();\n        }\n      } finally {\n        _this11.sessionExpiredCheckingSite[siteId || ''] = false;\n      }\n    })();\n  }\n  /**\n   * Check if a confirm should be shown to open a SSO authentication.\n   *\n   * @param typeOfLogin TypeOfLogin.BROWSER or TypeOfLogin.EMBEDDED.\n   * @returns True if confirm modal should be shown, false otherwise.\n   * @deprecated since 4.3. Not used anymore. See shouldSkipCredentialsScreenOnSSO.\n   */\n  shouldShowSSOConfirm(typeOfLogin) {\n    return !this.isSSOEmbeddedBrowser(typeOfLogin) && !this.shouldSkipCredentialsScreenOnSSO();\n  }\n  /**\n   * Check if we can skip credentials page.\n   *\n   * @returns If true, the browser should be opened without the user prompt.\n   */\n  shouldSkipCredentialsScreenOnSSO() {\n    return String(CoreConstants.CONFIG.skipssoconfirmation) === 'true';\n  }\n  /**\n   * Show a modal warning that the credentials introduced were not correct.\n   */\n  showInvalidLoginModal(error) {\n    var _error$errorDetails;\n    CoreDomUtils.showErrorModal((_error$errorDetails = error.errorDetails) !== null && _error$errorDetails !== void 0 ? _error$errorDetails : error.message);\n  }\n  /**\n   * Show a modal warning the user that he should use the Workplace app.\n   *\n   * @param message The warning message.\n   */\n  showWorkplaceNoticeModal(message) {\n    const link = CoreApp.getAppStoreUrl({\n      android: 'com.moodle.workplace',\n      ios: 'id1470929705'\n    });\n    CoreDomUtils.showDownloadAppNoticeModal(message, link);\n  }\n  /**\n   * Show a modal warning the user that he should use the current Moodle app.\n   *\n   * @param message The warning message.\n   */\n  showMoodleAppNoticeModal(message) {\n    const storesConfig = CoreConstants.CONFIG.appstores;\n    storesConfig.mobile = 'https://download.moodle.org/mobile/';\n    storesConfig.default = 'https://download.moodle.org/mobile/';\n    const link = CoreApp.getAppStoreUrl(storesConfig);\n    CoreDomUtils.showDownloadAppNoticeModal(message, link);\n  }\n  /**\n   * Show a modal to inform the user that a confirmation email was sent, and a button to resend the email on 3.6+ sites.\n   *\n   * @param siteUrl Site URL.\n   * @param email Email of the user. If set displayed in the message.\n   * @param username Username. If not set the button to resend email will not be shown.\n   * @param password User password. If not set the button to resend email will not be shown.\n   */\n  showNotConfirmedModal(siteUrl, email, username, password) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const title = Translate.instant('core.login.mustconfirm');\n      let message;\n      let canResend = false;\n      if (email) {\n        message = Translate.instant('core.login.emailconfirmsent', {\n          $a: email\n        });\n      } else {\n        message = Translate.instant('core.login.emailconfirmsentnoemail');\n      }\n      // Check whether we need to display the resend button or not.\n      if (username && password) {\n        canResend = yield _this12.canResendEmail(siteUrl);\n      }\n      if (!canResend) {\n        // Just display an informative alert.\n        yield CoreDomUtils.showAlert(title, message);\n        return;\n      }\n      const okText = Translate.instant('core.login.resendemail');\n      const cancelText = Translate.instant('core.close');\n      try {\n        // Ask the user if he wants to resend the email.\n        yield CoreDomUtils.showConfirm(message, title, okText, cancelText);\n        // Call the WS to resend the confirmation email.\n        const modal = yield CoreDomUtils.showModalLoading('core.sending', true);\n        const data = {\n          username,\n          password\n        };\n        const preSets = {\n          siteUrl\n        };\n        try {\n          const result = yield CoreWS.callAjax('core_auth_resend_confirmation_email', data, preSets);\n          if (!result.status) {\n            var _result$warnings2;\n            if ((_result$warnings2 = result.warnings) !== null && _result$warnings2 !== void 0 && _result$warnings2.length) {\n              throw new CoreWSError(result.warnings[0]);\n            }\n            throw new CoreError('Error sending confirmation email');\n          }\n          const message = Translate.instant('core.login.emailconfirmsentsuccess');\n          CoreDomUtils.showAlert(Translate.instant('core.success'), message);\n        } finally {\n          modal.dismiss();\n        }\n      } catch (error) {\n        CoreDomUtils.showErrorModal(error);\n      }\n    })();\n  }\n  /**\n   * Check if confirmation email an be resent.\n   *\n   * @param siteUrl Site URL to check.\n   * @returns Promise.\n   */\n  canResendEmail(siteUrl) {\n    return _asyncToGenerator(function* () {\n      const modal = yield CoreDomUtils.showModalLoading();\n      // We don't have site info before login, the only way to check if the WS is available is by calling it.\n      try {\n        // This call will always fail because we aren't sending parameters.\n        yield CoreWS.callAjax('core_auth_resend_confirmation_email', {}, {\n          siteUrl\n        });\n        return true; // We should never reach here.\n      } catch (error) {\n        // If the WS responds with an invalid parameter error it means the WS is avaiable.\n        return (error === null || error === void 0 ? void 0 : error.errorcode) === 'invalidparameter';\n      } finally {\n        modal.dismiss();\n      }\n    })();\n  }\n  /**\n   * Function called when site policy is not agreed. Reserved for core use.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   */\n  sitePolicyNotAgreed(siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    if (!siteId || siteId != CoreSites.getCurrentSiteId()) {\n      // Only current site allowed.\n      return;\n    }\n    // If current page is already site policy, stop.\n    if (CoreNavigator.isCurrent('/login/sitepolicy')) {\n      return;\n    }\n    CoreNavigator.navigate('/login/sitepolicy', {\n      params: {\n        siteId\n      },\n      reset: true\n    });\n  }\n  /**\n   * Convenient helper to handle get User Token error. It redirects to change password page if forcepassword is set.\n   *\n   * @param siteUrl Site URL to construct change password URL.\n   * @param error Error object containing errorcode and error message.\n   * @param username Username.\n   * @param password User password.\n   */\n  treatUserTokenError(siteUrl, error, username, password) {\n    var _CoreTextUtils$getErr, _CoreTextUtils$getErr2, _CoreTextUtils$getErr3;\n    switch (error.errorcode) {\n      case 'forcepasswordchangenotice':\n        this.openChangePassword(siteUrl, (_CoreTextUtils$getErr = CoreTextUtils.getErrorMessageFromError(error)) !== null && _CoreTextUtils$getErr !== void 0 ? _CoreTextUtils$getErr : '');\n        break;\n      case 'usernotconfirmed':\n        this.showNotConfirmedModal(siteUrl, undefined, username, password);\n        break;\n      case 'connecttomoodleapp':\n        this.showMoodleAppNoticeModal((_CoreTextUtils$getErr2 = CoreTextUtils.getErrorMessageFromError(error)) !== null && _CoreTextUtils$getErr2 !== void 0 ? _CoreTextUtils$getErr2 : '');\n        break;\n      case 'connecttoworkplaceapp':\n        this.showWorkplaceNoticeModal((_CoreTextUtils$getErr3 = CoreTextUtils.getErrorMessageFromError(error)) !== null && _CoreTextUtils$getErr3 !== void 0 ? _CoreTextUtils$getErr3 : '');\n        break;\n      case 'invalidlogin':\n        this.showInvalidLoginModal(error);\n        break;\n      default:\n        CoreDomUtils.showErrorModal(error);\n        break;\n    }\n  }\n  /**\n   * Convenient helper to validate a browser SSO login.\n   *\n   * @param url URL received, to be validated.\n   * @returns Promise resolved on success.\n   */\n  validateBrowserSSOLogin(url) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      // Split signature:::token\n      const params = url.split(':::');\n      const serializedData = yield CoreConfig.get(CoreConstants.LOGIN_LAUNCH_DATA);\n      const data = CoreTextUtils.parseJSON(serializedData, null);\n      if (data === null) {\n        throw new CoreError('No launch data stored.');\n      }\n      const passport = data.passport;\n      let launchSiteURL = data.siteUrl;\n      // Reset temporary values.\n      CoreConfig.delete(CoreConstants.LOGIN_LAUNCH_DATA);\n      // Validate the signature.\n      // We need to check both http and https.\n      let signature = Md5.hashAsciiStr(launchSiteURL + passport);\n      if (signature != params[0]) {\n        if (launchSiteURL.indexOf('https://') != -1) {\n          launchSiteURL = launchSiteURL.replace('https://', 'http://');\n        } else {\n          launchSiteURL = launchSiteURL.replace('http://', 'https://');\n        }\n        signature = Md5.hashAsciiStr(launchSiteURL + passport);\n      }\n      if (signature == params[0]) {\n        _this13.logger.debug('Signature validated');\n        return {\n          siteUrl: launchSiteURL,\n          token: params[1],\n          privateToken: params[2],\n          redirectPath: data.redirectPath,\n          redirectOptions: data.redirectOptions,\n          urlToOpen: data.urlToOpen,\n          ssoUrlParams: data.ssoUrlParams\n        };\n      } else {\n        _this13.logger.debug('Invalid signature in the URL request yours: ' + params[0] + ' mine: ' + signature + ' for passport ' + passport);\n        throw new CoreError(Translate.instant('core.unexpectederror'));\n      }\n    })();\n  }\n  /**\n   * Return whether the app is waiting for browser.\n   *\n   * @returns Whether the app is waiting for browser.\n   */\n  isWaitingForBrowser() {\n    return !!this.waitingForBrowser;\n  }\n  /**\n   * Start waiting when opening a browser/IAB.\n   *\n   * @returns Promise resolved when the app is resumed.\n   */\n  waitForBrowser() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this14.waitingForBrowser) {\n        _this14.waitingForBrowser = new CorePromisedValue();\n      }\n      yield _this14.waitingForBrowser;\n    })();\n  }\n  /**\n   * Stop waiting for browser.\n   */\n  stopWaitingForBrowser() {\n    var _this$waitingForBrows;\n    (_this$waitingForBrows = this.waitingForBrowser) === null || _this$waitingForBrows === void 0 || _this$waitingForBrows.resolve();\n    this.waitingForBrowser = undefined;\n  }\n  /**\n   * Check whether the QR reader should be displayed in site screen.\n   *\n   * @returns Whether the QR reader should be displayed in site screen.\n   */\n  displayQRInSiteScreen() {\n    return CoreUtils.canScanQR() && (CoreConstants.CONFIG.displayqronsitescreen === undefined || !!CoreConstants.CONFIG.displayqronsitescreen);\n  }\n  /**\n   * Check whether the QR reader should be displayed in credentials screen.\n   *\n   * @param qrCodeType QR Code type from public config, assuming enabled if undefined.\n   * @returns Whether the QR reader should be displayed in credentials screen.\n   */\n  displayQRInCredentialsScreen(qrCodeType = CoreSiteQRCodeType.QR_CODE_LOGIN) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      if (!CoreUtils.canScanQR()) {\n        return false;\n      }\n      const isSingleFixedSite = yield _this15.isSingleFixedSite();\n      if (CoreConstants.CONFIG.displayqroncredentialscreen === undefined && isSingleFixedSite || CoreConstants.CONFIG.displayqroncredentialscreen !== undefined && !!CoreConstants.CONFIG.displayqroncredentialscreen) {\n        return qrCodeType == CoreSiteQRCodeType.QR_CODE_LOGIN;\n      }\n      return false;\n    })();\n  }\n  /**\n   * Show instructions to scan QR code.\n   *\n   * @returns Promise resolved if the user accepts to scan QR.\n   */\n  showScanQRInstructions() {\n    return _asyncToGenerator(function* () {\n      const dontShowWarning = yield CoreConfig.get(FAQ_QRCODE_INFO_DONE, 0);\n      if (dontShowWarning) {\n        return;\n      }\n      const message = Translate.instant('core.login.faqwhereisqrcodeanswer', {\n        $image: '<div class=\"text-center\">' + FAQ_QRCODE_IMAGE_HTML + '</div>'\n      });\n      const header = Translate.instant('core.login.faqwhereisqrcode');\n      try {\n        const dontShowAgain = yield CoreDomUtils.showPrompt(message, header, Translate.instant('core.dontshowagain'), 'checkbox', {\n          okText: Translate.instant('core.next'),\n          cancelText: Translate.instant('core.cancel')\n        });\n        if (dontShowAgain) {\n          CoreConfig.set(FAQ_QRCODE_INFO_DONE, 1);\n        }\n      } catch (_unused) {\n        // User canceled.\n        throw new CoreCanceledError('');\n      }\n    })();\n  }\n  /**\n   * Scan a QR code and tries to authenticate the user using custom URL scheme.\n   *\n   * @returns Promise resolved when done.\n   */\n  scanQR() {\n    return _asyncToGenerator(function* () {\n      // Scan for a QR code.\n      const text = yield CoreUtils.scanQR();\n      if (text && CoreCustomURLSchemes.isCustomURL(text)) {\n        try {\n          yield CoreCustomURLSchemes.handleCustomURL(text);\n        } catch (error) {\n          CoreCustomURLSchemes.treatHandleCustomURLError(error);\n        }\n      } else if (text) {\n        // Not a custom URL scheme, check if it's a URL scheme to another app.\n        const scheme = CoreUrlUtils.getUrlProtocol(text);\n        if (scheme && scheme != 'http' && scheme != 'https') {\n          CoreDomUtils.showErrorModal(Translate.instant('core.errorurlschemeinvalidscheme', {\n            $a: text\n          }));\n        } else {\n          CoreDomUtils.showErrorModal('core.login.errorqrnoscheme', true);\n        }\n      }\n    })();\n  }\n  /**\n   * Get the accounts list classified per site.\n   *\n   * @returns Promise resolved with account list.\n   */\n  getAccountsList() {\n    return _asyncToGenerator(function* () {\n      const sites = yield CoreUtils.ignoreErrors(CoreSites.getSortedSites(), []);\n      const accountsList = {\n        sameSite: [],\n        otherSites: [],\n        count: sites.length\n      };\n      const currentSiteId = CoreSites.getCurrentSiteId();\n      let siteUrl = '';\n      if (currentSiteId) {\n        var _sites$find$siteUrlWi, _sites$find;\n        siteUrl = (_sites$find$siteUrlWi = (_sites$find = sites.find(site => site.id == currentSiteId)) === null || _sites$find === void 0 ? void 0 : _sites$find.siteUrlWithoutProtocol) !== null && _sites$find$siteUrlWi !== void 0 ? _sites$find$siteUrlWi : '';\n      }\n      const otherSites = {};\n      // Add site counter and classify sites.\n      yield Promise.all(sites.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (site) {\n          site.badge = (yield CoreUtils.ignoreErrors(CorePushNotifications.getSiteCounter(site.id))) || 0;\n          if (site.id === currentSiteId) {\n            accountsList.currentSite = site;\n          } else if (site.siteUrlWithoutProtocol == siteUrl) {\n            accountsList.sameSite.push(site);\n          } else {\n            if (!otherSites[site.siteUrlWithoutProtocol]) {\n              otherSites[site.siteUrlWithoutProtocol] = [];\n            }\n            otherSites[site.siteUrlWithoutProtocol].push(site);\n          }\n          return;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      accountsList.otherSites = CoreUtils.objectToArray(otherSites);\n      return accountsList;\n    })();\n  }\n  /**\n   * Find and delete a site from the list of sites.\n   *\n   * @param accountsList Account list.\n   * @param site Site to be deleted.\n   * @returns Resolved when done.\n   */\n  deleteAccountFromList(accountsList, site) {\n    return _asyncToGenerator(function* () {\n      yield CoreSites.deleteSite(site.id);\n      const siteUrl = site.siteUrlWithoutProtocol;\n      let index = 0;\n      // Found on same site.\n      if (accountsList.sameSite.length > 0 && accountsList.sameSite[0].siteUrlWithoutProtocol == siteUrl) {\n        index = accountsList.sameSite.findIndex(listedSite => listedSite.id == site.id);\n        if (index >= 0) {\n          accountsList.sameSite.splice(index, 1);\n          accountsList.count--;\n        }\n        return;\n      }\n      const otherSiteIndex = accountsList.otherSites.findIndex(sites => sites.length > 0 && sites[0].siteUrlWithoutProtocol == siteUrl);\n      if (otherSiteIndex < 0) {\n        // Site Url not found.\n        return;\n      }\n      index = accountsList.otherSites[otherSiteIndex].findIndex(listedSite => listedSite.id == site.id);\n      if (index >= 0) {\n        accountsList.otherSites[otherSiteIndex].splice(index, 1);\n        accountsList.count--;\n      }\n      if (accountsList.otherSites[otherSiteIndex].length == 0) {\n        accountsList.otherSites.splice(otherSiteIndex, 1);\n      }\n    })();\n  }\n  /**\n   * Get reconnect page route module.\n   *\n   * @returns Reconnect page route module.\n   */\n  getReconnectRouteModule() {\n    return _asyncToGenerator(function* () {\n      return import('@features/login/login-reconnect-lazy.module').then(m => m.CoreLoginReconnectLazyModule);\n    })();\n  }\n  /**\n   * Get credentials page route module.\n   *\n   * @returns Credentials page route module.\n   */\n  getCredentialsRouteModule() {\n    return _asyncToGenerator(function* () {\n      return import('@features/login/login-credentials-lazy.module').then(m => m.CoreLoginCredentialsLazyModule);\n    })();\n  }\n  /**\n   * Retrieve login methods.\n   *\n   * @returns Login methods found.\n   */\n  getLoginMethods() {\n    return _asyncToGenerator(function* () {\n      return [];\n    })();\n  }\n  /**\n   * Retrieve default login method.\n   *\n   * @returns Default login method.\n   */\n  getDefaultLoginMethod() {\n    return _asyncToGenerator(function* () {\n      return null;\n    })();\n  }\n  /**\n   * Record that a password reset has been requested for a given site.\n   *\n   * @param siteUrl Site url.\n   */\n  passwordResetRequested(siteUrl) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const passwordResets = yield _this16.getPasswordResets();\n      passwordResets[siteUrl] = Date.now();\n      yield CoreConfig.set(CoreLoginHelperProvider.PASSWORD_RESETS_CONFIG_KEY, JSON.stringify(passwordResets));\n    })();\n  }\n  /**\n   * Find out if a password reset has been requested recently for a given site.\n   *\n   * @param siteUrl Site url.\n   * @returns Whether a password reset has been requested recently.\n   */\n  wasPasswordResetRequestedRecently(siteUrl) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const passwordResets = yield _this17.getPasswordResets();\n      return siteUrl in passwordResets && passwordResets[siteUrl] > Date.now() - CoreConstants.MILLISECONDS_HOUR;\n    })();\n  }\n  /**\n   * Clean up expired password reset records from the database.\n   */\n  cleanUpPasswordResets() {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const passwordResets = yield _this18.getPasswordResets();\n      const siteUrls = Object.keys(passwordResets);\n      for (const siteUrl of siteUrls) {\n        if (passwordResets[siteUrl] > Date.now() - CoreConstants.MILLISECONDS_HOUR) {\n          continue;\n        }\n        delete passwordResets[siteUrl];\n      }\n      if (Object.values(passwordResets).length === 0) {\n        yield CoreConfig.delete(CoreLoginHelperProvider.PASSWORD_RESETS_CONFIG_KEY);\n      } else {\n        yield CoreConfig.set(CoreLoginHelperProvider.PASSWORD_RESETS_CONFIG_KEY, JSON.stringify(passwordResets));\n      }\n    })();\n  }\n  /**\n   * Build the HTML message to show once login attempts have been exceeded.\n   *\n   * @param canContactSupport Whether contacting support is enabled in the site.\n   * @param canRecoverPassword Whether recovering the password is enabled in the site.\n   * @returns HTML message.\n   */\n  buildExceededAttemptsHTML(canContactSupport, canRecoverPassword) {\n    const safeHTML = html => {\n      var _DomSanitizer$sanitiz;\n      return (_DomSanitizer$sanitiz = DomSanitizer.sanitize(SecurityContext.HTML, html)) !== null && _DomSanitizer$sanitiz !== void 0 ? _DomSanitizer$sanitiz : '';\n    };\n    const recoverPasswordHTML = messageKey => {\n      const placeholder = '%%RECOVER_PASSWORD%%';\n      const message = safeHTML(Translate.instant(messageKey, {\n        recoverPassword: placeholder\n      }));\n      const recoverPassword = safeHTML(Translate.instant('core.login.exceededloginattemptsrecoverpassword'));\n      return DomSanitizer.bypassSecurityTrustHtml(message.replace(placeholder, `<a href=\"#\" role=\"button\" style=\"color:inherit\">${recoverPassword}</a>`));\n    };\n    if (canContactSupport && canRecoverPassword) {\n      return recoverPasswordHTML('core.login.exceededloginattempts');\n    }\n    if (canContactSupport) {\n      return Translate.instant('core.login.exceededloginattemptswithoutpassword');\n    }\n    if (canRecoverPassword) {\n      return recoverPasswordHTML('core.login.exceededloginattemptswithoutsupport');\n    }\n    return null;\n  }\n  /**\n   * Get a record indexing the last time a password reset was requested for a site.\n   *\n   * @returns Password resets.\n   */\n  getPasswordResets() {\n    return _asyncToGenerator(function* () {\n      const passwordResetsJson = yield CoreConfig.get(CoreLoginHelperProvider.PASSWORD_RESETS_CONFIG_KEY, '{}');\n      return CoreTextUtils.parseJSON(passwordResetsJson, {});\n    })();\n  }\n}\n_class = CoreLoginHelperProvider;\n_class.PASSWORD_RESETS_CONFIG_KEY = 'password-resets';\n_class.ɵfac = function CoreLoginHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreLoginHelper = makeSingleton(CoreLoginHelperProvider);","map":{"version":3,"names":["SecurityContext","Md5","CoreApp","CoreConfig","CoreEvents","CoreSites","CoreWS","CoreDomUtils","CoreTextUtils","CoreUrlUtils","CoreUtils","CoreConstants","CoreError","CoreWSError","DomSanitizer","makeSingleton","Translate","CoreLogger","CoreUrl","CoreNavigator","CoreCanceledError","CoreCustomURLSchemes","CorePushNotifications","CorePath","CorePromisedValue","CoreSettingsHelper","CoreSiteQRCodeType","TypeOfLogin","EMAIL_SIGNUP_FEATURE_NAME","FAQ_QRCODE_IMAGE_HTML","FAQ_QRCODE_INFO_DONE","FORGOTTEN_PASSWORD_FEATURE_NAME","IDENTITY_PROVIDERS_FEATURE_NAME","IDENTITY_PROVIDER_FEATURE_NAME_PREFIX","CoreLoginHelperProvider","constructor","sessionExpiredCheckingSite","isOpenEditAlertShown","logger","getInstance","initialize","_this","_asyncToGenerator","cleanUpPasswordResets","acceptSitePolicy","siteId","_result$warnings","site","getSite","result","write","status","warnings","length","found","some","warning","warningcode","canRequestPasswordReset","siteUrl","_this2","requestPasswordReset","error","available","errorcode","checkLogout","currentSite","getCurrentSite","isSSOAuthenticationOngoing","isLoggedOut","isCurrent","logout","confirmAndOpenBrowserForSSOLogin","typeOfLogin","service","launchUrl","redirectData","_this3","openBrowserForSSOLogin","forgottenPasswordClicked","username","siteConfig","_this4","forgottenpasswordurl","openInApp","modal","showModalLoading","canReset","navigate","params","openForgottenPassword","dismiss","formatProfileFieldsForSignup","profileFields","categories","forEach","field","signup","categoryid","id","name","categoryname","fields","push","Object","keys","map","index","Number","getDisabledFeatures","config","disabledFeatures","tool_mobile_disabledfeatures","treatDisabledFeatures","getErrorMessages","requiredMsg","emailMsg","patternMsg","urlMsg","minlengthMsg","maxlengthMsg","minMsg","maxMsg","errors","required","requiredTrue","instant","email","pattern","url","minlength","maxlength","min","max","getLogoUrl","CONFIG","forceLoginLogo","logourl","compactlogourl","undefined","getLogoutLabel","_site","getStoredConfig","tool_mobile_forcelogout","getOAuthIdFromParams","oauthsso","getSitePolicy","sitePolicy","getConfig","settings","callAjax","getURL","sitepolicy","getFixedSites","notStagingSites","sites","filter","staging","getAvailableSites","hasEnabledStagingSites","demoMode","getDemoModeSiteInfo","find","getValidIdentityProviders","isFeatureDisabled","validProviders","httpUrl","concatenatePaths","wwwroot","httpsUrl","httpswwwroot","identityproviders","provider","urlParams","extractUrlParams","indexOf","getValidIdentityProvidersForSite","ignoreErrors","getPublicConfig","goToAddSite","setRoot","showKeyboard","_this5","path","openAddSite","isLoggedIn","willReload","logoutForRedirect","NO_SITE_ID","redirectPath","redirectOptions","getAddSiteRouteInfo","reset","_this6","demoModeSite","handleSSOLoginAuthentication","token","privateToken","oauthId","newSite","hasSeveralFixedSites","_this7","isEmailSignupDisabled","feature","isFixedUrlSet","isSingleFixedSite","_this8","isForgottenPasswordDisabled","isSiteLoggedOut","trigger","SESSION_EXPIRED","getId","isSiteUrlAllowed","checkSiteFinder","_this9","sameDomainAndPath","multisitesdisplay","onlyallowlistedsites","findSites","replace","isSSOEmbeddedBrowser","code","EMBEDDED","isSSOLoginNeeded","BROWSER","openBrowserForOAuthLogin","debug","loginUrl","prepareForSSOLogin","openInBrowser","showBrowserWarning","closeApp","clearsessioncache","closebuttoncaption","openChangePassword","alert","showAlert","onDidDismiss","openInAppForEdit","alertMessage","invalidateCache","_this10","getCurrentSiteId","waitingForBrowser","invalidateWsCache","openInAppWithAutoLogin","waitForBrowser","COMPLETE_REQUIRED_PROFILE_DATA_FINISHED","passwordChangeForced","_siteId","wsservice","passport","Math","random","customurlscheme","addParamsToUrl","set","LOGIN_LAUNCH_DATA","JSON","stringify","_objectSpread","ssoUrlParams","sessionExpired","data","_this11","urlToOpen","info","getInfo","showErrorModalDefault","shouldShowSSOConfirm","shouldSkipCredentialsScreenOnSSO","String","skipssoconfirmation","showInvalidLoginModal","_error$errorDetails","showErrorModal","errorDetails","message","showWorkplaceNoticeModal","link","getAppStoreUrl","android","ios","showDownloadAppNoticeModal","showMoodleAppNoticeModal","storesConfig","appstores","mobile","default","showNotConfirmedModal","password","_this12","title","canResend","$a","canResendEmail","okText","cancelText","showConfirm","preSets","_result$warnings2","sitePolicyNotAgreed","treatUserTokenError","_CoreTextUtils$getErr","_CoreTextUtils$getErr2","_CoreTextUtils$getErr3","getErrorMessageFromError","validateBrowserSSOLogin","_this13","split","serializedData","get","parseJSON","launchSiteURL","delete","signature","hashAsciiStr","isWaitingForBrowser","_this14","stopWaitingForBrowser","_this$waitingForBrows","resolve","displayQRInSiteScreen","canScanQR","displayqronsitescreen","displayQRInCredentialsScreen","qrCodeType","QR_CODE_LOGIN","_this15","displayqroncredentialscreen","showScanQRInstructions","dontShowWarning","$image","header","dontShowAgain","showPrompt","_unused","scanQR","text","isCustomURL","handleCustomURL","treatHandleCustomURLError","scheme","getUrlProtocol","getAccountsList","getSortedSites","accountsList","sameSite","otherSites","count","currentSiteId","_sites$find$siteUrlWi","_sites$find","siteUrlWithoutProtocol","Promise","all","_ref","badge","getSiteCounter","_x","apply","arguments","objectToArray","deleteAccountFromList","deleteSite","findIndex","listedSite","splice","otherSiteIndex","getReconnectRouteModule","then","m","CoreLoginReconnectLazyModule","getCredentialsRouteModule","CoreLoginCredentialsLazyModule","getLoginMethods","getDefaultLoginMethod","passwordResetRequested","_this16","passwordResets","getPasswordResets","Date","now","PASSWORD_RESETS_CONFIG_KEY","wasPasswordResetRequestedRecently","_this17","MILLISECONDS_HOUR","_this18","siteUrls","values","buildExceededAttemptsHTML","canContactSupport","canRecoverPassword","safeHTML","html","_DomSanitizer$sanitiz","sanitize","HTML","recoverPasswordHTML","messageKey","placeholder","recoverPassword","bypassSecurityTrustHtml","passwordResetsJson","_class","factory","ɵfac","providedIn","CoreLoginHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/login/services/login-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, SecurityContext } from '@angular/core';\nimport { Params } from '@angular/router';\nimport { Md5 } from 'ts-md5/dist/md5';\n\nimport { CoreApp, CoreStoreConfig } from '@services/app';\nimport { CoreConfig } from '@services/config';\nimport { CoreEvents, CoreEventSessionExpiredData, CoreEventSiteData } from '@singletons/events';\nimport { CoreSites, CoreLoginSiteInfo, CoreSiteBasicInfo } from '@services/sites';\nimport { CoreWS, CoreWSExternalWarning } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUrlParams, CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { DomSanitizer, makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreNavigator, CoreRedirectPayload } from '@services/navigator';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreCustomURLSchemes } from '@services/urlschemes';\nimport { CorePushNotifications } from '@features/pushnotifications/services/pushnotifications';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { SafeHtml } from '@angular/platform-browser';\nimport { CoreLoginError } from '@classes/errors/loginerror';\nimport { CoreSettingsHelper } from '@features/settings/services/settings-helper';\nimport {\n    CoreSiteIdentityProvider,\n    CoreSitePublicConfigResponse,\n    CoreSiteQRCodeType,\n    CoreUnauthenticatedSite,\n    TypeOfLogin,\n} from '@classes/sites/unauthenticated-site';\nimport {\n    EMAIL_SIGNUP_FEATURE_NAME,\n    FAQ_QRCODE_IMAGE_HTML,\n    FAQ_QRCODE_INFO_DONE,\n    FORGOTTEN_PASSWORD_FEATURE_NAME,\n    IDENTITY_PROVIDERS_FEATURE_NAME,\n    IDENTITY_PROVIDER_FEATURE_NAME_PREFIX,\n} from '../constants';\nimport { LazyRoutesModule } from '@/app/app-routing.module';\n\n/**\n * Helper provider that provides some common features regarding authentication.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreLoginHelperProvider {\n\n    protected static readonly PASSWORD_RESETS_CONFIG_KEY = 'password-resets';\n\n    protected logger: CoreLogger;\n    protected sessionExpiredCheckingSite: Record<string, boolean> = {};\n    protected isOpenEditAlertShown = false;\n    protected waitingForBrowser?: CorePromisedValue<void>;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreLoginHelper');\n    }\n\n    /**\n     * Initialize service.\n     */\n    async initialize(): Promise<void> {\n        this.cleanUpPasswordResets();\n    }\n\n    /**\n     * Accept site policy.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected if failure.\n     */\n    async acceptSitePolicy(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const result = await site.write<AgreeSitePolicyResult>('core_user_agree_site_policy', {});\n\n        if (result.status) {\n            return;\n        }\n\n        if (!result.warnings?.length) {\n            throw new CoreError('Cannot agree site policy');\n        }\n\n        // Check if there is a warning 'alreadyagreed'.\n        const found = result.warnings.some((warning) => warning.warningcode === 'alreadyagreed');\n        if (found) {\n            // Policy already agreed, treat it as a success.\n            return;\n        }\n\n        // Another warning, reject.\n        throw new CoreWSError(result.warnings[0]);\n\n    }\n\n    /**\n     * Check if a site allows requesting a password reset through the app.\n     *\n     * @param siteUrl URL of the site.\n     * @returns Promise resolved with boolean: whether can be done through the app.\n     */\n    async canRequestPasswordReset(siteUrl: string): Promise<boolean> {\n        try {\n            await this.requestPasswordReset(siteUrl);\n\n            return true;\n        } catch (error) {\n            return error.available == 1 || (error.errorcode && error.errorcode != 'invalidrecord');\n        }\n    }\n\n    /**\n     * Function called when an SSO InAppBrowser is closed or the app is resumed. Check if user needs to be logged out.\n     */\n    checkLogout(): void {\n        const currentSite = CoreSites.getCurrentSite();\n\n        if (\n            !CoreApp.isSSOAuthenticationOngoing() &&\n            currentSite?.isLoggedOut() &&\n            CoreNavigator.isCurrent('/login/reconnect')\n        ) {\n            // User must reauthenticate but he closed the InAppBrowser without doing so, logout him.\n            CoreSites.logout();\n        }\n    }\n\n    /**\n     * Open a browser to perform SSO login.\n     *\n     * @param siteUrl URL of the site where the SSO login will be performed.\n     * @param typeOfLogin TypeOfLogin.BROWSER or TypeOfLogin.EMBEDDED.\n     * @param service The service to use. If not defined, core service will be used.\n     * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n     * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n     * @returns Promise resolved when done or if user cancelled.\n     * @deprecated since 4.3. Use openBrowserForSSOLogin instead.\n     */\n    async confirmAndOpenBrowserForSSOLogin(\n        siteUrl: string,\n        typeOfLogin: TypeOfLogin,\n        service?: string,\n        launchUrl?: string,\n        redirectData?: CoreRedirectPayload,\n    ): Promise<void> {\n        this.openBrowserForSSOLogin(siteUrl, typeOfLogin, service, launchUrl, redirectData);\n    }\n\n    /**\n     * Helper function to act when the forgotten password is clicked.\n     *\n     * @param siteUrl Site URL.\n     * @param username Username.\n     * @param siteConfig Site config.\n     */\n    async forgottenPasswordClicked(siteUrl: string, username: string, siteConfig?: CoreSitePublicConfigResponse): Promise<void> {\n        if (siteConfig && siteConfig.forgottenpasswordurl) {\n            // URL set, open it.\n            CoreUtils.openInApp(siteConfig.forgottenpasswordurl);\n\n            return;\n        }\n\n        // Check if password reset can be done through the app.\n        const modal = await CoreDomUtils.showModalLoading();\n\n        try {\n            const canReset = await this.canRequestPasswordReset(siteUrl);\n\n            if (canReset) {\n                await CoreNavigator.navigate('/login/forgottenpassword', {\n                    params: {\n                        siteUrl,\n                        siteConfig,\n                        username,\n                    },\n                });\n            } else {\n                this.openForgottenPassword(siteUrl);\n            }\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Format profile fields, filtering the ones that shouldn't be shown on signup and classifying them in categories.\n     *\n     * @param profileFields Profile fields to format.\n     * @returns Categories with the fields to show in each one.\n     */\n    formatProfileFieldsForSignup(profileFields?: AuthEmailSignupProfileField[]): AuthEmailSignupProfileFieldsCategory[] {\n        if (!profileFields) {\n            return [];\n        }\n\n        const categories: Record<number, AuthEmailSignupProfileFieldsCategory> = {};\n\n        profileFields.forEach((field) => {\n            if (!field.signup || !field.categoryid) {\n                // Not a signup field, ignore it.\n                return;\n            }\n\n            if (!categories[field.categoryid]) {\n                categories[field.categoryid] = {\n                    id: field.categoryid,\n                    name: field.categoryname || '',\n                    fields: [],\n                };\n            }\n\n            categories[field.categoryid].fields.push(field);\n        });\n\n        return Object.keys(categories).map((index) => categories[Number(index)]);\n    }\n\n    /**\n     * Get disabled features from a site public config.\n     *\n     * @param config Site public config.\n     * @returns Disabled features.\n     * @deprecated since 4.4. No longer needed.\n     */\n    getDisabledFeatures(config?: CoreSitePublicConfigResponse): string {\n        const disabledFeatures = config?.tool_mobile_disabledfeatures;\n        if (!disabledFeatures) {\n            return '';\n        }\n\n        return CoreTextUtils.treatDisabledFeatures(disabledFeatures);\n    }\n\n    /**\n     * Builds an object with error messages for some common errors.\n     * Please notice that this function doesn't support all possible error types.\n     *\n     * @param requiredMsg Code of the string for required error.\n     * @param emailMsg Code of the string for invalid email error.\n     * @param patternMsg Code of the string for pattern not match error.\n     * @param urlMsg Code of the string for invalid url error.\n     * @param minlengthMsg Code of the string for \"too short\" error.\n     * @param maxlengthMsg Code of the string for \"too long\" error.\n     * @param minMsg Code of the string for min value error.\n     * @param maxMsg Code of the string for max value error.\n     * @returns Object with the errors.\n     */\n    getErrorMessages(\n        requiredMsg?: string,\n        emailMsg?: string,\n        patternMsg?: string,\n        urlMsg?: string,\n        minlengthMsg?: string,\n        maxlengthMsg?: string,\n        minMsg?: string,\n        maxMsg?: string,\n    ): Record<string, string> {\n        const errors: Record<string, string> = {};\n\n        if (requiredMsg) {\n            errors.required = errors.requiredTrue = Translate.instant(requiredMsg);\n        }\n        if (emailMsg) {\n            errors.email = Translate.instant(emailMsg);\n        }\n        if (patternMsg) {\n            errors.pattern = Translate.instant(patternMsg);\n        }\n        if (urlMsg) {\n            errors.url = Translate.instant(urlMsg);\n        }\n        if (minlengthMsg) {\n            errors.minlength = Translate.instant(minlengthMsg);\n        }\n        if (maxlengthMsg) {\n            errors.maxlength = Translate.instant(maxlengthMsg);\n        }\n        if (minMsg) {\n            errors.min = Translate.instant(minMsg);\n        }\n        if (maxMsg) {\n            errors.max = Translate.instant(maxMsg);\n        }\n\n        return errors;\n    }\n\n    /**\n     * Get logo URL from a site public config.\n     *\n     * @param config Site public config.\n     * @returns Logo URL.\n     * @deprecated since 4.4. Please use getLogoUrl in a site instance.\n     */\n    getLogoUrl(config: CoreSitePublicConfigResponse): string | undefined {\n        return !CoreConstants.CONFIG.forceLoginLogo && config ? (config.logourl || config.compactlogourl) : undefined;\n    }\n\n    /**\n     * Returns the logout label of a site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns The string key.\n     */\n    getLogoutLabel(site?: CoreSite): string {\n        site = site || CoreSites.getCurrentSite();\n        const config = site?.getStoredConfig();\n\n        return 'core.mainmenu.' + (config && config.tool_mobile_forcelogout == '1' ? 'logout' : 'switchaccount');\n    }\n\n    /**\n     * Get the OAuth ID of some URL params (if it has an OAuth ID).\n     *\n     * @param params Params.\n     * @returns OAuth ID.\n     */\n    getOAuthIdFromParams(params?: CoreUrlParams): number | undefined {\n        return params && params.oauthsso !== undefined ? Number(params.oauthsso) : undefined;\n    }\n\n    /**\n     * Get the site policy.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the site policy.\n     */\n    async getSitePolicy(siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n\n        let sitePolicy: string | undefined;\n\n        try {\n            // Try to get the latest config, maybe the site policy was just added or has changed.\n            sitePolicy = await site.getConfig('sitepolicy', true);\n        } catch (error) {\n            // Cannot get config, try to get the site policy using auth_email_get_signup_settings.\n            const settings = <AuthEmailSignupSettings> await CoreWS.callAjax(\n                'auth_email_get_signup_settings',\n                {},\n                { siteUrl: site.getURL() },\n            );\n\n            sitePolicy = settings.sitepolicy;\n        }\n\n        if (!sitePolicy) {\n            throw new CoreError('Cannot retrieve site policy');\n        }\n\n        return sitePolicy;\n    }\n\n    /**\n     * Get fixed site or sites.\n     *\n     * @returns Fixed site or list of fixed sites.\n     * @deprecated since 4.2. Use CoreConstants.CONFIG.sites or getAvailableSites() instead.\n     */\n    getFixedSites(): string | CoreLoginSiteInfo[] {\n        const notStagingSites = CoreConstants.CONFIG.sites.filter(site => !site.staging);\n\n        return notStagingSites.length === 1 ? notStagingSites[0].url : notStagingSites;\n    }\n\n    /**\n     * Get Available sites (includes staging sites if are enabled). It doesn't include demo mode site.\n     *\n     * @returns Available sites.\n     */\n    async getAvailableSites(): Promise<CoreLoginSiteInfo[]> {\n        const hasEnabledStagingSites = await CoreSettingsHelper.hasEnabledStagingSites();\n\n        return CoreConstants.CONFIG.sites.filter(site => (!site.staging || hasEnabledStagingSites) && !site.demoMode);\n    }\n\n    /**\n     * Get demo mode site info. This function doesn't check if demo mode is enabled.\n     *\n     * @returns Demo mode site info, undefined if no demo mode site.\n     */\n    getDemoModeSiteInfo(): CoreLoginSiteInfo | undefined {\n        return CoreConstants.CONFIG.sites.find(site => site.demoMode);\n    }\n\n    /**\n     * Get the valid identity providers from a site config.\n     *\n     * @param siteConfig Site's public config.\n     * @returns Valid identity providers.\n     * @deprecated since 4.4. Please use getValidIdentityProvidersForSite instead.\n     */\n    getValidIdentityProviders(siteConfig?: CoreSitePublicConfigResponse): CoreSiteIdentityProvider[] {\n        if (!siteConfig) {\n            return [];\n        }\n        // eslint-disable-next-line deprecation/deprecation\n        if (this.isFeatureDisabled(IDENTITY_PROVIDERS_FEATURE_NAME, siteConfig)) {\n            // Identity providers are disabled, return an empty list.\n            return [];\n        }\n\n        const validProviders: CoreSiteIdentityProvider[] = [];\n        const httpUrl = CorePath.concatenatePaths(siteConfig.wwwroot, 'auth/oauth2/');\n        const httpsUrl = CorePath.concatenatePaths(siteConfig.httpswwwroot, 'auth/oauth2/');\n\n        if (siteConfig.identityproviders && siteConfig.identityproviders.length) {\n            siteConfig.identityproviders.forEach((provider) => {\n                const urlParams = CoreUrlUtils.extractUrlParams(provider.url);\n\n                if (\n                    provider.url &&\n                    (provider.url.indexOf(httpsUrl) != -1 || provider.url.indexOf(httpUrl) != -1) &&\n                    !this.isFeatureDisabled( // eslint-disable-line deprecation/deprecation\n                        IDENTITY_PROVIDER_FEATURE_NAME_PREFIX + urlParams.id,\n                        siteConfig,\n                    )\n                ) {\n                    validProviders.push(provider);\n                }\n            });\n        }\n\n        return validProviders;\n    }\n\n    /**\n     * Get the valid identity providers from a site config.\n     *\n     * @param site Site instance.\n     * @returns Valid identity providers.\n     */\n    async getValidIdentityProvidersForSite(site: CoreUnauthenticatedSite): Promise<CoreSiteIdentityProvider[]> {\n        const siteConfig = await CoreUtils.ignoreErrors(site.getPublicConfig());\n        if (!siteConfig) {\n            return [];\n        }\n\n        if (site.isFeatureDisabled(IDENTITY_PROVIDERS_FEATURE_NAME)) {\n            // Identity providers are disabled, return an empty list.\n            return [];\n        }\n\n        const validProviders: CoreSiteIdentityProvider[] = [];\n        const httpUrl = CorePath.concatenatePaths(siteConfig.wwwroot, 'auth/oauth2/');\n        const httpsUrl = CorePath.concatenatePaths(siteConfig.httpswwwroot, 'auth/oauth2/');\n\n        if (siteConfig.identityproviders && siteConfig.identityproviders.length) {\n            siteConfig.identityproviders.forEach((provider) => {\n                const urlParams = CoreUrlUtils.extractUrlParams(provider.url);\n\n                if (provider.url && (provider.url.indexOf(httpsUrl) != -1 || provider.url.indexOf(httpUrl) != -1) &&\n                        !site.isFeatureDisabled(IDENTITY_PROVIDER_FEATURE_NAME_PREFIX + urlParams.id)) {\n                    validProviders.push(provider);\n                }\n            });\n        }\n\n        return validProviders;\n    }\n\n    /**\n     * Go to the page to add a new site.\n     * If a fixed URL is configured, go to credentials instead.\n     *\n     * @param setRoot True to set the new page as root, false to add it to the stack.\n     * @param showKeyboard Whether to show keyboard in the new page. Only if no fixed URL set.\n     * @returns Promise resolved when done.\n     */\n    async goToAddSite(setRoot = false, showKeyboard = false): Promise<void> {\n        let path = '/login/sites';\n        let params: Params = { openAddSite: true , showKeyboard };\n\n        if (CoreSites.isLoggedIn()) {\n            const willReload = await CoreSites.logoutForRedirect(CoreConstants.NO_SITE_ID, {\n                redirectPath: path,\n                redirectOptions: { params },\n            });\n\n            if (willReload) {\n                return;\n            }\n        } else {\n            [path, params] = await this.getAddSiteRouteInfo(showKeyboard);\n        }\n\n        await CoreNavigator.navigate(path, { params, reset: setRoot });\n    }\n\n    /**\n     * Get path and params to visit the route to add site.\n     *\n     * @param showKeyboard Whether to show keyboard in the new page. Only if no fixed URL set.\n     * @returns Path and params.\n     */\n    async getAddSiteRouteInfo(showKeyboard?: boolean): Promise<[string, Params]> {\n        if (CoreConstants.CONFIG.demoMode) {\n            const demoModeSite = this.getDemoModeSiteInfo();\n\n            if (demoModeSite) {\n                return ['/login/credentials', { siteUrl: demoModeSite.url }];\n            }\n        }\n\n        const sites = await this.getAvailableSites();\n\n        if (sites.length === 1) {\n            // Fixed URL is set, go to credentials page.\n            return ['/login/credentials', { siteUrl: sites[0].url }];\n        }\n\n        return ['/login/site', { showKeyboard }];\n    }\n\n    /**\n     * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,\n     * the site is stored and the user is authenticated. If the account already exists, update its token.\n     *\n     * @param siteUrl Site's URL.\n     * @param token User's token.\n     * @param privateToken User's private token.\n     * @param oauthId OAuth ID. Only if the authentication was using an OAuth method.\n     * @returns Promise resolved when the user is authenticated with the token.\n     */\n    handleSSOLoginAuthentication(siteUrl: string, token: string, privateToken?: string, oauthId?: number): Promise<string> {\n        // Always create a new site to prevent overriding data if another user credentials were introduced.\n        return CoreSites.newSite(siteUrl, token, privateToken, true, oauthId);\n    }\n\n    /**\n     * Check if the app is configured to use several fixed URLs.\n     *\n     * @returns Whether there are several fixed URLs.\n     * @deprecated since 4.2. Use CoreConstants.CONFIG.sites.length > 1 instead.\n     */\n    async hasSeveralFixedSites(): Promise<boolean> {\n        const sites = await this.getAvailableSites();\n\n        return sites.length > 1;\n    }\n\n    /**\n     * Given a site public config, check if email signup is disabled.\n     *\n     * @param config Site public config.\n     * @returns Whether email signup is disabled.\n     * @deprecated since 4.4. Please use isFeatureDisabled in a site instance.\n     */\n    isEmailSignupDisabled(config?: CoreSitePublicConfigResponse): boolean {\n        // eslint-disable-next-line deprecation/deprecation\n        return this.isFeatureDisabled(EMAIL_SIGNUP_FEATURE_NAME, config);\n    }\n\n    /**\n     * Given a site public config, check if a certian feature is disabled.\n     *\n     * @param feature Feature to check.\n     * @param config Site public config.\n     * @returns Whether email signup is disabled.\n     * @deprecated since 4.4. Please use isFeatureDisabled in a site instance.\n     */\n    isFeatureDisabled(feature: string, config?: CoreSitePublicConfigResponse): boolean {\n        // eslint-disable-next-line deprecation/deprecation\n        return this.isFeatureDisabled(feature, config);\n    }\n\n    /**\n     * Check if the app is configured to use a fixed URL (only 1).\n     *\n     * @returns Whether there is 1 fixed URL.\n     * @deprecated since 4.2. Use isSingleFixedSite instead.\n     */\n    isFixedUrlSet(): boolean {\n        return CoreConstants.CONFIG.sites.filter(site => !site.staging).length === 1;\n    }\n\n    /**\n     * Check if the app is configured to use a fixed URL (only 1).\n     *\n     * @returns Whether there is 1 fixed URL.\n     */\n    async isSingleFixedSite(): Promise<boolean> {\n        const sites = await this.getAvailableSites();\n\n        return sites.length === 1;\n    }\n\n    /**\n     * Given a site public config, check if forgotten password is disabled.\n     *\n     * @param config Site public config.\n     * @returns Whether it's disabled.\n     * @deprecated since 4.4. Please use isFeatureDisabled in a site instance.\n     */\n    isForgottenPasswordDisabled(config?: CoreSitePublicConfigResponse): boolean {\n        // eslint-disable-next-line deprecation/deprecation\n        return this.isFeatureDisabled(FORGOTTEN_PASSWORD_FEATURE_NAME, config);\n    }\n\n    /**\n     * Check if current site is logged out, triggering session expired event if it is.\n     *\n     * @param redirectData Data of the path/url to open once authenticated if logged out. If not defined, site initial page.\n     * @returns True if user is logged out, false otherwise.\n     */\n    isSiteLoggedOut(redirectData?: CoreRedirectPayload): boolean {\n        const site = CoreSites.getCurrentSite();\n        if (!site) {\n            return false;\n        }\n\n        if (site.isLoggedOut()) {\n            CoreEvents.trigger(CoreEvents.SESSION_EXPIRED, redirectData || {}, site.getId());\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if a site URL is \"allowed\". In case the app has fixed sites, only those will be allowed to connect to.\n     *\n     * @param siteUrl Site URL to check.\n     * @param checkSiteFinder Whether to check site finder if needed. Defaults to true.\n     * @returns Promise resolved with boolean: whether is one of the fixed sites.\n     */\n    async isSiteUrlAllowed(siteUrl: string, checkSiteFinder = true): Promise<boolean> {\n        const sites = await this.getAvailableSites();\n\n        if (sites.length) {\n            const demoModeSite = this.getDemoModeSiteInfo();\n\n            return sites.some((site) => CoreUrl.sameDomainAndPath(siteUrl, site.url)) ||\n                (!!demoModeSite && CoreUrl.sameDomainAndPath(siteUrl, demoModeSite.url));\n        } else if (CoreConstants.CONFIG.multisitesdisplay == 'sitefinder' && CoreConstants.CONFIG.onlyallowlistedsites &&\n                checkSiteFinder) {\n            // Call the sites finder to validate the site.\n            const result = await CoreSites.findSites(siteUrl.replace(/^https?:\\/\\/|\\.\\w{2,3}\\/?$/g, ''));\n\n            return result && result.some((site) => CoreUrl.sameDomainAndPath(siteUrl, site.url));\n        } else {\n            // No fixed sites or it uses a non-restrictive sites finder. Allow connecting.\n            return true;\n        }\n    }\n\n    /**\n     * Check if SSO login should use an embedded browser.\n     *\n     * @param code Code to check.\n     * @returns True if embedded browser, false othwerise.\n     */\n    isSSOEmbeddedBrowser(code: TypeOfLogin): boolean {\n        return code == TypeOfLogin.EMBEDDED;\n    }\n\n    /**\n     * Check if SSO login is needed based on code returned by the WS.\n     *\n     * @param code Code to check.\n     * @returns True if SSO login is needed, false othwerise.\n     */\n    isSSOLoginNeeded(code: TypeOfLogin): boolean {\n        return code == TypeOfLogin.BROWSER || code == TypeOfLogin.EMBEDDED;\n    }\n\n    /**\n     * Open a browser to perform OAuth login (Google, Facebook, Microsoft).\n     *\n     * @param siteUrl URL of the site where the login will be performed.\n     * @param provider The identity provider.\n     * @param launchUrl The URL to open for SSO. If not defined, tool/mobile launch URL will be used.\n     * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n     * @returns True if success, false if error.\n     */\n    openBrowserForOAuthLogin(\n        siteUrl: string,\n        provider: CoreSiteIdentityProvider,\n        launchUrl?: string,\n        redirectData?: CoreRedirectPayload,\n    ): boolean {\n        launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';\n\n        this.logger.debug('openBrowserForOAuthLogin launchUrl:', launchUrl);\n\n        if (!provider || !provider.url) {\n            return false;\n        }\n\n        const params = CoreUrlUtils.extractUrlParams(provider.url);\n\n        if (!params.id) {\n            return false;\n        }\n\n        const loginUrl = this.prepareForSSOLogin(siteUrl, undefined, launchUrl, redirectData, {\n            oauthsso: params.id,\n        });\n\n        // Always open it in browser because the user might have the session stored in there.\n        CoreUtils.openInBrowser(loginUrl, { showBrowserWarning: false });\n        CoreApp.closeApp();\n\n        return true;\n    }\n\n    /**\n     * Open a browser to perform SSO login.\n     *\n     * @param siteUrl URL of the site where the SSO login will be performed.\n     * @param typeOfLogin TypeOfLogin.BROWSER or TypeOfLogin.EMBEDDED.\n     * @param service The service to use. If not defined, core service will be used.\n     * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n     * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n     */\n    openBrowserForSSOLogin(\n        siteUrl: string,\n        typeOfLogin: TypeOfLogin,\n        service?: string,\n        launchUrl?: string,\n        redirectData?: CoreRedirectPayload,\n    ): void {\n        const loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, redirectData);\n\n        this.logger.debug('openBrowserForSSOLogin loginUrl:', loginUrl);\n\n        if (this.isSSOEmbeddedBrowser(typeOfLogin)) {\n            CoreUtils.openInApp(loginUrl, {\n                clearsessioncache: 'yes', // Clear the session cache to allow for multiple logins.\n                closebuttoncaption: Translate.instant('core.login.cancel'),\n            });\n        } else {\n            CoreUtils.openInBrowser(loginUrl, { showBrowserWarning: false });\n            CoreApp.closeApp();\n        }\n    }\n\n    /**\n     * Convenient helper to open change password page.\n     *\n     * @param siteUrl Site URL to construct change password URL.\n     * @param error Error message.\n     * @returns Promise resolved when done.\n     */\n    async openChangePassword(siteUrl: string, error: string): Promise<void> {\n        const alert = await CoreDomUtils.showAlert(Translate.instant('core.notice'), error, undefined, 3000);\n\n        await alert.onDidDismiss();\n\n        CoreUtils.openInApp(siteUrl + '/login/change_password.php');\n    }\n\n    /**\n     * Open forgotten password in inappbrowser.\n     *\n     * @param siteUrl URL of the site.\n     */\n    openForgottenPassword(siteUrl: string): void {\n        CoreUtils.openInApp(siteUrl + '/login/forgot_password.php');\n    }\n\n    /**\n     * Function to open in app browser to change password or complete user profile.\n     *\n     * @param siteId The site ID.\n     * @param path The relative path of the URL to open.\n     * @param alertMessage The key of the message to display before opening the in app browser.\n     * @param invalidateCache Whether to invalidate site's cache (e.g. when the user is forced to change password).\n     * @returns Promise resolved when done.\n     */\n    async openInAppForEdit(siteId: string, path: string, alertMessage?: string, invalidateCache?: boolean): Promise<void> {\n        if (!siteId || siteId !== CoreSites.getCurrentSiteId()) {\n            // Site that triggered the event is not current site, nothing to do.\n            return;\n        }\n\n        const currentSite = CoreSites.getCurrentSite();\n        const siteUrl = currentSite?.getURL();\n\n        if (!currentSite || !siteUrl) {\n            return;\n        }\n\n        if (!this.isOpenEditAlertShown && !this.waitingForBrowser) {\n            this.isOpenEditAlertShown = true;\n\n            if (invalidateCache) {\n                currentSite.invalidateWsCache();\n            }\n\n            // Open change password.\n            if (alertMessage) {\n                alertMessage = Translate.instant(alertMessage) + '<br>' +\n                    Translate.instant('core.redirectingtosite');\n            }\n\n            try {\n                await currentSite.openInAppWithAutoLogin(siteUrl + path, undefined, alertMessage);\n            } finally {\n                this.isOpenEditAlertShown = false;\n            }\n\n            await this.waitForBrowser();\n\n            CoreEvents.trigger(CoreEvents.COMPLETE_REQUIRED_PROFILE_DATA_FINISHED, {\n                path,\n            }, siteId);\n        }\n    }\n\n    /**\n     * Function that should be called when password change is forced. Reserved for core use.\n     *\n     * @param siteId The site ID. Undefined for current site.\n     */\n    async passwordChangeForced(siteId?: string): Promise<void> {\n        const currentSite = CoreSites.getCurrentSite();\n        siteId = siteId ?? currentSite?.getId();\n\n        if (!currentSite || siteId !== currentSite.getId()) {\n            return; // Site that triggered the event is not current site.\n        }\n\n        // If current page is already change password, stop.\n        if (CoreNavigator.isCurrent('/login/changepassword')) {\n            return;\n        }\n\n        await CoreNavigator.navigate('/login/changepassword', { params: { siteId }, reset: true });\n    }\n\n    /**\n     * Prepare the app to perform SSO login.\n     *\n     * @param siteUrl URL of the site where the SSO login will be performed.\n     * @param service The service to use. If not defined, core service will be used.\n     * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n     * @param redirectData Redirect dataof the page to go once authenticated. If not defined, site initial page.\n     * @param urlParams Other params to add to the URL.\n     * @returns Login Url.\n     */\n    prepareForSSOLogin(\n        siteUrl: string,\n        service?: string,\n        launchUrl?: string,\n        redirectData: CoreRedirectPayload = {},\n        urlParams?: CoreUrlParams,\n    ): string {\n\n        service = service || CoreConstants.CONFIG.wsservice;\n        launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';\n\n        const passport = Math.random() * 1000;\n        let loginUrl = launchUrl + '?service=' + service;\n\n        loginUrl += '&passport=' + passport;\n        loginUrl += '&urlscheme=' + CoreConstants.CONFIG.customurlscheme;\n\n        if (urlParams) {\n            loginUrl = CoreUrlUtils.addParamsToUrl(loginUrl, urlParams);\n        }\n\n        // Store the siteurl and passport in CoreConfigProvider for persistence.\n        // We are \"configuring\" the app to wait for an SSO. CoreConfigProvider shouldn't be used as a temporary storage.\n        CoreConfig.set(CoreConstants.LOGIN_LAUNCH_DATA, JSON.stringify(<StoredLoginLaunchData> {\n            siteUrl: siteUrl,\n            passport: passport,\n            ...redirectData,\n            ssoUrlParams: urlParams || {},\n        }));\n\n        return loginUrl;\n    }\n\n    /**\n     * Request a password reset.\n     *\n     * @param siteUrl URL of the site.\n     * @param username Username to search.\n     * @param email Email to search.\n     * @returns Promise resolved when done.\n     */\n    requestPasswordReset(siteUrl: string, username?: string, email?: string): Promise<CoreLoginRequestPasswordResetResult> {\n        const params: Record<string, string> = {};\n\n        if (username) {\n            params.username = username;\n        }\n\n        if (email) {\n            params.email = email;\n        }\n\n        return CoreWS.callAjax('core_auth_request_password_reset', params, { siteUrl });\n    }\n\n    /**\n     * Function that should be called when the session expires. Reserved for core use.\n     *\n     * @param data Data received by the SESSION_EXPIRED event.\n     * @returns Promise resolved when done.\n     */\n    async sessionExpired(data: CoreEventSessionExpiredData & CoreEventSiteData): Promise<void> {\n        const siteId = data?.siteId;\n        const currentSite = CoreSites.getCurrentSite();\n\n        if (!currentSite) {\n            return;\n        }\n\n        if (siteId && siteId !== currentSite.getId()) {\n            return; // Site that triggered the event is not current site.\n        }\n\n        if (this.sessionExpiredCheckingSite[siteId || '']) {\n            return; // Operation pending.\n        }\n\n        this.sessionExpiredCheckingSite[siteId || ''] = true;\n        const redirectData: CoreRedirectPayload = {\n            redirectPath: data.redirectPath,\n            redirectOptions: data.redirectOptions,\n            urlToOpen: data.urlToOpen,\n        };\n\n        try {\n            // Check authentication method.\n            const info = currentSite.getInfo();\n            if (info !== undefined && info.username !== undefined) {\n                // If current page is already reconnect, stop.\n                if (CoreNavigator.isCurrent('/login/reconnect')) {\n                    return;\n                }\n\n                await CoreUtils.ignoreErrors(CoreNavigator.navigate('/login/reconnect', {\n                    params: {\n                        siteId,\n                        ...redirectData,\n                    },\n                    reset: true,\n                }));\n            }\n        } catch (error) {\n            // Error checking site.\n            if (currentSite.isLoggedOut()) {\n                // Site is logged out, show error and logout the user.\n                CoreDomUtils.showErrorModalDefault(error, 'core.networkerrormsg', true);\n                CoreSites.logout();\n            }\n        } finally {\n            this.sessionExpiredCheckingSite[siteId || ''] = false;\n        }\n    }\n\n    /**\n     * Check if a confirm should be shown to open a SSO authentication.\n     *\n     * @param typeOfLogin TypeOfLogin.BROWSER or TypeOfLogin.EMBEDDED.\n     * @returns True if confirm modal should be shown, false otherwise.\n     * @deprecated since 4.3. Not used anymore. See shouldSkipCredentialsScreenOnSSO.\n     */\n    shouldShowSSOConfirm(typeOfLogin: TypeOfLogin): boolean {\n        return !this.isSSOEmbeddedBrowser(typeOfLogin) && !this.shouldSkipCredentialsScreenOnSSO();\n    }\n\n    /**\n     * Check if we can skip credentials page.\n     *\n     * @returns If true, the browser should be opened without the user prompt.\n     */\n    shouldSkipCredentialsScreenOnSSO(): boolean {\n        return String(CoreConstants.CONFIG.skipssoconfirmation) === 'true';\n    }\n\n    /**\n     * Show a modal warning that the credentials introduced were not correct.\n     */\n    protected showInvalidLoginModal(error: CoreLoginError): void {\n        CoreDomUtils.showErrorModal(error.errorDetails ?? error.message);\n    }\n\n    /**\n     * Show a modal warning the user that he should use the Workplace app.\n     *\n     * @param message The warning message.\n     */\n    protected showWorkplaceNoticeModal(message: string): void {\n        const link = CoreApp.getAppStoreUrl({ android: 'com.moodle.workplace', ios: 'id1470929705' });\n\n        CoreDomUtils.showDownloadAppNoticeModal(message, link);\n    }\n\n    /**\n     * Show a modal warning the user that he should use the current Moodle app.\n     *\n     * @param message The warning message.\n     */\n    protected showMoodleAppNoticeModal(message: string): void {\n        const storesConfig: CoreStoreConfig = CoreConstants.CONFIG.appstores;\n        storesConfig.mobile = 'https://download.moodle.org/mobile/';\n        storesConfig.default = 'https://download.moodle.org/mobile/';\n\n        const link = CoreApp.getAppStoreUrl(storesConfig);\n\n        CoreDomUtils.showDownloadAppNoticeModal(message, link);\n    }\n\n    /**\n     * Show a modal to inform the user that a confirmation email was sent, and a button to resend the email on 3.6+ sites.\n     *\n     * @param siteUrl Site URL.\n     * @param email Email of the user. If set displayed in the message.\n     * @param username Username. If not set the button to resend email will not be shown.\n     * @param password User password. If not set the button to resend email will not be shown.\n     */\n    protected async showNotConfirmedModal(siteUrl: string, email?: string, username?: string, password?: string): Promise<void> {\n        const title = Translate.instant('core.login.mustconfirm');\n        let message: string;\n        let canResend = false;\n        if (email) {\n            message = Translate.instant('core.login.emailconfirmsent', { $a: email });\n        } else {\n            message = Translate.instant('core.login.emailconfirmsentnoemail');\n        }\n\n        // Check whether we need to display the resend button or not.\n        if (username && password) {\n            canResend = await this.canResendEmail(siteUrl);\n        }\n\n        if (!canResend) {\n            // Just display an informative alert.\n            await CoreDomUtils.showAlert(title, message);\n\n            return;\n        }\n\n        const okText = Translate.instant('core.login.resendemail');\n        const cancelText = Translate.instant('core.close');\n\n        try {\n            // Ask the user if he wants to resend the email.\n            await CoreDomUtils.showConfirm(message, title, okText, cancelText);\n\n            // Call the WS to resend the confirmation email.\n            const modal = await CoreDomUtils.showModalLoading('core.sending', true);\n            const data = { username, password };\n            const preSets = { siteUrl };\n\n            try {\n                const result = <ResendConfirmationEmailResult> await CoreWS.callAjax(\n                    'core_auth_resend_confirmation_email',\n                    data,\n                    preSets,\n                );\n\n                if (!result.status) {\n                    if (result.warnings?.length) {\n                        throw new CoreWSError(result.warnings[0]);\n                    }\n\n                    throw new CoreError('Error sending confirmation email');\n                }\n\n                const message = Translate.instant('core.login.emailconfirmsentsuccess');\n                CoreDomUtils.showAlert(Translate.instant('core.success'), message);\n            } finally {\n                modal.dismiss();\n            }\n        } catch (error) {\n            CoreDomUtils.showErrorModal(error);\n        }\n    }\n\n    /**\n     * Check if confirmation email an be resent.\n     *\n     * @param siteUrl Site URL to check.\n     * @returns Promise.\n     */\n    protected async canResendEmail(siteUrl: string): Promise<boolean> {\n        const modal = await CoreDomUtils.showModalLoading();\n\n        // We don't have site info before login, the only way to check if the WS is available is by calling it.\n        try {\n            // This call will always fail because we aren't sending parameters.\n            await CoreWS.callAjax('core_auth_resend_confirmation_email', {}, { siteUrl });\n\n            return true; // We should never reach here.\n        } catch (error) {\n            // If the WS responds with an invalid parameter error it means the WS is avaiable.\n            return error?.errorcode === 'invalidparameter';\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Function called when site policy is not agreed. Reserved for core use.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     */\n    sitePolicyNotAgreed(siteId?: string): void {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n        if (!siteId || siteId != CoreSites.getCurrentSiteId()) {\n            // Only current site allowed.\n            return;\n        }\n\n        // If current page is already site policy, stop.\n        if (CoreNavigator.isCurrent('/login/sitepolicy')) {\n            return;\n        }\n\n        CoreNavigator.navigate('/login/sitepolicy', { params: { siteId }, reset: true });\n    }\n\n    /**\n     * Convenient helper to handle get User Token error. It redirects to change password page if forcepassword is set.\n     *\n     * @param siteUrl Site URL to construct change password URL.\n     * @param error Error object containing errorcode and error message.\n     * @param username Username.\n     * @param password User password.\n     */\n    treatUserTokenError(siteUrl: string, error: CoreWSError, username?: string, password?: string): void {\n        switch (error.errorcode) {\n            case 'forcepasswordchangenotice':\n                this.openChangePassword(siteUrl, CoreTextUtils.getErrorMessageFromError(error) ?? '');\n                break;\n            case 'usernotconfirmed':\n                this.showNotConfirmedModal(siteUrl, undefined, username, password);\n                break;\n            case 'connecttomoodleapp':\n                this.showMoodleAppNoticeModal(CoreTextUtils.getErrorMessageFromError(error) ?? '');\n                break;\n            case 'connecttoworkplaceapp':\n                this.showWorkplaceNoticeModal(CoreTextUtils.getErrorMessageFromError(error) ?? '');\n                break;\n            case 'invalidlogin':\n                this.showInvalidLoginModal(error);\n                break;\n            default:\n                CoreDomUtils.showErrorModal(error);\n                break;\n        }\n    }\n\n    /**\n     * Convenient helper to validate a browser SSO login.\n     *\n     * @param url URL received, to be validated.\n     * @returns Promise resolved on success.\n     */\n    async validateBrowserSSOLogin(url: string): Promise<CoreLoginSSOData> {\n        // Split signature:::token\n        const params = url.split(':::');\n\n        const serializedData = await CoreConfig.get<string>(CoreConstants.LOGIN_LAUNCH_DATA);\n\n        const data = <StoredLoginLaunchData | null> CoreTextUtils.parseJSON(serializedData, null);\n        if (data === null) {\n            throw new CoreError('No launch data stored.');\n        }\n\n        const passport = data.passport;\n        let launchSiteURL = data.siteUrl;\n\n        // Reset temporary values.\n        CoreConfig.delete(CoreConstants.LOGIN_LAUNCH_DATA);\n\n        // Validate the signature.\n        // We need to check both http and https.\n        let signature = <string> Md5.hashAsciiStr(launchSiteURL + passport);\n        if (signature != params[0]) {\n            if (launchSiteURL.indexOf('https://') != -1) {\n                launchSiteURL = launchSiteURL.replace('https://', 'http://');\n            } else {\n                launchSiteURL = launchSiteURL.replace('http://', 'https://');\n            }\n            signature = <string> Md5.hashAsciiStr(launchSiteURL + passport);\n        }\n\n        if (signature == params[0]) {\n            this.logger.debug('Signature validated');\n\n            return {\n                siteUrl: launchSiteURL,\n                token: params[1],\n                privateToken: params[2],\n                redirectPath: data.redirectPath,\n                redirectOptions: data.redirectOptions,\n                urlToOpen: data.urlToOpen,\n                ssoUrlParams: data.ssoUrlParams,\n            };\n        } else {\n            this.logger.debug('Invalid signature in the URL request yours: ' + params[0] + ' mine: '\n                + signature + ' for passport ' + passport);\n\n            throw new CoreError(Translate.instant('core.unexpectederror'));\n        }\n    }\n\n    /**\n     * Return whether the app is waiting for browser.\n     *\n     * @returns Whether the app is waiting for browser.\n     */\n    isWaitingForBrowser(): boolean {\n        return !!this.waitingForBrowser;\n    }\n\n    /**\n     * Start waiting when opening a browser/IAB.\n     *\n     * @returns Promise resolved when the app is resumed.\n     */\n    async waitForBrowser(): Promise<void> {\n        if (!this.waitingForBrowser) {\n            this.waitingForBrowser = new CorePromisedValue();\n        }\n\n        await this.waitingForBrowser;\n    }\n\n    /**\n     * Stop waiting for browser.\n     */\n    stopWaitingForBrowser(): void {\n        this.waitingForBrowser?.resolve();\n        this.waitingForBrowser = undefined;\n    }\n\n    /**\n     * Check whether the QR reader should be displayed in site screen.\n     *\n     * @returns Whether the QR reader should be displayed in site screen.\n     */\n    displayQRInSiteScreen(): boolean {\n        return CoreUtils.canScanQR() && (CoreConstants.CONFIG.displayqronsitescreen === undefined ||\n            !!CoreConstants.CONFIG.displayqronsitescreen);\n    }\n\n    /**\n     * Check whether the QR reader should be displayed in credentials screen.\n     *\n     * @param qrCodeType QR Code type from public config, assuming enabled if undefined.\n     * @returns Whether the QR reader should be displayed in credentials screen.\n     */\n    async displayQRInCredentialsScreen(qrCodeType = CoreSiteQRCodeType.QR_CODE_LOGIN): Promise<boolean> {\n        if (!CoreUtils.canScanQR()) {\n            return false;\n        }\n\n        const isSingleFixedSite = await this.isSingleFixedSite();\n\n        if ((CoreConstants.CONFIG.displayqroncredentialscreen === undefined && isSingleFixedSite) ||\n            (CoreConstants.CONFIG.displayqroncredentialscreen !== undefined &&\n                !!CoreConstants.CONFIG.displayqroncredentialscreen)) {\n\n            return qrCodeType == CoreSiteQRCodeType.QR_CODE_LOGIN;\n        }\n\n        return false;\n    }\n\n    /**\n     * Show instructions to scan QR code.\n     *\n     * @returns Promise resolved if the user accepts to scan QR.\n     */\n    async showScanQRInstructions(): Promise<void> {\n        const dontShowWarning = await CoreConfig.get(FAQ_QRCODE_INFO_DONE, 0);\n        if (dontShowWarning) {\n            return;\n        }\n\n        const message = Translate.instant(\n            'core.login.faqwhereisqrcodeanswer',\n            { $image: '<div class=\"text-center\">'+ FAQ_QRCODE_IMAGE_HTML + '</div>' },\n        );\n        const header = Translate.instant('core.login.faqwhereisqrcode');\n\n        try {\n            const dontShowAgain = await CoreDomUtils.showPrompt(\n                message,\n                header,\n                Translate.instant('core.dontshowagain'),\n                'checkbox',\n                { okText: Translate.instant('core.next'), cancelText: Translate.instant('core.cancel') },\n            );\n\n            if (dontShowAgain) {\n                CoreConfig.set(FAQ_QRCODE_INFO_DONE, 1);\n            }\n        } catch {\n            // User canceled.\n            throw new CoreCanceledError('');\n        }\n    }\n\n    /**\n     * Scan a QR code and tries to authenticate the user using custom URL scheme.\n     *\n     * @returns Promise resolved when done.\n     */\n    async scanQR(): Promise<void> {\n        // Scan for a QR code.\n        const text = await CoreUtils.scanQR();\n\n        if (text && CoreCustomURLSchemes.isCustomURL(text)) {\n            try {\n                await CoreCustomURLSchemes.handleCustomURL(text);\n            } catch (error) {\n                CoreCustomURLSchemes.treatHandleCustomURLError(error);\n            }\n        } else if (text) {\n            // Not a custom URL scheme, check if it's a URL scheme to another app.\n            const scheme = CoreUrlUtils.getUrlProtocol(text);\n\n            if (scheme && scheme != 'http' && scheme != 'https') {\n                CoreDomUtils.showErrorModal(Translate.instant('core.errorurlschemeinvalidscheme', { $a: text }));\n            } else {\n                CoreDomUtils.showErrorModal('core.login.errorqrnoscheme', true);\n            }\n        }\n    }\n\n    /**\n     * Get the accounts list classified per site.\n     *\n     * @returns Promise resolved with account list.\n     */\n    async getAccountsList(): Promise<CoreAccountsList> {\n        const sites = await CoreUtils.ignoreErrors(CoreSites.getSortedSites(), [] as CoreSiteBasicInfo[]);\n\n        const accountsList: CoreAccountsList = {\n            sameSite: [],\n            otherSites: [],\n            count: sites.length,\n        };\n        const currentSiteId = CoreSites.getCurrentSiteId();\n        let siteUrl = '';\n\n        if (currentSiteId) {\n            siteUrl = sites.find((site) => site.id == currentSiteId)?.siteUrlWithoutProtocol ?? '';\n        }\n\n        const otherSites: Record<string, CoreSiteBasicInfo[]> = {};\n\n        // Add site counter and classify sites.\n        await Promise.all(sites.map(async (site) => {\n            site.badge = await CoreUtils.ignoreErrors(CorePushNotifications.getSiteCounter(site.id)) || 0;\n\n            if (site.id === currentSiteId) {\n                accountsList.currentSite = site;\n            } else if (site.siteUrlWithoutProtocol == siteUrl) {\n                accountsList.sameSite.push(site);\n            } else {\n                if (!otherSites[site.siteUrlWithoutProtocol]) {\n                    otherSites[site.siteUrlWithoutProtocol] = [];\n                }\n\n                otherSites[site.siteUrlWithoutProtocol].push(site);\n            }\n\n            return;\n        }));\n\n        accountsList.otherSites = CoreUtils.objectToArray(otherSites);\n\n        return accountsList;\n    }\n\n    /**\n     * Find and delete a site from the list of sites.\n     *\n     * @param accountsList Account list.\n     * @param site Site to be deleted.\n     * @returns Resolved when done.\n     */\n    async deleteAccountFromList(accountsList: CoreAccountsList, site: CoreSiteBasicInfo): Promise<void> {\n        await CoreSites.deleteSite(site.id);\n\n        const siteUrl = site.siteUrlWithoutProtocol;\n        let index = 0;\n\n        // Found on same site.\n        if (accountsList.sameSite.length > 0 && accountsList.sameSite[0].siteUrlWithoutProtocol == siteUrl) {\n            index = accountsList.sameSite.findIndex((listedSite) => listedSite.id == site.id);\n            if (index >= 0) {\n                accountsList.sameSite.splice(index, 1);\n                accountsList.count--;\n            }\n\n            return;\n        }\n\n        const otherSiteIndex = accountsList.otherSites.findIndex((sites) =>\n            sites.length > 0 && sites[0].siteUrlWithoutProtocol == siteUrl);\n        if (otherSiteIndex < 0) {\n            // Site Url not found.\n            return;\n        }\n\n        index = accountsList.otherSites[otherSiteIndex].findIndex((listedSite) => listedSite.id == site.id);\n        if (index >= 0) {\n            accountsList.otherSites[otherSiteIndex].splice(index, 1);\n            accountsList.count--;\n        }\n\n        if (accountsList.otherSites[otherSiteIndex].length == 0) {\n            accountsList.otherSites.splice(otherSiteIndex, 1);\n        }\n    }\n\n    /**\n     * Get reconnect page route module.\n     *\n     * @returns Reconnect page route module.\n     */\n    async getReconnectRouteModule(): Promise<LazyRoutesModule> {\n        return import('@features/login/login-reconnect-lazy.module').then(m => m.CoreLoginReconnectLazyModule);\n    }\n\n    /**\n     * Get credentials page route module.\n     *\n     * @returns Credentials page route module.\n     */\n    async getCredentialsRouteModule(): Promise<LazyRoutesModule> {\n        return import('@features/login/login-credentials-lazy.module').then(m => m.CoreLoginCredentialsLazyModule);\n    }\n\n    /**\n     * Retrieve login methods.\n     *\n     * @returns Login methods found.\n     */\n    async getLoginMethods(): Promise<CoreLoginMethod[]> {\n        return [];\n    }\n\n    /**\n     * Retrieve default login method.\n     *\n     * @returns Default login method.\n     */\n    async getDefaultLoginMethod(): Promise<CoreLoginMethod | null> {\n        return null;\n    }\n\n    /**\n     * Record that a password reset has been requested for a given site.\n     *\n     * @param siteUrl Site url.\n     */\n    async passwordResetRequested(siteUrl: string): Promise<void> {\n        const passwordResets = await this.getPasswordResets();\n\n        passwordResets[siteUrl] = Date.now();\n\n        await CoreConfig.set(CoreLoginHelperProvider.PASSWORD_RESETS_CONFIG_KEY, JSON.stringify(passwordResets));\n    }\n\n    /**\n     * Find out if a password reset has been requested recently for a given site.\n     *\n     * @param siteUrl Site url.\n     * @returns Whether a password reset has been requested recently.\n     */\n    async wasPasswordResetRequestedRecently(siteUrl: string): Promise<boolean> {\n        const passwordResets = await this.getPasswordResets();\n\n        return siteUrl in passwordResets\n            && passwordResets[siteUrl] > Date.now() - CoreConstants.MILLISECONDS_HOUR;\n    }\n\n    /**\n     * Clean up expired password reset records from the database.\n     */\n    async cleanUpPasswordResets(): Promise<void> {\n        const passwordResets = await this.getPasswordResets();\n        const siteUrls = Object.keys(passwordResets);\n\n        for (const siteUrl of siteUrls) {\n            if (passwordResets[siteUrl] > Date.now() - CoreConstants.MILLISECONDS_HOUR) {\n                continue;\n            }\n\n            delete passwordResets[siteUrl];\n        }\n\n        if (Object.values(passwordResets).length === 0) {\n            await CoreConfig.delete(CoreLoginHelperProvider.PASSWORD_RESETS_CONFIG_KEY);\n        } else {\n            await CoreConfig.set(CoreLoginHelperProvider.PASSWORD_RESETS_CONFIG_KEY, JSON.stringify(passwordResets));\n        }\n    }\n\n    /**\n     * Build the HTML message to show once login attempts have been exceeded.\n     *\n     * @param canContactSupport Whether contacting support is enabled in the site.\n     * @param canRecoverPassword Whether recovering the password is enabled in the site.\n     * @returns HTML message.\n     */\n    buildExceededAttemptsHTML(canContactSupport: boolean, canRecoverPassword: boolean): SafeHtml | string | null {\n        const safeHTML = (html: string) => DomSanitizer.sanitize(SecurityContext.HTML, html) ?? '';\n        const recoverPasswordHTML = (messageKey: string) => {\n            const placeholder = '%%RECOVER_PASSWORD%%';\n            const message = safeHTML(Translate.instant(messageKey, { recoverPassword: placeholder }));\n            const recoverPassword = safeHTML(Translate.instant('core.login.exceededloginattemptsrecoverpassword'));\n\n            return DomSanitizer.bypassSecurityTrustHtml(\n                message.replace(placeholder, `<a href=\"#\" role=\"button\" style=\"color:inherit\">${recoverPassword}</a>`),\n            );\n        };\n\n        if (canContactSupport && canRecoverPassword) {\n            return recoverPasswordHTML('core.login.exceededloginattempts');\n        }\n\n        if (canContactSupport) {\n            return Translate.instant('core.login.exceededloginattemptswithoutpassword');\n        }\n\n        if (canRecoverPassword) {\n            return recoverPasswordHTML('core.login.exceededloginattemptswithoutsupport');\n        }\n\n        return null;\n    }\n\n    /**\n     * Get a record indexing the last time a password reset was requested for a site.\n     *\n     * @returns Password resets.\n     */\n    protected async getPasswordResets(): Promise<Record<string, number>> {\n        const passwordResetsJson = await CoreConfig.get(CoreLoginHelperProvider.PASSWORD_RESETS_CONFIG_KEY, '{}');\n\n        return CoreTextUtils.parseJSON<Record<string, number>>(passwordResetsJson, {});\n    }\n\n}\n\nexport const CoreLoginHelper = makeSingleton(CoreLoginHelperProvider);\n\n/**\n * Accounts list for selecting sites interfaces.\n */\nexport type CoreAccountsList<T extends CoreSiteBasicInfo = CoreSiteBasicInfo> = {\n    currentSite?: T; // If logged in, current site info.\n    sameSite: T[]; // If logged in, accounts info on the same site.\n    otherSites: T[][]; // Other accounts in other sites.\n    count: number; // Number of sites.\n};\n\n/**\n * Data related to a SSO authentication.\n */\nexport type CoreLoginSSOData = CoreRedirectPayload & {\n    siteUrl: string; // The site's URL.\n    token?: string; // User's token.\n    privateToken?: string; // User's private token.\n    ssoUrlParams?: CoreUrlParams; // Other params added to the login url.\n};\n\n/**\n * Result of WS core_user_agree_site_policy.\n */\ntype AgreeSitePolicyResult = {\n    status: boolean; // Status: true only if we set the policyagreed to 1 for the user.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result of WS auth_email_get_signup_settings.\n */\nexport type AuthEmailSignupSettings = {\n    namefields: string[];\n    passwordpolicy?: string; // Password policy.\n    sitepolicy?: string; // Site policy.\n    sitepolicyhandler?: string; // Site policy handler.\n    defaultcity?: string; // Default city.\n    country?: string; // Default country.\n    profilefields?: AuthEmailSignupProfileField[]; // Required profile fields.\n    recaptchapublickey?: string; // Recaptcha public key.\n    recaptchachallengehash?: string; // Recaptcha challenge hash.\n    recaptchachallengeimage?: string; // Recaptcha challenge noscript image.\n    recaptchachallengejs?: string; // Recaptcha challenge js url.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Profile field for signup.\n */\nexport type AuthEmailSignupProfileField = {\n    id?: number; // Profile field id.\n    shortname?: string; // Profile field shortname.\n    name?: string; // Profield field name.\n    datatype?: string; // Profield field datatype.\n    description?: string; // Profield field description.\n    descriptionformat: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    categoryid?: number; // Profield field category id.\n    categoryname?: string; // Profield field category name.\n    sortorder?: number; // Profield field sort order.\n    required?: number; // Profield field required.\n    locked?: number; // Profield field locked.\n    visible?: number; // Profield field visible.\n    forceunique?: number; // Profield field unique.\n    signup?: number; // Profield field in signup form.\n    defaultdata?: string; // Profield field default data.\n    defaultdataformat: number; // Defaultdata format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    param1?: string; // Profield field settings.\n    param2?: string; // Profield field settings.\n    param3?: string; // Profield field settings.\n    param4?: string; // Profield field settings.\n    param5?: string; // Profield field settings.\n};\n\n/**\n * Category of profile fields for signup.\n */\nexport type AuthEmailSignupProfileFieldsCategory = {\n    id: number; // Category ID.\n    name: string; // Category name.\n    fields: AuthEmailSignupProfileField[]; // Field in the category.\n};\n\n/**\n * Result of WS core_auth_request_password_reset.\n */\nexport type CoreLoginRequestPasswordResetResult = {\n    status: string; // The returned status of the process\n    notice: string; // Important information for the user about the process.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result of WS core_auth_resend_confirmation_email.\n */\ntype ResendConfirmationEmailResult = {\n    status: boolean; // True if the confirmation email was sent, false otherwise.\n    warnings?: CoreWSExternalWarning[];\n};\n\ntype StoredLoginLaunchData = CoreRedirectPayload & {\n    siteUrl: string;\n    passport: number;\n    ssoUrlParams: CoreUrlParams;\n};\n\nexport type CoreLoginSiteSelectorListMethod =\n    'url'|\n    'sitefinder'|\n    'list'|\n    '';\n\nexport type CoreLoginMethod = {\n    name: string; // Name of the login method.\n    icon: string; // Icon of the provider.\n    action: () => unknown; // Action to execute on button click.\n};\n\nexport type CoreLoginSiteFinderSettings = {\n    displayalias: boolean;\n    displaycity: boolean;\n    displaycountry: boolean;\n    displayimage: boolean;\n    displaysitename: boolean;\n    displayurl: boolean;\n    defaultimageurl?: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}