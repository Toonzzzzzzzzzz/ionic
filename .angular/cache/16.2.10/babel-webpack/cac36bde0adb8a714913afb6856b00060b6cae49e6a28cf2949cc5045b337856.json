{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonNotesOffline } from './notes-offline';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaNotes:';\n/**\n * Service to handle notes.\n */\nexport class AddonNotesProvider {\n  /**\n   * Add a note.\n   *\n   * @param userId User ID of the person to add the note.\n   * @param courseId Course ID where the note belongs.\n   * @param publishState Personal, Site or Course.\n   * @param noteText The note text.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: true if note was sent to server, false if stored in device.\n   */\n  addNote(userId, courseId, publishState, noteText, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Convenience function to store a note to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          yield AddonNotesOffline.saveNote(userId, courseId, publishState, noteText, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the note.\n        return storeOffline();\n      }\n      // Send note to server.\n      try {\n        yield _this.addNoteOnline(userId, courseId, publishState, noteText, siteId);\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, the user cannot send the message so don't store it.\n          throw error;\n        }\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Add a note. It will fail if offline or cannot connect.\n   *\n   * @param userId User ID of the person to add the note.\n   * @param courseId Course ID where the note belongs.\n   * @param publishState Personal, Site or Course.\n   * @param noteText The note text.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when added, rejected otherwise.\n   */\n  addNoteOnline(userId, courseId, publishState, noteText, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const notes = [{\n        courseid: courseId,\n        format: 1,\n        publishstate: publishState,\n        text: noteText,\n        userid: userId\n      }];\n      const response = yield _this2.addNotesOnline(notes, siteId);\n      if (response && response[0] && response[0].noteid === -1) {\n        // There was an error, and it should be translated already.\n        throw new CoreWSError({\n          message: response[0].errormessage\n        });\n      }\n      yield CoreUtils.ignoreErrors(_this2.invalidateNotes(courseId, undefined, siteId));\n    })();\n  }\n  /**\n   * Add several notes. It will fail if offline or cannot connect.\n   *\n   * @param notes Notes to save.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when added, rejected otherwise. Promise resolved doesn't mean that notes\n   *         have been added, the resolve param can contain errors for notes not sent.\n   */\n  addNotesOnline(notes, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!notes || !notes.length) {\n        return [];\n      }\n      const site = yield CoreSites.getSite(siteId);\n      const data = {\n        notes: notes\n      };\n      return site.write('core_notes_create_notes', data);\n    })();\n  }\n  /**\n   * Delete a note.\n   *\n   * @param note Note object to delete.\n   * @param courseId Course ID where the note belongs.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when deleted, rejected otherwise. Promise resolved doesn't mean that notes\n   *         have been deleted, the resolve param can contain errors for notes not deleted.\n   */\n  deleteNote(note, courseId, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (note.offline) {\n        yield AddonNotesOffline.deleteOfflineNote(note.userid, note.content, note.created, siteId);\n        return true;\n      }\n      // Convenience function to store the action to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          yield AddonNotesOffline.deleteNote(note.id, courseId, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the note.\n        return storeOffline();\n      }\n      // Send note to server.\n      try {\n        yield _this3.deleteNotesOnline([note.id], courseId, siteId);\n        return true;\n      } catch (error) {\n        if (CoreUtils.isWebServiceError(error)) {\n          // It's a WebService error, the user cannot send the note so don't store it.\n          throw error;\n        }\n        return storeOffline();\n      }\n    })();\n  }\n  /**\n   * Delete a note. It will fail if offline or cannot connect.\n   *\n   * @param noteIds Note IDs to delete.\n   * @param courseId Course ID where the note belongs.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when deleted, rejected otherwise. Promise resolved doesn't mean that notes\n   *         have been deleted, the resolve param can contain errors for notes not deleted.\n   */\n  deleteNotesOnline(noteIds, courseId, siteId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        notes: noteIds\n      };\n      yield site.write('core_notes_delete_notes', params);\n      CoreUtils.ignoreErrors(_this4.invalidateNotes(courseId, undefined, siteId));\n    })();\n  }\n  /**\n   * Returns whether or not the notes plugin is enabled for a certain site.\n   *\n   * This method is called quite often and thus should only perform a quick\n   * check, we should not be calling WS from here.\n   *\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if enabled, resolved with false or rejected otherwise.\n   */\n  isPluginEnabled(siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      return site.canUseAdvancedFeature('enablenotes');\n    })();\n  }\n  /**\n   * Returns whether or not the add note plugin is enabled for a certain course.\n   *\n   * @param courseId ID of the course.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if enabled, resolved with false or rejected otherwise.\n   */\n  isPluginAddNoteEnabledForCourse(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // The only way to detect if it's enabled is to perform a WS call.\n      // We use an invalid user ID (-1) to avoid saving the note if the user has permissions.\n      const params = {\n        notes: [{\n          userid: -1,\n          publishstate: 'personal',\n          courseid: courseId,\n          text: '',\n          format: 1\n        }]\n      };\n      const preSets = {\n        updateFrequency: CoreSite.FREQUENCY_RARELY\n      };\n      // Use .read to cache data and be able to check it in offline. This means that, if a user loses the capabilities\n      // to add notes, he'll still see the option in the app.\n      return CoreUtils.promiseWorks(site.read('core_notes_create_notes', params, preSets));\n    })();\n  }\n  /**\n   * Returns whether or not the read notes plugin is enabled for a certain course.\n   *\n   * @param courseId ID of the course.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if enabled, resolved with false or rejected otherwise.\n   */\n  isPluginViewNotesEnabledForCourse(courseId, siteId) {\n    return CoreUtils.promiseWorks(this.getNotes(courseId, undefined, false, true, siteId));\n  }\n  /**\n   * Get prefix cache key for course notes.\n   *\n   * @param courseId ID of the course to get the notes from.\n   * @returns Cache key.\n   */\n  getNotesPrefixCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'notes:' + courseId + ':';\n  }\n  /**\n   * Get the cache key for the get notes call.\n   *\n   * @param courseId ID of the course to get the notes from.\n   * @param userId ID of the user to get the notes from if requested.\n   * @returns Cache key.\n   */\n  getNotesCacheKey(courseId, userId) {\n    return this.getNotesPrefixCacheKey(courseId) + (userId ? userId : '');\n  }\n  /**\n   * Get users notes for a certain site, course and personal notes.\n   *\n   * @param courseId ID of the course to get the notes from.\n   * @param userId ID of the user to get the notes from if requested.\n   * @param ignoreCache True when we should not get the value from the cache.\n   * @param onlyOnline True to return only online notes, false to return both online and offline.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise to be resolved when the notes are retrieved.\n   */\n  getNotes(courseId, userId, ignoreCache = false, onlyOnline = false, siteId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        courseid: courseId\n      };\n      if (userId) {\n        params.userid = userId;\n      }\n      const preSets = {\n        cacheKey: _this5.getNotesCacheKey(courseId, userId),\n        updateFrequency: CoreSite.FREQUENCY_SOMETIMES\n      };\n      if (ignoreCache) {\n        preSets.getFromCache = false;\n        preSets.emergencyCache = false;\n      }\n      const notes = yield site.read('core_notes_get_course_notes', params, preSets);\n      if (onlyOnline) {\n        return notes;\n      }\n      const offlineNotes = yield AddonNotesOffline.getNotesForCourseAndUser(courseId, userId, siteId);\n      offlineNotes.forEach(note => {\n        const fieldName = note.publishstate + 'notes';\n        if (!notes[fieldName]) {\n          notes[fieldName] = [];\n        }\n        note.offline = true;\n        // Add note to the start of array since last notes are shown first.\n        notes[fieldName].unshift(note);\n      });\n      return notes;\n    })();\n  }\n  /**\n   * Get offline deleted notes and set the state.\n   *\n   * @param notes Array of notes.\n   * @param courseId ID of the course the notes belong to.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  setOfflineDeletedNotes(notes, courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      const deletedNotes = yield AddonNotesOffline.getCourseDeletedNotes(courseId, siteId);\n      notes.forEach(note => {\n        note.deleted = deletedNotes.some(n => n.noteid == note.id);\n      });\n    })();\n  }\n  /**\n   * Get user data for notes since they only have userid.\n   *\n   * @param notes Notes to get the data for.\n   * @returns Promise always resolved. Resolve param is the formatted notes.\n   */\n  getNotesUserData(notes) {\n    return _asyncToGenerator(function* () {\n      const promises = notes.map(note =>\n      // Get the user profile to retrieve the user image.\n      CoreUser.getProfile(note.userid, note.courseid, true).then(user => {\n        note.userfullname = user.fullname;\n        note.userprofileimageurl = user.profileimageurl;\n        return;\n      }).catch(() => {\n        note.userfullname = Translate.instant('core.user.userwithid', {\n          id: note.userid\n        });\n      }));\n      yield Promise.all(promises);\n      return notes;\n    })();\n  }\n  /**\n   * Invalidate get notes WS call.\n   *\n   * @param courseId Course ID.\n   * @param userId User ID if needed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when data is invalidated.\n   */\n  invalidateNotes(courseId, userId, siteId) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      if (userId) {\n        yield site.invalidateWsCacheForKey(_this6.getNotesCacheKey(courseId, userId));\n        return;\n      }\n      yield site.invalidateWsCacheForKeyStartingWith(_this6.getNotesPrefixCacheKey(courseId));\n    })();\n  }\n  /**\n   * Report notes as being viewed.\n   *\n   * @param courseId ID of the course.\n   * @param userId User ID if needed.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(courseId, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        courseid: courseId,\n        userid: userId || 0\n      };\n      yield site.write('core_notes_view_notes', params);\n    })();\n  }\n}\n_class = AddonNotesProvider;\n_class.ɵfac = function AddonNotesProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonNotes = makeSingleton(AddonNotesProvider);","map":{"version":3,"names":["CoreWSError","CoreSite","CoreUser","CoreNetwork","CoreSites","CoreUtils","makeSingleton","Translate","AddonNotesOffline","ROOT_CACHE_KEY","AddonNotesProvider","addNote","userId","courseId","publishState","noteText","siteId","_this","_asyncToGenerator","getCurrentSiteId","storeOffline","_ref","saveNote","apply","arguments","isOnline","addNoteOnline","error","isWebServiceError","_this2","notes","courseid","format","publishstate","text","userid","response","addNotesOnline","noteid","message","errormessage","ignoreErrors","invalidateNotes","undefined","length","site","getSite","data","write","deleteNote","note","_this3","offline","deleteOfflineNote","content","created","_ref2","id","deleteNotesOnline","noteIds","_this4","params","isPluginEnabled","canUseAdvancedFeature","isPluginAddNoteEnabledForCourse","preSets","updateFrequency","FREQUENCY_RARELY","promiseWorks","read","isPluginViewNotesEnabledForCourse","getNotes","getNotesPrefixCacheKey","getNotesCacheKey","ignoreCache","onlyOnline","_this5","cacheKey","FREQUENCY_SOMETIMES","getFromCache","emergencyCache","offlineNotes","getNotesForCourseAndUser","forEach","fieldName","unshift","setOfflineDeletedNotes","deletedNotes","getCourseDeletedNotes","deleted","some","n","getNotesUserData","promises","map","getProfile","then","user","userfullname","fullname","userprofileimageurl","profileimageurl","catch","instant","Promise","all","_this6","invalidateWsCacheForKey","invalidateWsCacheForKeyStartingWith","logView","factory","ɵfac","providedIn","AddonNotes"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/notes/services/notes.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreNetwork } from '@services/network';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreWSExternalWarning } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonNotesOffline } from './notes-offline';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaNotes:';\n\n/**\n * Service to handle notes.\n */\n@Injectable( { providedIn: 'root' } )\nexport class AddonNotesProvider {\n\n    /**\n     * Add a note.\n     *\n     * @param userId User ID of the person to add the note.\n     * @param courseId Course ID where the note belongs.\n     * @param publishState Personal, Site or Course.\n     * @param noteText The note text.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: true if note was sent to server, false if stored in device.\n     */\n    async addNote(\n        userId: number,\n        courseId: number,\n        publishState: AddonNotesPublishState,\n        noteText: string,\n        siteId?: string,\n    ): Promise<boolean> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Convenience function to store a note to be synchronized later.\n        const storeOffline = async (): Promise<boolean> => {\n            await AddonNotesOffline.saveNote(userId, courseId, publishState, noteText, siteId);\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the note.\n            return storeOffline();\n        }\n\n        // Send note to server.\n        try {\n            await this.addNoteOnline(userId, courseId, publishState, noteText, siteId);\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // It's a WebService error, the user cannot send the message so don't store it.\n                throw error;\n            }\n\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Add a note. It will fail if offline or cannot connect.\n     *\n     * @param userId User ID of the person to add the note.\n     * @param courseId Course ID where the note belongs.\n     * @param publishState Personal, Site or Course.\n     * @param noteText The note text.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when added, rejected otherwise.\n     */\n    async addNoteOnline(\n        userId: number,\n        courseId: number,\n        publishState: AddonNotesPublishState,\n        noteText: string,\n        siteId?: string,\n    ): Promise<void> {\n        const notes: AddonNotesCreateNoteData[] = [\n            {\n                courseid: courseId,\n                format: 1,\n                publishstate: publishState,\n                text: noteText,\n                userid: userId,\n            },\n        ];\n\n        const response = await this.addNotesOnline(notes, siteId);\n        if (response && response[0] && response[0].noteid === -1) {\n            // There was an error, and it should be translated already.\n            throw new CoreWSError({ message: response[0].errormessage });\n        }\n\n        await CoreUtils.ignoreErrors(this.invalidateNotes(courseId, undefined, siteId));\n    }\n\n    /**\n     * Add several notes. It will fail if offline or cannot connect.\n     *\n     * @param notes Notes to save.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when added, rejected otherwise. Promise resolved doesn't mean that notes\n     *         have been added, the resolve param can contain errors for notes not sent.\n     */\n    async addNotesOnline(notes: AddonNotesCreateNoteData[], siteId?: string): Promise<AddonNotesCreateNotesWSResponse> {\n        if (!notes || !notes.length) {\n            return [];\n        }\n\n        const site = await CoreSites.getSite(siteId);\n\n        const data: AddonNotesCreateNotesWSParams = {\n            notes: notes,\n        };\n\n        return site.write('core_notes_create_notes', data);\n    }\n\n    /**\n     * Delete a note.\n     *\n     * @param note Note object to delete.\n     * @param courseId Course ID where the note belongs.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when deleted, rejected otherwise. Promise resolved doesn't mean that notes\n     *         have been deleted, the resolve param can contain errors for notes not deleted.\n     */\n    async deleteNote(note: AddonNotesNoteFormatted, courseId: number, siteId?: string): Promise<boolean> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (note.offline) {\n            await AddonNotesOffline.deleteOfflineNote(note.userid, note.content, note.created, siteId);\n\n            return true;\n        }\n\n        // Convenience function to store the action to be synchronized later.\n        const storeOffline = async (): Promise<boolean> => {\n            await AddonNotesOffline.deleteNote(note.id, courseId, siteId);\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the note.\n            return storeOffline();\n        }\n\n        // Send note to server.\n        try {\n            await this.deleteNotesOnline([note.id], courseId, siteId);\n\n            return true;\n        } catch (error) {\n            if (CoreUtils.isWebServiceError(error)) {\n                // It's a WebService error, the user cannot send the note so don't store it.\n                throw error;\n            }\n\n            return storeOffline();\n        }\n    }\n\n    /**\n     * Delete a note. It will fail if offline or cannot connect.\n     *\n     * @param noteIds Note IDs to delete.\n     * @param courseId Course ID where the note belongs.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when deleted, rejected otherwise. Promise resolved doesn't mean that notes\n     *         have been deleted, the resolve param can contain errors for notes not deleted.\n     */\n    async deleteNotesOnline(noteIds: number[], courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonNotesDeleteNotesWSParams = {\n            notes: noteIds,\n        };\n\n        await site.write('core_notes_delete_notes', params);\n\n        CoreUtils.ignoreErrors(this.invalidateNotes(courseId, undefined, siteId));\n    }\n\n    /**\n     * Returns whether or not the notes plugin is enabled for a certain site.\n     *\n     * This method is called quite often and thus should only perform a quick\n     * check, we should not be calling WS from here.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if enabled, resolved with false or rejected otherwise.\n     */\n    async isPluginEnabled(siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        return site.canUseAdvancedFeature('enablenotes');\n    }\n\n    /**\n     * Returns whether or not the add note plugin is enabled for a certain course.\n     *\n     * @param courseId ID of the course.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if enabled, resolved with false or rejected otherwise.\n     */\n    async isPluginAddNoteEnabledForCourse(courseId: number, siteId?: string): Promise<boolean> {\n        const site = await CoreSites.getSite(siteId);\n\n        // The only way to detect if it's enabled is to perform a WS call.\n        // We use an invalid user ID (-1) to avoid saving the note if the user has permissions.\n        const params: AddonNotesCreateNotesWSParams = {\n            notes: [\n                {\n                    userid: -1,\n                    publishstate: 'personal',\n                    courseid: courseId,\n                    text: '',\n                    format: 1,\n                },\n            ],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n        };\n\n        // Use .read to cache data and be able to check it in offline. This means that, if a user loses the capabilities\n        // to add notes, he'll still see the option in the app.\n        return CoreUtils.promiseWorks(site.read('core_notes_create_notes', params, preSets));\n    }\n\n    /**\n     * Returns whether or not the read notes plugin is enabled for a certain course.\n     *\n     * @param courseId ID of the course.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if enabled, resolved with false or rejected otherwise.\n     */\n    isPluginViewNotesEnabledForCourse(courseId: number, siteId?: string): Promise<boolean> {\n        return CoreUtils.promiseWorks(this.getNotes(courseId, undefined, false, true, siteId));\n    }\n\n    /**\n     * Get prefix cache key for course notes.\n     *\n     * @param courseId ID of the course to get the notes from.\n     * @returns Cache key.\n     */\n    getNotesPrefixCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'notes:' + courseId + ':';\n    }\n\n    /**\n     * Get the cache key for the get notes call.\n     *\n     * @param courseId ID of the course to get the notes from.\n     * @param userId ID of the user to get the notes from if requested.\n     * @returns Cache key.\n     */\n    getNotesCacheKey(courseId: number, userId?: number): string {\n        return this.getNotesPrefixCacheKey(courseId) + (userId ? userId : '');\n    }\n\n    /**\n     * Get users notes for a certain site, course and personal notes.\n     *\n     * @param courseId ID of the course to get the notes from.\n     * @param userId ID of the user to get the notes from if requested.\n     * @param ignoreCache True when we should not get the value from the cache.\n     * @param onlyOnline True to return only online notes, false to return both online and offline.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise to be resolved when the notes are retrieved.\n     */\n    async getNotes(\n        courseId: number,\n        userId?: number,\n        ignoreCache = false,\n        onlyOnline = false,\n        siteId?: string,\n    ): Promise<AddonNotesGetCourseNotesWSResponse> {\n\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonNotesGetCourseNotesWSParams = {\n            courseid: courseId,\n        };\n        if (userId) {\n            params.userid = userId;\n        }\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getNotesCacheKey(courseId, userId),\n            updateFrequency: CoreSite.FREQUENCY_SOMETIMES,\n        };\n\n        if (ignoreCache) {\n            preSets.getFromCache = false;\n            preSets.emergencyCache = false;\n        }\n        const notes = await site.read<AddonNotesGetCourseNotesWSResponse>('core_notes_get_course_notes', params, preSets);\n        if (onlyOnline) {\n            return notes;\n        }\n\n        const offlineNotes = await AddonNotesOffline.getNotesForCourseAndUser(courseId, userId, siteId);\n        offlineNotes.forEach((note: AddonNotesNote) => {\n            const fieldName = note.publishstate + 'notes';\n            if (!notes[fieldName]) {\n                notes[fieldName] = [];\n            }\n            note.offline = true;\n            // Add note to the start of array since last notes are shown first.\n            notes[fieldName].unshift(note);\n        });\n\n        return notes;\n    }\n\n    /**\n     * Get offline deleted notes and set the state.\n     *\n     * @param notes Array of notes.\n     * @param courseId ID of the course the notes belong to.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    async setOfflineDeletedNotes(\n        notes: AddonNotesNoteFormatted[],\n        courseId: number,\n        siteId?: string,\n    ): Promise<void> {\n        const deletedNotes = await AddonNotesOffline.getCourseDeletedNotes(courseId, siteId);\n\n        notes.forEach((note) => {\n            note.deleted = deletedNotes.some((n) => n.noteid == note.id);\n        });\n    }\n\n    /**\n     * Get user data for notes since they only have userid.\n     *\n     * @param notes Notes to get the data for.\n     * @returns Promise always resolved. Resolve param is the formatted notes.\n     */\n    async getNotesUserData(notes: AddonNotesNoteFormatted[]): Promise<AddonNotesNoteFormatted[]> {\n        const promises = notes.map((note) =>\n            // Get the user profile to retrieve the user image.\n            CoreUser.getProfile(note.userid, note.courseid, true).then((user) => {\n                note.userfullname = user.fullname;\n                note.userprofileimageurl = user.profileimageurl;\n\n                return;\n            }).catch(() => {\n                note.userfullname = Translate.instant('core.user.userwithid', { id: note.userid });\n            }));\n\n        await Promise.all(promises);\n\n        return notes;\n    }\n\n    /**\n     * Invalidate get notes WS call.\n     *\n     * @param courseId Course ID.\n     * @param userId User ID if needed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when data is invalidated.\n     */\n    async invalidateNotes(courseId: number, userId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        if (userId) {\n            await site.invalidateWsCacheForKey(this.getNotesCacheKey(courseId, userId));\n\n            return;\n        }\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getNotesPrefixCacheKey(courseId));\n    }\n\n    /**\n     * Report notes as being viewed.\n     *\n     * @param courseId ID of the course.\n     * @param userId User ID if needed.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logView(courseId: number, userId?: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonNotesViewNotesWSParams = {\n            courseid: courseId,\n            userid: userId || 0,\n        };\n\n        await site.write('core_notes_view_notes', params);\n    }\n\n}\nexport const AddonNotes = makeSingleton(AddonNotesProvider);\n\n/**\n * Params of core_notes_view_notes WS.\n */\ntype AddonNotesViewNotesWSParams = {\n    courseid: number; // Course id, 0 for notes at system level.\n    userid?: number; // User id, 0 means view all the user notes.\n};\n\n/**\n * Params of core_notes_get_course_notes WS.\n */\nexport type AddonNotesGetCourseNotesWSParams = {\n    courseid: number; // Course id, 0 for SITE.\n    userid?: number; // User id.\n};\n\n/**\n * Note data returned by core_notes_get_course_notes.\n */\nexport type AddonNotesNote = {\n    id: number; // Id of this note.\n    courseid: number; // Id of the course.\n    userid: number; // User id.\n    content: string; // The content text formated.\n    format: number; // Content format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    created: number; // Time created (timestamp).\n    lastmodified: number; // Time of last modification (timestamp).\n    usermodified: number; // User id of the creator of this note.\n    publishstate: AddonNotesPublishState; // State of the note (i.e. draft, public, site).\n    offline?: boolean;\n};\n\n/**\n * Result of WS core_notes_get_course_notes.\n */\nexport type AddonNotesGetCourseNotesWSResponse = {\n    sitenotes?: AddonNotesNote[]; // Site notes.\n    coursenotes?: AddonNotesNote[]; // Couse notes.\n    personalnotes?: AddonNotesNote[]; // Personal notes.\n    canmanagesystemnotes?: boolean; // @since 3.7. Whether the user can manage notes at system level.\n    canmanagecoursenotes?: boolean; // @since 3.7. Whether the user can manage notes at the given course.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result of WS core_notes_view_notes.\n */\nexport type AddonNotesViewNotesResult = {\n    status: boolean; // Status: true if success.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Notes with some calculated data.\n */\nexport type AddonNotesNoteFormatted = AddonNotesNote & {\n    offline?: boolean; // Calculated in the app. Whether it's an offline note.\n    deleted?: boolean; // Calculated in the app. Whether the note was deleted in offline.\n    userfullname?: string; // Calculated in the app. Full name of the user the note refers to.\n    userprofileimageurl?: string; // Calculated in the app. Avatar url of the user the note refers to.\n};\n\nexport type AddonNotesCreateNoteData = {\n    userid: number; // Id of the user the note is about.\n    publishstate: AddonNotesPublishState; // 'personal', 'course' or 'site'.\n    courseid: number; // Course id of the note (in Moodle a note can only be created into a course,\n    // even for site and personal notes).\n    text: string; // The text of the message - text or HTML.\n    format?: number; // Text format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    clientnoteid?: string; // Your own client id for the note. If this id is provided, the fail message id will be returned to you.\n};\n\n/**\n * Params of core_notes_create_notes WS.\n */\ntype AddonNotesCreateNotesWSParams = {\n    notes: AddonNotesCreateNoteData[];\n};\n\n/**\n * Note returned by WS core_notes_create_notes.\n */\nexport type AddonNotesCreateNotesWSResponse = {\n    clientnoteid?: string; // Your own id for the note.\n    noteid: number; // ID of the created note when successful, -1 when failed.\n    errormessage?: string; // Error message - if failed.\n}[];\n\n/**\n * Params of core_notes_delete_notes WS.\n */\ntype AddonNotesDeleteNotesWSParams = {\n    notes: number[]; // Array of Note Ids to be deleted.\n};\n\nexport type AddonNotesPublishState = 'personal' | 'site' | 'course';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}