{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreError } from '@classes/errors/error';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { AddonModScorm, AddonModScormProvider } from './scorm';\nimport { AddonModScormOffline } from './scorm-offline';\nimport * as i0 from \"@angular/core\";\n// List of elements we want to ignore when copying attempts (they're calculated).\nconst elementsToIgnore = ['status', 'score_raw', 'total_time', 'session_time', 'student_id', 'student_name', 'credit', 'mode', 'entry'];\n/**\n * Helper service that provides some features for SCORM.\n */\nexport class AddonModScormHelperProvider {\n  /**\n   * Show a confirm dialog if needed. If SCORM doesn't have size, try to calculate it.\n   *\n   * @param scorm SCORM to download.\n   * @param isOutdated True if package outdated, false if not outdated, undefined to calculate it.\n   * @returns Promise resolved if the user confirms or no confirmation needed.\n   */\n  confirmDownload(scorm, isOutdated) {\n    return _asyncToGenerator(function* () {\n      // Check if file should be downloaded.\n      const download = yield AddonModScorm.shouldDownloadMainFile(scorm, isOutdated);\n      if (!download) {\n        // No need to download main file, no need to confirm.\n        return;\n      }\n      let size = scorm.packagesize;\n      if (!size) {\n        // We don't have package size, try to calculate it.\n        size = yield AddonModScorm.calculateScormSize(scorm);\n        // Store it so we don't have to calculate it again when using the same object.\n        scorm.packagesize = size;\n      }\n      return CoreDomUtils.confirmDownloadSize({\n        size: size,\n        total: true\n      });\n    })();\n  }\n  /**\n   * Creates a new offline attempt based on an existing online attempt.\n   *\n   * @param scorm SCORM.\n   * @param attempt Number of the online attempt.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the attempt is created.\n   */\n  convertAttemptToOffline(scorm, attempt, siteId) {\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Get data from the online attempt.\n      const onlineData = yield CoreUtils.ignoreErrors(AddonModScorm.getScormUserData(scorm.id, attempt, {\n        cmId: scorm.coursemodule,\n        siteId\n      }));\n      if (!onlineData) {\n        // Shouldn't happen.\n        throw new CoreError(Translate.instant('addon.mod_scorm.errorcreateofflineattempt'));\n      }\n      // The SCORM API might have written some data to the offline attempt already.\n      // We don't want to override it with cached online data.\n      const offlineData = yield CoreUtils.ignoreErrors(AddonModScormOffline.getScormUserData(scorm.id, attempt, undefined, siteId));\n      const dataToStore = CoreUtils.clone(onlineData);\n      // Filter the data to copy.\n      for (const scoId in dataToStore) {\n        const sco = dataToStore[scoId];\n        // Delete calculated data.\n        elementsToIgnore.forEach(el => {\n          delete sco.userdata[el];\n        });\n        // Don't override offline data.\n        if (offlineData && offlineData[sco.scoid] && offlineData[sco.scoid].userdata) {\n          const scoUserData = {};\n          for (const element in sco.userdata) {\n            if (!offlineData[sco.scoid].userdata[element]) {\n              // This element is not stored in offline, we can save it.\n              scoUserData[element] = sco.userdata[element];\n            }\n          }\n          sco.userdata = scoUserData;\n        }\n      }\n      yield AddonModScormOffline.createNewAttempt(scorm, attempt, dataToStore, onlineData, siteId);\n    })();\n  }\n  /**\n   * Creates a new offline attempt.\n   *\n   * @param scorm SCORM.\n   * @param newAttempt Number of the new attempt.\n   * @param lastOnline Number of the last online attempt.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the attempt is created.\n   */\n  createOfflineAttempt(scorm, newAttempt, lastOnline, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Try to get data from online attempts.\n      const userData = yield CoreUtils.ignoreErrors(_this.searchOnlineAttemptUserData(scorm.id, lastOnline, {\n        cmId: scorm.coursemodule,\n        siteId\n      }));\n      if (!userData) {\n        throw new CoreError(Translate.instant('addon.mod_scorm.errorcreateofflineattempt'));\n      }\n      // We're creating a new attempt, remove all the user data that is not needed for a new attempt.\n      for (const scoId in userData) {\n        const sco = userData[scoId];\n        const filtered = {};\n        for (const element in sco.userdata) {\n          if (element.indexOf('.') == -1 && elementsToIgnore.indexOf(element) == -1) {\n            // The element doesn't use a dot notation, probably SCO data.\n            filtered[element] = sco.userdata[element];\n          }\n        }\n        sco.userdata = filtered;\n      }\n      return AddonModScormOffline.createNewAttempt(scorm, newAttempt, userData, undefined, siteId);\n    })();\n  }\n  /**\n   * Determines the attempt to continue/review. It will be:\n   * - The last incomplete online attempt if it hasn't been continued in offline and all offline attempts are complete.\n   * - The attempt with highest number without surpassing max attempts otherwise.\n   *\n   * @param scorm SCORM object.\n   * @param attempts Attempts count.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the attempt data.\n   */\n  determineAttemptToContinue(scorm, attempts, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let lastOnline;\n      // Get last online attempt.\n      if (attempts.online.length) {\n        lastOnline = Math.max.apply(Math, attempts.online);\n      }\n      if (!lastOnline) {\n        return _this2.getLastBeforeMax(scorm, attempts);\n      }\n      // Check if last online incomplete.\n      const hasOffline = attempts.offline.indexOf(lastOnline) > -1;\n      const incomplete = yield AddonModScorm.isAttemptIncomplete(scorm.id, lastOnline, {\n        offline: hasOffline,\n        cmId: scorm.coursemodule,\n        siteId\n      });\n      if (incomplete) {\n        return {\n          num: lastOnline,\n          offline: hasOffline\n        };\n      } else {\n        return _this2.getLastBeforeMax(scorm, attempts);\n      }\n    })();\n  }\n  /**\n   * Get the first SCO to load in a SCORM: the first valid and incomplete SCO.\n   *\n   * @param scormId Scorm ID.\n   * @param attempt Attempt number.\n   * @param options Other options.\n   * @returns Promise resolved with the first SCO.\n   */\n  getFirstSco(scormId, attempt, options = {}) {\n    return _asyncToGenerator(function* () {\n      const mode = options.mode || AddonModScormProvider.MODENORMAL;\n      const isNormalMode = mode === AddonModScormProvider.MODENORMAL;\n      let scos = options.toc;\n      if (!scos || !scos.length) {\n        // SCORM doesn't have a TOC. Get all the scos.\n        scos = yield AddonModScorm.getScosWithData(scormId, attempt, options);\n      }\n      // Search the first valid SCO.\n      // In browse/review mode return the first visible sco. In normal mode, first incomplete sco.\n      const sco = scos.find(sco => sco.isvisible && sco.launch && sco.prereq && (!isNormalMode || AddonModScorm.isStatusIncomplete(sco.status)));\n      // If no \"valid\" SCO, load the first one. In web it loads the first child because the toc contains the organization SCO.\n      return sco || scos[0];\n    })();\n  }\n  /**\n   * Get the last attempt (number and whether it's offline).\n   * It'll be the highest number as long as it doesn't surpass the max number of attempts.\n   *\n   * @param scorm SCORM object.\n   * @param attempts Attempts count.\n   * @returns Last attempt data.\n   */\n  getLastBeforeMax(scorm, attempts) {\n    if (scorm.maxattempt && attempts.lastAttempt.num > scorm.maxattempt) {\n      return {\n        num: scorm.maxattempt,\n        offline: attempts.offline.indexOf(scorm.maxattempt) > -1\n      };\n    } else {\n      return {\n        num: attempts.lastAttempt.num,\n        offline: attempts.lastAttempt.offline\n      };\n    }\n  }\n  /**\n   * Given a TOC in array format and a scoId, return the next available SCO.\n   *\n   * @param toc SCORM's TOC.\n   * @param scoId SCO ID.\n   * @returns Next SCO.\n   */\n  getNextScoFromToc(toc, scoId) {\n    const currentTocIndex = toc.findIndex(item => item.id == scoId);\n    // We found the current SCO. Now search the next visible SCO with fulfilled prerequisites.\n    for (let j = currentTocIndex + 1; j < toc.length; j++) {\n      if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {\n        return toc[j];\n      }\n    }\n  }\n  /**\n   * Given a TOC in array format and a scoId, return the previous available SCO.\n   *\n   * @param toc SCORM's TOC.\n   * @param scoId SCO ID.\n   * @returns Previous SCO.\n   */\n  getPreviousScoFromToc(toc, scoId) {\n    const currentTocIndex = toc.findIndex(item => item.id == scoId);\n    // We found the current SCO. Now let's search the previous visible SCO with fulfilled prerequisites.\n    for (let j = currentTocIndex - 1; j >= 0; j--) {\n      if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {\n        return toc[j];\n      }\n    }\n  }\n  /**\n   * Given a TOC in array format and a scoId, return the SCO.\n   *\n   * @param toc SCORM's TOC.\n   * @param scoId SCO ID.\n   * @returns SCO.\n   */\n  getScoFromToc(toc, scoId) {\n    return toc.find(sco => sco.id == scoId);\n  }\n  /**\n   * Get SCORM TOC, formatted.\n   *\n   * @param scormId Scorm ID.\n   * @param lastAttempt Last attempt number.\n   * @param incomplete Whether last attempt is incomplete.\n   * @param options Options.\n   * @returns Promise resolved with the TOC.\n   */\n  getToc(scormId, lastAttempt, incomplete, options = {}) {\n    return _asyncToGenerator(function* () {\n      const toc = yield AddonModScorm.getOrganizationToc(scormId, lastAttempt, options);\n      const tocArray = AddonModScorm.formatTocToArray(toc);\n      // Get images for each SCO.\n      tocArray.forEach(sco => {\n        sco.icon = AddonModScorm.getScoStatusIcon(sco, incomplete);\n      });\n      return tocArray;\n    })();\n  }\n  /**\n   * Searches user data for an online attempt. If the data can't be retrieved, re-try with the previous online attempt.\n   *\n   * @param scormId SCORM ID.\n   * @param attempt Online attempt to get the data.\n   * @param options Other options.\n   * @returns Promise resolved with user data.\n   */\n  searchOnlineAttemptUserData(scormId, attempt, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n      try {\n        return yield AddonModScorm.getScormUserData(scormId, attempt, options);\n      } catch (error) {\n        if (attempt <= 0) {\n          // No more attempts to try.\n          throw error;\n        }\n        try {\n          // We couldn't retrieve the data. Try again with the previous online attempt.\n          return yield _this3.searchOnlineAttemptUserData(scormId, attempt - 1, options);\n        } catch (_unused) {\n          // Couldn't retrieve previous attempts data either.\n          throw error;\n        }\n      }\n    })();\n  }\n}\n_class = AddonModScormHelperProvider;\n_class.ɵfac = function AddonModScormHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModScormHelper = makeSingleton(AddonModScormHelperProvider);","map":{"version":3,"names":["CoreError","CoreSites","CoreDomUtils","CoreUtils","makeSingleton","Translate","AddonModScorm","AddonModScormProvider","AddonModScormOffline","elementsToIgnore","AddonModScormHelperProvider","confirmDownload","scorm","isOutdated","_asyncToGenerator","download","shouldDownloadMainFile","size","packagesize","calculateScormSize","confirmDownloadSize","total","convertAttemptToOffline","attempt","siteId","getCurrentSiteId","onlineData","ignoreErrors","getScormUserData","id","cmId","coursemodule","instant","offlineData","undefined","dataToStore","clone","scoId","sco","forEach","el","userdata","scoid","scoUserData","element","createNewAttempt","createOfflineAttempt","newAttempt","lastOnline","_this","userData","searchOnlineAttemptUserData","filtered","indexOf","determineAttemptToContinue","attempts","_this2","online","length","Math","max","apply","getLastBeforeMax","hasOffline","offline","incomplete","isAttemptIncomplete","num","getFirstSco","scormId","options","mode","MODENORMAL","isNormalMode","scos","toc","getScosWithData","find","isvisible","launch","prereq","isStatusIncomplete","status","maxattempt","lastAttempt","getNextScoFromToc","currentTocIndex","findIndex","item","j","getPreviousScoFromToc","getScoFromToc","getToc","getOrganizationToc","tocArray","formatTocToArray","icon","getScoStatusIcon","_this3","error","_unused","factory","ɵfac","providedIn","AddonModScormHelper"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/scorm/services/scorm-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreSites } from '@services/sites';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport {\n    AddonModScorm,\n    AddonModScormAttempt,\n    AddonModScormAttemptCountResult,\n    AddonModScormDataValue,\n    AddonModScormGetScosWithDataOptions,\n    AddonModScormProvider,\n    AddonModScormScoIcon,\n    AddonModScormScorm,\n    AddonModScormScoWithData,\n    AddonModScormTOCListSco,\n    AddonModScormUserDataMap,\n} from './scorm';\nimport { AddonModScormOffline } from './scorm-offline';\n\n// List of elements we want to ignore when copying attempts (they're calculated).\nconst elementsToIgnore = [\n    'status', 'score_raw', 'total_time', 'session_time', 'student_id', 'student_name', 'credit', 'mode', 'entry',\n];\n\n/**\n * Helper service that provides some features for SCORM.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModScormHelperProvider {\n\n    /**\n     * Show a confirm dialog if needed. If SCORM doesn't have size, try to calculate it.\n     *\n     * @param scorm SCORM to download.\n     * @param isOutdated True if package outdated, false if not outdated, undefined to calculate it.\n     * @returns Promise resolved if the user confirms or no confirmation needed.\n     */\n    async confirmDownload(scorm: AddonModScormScorm, isOutdated?: boolean): Promise<void> {\n        // Check if file should be downloaded.\n        const download = await AddonModScorm.shouldDownloadMainFile(scorm, isOutdated);\n\n        if (!download) {\n            // No need to download main file, no need to confirm.\n            return;\n        }\n\n        let size = scorm.packagesize;\n\n        if (!size) {\n            // We don't have package size, try to calculate it.\n            size = await AddonModScorm.calculateScormSize(scorm);\n\n            // Store it so we don't have to calculate it again when using the same object.\n            scorm.packagesize = size;\n        }\n\n        return CoreDomUtils.confirmDownloadSize({ size: size, total: true });\n    }\n\n    /**\n     * Creates a new offline attempt based on an existing online attempt.\n     *\n     * @param scorm SCORM.\n     * @param attempt Number of the online attempt.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the attempt is created.\n     */\n    async convertAttemptToOffline(scorm: AddonModScormScorm, attempt: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Get data from the online attempt.\n        const onlineData = await CoreUtils.ignoreErrors(\n            AddonModScorm.getScormUserData(scorm.id, attempt, { cmId: scorm.coursemodule, siteId }),\n        );\n\n        if (!onlineData) {\n            // Shouldn't happen.\n            throw new CoreError(Translate.instant('addon.mod_scorm.errorcreateofflineattempt'));\n        }\n\n        // The SCORM API might have written some data to the offline attempt already.\n        // We don't want to override it with cached online data.\n        const offlineData = await CoreUtils.ignoreErrors(\n            AddonModScormOffline.getScormUserData(scorm.id, attempt, undefined, siteId),\n        );\n\n        const dataToStore = CoreUtils.clone(onlineData);\n\n        // Filter the data to copy.\n        for (const scoId in dataToStore) {\n            const sco = dataToStore[scoId];\n\n            // Delete calculated data.\n            elementsToIgnore.forEach((el) => {\n                delete sco.userdata[el];\n            });\n\n            // Don't override offline data.\n            if (offlineData && offlineData[sco.scoid] && offlineData[sco.scoid].userdata) {\n                const scoUserData: Record<string, AddonModScormDataValue> = {};\n\n                for (const element in sco.userdata) {\n                    if (!offlineData[sco.scoid].userdata[element]) {\n                        // This element is not stored in offline, we can save it.\n                        scoUserData[element] = sco.userdata[element];\n                    }\n                }\n\n                sco.userdata = scoUserData;\n            }\n        }\n\n        await AddonModScormOffline.createNewAttempt(scorm, attempt, dataToStore, onlineData, siteId);\n    }\n\n    /**\n     * Creates a new offline attempt.\n     *\n     * @param scorm SCORM.\n     * @param newAttempt Number of the new attempt.\n     * @param lastOnline Number of the last online attempt.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the attempt is created.\n     */\n    async createOfflineAttempt(scorm: AddonModScormScorm, newAttempt: number, lastOnline: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Try to get data from online attempts.\n        const userData = await CoreUtils.ignoreErrors(\n            this.searchOnlineAttemptUserData(scorm.id, lastOnline, { cmId: scorm.coursemodule, siteId }),\n        );\n\n        if (!userData) {\n            throw new CoreError(Translate.instant('addon.mod_scorm.errorcreateofflineattempt'));\n        }\n\n        // We're creating a new attempt, remove all the user data that is not needed for a new attempt.\n        for (const scoId in userData) {\n            const sco = userData[scoId];\n            const filtered: Record<string, AddonModScormDataValue> = {};\n\n            for (const element in sco.userdata) {\n                if (element.indexOf('.') == -1 && elementsToIgnore.indexOf(element) == -1) {\n                    // The element doesn't use a dot notation, probably SCO data.\n                    filtered[element] = sco.userdata[element];\n                }\n            }\n\n            sco.userdata = filtered;\n        }\n\n        return AddonModScormOffline.createNewAttempt(scorm, newAttempt, userData, undefined, siteId);\n    }\n\n    /**\n     * Determines the attempt to continue/review. It will be:\n     * - The last incomplete online attempt if it hasn't been continued in offline and all offline attempts are complete.\n     * - The attempt with highest number without surpassing max attempts otherwise.\n     *\n     * @param scorm SCORM object.\n     * @param attempts Attempts count.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the attempt data.\n     */\n    async determineAttemptToContinue(\n        scorm: AddonModScormScorm,\n        attempts: AddonModScormAttemptCountResult,\n        siteId?: string,\n    ): Promise<AddonModScormAttempt> {\n\n        let lastOnline: number | undefined;\n\n        // Get last online attempt.\n        if (attempts.online.length) {\n            lastOnline = Math.max.apply(Math, attempts.online);\n        }\n\n        if (!lastOnline) {\n            return this.getLastBeforeMax(scorm, attempts);\n        }\n\n        // Check if last online incomplete.\n        const hasOffline = attempts.offline.indexOf(lastOnline) > -1;\n\n        const incomplete = await AddonModScorm.isAttemptIncomplete(scorm.id, lastOnline, {\n            offline: hasOffline,\n            cmId: scorm.coursemodule,\n            siteId,\n        });\n\n        if (incomplete) {\n            return {\n                num: lastOnline,\n                offline: hasOffline,\n            };\n        } else {\n            return this.getLastBeforeMax(scorm, attempts);\n        }\n    }\n\n    /**\n     * Get the first SCO to load in a SCORM: the first valid and incomplete SCO.\n     *\n     * @param scormId Scorm ID.\n     * @param attempt Attempt number.\n     * @param options Other options.\n     * @returns Promise resolved with the first SCO.\n     */\n    async getFirstSco(\n        scormId: number,\n        attempt: number,\n        options: AddonModScormGetFirstScoOptions = {},\n    ): Promise<AddonModScormScoWithData | undefined> {\n\n        const mode = options.mode || AddonModScormProvider.MODENORMAL;\n        const isNormalMode = mode === AddonModScormProvider.MODENORMAL;\n\n        let scos = options.toc;\n        if (!scos || !scos.length) {\n            // SCORM doesn't have a TOC. Get all the scos.\n            scos = await AddonModScorm.getScosWithData(scormId, attempt, options);\n        }\n\n        // Search the first valid SCO.\n        // In browse/review mode return the first visible sco. In normal mode, first incomplete sco.\n        const sco = scos.find(sco => sco.isvisible && sco.launch && sco.prereq &&\n            (!isNormalMode || AddonModScorm.isStatusIncomplete(sco.status)));\n\n        // If no \"valid\" SCO, load the first one. In web it loads the first child because the toc contains the organization SCO.\n        return sco || scos[0];\n    }\n\n    /**\n     * Get the last attempt (number and whether it's offline).\n     * It'll be the highest number as long as it doesn't surpass the max number of attempts.\n     *\n     * @param scorm SCORM object.\n     * @param attempts Attempts count.\n     * @returns Last attempt data.\n     */\n    protected getLastBeforeMax(\n        scorm: AddonModScormScorm,\n        attempts: AddonModScormAttemptCountResult,\n    ): AddonModScormAttempt {\n        if (scorm.maxattempt && attempts.lastAttempt.num > scorm.maxattempt) {\n            return {\n                num: scorm.maxattempt,\n                offline: attempts.offline.indexOf(scorm.maxattempt) > -1,\n            };\n        } else {\n            return {\n                num: attempts.lastAttempt.num,\n                offline: attempts.lastAttempt.offline,\n            };\n        }\n    }\n\n    /**\n     * Given a TOC in array format and a scoId, return the next available SCO.\n     *\n     * @param toc SCORM's TOC.\n     * @param scoId SCO ID.\n     * @returns Next SCO.\n     */\n    getNextScoFromToc(toc: AddonModScormScoWithData[], scoId: number): AddonModScormScoWithData | undefined {\n        const currentTocIndex = toc.findIndex((item) => item.id == scoId);\n\n        // We found the current SCO. Now search the next visible SCO with fulfilled prerequisites.\n        for (let j = currentTocIndex + 1; j < toc.length; j++) {\n            if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {\n                return toc[j];\n            }\n        }\n    }\n\n    /**\n     * Given a TOC in array format and a scoId, return the previous available SCO.\n     *\n     * @param toc SCORM's TOC.\n     * @param scoId SCO ID.\n     * @returns Previous SCO.\n     */\n    getPreviousScoFromToc(toc: AddonModScormScoWithData[], scoId: number): AddonModScormScoWithData | undefined {\n        const currentTocIndex = toc.findIndex((item) => item.id == scoId);\n\n        // We found the current SCO. Now let's search the previous visible SCO with fulfilled prerequisites.\n        for (let j = currentTocIndex - 1; j >= 0; j--) {\n            if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {\n                return toc[j];\n            }\n        }\n    }\n\n    /**\n     * Given a TOC in array format and a scoId, return the SCO.\n     *\n     * @param toc SCORM's TOC.\n     * @param scoId SCO ID.\n     * @returns SCO.\n     */\n    getScoFromToc(toc: AddonModScormScoWithData[], scoId: number): AddonModScormScoWithData | undefined {\n        return toc.find(sco => sco.id == scoId);\n    }\n\n    /**\n     * Get SCORM TOC, formatted.\n     *\n     * @param scormId Scorm ID.\n     * @param lastAttempt Last attempt number.\n     * @param incomplete Whether last attempt is incomplete.\n     * @param options Options.\n     * @returns Promise resolved with the TOC.\n     */\n    async getToc(\n        scormId: number,\n        lastAttempt: number,\n        incomplete: boolean,\n        options: AddonModScormGetScosWithDataOptions = {},\n    ): Promise<AddonModScormTOCScoWithIcon[]> {\n        const toc = await AddonModScorm.getOrganizationToc(scormId, lastAttempt, options);\n\n        const tocArray = <AddonModScormTOCScoWithIcon[]> AddonModScorm.formatTocToArray(toc);\n\n        // Get images for each SCO.\n        tocArray.forEach((sco) => {\n            sco.icon = AddonModScorm.getScoStatusIcon(sco, incomplete);\n        });\n\n        return tocArray;\n    }\n\n    /**\n     * Searches user data for an online attempt. If the data can't be retrieved, re-try with the previous online attempt.\n     *\n     * @param scormId SCORM ID.\n     * @param attempt Online attempt to get the data.\n     * @param options Other options.\n     * @returns Promise resolved with user data.\n     */\n    async searchOnlineAttemptUserData(\n        scormId: number,\n        attempt: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModScormUserDataMap> {\n        options.siteId = options.siteId || CoreSites.getCurrentSiteId();\n\n        try {\n            return await AddonModScorm.getScormUserData(scormId, attempt, options);\n        } catch (error) {\n            if (attempt <= 0) {\n                // No more attempts to try.\n                throw error;\n            }\n\n            try {\n                // We couldn't retrieve the data. Try again with the previous online attempt.\n                return await this.searchOnlineAttemptUserData(scormId, attempt - 1, options);\n            } catch {\n                // Couldn't retrieve previous attempts data either.\n                throw error;\n            }\n        }\n    }\n\n}\n\nexport const AddonModScormHelper = makeSingleton(AddonModScormHelperProvider);\n\n/**\n * Options to pass to getFirstSco.\n */\nexport type AddonModScormGetFirstScoOptions = CoreCourseCommonModWSOptions & {\n    toc?: AddonModScormScoWithData[]; // SCORM's TOC. If not provided, it will be calculated.\n    organization?: string; // Organization to use.\n    mode?: string; // Mode.\n    offline?: boolean; // Whether the attempt is offline.\n};\n\n/**\n * TOC SCO with icon.\n */\nexport type AddonModScormTOCScoWithIcon = AddonModScormTOCListSco & {\n    icon?: AddonModScormScoIcon;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}