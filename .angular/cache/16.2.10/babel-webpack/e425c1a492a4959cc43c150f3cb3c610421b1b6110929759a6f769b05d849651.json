{"ast":null,"code":"// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Translate } from '@singletons';\nimport { CoreConstants } from '../constants';\n/**\n * Singleton with helper functions for time operations.\n */\nexport class CoreTime {\n  /**\n   * Returns years, months, days, hours, minutes and seconds in a human readable format.\n   *\n   * @param seconds A number of seconds\n   * @param precision Number of elements to have in precision.\n   * @returns Seconds in a human readable format.\n   */\n  static formatTime(seconds, precision = 2) {\n    precision = precision || 5; // Use max precision if 0 is passed.\n    const totalSecs = Math.abs(seconds);\n    if (!totalSecs) {\n      return Translate.instant('core.now');\n    }\n    const years = Math.floor(totalSecs / CoreConstants.SECONDS_YEAR);\n    let remainder = totalSecs - years * CoreConstants.SECONDS_YEAR;\n    const days = Math.floor(remainder / CoreConstants.SECONDS_DAY);\n    remainder = remainder - days * CoreConstants.SECONDS_DAY;\n    const hours = Math.floor(remainder / CoreConstants.SECONDS_HOUR);\n    remainder = remainder - hours * CoreConstants.SECONDS_HOUR;\n    const mins = Math.floor(remainder / CoreConstants.SECONDS_MINUTE);\n    const secs = remainder - mins * CoreConstants.SECONDS_MINUTE;\n    const secondsUnit = Translate.instant('core.' + (secs === 1 ? 'sec' : 'secs'));\n    const minutesUnit = Translate.instant('core.' + (mins === 1 ? 'min' : 'mins'));\n    const hoursUnit = Translate.instant('core.' + (hours === 1 ? 'hour' : 'hours'));\n    const daysUnit = Translate.instant('core.' + (days === 1 ? 'day' : 'days'));\n    const yearsUnit = Translate.instant('core.' + (years === 1 ? 'year' : 'years'));\n    const parts = [];\n    if (precision && years) {\n      parts.push(`${years} ${yearsUnit}`);\n      precision--;\n    }\n    if (precision && days) {\n      parts.push(`${days} ${daysUnit}`);\n      precision--;\n    }\n    if (precision && hours) {\n      parts.push(`${hours} ${hoursUnit}`);\n      precision--;\n    }\n    if (precision && mins) {\n      parts.push(`${mins} ${minutesUnit}`);\n      precision--;\n    }\n    if (precision && secs) {\n      parts.push(`${secs} ${secondsUnit}`);\n      precision--;\n    }\n    return parts.join(' ');\n  }\n  /**\n   * Converts a number of seconds into a short human readable format: minutes and seconds, in fromat: 3' 27''.\n   *\n   * @param duration Duration in seconds.\n   * @returns Short human readable text.\n   */\n  static formatTimeShort(duration) {\n    const minutes = Math.floor(duration / 60);\n    const seconds = duration - minutes * 60;\n    const durations = [];\n    if (minutes > 0) {\n      durations.push(minutes + '\\'');\n    }\n    if (seconds > 0 || minutes === 0) {\n      durations.push(seconds + '\\'\\'');\n    }\n    return durations.join(' ');\n  }\n  /**\n   * Wrap a function so that it is called only once.\n   *\n   * @param fn Function.\n   * @returns Wrapper that will call the underlying function only once.\n   */\n  static once(fn) {\n    let called = false;\n    return (...args) => {\n      if (called) {\n        return;\n      }\n      called = true;\n      fn.apply(null, args);\n    };\n  }\n}","map":{"version":3,"names":["Translate","CoreConstants","CoreTime","formatTime","seconds","precision","totalSecs","Math","abs","instant","years","floor","SECONDS_YEAR","remainder","days","SECONDS_DAY","hours","SECONDS_HOUR","mins","SECONDS_MINUTE","secs","secondsUnit","minutesUnit","hoursUnit","daysUnit","yearsUnit","parts","push","join","formatTimeShort","duration","minutes","durations","once","fn","called","args","apply"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/singletons/time.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Translate } from '@singletons';\nimport { CoreConstants } from '../constants';\n\n/**\n * Singleton with helper functions for time operations.\n */\nexport class CoreTime {\n\n    /**\n     * Returns years, months, days, hours, minutes and seconds in a human readable format.\n     *\n     * @param seconds A number of seconds\n     * @param precision Number of elements to have in precision.\n     * @returns Seconds in a human readable format.\n     */\n    static formatTime(seconds: number, precision = 2): string {\n        precision = precision || 5; // Use max precision if 0 is passed.\n\n        const totalSecs = Math.abs(seconds);\n        if (!totalSecs) {\n            return Translate.instant('core.now');\n        }\n\n        const years = Math.floor(totalSecs / CoreConstants.SECONDS_YEAR);\n        let remainder = totalSecs - (years * CoreConstants.SECONDS_YEAR);\n        const days = Math.floor(remainder / CoreConstants.SECONDS_DAY);\n\n        remainder = remainder - (days * CoreConstants.SECONDS_DAY);\n\n        const hours = Math.floor(remainder / CoreConstants.SECONDS_HOUR);\n        remainder = remainder - (hours * CoreConstants.SECONDS_HOUR);\n\n        const mins = Math.floor(remainder / CoreConstants.SECONDS_MINUTE);\n        const secs = remainder - (mins * CoreConstants.SECONDS_MINUTE);\n\n        const secondsUnit = Translate.instant('core.' + (secs === 1 ? 'sec' : 'secs'));\n        const minutesUnit = Translate.instant('core.' + (mins === 1 ? 'min' : 'mins'));\n        const hoursUnit = Translate.instant('core.' + (hours === 1 ? 'hour' : 'hours'));\n        const daysUnit = Translate.instant('core.' + (days === 1 ? 'day' : 'days'));\n        const yearsUnit = Translate.instant('core.' + (years === 1 ? 'year' : 'years'));\n        const parts: string[] = [];\n\n        if (precision && years) {\n            parts.push(`${years} ${yearsUnit}`);\n            precision--;\n        }\n        if (precision && days) {\n            parts.push(`${days} ${daysUnit}`);\n            precision--;\n        }\n        if (precision && hours) {\n            parts.push(`${hours} ${hoursUnit}`);\n            precision--;\n        }\n        if (precision && mins) {\n            parts.push(`${mins} ${minutesUnit}`);\n            precision--;\n        }\n        if (precision && secs) {\n            parts.push(`${secs} ${secondsUnit}`);\n            precision--;\n        }\n\n        return parts.join(' ');\n    }\n\n    /**\n     * Converts a number of seconds into a short human readable format: minutes and seconds, in fromat: 3' 27''.\n     *\n     * @param duration Duration in seconds.\n     * @returns Short human readable text.\n     */\n    static formatTimeShort(duration: number): string {\n        const minutes = Math.floor(duration / 60);\n        const seconds = duration - minutes * 60;\n        const durations = <string[]>[];\n\n        if (minutes > 0) {\n            durations.push(minutes + '\\'');\n        }\n\n        if (seconds > 0 || minutes === 0) {\n            durations.push(seconds + '\\'\\'');\n        }\n\n        return durations.join(' ');\n    }\n\n    /**\n     * Wrap a function so that it is called only once.\n     *\n     * @param fn Function.\n     * @returns Wrapper that will call the underlying function only once.\n     */\n    static once<T extends unknown[]>(fn: (...args: T) => unknown): (...args: T) => void {\n        let called = false;\n\n        return (...args: T) => {\n            if (called) {\n                return;\n            }\n\n            called = true;\n            fn.apply(null, args);\n        };\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}