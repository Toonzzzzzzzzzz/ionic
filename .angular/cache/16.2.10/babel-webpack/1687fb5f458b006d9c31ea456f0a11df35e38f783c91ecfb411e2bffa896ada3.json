{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreInterceptor } from '@classes/interceptor';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreGrades } from '@features/grades/services/grades';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUtils } from '@services/utils/utils';\nimport { AddonModAssignOffline } from './assign-offline';\nimport { AddonModAssignSubmissionDelegate } from './submission-delegate';\nimport { CoreComments } from '@features/comments/services/comments';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { AddonModAssignSyncProvider } from './assign-sync';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreIonicColorNames } from '@singletons/colors';\nimport * as i0 from \"@angular/core\";\nconst ROOT_CACHE_KEY = 'mmaModAssign:';\n/**\n * Service that provides some functions for assign.\n */\nexport class AddonModAssignProvider {\n  /**\n   * Check if the user can submit in offline. This should only be used if submissionStatus.lastattempt.cansubmit cannot\n   * be used (offline usage).\n   * This function doesn't check if the submission is empty, it should be checked before calling this function.\n   *\n   * @param assign Assignment instance.\n   * @param submissionStatus Submission status returned by getSubmissionStatus.\n   * @returns Whether it can submit.\n   */\n  canSubmitOffline(assign, submissionStatus) {\n    var _submissionStatus$las, _submissionStatus$las2;\n    if (!this.isSubmissionOpen(assign, submissionStatus)) {\n      return false;\n    }\n    const userSubmission = (_submissionStatus$las = submissionStatus.lastattempt) === null || _submissionStatus$las === void 0 ? void 0 : _submissionStatus$las.submission;\n    const teamSubmission = (_submissionStatus$las2 = submissionStatus.lastattempt) === null || _submissionStatus$las2 === void 0 ? void 0 : _submissionStatus$las2.teamsubmission;\n    if (teamSubmission) {\n      var _submissionStatus$las3;\n      if (teamSubmission.status === AddonModAssignSubmissionStatusValues.SUBMITTED) {\n        // The assignment submission has been completed.\n        return false;\n      } else if (userSubmission && userSubmission.status === AddonModAssignSubmissionStatusValues.SUBMITTED) {\n        // The user has already clicked the submit button on the team submission.\n        return false;\n      } else if (assign.preventsubmissionnotingroup && !((_submissionStatus$las3 = submissionStatus.lastattempt) !== null && _submissionStatus$las3 !== void 0 && _submissionStatus$las3.submissiongroup)) {\n        return false;\n      }\n    } else if (userSubmission) {\n      if (userSubmission.status === AddonModAssignSubmissionStatusValues.SUBMITTED) {\n        // The assignment submission has been completed.\n        return false;\n      }\n    } else {\n      // No valid submission or team submission.\n      return false;\n    }\n    // Last check is that this instance allows drafts.\n    return !!assign.submissiondrafts;\n  }\n  /**\n   * Fix some submission status params.\n   *\n   * @param site Site to use.\n   * @param userId User Id (empty for current user).\n   * @param groupId Group Id (empty for all participants).\n   * @param isBlind If blind marking is enabled or not.\n   * @returns Object with fixed params.\n   */\n  fixSubmissionStatusParams(site, userId, groupId, isBlind = false) {\n    return {\n      isBlind: !userId ? false : !!isBlind,\n      groupId: groupId || 0,\n      userId: userId || site.getUserId()\n    };\n  }\n  /**\n   * Get an assignment by course module ID.\n   *\n   * @param courseId Course ID the assignment belongs to.\n   * @param cmId Assignment module ID.\n   * @param options Other options.\n   * @returns Promise resolved with the assignment.\n   */\n  getAssignment(courseId, cmId, options = {}) {\n    return this.getAssignmentByField(courseId, 'cmid', cmId, options);\n  }\n  /**\n   * Get an assigment with key=value. If more than one is found, only the first will be returned.\n   *\n   * @param courseId Course ID.\n   * @param key Name of the property to check.\n   * @param value Value to search.\n   * @param options Other options.\n   * @returns Promise resolved when the assignment is retrieved.\n   */\n  getAssignmentByField(courseId, key, value, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        courseids: [courseId],\n        includenotenrolledcourses: true\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this.getAssignmentCacheKey(courseId),\n        updateFrequency: CoreSite.FREQUENCY_RARELY,\n        component: AddonModAssignProvider.COMPONENT\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      let response;\n      try {\n        response = yield site.read('mod_assign_get_assignments', params, preSets);\n      } catch (_unused) {\n        // In 3.6 we added a new parameter includenotenrolledcourses that could cause offline data not to be found.\n        // Retry again without the param to check if the request is already cached.\n        delete params.includenotenrolledcourses;\n        response = yield site.read('mod_assign_get_assignments', params, preSets);\n      }\n      // Search the assignment to return.\n      if (response.courses.length) {\n        const assignment = response.courses[0].assignments.find(assignment => assignment[key] == value);\n        if (assignment) {\n          return assignment;\n        }\n      }\n      throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    })();\n  }\n  /**\n   * Get an assignment by instance ID.\n   *\n   * @param courseId Course ID the assignment belongs to.\n   * @param id Assignment instance ID.\n   * @param options Other options.\n   * @returns Promise resolved with the assignment.\n   */\n  getAssignmentById(courseId, id, options = {}) {\n    return this.getAssignmentByField(courseId, 'id', id, options);\n  }\n  /**\n   * Get cache key for assignment data WS calls.\n   *\n   * @param courseId Course ID.\n   * @returns Cache key.\n   */\n  getAssignmentCacheKey(courseId) {\n    return ROOT_CACHE_KEY + 'assignment:' + courseId;\n  }\n  /**\n   * Get an assignment user mapping for blind marking.\n   *\n   * @param assignId Assignment Id.\n   * @param userId User Id to be blinded.\n   * @param options Other options.\n   * @returns Promise resolved with the user blind id.\n   */\n  getAssignmentUserMappings(assignId, userId, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!userId || userId < 0) {\n        // User not valid, stop.\n        return -1;\n      }\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        assignmentids: [assignId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this2.getAssignmentUserMappingsCacheKey(assignId),\n        updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        component: AddonModAssignProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_assign_get_user_mappings', params, preSets);\n      // Search the user.\n      if (response.assignments.length && response.assignments[0].assignmentid == assignId) {\n        const mapping = response.assignments[0].mappings.find(mapping => mapping.userid == userId);\n        if (mapping) {\n          return mapping.id;\n        }\n      } else if (response.warnings && response.warnings.length) {\n        throw response.warnings[0];\n      }\n      throw new CoreError('Assignment user mappings not found');\n    })();\n  }\n  /**\n   * Get cache key for assignment user mappings data WS calls.\n   *\n   * @param assignId Assignment ID.\n   * @returns Cache key.\n   */\n  getAssignmentUserMappingsCacheKey(assignId) {\n    return ROOT_CACHE_KEY + 'usermappings:' + assignId;\n  }\n  /**\n   * Returns grade information from assign_grades for the requested assignment id\n   *\n   * @param assignId Assignment Id.\n   * @param options Other options.\n   * @returns Resolved with requested info when done.\n   */\n  getAssignmentGrades(assignId, options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        assignmentids: [assignId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this3.getAssignmentGradesCacheKey(assignId),\n        component: AddonModAssignProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_assign_get_grades', params, preSets);\n      // Search the assignment.\n      if (response.assignments.length && response.assignments[0].assignmentid == assignId) {\n        return response.assignments[0].grades;\n      } else if (response.warnings && response.warnings.length) {\n        if (response.warnings[0].warningcode == '3') {\n          // No grades found.\n          return [];\n        }\n        throw response.warnings[0];\n      }\n      throw new CoreError('Assignment grades not found.');\n    })();\n  }\n  /**\n   * Get cache key for assignment grades data WS calls.\n   *\n   * @param assignId Assignment ID.\n   * @returns Cache key.\n   */\n  getAssignmentGradesCacheKey(assignId) {\n    return ROOT_CACHE_KEY + 'assigngrades:' + assignId;\n  }\n  /**\n   * Returns the color name for a given grading status name.\n   *\n   * @param status Grading status name\n   * @returns The color name.\n   */\n  getSubmissionGradingStatusColor(status) {\n    if (!status) {\n      return CoreIonicColorNames.NONE;\n    }\n    if (status == AddonModAssignGradingStates.GRADED || status == AddonModAssignGradingStates.MARKING_WORKFLOW_STATE_RELEASED) {\n      return CoreIonicColorNames.SUCCESS;\n    }\n    return CoreIonicColorNames.DANGER;\n  }\n  /**\n   * Returns the translation id for a given grading status name.\n   *\n   * @param status Grading Status name\n   * @returns The status translation identifier.\n   */\n  getSubmissionGradingStatusTranslationId(status) {\n    if (!status) {\n      return;\n    }\n    if (status == AddonModAssignGradingStates.GRADED || status == AddonModAssignGradingStates.NOT_GRADED || status == AddonModAssignGradingStates.GRADED_FOLLOWUP_SUBMIT) {\n      return 'addon.mod_assign.' + status;\n    }\n    return 'addon.mod_assign.markingworkflowstate' + status;\n  }\n  /**\n   * Get the submission object from an attempt.\n   *\n   * @param assign Assign.\n   * @param attempt Attempt.\n   * @returns Submission object or null.\n   */\n  getSubmissionObjectFromAttempt(assign, attempt) {\n    if (!attempt) {\n      return;\n    }\n    return assign.teamsubmission ? attempt.teamsubmission : attempt.submission;\n  }\n  /**\n   * Get attachments of a submission plugin.\n   *\n   * @param submissionPlugin Submission plugin.\n   * @returns Submission plugin attachments.\n   */\n  getSubmissionPluginAttachments(submissionPlugin) {\n    if (!submissionPlugin.fileareas) {\n      return [];\n    }\n    const files = [];\n    submissionPlugin.fileareas.forEach(filearea => {\n      if (!filearea || !filearea.files) {\n        // No files to get.\n        return;\n      }\n      filearea.files.forEach(file => {\n        if (!file.filename) {\n          // We don't have filename, extract it from the path.\n          file.filename = CoreFileHelper.getFilenameFromPath(file);\n        }\n        files.push(file);\n      });\n    });\n    return files;\n  }\n  /**\n   * Get text of a submission plugin.\n   *\n   * @param submissionPlugin Submission plugin.\n   * @param keepUrls True if it should keep original URLs, false if they should be replaced.\n   * @returns Submission text.\n   */\n  getSubmissionPluginText(submissionPlugin, keepUrls = false) {\n    if (!submissionPlugin.editorfields) {\n      return '';\n    }\n    let text = '';\n    submissionPlugin.editorfields.forEach(field => {\n      text += field.text;\n    });\n    if (!keepUrls && submissionPlugin.fileareas && submissionPlugin.fileareas[0]) {\n      text = CoreTextUtils.replacePluginfileUrls(text, submissionPlugin.fileareas[0].files || []);\n    }\n    return text;\n  }\n  /**\n   * Get an assignment submissions.\n   *\n   * @param assignId Assignment id.\n   * @param options Other options.\n   * @returns Promise resolved when done.\n   */\n  getSubmissions(assignId, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _response$warnings;\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        assignmentids: [assignId]\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this4.getSubmissionsCacheKey(assignId),\n        updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        component: AddonModAssignProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      const response = yield site.read('mod_assign_get_submissions', params, preSets);\n      // Check if we can view submissions, with enough permissions.\n      if ((_response$warnings = response.warnings) !== null && _response$warnings !== void 0 && _response$warnings.length && response.warnings[0].warningcode == '1') {\n        return {\n          canviewsubmissions: false\n        };\n      }\n      if (response.assignments && response.assignments.length) {\n        return {\n          canviewsubmissions: true,\n          submissions: response.assignments[0].submissions\n        };\n      }\n      throw new CoreError('Assignment submissions not found');\n    })();\n  }\n  /**\n   * Get cache key for assignment submissions data WS calls.\n   *\n   * @param assignId Assignment id.\n   * @returns Cache key.\n   */\n  getSubmissionsCacheKey(assignId) {\n    return ROOT_CACHE_KEY + 'submissions:' + assignId;\n  }\n  /**\n   * Get information about an assignment submission status for a given user.\n   *\n   * @param assignId Assignment instance id.\n   * @param options Other options.\n   * @returns Promise always resolved with the user submission status.\n   */\n  getSubmissionStatus(assignId, options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(options.siteId);\n      options = _objectSpread({\n        filter: true\n      }, options);\n      const fixedParams = _this5.fixSubmissionStatusParams(site, options.userId, options.groupId, options.isBlind);\n      const params = {\n        assignid: assignId,\n        userid: fixedParams.userId\n      };\n      if (fixedParams.groupId) {\n        params.groupid = fixedParams.groupId;\n      }\n      const preSets = _objectSpread({\n        cacheKey: _this5.getSubmissionStatusCacheKey(assignId, fixedParams.userId, fixedParams.groupId, fixedParams.isBlind),\n        getCacheUsingCacheKey: true,\n        filter: options.filter,\n        rewriteurls: options.filter,\n        component: AddonModAssignProvider.COMPONENT,\n        componentId: options.cmId,\n        // Don't cache when getting text without filters.\n        // @todo Change this to support offline editing.\n        saveToCache: options.filter\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_assign_get_submission_status', params, preSets);\n    })();\n  }\n  /**\n   * Get information about an assignment submission status for a given user.\n   * If the data doesn't include the user submission, retry ignoring cache.\n   *\n   * @param assign Assignment.\n   * @param options Other options.\n   * @returns Promise always resolved with the user submission status.\n   */\n  getSubmissionStatusWithRetry(assign, options = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      options.cmId = options.cmId || assign.cmid;\n      const response = yield _this6.getSubmissionStatus(assign.id, options);\n      const userSubmission = _this6.getSubmissionObjectFromAttempt(assign, response.lastattempt);\n      if (userSubmission) {\n        return response;\n      }\n      // Try again, ignoring cache.\n      const newOptions = _objectSpread(_objectSpread({}, options), {}, {\n        readingStrategy: 2 /* CoreSitesReadingStrategy.ONLY_NETWORK */\n      });\n\n      try {\n        return yield _this6.getSubmissionStatus(assign.id, newOptions);\n      } catch (_unused2) {\n        // Error, return the first result even if it doesn't have the user submission.\n        return response;\n      }\n    })();\n  }\n  /**\n   * Get cache key for get submission status data WS calls.\n   *\n   * @param assignId Assignment instance id.\n   * @param userId User id (empty for current user).\n   * @param groupId Group Id (empty for all participants).\n   * @param isBlind If blind marking is enabled or not.\n   * @returns Cache key.\n   */\n  getSubmissionStatusCacheKey(assignId, userId, groupId, isBlind = false) {\n    return this.getSubmissionsCacheKey(assignId) + ':' + userId + ':' + (isBlind ? 1 : 0) + ':' + groupId;\n  }\n  /**\n   * Returns the color name for a given status name.\n   *\n   * @param status Status name\n   * @returns The color name.\n   */\n  getSubmissionStatusColor(status) {\n    switch (status) {\n      case AddonModAssignSubmissionStatusValues.SUBMITTED:\n        return CoreIonicColorNames.SUCCESS;\n      case AddonModAssignSubmissionStatusValues.DRAFT:\n        return CoreIonicColorNames.INFO;\n      case AddonModAssignSubmissionStatusValues.NEW:\n      case AddonModAssignSubmissionStatusValues.NO_ATTEMPT:\n      case AddonModAssignSubmissionStatusValues.NO_ONLINE_SUBMISSIONS:\n      case AddonModAssignSubmissionStatusValues.NO_SUBMISSION:\n      case AddonModAssignSubmissionStatusValues.GRADED_FOLLOWUP_SUBMIT:\n        return CoreIonicColorNames.DANGER;\n      default:\n        return CoreIonicColorNames.LIGHT;\n    }\n  }\n  /**\n   * Given a list of plugins, returns the plugin names that aren't supported for editing.\n   *\n   * @param plugins Plugins to check.\n   * @returns Promise resolved with unsupported plugin names.\n   */\n  getUnsupportedEditPlugins(plugins) {\n    return _asyncToGenerator(function* () {\n      const notSupported = [];\n      const promises = plugins.map(plugin => AddonModAssignSubmissionDelegate.isPluginSupportedForEdit(plugin.type).then(enabled => {\n        if (!enabled) {\n          notSupported.push(plugin.name);\n        }\n        return;\n      }));\n      yield Promise.all(promises);\n      return notSupported;\n    })();\n  }\n  /**\n   * List the participants for a single assignment, with some summary info about their submissions.\n   *\n   * @param assignId Assignment id.\n   * @param groupId Group id. If not defined, 0.\n   * @param options Other options.\n   * @returns Promise resolved with the list of participants and summary of submissions.\n   */\n  listParticipants(assignId, groupId, options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      groupId = groupId || 0;\n      const site = yield CoreSites.getSite(options.siteId);\n      const params = {\n        assignid: assignId,\n        groupid: groupId,\n        filter: ''\n      };\n      const preSets = _objectSpread({\n        cacheKey: _this7.listParticipantsCacheKey(assignId, groupId),\n        updateFrequency: CoreSite.FREQUENCY_OFTEN,\n        component: AddonModAssignProvider.COMPONENT,\n        componentId: options.cmId\n      }, CoreSites.getReadingStrategyPreSets(options.readingStrategy));\n      return site.read('mod_assign_list_participants', params, preSets);\n    })();\n  }\n  /**\n   * Get cache key for assignment list participants data WS calls.\n   *\n   * @param assignId Assignment id.\n   * @param groupId Group id.\n   * @returns Cache key.\n   */\n  listParticipantsCacheKey(assignId, groupId) {\n    return this.listParticipantsPrefixCacheKey(assignId) + ':' + groupId;\n  }\n  /**\n   * Get prefix cache key for assignment list participants data WS calls.\n   *\n   * @param assignId Assignment id.\n   * @returns Cache key.\n   */\n  listParticipantsPrefixCacheKey(assignId) {\n    return ROOT_CACHE_KEY + 'participants:' + assignId;\n  }\n  /**\n   * Invalidates all submission status data.\n   *\n   * @param assignId Assignment instance id.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAllSubmissionData(assignId, siteId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this8.getSubmissionsCacheKey(assignId));\n    })();\n  }\n  /**\n   * Invalidates assignment data WS calls.\n   *\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAssignmentData(courseId, siteId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this9.getAssignmentCacheKey(courseId));\n    })();\n  }\n  /**\n   * Invalidates assignment user mappings data WS calls.\n   *\n   * @param assignId Assignment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAssignmentUserMappingsData(assignId, siteId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this10.getAssignmentUserMappingsCacheKey(assignId));\n    })();\n  }\n  /**\n   * Invalidates assignment grades data WS calls.\n   *\n   * @param assignId Assignment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateAssignmentGradesData(assignId, siteId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this11.getAssignmentGradesCacheKey(assignId));\n    })();\n  }\n  /**\n   * Invalidate the prefetched content except files.\n   *\n   * @param moduleId The module ID.\n   * @param courseId Course ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateContent(moduleId, courseId, siteId) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      const assign = yield _this12.getAssignment(courseId, moduleId, {\n        siteId\n      });\n      const promises = [];\n      // Do not invalidate assignment data before getting assignment info, we need it!\n      promises.push(_this12.invalidateAllSubmissionData(assign.id, siteId));\n      promises.push(_this12.invalidateAssignmentUserMappingsData(assign.id, siteId));\n      promises.push(_this12.invalidateAssignmentGradesData(assign.id, siteId));\n      promises.push(_this12.invalidateListParticipantsData(assign.id, siteId));\n      promises.push(CoreComments.invalidateCommentsByInstance('module', assign.id, siteId));\n      promises.push(_this12.invalidateAssignmentData(courseId, siteId));\n      promises.push(CoreGrades.invalidateAllCourseGradesData(courseId));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Invalidates assignment submissions data WS calls.\n   *\n   * @param assignId Assignment instance id.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateSubmissionData(assignId, siteId) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKey(_this13.getSubmissionsCacheKey(assignId));\n    })();\n  }\n  /**\n   * Invalidates submission status data.\n   *\n   * @param assignId Assignment instance id.\n   * @param userId User id (empty for current user).\n   * @param groupId Group Id (empty for all participants).\n   * @param isBlind Whether blind marking is enabled or not.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateSubmissionStatusData(assignId, userId, groupId, isBlind = false, siteId) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const fixedParams = _this14.fixSubmissionStatusParams(site, userId, groupId, isBlind);\n      yield site.invalidateWsCacheForKey(_this14.getSubmissionStatusCacheKey(assignId, fixedParams.userId, fixedParams.groupId, fixedParams.isBlind));\n    })();\n  }\n  /**\n   * Invalidates assignment participants data.\n   *\n   * @param assignId Assignment instance id.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateListParticipantsData(assignId, siteId) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      yield site.invalidateWsCacheForKeyStartingWith(_this15.listParticipantsPrefixCacheKey(assignId));\n    })();\n  }\n  /**\n   * Check if a submission is open. This function is based on Moodle's submissions_open.\n   *\n   * @param assign Assignment instance.\n   * @param submissionStatus Submission status returned by getSubmissionStatus.\n   * @returns Whether submission is open.\n   */\n  isSubmissionOpen(assign, submissionStatus) {\n    if (!assign || !submissionStatus) {\n      return false;\n    }\n    const time = CoreTimeUtils.timestamp();\n    const lastAttempt = submissionStatus.lastattempt;\n    const submission = this.getSubmissionObjectFromAttempt(assign, lastAttempt);\n    let dateOpen = true;\n    let finalDate;\n    if (assign.cutoffdate) {\n      finalDate = assign.cutoffdate;\n    }\n    if (lastAttempt && lastAttempt.locked) {\n      return false;\n    }\n    // User extensions.\n    if (finalDate) {\n      if (lastAttempt && lastAttempt.extensionduedate) {\n        // Extension can be before cut off date.\n        if (lastAttempt.extensionduedate > finalDate) {\n          finalDate = lastAttempt.extensionduedate;\n        }\n      }\n    }\n    if (finalDate) {\n      dateOpen = assign.allowsubmissionsfromdate <= time && time <= finalDate;\n    } else {\n      dateOpen = assign.allowsubmissionsfromdate <= time;\n    }\n    if (!dateOpen) {\n      return false;\n    }\n    if (submission) {\n      if (assign.submissiondrafts && submission.status == AddonModAssignSubmissionStatusValues.SUBMITTED) {\n        // Drafts are tracked and the student has submitted the assignment.\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Report an assignment submission as being viewed.\n   *\n   * @param assignid Assignment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logSubmissionView(assignid, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        assignid\n      };\n      yield CoreCourseLogHelper.log('mod_assign_view_submission_status', params, AddonModAssignProvider.COMPONENT, assignid, siteId);\n    })();\n  }\n  /**\n   * Report an assignment grading table is being viewed.\n   *\n   * @param assignid Assignment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logGradingView(assignid, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        assignid\n      };\n      yield CoreCourseLogHelper.log('mod_assign_view_grading_table', params, AddonModAssignProvider.COMPONENT, assignid, siteId);\n    })();\n  }\n  /**\n   * Report an assign as being viewed.\n   *\n   * @param assignid Assignment ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the WS call is successful.\n   */\n  logView(assignid, siteId) {\n    return _asyncToGenerator(function* () {\n      const params = {\n        assignid\n      };\n      yield CoreCourseLogHelper.log('mod_assign_view_assign', params, AddonModAssignProvider.COMPONENT, assignid, siteId);\n    })();\n  }\n  /**\n   * Returns if a submissions needs to be graded.\n   *\n   * @param submission Submission.\n   * @param assignId Assignment ID.\n   * @returns Promise resolved with boolean: whether it needs to be graded or not.\n   */\n  needsSubmissionToBeGraded(submission, assignId) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      if (submission.status != AddonModAssignSubmissionStatusValues.SUBMITTED) {\n        return false;\n      }\n      if (!submission.gradingstatus) {\n        // This should not happen, but it's better to show rather than not showing any of the submissions.\n        return true;\n      }\n      if (submission.gradingstatus != AddonModAssignGradingStates.GRADED && submission.gradingstatus != AddonModAssignGradingStates.MARKING_WORKFLOW_STATE_RELEASED) {\n        // Not graded.\n        return true;\n      }\n      // We need more data to decide that.\n      const response = yield _this16.getSubmissionStatus(assignId, {\n        userId: submission.submitid,\n        isBlind: !!submission.blindid\n      });\n      if (!response.feedback || !response.feedback.gradeddate) {\n        // Not graded.\n        return true;\n      }\n      return response.feedback.gradeddate < submission.timemodified;\n    })();\n  }\n  /**\n   * Save current user submission for a certain assignment.\n   *\n   * @param assignId Assign ID.\n   * @param courseId Course ID the assign belongs to.\n   * @param pluginData Data to save.\n   * @param allowOffline Whether to allow offline usage.\n   * @param timemodified The time the submission was last modified in online.\n   * @param allowsDrafts Whether the assignment allows submission drafts.\n   * @param userId User ID. If not defined, site's current user.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if sent to server, resolved with false if stored in offline.\n   */\n  saveSubmission(assignId, courseId, pluginData, allowOffline, timemodified, allowsDrafts = false, userId, siteId) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Function to store the submission to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          yield AddonModAssignOffline.saveSubmission(assignId, courseId, pluginData, timemodified, !allowsDrafts, userId, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      if (allowOffline && !CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        // If there's already a submission to be sent to the server, discard it first.\n        yield AddonModAssignOffline.deleteSubmission(assignId, userId, siteId);\n        yield _this17.saveSubmissionOnline(assignId, pluginData, siteId);\n        return true;\n      } catch (error) {\n        if (allowOffline && error && !CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server, store in offline.\n          return storeOffline();\n        } else {\n          // The WebService has thrown an error or offline not supported, reject.\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Save current user submission for a certain assignment. It will fail if offline or cannot connect.\n   *\n   * @param assignId Assign ID.\n   * @param pluginData Data to save.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when saved, rejected otherwise.\n   */\n  saveSubmissionOnline(assignId, pluginData, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        assignmentid: assignId,\n        plugindata: pluginData\n      };\n      const warnings = yield site.write('mod_assign_save_submission', params);\n      if (warnings.length) {\n        // The WebService returned warnings, reject.\n        throw new CoreWSError(warnings[0]);\n      }\n    })();\n  }\n  /**\n   * Start a submission.\n   *\n   * @param assignId Assign ID.\n   * @param siteId Site ID. If not defined, use current site.\n   * @returns Promise resolved when done.\n   */\n  startSubmission(assignId, siteId) {\n    return _asyncToGenerator(function* () {\n      var _result$warnings;\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        assignid: assignId\n      };\n      const result = yield site.write('mod_assign_start_submission', params);\n      if (!((_result$warnings = result.warnings) !== null && _result$warnings !== void 0 && _result$warnings.length)) {\n        return;\n      }\n      // Ignore some warnings.\n      const warning = result.warnings.find(warning => warning.warningcode !== 'timelimitnotenabled' && warning.warningcode !== 'opensubmissionexists');\n      if (warning) {\n        throw new CoreWSError(warning);\n      }\n    })();\n  }\n  /**\n   * Submit the current user assignment for grading.\n   *\n   * @param assignId Assign ID.\n   * @param courseId Course ID the assign belongs to.\n   * @param acceptStatement True if submission statement is accepted, false otherwise.\n   * @param timemodified The time the submission was last modified in online.\n   * @param forceOffline True to always mark it in offline.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if sent to server, resolved with false if stored in offline.\n   */\n  submitForGrading(assignId, courseId, acceptStatement, timemodified, forceOffline = false, siteId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Function to store the submission to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          yield AddonModAssignOffline.markSubmitted(assignId, courseId, true, acceptStatement, timemodified, undefined, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      if (forceOffline || !CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        // If there's already a submission to be sent to the server, discard it first.\n        yield AddonModAssignOffline.deleteSubmission(assignId, undefined, siteId);\n        yield _this18.submitForGradingOnline(assignId, acceptStatement, siteId);\n        return true;\n      } catch (error) {\n        if (error && !CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server, store in offline.\n          return storeOffline();\n        } else {\n          // The WebService has thrown an error, reject.\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Submit the current user assignment for grading. It will fail if offline or cannot connect.\n   *\n   * @param assignId Assign ID.\n   * @param acceptStatement True if submission statement is accepted, false otherwise.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when submitted, rejected otherwise.\n   */\n  submitForGradingOnline(assignId, acceptStatement, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const params = {\n        assignmentid: assignId,\n        acceptsubmissionstatement: acceptStatement\n      };\n      const warnings = yield site.write('mod_assign_submit_for_grading', params);\n      if (warnings.length) {\n        // The WebService returned warnings, reject.\n        throw new CoreWSError(warnings[0]);\n      }\n    })();\n  }\n  /**\n   * Submit the grading for the current user and assignment. It will use old or new WS depending on availability.\n   *\n   * @param assignId Assign ID.\n   * @param userId User ID.\n   * @param courseId Course ID the assign belongs to.\n   * @param grade Grade to submit.\n   * @param attemptNumber Number of the attempt being graded.\n   * @param addAttempt Admit the user to attempt again.\n   * @param workflowState Next workflow State.\n   * @param applyToAll If it's a team submission, whether the grade applies to all group members.\n   * @param outcomes Object including all outcomes values. If empty, any of them will be sent.\n   * @param pluginData Feedback plugin data to save.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with true if sent to server, resolved with false if stored offline.\n   */\n  submitGradingForm(assignId, userId, courseId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      // Function to store the grading to be synchronized later.\n      const storeOffline = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* () {\n          yield AddonModAssignOffline.submitGradingForm(assignId, userId, courseId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId);\n          return false;\n        });\n        return function storeOffline() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      if (!CoreNetwork.isOnline()) {\n        // App is offline, store the action.\n        return storeOffline();\n      }\n      try {\n        // If there's already a grade to be sent to the server, discard it first.\n        yield AddonModAssignOffline.deleteSubmissionGrade(assignId, userId, siteId);\n        yield _this19.submitGradingFormOnline(assignId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId);\n        return true;\n      } catch (error) {\n        if (error && !CoreUtils.isWebServiceError(error)) {\n          // Couldn't connect to server, store in offline.\n          return storeOffline();\n        } else {\n          // The WebService has thrown an error, reject.\n          throw error;\n        }\n      }\n    })();\n  }\n  /**\n   * Submit the grading for the current user and assignment. It will use old or new WS depending on availability.\n   * It will fail if offline or cannot connect.\n   *\n   * @param assignId Assign ID.\n   * @param userId User ID.\n   * @param grade Grade to submit.\n   * @param attemptNumber Number of the attempt being graded.\n   * @param addAttempt Allow the user to attempt again.\n   * @param workflowState Next workflow State.\n   * @param applyToAll If it's a team submission, if the grade applies to all group members.\n   * @param outcomes Object including all outcomes values. If empty, any of them will be sent.\n   * @param pluginData Feedback plugin data to save.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when submitted, rejected otherwise.\n   */\n  submitGradingFormOnline(assignId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      userId = userId || site.getUserId();\n      const jsonData = {\n        grade,\n        attemptnumber: attemptNumber,\n        addattempt: addAttempt ? 1 : 0,\n        workflowstate: workflowState,\n        applytoall: applyToAll ? 1 : 0\n      };\n      for (const index in outcomes) {\n        jsonData['outcome_' + index + '[' + userId + ']'] = outcomes[index];\n      }\n      for (const index in pluginData) {\n        jsonData[index] = pluginData[index];\n      }\n      const serialized = CoreInterceptor.serialize(jsonData, true);\n      const params = {\n        assignmentid: assignId,\n        userid: userId,\n        jsonformdata: JSON.stringify(serialized)\n      };\n      const warnings = yield site.write('mod_assign_submit_grading_form', params);\n      if (warnings.length) {\n        // The WebService returned warnings, reject.\n        throw new CoreWSError(warnings[0]);\n      }\n    })();\n  }\n}\n_class = AddonModAssignProvider;\n_class.COMPONENT = 'mmaModAssign';\n_class.SUBMISSION_COMPONENT = 'mmaModAssignSubmission';\n_class.UNLIMITED_ATTEMPTS = -1;\n// Group submissions warnings.\n_class.WARN_GROUPS_REQUIRED = 'warnrequired';\n_class.WARN_GROUPS_OPTIONAL = 'warnoptional';\n// Events.\n_class.SUBMISSION_SAVED_EVENT = 'addon_mod_assign_submission_saved';\n_class.SUBMITTED_FOR_GRADING_EVENT = 'addon_mod_assign_submitted_for_grading';\n_class.GRADED_EVENT = 'addon_mod_assign_graded';\n_class.STARTED_EVENT = 'addon_mod_assign_started';\n_class.ɵfac = function AddonModAssignProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonModAssign = makeSingleton(AddonModAssignProvider);\n/**\n * Submission status.\n * Constants on LMS starting with ASSIGN_SUBMISSION_STATUS_\n */\nexport var AddonModAssignSubmissionStatusValues;\n(function (AddonModAssignSubmissionStatusValues) {\n  AddonModAssignSubmissionStatusValues[\"SUBMITTED\"] = \"submitted\";\n  AddonModAssignSubmissionStatusValues[\"DRAFT\"] = \"draft\";\n  AddonModAssignSubmissionStatusValues[\"NEW\"] = \"new\";\n  AddonModAssignSubmissionStatusValues[\"REOPENED\"] = \"reopened\";\n  // Added by App Statuses.\n  AddonModAssignSubmissionStatusValues[\"NO_ATTEMPT\"] = \"noattempt\";\n  AddonModAssignSubmissionStatusValues[\"NO_ONLINE_SUBMISSIONS\"] = \"noonlinesubmissions\";\n  AddonModAssignSubmissionStatusValues[\"NO_SUBMISSION\"] = \"nosubmission\";\n  AddonModAssignSubmissionStatusValues[\"GRADED_FOLLOWUP_SUBMIT\"] = \"gradedfollowupsubmit\";\n})(AddonModAssignSubmissionStatusValues || (AddonModAssignSubmissionStatusValues = {}));\n/**\n * Grading status.\n * Constants on LMS starting with ASSIGN_GRADING_STATUS_\n */\nexport var AddonModAssignGradingStates;\n(function (AddonModAssignGradingStates) {\n  AddonModAssignGradingStates[\"GRADED\"] = \"graded\";\n  AddonModAssignGradingStates[\"NOT_GRADED\"] = \"notgraded\";\n  // Added by App Statuses.\n  AddonModAssignGradingStates[\"MARKING_WORKFLOW_STATE_RELEASED\"] = \"released\";\n  AddonModAssignGradingStates[\"GRADED_FOLLOWUP_SUBMIT\"] = \"gradedfollowupsubmit\";\n})(AddonModAssignGradingStates || (AddonModAssignGradingStates = {}));\n/**\n * Reopen attempt methods.\n * Constants on LMS starting with ASSIGN_ATTEMPT_REOPEN_METHOD_\n */\nexport var AddonModAssignAttemptReopenMethodValues;\n(function (AddonModAssignAttemptReopenMethodValues) {\n  AddonModAssignAttemptReopenMethodValues[\"NONE\"] = \"none\";\n  AddonModAssignAttemptReopenMethodValues[\"MANUAL\"] = \"manual\";\n  AddonModAssignAttemptReopenMethodValues[\"UNTILPASS\"] = \"untilpass\";\n})(AddonModAssignAttemptReopenMethodValues || (AddonModAssignAttemptReopenMethodValues = {}));","map":{"version":3,"names":["CoreSites","CoreSitesReadingStrategy","CoreSite","CoreInterceptor","makeSingleton","Translate","CoreTextUtils","CoreGrades","CoreTimeUtils","CoreCourseLogHelper","CoreError","CoreNetwork","CoreUtils","AddonModAssignOffline","AddonModAssignSubmissionDelegate","CoreComments","CoreWSError","AddonModAssignSyncProvider","CoreFileHelper","CoreIonicColorNames","ROOT_CACHE_KEY","AddonModAssignProvider","canSubmitOffline","assign","submissionStatus","_submissionStatus$las","_submissionStatus$las2","isSubmissionOpen","userSubmission","lastattempt","submission","teamSubmission","teamsubmission","_submissionStatus$las3","status","AddonModAssignSubmissionStatusValues","SUBMITTED","preventsubmissionnotingroup","submissiongroup","submissiondrafts","fixSubmissionStatusParams","site","userId","groupId","isBlind","getUserId","getAssignment","courseId","cmId","options","getAssignmentByField","key","value","_this","_asyncToGenerator","getSite","siteId","params","courseids","includenotenrolledcourses","preSets","_objectSpread","cacheKey","getAssignmentCacheKey","updateFrequency","FREQUENCY_RARELY","component","COMPONENT","getReadingStrategyPreSets","readingStrategy","response","read","_unused","courses","length","assignment","assignments","find","instant","getAssignmentById","id","getAssignmentUserMappings","assignId","_this2","assignmentids","getAssignmentUserMappingsCacheKey","FREQUENCY_OFTEN","componentId","assignmentid","mapping","mappings","userid","warnings","getAssignmentGrades","_this3","getAssignmentGradesCacheKey","grades","warningcode","getSubmissionGradingStatusColor","NONE","AddonModAssignGradingStates","GRADED","MARKING_WORKFLOW_STATE_RELEASED","SUCCESS","DANGER","getSubmissionGradingStatusTranslationId","NOT_GRADED","GRADED_FOLLOWUP_SUBMIT","getSubmissionObjectFromAttempt","attempt","getSubmissionPluginAttachments","submissionPlugin","fileareas","files","forEach","filearea","file","filename","getFilenameFromPath","push","getSubmissionPluginText","keepUrls","editorfields","text","field","replacePluginfileUrls","getSubmissions","_this4","_response$warnings","getSubmissionsCacheKey","canviewsubmissions","submissions","getSubmissionStatus","_this5","filter","fixedParams","assignid","groupid","getSubmissionStatusCacheKey","getCacheUsingCacheKey","rewriteurls","saveToCache","getSubmissionStatusWithRetry","_this6","cmid","newOptions","_unused2","getSubmissionStatusColor","DRAFT","INFO","NEW","NO_ATTEMPT","NO_ONLINE_SUBMISSIONS","NO_SUBMISSION","LIGHT","getUnsupportedEditPlugins","plugins","notSupported","promises","map","plugin","isPluginSupportedForEdit","type","then","enabled","name","Promise","all","listParticipants","_this7","listParticipantsCacheKey","listParticipantsPrefixCacheKey","invalidateAllSubmissionData","_this8","invalidateWsCacheForKeyStartingWith","invalidateAssignmentData","_this9","invalidateWsCacheForKey","invalidateAssignmentUserMappingsData","_this10","invalidateAssignmentGradesData","_this11","invalidateContent","moduleId","_this12","getCurrentSiteId","invalidateListParticipantsData","invalidateCommentsByInstance","invalidateAllCourseGradesData","invalidateSubmissionData","_this13","invalidateSubmissionStatusData","_this14","_this15","time","timestamp","lastAttempt","dateOpen","finalDate","cutoffdate","locked","extensionduedate","allowsubmissionsfromdate","logSubmissionView","log","logGradingView","logView","needsSubmissionToBeGraded","_this16","gradingstatus","submitid","blindid","feedback","gradeddate","timemodified","saveSubmission","pluginData","allowOffline","allowsDrafts","_this17","storeOffline","_ref","apply","arguments","isOnline","deleteSubmission","saveSubmissionOnline","error","isWebServiceError","plugindata","write","startSubmission","_result$warnings","result","warning","submitForGrading","acceptStatement","forceOffline","_this18","_ref2","markSubmitted","undefined","submitForGradingOnline","acceptsubmissionstatement","submitGradingForm","grade","attemptNumber","addAttempt","workflowState","applyToAll","outcomes","_this19","_ref3","deleteSubmissionGrade","submitGradingFormOnline","jsonData","attemptnumber","addattempt","workflowstate","applytoall","index","serialized","serialize","jsonformdata","JSON","stringify","_class","SUBMISSION_COMPONENT","UNLIMITED_ATTEMPTS","WARN_GROUPS_REQUIRED","WARN_GROUPS_OPTIONAL","SUBMISSION_SAVED_EVENT","SUBMITTED_FOR_GRADING_EVENT","GRADED_EVENT","STARTED_EVENT","factory","ɵfac","providedIn","AddonModAssign","AddonModAssignAttemptReopenMethodValues"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/mod/assign/services/assign.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites, CoreSitesCommonWSOptions, CoreSitesReadingStrategy } from '@services/sites';\nimport { CoreSite } from '@classes/sites/site';\nimport { CoreInterceptor } from '@classes/interceptor';\nimport { CoreWSExternalWarning, CoreWSExternalFile, CoreWSFile } from '@services/ws';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreCourseCommonModWSOptions } from '@features/course/services/course';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreGrades } from '@features/grades/services/grades';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreCourseLogHelper } from '@features/course/services/log-helper';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreNetwork } from '@services/network';\nimport { CoreUtils } from '@services/utils/utils';\nimport { AddonModAssignOffline } from './assign-offline';\nimport { AddonModAssignSubmissionDelegate } from './submission-delegate';\nimport { CoreComments } from '@features/comments/services/comments';\nimport { AddonModAssignSubmissionFormatted } from './assign-helper';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { AddonModAssignAutoSyncData, AddonModAssignManualSyncData, AddonModAssignSyncProvider } from './assign-sync';\nimport { CoreFormFields } from '@singletons/form';\nimport { CoreFileHelper } from '@services/file-helper';\nimport { CoreIonicColorNames } from '@singletons/colors';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\nconst ROOT_CACHE_KEY = 'mmaModAssign:';\n\ndeclare module '@singletons/events' {\n\n    /**\n     * Augment CoreEventsData interface with events specific to this service.\n     *\n     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\n     */\n    export interface CoreEventsData {\n        [AddonModAssignProvider.SUBMISSION_SAVED_EVENT]: AddonModAssignSubmissionSavedEventData;\n        [AddonModAssignProvider.SUBMITTED_FOR_GRADING_EVENT]: AddonModAssignSubmittedForGradingEventData;\n        [AddonModAssignProvider.GRADED_EVENT]: AddonModAssignGradedEventData;\n        [AddonModAssignProvider.STARTED_EVENT]: AddonModAssignStartedEventData;\n        [AddonModAssignSyncProvider.MANUAL_SYNCED]: AddonModAssignManualSyncData;\n        [AddonModAssignSyncProvider.AUTO_SYNCED]: AddonModAssignAutoSyncData;\n    }\n\n}\n\n/**\n * Service that provides some functions for assign.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonModAssignProvider {\n\n    static readonly COMPONENT = 'mmaModAssign';\n    static readonly SUBMISSION_COMPONENT = 'mmaModAssignSubmission';\n    static readonly UNLIMITED_ATTEMPTS = -1;\n\n    // Group submissions warnings.\n    static readonly WARN_GROUPS_REQUIRED = 'warnrequired';\n    static readonly WARN_GROUPS_OPTIONAL = 'warnoptional';\n\n    // Events.\n    static readonly SUBMISSION_SAVED_EVENT = 'addon_mod_assign_submission_saved';\n    static readonly SUBMITTED_FOR_GRADING_EVENT = 'addon_mod_assign_submitted_for_grading';\n    static readonly GRADED_EVENT = 'addon_mod_assign_graded';\n    static readonly STARTED_EVENT = 'addon_mod_assign_started';\n\n    /**\n     * Check if the user can submit in offline. This should only be used if submissionStatus.lastattempt.cansubmit cannot\n     * be used (offline usage).\n     * This function doesn't check if the submission is empty, it should be checked before calling this function.\n     *\n     * @param assign Assignment instance.\n     * @param submissionStatus Submission status returned by getSubmissionStatus.\n     * @returns Whether it can submit.\n     */\n    canSubmitOffline(assign: AddonModAssignAssign, submissionStatus: AddonModAssignGetSubmissionStatusWSResponse): boolean {\n        if (!this.isSubmissionOpen(assign, submissionStatus)) {\n            return false;\n        }\n\n        const userSubmission = submissionStatus.lastattempt?.submission;\n        const teamSubmission = submissionStatus.lastattempt?.teamsubmission;\n\n        if (teamSubmission) {\n            if (teamSubmission.status === AddonModAssignSubmissionStatusValues.SUBMITTED) {\n                // The assignment submission has been completed.\n                return false;\n            } else if (userSubmission && userSubmission.status === AddonModAssignSubmissionStatusValues.SUBMITTED) {\n                // The user has already clicked the submit button on the team submission.\n                return false;\n            } else if (assign.preventsubmissionnotingroup && !submissionStatus.lastattempt?.submissiongroup) {\n                return false;\n            }\n        } else if (userSubmission) {\n            if (userSubmission.status === AddonModAssignSubmissionStatusValues.SUBMITTED) {\n                // The assignment submission has been completed.\n                return false;\n            }\n        } else {\n            // No valid submission or team submission.\n            return false;\n        }\n\n        // Last check is that this instance allows drafts.\n        return !!assign.submissiondrafts;\n    }\n\n    /**\n     * Fix some submission status params.\n     *\n     * @param site Site to use.\n     * @param userId User Id (empty for current user).\n     * @param groupId Group Id (empty for all participants).\n     * @param isBlind If blind marking is enabled or not.\n     * @returns Object with fixed params.\n     */\n    protected fixSubmissionStatusParams(\n        site: CoreSite,\n        userId?: number,\n        groupId?: number,\n        isBlind = false,\n    ): AddonModAssignFixedSubmissionParams {\n\n        return {\n            isBlind: !userId ? false : !!isBlind,\n            groupId: groupId || 0,\n            userId: userId || site.getUserId(),\n        };\n    }\n\n    /**\n     * Get an assignment by course module ID.\n     *\n     * @param courseId Course ID the assignment belongs to.\n     * @param cmId Assignment module ID.\n     * @param options Other options.\n     * @returns Promise resolved with the assignment.\n     */\n    getAssignment(courseId: number, cmId: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModAssignAssign> {\n        return this.getAssignmentByField(courseId, 'cmid', cmId, options);\n    }\n\n    /**\n     * Get an assigment with key=value. If more than one is found, only the first will be returned.\n     *\n     * @param courseId Course ID.\n     * @param key Name of the property to check.\n     * @param value Value to search.\n     * @param options Other options.\n     * @returns Promise resolved when the assignment is retrieved.\n     */\n    protected async getAssignmentByField(\n        courseId: number,\n        key: string,\n        value: number,\n        options: CoreSitesCommonWSOptions = {},\n    ): Promise<AddonModAssignAssign> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModAssignGetAssignmentsWSParams = {\n            courseids: [courseId],\n            includenotenrolledcourses: true,\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAssignmentCacheKey(courseId),\n            updateFrequency: CoreSite.FREQUENCY_RARELY,\n            component: AddonModAssignProvider.COMPONENT,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy), // Include reading strategy preSets.\n        };\n\n        let response: AddonModAssignGetAssignmentsWSResponse;\n\n        try {\n            response = await site.read<AddonModAssignGetAssignmentsWSResponse>('mod_assign_get_assignments', params, preSets);\n        } catch {\n            // In 3.6 we added a new parameter includenotenrolledcourses that could cause offline data not to be found.\n            // Retry again without the param to check if the request is already cached.\n            delete params.includenotenrolledcourses;\n\n            response = await site.read('mod_assign_get_assignments', params, preSets);\n        }\n\n        // Search the assignment to return.\n        if (response.courses.length) {\n            const assignment = response.courses[0].assignments.find((assignment) => assignment[key] == value);\n\n            if (assignment) {\n                return assignment;\n            }\n        }\n\n        throw new CoreError(Translate.instant('core.course.modulenotfound'));\n    }\n\n    /**\n     * Get an assignment by instance ID.\n     *\n     * @param courseId Course ID the assignment belongs to.\n     * @param id Assignment instance ID.\n     * @param options Other options.\n     * @returns Promise resolved with the assignment.\n     */\n    getAssignmentById(courseId: number, id: number, options: CoreSitesCommonWSOptions = {}): Promise<AddonModAssignAssign> {\n        return this.getAssignmentByField(courseId, 'id', id, options);\n    }\n\n    /**\n     * Get cache key for assignment data WS calls.\n     *\n     * @param courseId Course ID.\n     * @returns Cache key.\n     */\n    protected getAssignmentCacheKey(courseId: number): string {\n        return ROOT_CACHE_KEY + 'assignment:' + courseId;\n    }\n\n    /**\n     * Get an assignment user mapping for blind marking.\n     *\n     * @param assignId Assignment Id.\n     * @param userId User Id to be blinded.\n     * @param options Other options.\n     * @returns Promise resolved with the user blind id.\n     */\n    async getAssignmentUserMappings(assignId: number, userId: number, options: CoreCourseCommonModWSOptions = {}): Promise<number> {\n        if (!userId || userId < 0) {\n            // User not valid, stop.\n            return -1;\n        }\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModAssignGetUserMappingsWSParams = {\n            assignmentids: [assignId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAssignmentUserMappingsCacheKey(assignId),\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n            component: AddonModAssignProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        const response = await site.read<AddonModAssignGetUserMappingsWSResponse>('mod_assign_get_user_mappings', params, preSets);\n\n        // Search the user.\n        if (response.assignments.length && response.assignments[0].assignmentid == assignId) {\n            const mapping = response.assignments[0].mappings.find((mapping) => mapping.userid == userId);\n\n            if (mapping) {\n                return mapping.id;\n            }\n        } else if (response.warnings && response.warnings.length) {\n            throw response.warnings[0];\n        }\n\n        throw new CoreError('Assignment user mappings not found');\n    }\n\n    /**\n     * Get cache key for assignment user mappings data WS calls.\n     *\n     * @param assignId Assignment ID.\n     * @returns Cache key.\n     */\n    protected getAssignmentUserMappingsCacheKey(assignId: number): string {\n        return ROOT_CACHE_KEY + 'usermappings:' + assignId;\n    }\n\n    /**\n     * Returns grade information from assign_grades for the requested assignment id\n     *\n     * @param assignId Assignment Id.\n     * @param options Other options.\n     * @returns Resolved with requested info when done.\n     */\n    async getAssignmentGrades(assignId: number, options: CoreCourseCommonModWSOptions = {}): Promise<AddonModAssignGrade[]> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModAssignGetGradesWSParams = {\n            assignmentids: [assignId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getAssignmentGradesCacheKey(assignId),\n            component: AddonModAssignProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        const response = await site.read<AddonModAssignGetGradesWSResponse>('mod_assign_get_grades', params, preSets);\n\n        // Search the assignment.\n        if (response.assignments.length && response.assignments[0].assignmentid == assignId) {\n            return response.assignments[0].grades;\n        } else if (response.warnings && response.warnings.length) {\n            if (response.warnings[0].warningcode == '3') {\n                // No grades found.\n                return [];\n            }\n\n            throw response.warnings[0];\n        }\n\n        throw new CoreError('Assignment grades not found.');\n    }\n\n    /**\n     * Get cache key for assignment grades data WS calls.\n     *\n     * @param assignId Assignment ID.\n     * @returns Cache key.\n     */\n    protected getAssignmentGradesCacheKey(assignId: number): string {\n        return ROOT_CACHE_KEY + 'assigngrades:' + assignId;\n    }\n\n    /**\n     * Returns the color name for a given grading status name.\n     *\n     * @param status Grading status name\n     * @returns The color name.\n     */\n    getSubmissionGradingStatusColor(status?: AddonModAssignGradingStates): CoreIonicColorNames {\n        if (!status) {\n            return CoreIonicColorNames.NONE;\n        }\n\n        if (status == AddonModAssignGradingStates.GRADED\n                || status == AddonModAssignGradingStates.MARKING_WORKFLOW_STATE_RELEASED) {\n            return CoreIonicColorNames.SUCCESS;\n        }\n\n        return CoreIonicColorNames.DANGER;\n    }\n\n    /**\n     * Returns the translation id for a given grading status name.\n     *\n     * @param status Grading Status name\n     * @returns The status translation identifier.\n     */\n    getSubmissionGradingStatusTranslationId(status?: AddonModAssignGradingStates): string | undefined {\n        if (!status) {\n            return;\n        }\n\n        if (status == AddonModAssignGradingStates.GRADED\n                || status == AddonModAssignGradingStates.NOT_GRADED\n                || status == AddonModAssignGradingStates.GRADED_FOLLOWUP_SUBMIT) {\n            return 'addon.mod_assign.' + status;\n        }\n\n        return 'addon.mod_assign.markingworkflowstate' + status;\n    }\n\n    /**\n     * Get the submission object from an attempt.\n     *\n     * @param assign Assign.\n     * @param attempt Attempt.\n     * @returns Submission object or null.\n     */\n    getSubmissionObjectFromAttempt(\n        assign: AddonModAssignAssign,\n        attempt: AddonModAssignSubmissionAttempt | undefined,\n    ): AddonModAssignSubmission | undefined {\n        if (!attempt) {\n            return;\n        }\n\n        return assign.teamsubmission ? attempt.teamsubmission : attempt.submission;\n    }\n\n    /**\n     * Get attachments of a submission plugin.\n     *\n     * @param submissionPlugin Submission plugin.\n     * @returns Submission plugin attachments.\n     */\n    getSubmissionPluginAttachments(submissionPlugin: AddonModAssignPlugin): CoreWSFile[] {\n        if (!submissionPlugin.fileareas) {\n            return [];\n        }\n\n        const files: CoreWSFile[] = [];\n\n        submissionPlugin.fileareas.forEach((filearea) => {\n            if (!filearea || !filearea.files) {\n                // No files to get.\n                return;\n            }\n\n            filearea.files.forEach((file) => {\n                if (!file.filename) {\n                    // We don't have filename, extract it from the path.\n                    file.filename = CoreFileHelper.getFilenameFromPath(file);\n                }\n\n                files.push(file);\n            });\n        });\n\n        return files;\n    }\n\n    /**\n     * Get text of a submission plugin.\n     *\n     * @param submissionPlugin Submission plugin.\n     * @param keepUrls True if it should keep original URLs, false if they should be replaced.\n     * @returns Submission text.\n     */\n    getSubmissionPluginText(submissionPlugin: AddonModAssignPlugin, keepUrls = false): string {\n        if (!submissionPlugin.editorfields) {\n            return '';\n        }\n        let text = '';\n\n        submissionPlugin.editorfields.forEach((field) => {\n            text += field.text;\n        });\n\n        if (!keepUrls && submissionPlugin.fileareas && submissionPlugin.fileareas[0]) {\n            text = CoreTextUtils.replacePluginfileUrls(text, submissionPlugin.fileareas[0].files || []);\n        }\n\n        return text;\n    }\n\n    /**\n     * Get an assignment submissions.\n     *\n     * @param assignId Assignment id.\n     * @param options Other options.\n     * @returns Promise resolved when done.\n     */\n    async getSubmissions(\n        assignId: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<{ canviewsubmissions: boolean; submissions?: AddonModAssignSubmission[] }> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModAssignGetSubmissionsWSParams = {\n            assignmentids: [assignId],\n        };\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getSubmissionsCacheKey(assignId),\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n            component: AddonModAssignProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n        const response = await site.read<AddonModAssignGetSubmissionsWSResponse>('mod_assign_get_submissions', params, preSets);\n\n        // Check if we can view submissions, with enough permissions.\n        if (response.warnings?.length && response.warnings[0].warningcode == '1') {\n            return { canviewsubmissions: false };\n        }\n\n        if (response.assignments && response.assignments.length) {\n            return {\n                canviewsubmissions: true,\n                submissions: response.assignments[0].submissions,\n            };\n        }\n\n        throw new CoreError('Assignment submissions not found');\n    }\n\n    /**\n     * Get cache key for assignment submissions data WS calls.\n     *\n     * @param assignId Assignment id.\n     * @returns Cache key.\n     */\n    protected getSubmissionsCacheKey(assignId: number): string {\n        return ROOT_CACHE_KEY + 'submissions:' + assignId;\n    }\n\n    /**\n     * Get information about an assignment submission status for a given user.\n     *\n     * @param assignId Assignment instance id.\n     * @param options Other options.\n     * @returns Promise always resolved with the user submission status.\n     */\n    async getSubmissionStatus(\n        assignId: number,\n        options: AddonModAssignSubmissionStatusOptions = {},\n    ): Promise<AddonModAssignGetSubmissionStatusWSResponse> {\n        const site = await CoreSites.getSite(options.siteId);\n\n        options = {\n            filter: true,\n            ...options,\n        };\n\n        const fixedParams = this.fixSubmissionStatusParams(site, options.userId, options.groupId, options.isBlind);\n        const params: AddonModAssignGetSubmissionStatusWSParams = {\n            assignid: assignId,\n            userid: fixedParams.userId,\n        };\n        if (fixedParams.groupId) {\n            params.groupid = fixedParams.groupId;\n        }\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getSubmissionStatusCacheKey(\n                assignId,\n                fixedParams.userId,\n                fixedParams.groupId,\n                fixedParams.isBlind,\n            ),\n            getCacheUsingCacheKey: true,\n            filter: options.filter,\n            rewriteurls: options.filter,\n            component: AddonModAssignProvider.COMPONENT,\n            componentId: options.cmId,\n            // Don't cache when getting text without filters.\n            // @todo Change this to support offline editing.\n            saveToCache: options.filter,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        return site.read<AddonModAssignGetSubmissionStatusWSResponse>('mod_assign_get_submission_status', params, preSets);\n    }\n\n    /**\n     * Get information about an assignment submission status for a given user.\n     * If the data doesn't include the user submission, retry ignoring cache.\n     *\n     * @param assign Assignment.\n     * @param options Other options.\n     * @returns Promise always resolved with the user submission status.\n     */\n    async getSubmissionStatusWithRetry(\n        assign: AddonModAssignAssign,\n        options: AddonModAssignSubmissionStatusOptions = {},\n    ): Promise<AddonModAssignGetSubmissionStatusWSResponse> {\n        options.cmId = options.cmId || assign.cmid;\n\n        const response = await this.getSubmissionStatus(assign.id, options);\n\n        const userSubmission = this.getSubmissionObjectFromAttempt(assign, response.lastattempt);\n        if (userSubmission) {\n            return response;\n        }\n        // Try again, ignoring cache.\n        const newOptions = {\n            ...options,\n            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,\n        };\n\n        try {\n            return await this.getSubmissionStatus(assign.id, newOptions);\n        } catch {\n            // Error, return the first result even if it doesn't have the user submission.\n            return response;\n        }\n    }\n\n    /**\n     * Get cache key for get submission status data WS calls.\n     *\n     * @param assignId Assignment instance id.\n     * @param userId User id (empty for current user).\n     * @param groupId Group Id (empty for all participants).\n     * @param isBlind If blind marking is enabled or not.\n     * @returns Cache key.\n     */\n    protected getSubmissionStatusCacheKey(assignId: number, userId: number, groupId?: number, isBlind = false): string {\n        return this.getSubmissionsCacheKey(assignId) + ':' + userId + ':' + (isBlind ? 1 : 0) + ':' + groupId;\n    }\n\n    /**\n     * Returns the color name for a given status name.\n     *\n     * @param status Status name\n     * @returns The color name.\n     */\n    getSubmissionStatusColor(status: AddonModAssignSubmissionStatusValues): CoreIonicColorNames {\n        switch (status) {\n            case AddonModAssignSubmissionStatusValues.SUBMITTED:\n                return CoreIonicColorNames.SUCCESS;\n            case AddonModAssignSubmissionStatusValues.DRAFT:\n                return CoreIonicColorNames.INFO;\n            case AddonModAssignSubmissionStatusValues.NEW:\n            case AddonModAssignSubmissionStatusValues.NO_ATTEMPT:\n            case AddonModAssignSubmissionStatusValues.NO_ONLINE_SUBMISSIONS:\n            case AddonModAssignSubmissionStatusValues.NO_SUBMISSION:\n            case AddonModAssignSubmissionStatusValues.GRADED_FOLLOWUP_SUBMIT:\n                return CoreIonicColorNames.DANGER;\n            default:\n                return CoreIonicColorNames.LIGHT;\n        }\n    }\n\n    /**\n     * Given a list of plugins, returns the plugin names that aren't supported for editing.\n     *\n     * @param plugins Plugins to check.\n     * @returns Promise resolved with unsupported plugin names.\n     */\n    async getUnsupportedEditPlugins(plugins: AddonModAssignPlugin[]): Promise<string[]> {\n        const notSupported: string[] = [];\n        const promises = plugins.map((plugin) =>\n            AddonModAssignSubmissionDelegate.isPluginSupportedForEdit(plugin.type).then((enabled) => {\n                if (!enabled) {\n                    notSupported.push(plugin.name);\n                }\n\n                return;\n            }));\n\n        await Promise.all(promises);\n\n        return notSupported;\n    }\n\n    /**\n     * List the participants for a single assignment, with some summary info about their submissions.\n     *\n     * @param assignId Assignment id.\n     * @param groupId Group id. If not defined, 0.\n     * @param options Other options.\n     * @returns Promise resolved with the list of participants and summary of submissions.\n     */\n    async listParticipants(\n        assignId: number,\n        groupId?: number,\n        options: CoreCourseCommonModWSOptions = {},\n    ): Promise<AddonModAssignParticipant[]> {\n\n        groupId = groupId || 0;\n\n        const site = await CoreSites.getSite(options.siteId);\n\n        const params: AddonModAssignListParticipantsWSParams = {\n            assignid: assignId,\n            groupid: groupId,\n            filter: '',\n        };\n\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.listParticipantsCacheKey(assignId, groupId),\n            updateFrequency: CoreSite.FREQUENCY_OFTEN,\n            component: AddonModAssignProvider.COMPONENT,\n            componentId: options.cmId,\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        return site.read<AddonModAssignListParticipantsWSResponse>('mod_assign_list_participants', params, preSets);\n    }\n\n    /**\n     * Get cache key for assignment list participants data WS calls.\n     *\n     * @param assignId Assignment id.\n     * @param groupId Group id.\n     * @returns Cache key.\n     */\n    protected listParticipantsCacheKey(assignId: number, groupId: number): string {\n        return this.listParticipantsPrefixCacheKey(assignId) + ':' + groupId;\n    }\n\n    /**\n     * Get prefix cache key for assignment list participants data WS calls.\n     *\n     * @param assignId Assignment id.\n     * @returns Cache key.\n     */\n    protected listParticipantsPrefixCacheKey(assignId: number): string {\n        return ROOT_CACHE_KEY + 'participants:' + assignId;\n    }\n\n    /**\n     * Invalidates all submission status data.\n     *\n     * @param assignId Assignment instance id.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAllSubmissionData(assignId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.getSubmissionsCacheKey(assignId));\n    }\n\n    /**\n     * Invalidates assignment data WS calls.\n     *\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAssignmentData(courseId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAssignmentCacheKey(courseId));\n    }\n\n    /**\n     * Invalidates assignment user mappings data WS calls.\n     *\n     * @param assignId Assignment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAssignmentUserMappingsData(assignId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAssignmentUserMappingsCacheKey(assignId));\n    }\n\n    /**\n     * Invalidates assignment grades data WS calls.\n     *\n     * @param assignId Assignment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateAssignmentGradesData(assignId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getAssignmentGradesCacheKey(assignId));\n    }\n\n    /**\n     * Invalidate the prefetched content except files.\n     *\n     * @param moduleId The module ID.\n     * @param courseId Course ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateContent(moduleId: number, courseId: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const assign = await this.getAssignment(courseId, moduleId, { siteId });\n        const promises: Promise<void>[] = [];\n        // Do not invalidate assignment data before getting assignment info, we need it!\n        promises.push(this.invalidateAllSubmissionData(assign.id, siteId));\n        promises.push(this.invalidateAssignmentUserMappingsData(assign.id, siteId));\n        promises.push(this.invalidateAssignmentGradesData(assign.id, siteId));\n        promises.push(this.invalidateListParticipantsData(assign.id, siteId));\n        promises.push(CoreComments.invalidateCommentsByInstance('module', assign.id, siteId));\n        promises.push(this.invalidateAssignmentData(courseId, siteId));\n        promises.push(CoreGrades.invalidateAllCourseGradesData(courseId));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Invalidates assignment submissions data WS calls.\n     *\n     * @param assignId Assignment instance id.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateSubmissionData(assignId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKey(this.getSubmissionsCacheKey(assignId));\n    }\n\n    /**\n     * Invalidates submission status data.\n     *\n     * @param assignId Assignment instance id.\n     * @param userId User id (empty for current user).\n     * @param groupId Group Id (empty for all participants).\n     * @param isBlind Whether blind marking is enabled or not.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateSubmissionStatusData(\n        assignId: number,\n        userId?: number,\n        groupId?: number,\n        isBlind = false,\n        siteId?: string,\n    ): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const fixedParams = this.fixSubmissionStatusParams(site, userId, groupId, isBlind);\n\n        await site.invalidateWsCacheForKey(this.getSubmissionStatusCacheKey(\n            assignId,\n            fixedParams.userId,\n            fixedParams.groupId,\n            fixedParams.isBlind,\n        ));\n    }\n\n    /**\n     * Invalidates assignment participants data.\n     *\n     * @param assignId Assignment instance id.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateListParticipantsData(assignId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        await site.invalidateWsCacheForKeyStartingWith(this.listParticipantsPrefixCacheKey(assignId));\n    }\n\n    /**\n     * Check if a submission is open. This function is based on Moodle's submissions_open.\n     *\n     * @param assign Assignment instance.\n     * @param submissionStatus Submission status returned by getSubmissionStatus.\n     * @returns Whether submission is open.\n     */\n    isSubmissionOpen(assign: AddonModAssignAssign, submissionStatus?: AddonModAssignGetSubmissionStatusWSResponse): boolean {\n        if (!assign || !submissionStatus) {\n            return false;\n        }\n\n        const time = CoreTimeUtils.timestamp();\n        const lastAttempt = submissionStatus.lastattempt;\n        const submission = this.getSubmissionObjectFromAttempt(assign, lastAttempt);\n\n        let dateOpen = true;\n        let finalDate: number | undefined;\n\n        if (assign.cutoffdate) {\n            finalDate = assign.cutoffdate;\n        }\n\n        if (lastAttempt && lastAttempt.locked) {\n            return false;\n        }\n\n        // User extensions.\n        if (finalDate) {\n            if (lastAttempt && lastAttempt.extensionduedate) {\n                // Extension can be before cut off date.\n                if (lastAttempt.extensionduedate > finalDate) {\n                    finalDate = lastAttempt.extensionduedate;\n                }\n            }\n        }\n\n        if (finalDate) {\n            dateOpen = assign.allowsubmissionsfromdate <= time && time <= finalDate;\n        } else {\n            dateOpen = assign.allowsubmissionsfromdate <= time;\n        }\n\n        if (!dateOpen) {\n            return false;\n        }\n\n        if (submission) {\n            if (assign.submissiondrafts && submission.status == AddonModAssignSubmissionStatusValues.SUBMITTED) {\n                // Drafts are tracked and the student has submitted the assignment.\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Report an assignment submission as being viewed.\n     *\n     * @param assignid Assignment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logSubmissionView(assignid: number, siteId?: string): Promise<void> {\n        const params: AddonModAssignViewSubmissionStatusWSParams = {\n            assignid,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_assign_view_submission_status',\n            params,\n            AddonModAssignProvider.COMPONENT,\n            assignid,\n            siteId,\n        );\n    }\n\n    /**\n     * Report an assignment grading table is being viewed.\n     *\n     * @param assignid Assignment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logGradingView(assignid: number, siteId?: string): Promise<void> {\n        const params: AddonModAssignViewGradingTableWSParams = {\n            assignid,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_assign_view_grading_table',\n            params,\n            AddonModAssignProvider.COMPONENT,\n            assignid,\n            siteId,\n        );\n    }\n\n    /**\n     * Report an assign as being viewed.\n     *\n     * @param assignid Assignment ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the WS call is successful.\n     */\n    async logView(assignid: number, siteId?: string): Promise<void> {\n        const params: AddonModAssignViewAssignWSParams = {\n            assignid,\n        };\n\n        await CoreCourseLogHelper.log(\n            'mod_assign_view_assign',\n            params,\n            AddonModAssignProvider.COMPONENT,\n            assignid,\n            siteId,\n        );\n    }\n\n    /**\n     * Returns if a submissions needs to be graded.\n     *\n     * @param submission Submission.\n     * @param assignId Assignment ID.\n     * @returns Promise resolved with boolean: whether it needs to be graded or not.\n     */\n    async needsSubmissionToBeGraded(submission: AddonModAssignSubmissionFormatted, assignId: number): Promise<boolean> {\n        if (submission.status != AddonModAssignSubmissionStatusValues.SUBMITTED) {\n            return false;\n        }\n\n        if (!submission.gradingstatus) {\n            // This should not happen, but it's better to show rather than not showing any of the submissions.\n            return true;\n        }\n\n        if (submission.gradingstatus != AddonModAssignGradingStates.GRADED &&\n                submission.gradingstatus != AddonModAssignGradingStates.MARKING_WORKFLOW_STATE_RELEASED) {\n            // Not graded.\n            return true;\n        }\n\n        // We need more data to decide that.\n        const response = await this.getSubmissionStatus(assignId, {\n            userId: submission.submitid,\n            isBlind: !!submission.blindid,\n        });\n\n        if (!response.feedback || !response.feedback.gradeddate) {\n            // Not graded.\n            return true;\n        }\n\n        return response.feedback.gradeddate < submission.timemodified;\n    }\n\n    /**\n     * Save current user submission for a certain assignment.\n     *\n     * @param assignId Assign ID.\n     * @param courseId Course ID the assign belongs to.\n     * @param pluginData Data to save.\n     * @param allowOffline Whether to allow offline usage.\n     * @param timemodified The time the submission was last modified in online.\n     * @param allowsDrafts Whether the assignment allows submission drafts.\n     * @param userId User ID. If not defined, site's current user.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if sent to server, resolved with false if stored in offline.\n     */\n    async saveSubmission(\n        assignId: number,\n        courseId: number,\n        pluginData: AddonModAssignSavePluginData,\n        allowOffline: boolean,\n        timemodified: number,\n        allowsDrafts = false,\n        userId?: number,\n        siteId?: string,\n    ): Promise<boolean> {\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Function to store the submission to be synchronized later.\n        const storeOffline = async (): Promise<boolean> => {\n            await AddonModAssignOffline.saveSubmission(\n                assignId,\n                courseId,\n                pluginData,\n                timemodified,\n                !allowsDrafts,\n                userId,\n                siteId,\n            );\n\n            return false;\n        };\n\n        if (allowOffline && !CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            // If there's already a submission to be sent to the server, discard it first.\n            await AddonModAssignOffline.deleteSubmission(assignId, userId, siteId);\n            await this.saveSubmissionOnline(assignId, pluginData, siteId);\n\n            return true;\n        } catch (error) {\n            if (allowOffline && error && !CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server, store in offline.\n                return storeOffline();\n            } else {\n                // The WebService has thrown an error or offline not supported, reject.\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Save current user submission for a certain assignment. It will fail if offline or cannot connect.\n     *\n     * @param assignId Assign ID.\n     * @param pluginData Data to save.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when saved, rejected otherwise.\n     */\n    async saveSubmissionOnline(assignId: number, pluginData: AddonModAssignSavePluginData, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const params: AddonModAssignSaveSubmissionWSParams = {\n            assignmentid: assignId,\n            plugindata: pluginData,\n        };\n        const warnings = await site.write<CoreWSExternalWarning[]>('mod_assign_save_submission', params);\n\n        if (warnings.length) {\n            // The WebService returned warnings, reject.\n            throw new CoreWSError(warnings[0]);\n        }\n    }\n\n    /**\n     * Start a submission.\n     *\n     * @param assignId Assign ID.\n     * @param siteId Site ID. If not defined, use current site.\n     * @returns Promise resolved when done.\n     */\n    async startSubmission(assignId: number, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModAssignStartSubmissionWSParams = {\n            assignid: assignId,\n        };\n\n        const result = await site.write<AddonModAssignStartSubmissionWSResponse>('mod_assign_start_submission', params);\n\n        if (!result.warnings?.length) {\n            return;\n        }\n\n        // Ignore some warnings.\n        const warning = result.warnings.find(warning =>\n            warning.warningcode !== 'timelimitnotenabled' && warning.warningcode !== 'opensubmissionexists');\n\n        if (warning) {\n            throw new CoreWSError(warning);\n        }\n    }\n\n    /**\n     * Submit the current user assignment for grading.\n     *\n     * @param assignId Assign ID.\n     * @param courseId Course ID the assign belongs to.\n     * @param acceptStatement True if submission statement is accepted, false otherwise.\n     * @param timemodified The time the submission was last modified in online.\n     * @param forceOffline True to always mark it in offline.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if sent to server, resolved with false if stored in offline.\n     */\n    async submitForGrading(\n        assignId: number,\n        courseId: number,\n        acceptStatement: boolean,\n        timemodified: number,\n        forceOffline = false,\n        siteId?: string,\n    ): Promise<boolean> {\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Function to store the submission to be synchronized later.\n        const storeOffline = async (): Promise<boolean> => {\n            await AddonModAssignOffline.markSubmitted(\n                assignId,\n                courseId,\n                true,\n                acceptStatement,\n                timemodified,\n                undefined,\n                siteId,\n            );\n\n            return false;\n        };\n\n        if (forceOffline || !CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            // If there's already a submission to be sent to the server, discard it first.\n            await AddonModAssignOffline.deleteSubmission(assignId, undefined, siteId);\n            await this.submitForGradingOnline(assignId, acceptStatement, siteId);\n\n            return true;\n        } catch (error) {\n            if (error && !CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server, store in offline.\n                return storeOffline();\n            } else {\n                // The WebService has thrown an error, reject.\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Submit the current user assignment for grading. It will fail if offline or cannot connect.\n     *\n     * @param assignId Assign ID.\n     * @param acceptStatement True if submission statement is accepted, false otherwise.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when submitted, rejected otherwise.\n     */\n    async submitForGradingOnline(assignId: number, acceptStatement: boolean, siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const params: AddonModAssignSubmitForGradingWSParams = {\n            assignmentid: assignId,\n            acceptsubmissionstatement: acceptStatement,\n        };\n\n        const warnings = await site.write<CoreWSExternalWarning[]>('mod_assign_submit_for_grading', params);\n\n        if (warnings.length) {\n            // The WebService returned warnings, reject.\n            throw new CoreWSError(warnings[0]);\n        }\n    }\n\n    /**\n     * Submit the grading for the current user and assignment. It will use old or new WS depending on availability.\n     *\n     * @param assignId Assign ID.\n     * @param userId User ID.\n     * @param courseId Course ID the assign belongs to.\n     * @param grade Grade to submit.\n     * @param attemptNumber Number of the attempt being graded.\n     * @param addAttempt Admit the user to attempt again.\n     * @param workflowState Next workflow State.\n     * @param applyToAll If it's a team submission, whether the grade applies to all group members.\n     * @param outcomes Object including all outcomes values. If empty, any of them will be sent.\n     * @param pluginData Feedback plugin data to save.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with true if sent to server, resolved with false if stored offline.\n     */\n    async submitGradingForm(\n        assignId: number,\n        userId: number,\n        courseId: number,\n        grade: number,\n        attemptNumber: number,\n        addAttempt: boolean,\n        workflowState: string,\n        applyToAll: boolean,\n        outcomes: AddonModAssignOutcomes,\n        pluginData: AddonModAssignSavePluginData,\n        siteId?: string,\n    ): Promise<boolean> {\n\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        // Function to store the grading to be synchronized later.\n        const storeOffline = async (): Promise<boolean> => {\n            await AddonModAssignOffline.submitGradingForm(\n                assignId,\n                userId,\n                courseId,\n                grade,\n                attemptNumber,\n                addAttempt,\n                workflowState,\n                applyToAll,\n                outcomes,\n                pluginData,\n                siteId,\n            );\n\n            return false;\n        };\n\n        if (!CoreNetwork.isOnline()) {\n            // App is offline, store the action.\n            return storeOffline();\n        }\n\n        try {\n            // If there's already a grade to be sent to the server, discard it first.\n            await AddonModAssignOffline.deleteSubmissionGrade(assignId, userId, siteId);\n            await this.submitGradingFormOnline(\n                assignId,\n                userId,\n                grade,\n                attemptNumber,\n                addAttempt,\n                workflowState,\n                applyToAll,\n                outcomes,\n                pluginData,\n                siteId,\n            );\n\n            return true;\n        } catch (error) {\n            if (error && !CoreUtils.isWebServiceError(error)) {\n                // Couldn't connect to server, store in offline.\n                return storeOffline();\n            } else {\n                // The WebService has thrown an error, reject.\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Submit the grading for the current user and assignment. It will use old or new WS depending on availability.\n     * It will fail if offline or cannot connect.\n     *\n     * @param assignId Assign ID.\n     * @param userId User ID.\n     * @param grade Grade to submit.\n     * @param attemptNumber Number of the attempt being graded.\n     * @param addAttempt Allow the user to attempt again.\n     * @param workflowState Next workflow State.\n     * @param applyToAll If it's a team submission, if the grade applies to all group members.\n     * @param outcomes Object including all outcomes values. If empty, any of them will be sent.\n     * @param pluginData Feedback plugin data to save.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when submitted, rejected otherwise.\n     */\n    async submitGradingFormOnline(\n        assignId: number,\n        userId: number,\n        grade: number,\n        attemptNumber: number,\n        addAttempt: boolean,\n        workflowState: string,\n        applyToAll: boolean,\n        outcomes: AddonModAssignOutcomes,\n        pluginData: AddonModAssignSavePluginData,\n        siteId?: string,\n    ): Promise<void> {\n\n        const site = await CoreSites.getSite(siteId);\n        userId = userId || site.getUserId();\n\n        const jsonData = {\n            grade,\n            attemptnumber: attemptNumber,\n            addattempt: addAttempt ? 1 : 0,\n            workflowstate: workflowState,\n            applytoall: applyToAll ? 1 : 0,\n        };\n\n        for (const index in outcomes) {\n            jsonData['outcome_' + index + '[' + userId + ']'] = outcomes[index];\n        }\n\n        for (const index in pluginData) {\n            jsonData[index] = pluginData[index];\n        }\n\n        const serialized = CoreInterceptor.serialize(jsonData, true);\n        const params: AddonModAssignSubmitGradingFormWSParams = {\n            assignmentid: assignId,\n            userid: userId,\n            jsonformdata: JSON.stringify(serialized),\n        };\n\n        const warnings = await site.write<CoreWSExternalWarning[]>('mod_assign_submit_grading_form', params);\n\n        if (warnings.length) {\n            // The WebService returned warnings, reject.\n            throw new CoreWSError(warnings[0]);\n        }\n    }\n\n}\nexport const AddonModAssign = makeSingleton(AddonModAssignProvider);\n\n/**\n * Options to pass to get submission status.\n */\nexport type AddonModAssignSubmissionStatusOptions = CoreCourseCommonModWSOptions & {\n    userId?: number; // User Id (empty for current user).\n    groupId?: number; // Group Id (empty for all participants).\n    isBlind?: boolean; // If blind marking is enabled or not.\n    filter?: boolean; // True to filter WS response and rewrite URLs, false otherwise. Defaults to true.\n};\n\n/**\n * Assign data returned by mod_assign_get_assignments.\n */\nexport type AddonModAssignAssign = {\n    id: number; // Assignment id.\n    cmid: number; // Course module id.\n    course: number; // Course id.\n    name: string; // Assignment name.\n    nosubmissions: number; // No submissions.\n    submissiondrafts: number; // Submissions drafts.\n    sendnotifications: number; // Send notifications.\n    sendlatenotifications: number; // Send notifications.\n    sendstudentnotifications: number; // Send student notifications (default).\n    duedate: number; // Assignment due date.\n    allowsubmissionsfromdate: number; // Allow submissions from date.\n    grade: number; // Grade type.\n    timemodified: number; // Last time assignment was modified.\n    completionsubmit: number; // If enabled, set activity as complete following submission.\n    cutoffdate: number; // Date after which submission is not accepted without an extension.\n    gradingduedate?: number; // The expected date for marking the submissions.\n    teamsubmission: number; // If enabled, students submit as a team.\n    requireallteammemberssubmit: number; // If enabled, all team members must submit.\n    teamsubmissiongroupingid: number; // The grouping id for the team submission groups.\n    blindmarking: number; // If enabled, hide identities until reveal identities actioned.\n    hidegrader?: number; // @since 3.7. If enabled, hide grader to student.\n    revealidentities: number; // Show identities for a blind marking assignment.\n    attemptreopenmethod: AddonModAssignAttemptReopenMethodValues; // Method used to control opening new attempts.\n    maxattempts: number; // Maximum number of attempts allowed.\n    markingworkflow: number; // Enable marking workflow.\n    markingallocation: number; // Enable marking allocation.\n    requiresubmissionstatement: number; // Student must accept submission statement.\n    preventsubmissionnotingroup?: number; // Prevent submission not in group.\n    submissionstatement?: string; // Submission statement formatted.\n    submissionstatementformat?: number; // Submissionstatement format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    configs: AddonModAssignConfig[]; // Configuration settings.\n    intro?: string; // Assignment intro, not allways returned because it deppends on the activity configuration.\n    introformat?: number; // Intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    introfiles?: CoreWSExternalFile[];\n    introattachments?: CoreWSExternalFile[];\n    activity?: string; // @since 4.0. Description of activity.\n    activityformat?: number; // @since 4.0. Format of activity.\n    activityattachments?: CoreWSExternalFile[]; // @since 4.0. Files from activity field.\n    timelimit?: number; // @since 4.0. Time limit to complete assigment.\n    submissionattachments?: number; // @since 4.0. Flag to only show files during submission.\n};\n\n/**\n * Config setting in an assign.\n */\nexport type AddonModAssignConfig = {\n    id?: number; // Assign_plugin_config id.\n    assignment?: number; // Assignment id.\n    plugin: string; // Plugin.\n    subtype: string; // Subtype.\n    name: string; // Name.\n    value: string; // Value.\n};\n\n/**\n * Grade of an assign, returned by mod_assign_get_grades.\n */\nexport type AddonModAssignGrade = {\n    id: number; // Grade id.\n    assignment?: number; // Assignment id.\n    userid: number; // Student id.\n    attemptnumber: number; // Attempt number.\n    timecreated: number; // Grade creation time.\n    timemodified: number; // Grade last modified time.\n    grader: number; // Grader, -1 if grader is hidden.\n    grade: string; // Grade.\n    gradefordisplay?: string; // Grade rendered into a format suitable for display.\n};\n\n/**\n * Assign submission returned by mod_assign_get_submissions.\n */\nexport type AddonModAssignSubmission = {\n    id: number; // Submission id.\n    userid: number; // Student id.\n    attemptnumber: number; // Attempt number.\n    timecreated: number; // Submission creation time.\n    timemodified: number; // Submission last modified time.\n    status: AddonModAssignSubmissionStatusValues; // Submission status.\n    groupid: number; // Group id.\n    assignment?: number; // Assignment id.\n    latest?: number; // Latest attempt.\n    plugins?: AddonModAssignPlugin[]; // Plugins.\n    gradingstatus?: AddonModAssignGradingStates; // Grading status.\n    timestarted?: number; // @since 4.0. Submission start time.\n};\n\n/**\n * Assign plugin.\n */\nexport type AddonModAssignPlugin = {\n    type: string; // Submission plugin type.\n    name: string; // Submission plugin name.\n    fileareas?: { // Fileareas.\n        area: string; // File area.\n        files?: CoreWSExternalFile[];\n    }[];\n    editorfields?: { // Editorfields.\n        name: string; // Field name.\n        description: string; // Field description.\n        text: string; // Field value.\n        format: number; // Text format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    }[];\n};\n\n/**\n * Grading summary of an assign submission.\n */\nexport type AddonModAssignSubmissionGradingSummary = {\n    participantcount: number; // Number of users who can submit.\n    submissiondraftscount: number; // Number of submissions in draft status.\n    submissionsenabled: boolean; // Whether submissions are enabled or not.\n    submissionssubmittedcount: number; // Number of submissions in submitted status.\n    submissionsneedgradingcount: number; // Number of submissions that need grading.\n    warnofungroupedusers: string | boolean; // Whether we need to warn people about groups.\n};\n\n/**\n * Attempt of an assign submission.\n */\nexport type AddonModAssignSubmissionAttempt = {\n    submission?: AddonModAssignSubmission; // Submission info.\n    teamsubmission?: AddonModAssignSubmission; // Submission info.\n    submissiongroup?: number; // The submission group id (for group submissions only).\n    submissiongroupmemberswhoneedtosubmit?: number[]; // List of users who still need to submit (for group submissions only).\n    submissionsenabled: boolean; // Whether submissions are enabled or not.\n    locked: boolean; // Whether new submissions are locked.\n    graded: boolean; // Whether the submission is graded.\n    canedit: boolean; // Whether the user can edit the current submission.\n    caneditowner?: boolean; // Whether the owner of the submission can edit it.\n    cansubmit: boolean; // Whether the user can submit.\n    extensionduedate: number; // Extension due date.\n    blindmarking: boolean; // Whether blind marking is enabled.\n    gradingstatus: AddonModAssignGradingStates; // Grading status.\n    usergroups: number[]; // User groups in the course.\n    timelimit?: number; // @since 4.0. Time limit for submission.\n};\n\n/**\n * Previous attempt of an assign submission.\n */\nexport type AddonModAssignSubmissionPreviousAttempt = {\n    attemptnumber: number; // Attempt number.\n    submission?: AddonModAssignSubmission; // Submission info.\n    grade?: AddonModAssignGrade; // Grade information.\n    feedbackplugins?: AddonModAssignPlugin[]; // Feedback info.\n};\n\n/**\n * Feedback of an assign submission.\n */\nexport type AddonModAssignSubmissionFeedback = {\n    grade?: AddonModAssignGrade; // Grade information.\n    gradefordisplay: string; // Grade rendered into a format suitable for display.\n    gradeddate: number; // The date the user was graded.\n    plugins?: AddonModAssignPlugin[]; // Plugins info.\n};\n\n/**\n * Params of mod_assign_list_participants WS.\n */\ntype AddonModAssignListParticipantsWSParams = {\n    assignid: number; // Assign instance id.\n    groupid: number; // Group id.\n    filter: string; // Search string to filter the results.\n    skip?: number; // Number of records to skip.\n    limit?: number; // Maximum number of records to return.\n    onlyids?: boolean; // Do not return all user fields.\n    includeenrolments?: boolean; // Do return courses where the user is enrolled.\n    tablesort?: boolean; // Apply current user table sorting preferences.\n};\n\n/**\n * Data returned by mod_assign_list_participants WS.\n */\ntype AddonModAssignListParticipantsWSResponse = AddonModAssignParticipant[];\n\n/**\n * Participant returned by mod_assign_list_participants.\n */\nexport type AddonModAssignParticipant = {\n    id: number; // ID of the user.\n    username?: string; // The username.\n    firstname?: string; // The first name(s) of the user.\n    lastname?: string; // The family name of the user.\n    fullname: string; // The fullname of the user.\n    email?: string; // Email address.\n    address?: string; // Postal address.\n    phone1?: string; // Phone 1.\n    phone2?: string; // Phone 2.\n    icq?: string; // Icq number.\n    skype?: string; // Skype id.\n    yahoo?: string; // Yahoo id.\n    aim?: string; // Aim id.\n    msn?: string; // Msn number.\n    department?: string; // Department.\n    institution?: string; // Institution.\n    idnumber?: string; // The idnumber of the user.\n    interests?: string; // User interests (separated by commas).\n    firstaccess?: number; // First access to the site (0 if never).\n    lastaccess?: number; // Last access to the site (0 if never).\n    suspended?: boolean; // Suspend user account, either false to enable user login or true to disable it.\n    description?: string; // User profile description.\n    descriptionformat?: number; // Int format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    city?: string; // Home city of the user.\n    url?: string; // URL of the user.\n    country?: string; // Home country code of the user, such as AU or CZ.\n    profileimageurlsmall?: string; // User image profile URL - small version.\n    profileimageurl?: string; // User image profile URL - big version.\n    customfields?: { // User custom fields (also known as user profile fields).\n        type: string; // The type of the custom field - text field, checkbox...\n        value: string; // The value of the custom field.\n        displayvalue: string; // @since 4.2.Formatted value of the custom field.\n        name: string; // The name of the custom field.\n        shortname: string; // The shortname of the custom field - to be able to build the field class in the code.\n    }[];\n    preferences?: { // Users preferences.\n        name: string; // The name of the preferences.\n        value: string; // The value of the preference.\n    }[];\n    recordid?: number; // @since 3.7. Record id.\n    groups?: { // User groups.\n        id: number; // Group id.\n        name: string; // Group name.\n        description: string; // Group description.\n    }[];\n    roles?: { // User roles.\n        roleid: number; // Role id.\n        name: string; // Role name.\n        shortname: string; // Role shortname.\n        sortorder: number; // Role sortorder.\n    }[];\n    enrolledcourses?: { // Courses where the user is enrolled - limited by which courses the user is able to see.\n        id: number; // Id of the course.\n        fullname: string; // Fullname of the course.\n        shortname: string; // Shortname of the course.\n    }[];\n    submitted: boolean; // Have they submitted their assignment.\n    requiregrading: boolean; // Is their submission waiting for grading.\n    grantedextension?: boolean; // Have they been granted an extension.\n    groupid?: number; // For group assignments this is the group id.\n    groupname?: string; // For group assignments this is the group name.\n};\n\n/**\n * Result of WS mod_assign_get_assignments.\n */\nexport type AddonModAssignGetAssignmentsWSResponse = {\n    courses: { // List of courses.\n        id: number; // Course id.\n        fullname: string; // Course full name.\n        shortname: string; // Course short name.\n        timemodified: number; // Last time modified.\n        assignments: AddonModAssignAssign[]; // Assignment info.\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_assign_get_submissions WS.\n */\ntype AddonModAssignGetSubmissionsWSParams = {\n    assignmentids: number[]; // 1 or more assignment ids.\n    status?: string; // Status.\n    since?: number; // Submitted since.\n    before?: number; // Submitted before.\n};\n\n/**\n * Data returned by mod_assign_get_submissions WS.\n */\nexport type AddonModAssignGetSubmissionsWSResponse = {\n    assignments: { // Assignment submissions.\n        assignmentid: number; // Assignment id.\n        submissions: AddonModAssignSubmission[];\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_assign_get_submission_status WS.\n */\ntype AddonModAssignGetSubmissionStatusWSParams = {\n    assignid: number; // Assignment instance id.\n    userid?: number; // User id (empty for current user).\n    groupid?: number; // Filter by users in group (used for generating the grading summary). Empty or 0 for all groups information.\n};\n\n/**\n * Result of WS mod_assign_get_submission_status.\n */\nexport type AddonModAssignGetSubmissionStatusWSResponse = {\n    gradingsummary?: AddonModAssignSubmissionGradingSummary; // Grading information.\n    lastattempt?: AddonModAssignSubmissionAttempt; // Last attempt information.\n    feedback?: AddonModAssignSubmissionFeedback; // Feedback for the last attempt.\n    previousattempts?: AddonModAssignSubmissionPreviousAttempt[]; // List all the previous attempts did by the user.\n    assignmentdata?: { // @since 4.0. Extra information about assignment.\n        attachments?: { // Intro and activity attachments.\n            intro?: CoreWSExternalFile[]; // Intro attachments files.\n            activity?: CoreWSExternalFile[]; // Activity attachments files.\n        };\n        activity?: string; // Text of activity.\n        activityformat?: number; // Format of activity.\n    };\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_assign_view_submission_status WS.\n */\ntype AddonModAssignViewSubmissionStatusWSParams = {\n    assignid: number; // Assign instance id.\n};\n\n/**\n * Params of mod_assign_view_grading_table WS.\n */\ntype AddonModAssignViewGradingTableWSParams = {\n    assignid: number; // Assign instance id.\n};\n\n/**\n * Params of mod_assign_view_assign WS.\n */\ntype AddonModAssignViewAssignWSParams = {\n    assignid: number; // Assign instance id.\n};\n\ntype AddonModAssignFixedSubmissionParams = {\n    userId: number;\n    groupId: number;\n    isBlind: boolean;\n};\n\n/**\n * Params of mod_assign_get_assignments WS.\n */\ntype AddonModAssignGetAssignmentsWSParams = {\n    courseids?: number[]; // 0 or more course ids.\n    capabilities?: string[]; // List of capabilities used to filter courses.\n    includenotenrolledcourses?: boolean; // Whether to return courses that the user can see even if is not enroled in.\n    // This requires the parameter courseids to not be empty.\n\n};\n\n/**\n * Params of mod_assign_get_user_mappings WS.\n */\ntype AddonModAssignGetUserMappingsWSParams = {\n    assignmentids: number[]; // 1 or more assignment ids.\n};\n\n/**\n * Data returned by mod_assign_get_user_mappings WS.\n */\nexport type AddonModAssignGetUserMappingsWSResponse = {\n    assignments: { // List of assign user mapping data.\n        assignmentid: number; // Assignment id.\n        mappings: {\n            id: number; // User mapping id.\n            userid: number; // Student id.\n        }[];\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_assign_get_grades WS.\n */\ntype AddonModAssignGetGradesWSParams = {\n    assignmentids: number[]; // 1 or more assignment ids.\n    since?: number; // Timestamp, only return records where timemodified >= since.\n};\n\n/**\n * Data returned by mod_assign_get_grades WS.\n */\nexport type AddonModAssignGetGradesWSResponse = {\n    assignments: { // List of assignment grade information.\n        assignmentid: number; // Assignment id.\n        grades: AddonModAssignGrade[];\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Params of mod_assign_save_submission WS.\n */\ntype AddonModAssignSaveSubmissionWSParams = {\n    assignmentid: number; // The assignment id to operate on.\n    plugindata: AddonModAssignSavePluginData;\n};\n\n/**\n * All subplugins will decide what to add here.\n */\nexport type AddonModAssignSavePluginData = CoreFormFields;\n\n/**\n * Params of mod_assign_submit_for_grading WS.\n */\ntype AddonModAssignSubmitForGradingWSParams = {\n    assignmentid: number; // The assignment id to operate on.\n    acceptsubmissionstatement: boolean; // Accept the assignment submission statement.\n};\n\n/**\n * Params of mod_assign_submit_grading_form WS.\n */\ntype AddonModAssignSubmitGradingFormWSParams = {\n    assignmentid: number; // The assignment id to operate on.\n    userid: number; // The user id the submission belongs to.\n    jsonformdata: string; // The data from the grading form, encoded as a json array.\n};\n\n/**\n * Params of mod_assign_start_submission WS.\n *\n * @since 4.0\n */\ntype AddonModAssignStartSubmissionWSParams = {\n    assignid: number; // Assignment instance id.\n};\n\n/**\n * Data returned by mod_assign_start_submission WS.\n *\n * @since 4.0\n */\nexport type AddonModAssignStartSubmissionWSResponse = {\n    submissionid: number; // New submission ID.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Assignment grade outcomes.\n */\nexport type AddonModAssignOutcomes = { [itemNumber: number]: number };\n\n/**\n * Data sent by SUBMITTED_FOR_GRADING_EVENT event.\n */\nexport type AddonModAssignSubmittedForGradingEventData = {\n    assignmentId: number;\n    submissionId: number;\n    userId: number;\n};\n\n/**\n * Data sent by SUBMISSION_SAVED_EVENT event.\n */\nexport type AddonModAssignSubmissionSavedEventData = AddonModAssignSubmittedForGradingEventData;\n\n/**\n * Data sent by GRADED_EVENT event.\n */\nexport type AddonModAssignGradedEventData = AddonModAssignSubmittedForGradingEventData;\n\n/**\n * Data sent by STARTED_EVENT event.\n */\nexport type AddonModAssignStartedEventData = {\n    assignmentId: number;\n};\n\n/**\n * Submission status.\n * Constants on LMS starting with ASSIGN_SUBMISSION_STATUS_\n */\nexport enum AddonModAssignSubmissionStatusValues {\n    SUBMITTED = 'submitted',\n    DRAFT = 'draft',\n    NEW = 'new',\n    REOPENED = 'reopened',\n    // Added by App Statuses.\n    NO_ATTEMPT = 'noattempt',\n    NO_ONLINE_SUBMISSIONS = 'noonlinesubmissions',\n    NO_SUBMISSION = 'nosubmission',\n    GRADED_FOLLOWUP_SUBMIT = 'gradedfollowupsubmit',\n}\n\n/**\n * Grading status.\n * Constants on LMS starting with ASSIGN_GRADING_STATUS_\n */\nexport enum AddonModAssignGradingStates {\n    GRADED = 'graded',\n    NOT_GRADED = 'notgraded',\n    // Added by App Statuses.\n    MARKING_WORKFLOW_STATE_RELEASED = 'released', // with ASSIGN_MARKING_WORKFLOW_STATE_RELEASED\n    GRADED_FOLLOWUP_SUBMIT = 'gradedfollowupsubmit',\n}\n\n/**\n * Reopen attempt methods.\n * Constants on LMS starting with ASSIGN_ATTEMPT_REOPEN_METHOD_\n */\nexport enum AddonModAssignAttemptReopenMethodValues {\n    NONE = 'none',\n    MANUAL = 'manual',\n    UNTILPASS = 'untilpass',\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}