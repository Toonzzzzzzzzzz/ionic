{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSyncBaseProvider } from '@classes/base-sync';\nimport { AddonMessagesOffline } from './messages-offline';\nimport { AddonMessagesProvider, AddonMessages } from './messages';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreTextUtils } from '@services/utils/text';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to sync messages.\n */\nexport class AddonMessagesSyncProvider extends CoreSyncBaseProvider {\n  constructor() {\n    super('AddonMessagesSync');\n  }\n  /**\n   * Get the ID of a discussion sync.\n   *\n   * @param conversationId Conversation ID.\n   * @param userId User ID talking to (if no conversation ID).\n   * @returns Sync ID.\n   */\n  getSyncId(conversationId, userId) {\n    if (conversationId) {\n      return 'conversationid:' + conversationId;\n    } else if (userId) {\n      return 'userid:' + userId;\n    } else {\n      // Should not happen.\n      throw new CoreError('Incorrect messages sync id.');\n    }\n  }\n  /**\n   * Try to synchronize all the discussions in a certain site or in all sites.\n   *\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @param onlyDeviceOffline True to only sync discussions that failed because device was offline,\n   *                          false to sync all.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllDiscussions(siteId, onlyDeviceOffline = false) {\n    const syncFunctionLog = 'all discussions' + (onlyDeviceOffline ? ' (Only offline)' : '');\n    return this.syncOnSites(syncFunctionLog, siteId => this.syncAllDiscussionsFunc(onlyDeviceOffline, siteId), siteId);\n  }\n  /**\n   * Get all messages pending to be sent in the site.\n   *\n   * @param onlyDeviceOffline True to only sync discussions that failed because device was offline.\n   * @param siteId Site ID to sync. If not defined, sync all sites.\n   * @returns Promise resolved if sync is successful, rejected if sync fails.\n   */\n  syncAllDiscussionsFunc(onlyDeviceOffline, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const userIds = [];\n      const conversationIds = [];\n      const promises = [];\n      const messages = onlyDeviceOffline ? yield AddonMessagesOffline.getAllDeviceOfflineMessages(siteId) : yield AddonMessagesOffline.getAllMessages(siteId);\n      // Get all the conversations to be synced.\n      messages.forEach(message => {\n        if ('conversationid' in message) {\n          if (conversationIds.indexOf(message.conversationid) == -1) {\n            conversationIds.push(message.conversationid);\n          }\n        } else if (userIds.indexOf(message.touserid) == -1) {\n          userIds.push(message.touserid);\n        }\n      });\n      // Sync all conversations.\n      conversationIds.forEach(conversationId => {\n        promises.push(_this.syncDiscussion(conversationId, undefined, siteId).then(result => {\n          if (result === undefined) {\n            return;\n          }\n          // Sync successful, send event.\n          CoreEvents.trigger(AddonMessagesSyncProvider.AUTO_SYNCED, result, siteId);\n          return;\n        }));\n      });\n      userIds.forEach(userId => {\n        promises.push(_this.syncDiscussion(undefined, userId, siteId).then(result => {\n          if (result === undefined) {\n            return;\n          }\n          // Sync successful, send event.\n          CoreEvents.trigger(AddonMessagesSyncProvider.AUTO_SYNCED, result, siteId);\n          return;\n        }));\n      });\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Synchronize a discussion.\n   *\n   * @param conversationId Conversation ID.\n   * @param userId User ID talking to (if no conversation ID).\n   * @param siteId Site ID.\n   * @returns Promise resolved with the list of warnings if sync is successful, rejected otherwise.\n   */\n  syncDiscussion(conversationId, userId, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    const syncId = this.getSyncId(conversationId, userId);\n    const currentSyncPromise = this.getOngoingSync(syncId, siteId);\n    if (currentSyncPromise) {\n      // There's already a sync ongoing for this conversation, return the promise.\n      return currentSyncPromise;\n    }\n    return this.addOngoingSync(syncId, this.performSyncDiscussion(conversationId, userId, siteId), siteId);\n  }\n  /**\n   * Perform the synchronization of a discussion.\n   *\n   * @param conversationId Conversation ID.\n   * @param userId User ID talking to (if no conversation ID).\n   * @param siteId Site ID.\n   * @returns Promise resolved with the list of warnings if sync is successful, rejected otherwise.\n   */\n  performSyncDiscussion(conversationId, userId, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const result = {\n        warnings: [],\n        userId,\n        conversationId\n      };\n      const groupMessagingEnabled = AddonMessages.isGroupMessagingEnabled();\n      let messages;\n      const errors = [];\n      if (conversationId) {\n        _this2.logger.debug(`Try to sync conversation '${conversationId}'`);\n        messages = yield AddonMessagesOffline.getConversationMessages(conversationId, undefined, siteId);\n      } else if (userId) {\n        _this2.logger.debug(`Try to sync discussion with user '${userId}'`);\n        messages = yield AddonMessagesOffline.getMessages(userId, siteId);\n      } else {\n        // Should not happen.\n        throw new CoreError('Incorrect messages sync.');\n      }\n      if (!messages.length) {\n        // Nothing to sync.\n        return result;\n      } else if (!CoreNetwork.isOnline()) {\n        // Cannot sync in offline. Mark messages as device offline.\n        AddonMessagesOffline.setMessagesDeviceOffline(messages, true);\n        throw new CoreError('Cannot sync in offline. Mark messages as device offline.');\n      }\n      // Order message by timecreated.\n      messages = AddonMessages.sortMessages(messages);\n      // Get messages sent by the user after the first offline message was sent.\n      // We subtract some time because the message could've been saved in server before it was in the app.\n      const timeFrom = Math.floor((messages[0].timecreated - CoreConstants.WS_TIMEOUT - 1000) / 1000);\n      const onlineMessages = yield _this2.getMessagesSentAfter(timeFrom, conversationId, userId, siteId);\n      // Send the messages. Send them 1 by 1 to simulate web's behaviour and to make sure we know which message has failed.\n      for (let i = 0; i < messages.length; i++) {\n        const message = messages[i];\n        const text = ('text' in message ? message.text : message.smallmessage) || '';\n        const textFieldName = conversationId ? 'text' : 'smallmessage';\n        const wrappedText = message[textFieldName][0] != '<' ? '<p>' + text + '</p>' : text;\n        try {\n          if (onlineMessages.indexOf(wrappedText) != -1) {\n            // Message already sent, ignore it to prevent duplicates.\n          } else if (conversationId) {\n            yield AddonMessages.sendMessageToConversationOnline(conversationId, text, siteId);\n          } else if (userId) {\n            yield AddonMessages.sendMessageOnline(userId, text, siteId);\n          }\n        } catch (error) {\n          if (!CoreUtils.isWebServiceError(error)) {\n            // Error sending, stop execution.\n            if (CoreNetwork.isOnline()) {\n              // App is online, unmark deviceoffline if marked.\n              AddonMessagesOffline.setMessagesDeviceOffline(messages, false);\n            }\n            throw error;\n          }\n          // Error returned by WS. Store the error to show a warning but keep sending messages.\n          if (errors.indexOf(error) == -1) {\n            errors.push(error);\n          }\n        }\n        // Message was sent, delete it from local DB.\n        if (conversationId) {\n          yield AddonMessagesOffline.deleteConversationMessage(conversationId, text, message.timecreated, siteId);\n        } else if (userId) {\n          yield AddonMessagesOffline.deleteMessage(userId, text, message.timecreated, siteId);\n        }\n        // In some Moodle versions, wait 1 second to make sure timecreated is different.\n        // This is because there was a bug where messages with the same timecreated had a wrong order.\n        if (!groupMessagingEnabled && i < messages.length - 1) {\n          yield CoreUtils.wait(1000);\n        }\n      }\n      yield _this2.handleSyncErrors(conversationId, userId, errors, result.warnings);\n      // All done, return the warnings.\n      return result;\n    })();\n  }\n  /**\n   * Get messages sent by current user after a certain time.\n   *\n   * @param time Time in seconds.\n   * @param conversationId Conversation ID.\n   * @param userId User ID talking to (if no conversation ID).\n   * @param siteId Site ID.\n   * @returns Promise resolved with the messages texts.\n   */\n  getMessagesSentAfter(time, conversationId, userId, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const siteCurrentUserId = site.getUserId();\n      if (conversationId) {\n        try {\n          const result = yield AddonMessages.getConversationMessages(conversationId, {\n            excludePending: true,\n            ignoreCache: true,\n            timeFrom: time\n          });\n          const sentMessages = result.messages.filter(message => message.useridfrom == siteCurrentUserId);\n          return sentMessages.map(message => message.text);\n        } catch (error) {\n          if (error && error.errorcode == 'invalidresponse') {\n            // There's a bug in Moodle that causes this error if there are no new messages. Return empty array.\n            return [];\n          }\n          throw error;\n        }\n      } else if (userId) {\n        const params = {\n          useridto: userId,\n          useridfrom: siteCurrentUserId,\n          limitnum: AddonMessagesProvider.LIMIT_MESSAGES\n        };\n        const preSets = {\n          cacheKey: AddonMessages.getCacheKeyForDiscussion(userId),\n          getFromCache: false,\n          emergencyCache: false\n        };\n        const messages = yield AddonMessages.getRecentMessages(params, preSets, 0, 0, false, siteId);\n        time = time * 1000; // Convert to milliseconds.\n        const messagesAfterTime = messages.filter(message => message.timecreated >= time);\n        return messagesAfterTime.map(message => message.text);\n      } else {\n        throw new CoreError('Incorrect messages sync identifier');\n      }\n    })();\n  }\n  /**\n   * Handle sync errors.\n   *\n   * @param conversationId Conversation ID.\n   * @param userId User ID talking to (if no conversation ID).\n   * @param errors List of errors.\n   * @param warnings Array where to place the warnings.\n   * @returns Promise resolved when done.\n   */\n  handleSyncErrors(conversationId, userId, errors = [], warnings = []) {\n    return _asyncToGenerator(function* () {\n      if (!errors || errors.length <= 0) {\n        return;\n      }\n      if (conversationId) {\n        let conversationIdentifier = String(conversationId);\n        try {\n          // Get conversation name and add errors to warnings array.\n          const conversation = yield AddonMessages.getConversation(conversationId, false, false);\n          conversationIdentifier = conversation.name || String(conversationId);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n        errors.forEach(error => {\n          warnings.push(Translate.instant('addon.messages.warningconversationmessagenotsent', {\n            conversation: conversationIdentifier,\n            error: CoreTextUtils.getErrorMessageFromError(error)\n          }));\n        });\n      } else if (userId) {\n        // Get user full name and add errors to warnings array.\n        let userIdentifier = String(userId);\n        try {\n          const user = yield CoreUser.getProfile(userId, undefined, true);\n          userIdentifier = user.fullname;\n        } catch (_unused2) {\n          // Ignore errors.\n        }\n        errors.forEach(error => {\n          warnings.push(Translate.instant('addon.messages.warningmessagenotsent', {\n            user: userIdentifier,\n            error: CoreTextUtils.getErrorMessageFromError(error)\n          }));\n        });\n      }\n    })();\n  }\n  /**\n   * If there's an ongoing sync for a certain conversation, wait for it to end.\n   * If there's no sync ongoing the promise will be resolved right away.\n   *\n   * @param conversationId Conversation ID.\n   * @param userId User ID talking to (if no conversation ID).\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when there's no sync going on for the identifier.\n   */\n  waitForSyncConversation(conversationId, userId, siteId) {\n    const syncId = this.getSyncId(conversationId, userId);\n    return this.waitForSync(syncId, siteId);\n  }\n}\n_class = AddonMessagesSyncProvider;\n_class.AUTO_SYNCED = 'addon_messages_autom_synced';\n_class.ɵfac = function AddonMessagesSyncProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonMessagesSync = makeSingleton(AddonMessagesSyncProvider);","map":{"version":3,"names":["CoreSyncBaseProvider","AddonMessagesOffline","AddonMessagesProvider","AddonMessages","CoreEvents","CoreUtils","makeSingleton","Translate","CoreSites","CoreNetwork","CoreConstants","CoreUser","CoreError","CoreTextUtils","AddonMessagesSyncProvider","constructor","getSyncId","conversationId","userId","syncAllDiscussions","siteId","onlyDeviceOffline","syncFunctionLog","syncOnSites","syncAllDiscussionsFunc","_this","_asyncToGenerator","userIds","conversationIds","promises","messages","getAllDeviceOfflineMessages","getAllMessages","forEach","message","indexOf","conversationid","push","touserid","syncDiscussion","undefined","then","result","trigger","AUTO_SYNCED","Promise","all","getCurrentSiteId","syncId","currentSyncPromise","getOngoingSync","addOngoingSync","performSyncDiscussion","_this2","warnings","groupMessagingEnabled","isGroupMessagingEnabled","errors","logger","debug","getConversationMessages","getMessages","length","isOnline","setMessagesDeviceOffline","sortMessages","timeFrom","Math","floor","timecreated","WS_TIMEOUT","onlineMessages","getMessagesSentAfter","i","text","smallmessage","textFieldName","wrappedText","sendMessageToConversationOnline","sendMessageOnline","error","isWebServiceError","deleteConversationMessage","deleteMessage","wait","handleSyncErrors","time","site","getSite","siteCurrentUserId","getUserId","excludePending","ignoreCache","sentMessages","filter","useridfrom","map","errorcode","params","useridto","limitnum","LIMIT_MESSAGES","preSets","cacheKey","getCacheKeyForDiscussion","getFromCache","emergencyCache","getRecentMessages","messagesAfterTime","conversationIdentifier","String","conversation","getConversation","name","_unused","instant","getErrorMessageFromError","userIdentifier","user","getProfile","fullname","_unused2","waitForSyncConversation","waitForSync","_class","factory","ɵfac","providedIn","AddonMessagesSync"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/messages/services/messages-sync.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSyncBaseProvider } from '@classes/base-sync';\nimport {\n    AddonMessagesOffline, AddonMessagesOfflineAnyMessagesFormatted,\n} from './messages-offline';\nimport {\n    AddonMessagesProvider,\n    AddonMessages,\n    AddonMessagesGetMessagesWSParams,\n} from './messages';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, Translate } from '@singletons';\nimport { CoreSites } from '@services/sites';\nimport { CoreNetwork } from '@services/network';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreUser } from '@features/user/services/user';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreTextErrorObject, CoreTextUtils } from '@services/utils/text';\nimport { CoreSiteWSPreSets } from '@classes/sites/authenticated-site';\n\n/**\n * Service to sync messages.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonMessagesSyncProvider extends CoreSyncBaseProvider<AddonMessagesSyncEvents> {\n\n    static readonly AUTO_SYNCED = 'addon_messages_autom_synced';\n\n    constructor() {\n        super('AddonMessagesSync');\n    }\n\n    /**\n     * Get the ID of a discussion sync.\n     *\n     * @param conversationId Conversation ID.\n     * @param userId User ID talking to (if no conversation ID).\n     * @returns Sync ID.\n     */\n    protected getSyncId(conversationId?: number, userId?: number): string {\n        if (conversationId) {\n            return 'conversationid:' + conversationId;\n        } else if (userId) {\n            return 'userid:' + userId;\n        } else {\n            // Should not happen.\n            throw new CoreError('Incorrect messages sync id.');\n        }\n    }\n\n    /**\n     * Try to synchronize all the discussions in a certain site or in all sites.\n     *\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @param onlyDeviceOffline True to only sync discussions that failed because device was offline,\n     *                          false to sync all.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    syncAllDiscussions(siteId?: string, onlyDeviceOffline: boolean = false): Promise<void> {\n        const syncFunctionLog = 'all discussions' + (onlyDeviceOffline ? ' (Only offline)' : '');\n\n        return this.syncOnSites(syncFunctionLog, (siteId) => this.syncAllDiscussionsFunc(onlyDeviceOffline, siteId), siteId);\n    }\n\n    /**\n     * Get all messages pending to be sent in the site.\n     *\n     * @param onlyDeviceOffline True to only sync discussions that failed because device was offline.\n     * @param siteId Site ID to sync. If not defined, sync all sites.\n     * @returns Promise resolved if sync is successful, rejected if sync fails.\n     */\n    protected async syncAllDiscussionsFunc(onlyDeviceOffline: boolean, siteId: string): Promise<void> {\n        const userIds: number[] = [];\n        const conversationIds: number[] = [];\n        const promises: Promise<void>[] = [];\n\n        const messages = onlyDeviceOffline\n            ? await AddonMessagesOffline.getAllDeviceOfflineMessages(siteId)\n            : await AddonMessagesOffline.getAllMessages(siteId);\n\n        // Get all the conversations to be synced.\n        messages.forEach((message) => {\n            if ('conversationid' in message) {\n                if (conversationIds.indexOf(message.conversationid) == -1) {\n                    conversationIds.push(message.conversationid);\n                }\n            } else if (userIds.indexOf(message.touserid) == -1) {\n                userIds.push(message.touserid);\n            }\n        });\n\n        // Sync all conversations.\n        conversationIds.forEach((conversationId) => {\n            promises.push(this.syncDiscussion(conversationId, undefined, siteId).then((result) => {\n                if (result === undefined) {\n                    return;\n                }\n\n                // Sync successful, send event.\n                CoreEvents.trigger(AddonMessagesSyncProvider.AUTO_SYNCED, result, siteId);\n\n                return;\n            }));\n        });\n\n        userIds.forEach((userId) => {\n            promises.push(this.syncDiscussion(undefined, userId, siteId).then((result) => {\n                if (result === undefined) {\n                    return;\n                }\n\n                // Sync successful, send event.\n                CoreEvents.trigger(AddonMessagesSyncProvider.AUTO_SYNCED, result, siteId);\n\n                return;\n            }));\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Synchronize a discussion.\n     *\n     * @param conversationId Conversation ID.\n     * @param userId User ID talking to (if no conversation ID).\n     * @param siteId Site ID.\n     * @returns Promise resolved with the list of warnings if sync is successful, rejected otherwise.\n     */\n    syncDiscussion(conversationId?: number, userId?: number, siteId?: string): Promise<AddonMessagesSyncEvents> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        const syncId = this.getSyncId(conversationId, userId);\n\n        const currentSyncPromise = this.getOngoingSync(syncId, siteId);\n        if (currentSyncPromise) {\n            // There's already a sync ongoing for this conversation, return the promise.\n            return currentSyncPromise;\n        }\n\n        return this.addOngoingSync(syncId, this.performSyncDiscussion(conversationId, userId, siteId), siteId);\n    }\n\n    /**\n     * Perform the synchronization of a discussion.\n     *\n     * @param conversationId Conversation ID.\n     * @param userId User ID talking to (if no conversation ID).\n     * @param siteId Site ID.\n     * @returns Promise resolved with the list of warnings if sync is successful, rejected otherwise.\n     */\n    protected async performSyncDiscussion(\n        conversationId: number | undefined,\n        userId: number | undefined,\n        siteId: string,\n    ): Promise<AddonMessagesSyncEvents> {\n        const result: AddonMessagesSyncEvents = {\n            warnings: [],\n            userId,\n            conversationId,\n        };\n\n        const groupMessagingEnabled = AddonMessages.isGroupMessagingEnabled();\n        let messages: AddonMessagesOfflineAnyMessagesFormatted[];\n        const errors: (string | CoreError | CoreTextErrorObject)[] = [];\n\n        if (conversationId) {\n            this.logger.debug(`Try to sync conversation '${conversationId}'`);\n            messages = await AddonMessagesOffline.getConversationMessages(conversationId, undefined, siteId);\n        } else if (userId) {\n            this.logger.debug(`Try to sync discussion with user '${userId}'`);\n            messages = await AddonMessagesOffline.getMessages(userId, siteId);\n        } else {\n            // Should not happen.\n            throw new CoreError('Incorrect messages sync.');\n        }\n\n        if (!messages.length) {\n            // Nothing to sync.\n            return result;\n        } else if (!CoreNetwork.isOnline()) {\n            // Cannot sync in offline. Mark messages as device offline.\n            AddonMessagesOffline.setMessagesDeviceOffline(messages, true);\n\n            throw new CoreError('Cannot sync in offline. Mark messages as device offline.');\n        }\n\n        // Order message by timecreated.\n        messages = AddonMessages.sortMessages(messages);\n\n        // Get messages sent by the user after the first offline message was sent.\n        // We subtract some time because the message could've been saved in server before it was in the app.\n        const timeFrom = Math.floor((messages[0].timecreated - CoreConstants.WS_TIMEOUT - 1000) / 1000);\n\n        const onlineMessages = await this.getMessagesSentAfter(timeFrom, conversationId, userId, siteId);\n\n        // Send the messages. Send them 1 by 1 to simulate web's behaviour and to make sure we know which message has failed.\n        for (let i = 0; i < messages.length; i++) {\n            const message = messages[i];\n\n            const text = ('text' in message ? message.text : message.smallmessage) || '';\n            const textFieldName = conversationId ? 'text' : 'smallmessage';\n            const wrappedText = message[textFieldName][0] != '<' ? '<p>' + text + '</p>' : text;\n\n            try {\n                if (onlineMessages.indexOf(wrappedText) != -1) {\n                    // Message already sent, ignore it to prevent duplicates.\n                } else if (conversationId) {\n                    await AddonMessages.sendMessageToConversationOnline(conversationId, text, siteId);\n                } else if (userId) {\n                    await AddonMessages.sendMessageOnline(userId, text, siteId);\n                }\n            } catch (error) {\n                if (!CoreUtils.isWebServiceError(error)) {\n                    // Error sending, stop execution.\n                    if (CoreNetwork.isOnline()) {\n                        // App is online, unmark deviceoffline if marked.\n                        AddonMessagesOffline.setMessagesDeviceOffline(messages, false);\n                    }\n\n                    throw error;\n                }\n\n                // Error returned by WS. Store the error to show a warning but keep sending messages.\n                if (errors.indexOf(error) == -1) {\n                    errors.push(error);\n                }\n            }\n\n            // Message was sent, delete it from local DB.\n            if (conversationId) {\n                await AddonMessagesOffline.deleteConversationMessage(conversationId, text, message.timecreated, siteId);\n            } else if (userId) {\n                await AddonMessagesOffline.deleteMessage(userId, text, message.timecreated, siteId);\n            }\n\n            // In some Moodle versions, wait 1 second to make sure timecreated is different.\n            // This is because there was a bug where messages with the same timecreated had a wrong order.\n            if (!groupMessagingEnabled && i < messages.length - 1) {\n                await CoreUtils.wait(1000);\n            }\n        }\n\n        await this.handleSyncErrors(conversationId, userId, errors, result.warnings);\n\n        // All done, return the warnings.\n        return result;\n    }\n\n    /**\n     * Get messages sent by current user after a certain time.\n     *\n     * @param time Time in seconds.\n     * @param conversationId Conversation ID.\n     * @param userId User ID talking to (if no conversation ID).\n     * @param siteId Site ID.\n     * @returns Promise resolved with the messages texts.\n     */\n    protected async getMessagesSentAfter(\n        time: number,\n        conversationId?: number,\n        userId?: number,\n        siteId?: string,\n    ): Promise<string[]> {\n        const site = await CoreSites.getSite(siteId);\n\n        const siteCurrentUserId = site.getUserId();\n\n        if (conversationId) {\n            try {\n                const result = await AddonMessages.getConversationMessages(conversationId, {\n                    excludePending: true,\n                    ignoreCache: true,\n                    timeFrom: time,\n                });\n\n                const sentMessages = result.messages.filter((message) => message.useridfrom == siteCurrentUserId);\n\n                return sentMessages.map((message) => message.text);\n            } catch (error) {\n                if (error && error.errorcode == 'invalidresponse') {\n                    // There's a bug in Moodle that causes this error if there are no new messages. Return empty array.\n                    return [];\n                }\n\n                throw error;\n            }\n        } else if (userId) {\n            const params: AddonMessagesGetMessagesWSParams = {\n                useridto: userId,\n                useridfrom: siteCurrentUserId,\n                limitnum: AddonMessagesProvider.LIMIT_MESSAGES,\n            };\n            const preSets: CoreSiteWSPreSets = {\n                cacheKey: AddonMessages.getCacheKeyForDiscussion(userId),\n                getFromCache: false,\n                emergencyCache: false,\n            };\n\n            const messages = await AddonMessages.getRecentMessages(params, preSets, 0, 0, false, siteId);\n\n            time = time * 1000; // Convert to milliseconds.\n            const messagesAfterTime = messages.filter((message) => message.timecreated >= time);\n\n            return messagesAfterTime.map((message) => message.text);\n        } else {\n            throw new CoreError('Incorrect messages sync identifier');\n        }\n    }\n\n    /**\n     * Handle sync errors.\n     *\n     * @param conversationId Conversation ID.\n     * @param userId User ID talking to (if no conversation ID).\n     * @param errors List of errors.\n     * @param warnings Array where to place the warnings.\n     * @returns Promise resolved when done.\n     */\n    protected async handleSyncErrors(\n        conversationId?: number,\n        userId?: number,\n        errors: (string | CoreError | CoreTextErrorObject)[] = [],\n        warnings: string[] = [],\n    ): Promise<void> {\n        if (!errors || errors.length <= 0) {\n            return;\n        }\n\n        if (conversationId) {\n            let conversationIdentifier = String(conversationId);\n            try {\n                // Get conversation name and add errors to warnings array.\n                const conversation = await AddonMessages.getConversation(conversationId, false, false);\n                conversationIdentifier = conversation.name || String(conversationId);\n            } catch {\n                // Ignore errors.\n            }\n\n            errors.forEach((error) => {\n                warnings.push(Translate.instant('addon.messages.warningconversationmessagenotsent', {\n                    conversation: conversationIdentifier,\n                    error: CoreTextUtils.getErrorMessageFromError(error),\n                }));\n            });\n        } else if (userId) {\n\n            // Get user full name and add errors to warnings array.\n            let userIdentifier = String(userId);\n            try {\n                const user = await CoreUser.getProfile(userId, undefined, true);\n                userIdentifier = user.fullname;\n            } catch {\n                // Ignore errors.\n            }\n\n            errors.forEach((error) => {\n                warnings.push(Translate.instant('addon.messages.warningmessagenotsent', {\n                    user: userIdentifier,\n                    error: CoreTextUtils.getErrorMessageFromError(error),\n                }));\n            });\n        }\n    }\n\n    /**\n     * If there's an ongoing sync for a certain conversation, wait for it to end.\n     * If there's no sync ongoing the promise will be resolved right away.\n     *\n     * @param conversationId Conversation ID.\n     * @param userId User ID talking to (if no conversation ID).\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when there's no sync going on for the identifier.\n     */\n    waitForSyncConversation(\n        conversationId?: number,\n        userId?: number,\n        siteId?: string,\n    ): Promise<AddonMessagesSyncEvents | undefined> {\n        const syncId = this.getSyncId(conversationId, userId);\n\n        return this.waitForSync(syncId, siteId);\n    }\n\n}\n\nexport const AddonMessagesSync = makeSingleton(AddonMessagesSyncProvider);\n\nexport type AddonMessagesSyncEvents = {\n    warnings: string[];\n    conversationId?: number;\n    userId?: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}