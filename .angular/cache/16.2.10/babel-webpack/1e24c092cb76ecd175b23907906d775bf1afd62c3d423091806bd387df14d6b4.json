{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreQuestion } from '@features/question/services/question';\nimport { CoreQuestionDelegate } from '@features/question/services/question-delegate';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to support deferred feedback question behaviour.\n */\nexport class AddonQbehaviourDeferredFeedbackHandlerService {\n  constructor() {\n    this.name = 'AddonQbehaviourDeferredFeedback';\n    this.type = 'deferredfeedback';\n  }\n  /**\n   * Determine a question new state based on its answer(s).\n   *\n   * @param component Component the question belongs to.\n   * @param attemptId Attempt ID the question belongs to.\n   * @param question The question.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns New state (or promise resolved with state).\n   */\n  determineNewState(component, attemptId, question, componentId, siteId) {\n    return this.determineNewStateDeferred(component, attemptId, question, componentId, siteId);\n  }\n  /**\n   * Determine a question new state based on its answer(s) for deferred question behaviour.\n   *\n   * @param component Component the question belongs to.\n   * @param attemptId Attempt ID the question belongs to.\n   * @param question The question.\n   * @param componentId Component ID.\n   * @param siteId Site ID. If not defined, current site.\n   * @param isCompleteFn Function to override the default isCompleteResponse check.\n   * @param isSameFn Function to override the default isSameResponse check.\n   * @returns Promise resolved with state.\n   */\n  determineNewStateDeferred(component, attemptId, question, componentId, siteId, isCompleteFn, isSameFn) {\n    return _asyncToGenerator(function* () {\n      // Check if we have local data for the question.\n      let dbQuestion = question;\n      try {\n        dbQuestion = yield CoreQuestion.getQuestion(component, attemptId, question.slot, siteId);\n      } catch (error) {\n        // No entry found, use the original data.\n      }\n      const state = CoreQuestion.getState(dbQuestion.state);\n      if (state.finished || !state.active) {\n        // Question is finished, it cannot change.\n        return state;\n      }\n      const newBasicAnswers = CoreQuestion.getBasicAnswers(question.answers || {});\n      if (dbQuestion.state) {\n        // Question already has a state stored. Check if answer has changed.\n        const prevAnswersList = yield CoreQuestion.getQuestionAnswers(component, attemptId, question.slot, false, siteId);\n        const prevAnswers = CoreQuestion.convertAnswersArrayToObject(prevAnswersList, true);\n        const prevBasicAnswers = CoreQuestion.getBasicAnswers(prevAnswers);\n        // If answers haven't changed the state is the same.\n        let sameResponse = false;\n        if (isSameFn) {\n          sameResponse = isSameFn(question, prevAnswers, prevBasicAnswers, question.answers || {}, newBasicAnswers, component, componentId);\n        } else {\n          sameResponse = CoreQuestionDelegate.isSameResponse(question, prevBasicAnswers, newBasicAnswers, component, componentId);\n        }\n        if (sameResponse) {\n          return state;\n        }\n      }\n      // Answers have changed. Now check if the response is complete and calculate the new state.\n      let complete;\n      let newState;\n      if (isCompleteFn) {\n        // Pass all the answers since some behaviours might need the extra data.\n        complete = isCompleteFn(question, question.answers || {}, component, componentId);\n      } else {\n        // Only pass the basic answers since questions should be independent of extra data.\n        complete = CoreQuestionDelegate.isCompleteResponse(question, newBasicAnswers, component, componentId);\n      }\n      if (complete < 0) {\n        newState = 'cannotdeterminestatus';\n      } else if (complete > 0) {\n        newState = 'complete';\n      } else {\n        const gradable = CoreQuestionDelegate.isGradableResponse(question, newBasicAnswers, component, componentId);\n        if (gradable < 0) {\n          newState = 'cannotdeterminestatus';\n        } else if (gradable > 0) {\n          newState = 'invalid';\n        } else {\n          newState = 'todo';\n        }\n      }\n      return CoreQuestion.getState(newState);\n    })();\n  }\n  /**\n   * Whether or not the handler is enabled on a site level.\n   *\n   * @returns True or promise resolved with true if enabled.\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n}\n_class = AddonQbehaviourDeferredFeedbackHandlerService;\n_class.ɵfac = function AddonQbehaviourDeferredFeedbackHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonQbehaviourDeferredFeedbackHandler = makeSingleton(AddonQbehaviourDeferredFeedbackHandlerService);","map":{"version":3,"names":["CoreQuestion","CoreQuestionDelegate","makeSingleton","AddonQbehaviourDeferredFeedbackHandlerService","constructor","name","type","determineNewState","component","attemptId","question","componentId","siteId","determineNewStateDeferred","isCompleteFn","isSameFn","_asyncToGenerator","dbQuestion","getQuestion","slot","error","state","getState","finished","active","newBasicAnswers","getBasicAnswers","answers","prevAnswersList","getQuestionAnswers","prevAnswers","convertAnswersArrayToObject","prevBasicAnswers","sameResponse","isSameResponse","complete","newState","isCompleteResponse","gradable","isGradableResponse","isEnabled","factory","ɵfac","providedIn","AddonQbehaviourDeferredFeedbackHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/qbehaviour/deferredfeedback/services/handlers/deferredfeedback.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\n\nimport { CoreQuestionBehaviourHandler, CoreQuestionQuestionWithAnswers } from '@features/question/services/behaviour-delegate';\nimport { CoreQuestionDBRecord } from '@features/question/services/database/question';\nimport {\n    CoreQuestion,\n    CoreQuestionQuestionParsed,\n    CoreQuestionsAnswers,\n    CoreQuestionState,\n} from '@features/question/services/question';\nimport { CoreQuestionDelegate } from '@features/question/services/question-delegate';\nimport { makeSingleton } from '@singletons';\n\n/**\n * Handler to support deferred feedback question behaviour.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonQbehaviourDeferredFeedbackHandlerService implements CoreQuestionBehaviourHandler {\n\n    name = 'AddonQbehaviourDeferredFeedback';\n    type = 'deferredfeedback';\n\n    /**\n     * Determine a question new state based on its answer(s).\n     *\n     * @param component Component the question belongs to.\n     * @param attemptId Attempt ID the question belongs to.\n     * @param question The question.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns New state (or promise resolved with state).\n     */\n    determineNewState(\n        component: string,\n        attemptId: number,\n        question: CoreQuestionQuestionWithAnswers,\n        componentId: string | number,\n        siteId?: string,\n    ): CoreQuestionState | Promise<CoreQuestionState> {\n        return this.determineNewStateDeferred(component, attemptId, question, componentId, siteId);\n    }\n\n    /**\n     * Determine a question new state based on its answer(s) for deferred question behaviour.\n     *\n     * @param component Component the question belongs to.\n     * @param attemptId Attempt ID the question belongs to.\n     * @param question The question.\n     * @param componentId Component ID.\n     * @param siteId Site ID. If not defined, current site.\n     * @param isCompleteFn Function to override the default isCompleteResponse check.\n     * @param isSameFn Function to override the default isSameResponse check.\n     * @returns Promise resolved with state.\n     */\n    async determineNewStateDeferred(\n        component: string,\n        attemptId: number,\n        question: CoreQuestionQuestionWithAnswers,\n        componentId: string | number,\n        siteId?: string,\n        isCompleteFn?: isCompleteResponseFunction,\n        isSameFn?: isSameResponseFunction,\n    ): Promise<CoreQuestionState> {\n\n        // Check if we have local data for the question.\n        let dbQuestion: CoreQuestionDBRecord | CoreQuestionQuestionWithAnswers = question;\n        try {\n            dbQuestion = await CoreQuestion.getQuestion(component, attemptId, question.slot, siteId);\n        } catch (error) {\n            // No entry found, use the original data.\n        }\n\n        const state = CoreQuestion.getState(dbQuestion.state);\n\n        if (state.finished || !state.active) {\n            // Question is finished, it cannot change.\n            return state;\n        }\n\n        const newBasicAnswers = CoreQuestion.getBasicAnswers(question.answers || {});\n\n        if (dbQuestion.state) {\n            // Question already has a state stored. Check if answer has changed.\n            const prevAnswersList = await CoreQuestion.getQuestionAnswers(\n                component,\n                attemptId,\n                question.slot,\n                false,\n                siteId,\n            );\n            const prevAnswers = CoreQuestion.convertAnswersArrayToObject(prevAnswersList, true);\n            const prevBasicAnswers = CoreQuestion.getBasicAnswers(prevAnswers);\n\n            // If answers haven't changed the state is the same.\n            let sameResponse = false;\n\n            if (isSameFn) {\n                sameResponse = isSameFn(\n                    question,\n                    prevAnswers,\n                    prevBasicAnswers,\n                    question.answers || {},\n                    newBasicAnswers,\n                    component,\n                    componentId,\n                );\n            } else {\n                sameResponse = CoreQuestionDelegate.isSameResponse(\n                    question,\n                    prevBasicAnswers,\n                    newBasicAnswers,\n                    component,\n                    componentId,\n                );\n            }\n\n            if (sameResponse) {\n                return state;\n            }\n        }\n\n        // Answers have changed. Now check if the response is complete and calculate the new state.\n        let complete: number;\n        let newState: string;\n\n        if (isCompleteFn) {\n            // Pass all the answers since some behaviours might need the extra data.\n            complete = isCompleteFn(question, question.answers || {}, component, componentId);\n        } else {\n            // Only pass the basic answers since questions should be independent of extra data.\n            complete = CoreQuestionDelegate.isCompleteResponse(question, newBasicAnswers, component, componentId);\n        }\n\n        if (complete < 0) {\n            newState = 'cannotdeterminestatus';\n        } else if (complete > 0) {\n            newState = 'complete';\n        } else {\n            const gradable = CoreQuestionDelegate.isGradableResponse(question, newBasicAnswers, component, componentId);\n            if (gradable < 0) {\n                newState = 'cannotdeterminestatus';\n            } else if (gradable > 0) {\n                newState = 'invalid';\n            } else {\n                newState = 'todo';\n            }\n        }\n\n        return CoreQuestion.getState(newState);\n    }\n\n    /**\n     * Whether or not the handler is enabled on a site level.\n     *\n     * @returns True or promise resolved with true if enabled.\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n}\n\nexport const AddonQbehaviourDeferredFeedbackHandler = makeSingleton(AddonQbehaviourDeferredFeedbackHandlerService);\n\n/**\n * Check if a response is complete.\n *\n * @param question The question.\n * @param answers Object with the question answers (without prefix).\n * @param component The component the question is related to.\n * @param componentId Component ID.\n * @returns 1 if complete, 0 if not complete, -1 if cannot determine.\n */\nexport type isCompleteResponseFunction = (\n    question: CoreQuestionQuestionParsed,\n    answers: CoreQuestionsAnswers,\n    component: string,\n    componentId: string | number,\n) => number;\n\n/**\n * Check if two responses are the same.\n *\n * @param question Question.\n * @param prevAnswers Object with the previous question answers.\n * @param prevBasicAnswers Object with the previous basic\" answers (without sequencecheck, certainty, ...).\n * @param newAnswers Object with the new question answers.\n * @param newBasicAnswers Object with the previous basic\" answers (without sequencecheck, certainty, ...).\n * @param component The component the question is related to.\n * @param componentId Component ID.\n * @returns Whether they're the same.\n */\nexport type isSameResponseFunction = (\n    question: CoreQuestionQuestionParsed,\n    prevAnswers: CoreQuestionsAnswers,\n    prevBasicAnswers: CoreQuestionsAnswers,\n    newAnswers: CoreQuestionsAnswers,\n    newBasicAnswers: CoreQuestionsAnswers,\n    component: string,\n    componentId: string | number,\n) => boolean;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}