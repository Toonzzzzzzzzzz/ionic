{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, NgZone } from '@singletons';\nimport { TestingBehatRuntime } from './behat-runtime';\nimport * as i0 from \"@angular/core\";\n/**\n * Behat block JS manager.\n */\nexport class TestingBehatBlockingService {\n  constructor() {\n    this.waitingBlocked = false;\n    this.recentMutation = false;\n    this.lastMutation = 0;\n    this.initialized = false;\n    this.keyIndex = 0;\n  }\n  /**\n   * Listen to mutations and override XML Requests.\n   */\n  init() {\n    var _win$M, _win$M$util, _win$M$util$pending_j;\n    if (this.initialized) {\n      return;\n    }\n    this.initialized = true;\n    this.listenToMutations();\n    this.xmlRequestOverride();\n    const win = window;\n    // Set up the M object - only pending_js is implemented.\n    win.M = (_win$M = win.M) !== null && _win$M !== void 0 ? _win$M : {};\n    win.M.util = (_win$M$util = win.M.util) !== null && _win$M$util !== void 0 ? _win$M$util : {};\n    win.M.util.pending_js = (_win$M$util$pending_j = win.M.util.pending_js) !== null && _win$M$util$pending_j !== void 0 ? _win$M$util$pending_j : [];\n    TestingBehatRuntime.log('Initialized!');\n  }\n  /**\n   * Get pending list on window M object.\n   *\n   * @returns List of pending JS blockers.\n   */\n  get pendingList() {\n    var _win$M2;\n    const win = window;\n    return ((_win$M2 = win.M) === null || _win$M2 === void 0 || (_win$M2 = _win$M2.util) === null || _win$M2 === void 0 ? void 0 : _win$M2.pending_js) || [];\n  }\n  /**\n   * Set pending list on window M object.\n   */\n  set pendingList(values) {\n    var _win$M3;\n    const win = window;\n    if (!((_win$M3 = win.M) !== null && _win$M3 !== void 0 && (_win$M3 = _win$M3.util) !== null && _win$M3 !== void 0 && _win$M3.pending_js)) {\n      return;\n    }\n    win.M.util.pending_js = values;\n  }\n  /**\n   * Adds a pending key to the array.\n   *\n   * @param key Key to add. It will be generated if none.\n   * @returns Key name.\n   */\n  block(key = '') {\n    // Add a special DELAY entry whenever another entry is added.\n    if (this.pendingList.length === 0) {\n      this.pendingList.push('DELAY');\n    }\n    if (!key) {\n      key = 'generated-' + this.keyIndex;\n      this.keyIndex++;\n    }\n    this.pendingList.push(key);\n    TestingBehatRuntime.log('PENDING+: ' + this.pendingList);\n    return key;\n  }\n  /**\n   * Removes a pending key from the array. If this would clear the array, the actual clear only\n   * takes effect after the queued events are finished.\n   *\n   * @param key Key to remove\n   */\n  unblock(key) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Remove the key immediately.\n      _this.pendingList = _this.pendingList.filter(x => x !== key);\n      TestingBehatRuntime.log('PENDING-: ' + _this.pendingList);\n      // If the only thing left is DELAY, then remove that as well, later...\n      if (_this.pendingList.length === 1) {\n        if (!document.hidden) {\n          // When tab is not active, ticks should be slower and may do Behat to fail.\n          // From Timers API:\n          // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\n          // \"This API does not guarantee that timers will run exactly on schedule.\n          // Delays due to CPU load, other tasks, etc, are to be expected.\"\n          yield CoreUtils.nextTicks(10);\n        }\n        // Check there isn't a spinner...\n        yield _this.checkUIBlocked();\n        // Only remove it if the pending array is STILL empty after all that.\n        if (_this.pendingList.length === 1) {\n          _this.pendingList = [];\n          TestingBehatRuntime.log('PENDING-: ' + _this.pendingList);\n        }\n      }\n    })();\n  }\n  /**\n   * Adds a pending key to the array, but removes it after some ticks.\n   */\n  delay() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const key = _this2.block('forced-delay');\n      _this2.unblock(key);\n    })();\n  }\n  /**\n   * It would be really beautiful if you could detect CSS transitions and animations, that would\n   * cover almost everything, but sadly there is no way to do this because the transitionstart\n   * and animationcancel events are not implemented in Chrome, so we cannot detect either of\n   * these reliably. Instead, we have to look for any DOM changes and do horrible polling. Most\n   * of the animations are set to 500ms so we allow it to continue from 500ms after any DOM\n   * change.\n   */\n  listenToMutations() {\n    // Set listener using the mutation callback.\n    const observer = new MutationObserver(() => {\n      this.lastMutation = Date.now();\n      if (!this.recentMutation) {\n        this.recentMutation = true;\n        this.block('dom-mutation');\n        setTimeout(() => {\n          this.pollRecentMutation();\n        }, 500);\n      }\n      // Also update the spinner presence if needed.\n      this.checkUIBlocked();\n    });\n    observer.observe(document, {\n      attributes: true,\n      childList: true,\n      subtree: true\n    });\n  }\n  /**\n   * Called from the mutation callback to remove the pending tag after 500ms if nothing else\n   * gets mutated.\n   *\n   * This will be called after 500ms, then every 100ms until there have been no mutation events\n   * for 500ms.\n   */\n  pollRecentMutation() {\n    if (Date.now() - this.lastMutation > 500) {\n      this.recentMutation = false;\n      this.unblock('dom-mutation');\n      return;\n    }\n    setTimeout(() => {\n      this.pollRecentMutation();\n    }, 100);\n  }\n  /**\n   * Checks if a loading spinner is present and visible; if so, adds it to the pending array\n   * (and if not, removes it).\n   */\n  checkUIBlocked() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield CoreUtils.nextTick();\n      const blockingElements = Array.from(document.querySelectorAll('div.core-loading-container, ion-loading, .click-block-active'));\n      const isBlocked = blockingElements.some(element => {\n        if (!element.offsetParent) {\n          return false;\n        }\n        const slide = element.closest('swiper-slide');\n        if (slide && !slide.classList.contains('swiper-slide-active')) {\n          return false;\n        }\n        return true;\n      });\n      if (isBlocked) {\n        if (!_this3.waitingBlocked) {\n          _this3.block('blocked');\n          _this3.waitingBlocked = true;\n        }\n      } else {\n        if (_this3.waitingBlocked) {\n          _this3.unblock('blocked');\n          _this3.waitingBlocked = false;\n        }\n      }\n    })();\n  }\n  /**\n   * Override XMLHttpRequest to mark things pending while there is a request waiting.\n   */\n  xmlRequestOverride() {\n    const realOpen = XMLHttpRequest.prototype.open;\n    let requestIndex = 0;\n    XMLHttpRequest.prototype.open = function (...args) {\n      NgZone.run(() => {\n        const index = requestIndex++;\n        const key = 'httprequest-' + index;\n        const isAsync = args[2] !== false;\n        try {\n          // Add to the list of pending requests.\n          TestingBehatBlocking.block(key);\n          // Detect when it finishes and remove it from the list.\n          if (isAsync) {\n            this.addEventListener('loadend', () => {\n              TestingBehatBlocking.unblock(key);\n            });\n          } else {\n            const realSend = this.send;\n            this.send = (...args) => {\n              try {\n                return realSend.apply(this, args);\n              } finally {\n                TestingBehatBlocking.unblock(key);\n              }\n            };\n          }\n          return realOpen.apply(this, args);\n        } catch (error) {\n          TestingBehatBlocking.unblock(key);\n          throw error;\n        }\n      });\n    };\n  }\n}\n_class = TestingBehatBlockingService;\n_class.ɵfac = function TestingBehatBlockingService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const TestingBehatBlocking = makeSingleton(TestingBehatBlockingService);","map":{"version":3,"names":["CoreUtils","makeSingleton","NgZone","TestingBehatRuntime","TestingBehatBlockingService","constructor","waitingBlocked","recentMutation","lastMutation","initialized","keyIndex","init","_win$M","_win$M$util","_win$M$util$pending_j","listenToMutations","xmlRequestOverride","win","window","M","util","pending_js","log","pendingList","_win$M2","values","_win$M3","block","key","length","push","unblock","_this","_asyncToGenerator","filter","x","document","hidden","nextTicks","checkUIBlocked","delay","_this2","observer","MutationObserver","Date","now","setTimeout","pollRecentMutation","observe","attributes","childList","subtree","_this3","nextTick","blockingElements","Array","from","querySelectorAll","isBlocked","some","element","offsetParent","slide","closest","classList","contains","realOpen","XMLHttpRequest","prototype","open","requestIndex","args","run","index","isAsync","TestingBehatBlocking","addEventListener","realSend","send","apply","error","factory","ɵfac","providedIn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/testing/services/behat-blocking.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton, NgZone } from '@singletons';\nimport { BehatTestsWindow, TestingBehatRuntime } from './behat-runtime';\n\n/**\n * Behat block JS manager.\n */\n@Injectable({ providedIn: 'root' })\nexport class TestingBehatBlockingService {\n\n    protected waitingBlocked = false;\n    protected recentMutation = false;\n    protected lastMutation = 0;\n    protected initialized = false;\n    protected keyIndex = 0;\n\n    /**\n     * Listen to mutations and override XML Requests.\n     */\n    init(): void {\n        if (this.initialized) {\n            return;\n        }\n\n        this.initialized = true;\n        this.listenToMutations();\n        this.xmlRequestOverride();\n\n        const win = window as BehatTestsWindow;\n\n        // Set up the M object - only pending_js is implemented.\n        win.M = win.M ?? {};\n        win.M.util = win.M.util ?? {};\n        win.M.util.pending_js = win.M.util.pending_js ?? [];\n\n        TestingBehatRuntime.log('Initialized!');\n    }\n\n    /**\n     * Get pending list on window M object.\n     *\n     * @returns List of pending JS blockers.\n     */\n    protected get pendingList(): string[] {\n        const win = window as BehatTestsWindow;\n\n        return win.M?.util?.pending_js || [];\n    }\n\n    /**\n     * Set pending list on window M object.\n     */\n    protected set pendingList(values: string[]) {\n        const win = window as BehatTestsWindow;\n\n        if (!win.M?.util?.pending_js) {\n            return;\n        }\n\n        win.M.util.pending_js = values;\n    }\n\n    /**\n     * Adds a pending key to the array.\n     *\n     * @param key Key to add. It will be generated if none.\n     * @returns Key name.\n     */\n    block(key = ''): string {\n        // Add a special DELAY entry whenever another entry is added.\n        if (this.pendingList.length === 0) {\n            this.pendingList.push('DELAY');\n        }\n        if (!key) {\n            key = 'generated-' + this.keyIndex;\n            this.keyIndex++;\n        }\n        this.pendingList.push(key);\n\n        TestingBehatRuntime.log('PENDING+: ' + this.pendingList);\n\n        return key;\n    }\n\n    /**\n     * Removes a pending key from the array. If this would clear the array, the actual clear only\n     * takes effect after the queued events are finished.\n     *\n     * @param key Key to remove\n     */\n    async unblock(key: string): Promise<void> {\n        // Remove the key immediately.\n        this.pendingList = this.pendingList.filter((x) => x !== key);\n\n        TestingBehatRuntime.log('PENDING-: ' + this.pendingList);\n\n        // If the only thing left is DELAY, then remove that as well, later...\n        if (this.pendingList.length === 1) {\n            if (!document.hidden) {\n                // When tab is not active, ticks should be slower and may do Behat to fail.\n                // From Timers API:\n                // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\n                // \"This API does not guarantee that timers will run exactly on schedule.\n                // Delays due to CPU load, other tasks, etc, are to be expected.\"\n                await CoreUtils.nextTicks(10);\n            }\n\n            // Check there isn't a spinner...\n            await this.checkUIBlocked();\n\n            // Only remove it if the pending array is STILL empty after all that.\n            if (this.pendingList.length === 1) {\n                this.pendingList = [];\n                TestingBehatRuntime.log('PENDING-: ' + this.pendingList);\n            }\n        }\n    }\n\n    /**\n     * Adds a pending key to the array, but removes it after some ticks.\n     */\n    async delay(): Promise<void> {\n        const key = this.block('forced-delay');\n        this.unblock(key);\n    }\n\n    /**\n     * It would be really beautiful if you could detect CSS transitions and animations, that would\n     * cover almost everything, but sadly there is no way to do this because the transitionstart\n     * and animationcancel events are not implemented in Chrome, so we cannot detect either of\n     * these reliably. Instead, we have to look for any DOM changes and do horrible polling. Most\n     * of the animations are set to 500ms so we allow it to continue from 500ms after any DOM\n     * change.\n     */\n    protected listenToMutations(): void {\n        // Set listener using the mutation callback.\n        const observer = new MutationObserver(() => {\n            this.lastMutation = Date.now();\n\n            if (!this.recentMutation) {\n                this.recentMutation = true;\n                this.block('dom-mutation');\n\n                setTimeout(() => {\n                    this.pollRecentMutation();\n                }, 500);\n            }\n\n            // Also update the spinner presence if needed.\n            this.checkUIBlocked();\n        });\n\n        observer.observe(document, { attributes: true, childList: true, subtree: true });\n    }\n\n    /**\n     * Called from the mutation callback to remove the pending tag after 500ms if nothing else\n     * gets mutated.\n     *\n     * This will be called after 500ms, then every 100ms until there have been no mutation events\n     * for 500ms.\n     */\n    protected pollRecentMutation(): void {\n        if (Date.now() - this.lastMutation > 500) {\n            this.recentMutation = false;\n            this.unblock('dom-mutation');\n\n            return;\n        }\n\n        setTimeout(() => {\n            this.pollRecentMutation();\n        }, 100);\n    }\n\n    /**\n     * Checks if a loading spinner is present and visible; if so, adds it to the pending array\n     * (and if not, removes it).\n     */\n    protected async checkUIBlocked(): Promise<void> {\n        await CoreUtils.nextTick();\n\n        const blockingElements = Array.from(\n            document.querySelectorAll<HTMLElement>('div.core-loading-container, ion-loading, .click-block-active'),\n        );\n\n        const isBlocked = blockingElements.some(element => {\n            if (!element.offsetParent) {\n                return false;\n            }\n\n            const slide = element.closest('swiper-slide');\n            if (slide && !slide.classList.contains('swiper-slide-active')) {\n                return false;\n            }\n\n            return true;\n        });\n\n        if (isBlocked) {\n            if (!this.waitingBlocked) {\n                this.block('blocked');\n                this.waitingBlocked = true;\n            }\n        } else {\n            if (this.waitingBlocked) {\n                this.unblock('blocked');\n                this.waitingBlocked = false;\n            }\n        }\n    }\n\n    /**\n     * Override XMLHttpRequest to mark things pending while there is a request waiting.\n     */\n    protected xmlRequestOverride(): void {\n        const realOpen = XMLHttpRequest.prototype.open;\n        let requestIndex = 0;\n\n        XMLHttpRequest.prototype.open = function(...args) {\n            NgZone.run(() => {\n                const index = requestIndex++;\n                const key = 'httprequest-' + index;\n                const isAsync = args[2] !== false;\n\n                try {\n                    // Add to the list of pending requests.\n                    TestingBehatBlocking.block(key);\n\n                    // Detect when it finishes and remove it from the list.\n                    if (isAsync) {\n                        this.addEventListener('loadend', () => {\n                            TestingBehatBlocking.unblock(key);\n                        });\n                    } else {\n                        const realSend = this.send;\n                        this.send = (...args) => {\n                            try {\n                                return realSend.apply(this, args);\n                            } finally {\n                                TestingBehatBlocking.unblock(key);\n                            }\n                        };\n                    }\n\n                    return realOpen.apply(this, args);\n                } catch (error) {\n                    TestingBehatBlocking.unblock(key);\n                    throw error;\n                }\n            });\n        };\n    }\n\n}\n\nexport const TestingBehatBlocking = makeSingleton(TestingBehatBlockingService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}