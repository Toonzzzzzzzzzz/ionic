{"ast":null,"code":"// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreDom } from '@singletons/dom';\nimport { CoreLogger } from '@singletons/logger';\nimport { AddonQtypeDdMarkerGraphicsApi } from './graphics_api';\n/**\n * Class to make a question of ddmarker type work.\n */\nexport class AddonQtypeDdMarkerQuestion {\n  /**\n   * Create the instance.\n   *\n   * @param container The container HTMLElement of the question.\n   * @param question The question instance.\n   * @param readOnly Whether it's read only.\n   * @param dropZones The drop zones received in the init object of the question.\n   * @param imgSrc Background image source (3.6+ sites).\n   */\n  constructor(container, question, readOnly, dropZones,\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  imgSrc) {\n    this.container = container;\n    this.question = question;\n    this.readOnly = readOnly;\n    this.dropZones = dropZones;\n    this.imgSrc = imgSrc;\n    this.COLOURS = ['#FFFFFF', '#B0C4DE', '#DCDCDC', '#D8BFD8', '#87CEFA', '#DAA520', '#FFD700', '#F0E68C'];\n    this.afterImageLoadDone = false;\n    this.nextColourIndex = 0;\n    this.proportion = 1;\n    this.shapes = [];\n    this.logger = CoreLogger.getInstance('AddonQtypeDdMarkerQuestion');\n    this.graphics = new AddonQtypeDdMarkerGraphicsApi(this);\n    this.initializer();\n  }\n  /**\n   * Calculate image proportion to make easy conversions.\n   */\n  calculateImgProportion() {\n    const bgImg = this.doc.bgImg();\n    if (!bgImg) {\n      return;\n    }\n    // Render the position related to the current image dimensions.\n    this.proportion = 1;\n    if (bgImg.width != bgImg.naturalWidth) {\n      this.proportion = bgImg.width / bgImg.naturalWidth;\n    }\n  }\n  /**\n   * Create a new draggable element cloning a certain element.\n   *\n   * @param dragHome The element to clone.\n   * @param itemNo The number of the new item.\n   * @returns The new element.\n   */\n  cloneNewDragItem(dragHome, itemNo) {\n    var _dragHome$parentEleme;\n    // Clone the element and add the right classes.\n    const drag = dragHome.cloneNode(true);\n    drag.classList.remove('draghome');\n    drag.classList.add('dragitem');\n    drag.classList.add('item' + itemNo);\n    drag.classList.remove('dragplaceholder'); // In case it has it.\n    dragHome.classList.add('dragplaceholder');\n    // Insert the new drag after the dragHome.\n    (_dragHome$parentEleme = dragHome.parentElement) === null || _dragHome$parentEleme === void 0 || _dragHome$parentEleme.insertBefore(drag, dragHome.nextSibling);\n    if (!this.readOnly) {\n      this.draggable(drag);\n    }\n    return drag;\n  }\n  /**\n   * Convert the X and Y position of the BG IMG to a position relative to the window.\n   *\n   * @param bgImgXY X and Y of the BG IMG relative position.\n   * @returns Position relative to the window.\n   */\n  convertToWindowXY(bgImgXY) {\n    const bgImg = this.doc.bgImg();\n    if (!bgImg) {\n      return [];\n    }\n    const position = this.getElementCoordinates(bgImg);\n    let coordsNumbers = this.parsePoint(bgImgXY);\n    coordsNumbers = this.makePointProportional(coordsNumbers);\n    return [coordsNumbers.x + position[0], coordsNumbers.y + position[1]];\n  }\n  /**\n   * Returns elements coordinates relative to ddarea container.\n   *\n   * @param element Element.\n   * @returns Array of X and Y coordinates.\n   */\n  getElementCoordinates(element) {\n    const ddArea = this.container.querySelector('.ddarea');\n    if (!ddArea) {\n      return [];\n    }\n    const position = CoreDom.getRelativeElementPosition(element, ddArea);\n    return [position.x, position.y];\n  }\n  /**\n   * Check if some coordinates (X, Y) are inside the background image.\n   *\n   * @param coords Coordinates to check.\n   * @returns Whether they're inside the background image.\n   */\n  coordsInImg(coords) {\n    const bgImg = this.doc.bgImg();\n    if (!bgImg) {\n      return false;\n    }\n    return coords.x * this.proportion <= bgImg.width + 1 && coords.y * this.proportion <= bgImg.height + 1;\n  }\n  /**\n   * Deselect all draggable items.\n   */\n  deselectDrags() {\n    const drags = this.doc.dragItems();\n    drags.forEach(drag => {\n      drag.classList.remove('beingdragged');\n    });\n    this.selected = undefined;\n  }\n  /**\n   * Function to call when the instance is no longer needed.\n   */\n  destroy() {\n    var _this$resizeListener;\n    (_this$resizeListener = this.resizeListener) === null || _this$resizeListener === void 0 || _this$resizeListener.off();\n  }\n  /**\n   * Make an element \"draggable\". In the mobile app, items are \"dragged\" using tap and drop.\n   *\n   * @param drag Element.\n   */\n  draggable(drag) {\n    drag.addEventListener('click', e => {\n      e.preventDefault();\n      e.stopPropagation();\n      const dragging = this.selected;\n      if (dragging && !drag.classList.contains('unplaced')) {\n        const position = this.getElementCoordinates(drag);\n        const bgImg = this.doc.bgImg();\n        if (!bgImg) {\n          return;\n        }\n        const bgImgPos = this.getElementCoordinates(bgImg);\n        position[0] = position[0] - bgImgPos[0] + e.offsetX;\n        position[1] = position[1] - bgImgPos[1] + e.offsetY;\n        // Ensure the we click on a placed dragitem.\n        if (position[0] <= bgImg.width && position[1] <= bgImg.height) {\n          this.deselectDrags();\n          this.dropDrag(dragging, position);\n          return;\n        }\n      }\n      if (drag.classList.contains('beingdragged')) {\n        this.deselectDrags();\n      } else {\n        this.selectDrag(drag);\n      }\n    });\n  }\n  /**\n   * Get the coordinates of the drag home of a certain choice.\n   *\n   * @param choiceNo Choice number.\n   * @returns Coordinates.\n   */\n  dragHomeXY(choiceNo) {\n    const dragItemHome = this.doc.dragItemHome(choiceNo);\n    if (!dragItemHome) {\n      return [];\n    }\n    const position = this.getElementCoordinates(dragItemHome);\n    return [position[0], position[1]];\n  }\n  /**\n   * Draw a drop zone.\n   *\n   * @param dropZoneNo Number of the drop zone.\n   * @param markerText The marker text to set.\n   * @param shape Name of the shape of the drop zone (circle, rectangle, polygon).\n   * @param coords Coordinates of the shape.\n   * @param colour Colour of the shape.\n   */\n  drawDropZone(dropZoneNo, markerText, shape, coords, colour) {\n    var _this$doc$topNode;\n    const markerTexts = this.doc.markerTexts();\n    // Check if there is already a marker text for this drop zone.\n    const existingMarkerText = markerTexts === null || markerTexts === void 0 ? void 0 : markerTexts.querySelector('span.markertext' + dropZoneNo);\n    if (existingMarkerText) {\n      // Marker text already exists. Update it or remove it if empty.\n      if (markerText !== '') {\n        existingMarkerText.innerHTML = markerText;\n      } else {\n        existingMarkerText.remove();\n      }\n    } else if (markerText !== '' && markerTexts) {\n      // Create and add the marker text.\n      const classNames = 'markertext markertext' + dropZoneNo;\n      const span = document.createElement('span');\n      span.className = classNames;\n      span.innerHTML = markerText;\n      markerTexts.appendChild(span);\n    }\n    // Check that a function to draw this shape exists.\n    const drawFunc = 'drawShape' + CoreTextUtils.ucFirst(shape);\n    if (!(this[drawFunc] instanceof Function)) {\n      return;\n    }\n    // Call the function.\n    const xyForText = this[drawFunc](dropZoneNo, coords, colour);\n    if (xyForText === null || xyForText === undefined) {\n      return;\n    }\n    // Search the marker for the drop zone.\n    const markerSpan = (_this$doc$topNode = this.doc.topNode) === null || _this$doc$topNode === void 0 ? void 0 : _this$doc$topNode.querySelector(`div.ddarea div.markertexts span.markertext${dropZoneNo}`);\n    if (!markerSpan) {\n      return;\n    }\n    const computedStyle = getComputedStyle(markerSpan);\n    const width = markerSpan.getBoundingClientRect().width + CoreDomUtils.getComputedStyleMeasure(computedStyle, 'borderLeftWidth') + CoreDomUtils.getComputedStyleMeasure(computedStyle, 'borderRightWidth') + CoreDomUtils.getComputedStyleMeasure(computedStyle, 'paddingLeft') + CoreDomUtils.getComputedStyleMeasure(computedStyle, 'paddingRight');\n    const height = markerSpan.getBoundingClientRect().height + CoreDomUtils.getComputedStyleMeasure(computedStyle, 'borderTopWidth') + CoreDomUtils.getComputedStyleMeasure(computedStyle, 'borderBottomWidth') + CoreDomUtils.getComputedStyleMeasure(computedStyle, 'paddingTop') + CoreDomUtils.getComputedStyleMeasure(computedStyle, 'paddingBottom');\n    markerSpan.style.opacity = '0.6';\n    markerSpan.style.left = xyForText.x - width / 2 + 'px';\n    markerSpan.style.top = xyForText.y - height / 2 + 'px';\n    const markerSpanAnchor = markerSpan.querySelector('a');\n    if (markerSpanAnchor !== null) {\n      markerSpanAnchor.addEventListener('click', e => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.shapes.forEach(elem => {\n          elem.style.fillOpacity = '0.5';\n        });\n        this.shapes[dropZoneNo].style.fillOpacity = '1';\n        setTimeout(() => {\n          this.shapes[dropZoneNo].style.fillOpacity = '0.5';\n        }, 2000);\n      });\n      markerSpanAnchor.setAttribute('tabIndex', '0');\n    }\n  }\n  /**\n   * Draw a circle in a drop zone.\n   *\n   * @param dropZoneNo Number of the drop zone.\n   * @param coordinates Coordinates of the circle.\n   * @param colour Colour of the circle.\n   * @returns X and Y position of the center of the circle.\n   */\n  drawShapeCircle(dropZoneNo, coordinates, colour) {\n    if (!coordinates.match(/^\\d+(\\.\\d+)?,\\d+(\\.\\d+)?;\\d+(\\.\\d+)?$/)) {\n      return null;\n    }\n    const bits = coordinates.split(';');\n    let centre = this.parsePoint(bits[0]);\n    const radius = Number(bits[1]);\n    // Calculate circle limits and check it's inside the background image.\n    const circleLimit = {\n      x: centre.x - radius,\n      y: centre.y - radius\n    };\n    if (this.coordsInImg(circleLimit)) {\n      centre = this.makePointProportional(centre);\n      // All good, create the shape.\n      this.shapes[dropZoneNo] = this.graphics.addShape({\n        type: 'circle',\n        color: colour\n      }, {\n        cx: centre.x,\n        cy: centre.y,\n        r: Math.round(radius * this.proportion)\n      });\n      // Return the centre.\n      return centre;\n    }\n    return null;\n  }\n  /**\n   * Draw a rectangle in a drop zone.\n   *\n   * @param dropZoneNo Number of the drop zone.\n   * @param coordinates Coordinates of the rectangle.\n   * @param colour Colour of the rectangle.\n   * @returns X and Y position of the center of the rectangle.\n   */\n  drawShapeRectangle(dropZoneNo, coordinates, colour) {\n    if (!coordinates.match(/^\\d+(\\.\\d+)?,\\d+(\\.\\d+)?;\\d+(\\.\\d+)?,\\d+(\\.\\d+)?$/)) {\n      return null;\n    }\n    const bits = coordinates.split(';');\n    const startPoint = this.parsePoint(bits[0]);\n    const size = this.parsePoint(bits[1]);\n    // Calculate rectangle limits and check it's inside the background image.\n    const rectLimits = {\n      x: startPoint.x + size.x,\n      y: startPoint.y + size.y\n    };\n    if (this.coordsInImg(rectLimits)) {\n      const startPointProp = this.makePointProportional(startPoint);\n      const sizeProp = this.makePointProportional(size);\n      // All good, create the shape.\n      this.shapes[dropZoneNo] = this.graphics.addShape({\n        type: 'rect',\n        color: colour\n      }, {\n        x: startPointProp.x,\n        y: startPointProp.y,\n        width: sizeProp.x,\n        height: sizeProp.y\n      });\n      const centre = {\n        x: startPoint.x + size.x / 2,\n        y: startPoint.y + size.y / 2\n      };\n      // Return the centre.\n      return this.makePointProportional(centre);\n    }\n    return null;\n  }\n  /**\n   * Draw a polygon in a drop zone.\n   *\n   * @param dropZoneNo Number of the drop zone.\n   * @param coordinates Coordinates of the polygon.\n   * @param colour Colour of the polygon.\n   * @returns X and Y position of the center of the polygon.\n   */\n  drawShapePolygon(dropZoneNo, coordinates, colour) {\n    if (!coordinates.match(/^\\d+(\\.\\d+)?,\\d+(\\.\\d+)?(?:;\\d+(\\.\\d+)?,\\d+(\\.\\d+)?)*$/)) {\n      return null;\n    }\n    const bits = coordinates.split(';');\n    const centre = {\n      x: 0,\n      y: 0\n    };\n    const points = bits.map(bit => {\n      const point = this.parsePoint(bit);\n      centre.x += point.x;\n      centre.y += point.y;\n      return point;\n    });\n    if (points.length > 0) {\n      centre.x = Math.round(centre.x / points.length);\n      centre.y = Math.round(centre.y / points.length);\n    }\n    const pointsOnImg = [];\n    points.forEach(point => {\n      if (this.coordsInImg(point)) {\n        point = this.makePointProportional(point);\n        pointsOnImg.push(point.x + ',' + point.y);\n      }\n    });\n    if (pointsOnImg.length > 2) {\n      this.shapes[dropZoneNo] = this.graphics.addShape({\n        type: 'polygon',\n        color: colour\n      }, {\n        points: pointsOnImg.join(' ')\n      });\n      // Return the centre.\n      return this.makePointProportional(centre);\n    }\n    return null;\n  }\n  /**\n   * Make a point from the string representation.\n   *\n   * @param coordinates \"x,y\".\n   * @returns Coordinates to the point.\n   */\n  parsePoint(coordinates) {\n    const bits = coordinates.split(',');\n    if (bits.length !== 2) {\n      throw coordinates + ' is not a valid point';\n    }\n    return {\n      x: Number(bits[0]),\n      y: Number(bits[1])\n    };\n  }\n  /**\n   * Make proportional position of the point.\n   *\n   * @param point Point coordinates.\n   * @returns Converted point.\n   */\n  makePointProportional(point) {\n    return {\n      x: Math.round(point.x * this.proportion),\n      y: Math.round(point.y * this.proportion)\n    };\n  }\n  /**\n   * Drop a drag element into a certain position.\n   *\n   * @param drag The element to drop.\n   * @param position Position to drop to (X, Y).\n   */\n  dropDrag(drag, position) {\n    const choiceNo = this.getChoiceNoForNode(drag);\n    if (position) {\n      // Set the position related to the natural image dimensions.\n      if (this.proportion < 1) {\n        position[0] = Math.round(position[0] / this.proportion);\n        position[1] = Math.round(position[1] / this.proportion);\n      }\n    }\n    this.saveAllXYForChoice(choiceNo, drag, position);\n    this.redrawDragsAndDrops();\n  }\n  /**\n   * Determine which drag items need to be shown and return coords of all drag items except any that are currently being\n   * dragged based on contents of hidden inputs and whether drags are 'infinite' or how many drags should be shown.\n   *\n   * @param input The input element.\n   * @returns List of coordinates.\n   */\n  getCoords(input) {\n    const choiceNo = this.getChoiceNoForNode(input);\n    const fv = input.getAttribute('value');\n    const infinite = input.classList.contains('infinite');\n    const noOfDrags = this.getNoOfDragsForNode(input);\n    const dragging = !!this.doc.dragItemBeingDragged(choiceNo);\n    const coords = [];\n    if (fv !== '' && fv !== undefined && fv !== null) {\n      // Get all the coordinates in the input and add them to the coords list.\n      const coordsStrings = fv.split(';');\n      for (let i = 0; i < coordsStrings.length; i++) {\n        coords[coords.length] = this.convertToWindowXY(coordsStrings[i]);\n      }\n    }\n    const displayedDrags = coords.length + (dragging ? 1 : 0);\n    if (infinite || displayedDrags < noOfDrags) {\n      coords[coords.length] = this.dragHomeXY(choiceNo);\n    }\n    return coords;\n  }\n  /**\n   * Get the choice number from an HTML element.\n   *\n   * @param node Element to check.\n   * @returns Choice number.\n   */\n  getChoiceNoForNode(node) {\n    return Number(this.doc.getClassnameNumericSuffix(node, 'choice'));\n  }\n  /**\n   * Get the coordinates (X, Y) of a draggable element.\n   *\n   * @param dragItem The draggable item.\n   * @returns Coordinates.\n   */\n  getDragXY(dragItem) {\n    const position = this.getElementCoordinates(dragItem);\n    const bgImg = this.doc.bgImg();\n    if (bgImg) {\n      const bgImgXY = this.getElementCoordinates(bgImg);\n      position[0] -= bgImgXY[0];\n      position[1] -= bgImgXY[1];\n    }\n    // Set the position related to the natural image dimensions.\n    if (this.proportion < 1) {\n      position[0] = Math.round(position[0] / this.proportion);\n      position[1] = Math.round(position[1] / this.proportion);\n    }\n    return position;\n  }\n  /**\n   * Get the item number from an HTML element.\n   *\n   * @param node Element to check.\n   * @returns Choice number.\n   */\n  getItemNoForNode(node) {\n    return Number(this.doc.getClassnameNumericSuffix(node, 'item'));\n  }\n  /**\n   * Get the next colour.\n   *\n   * @returns Colour.\n   */\n  getNextColour() {\n    const colour = this.COLOURS[this.nextColourIndex];\n    this.nextColourIndex++;\n    // If we reached the end of the list, start again.\n    if (this.nextColourIndex === this.COLOURS.length) {\n      this.nextColourIndex = 0;\n    }\n    return colour;\n  }\n  /**\n   * Get the number of drags from an HTML element.\n   *\n   * @param node Element to check.\n   * @returns Choice number.\n   */\n  getNoOfDragsForNode(node) {\n    return Number(this.doc.getClassnameNumericSuffix(node, 'noofdrags'));\n  }\n  /**\n   * Initialize the question.\n   */\n  initializer() {\n    this.doc = new AddonQtypeDdMarkerQuestionDocStructure(this.container);\n    // Wait the DOM to be rendered.\n    setTimeout(() => {\n      this.pollForImageLoad();\n    });\n    this.resizeListener = CoreDom.onWindowResize(() => {\n      this.redrawDragsAndDrops();\n    });\n  }\n  /**\n   * Make background image and home zone dropable.\n   */\n  makeImageDropable() {\n    if (this.readOnly) {\n      return;\n    }\n    // Listen for click events in the background image to make it dropable.\n    const bgImg = this.doc.bgImg();\n    bgImg === null || bgImg === void 0 || bgImg.addEventListener('click', e => {\n      const drag = this.selected;\n      if (!drag) {\n        // No draggable element selected, nothing to do.\n        return false;\n      }\n      // There's an element being dragged. Deselect it and drop it in the position.\n      const position = [e.offsetX, e.offsetY];\n      this.deselectDrags();\n      this.dropDrag(drag, position);\n      e.preventDefault();\n      e.stopPropagation();\n    });\n    const home = this.doc.dragItemsArea;\n    home === null || home === void 0 || home.addEventListener('click', e => {\n      const drag = this.selected;\n      if (!drag) {\n        // No draggable element selected, nothing to do.\n        return false;\n      }\n      // There's an element being dragged but it's not placed yet, deselect.\n      if (drag.classList.contains('unplaced')) {\n        this.deselectDrags();\n        return false;\n      }\n      // There's an element being dragged and it's placed somewhere. Move it back to the home area.\n      this.deselectDrags();\n      this.dropDrag(drag, null);\n      e.preventDefault();\n      e.stopPropagation();\n    });\n  }\n  /**\n   * Wait for the background image to be loaded.\n   */\n  pollForImageLoad() {\n    if (this.afterImageLoadDone) {\n      // Already treated.\n      return;\n    }\n    const bgImg = this.doc.bgImg();\n    if (!bgImg) {\n      return;\n    }\n    if (!bgImg.src && this.imgSrc) {\n      bgImg.src = this.imgSrc;\n    }\n    const imgLoaded = () => {\n      bgImg.removeEventListener('load', imgLoaded);\n      this.makeImageDropable();\n      setTimeout(() => {\n        this.redrawDragsAndDrops();\n      });\n      this.afterImageLoadDone = true;\n      this.question.loaded = true;\n    };\n    if (!bgImg.src || bgImg.complete && bgImg.naturalWidth) {\n      imgLoaded();\n      return;\n    }\n    bgImg.addEventListener('load', imgLoaded);\n    // Try again after a while.\n    setTimeout(() => {\n      this.pollForImageLoad();\n    }, 500);\n  }\n  /**\n   * Redraw all draggables and drop zones.\n   */\n  redrawDragsAndDrops() {\n    // Mark all the draggable items as not placed.\n    const drags = this.doc.dragItems();\n    drags.forEach(drag => {\n      drag.classList.add('unneeded', 'unplaced');\n    });\n    // Re-calculate the image proportion.\n    this.calculateImgProportion();\n    // Get all the inputs.\n    const inputs = this.doc.inputsForChoices();\n    for (let x = 0; x < inputs.length; x++) {\n      // Get all the drag items for the choice.\n      const input = inputs[x];\n      const choiceNo = this.getChoiceNoForNode(input);\n      const coords = this.getCoords(input);\n      const dragItemHome = this.doc.dragItemHome(choiceNo);\n      const homePosition = this.dragHomeXY(choiceNo);\n      if (!dragItemHome) {\n        continue;\n      }\n      for (let i = 0; i < coords.length; i++) {\n        let dragItem = this.doc.dragItemForChoice(choiceNo, i);\n        if (!dragItem || dragItem.classList.contains('beingdragged')) {\n          dragItem = this.cloneNewDragItem(dragItemHome, i);\n        } else {\n          dragItem.classList.remove('unneeded');\n        }\n        const placeholder = this.doc.dragItemPlaceholder(choiceNo);\n        // Remove the class only if is placed on the image.\n        if (homePosition[0] != coords[i][0] || homePosition[1] != coords[i][1]) {\n          dragItem.classList.remove('unplaced');\n          dragItem.classList.add('placed');\n          const computedStyle = getComputedStyle(dragItem);\n          const left = coords[i][0] - CoreDomUtils.getComputedStyleMeasure(computedStyle, 'marginLeft');\n          const top = coords[i][1] - CoreDomUtils.getComputedStyleMeasure(computedStyle, 'marginTop');\n          dragItem.style.left = left + 'px';\n          dragItem.style.top = top + 'px';\n          placeholder === null || placeholder === void 0 || placeholder.classList.add('active');\n        } else {\n          dragItem.classList.remove('placed');\n          dragItem.classList.add('unplaced');\n          placeholder === null || placeholder === void 0 || placeholder.classList.remove('active');\n        }\n      }\n    }\n    // Remove unneeded draggable items.\n    for (let y = 0; y < drags.length; y++) {\n      const item = drags[y];\n      if (item.classList.contains('unneeded') && !item.classList.contains('beingdragged')) {\n        item.remove();\n      }\n    }\n    // Re-draw drop zones.\n    if (this.dropZones && this.dropZones.length !== 0) {\n      this.graphics.clear();\n      this.restartColours();\n      for (const dropZoneNo in this.dropZones) {\n        const colourForDropZone = this.getNextColour();\n        const dropZone = this.dropZones[dropZoneNo];\n        const dzNo = Number(dropZoneNo);\n        this.drawDropZone(dzNo, dropZone.markertext, dropZone.shape, dropZone.coords, colourForDropZone);\n      }\n    }\n  }\n  /**\n   * Reset the coordinates stored for a choice.\n   *\n   * @param choiceNo Choice number.\n   */\n  resetDragXY(choiceNo) {\n    this.setFormValue(choiceNo, '');\n  }\n  /**\n   * Restart the colour index.\n   */\n  restartColours() {\n    this.nextColourIndex = 0;\n  }\n  /**\n   * Save all the coordinates of a choice into the right input.\n   *\n   * @param choiceNo Number of the choice.\n   * @param dropped Element being dropped.\n   * @param position Position where the element is dropped.\n   */\n  saveAllXYForChoice(choiceNo, dropped, position) {\n    const coords = [];\n    // Calculate the coords for the choice.\n    const dragItemsChoice = this.doc.dragItemsForChoice(choiceNo);\n    for (let i = 0; i < dragItemsChoice.length; i++) {\n      const dragItem = this.doc.dragItemForChoice(choiceNo, i);\n      if (dragItem) {\n        const bgImgXY = this.getDragXY(dragItem);\n        dragItem.classList.remove('item' + i);\n        dragItem.classList.add('item' + coords.length);\n        coords.push(bgImgXY);\n      }\n    }\n    if (position !== null) {\n      // Element dropped into a certain position. Mark it as placed and save the position.\n      dropped.classList.remove('unplaced');\n      dropped.classList.add('item' + coords.length);\n      coords.push(position);\n    } else {\n      // Element back at home, mark it as unplaced.\n      dropped.classList.add('unplaced');\n    }\n    if (coords.length > 0) {\n      // Save the coordinates in the input.\n      this.setFormValue(choiceNo, coords.join(';'));\n    } else {\n      // Empty the input.\n      this.resetDragXY(choiceNo);\n    }\n  }\n  /**\n   * Save a certain value in the input of a choice.\n   *\n   * @param choiceNo Choice number.\n   * @param value The value to set.\n   */\n  setFormValue(choiceNo, value) {\n    var _this$doc$inputForCho;\n    (_this$doc$inputForCho = this.doc.inputForChoice(choiceNo)) === null || _this$doc$inputForCho === void 0 || _this$doc$inputForCho.setAttribute('value', value);\n  }\n  /**\n   * Select a draggable element.\n   *\n   * @param drag Element.\n   */\n  selectDrag(drag) {\n    // Deselect previous drags.\n    this.deselectDrags();\n    this.selected = drag;\n    drag.classList.add('beingdragged');\n    const itemNo = this.getItemNoForNode(drag);\n    if (itemNo !== null) {\n      drag.classList.remove('item' + itemNo);\n    }\n  }\n}\n/**\n * Encapsulates operations on dd area.\n */\nexport class AddonQtypeDdMarkerQuestionDocStructure {\n  constructor(container) {\n    var _this$topNode;\n    this.container = container;\n    this.logger = CoreLogger.getInstance('AddonQtypeDdMarkerQuestionDocStructure');\n    this.topNode = this.container.querySelector('.addon-qtype-ddmarker-container');\n    this.dragItemsArea = ((_this$topNode = this.topNode) === null || _this$topNode === void 0 ? void 0 : _this$topNode.querySelector('div.dragitems, div.draghomes')) || null;\n  }\n  querySelector(element, selector) {\n    if (!element) {\n      return null;\n    }\n    return element.querySelector(selector);\n  }\n  querySelectorAll(element, selector) {\n    if (!element) {\n      return [];\n    }\n    return Array.from(element.querySelectorAll(selector));\n  }\n  bgImg() {\n    return this.querySelector(this.topNode, '.dropbackground');\n  }\n  dragItems() {\n    return this.querySelectorAll(this.dragItemsArea, '.dragitem');\n  }\n  dragItemsForChoice(choiceNo) {\n    return this.querySelectorAll(this.dragItemsArea, `span.dragitem.choice${choiceNo}`);\n  }\n  dragItemForChoice(choiceNo, itemNo) {\n    return this.querySelector(this.dragItemsArea, `span.dragitem.choice${choiceNo}.item${itemNo}`);\n  }\n  dragItemPlaceholder(choiceNo) {\n    return this.querySelector(this.dragItemsArea, `span.dragplaceholder.choice${choiceNo}`);\n  }\n  dragItemBeingDragged(choiceNo) {\n    return this.querySelector(this.dragItemsArea, `span.dragitem.beingdragged.choice${choiceNo}`);\n  }\n  dragItemHome(choiceNo) {\n    return this.querySelector(this.dragItemsArea, `span.draghome.choice${choiceNo}, span.marker.choice${choiceNo}`);\n  }\n  dragItemHomes() {\n    return this.querySelectorAll(this.dragItemsArea, 'span.draghome, span.marker');\n  }\n  getClassnameNumericSuffix(node, prefix) {\n    if (node.classList.length) {\n      const patt1 = new RegExp('^' + prefix + '([0-9])+$');\n      const patt2 = new RegExp('([0-9])+$');\n      for (let index = 0; index < node.classList.length; index++) {\n        if (patt1.test(node.classList[index])) {\n          const match = patt2.exec(node.classList[index]);\n          return Number(match === null || match === void 0 ? void 0 : match[0]);\n        }\n      }\n    }\n    this.logger.warn('Prefix \"' + prefix + '\" not found in class names.');\n  }\n  inputsForChoices() {\n    return this.querySelectorAll(this.topNode, 'input.choices');\n  }\n  inputForChoice(choiceNo) {\n    return this.querySelector(this.topNode, `input.choice${choiceNo}`);\n  }\n  markerTexts() {\n    return this.querySelector(this.topNode, 'div.markertexts');\n  }\n}","map":{"version":3,"names":["CoreDomUtils","CoreTextUtils","CoreDom","CoreLogger","AddonQtypeDdMarkerGraphicsApi","AddonQtypeDdMarkerQuestion","constructor","container","question","readOnly","dropZones","imgSrc","COLOURS","afterImageLoadDone","nextColourIndex","proportion","shapes","logger","getInstance","graphics","initializer","calculateImgProportion","bgImg","doc","width","naturalWidth","cloneNewDragItem","dragHome","itemNo","_dragHome$parentEleme","drag","cloneNode","classList","remove","add","parentElement","insertBefore","nextSibling","draggable","convertToWindowXY","bgImgXY","position","getElementCoordinates","coordsNumbers","parsePoint","makePointProportional","x","y","element","ddArea","querySelector","getRelativeElementPosition","coordsInImg","coords","height","deselectDrags","drags","dragItems","forEach","selected","undefined","destroy","_this$resizeListener","resizeListener","off","addEventListener","e","preventDefault","stopPropagation","dragging","contains","bgImgPos","offsetX","offsetY","dropDrag","selectDrag","dragHomeXY","choiceNo","dragItemHome","drawDropZone","dropZoneNo","markerText","shape","colour","_this$doc$topNode","markerTexts","existingMarkerText","innerHTML","classNames","span","document","createElement","className","appendChild","drawFunc","ucFirst","Function","xyForText","markerSpan","topNode","computedStyle","getComputedStyle","getBoundingClientRect","getComputedStyleMeasure","style","opacity","left","top","markerSpanAnchor","elem","fillOpacity","setTimeout","setAttribute","drawShapeCircle","coordinates","match","bits","split","centre","radius","Number","circleLimit","addShape","type","color","cx","cy","r","Math","round","drawShapeRectangle","startPoint","size","rectLimits","startPointProp","sizeProp","drawShapePolygon","points","map","bit","point","length","pointsOnImg","push","join","getChoiceNoForNode","saveAllXYForChoice","redrawDragsAndDrops","getCoords","input","fv","getAttribute","infinite","noOfDrags","getNoOfDragsForNode","dragItemBeingDragged","coordsStrings","i","displayedDrags","node","getClassnameNumericSuffix","getDragXY","dragItem","getItemNoForNode","getNextColour","AddonQtypeDdMarkerQuestionDocStructure","pollForImageLoad","onWindowResize","makeImageDropable","home","dragItemsArea","src","imgLoaded","removeEventListener","loaded","complete","inputs","inputsForChoices","homePosition","dragItemForChoice","placeholder","dragItemPlaceholder","item","clear","restartColours","colourForDropZone","dropZone","dzNo","markertext","resetDragXY","setFormValue","dropped","dragItemsChoice","dragItemsForChoice","value","_this$doc$inputForCho","inputForChoice","_this$topNode","selector","querySelectorAll","Array","from","dragItemHomes","prefix","patt1","RegExp","patt2","index","test","exec","warn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/qtype/ddmarker/classes/ddmarker.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreCoordinates, CoreDom } from '@singletons/dom';\nimport { CoreEventObserver } from '@singletons/events';\nimport { CoreLogger } from '@singletons/logger';\nimport { AddonQtypeDdMarkerQuestionData } from '../component/ddmarker';\nimport { AddonQtypeDdMarkerGraphicsApi } from './graphics_api';\n\n/**\n * Class to make a question of ddmarker type work.\n */\nexport class AddonQtypeDdMarkerQuestion {\n\n    protected readonly COLOURS = ['#FFFFFF', '#B0C4DE', '#DCDCDC', '#D8BFD8', '#87CEFA', '#DAA520', '#FFD700', '#F0E68C'];\n\n    protected logger: CoreLogger;\n    protected afterImageLoadDone = false;\n    protected topNode?: HTMLElement | null;\n    protected nextColourIndex = 0;\n    protected proportion = 1;\n    protected selected?: HTMLElement; // Selected element (being \"dragged\").\n    protected graphics: AddonQtypeDdMarkerGraphicsApi;\n    protected resizeListener?: CoreEventObserver;\n\n    doc!: AddonQtypeDdMarkerQuestionDocStructure;\n    shapes: SVGElement[] = [];\n\n    /**\n     * Create the instance.\n     *\n     * @param container The container HTMLElement of the question.\n     * @param question The question instance.\n     * @param readOnly Whether it's read only.\n     * @param dropZones The drop zones received in the init object of the question.\n     * @param imgSrc Background image source (3.6+ sites).\n     */\n    constructor(\n        protected container: HTMLElement,\n        protected question: AddonQtypeDdMarkerQuestionData,\n        protected readOnly: boolean,\n        protected dropZones: any[], // eslint-disable-line @typescript-eslint/no-explicit-any\n        protected imgSrc?: string,\n    ) {\n        this.logger = CoreLogger.getInstance('AddonQtypeDdMarkerQuestion');\n\n        this.graphics = new AddonQtypeDdMarkerGraphicsApi(this);\n\n        this.initializer();\n    }\n\n    /**\n     * Calculate image proportion to make easy conversions.\n     */\n    calculateImgProportion(): void {\n        const bgImg = this.doc.bgImg();\n        if (!bgImg) {\n            return;\n        }\n\n        // Render the position related to the current image dimensions.\n        this.proportion = 1;\n        if (bgImg.width != bgImg.naturalWidth) {\n            this.proportion = bgImg.width / bgImg.naturalWidth;\n        }\n    }\n\n    /**\n     * Create a new draggable element cloning a certain element.\n     *\n     * @param dragHome The element to clone.\n     * @param itemNo The number of the new item.\n     * @returns The new element.\n     */\n    cloneNewDragItem(dragHome: HTMLElement, itemNo: number): HTMLElement {\n        // Clone the element and add the right classes.\n        const drag = <HTMLElement> dragHome.cloneNode(true);\n        drag.classList.remove('draghome');\n        drag.classList.add('dragitem');\n        drag.classList.add('item' + itemNo);\n        drag.classList.remove('dragplaceholder'); // In case it has it.\n        dragHome.classList.add('dragplaceholder');\n\n        // Insert the new drag after the dragHome.\n        dragHome.parentElement?.insertBefore(drag, dragHome.nextSibling);\n        if (!this.readOnly) {\n            this.draggable(drag);\n        }\n\n        return drag;\n    }\n\n    /**\n     * Convert the X and Y position of the BG IMG to a position relative to the window.\n     *\n     * @param bgImgXY X and Y of the BG IMG relative position.\n     * @returns Position relative to the window.\n     */\n    convertToWindowXY(bgImgXY: string): number[] {\n        const bgImg = this.doc.bgImg();\n        if (!bgImg) {\n            return [];\n        }\n\n        const position = this.getElementCoordinates(bgImg);\n        let coordsNumbers = this.parsePoint(bgImgXY);\n\n        coordsNumbers = this.makePointProportional(coordsNumbers);\n\n        return [coordsNumbers.x + position[0], coordsNumbers.y + position[1]];\n    }\n\n    /**\n     * Returns elements coordinates relative to ddarea container.\n     *\n     * @param element Element.\n     * @returns Array of X and Y coordinates.\n     */\n    protected getElementCoordinates(element: HTMLElement): number[] {\n        const ddArea = this.container.querySelector<HTMLElement>('.ddarea');\n        if (!ddArea) {\n            return [];\n        }\n\n        const position = CoreDom.getRelativeElementPosition(element, ddArea);\n\n        return [position.x, position.y];\n    }\n\n    /**\n     * Check if some coordinates (X, Y) are inside the background image.\n     *\n     * @param coords Coordinates to check.\n     * @returns Whether they're inside the background image.\n     */\n    coordsInImg(coords: CoreCoordinates): boolean {\n        const bgImg = this.doc.bgImg();\n        if (!bgImg) {\n            return false;\n        }\n\n        return (coords.x * this.proportion <= bgImg.width + 1) && (coords.y * this.proportion <= bgImg.height + 1);\n    }\n\n    /**\n     * Deselect all draggable items.\n     */\n    deselectDrags(): void {\n        const drags = this.doc.dragItems();\n        drags.forEach((drag) => {\n            drag.classList.remove('beingdragged');\n        });\n        this.selected = undefined;\n    }\n\n    /**\n     * Function to call when the instance is no longer needed.\n     */\n    destroy(): void {\n        this.resizeListener?.off();\n    }\n\n    /**\n     * Make an element \"draggable\". In the mobile app, items are \"dragged\" using tap and drop.\n     *\n     * @param drag Element.\n     */\n    draggable(drag: HTMLElement): void {\n        drag.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const dragging = this.selected;\n            if (dragging && !drag.classList.contains('unplaced')) {\n\n                const position = this.getElementCoordinates(drag);\n                const bgImg = this.doc.bgImg();\n                if (!bgImg) {\n                    return;\n                }\n\n                const bgImgPos = this.getElementCoordinates(bgImg);\n\n                position[0] = position[0] - bgImgPos[0] + e.offsetX;\n                position[1] = position[1] - bgImgPos[1] + e.offsetY;\n\n                // Ensure the we click on a placed dragitem.\n                if (position[0] <= bgImg.width && position[1] <= bgImg.height) {\n                    this.deselectDrags();\n                    this.dropDrag(dragging, position);\n\n                    return;\n                }\n            }\n\n            if (drag.classList.contains('beingdragged')) {\n                this.deselectDrags();\n            } else {\n                this.selectDrag(drag);\n            }\n        });\n    }\n\n    /**\n     * Get the coordinates of the drag home of a certain choice.\n     *\n     * @param choiceNo Choice number.\n     * @returns Coordinates.\n     */\n    dragHomeXY(choiceNo: number): number[] {\n        const dragItemHome = this.doc.dragItemHome(choiceNo);\n        if (!dragItemHome) {\n            return [];\n        }\n\n        const position = this.getElementCoordinates(dragItemHome);\n\n        return [position[0], position[1]];\n    }\n\n    /**\n     * Draw a drop zone.\n     *\n     * @param dropZoneNo Number of the drop zone.\n     * @param markerText The marker text to set.\n     * @param shape Name of the shape of the drop zone (circle, rectangle, polygon).\n     * @param coords Coordinates of the shape.\n     * @param colour Colour of the shape.\n     */\n    drawDropZone(dropZoneNo: number, markerText: string, shape: string, coords: string, colour: string): void {\n        const markerTexts = this.doc.markerTexts();\n        // Check if there is already a marker text for this drop zone.\n        const existingMarkerText = markerTexts?.querySelector<HTMLElement>('span.markertext' + dropZoneNo);\n\n        if (existingMarkerText) {\n            // Marker text already exists. Update it or remove it if empty.\n            if (markerText !== '') {\n                existingMarkerText.innerHTML = markerText;\n            } else {\n                existingMarkerText.remove();\n            }\n        } else if (markerText !== '' && markerTexts) {\n            // Create and add the marker text.\n            const classNames = 'markertext markertext' + dropZoneNo;\n            const span = document.createElement('span');\n\n            span.className = classNames;\n            span.innerHTML = markerText;\n\n            markerTexts.appendChild(span);\n        }\n\n        // Check that a function to draw this shape exists.\n        const drawFunc = 'drawShape' + CoreTextUtils.ucFirst(shape);\n        if (!(this[drawFunc] instanceof Function)) {\n            return;\n        }\n\n        // Call the function.\n        const xyForText = this[drawFunc](dropZoneNo, coords, colour);\n        if (xyForText === null || xyForText === undefined) {\n            return;\n        }\n\n        // Search the marker for the drop zone.\n        const markerSpan = this.doc.topNode?.querySelector<HTMLElement>(`div.ddarea div.markertexts span.markertext${dropZoneNo}`);\n        if (!markerSpan) {\n            return;\n        }\n\n        const computedStyle = getComputedStyle(markerSpan);\n        const width = markerSpan.getBoundingClientRect().width +\n            CoreDomUtils.getComputedStyleMeasure(computedStyle, 'borderLeftWidth') +\n            CoreDomUtils.getComputedStyleMeasure(computedStyle, 'borderRightWidth') +\n            CoreDomUtils.getComputedStyleMeasure(computedStyle, 'paddingLeft') +\n            CoreDomUtils.getComputedStyleMeasure(computedStyle, 'paddingRight');\n\n        const height =  markerSpan.getBoundingClientRect().height +\n            CoreDomUtils.getComputedStyleMeasure(computedStyle, 'borderTopWidth') +\n            CoreDomUtils.getComputedStyleMeasure(computedStyle, 'borderBottomWidth') +\n            CoreDomUtils.getComputedStyleMeasure(computedStyle, 'paddingTop') +\n            CoreDomUtils.getComputedStyleMeasure(computedStyle, 'paddingBottom');\n        markerSpan.style.opacity = '0.6';\n        markerSpan.style.left = (xyForText.x - (width / 2)) + 'px';\n        markerSpan.style.top = (xyForText.y - (height / 2)) + 'px';\n\n        const markerSpanAnchor = markerSpan.querySelector('a');\n        if (markerSpanAnchor !== null) {\n\n            markerSpanAnchor.addEventListener('click', (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n\n                this.shapes.forEach((elem) => {\n                    elem.style.fillOpacity = '0.5';\n                });\n\n                this.shapes[dropZoneNo].style.fillOpacity = '1';\n                setTimeout(() => {\n                    this.shapes[dropZoneNo].style.fillOpacity = '0.5';\n                }, 2000);\n            });\n\n            markerSpanAnchor.setAttribute('tabIndex', '0');\n        }\n    }\n\n    /**\n     * Draw a circle in a drop zone.\n     *\n     * @param dropZoneNo Number of the drop zone.\n     * @param coordinates Coordinates of the circle.\n     * @param colour Colour of the circle.\n     * @returns X and Y position of the center of the circle.\n     */\n    drawShapeCircle(dropZoneNo: number, coordinates: string, colour: string): CoreCoordinates | null {\n        if (!coordinates.match(/^\\d+(\\.\\d+)?,\\d+(\\.\\d+)?;\\d+(\\.\\d+)?$/)) {\n            return null;\n        }\n\n        const bits = coordinates.split(';');\n        let centre = this.parsePoint(bits[0]);\n        const radius = Number(bits[1]);\n\n        // Calculate circle limits and check it's inside the background image.\n        const circleLimit = { x: centre.x - radius, y: centre.y - radius };\n        if (this.coordsInImg(circleLimit)) {\n            centre = this.makePointProportional(centre);\n\n            // All good, create the shape.\n            this.shapes[dropZoneNo] = this.graphics.addShape({\n                type: 'circle',\n                color: colour,\n            }, {\n                cx: centre.x,\n                cy: centre.y,\n                r: Math.round(radius * this.proportion),\n            });\n\n            // Return the centre.\n            return centre;\n        }\n\n        return null;\n    }\n\n    /**\n     * Draw a rectangle in a drop zone.\n     *\n     * @param dropZoneNo Number of the drop zone.\n     * @param coordinates Coordinates of the rectangle.\n     * @param colour Colour of the rectangle.\n     * @returns X and Y position of the center of the rectangle.\n     */\n    drawShapeRectangle(dropZoneNo: number, coordinates: string, colour: string): CoreCoordinates | null {\n        if (!coordinates.match(/^\\d+(\\.\\d+)?,\\d+(\\.\\d+)?;\\d+(\\.\\d+)?,\\d+(\\.\\d+)?$/)) {\n            return null;\n        }\n\n        const bits = coordinates.split(';');\n        const startPoint = this.parsePoint(bits[0]);\n        const size = this.parsePoint(bits[1]);\n\n        // Calculate rectangle limits and check it's inside the background image.\n        const rectLimits = { x: startPoint.x + size.x, y: startPoint.y + size.y };\n        if (this.coordsInImg(rectLimits)) {\n            const startPointProp = this.makePointProportional(startPoint);\n            const sizeProp = this.makePointProportional(size);\n\n            // All good, create the shape.\n            this.shapes[dropZoneNo] = this.graphics.addShape({\n                type: 'rect',\n                color: colour,\n            }, {\n                x: startPointProp.x,\n                y: startPointProp.y,\n                width: sizeProp.x,\n                height: sizeProp.y,\n            });\n\n            const centre = { x: startPoint.x + (size.x / 2) , y: startPoint.y + (size.y / 2) };\n\n            // Return the centre.\n            return this.makePointProportional(centre);\n        }\n\n        return null;\n    }\n\n    /**\n     * Draw a polygon in a drop zone.\n     *\n     * @param dropZoneNo Number of the drop zone.\n     * @param coordinates Coordinates of the polygon.\n     * @param colour Colour of the polygon.\n     * @returns X and Y position of the center of the polygon.\n     */\n    drawShapePolygon(dropZoneNo: number, coordinates: string, colour: string): CoreCoordinates | null {\n        if (!coordinates.match(/^\\d+(\\.\\d+)?,\\d+(\\.\\d+)?(?:;\\d+(\\.\\d+)?,\\d+(\\.\\d+)?)*$/)) {\n            return null;\n        }\n\n        const bits = coordinates.split(';');\n        const centre = { x: 0, y: 0 };\n        const points = bits.map((bit) => {\n            const point = this.parsePoint(bit);\n            centre.x += point.x;\n            centre.y += point.y;\n\n            return point;\n        });\n\n        if (points.length > 0) {\n            centre.x = Math.round(centre.x / points.length);\n            centre.y = Math.round(centre.y / points.length);\n        }\n\n        const pointsOnImg: string[] = [];\n        points.forEach((point) => {\n            if (this.coordsInImg(point)) {\n                point = this.makePointProportional(point);\n\n                pointsOnImg.push(point.x + ',' + point.y);\n            }\n        });\n\n        if (pointsOnImg.length > 2) {\n            this.shapes[dropZoneNo] = this.graphics.addShape({\n                type: 'polygon',\n                color: colour,\n            }, {\n                points: pointsOnImg.join(' '),\n            });\n\n            // Return the centre.\n            return this.makePointProportional(centre);\n        }\n\n        return null;\n    }\n\n    /**\n     * Make a point from the string representation.\n     *\n     * @param coordinates \"x,y\".\n     * @returns Coordinates to the point.\n     */\n    parsePoint(coordinates: string): CoreCoordinates {\n        const bits = coordinates.split(',');\n        if (bits.length !== 2) {\n            throw coordinates + ' is not a valid point';\n        }\n\n        return { x: Number(bits[0]), y: Number(bits[1]) };\n    }\n\n    /**\n     * Make proportional position of the point.\n     *\n     * @param point Point coordinates.\n     * @returns Converted point.\n     */\n    makePointProportional(point: CoreCoordinates): CoreCoordinates {\n        return {\n            x: Math.round(point.x * this.proportion),\n            y: Math.round(point.y * this.proportion),\n\n        };\n    }\n\n    /**\n     * Drop a drag element into a certain position.\n     *\n     * @param drag The element to drop.\n     * @param position Position to drop to (X, Y).\n     */\n    dropDrag(drag: HTMLElement, position: number[] | null): void {\n        const choiceNo = this.getChoiceNoForNode(drag);\n\n        if (position) {\n            // Set the position related to the natural image dimensions.\n            if (this.proportion < 1) {\n                position[0] = Math.round(position[0] / this.proportion);\n                position[1] = Math.round(position[1] / this.proportion);\n            }\n        }\n\n        this.saveAllXYForChoice(choiceNo, drag, position);\n        this.redrawDragsAndDrops();\n    }\n\n    /**\n     * Determine which drag items need to be shown and return coords of all drag items except any that are currently being\n     * dragged based on contents of hidden inputs and whether drags are 'infinite' or how many drags should be shown.\n     *\n     * @param input The input element.\n     * @returns List of coordinates.\n     */\n    getCoords(input: HTMLElement): number[][] {\n        const choiceNo = this.getChoiceNoForNode(input);\n        const fv = input.getAttribute('value');\n        const infinite = input.classList.contains('infinite');\n        const noOfDrags = this.getNoOfDragsForNode(input);\n        const dragging = !!this.doc.dragItemBeingDragged(choiceNo);\n        const coords: number[][] = [];\n\n        if (fv !== '' && fv !== undefined && fv !== null) {\n            // Get all the coordinates in the input and add them to the coords list.\n            const coordsStrings = fv.split(';');\n\n            for (let i = 0; i < coordsStrings.length; i++) {\n                coords[coords.length] = this.convertToWindowXY(coordsStrings[i]);\n            }\n        }\n\n        const displayedDrags = coords.length + (dragging ? 1 : 0);\n        if (infinite || (displayedDrags < noOfDrags)) {\n            coords[coords.length] = this.dragHomeXY(choiceNo);\n        }\n\n        return coords;\n    }\n\n    /**\n     * Get the choice number from an HTML element.\n     *\n     * @param node Element to check.\n     * @returns Choice number.\n     */\n    getChoiceNoForNode(node: HTMLElement): number {\n        return Number(this.doc.getClassnameNumericSuffix(node, 'choice'));\n    }\n\n    /**\n     * Get the coordinates (X, Y) of a draggable element.\n     *\n     * @param dragItem The draggable item.\n     * @returns Coordinates.\n     */\n    getDragXY(dragItem: HTMLElement): number[] {\n        const position = this.getElementCoordinates(dragItem);\n        const bgImg = this.doc.bgImg();\n        if (bgImg) {\n            const bgImgXY = this.getElementCoordinates(bgImg);\n\n            position[0] -= bgImgXY[0];\n            position[1] -= bgImgXY[1];\n        }\n\n        // Set the position related to the natural image dimensions.\n        if (this.proportion < 1) {\n            position[0] = Math.round(position[0] / this.proportion);\n            position[1] = Math.round(position[1] / this.proportion);\n        }\n\n        return position;\n    }\n\n    /**\n     * Get the item number from an HTML element.\n     *\n     * @param node Element to check.\n     * @returns Choice number.\n     */\n    getItemNoForNode(node: HTMLElement): number {\n        return Number(this.doc.getClassnameNumericSuffix(node, 'item'));\n    }\n\n    /**\n     * Get the next colour.\n     *\n     * @returns Colour.\n     */\n    getNextColour(): string {\n        const colour = this.COLOURS[this.nextColourIndex];\n        this.nextColourIndex++;\n\n        // If we reached the end of the list, start again.\n        if (this.nextColourIndex === this.COLOURS.length) {\n            this.nextColourIndex = 0;\n        }\n\n        return colour;\n    }\n\n    /**\n     * Get the number of drags from an HTML element.\n     *\n     * @param node Element to check.\n     * @returns Choice number.\n     */\n    getNoOfDragsForNode(node: HTMLElement): number {\n        return Number(this.doc.getClassnameNumericSuffix(node, 'noofdrags'));\n    }\n\n    /**\n     * Initialize the question.\n     */\n    initializer(): void {\n        this.doc = new AddonQtypeDdMarkerQuestionDocStructure(this.container);\n\n        // Wait the DOM to be rendered.\n        setTimeout(() => {\n            this.pollForImageLoad();\n        });\n\n        this.resizeListener = CoreDom.onWindowResize(() => {\n            this.redrawDragsAndDrops();\n        });\n    }\n\n    /**\n     * Make background image and home zone dropable.\n     */\n    makeImageDropable(): void {\n        if (this.readOnly) {\n            return;\n        }\n\n        // Listen for click events in the background image to make it dropable.\n        const bgImg = this.doc.bgImg();\n        bgImg?.addEventListener('click', (e) => {\n\n            const drag = this.selected;\n            if (!drag) {\n                // No draggable element selected, nothing to do.\n                return false;\n            }\n\n            // There's an element being dragged. Deselect it and drop it in the position.\n            const position = [e.offsetX, e.offsetY];\n            this.deselectDrags();\n            this.dropDrag(drag, position);\n\n            e.preventDefault();\n            e.stopPropagation();\n        });\n\n        const home = this.doc.dragItemsArea;\n        home?.addEventListener('click', (e) => {\n\n            const drag = this.selected;\n            if (!drag) {\n                // No draggable element selected, nothing to do.\n                return false;\n            }\n\n            // There's an element being dragged but it's not placed yet, deselect.\n            if (drag.classList.contains('unplaced')) {\n                this.deselectDrags();\n\n                return false;\n            }\n\n            // There's an element being dragged and it's placed somewhere. Move it back to the home area.\n            this.deselectDrags();\n            this.dropDrag(drag, null);\n\n            e.preventDefault();\n            e.stopPropagation();\n        });\n    }\n\n    /**\n     * Wait for the background image to be loaded.\n     */\n    pollForImageLoad(): void {\n        if (this.afterImageLoadDone) {\n            // Already treated.\n            return;\n        }\n\n        const bgImg = this.doc.bgImg();\n        if (!bgImg) {\n            return;\n        }\n\n        if (!bgImg.src && this.imgSrc) {\n            bgImg.src = this.imgSrc;\n        }\n\n        const imgLoaded = (): void => {\n            bgImg.removeEventListener('load', imgLoaded);\n\n            this.makeImageDropable();\n\n            setTimeout(() => {\n                this.redrawDragsAndDrops();\n            });\n\n            this.afterImageLoadDone = true;\n            this.question.loaded = true;\n        };\n\n        if (!bgImg.src || (bgImg.complete && bgImg.naturalWidth)) {\n            imgLoaded();\n\n            return;\n        }\n\n        bgImg.addEventListener('load', imgLoaded);\n\n        // Try again after a while.\n        setTimeout(() => {\n            this.pollForImageLoad();\n        }, 500);\n    }\n\n    /**\n     * Redraw all draggables and drop zones.\n     */\n    redrawDragsAndDrops(): void {\n        // Mark all the draggable items as not placed.\n        const drags = this.doc.dragItems();\n        drags.forEach((drag) => {\n            drag.classList.add('unneeded', 'unplaced');\n        });\n\n        // Re-calculate the image proportion.\n        this.calculateImgProportion();\n\n        // Get all the inputs.\n        const inputs = this.doc.inputsForChoices();\n        for (let x = 0; x < inputs.length; x++) {\n\n            // Get all the drag items for the choice.\n            const input = inputs[x];\n            const choiceNo = this.getChoiceNoForNode(input);\n            const coords = this.getCoords(input);\n            const dragItemHome = this.doc.dragItemHome(choiceNo);\n            const homePosition = this.dragHomeXY(choiceNo);\n            if (!dragItemHome) {\n                continue;\n            }\n\n            for (let i = 0; i < coords.length; i++) {\n                let dragItem = this.doc.dragItemForChoice(choiceNo, i);\n\n                if (!dragItem || dragItem.classList.contains('beingdragged')) {\n                    dragItem = this.cloneNewDragItem(dragItemHome, i);\n                } else {\n                    dragItem.classList.remove('unneeded');\n                }\n\n                const placeholder = this.doc.dragItemPlaceholder(choiceNo);\n\n                // Remove the class only if is placed on the image.\n                if (homePosition[0] != coords[i][0] || homePosition[1] != coords[i][1]) {\n                    dragItem.classList.remove('unplaced');\n                    dragItem.classList.add('placed');\n\n                    const computedStyle = getComputedStyle(dragItem);\n                    const left = coords[i][0] - CoreDomUtils.getComputedStyleMeasure(computedStyle, 'marginLeft');\n                    const top = coords[i][1] - CoreDomUtils.getComputedStyleMeasure(computedStyle, 'marginTop');\n\n                    dragItem.style.left = left + 'px';\n                    dragItem.style.top = top + 'px';\n                    placeholder?.classList.add('active');\n                } else {\n                    dragItem.classList.remove('placed');\n                    dragItem.classList.add('unplaced');\n                    placeholder?.classList.remove('active');\n                }\n            }\n        }\n\n        // Remove unneeded draggable items.\n        for (let y = 0; y < drags.length; y++) {\n            const item = drags[y];\n            if (item.classList.contains('unneeded') && !item.classList.contains('beingdragged')) {\n                item.remove();\n            }\n        }\n\n        // Re-draw drop zones.\n        if (this.dropZones && this.dropZones.length !== 0) {\n            this.graphics.clear();\n            this.restartColours();\n\n            for (const dropZoneNo in this.dropZones) {\n                const colourForDropZone = this.getNextColour();\n                const dropZone = this.dropZones[dropZoneNo];\n                const dzNo = Number(dropZoneNo);\n\n                this.drawDropZone(dzNo, dropZone.markertext, dropZone.shape, dropZone.coords, colourForDropZone);\n            }\n        }\n    }\n\n    /**\n     * Reset the coordinates stored for a choice.\n     *\n     * @param choiceNo Choice number.\n     */\n    resetDragXY(choiceNo: number): void {\n        this.setFormValue(choiceNo, '');\n    }\n\n    /**\n     * Restart the colour index.\n     */\n    restartColours(): void {\n        this.nextColourIndex = 0;\n    }\n\n    /**\n     * Save all the coordinates of a choice into the right input.\n     *\n     * @param choiceNo Number of the choice.\n     * @param dropped Element being dropped.\n     * @param position Position where the element is dropped.\n     */\n    saveAllXYForChoice(choiceNo: number, dropped: HTMLElement, position: number[] | null): void {\n        const coords: number[][] = [];\n\n        // Calculate the coords for the choice.\n        const dragItemsChoice = this.doc.dragItemsForChoice(choiceNo);\n        for (let i = 0; i < dragItemsChoice.length; i++) {\n\n            const dragItem = this.doc.dragItemForChoice(choiceNo, i);\n            if (dragItem) {\n                const bgImgXY = this.getDragXY(dragItem);\n                dragItem.classList.remove('item' + i);\n                dragItem.classList.add('item' + coords.length);\n                coords.push(bgImgXY);\n            }\n        }\n\n        if (position !== null) {\n            // Element dropped into a certain position. Mark it as placed and save the position.\n            dropped.classList.remove('unplaced');\n            dropped.classList.add('item' + coords.length);\n            coords.push(position);\n        } else {\n            // Element back at home, mark it as unplaced.\n            dropped.classList.add('unplaced');\n        }\n\n        if (coords.length > 0) {\n            // Save the coordinates in the input.\n            this.setFormValue(choiceNo, coords.join(';'));\n        } else {\n            // Empty the input.\n            this.resetDragXY(choiceNo);\n        }\n    }\n\n    /**\n     * Save a certain value in the input of a choice.\n     *\n     * @param choiceNo Choice number.\n     * @param value The value to set.\n     */\n    setFormValue(choiceNo: number, value: string): void {\n        this.doc.inputForChoice(choiceNo)?.setAttribute('value', value);\n    }\n\n    /**\n     * Select a draggable element.\n     *\n     * @param drag Element.\n     */\n    selectDrag(drag: HTMLElement): void {\n        // Deselect previous drags.\n        this.deselectDrags();\n\n        this.selected = drag;\n        drag.classList.add('beingdragged');\n\n        const itemNo = this.getItemNoForNode(drag);\n        if (itemNo !== null) {\n            drag.classList.remove('item' + itemNo);\n        }\n    }\n\n}\n\n/**\n * Encapsulates operations on dd area.\n */\nexport class AddonQtypeDdMarkerQuestionDocStructure {\n\n    topNode: HTMLElement | null;\n    dragItemsArea: HTMLElement | null;\n\n    protected logger: CoreLogger;\n\n    constructor(\n        protected container: HTMLElement,\n    ) {\n        this.logger = CoreLogger.getInstance('AddonQtypeDdMarkerQuestionDocStructure');\n\n        this.topNode = this.container.querySelector<HTMLElement>('.addon-qtype-ddmarker-container');\n        this.dragItemsArea = this.topNode?.querySelector<HTMLElement>('div.dragitems, div.draghomes') || null;\n    }\n\n    querySelector<T = HTMLElement>(element: HTMLElement | null, selector: string): T | null {\n        if (!element) {\n            return null;\n        }\n\n        return <T | null> element.querySelector(selector);\n    }\n\n    querySelectorAll(element: HTMLElement | null, selector: string): HTMLElement[] {\n        if (!element) {\n            return [];\n        }\n\n        return Array.from(element.querySelectorAll(selector));\n    }\n\n    bgImg(): HTMLImageElement | null {\n        return this.querySelector(this.topNode, '.dropbackground');\n    }\n\n    dragItems(): HTMLElement[] {\n        return this.querySelectorAll(this.dragItemsArea, '.dragitem');\n    }\n\n    dragItemsForChoice(choiceNo: number): HTMLElement[] {\n        return this.querySelectorAll(this.dragItemsArea, `span.dragitem.choice${choiceNo}`);\n    }\n\n    dragItemForChoice(choiceNo: number, itemNo: number): HTMLElement | null {\n        return this.querySelector(this.dragItemsArea, `span.dragitem.choice${choiceNo}.item${itemNo}`);\n    }\n\n    dragItemPlaceholder(choiceNo: number): HTMLElement | null {\n        return this.querySelector(this.dragItemsArea, `span.dragplaceholder.choice${choiceNo}`);\n    }\n\n    dragItemBeingDragged(choiceNo: number): HTMLElement | null {\n        return this.querySelector(this.dragItemsArea, `span.dragitem.beingdragged.choice${choiceNo}`);\n\n    }\n\n    dragItemHome(choiceNo: number): HTMLElement | null {\n        return this.querySelector(this.dragItemsArea, `span.draghome.choice${choiceNo}, span.marker.choice${choiceNo}`);\n    }\n\n    dragItemHomes(): HTMLElement[] {\n        return this.querySelectorAll(this.dragItemsArea, 'span.draghome, span.marker');\n    }\n\n    getClassnameNumericSuffix(node: HTMLElement, prefix: string): number | undefined {\n        if (node.classList.length) {\n            const patt1 = new RegExp('^' + prefix + '([0-9])+$');\n            const patt2 = new RegExp('([0-9])+$');\n\n            for (let index = 0; index < node.classList.length; index++) {\n                if (patt1.test(node.classList[index])) {\n                    const match = patt2.exec(node.classList[index]);\n\n                    return Number(match?.[0]);\n                }\n            }\n        }\n\n        this.logger.warn('Prefix \"' + prefix + '\" not found in class names.');\n    }\n\n    inputsForChoices(): HTMLElement[] {\n        return this.querySelectorAll(this.topNode, 'input.choices');\n    }\n\n    inputForChoice(choiceNo: number): HTMLElement | null {\n        return this.querySelector(this.topNode, `input.choice${choiceNo}`);\n    }\n\n    markerTexts(): HTMLElement | null {\n        return this.querySelector(this.topNode, 'div.markertexts');\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}