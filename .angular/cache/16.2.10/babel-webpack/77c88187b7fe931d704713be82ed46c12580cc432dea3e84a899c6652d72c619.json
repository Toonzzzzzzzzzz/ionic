{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreSites } from '@services/sites';\nimport { AddonCalendar, AddonCalendarEventType, AddonCalendarProvider } from './calendar';\nimport { CoreConfig } from '@services/config';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourse } from '@features/course/services/course';\nimport { CoreConstants } from '@/core/constants';\nimport moment from 'moment-timezone';\nimport { makeSingleton } from '@singletons';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreReminders, CoreRemindersService } from '@features/reminders/services/reminders';\nimport { CoreCourseModuleDelegate } from '@features/course/services/module-delegate';\nimport * as i0 from \"@angular/core\";\n/**\n * Context levels enumeration.\n */\nexport var AddonCalendarEventIcons;\n(function (AddonCalendarEventIcons) {\n  AddonCalendarEventIcons[\"SITE\"] = \"fas-globe\";\n  AddonCalendarEventIcons[\"CATEGORY\"] = \"fas-cubes\";\n  AddonCalendarEventIcons[\"COURSE\"] = \"fas-graduation-cap\";\n  AddonCalendarEventIcons[\"GROUP\"] = \"fas-users\";\n  AddonCalendarEventIcons[\"USER\"] = \"fas-user\";\n})(AddonCalendarEventIcons || (AddonCalendarEventIcons = {}));\n/**\n * Service that provides some features regarding lists of courses and categories.\n */\nexport class AddonCalendarHelperProvider {\n  constructor() {\n    this.eventTypeIcons = [];\n  }\n  /**\n   * Returns event icon based on event type.\n   *\n   * @param eventType Type of the event.\n   * @returns Event icon.\n   */\n  getEventIcon(eventType) {\n    if (this.eventTypeIcons.length == 0) {\n      CoreUtils.enumKeys(AddonCalendarEventType).forEach(name => {\n        const value = AddonCalendarEventType[name];\n        this.eventTypeIcons[value] = AddonCalendarEventIcons[name];\n      });\n    }\n    return this.eventTypeIcons[eventType] || '';\n  }\n  /**\n   * Calculate some day data based on a list of events for that day.\n   *\n   * @param day Day.\n   * @param events Events.\n   */\n  calculateDayData(day, events) {\n    day.hasevents = events.length > 0;\n    day.haslastdayofevent = false;\n    const types = {};\n    events.forEach(event => {\n      types[event.formattedType || event.eventtype] = true;\n      if (event.islastday) {\n        day.haslastdayofevent = true;\n      }\n    });\n    day.calendareventtypes = Object.keys(types);\n  }\n  /**\n   * Check if current user can create/edit events.\n   *\n   * @param courseId Course ID. If not defined, site calendar.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with boolean: whether the user can create events.\n   */\n  canEditEvents(courseId, siteId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const canEdit = yield AddonCalendar.canEditEvents(siteId);\n        if (!canEdit) {\n          return false;\n        }\n        const types = yield AddonCalendar.getAllowedEventTypes(courseId, siteId);\n        return Object.keys(types).length > 0;\n      } catch (_unused) {\n        return false;\n      }\n    })();\n  }\n  /**\n   * Classify events into their respective months and days. If an event duration covers more than one day,\n   * it will be included in all the days it lasts.\n   *\n   * @param offlineEvents Events to classify.\n   * @returns Object with the classified events.\n   */\n  classifyIntoMonths(offlineEvents) {\n    // Format data.\n    const events = offlineEvents.map(event => AddonCalendarHelper.formatOfflineEventData(event));\n    const result = {};\n    events.forEach(event => {\n      const treatedDay = moment(event.timestart * 1000);\n      const endDay = moment((event.timestart + event.timeduration) * 1000);\n      // Add the event to all the days it lasts.\n      while (!treatedDay.isAfter(endDay, 'day')) {\n        const monthId = this.getMonthId(treatedDay);\n        const day = treatedDay.date();\n        if (!result[monthId]) {\n          result[monthId] = {};\n        }\n        if (!result[monthId][day]) {\n          result[monthId][day] = [];\n        }\n        result[monthId][day].push(event);\n        treatedDay.add(1, 'day'); // Treat next day.\n      }\n    });\n\n    return result;\n  }\n  /**\n   * Convenience function to format some event data to be rendered.\n   *\n   * @param event Event to format.\n   * @returns The formatted event to display.\n   */\n  formatEventData(event) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const eventFormatted = _objectSpread(_objectSpread({}, event), {}, {\n        location: 'location' in event ? event.location : undefined,\n        eventcount: 'eventcount' in event ? event.eventcount || 0 : 0,\n        repeatid: event.repeatid || 0,\n        eventIcon: _this.getEventIcon(event.eventtype),\n        formattedType: AddonCalendar.getEventType(event),\n        format: 1,\n        visible: 1,\n        offline: false,\n        purpose: 'purpose' in event ? event.purpose : undefined\n      });\n      if (event.modulename) {\n        eventFormatted.eventIcon = yield CoreCourseModuleDelegate.getModuleIconSrc(event.modulename, 'icon' in event ? event.icon.iconurl : undefined);\n        eventFormatted.moduleIcon = eventFormatted.eventIcon;\n        eventFormatted.iconTitle = CoreCourse.translateModuleName(event.modulename);\n      }\n      eventFormatted.formattedType = AddonCalendar.getEventType(event);\n      // Calculate context.\n      if ('course' in event) {\n        var _event$course;\n        eventFormatted.courseid = (_event$course = event.course) === null || _event$course === void 0 ? void 0 : _event$course.id;\n      } else if ('courseid' in event) {\n        eventFormatted.courseid = event.courseid;\n      }\n      // Calculate context.\n      if ('category' in event) {\n        var _event$category;\n        eventFormatted.categoryid = (_event$category = event.category) === null || _event$category === void 0 ? void 0 : _event$category.id;\n      } else if ('categoryid' in event) {\n        eventFormatted.categoryid = event.categoryid;\n      }\n      if ('canedit' in event) {\n        eventFormatted.canedit = event.canedit;\n      }\n      if ('candelete' in event) {\n        eventFormatted.candelete = event.candelete;\n      }\n      _this.formatEventContext(eventFormatted, eventFormatted.courseid, eventFormatted.categoryid);\n      return eventFormatted;\n    })();\n  }\n  /**\n   * Convenience function to format some event data to be rendered.\n   *\n   * @param event Event to format.\n   * @returns The formatted offline event to display.\n   */\n  formatOfflineEventData(event) {\n    const eventFormatted = {\n      id: event.id,\n      name: event.name,\n      timestart: event.timestart,\n      eventtype: event.eventtype,\n      categoryid: event.categoryid,\n      courseid: event.courseid || event.groupcourseid,\n      groupid: event.groupid,\n      description: event.description,\n      location: event.location,\n      duration: event.duration,\n      timedurationuntil: event.timedurationuntil,\n      timedurationminutes: event.timedurationminutes,\n      // repeat: event.repeat,\n      eventcount: event.repeats || 0,\n      repeatid: event.repeatid || 0,\n      // repeateditall: event.repeateditall,\n      userid: event.userid,\n      timemodified: event.timecreated || 0,\n      eventIcon: this.getEventIcon(event.eventtype),\n      formattedType: event.eventtype,\n      format: 1,\n      visible: 1,\n      offline: true,\n      canedit: event.id < 0,\n      candelete: event.id < 0,\n      timeduration: 0\n    };\n    // Calculate context.\n    const categoryId = event.categoryid;\n    const courseId = event.courseid || event.groupcourseid;\n    this.formatEventContext(eventFormatted, courseId, categoryId);\n    if (eventFormatted.duration == 1) {\n      eventFormatted.timeduration = (event.timedurationuntil || 0) - event.timestart;\n    } else if (eventFormatted.duration == 2) {\n      eventFormatted.timeduration = (event.timedurationminutes || 0) * CoreConstants.SECONDS_MINUTE;\n    } else {\n      eventFormatted.timeduration = 0;\n    }\n    return eventFormatted;\n  }\n  /**\n   * Modifies event data with the context information.\n   *\n   * @param eventFormatted Event formatted to be displayed.\n   * @param courseId Course Id if any.\n   * @param categoryId Category Id if any.\n   */\n  formatEventContext(eventFormatted, courseId, categoryId) {\n    if (categoryId && categoryId > 0) {\n      eventFormatted.contextLevel = \"coursecat\" /* ContextLevel.COURSECAT */;\n      eventFormatted.contextInstanceId = categoryId;\n    } else if (courseId && courseId > 0) {\n      eventFormatted.contextLevel = \"course\" /* ContextLevel.COURSE */;\n      eventFormatted.contextInstanceId = courseId;\n    } else {\n      eventFormatted.contextLevel = \"user\" /* ContextLevel.USER */;\n      eventFormatted.contextInstanceId = eventFormatted.userid;\n    }\n  }\n  /**\n   * Format reminders, adding calculated data.\n   *\n   * @param reminders Reminders.\n   * @param timestart Event timestart.\n   * @param siteId Site ID.\n   * @returns Formatted reminders.\n   * @deprecated since 4.1 Use AddonCalendarHelper.getEventReminders.\n   */\n  formatReminders(reminders, timestart, siteId) {\n    return _asyncToGenerator(function* () {\n      if (!reminders.length) {\n        return [];\n      }\n      return AddonCalendarHelper.getEventReminders(reminders[0].eventid, timestart, siteId);\n    })();\n  }\n  /**\n   * Format reminders, adding calculated data.\n   *\n   * @param eventId Event Id.\n   * @param eventTimestart Event timestart.\n   * @param siteId Site ID.\n   * @returns Formatted reminders.\n   */\n  getEventReminders(eventId, eventTimestart, siteId) {\n    return _asyncToGenerator(function* () {\n      const reminders = yield CoreReminders.getReminders({\n        instanceId: eventId,\n        component: AddonCalendarProvider.COMPONENT\n      }, siteId);\n      if (!reminders.length) {\n        return [];\n      }\n      const defaultTime = yield CoreReminders.getDefaultNotificationTime(siteId);\n      let defaultLabel;\n      if (defaultTime > CoreRemindersService.DISABLED) {\n        const data = CoreRemindersService.convertSecondsToValueAndUnit(defaultTime);\n        defaultLabel = CoreReminders.getUnitValueLabel(data.value, data.unit, true);\n      }\n      return reminders.map(reminder => {\n        const formatted = {\n          id: reminder.id\n        };\n        if (reminder.timebefore === CoreRemindersService.DEFAULT_REMINDER_TIMEBEFORE) {\n          // Default time. Check if default notifications are disabled.\n          if (defaultLabel !== undefined) {\n            formatted.label = defaultLabel;\n            formatted.timestamp = eventTimestart - defaultTime;\n          }\n        } else {\n          const data = CoreRemindersService.convertSecondsToValueAndUnit(reminder.timebefore);\n          formatted.label = CoreReminders.getUnitValueLabel(data.value, data.unit, false);\n          formatted.timestamp = eventTimestart - reminder.timebefore;\n        }\n        if (formatted.timestamp) {\n          formatted.sublabel = CoreTimeUtils.userDate(formatted.timestamp * 1000, 'core.strftimedatetime');\n        }\n        return formatted;\n      });\n    })();\n  }\n  /**\n   * Get options (name & value) for each allowed event type.\n   *\n   * @param eventTypes Result of getAllowedEventTypes.\n   * @returns Options.\n   */\n  getEventTypeOptions(eventTypes) {\n    const options = [];\n    if (eventTypes.user) {\n      options.push({\n        name: 'core.user',\n        value: AddonCalendarEventType.USER\n      });\n    }\n    if (eventTypes.group) {\n      options.push({\n        name: 'core.group',\n        value: AddonCalendarEventType.GROUP\n      });\n    }\n    if (eventTypes.course) {\n      options.push({\n        name: 'core.course',\n        value: AddonCalendarEventType.COURSE\n      });\n    }\n    if (eventTypes.category) {\n      options.push({\n        name: 'core.category',\n        value: AddonCalendarEventType.CATEGORY\n      });\n    }\n    if (eventTypes.site) {\n      options.push({\n        name: 'core.site',\n        value: AddonCalendarEventType.SITE\n      });\n    }\n    return options;\n  }\n  /**\n   * Get the month \"id\".\n   *\n   * @param moment Month moment.\n   * @returns The \"id\".\n   */\n  getMonthId(moment) {\n    return `${moment.year()}#${moment.month() + 1}`;\n  }\n  /**\n   * Get the day \"id\".\n   *\n   * @param moment Day moment.\n   * @returns The \"id\".\n   */\n  getDayId(moment) {\n    return `${this.getMonthId(moment)}#${moment.date()}`;\n  }\n  /**\n   * Get weeks of a month in offline (with no events).\n   *\n   * The result has the same structure than getMonthlyEvents, but it only contains fields that are actually used by the app.\n   *\n   * @param year Year to get.\n   * @param month Month to get.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved with the response.\n   */\n  getOfflineMonthWeeks(year, month, siteId) {\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      // Get starting week day user preference, fallback to site configuration.\n      let startWeekDayStr = site.getStoredConfig('calendar_startwday') || '1';\n      startWeekDayStr = yield CoreConfig.get(AddonCalendarProvider.STARTING_WEEK_DAY, startWeekDayStr);\n      const startWeekDay = parseInt(startWeekDayStr, 10);\n      const today = moment();\n      const isCurrentMonth = today.year() == year && today.month() == month - 1;\n      const weeks = [];\n      let date = moment({\n        year,\n        month: month - 1,\n        date: 1\n      });\n      for (let mday = 1; mday <= date.daysInMonth(); mday++) {\n        date = moment({\n          year,\n          month: month - 1,\n          date: mday\n        });\n        // Add new week and calculate prepadding.\n        if (!weeks.length || date.day() == startWeekDay) {\n          const prepaddingLength = (date.day() - startWeekDay + 7) % 7;\n          const prepadding = [];\n          for (let i = 0; i < prepaddingLength; i++) {\n            prepadding.push(i);\n          }\n          weeks.push({\n            prepadding,\n            postpadding: [],\n            days: []\n          });\n        }\n        // Calculate postpadding of last week.\n        if (mday == date.daysInMonth()) {\n          const postpaddingLength = (startWeekDay - date.day() + 6) % 7;\n          const postpadding = [];\n          for (let i = 0; i < postpaddingLength; i++) {\n            postpadding.push(i);\n          }\n          weeks[weeks.length - 1].postpadding = postpadding;\n        }\n        // Add day to current week.\n        weeks[weeks.length - 1].days.push({\n          events: [],\n          hasevents: false,\n          mday: date.date(),\n          isweekend: date.day() == 0 || date.day() == 6,\n          istoday: isCurrentMonth && today.date() == date.date(),\n          calendareventtypes: [],\n          // Added to match the type. And possibly unused.\n          popovertitle: '',\n          ispast: today.date() > date.date(),\n          seconds: date.seconds(),\n          minutes: date.minutes(),\n          hours: date.hours(),\n          wday: date.weekday(),\n          year: year,\n          yday: date.dayOfYear(),\n          timestamp: date.date(),\n          haslastdayofevent: false,\n          neweventtimestamp: 0,\n          previousperiod: 0,\n          nextperiod: 0,\n          navigation: '' // Navigation.\n        });\n      }\n\n      return {\n        weeks,\n        daynames: [{\n          dayno: startWeekDay\n        }]\n      };\n    })();\n  }\n  /**\n   * Check if the data of an event has changed.\n   *\n   * @param data Current data.\n   * @param original Original data.\n   * @returns True if data has changed, false otherwise.\n   */\n  hasEventDataChanged(data, original) {\n    if (!original) {\n      // There is no original data, assume it hasn't changed.\n      return false;\n    }\n    // Check the fields that don't depend on any other.\n    if (data.name != original.name || data.timestart != original.timestart || data.eventtype != original.eventtype || data.description != original.description || data.location != original.location || data.duration != original.duration || data.repeat != original.repeat) {\n      return true;\n    }\n    // Check data that depends on eventtype.\n    if (data.eventtype == AddonCalendarEventType.CATEGORY && data.categoryid != original.categoryid || data.eventtype == AddonCalendarEventType.COURSE && data.courseid != original.courseid || data.eventtype == AddonCalendarEventType.GROUP && data.groupcourseid != original.groupcourseid && data.groupid != original.groupid) {\n      return true;\n    }\n    // Check data that depends on duration.\n    if (data.duration == 1 && data.timedurationuntil != original.timedurationuntil || data.duration == 2 && data.timedurationminutes != original.timedurationminutes) {\n      return true;\n    }\n    if (data.repeat && data.repeats != original.repeats) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Filter events to be shown on the events list.\n   *\n   * @param events Events without filtering.\n   * @param filter Filter from popover.\n   * @param categories Categories indexed by ID.\n   * @returns Filtered events.\n   */\n  getFilteredEvents(events, filter, categories) {\n    // Do not filter.\n    if (!filter || !filter.filtered) {\n      return events;\n    }\n    const courseId = filter.courseId ? Number(filter.courseId) : undefined;\n    if (!courseId || courseId < 0) {\n      // Filter only by type.\n      return events.filter(event => filter[event.formattedType]);\n    }\n    const categoryId = filter.categoryId ? Number(filter.categoryId) : undefined;\n    return events.filter(event => filter[event.formattedType] && this.shouldDisplayEvent(event, categories, courseId, categoryId));\n  }\n  /**\n   * Check if an event should be displayed based on the filter.\n   *\n   * @param event Event object.\n   * @param categories Categories indexed by ID.\n   * @param courseId Course ID to filter.\n   * @param categoryId Category ID the course belongs to.\n   * @returns Whether it should be displayed.\n   */\n  shouldDisplayEvent(event, categories, courseId, categoryId) {\n    if (event.eventtype === 'user' || event.eventtype === 'site') {\n      // User or site event, display it.\n      return true;\n    }\n    if (event.eventtype === 'category' && categories) {\n      if (!event.categoryid || !Object.keys(categories).length || !categoryId) {\n        // We can't tell if the course belongs to the category, display them all.\n        return true;\n      }\n      if (event.categoryid === categoryId) {\n        // The event is in the same category as the course, display it.\n        return true;\n      }\n      // Check parent categories.\n      let category = categories[categoryId];\n      while (category) {\n        if (!category.parent) {\n          // Category doesn't have parent, stop.\n          break;\n        }\n        if (event.categoryid === category.parent) {\n          return true;\n        }\n        category = categories[category.parent];\n      }\n      return false;\n    }\n    const eventCourse = event.course && event.course.id || event.courseid;\n    // Show the event if it is from site home or if it matches the selected course.\n    return !eventCourse || eventCourse === CoreSites.getCurrentSiteHomeId() || eventCourse === courseId;\n  }\n  /**\n   * Refresh the month & day for several created/edited/deleted events, and invalidate the months & days\n   * for their repeated events if needed.\n   *\n   * @param events Events that have been touched and number of times each event is repeated.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  refreshAfterChangeEvents(events, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const site = yield CoreSites.getSite(siteId);\n      const fetchTimestarts = [];\n      const invalidateTimestarts = [];\n      let promises = [];\n      // Always fetch upcoming events.\n      promises.push(AddonCalendar.getUpcomingEvents(undefined, undefined, true, site.id));\n      promises = promises.concat(events.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (eventData) {\n          if (eventData.repeated <= 1) {\n            // Not repeated.\n            fetchTimestarts.push(eventData.timestart);\n            return AddonCalendar.invalidateEvent(eventData.id);\n          }\n          if (eventData.repeatid) {\n            // Being edited or deleted.\n            // We need to calculate the days to invalidate because the event date could have changed.\n            // We don't know if the repeated events are before or after this one, invalidate them all.\n            fetchTimestarts.push(eventData.timestart);\n            for (let i = 1; i < eventData.repeated; i++) {\n              invalidateTimestarts.push(eventData.timestart + CoreConstants.SECONDS_DAY * 7 * i);\n              invalidateTimestarts.push(eventData.timestart - CoreConstants.SECONDS_DAY * 7 * i);\n            }\n            // Get the repeated events to invalidate them.\n            const repeatedEvents = yield AddonCalendar.getLocalEventsByRepeatIdFromLocalDb(eventData.repeatid, site.id);\n            yield CoreUtils.allPromises(repeatedEvents.map(event => AddonCalendar.invalidateEvent(event.id)));\n            return;\n          }\n          // Being added.\n          let time = eventData.timestart;\n          fetchTimestarts.push(time);\n          while (eventData.repeated > 1) {\n            time += CoreConstants.SECONDS_DAY * 7;\n            eventData.repeated--;\n            invalidateTimestarts.push(time);\n          }\n          return;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      try {\n        yield CoreUtils.allPromisesIgnoringErrors(promises);\n      } finally {\n        const treatedMonths = {};\n        const treatedDays = {};\n        const finalPromises = [AddonCalendar.invalidateAllUpcomingEvents()];\n        // Fetch months and days.\n        fetchTimestarts.forEach(fetchTime => {\n          const day = moment(fetchTime * 1000);\n          const monthId = _this2.getMonthId(day);\n          if (!treatedMonths[monthId]) {\n            // Month not refetch or invalidated already, do it now.\n            treatedMonths[monthId] = true;\n            finalPromises.push(AddonCalendar.getMonthlyEvents(day.year(), day.month() + 1, undefined, undefined, true, site.id));\n          }\n          const dayId = monthId + '#' + day.date();\n          if (!treatedDays[dayId]) {\n            // Dat not refetch or invalidated already, do it now.\n            treatedDays[dayId] = true;\n            finalPromises.push(AddonCalendar.getDayEvents(day.year(), day.month() + 1, day.date(), undefined, undefined, true, site.id));\n          }\n        });\n        // Invalidate months and days.\n        invalidateTimestarts.forEach(fetchTime => {\n          const day = moment(fetchTime * 1000);\n          const monthId = _this2.getMonthId(day);\n          if (!treatedMonths[monthId]) {\n            // Month not refetch or invalidated already, do it now.\n            treatedMonths[monthId] = true;\n            finalPromises.push(AddonCalendar.invalidateMonthlyEvents(day.year(), day.month() + 1, site.id));\n          }\n          const dayId = monthId + '#' + day.date();\n          if (!treatedDays[dayId]) {\n            // Dat not refetch or invalidated already, do it now.\n            treatedDays[dayId] = true;\n            finalPromises.push(AddonCalendar.invalidateDayEvents(day.year(), day.month() + 1, day.date(), site.id));\n          }\n        });\n        yield CoreUtils.allPromisesIgnoringErrors(finalPromises);\n      }\n    })();\n  }\n  /**\n   * Refresh the month & day for a created/edited/deleted event, and invalidate the months & days\n   * for their repeated events if needed.\n   *\n   * @param event Event that has been touched.\n   * @param repeated Number of times the event is repeated.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Resolved when done.\n   */\n  refreshAfterChangeEvent(event, repeated, siteId) {\n    return this.refreshAfterChangeEvents([{\n      id: event.id,\n      repeatid: event.repeatid,\n      timestart: event.timestart,\n      repeated: repeated\n    }], siteId);\n  }\n  /**\n   * Sort events by timestart.\n   *\n   * @param events List to sort.\n   * @returns Events sorted.\n   */\n  sortEvents(events) {\n    return events.sort((a, b) => {\n      if (a.timestart == b.timestart) {\n        return a.timeduration - b.timeduration;\n      }\n      return a.timestart - b.timestart;\n    });\n  }\n}\n_class = AddonCalendarHelperProvider;\n_class.ɵfac = function AddonCalendarHelperProvider_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonCalendarHelper = makeSingleton(AddonCalendarHelperProvider);","map":{"version":3,"names":["CoreSites","AddonCalendar","AddonCalendarEventType","AddonCalendarProvider","CoreConfig","CoreUtils","CoreCourse","CoreConstants","moment","makeSingleton","CoreTimeUtils","CoreReminders","CoreRemindersService","CoreCourseModuleDelegate","AddonCalendarEventIcons","AddonCalendarHelperProvider","constructor","eventTypeIcons","getEventIcon","eventType","length","enumKeys","forEach","name","value","calculateDayData","day","events","hasevents","haslastdayofevent","types","event","formattedType","eventtype","islastday","calendareventtypes","Object","keys","canEditEvents","courseId","siteId","_asyncToGenerator","canEdit","getAllowedEventTypes","_unused","classifyIntoMonths","offlineEvents","map","AddonCalendarHelper","formatOfflineEventData","result","treatedDay","timestart","endDay","timeduration","isAfter","monthId","getMonthId","date","push","add","formatEventData","_this","eventFormatted","_objectSpread","location","undefined","eventcount","repeatid","eventIcon","getEventType","format","visible","offline","purpose","modulename","getModuleIconSrc","icon","iconurl","moduleIcon","iconTitle","translateModuleName","_event$course","courseid","course","id","_event$category","categoryid","category","canedit","candelete","formatEventContext","groupcourseid","groupid","description","duration","timedurationuntil","timedurationminutes","repeats","userid","timemodified","timecreated","categoryId","SECONDS_MINUTE","contextLevel","contextInstanceId","formatReminders","reminders","getEventReminders","eventid","eventId","eventTimestart","getReminders","instanceId","component","COMPONENT","defaultTime","getDefaultNotificationTime","defaultLabel","DISABLED","data","convertSecondsToValueAndUnit","getUnitValueLabel","unit","reminder","formatted","timebefore","DEFAULT_REMINDER_TIMEBEFORE","label","timestamp","sublabel","userDate","getEventTypeOptions","eventTypes","options","user","USER","group","GROUP","COURSE","CATEGORY","site","SITE","year","month","getDayId","getOfflineMonthWeeks","getSite","startWeekDayStr","getStoredConfig","get","STARTING_WEEK_DAY","startWeekDay","parseInt","today","isCurrentMonth","weeks","mday","daysInMonth","prepaddingLength","prepadding","i","postpadding","days","postpaddingLength","isweekend","istoday","popovertitle","ispast","seconds","minutes","hours","wday","weekday","yday","dayOfYear","neweventtimestamp","previousperiod","nextperiod","navigation","daynames","dayno","hasEventDataChanged","original","repeat","getFilteredEvents","filter","categories","filtered","Number","shouldDisplayEvent","parent","eventCourse","getCurrentSiteHomeId","refreshAfterChangeEvents","_this2","fetchTimestarts","invalidateTimestarts","promises","getUpcomingEvents","concat","_ref","eventData","repeated","invalidateEvent","SECONDS_DAY","repeatedEvents","getLocalEventsByRepeatIdFromLocalDb","allPromises","time","_x","apply","arguments","allPromisesIgnoringErrors","treatedMonths","treatedDays","finalPromises","invalidateAllUpcomingEvents","fetchTime","getMonthlyEvents","dayId","getDayEvents","invalidateMonthlyEvents","invalidateDayEvents","refreshAfterChangeEvent","sortEvents","sort","a","b","factory","ɵfac","providedIn"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/calendar/services/calendar-helper.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { CoreSites } from '@services/sites';\nimport {\n    AddonCalendar,\n    AddonCalendarDayName,\n    AddonCalendarEvent,\n    AddonCalendarEventBase,\n    AddonCalendarEventToDisplay,\n    AddonCalendarEventType,\n    AddonCalendarGetEventsEvent,\n    AddonCalendarProvider,\n    AddonCalendarWeek,\n    AddonCalendarWeekDay,\n} from './calendar';\nimport { CoreConfig } from '@services/config';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreCourse } from '@features/course/services/course';\nimport { ContextLevel, CoreConstants } from '@/core/constants';\nimport moment from 'moment-timezone';\nimport { makeSingleton } from '@singletons';\nimport { AddonCalendarSyncInvalidateEvent } from './calendar-sync';\nimport { AddonCalendarOfflineEventDBRecord } from './database/calendar-offline';\nimport { CoreCategoryData } from '@features/courses/services/courses';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreReminders, CoreRemindersService } from '@features/reminders/services/reminders';\nimport { CoreCourseModuleDelegate } from '@features/course/services/module-delegate';\n\n/**\n * Context levels enumeration.\n */\nexport enum AddonCalendarEventIcons {\n    SITE = 'fas-globe',\n    CATEGORY = 'fas-cubes',\n    COURSE = 'fas-graduation-cap',\n    GROUP = 'fas-users',\n    USER = 'fas-user',\n}\n\n/**\n * Service that provides some features regarding lists of courses and categories.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonCalendarHelperProvider {\n\n    protected eventTypeIcons: string[] = [];\n\n    /**\n     * Returns event icon based on event type.\n     *\n     * @param eventType Type of the event.\n     * @returns Event icon.\n     */\n    getEventIcon(eventType: AddonCalendarEventType | string): string {\n        if (this.eventTypeIcons.length == 0) {\n            CoreUtils.enumKeys(AddonCalendarEventType).forEach((name) => {\n                const value = AddonCalendarEventType[name];\n                this.eventTypeIcons[value] = AddonCalendarEventIcons[name];\n            });\n        }\n\n        return this.eventTypeIcons[eventType] || '';\n    }\n\n    /**\n     * Calculate some day data based on a list of events for that day.\n     *\n     * @param day Day.\n     * @param events Events.\n     */\n    calculateDayData(day: AddonCalendarWeekDay, events: AddonCalendarEventToDisplay[]): void {\n        day.hasevents = events.length > 0;\n        day.haslastdayofevent = false;\n\n        const types = {};\n        events.forEach((event) => {\n            types[event.formattedType || event.eventtype] = true;\n\n            if (event.islastday) {\n                day.haslastdayofevent = true;\n            }\n        });\n\n        day.calendareventtypes = Object.keys(types) as AddonCalendarEventType[];\n    }\n\n    /**\n     * Check if current user can create/edit events.\n     *\n     * @param courseId Course ID. If not defined, site calendar.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with boolean: whether the user can create events.\n     */\n    async canEditEvents(courseId?: number, siteId?: string): Promise<boolean> {\n        try {\n            const canEdit = await AddonCalendar.canEditEvents(siteId);\n            if (!canEdit) {\n                return false;\n            }\n\n            const types = await AddonCalendar.getAllowedEventTypes(courseId, siteId);\n\n            return Object.keys(types).length > 0;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Classify events into their respective months and days. If an event duration covers more than one day,\n     * it will be included in all the days it lasts.\n     *\n     * @param offlineEvents Events to classify.\n     * @returns Object with the classified events.\n     */\n    classifyIntoMonths(\n        offlineEvents: AddonCalendarOfflineEventDBRecord[],\n    ): { [monthId: string]: { [day: number]: AddonCalendarEventToDisplay[] } } {\n        // Format data.\n        const events: AddonCalendarEventToDisplay[] = offlineEvents.map((event) =>\n            AddonCalendarHelper.formatOfflineEventData(event));\n\n        const result = {};\n\n        events.forEach((event) => {\n            const treatedDay = moment(event.timestart * 1000);\n            const endDay = moment((event.timestart + event.timeduration) * 1000);\n\n            // Add the event to all the days it lasts.\n            while (!treatedDay.isAfter(endDay, 'day')) {\n                const monthId = this.getMonthId(treatedDay);\n                const day = treatedDay.date();\n\n                if (!result[monthId]) {\n                    result[monthId] = {};\n                }\n                if (!result[monthId][day]) {\n                    result[monthId][day] = [];\n                }\n                result[monthId][day].push(event);\n\n                treatedDay.add(1, 'day'); // Treat next day.\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Convenience function to format some event data to be rendered.\n     *\n     * @param event Event to format.\n     * @returns The formatted event to display.\n     */\n    async formatEventData(\n        event: AddonCalendarEvent | AddonCalendarEventBase | AddonCalendarGetEventsEvent,\n    ): Promise<AddonCalendarEventToDisplay> {\n\n        const eventFormatted: AddonCalendarEventToDisplay = {\n            ...event,\n            location: 'location' in event ? event.location : undefined,\n            eventcount: 'eventcount' in event ? event.eventcount || 0 : 0,\n            repeatid: event.repeatid || 0,\n            eventIcon: this.getEventIcon(event.eventtype),\n            formattedType: AddonCalendar.getEventType(event),\n            format: 1,\n            visible: 1,\n            offline: false,\n            purpose: 'purpose' in event ? event.purpose : undefined,\n        };\n\n        if (event.modulename) {\n            eventFormatted.eventIcon = await CoreCourseModuleDelegate.getModuleIconSrc(\n                event.modulename,\n                'icon' in event ? event.icon.iconurl : undefined,\n            );\n            eventFormatted.moduleIcon = eventFormatted.eventIcon;\n            eventFormatted.iconTitle = CoreCourse.translateModuleName(event.modulename);\n        }\n\n        eventFormatted.formattedType = AddonCalendar.getEventType(event);\n\n        // Calculate context.\n        if ('course' in event) {\n            eventFormatted.courseid = event.course?.id;\n        } else if ('courseid' in event) {\n            eventFormatted.courseid = event.courseid;\n        }\n\n        // Calculate context.\n        if ('category' in event) {\n            eventFormatted.categoryid = event.category?.id;\n        } else if ('categoryid' in event) {\n            eventFormatted.categoryid = event.categoryid;\n        }\n\n        if ('canedit' in event) {\n            eventFormatted.canedit = event.canedit;\n        }\n\n        if ('candelete' in event) {\n            eventFormatted.candelete = event.candelete;\n        }\n\n        this.formatEventContext(eventFormatted, eventFormatted.courseid, eventFormatted.categoryid);\n\n        return eventFormatted;\n    }\n\n    /**\n     * Convenience function to format some event data to be rendered.\n     *\n     * @param event Event to format.\n     * @returns The formatted offline event to display.\n     */\n    formatOfflineEventData(event: AddonCalendarOfflineEventDBRecord): AddonCalendarEventToDisplay {\n\n        const eventFormatted: AddonCalendarEventToDisplay = {\n            id: event.id,\n            name: event.name,\n            timestart: event.timestart,\n            eventtype: event.eventtype,\n            categoryid: event.categoryid,\n            courseid: event.courseid || event.groupcourseid,\n            groupid: event.groupid,\n            description: event.description,\n            location: event.location,\n            duration: event.duration,\n            timedurationuntil: event.timedurationuntil,\n            timedurationminutes: event.timedurationminutes,\n            // repeat: event.repeat,\n            eventcount: event.repeats || 0,\n            repeatid: event.repeatid || 0,\n            // repeateditall: event.repeateditall,\n            userid: event.userid,\n            timemodified: event.timecreated || 0,\n            eventIcon: this.getEventIcon(event.eventtype),\n            formattedType: event.eventtype,\n            format: 1,\n            visible: 1,\n            offline: true,\n            canedit: event.id < 0,\n            candelete: event.id < 0,\n            timeduration: 0,\n        };\n\n        // Calculate context.\n        const categoryId = event.categoryid;\n        const courseId = event.courseid || event.groupcourseid;\n        this.formatEventContext(eventFormatted, courseId, categoryId);\n\n        if (eventFormatted.duration == 1) {\n            eventFormatted.timeduration = (event.timedurationuntil || 0) - event.timestart;\n        } else if (eventFormatted.duration == 2) {\n            eventFormatted.timeduration = (event.timedurationminutes || 0) * CoreConstants.SECONDS_MINUTE;\n        } else {\n            eventFormatted.timeduration = 0;\n        }\n\n        return eventFormatted;\n    }\n\n    /**\n     * Modifies event data with the context information.\n     *\n     * @param eventFormatted Event formatted to be displayed.\n     * @param courseId Course Id if any.\n     * @param categoryId Category Id if any.\n     */\n    protected formatEventContext(eventFormatted: AddonCalendarEventToDisplay, courseId?: number, categoryId?: number): void {\n        if (categoryId && categoryId > 0) {\n            eventFormatted.contextLevel = ContextLevel.COURSECAT;\n            eventFormatted.contextInstanceId = categoryId;\n        } else if (courseId && courseId > 0) {\n            eventFormatted.contextLevel = ContextLevel.COURSE;\n            eventFormatted.contextInstanceId = courseId;\n        } else {\n            eventFormatted.contextLevel = ContextLevel.USER;\n            eventFormatted.contextInstanceId = eventFormatted.userid;\n        }\n    }\n\n    /**\n     * Format reminders, adding calculated data.\n     *\n     * @param reminders Reminders.\n     * @param timestart Event timestart.\n     * @param siteId Site ID.\n     * @returns Formatted reminders.\n     * @deprecated since 4.1 Use AddonCalendarHelper.getEventReminders.\n     */\n    async formatReminders(\n        reminders: { eventid: number }[],\n        timestart: number,\n        siteId?: string,\n    ): Promise<AddonCalendarEventReminder[]> {\n        if (!reminders.length) {\n            return [];\n        }\n\n        return AddonCalendarHelper.getEventReminders(reminders[0].eventid, timestart, siteId);\n    }\n\n    /**\n     * Format reminders, adding calculated data.\n     *\n     * @param eventId Event Id.\n     * @param eventTimestart Event timestart.\n     * @param siteId Site ID.\n     * @returns Formatted reminders.\n     */\n    async getEventReminders(\n        eventId: number,\n        eventTimestart: number,\n        siteId?: string,\n    ): Promise<AddonCalendarEventReminder[]> {\n        const reminders = await CoreReminders.getReminders(\n            {\n                instanceId: eventId,\n                component: AddonCalendarProvider.COMPONENT,\n            },\n            siteId,\n        );\n\n        if (!reminders.length) {\n            return [];\n        }\n\n        const defaultTime = await CoreReminders.getDefaultNotificationTime(siteId);\n        let defaultLabel: string | undefined;\n\n        if (defaultTime > CoreRemindersService.DISABLED) {\n            const data = CoreRemindersService.convertSecondsToValueAndUnit(defaultTime);\n            defaultLabel = CoreReminders.getUnitValueLabel(data.value, data.unit, true);\n        }\n\n        return reminders.map((reminder) => {\n            const formatted: AddonCalendarEventReminder = {\n                id: reminder.id,\n            };\n\n            if (reminder.timebefore === CoreRemindersService.DEFAULT_REMINDER_TIMEBEFORE) {\n                // Default time. Check if default notifications are disabled.\n                if (defaultLabel !== undefined) {\n                    formatted.label = defaultLabel;\n                    formatted.timestamp = eventTimestart - defaultTime;\n                }\n            } else {\n                const data = CoreRemindersService.convertSecondsToValueAndUnit(reminder.timebefore);\n                formatted.label = CoreReminders.getUnitValueLabel(data.value, data.unit, false);\n                formatted.timestamp = eventTimestart - reminder.timebefore;\n            }\n\n            if (formatted.timestamp) {\n                formatted.sublabel = CoreTimeUtils.userDate(formatted.timestamp * 1000, 'core.strftimedatetime');\n            }\n\n            return formatted;\n        });\n    }\n\n    /**\n     * Get options (name & value) for each allowed event type.\n     *\n     * @param eventTypes Result of getAllowedEventTypes.\n     * @returns Options.\n     */\n    getEventTypeOptions(eventTypes: {[name: string]: boolean}): AddonCalendarEventTypeOption[] {\n        const options: AddonCalendarEventTypeOption[] = [];\n\n        if (eventTypes.user) {\n            options.push({ name: 'core.user', value: AddonCalendarEventType.USER });\n        }\n        if (eventTypes.group) {\n            options.push({ name: 'core.group', value: AddonCalendarEventType.GROUP });\n        }\n        if (eventTypes.course) {\n            options.push({ name: 'core.course', value: AddonCalendarEventType.COURSE });\n        }\n        if (eventTypes.category) {\n            options.push({ name: 'core.category', value: AddonCalendarEventType.CATEGORY });\n        }\n        if (eventTypes.site) {\n            options.push({ name: 'core.site', value: AddonCalendarEventType.SITE });\n        }\n\n        return options;\n    }\n\n    /**\n     * Get the month \"id\".\n     *\n     * @param moment Month moment.\n     * @returns The \"id\".\n     */\n    getMonthId(moment: moment.Moment): string {\n        return `${moment.year()}#${moment.month() + 1}`;\n    }\n\n    /**\n     * Get the day \"id\".\n     *\n     * @param moment Day moment.\n     * @returns The \"id\".\n     */\n    getDayId(moment: moment.Moment): string {\n        return `${this.getMonthId(moment)}#${moment.date()}`;\n    }\n\n    /**\n     * Get weeks of a month in offline (with no events).\n     *\n     * The result has the same structure than getMonthlyEvents, but it only contains fields that are actually used by the app.\n     *\n     * @param year Year to get.\n     * @param month Month to get.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the response.\n     */\n    async getOfflineMonthWeeks(\n        year: number,\n        month: number,\n        siteId?: string,\n    ): Promise<{ daynames: Partial<AddonCalendarDayName>[]; weeks: AddonCalendarWeek[] }> {\n        const site = await CoreSites.getSite(siteId);\n        // Get starting week day user preference, fallback to site configuration.\n        let startWeekDayStr = site.getStoredConfig('calendar_startwday') || '1';\n        startWeekDayStr = await CoreConfig.get(AddonCalendarProvider.STARTING_WEEK_DAY, startWeekDayStr);\n        const startWeekDay = parseInt(startWeekDayStr, 10);\n\n        const today = moment();\n        const isCurrentMonth = today.year() == year && today.month() == month - 1;\n        const weeks: AddonCalendarWeek[] = [];\n\n        let date = moment({ year, month: month - 1, date: 1 });\n        for (let mday = 1; mday <= date.daysInMonth(); mday++) {\n            date = moment({ year, month: month - 1, date: mday });\n\n            // Add new week and calculate prepadding.\n            if (!weeks.length || date.day() == startWeekDay) {\n                const prepaddingLength = (date.day() - startWeekDay + 7) % 7;\n                const prepadding: number[] = [];\n                for (let i = 0; i < prepaddingLength; i++) {\n                    prepadding.push(i);\n                }\n                weeks.push({ prepadding, postpadding: [], days: [] });\n            }\n\n            // Calculate postpadding of last week.\n            if (mday == date.daysInMonth()) {\n                const postpaddingLength = (startWeekDay - date.day() + 6) % 7;\n                const postpadding: number[] = [];\n                for (let i = 0; i < postpaddingLength; i++) {\n                    postpadding.push(i);\n                }\n                weeks[weeks.length - 1].postpadding = postpadding;\n            }\n\n            // Add day to current week.\n            weeks[weeks.length - 1].days.push({\n                events: [],\n                hasevents: false,\n                mday: date.date(),\n                isweekend: date.day() == 0 || date.day() == 6,\n                istoday: isCurrentMonth && today.date() == date.date(),\n                calendareventtypes: [],\n                // Added to match the type. And possibly unused.\n                popovertitle: '',\n                ispast: today.date() > date.date(),\n                seconds: date.seconds(),\n                minutes: date.minutes(),\n                hours: date.hours(),\n                wday: date.weekday(),\n                year: year,\n                yday: date.dayOfYear(),\n                timestamp: date.date(),\n                haslastdayofevent: false,\n                neweventtimestamp: 0,\n                previousperiod: 0, // Previousperiod.\n                nextperiod: 0, // Nextperiod.\n                navigation: '', // Navigation.\n            });\n        }\n\n        return { weeks, daynames: [{ dayno: startWeekDay }] };\n    }\n\n    /**\n     * Check if the data of an event has changed.\n     *\n     * @param data Current data.\n     * @param original Original data.\n     * @returns True if data has changed, false otherwise.\n     */\n    hasEventDataChanged(data: AddonCalendarOfflineEventDBRecord, original?: AddonCalendarOfflineEventDBRecord): boolean {\n        if (!original) {\n            // There is no original data, assume it hasn't changed.\n            return false;\n        }\n\n        // Check the fields that don't depend on any other.\n        if (data.name != original.name || data.timestart != original.timestart || data.eventtype != original.eventtype ||\n                data.description != original.description || data.location != original.location ||\n                data.duration != original.duration || data.repeat != original.repeat) {\n            return true;\n        }\n\n        // Check data that depends on eventtype.\n        if ((data.eventtype == AddonCalendarEventType.CATEGORY && data.categoryid != original.categoryid) ||\n                (data.eventtype == AddonCalendarEventType.COURSE && data.courseid != original.courseid) ||\n                (data.eventtype == AddonCalendarEventType.GROUP && data.groupcourseid != original.groupcourseid &&\n                    data.groupid != original.groupid)) {\n            return true;\n        }\n\n        // Check data that depends on duration.\n        if ((data.duration == 1 && data.timedurationuntil != original.timedurationuntil) ||\n                (data.duration == 2 && data.timedurationminutes != original.timedurationminutes)) {\n            return true;\n        }\n\n        if (data.repeat && data.repeats != original.repeats) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Filter events to be shown on the events list.\n     *\n     * @param events Events without filtering.\n     * @param filter Filter from popover.\n     * @param categories Categories indexed by ID.\n     * @returns Filtered events.\n     */\n    getFilteredEvents(\n        events: AddonCalendarEventToDisplay[],\n        filter: AddonCalendarFilter | undefined,\n        categories: { [id: number]: CoreCategoryData },\n    ): AddonCalendarEventToDisplay[] {\n        // Do not filter.\n        if (!filter || !filter.filtered) {\n            return events;\n        }\n\n        const courseId = filter.courseId ? Number(filter.courseId) : undefined;\n\n        if (!courseId || courseId < 0) {\n            // Filter only by type.\n            return events.filter((event) => filter[event.formattedType]);\n        }\n\n        const categoryId = filter.categoryId ? Number(filter.categoryId) : undefined;\n\n        return events.filter((event) => filter[event.formattedType] &&\n                this.shouldDisplayEvent(event, categories, courseId, categoryId));\n    }\n\n    /**\n     * Check if an event should be displayed based on the filter.\n     *\n     * @param event Event object.\n     * @param categories Categories indexed by ID.\n     * @param courseId Course ID to filter.\n     * @param categoryId Category ID the course belongs to.\n     * @returns Whether it should be displayed.\n     */\n    protected shouldDisplayEvent(\n        event: AddonCalendarEventToDisplay,\n        categories: { [id: number]: CoreCategoryData },\n        courseId: number,\n        categoryId?: number,\n    ): boolean {\n        if (event.eventtype === 'user' || event.eventtype === 'site') {\n            // User or site event, display it.\n            return true;\n        }\n\n        if (event.eventtype === 'category' && categories) {\n            if (!event.categoryid || !Object.keys(categories).length || !categoryId) {\n                // We can't tell if the course belongs to the category, display them all.\n                return true;\n            }\n\n            if (event.categoryid === categoryId) {\n                // The event is in the same category as the course, display it.\n                return true;\n            }\n\n            // Check parent categories.\n            let category = categories[categoryId];\n            while (category) {\n                if (!category.parent) {\n                    // Category doesn't have parent, stop.\n                    break;\n                }\n\n                if (event.categoryid === category.parent) {\n                    return true;\n                }\n                category = categories[category.parent];\n            }\n\n            return false;\n        }\n\n        const eventCourse = (event.course && event.course.id) || event.courseid;\n\n        // Show the event if it is from site home or if it matches the selected course.\n        return !eventCourse || (eventCourse === CoreSites.getCurrentSiteHomeId() || eventCourse === courseId);\n    }\n\n    /**\n     * Refresh the month & day for several created/edited/deleted events, and invalidate the months & days\n     * for their repeated events if needed.\n     *\n     * @param events Events that have been touched and number of times each event is repeated.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    async refreshAfterChangeEvents(events: AddonCalendarSyncInvalidateEvent[], siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n        const fetchTimestarts: number[] = [];\n        const invalidateTimestarts: number[] = [];\n        let promises: Promise<unknown>[] = [];\n\n        // Always fetch upcoming events.\n        promises.push(AddonCalendar.getUpcomingEvents(undefined, undefined, true, site.id));\n\n        promises = promises.concat(events.map(async (eventData) => {\n\n            if (eventData.repeated <= 1) {\n                // Not repeated.\n                fetchTimestarts.push(eventData.timestart);\n\n                return AddonCalendar.invalidateEvent(eventData.id);\n            }\n\n            if (eventData.repeatid) {\n                // Being edited or deleted.\n                // We need to calculate the days to invalidate because the event date could have changed.\n                // We don't know if the repeated events are before or after this one, invalidate them all.\n                fetchTimestarts.push(eventData.timestart);\n\n                for (let i = 1; i < eventData.repeated; i++) {\n                    invalidateTimestarts.push(eventData.timestart + CoreConstants.SECONDS_DAY * 7 * i);\n                    invalidateTimestarts.push(eventData.timestart - CoreConstants.SECONDS_DAY * 7 * i);\n                }\n\n                // Get the repeated events to invalidate them.\n                const repeatedEvents =\n                    await AddonCalendar.getLocalEventsByRepeatIdFromLocalDb(eventData.repeatid, site.id);\n\n                await CoreUtils.allPromises(repeatedEvents.map((event) =>\n                    AddonCalendar.invalidateEvent(event.id)));\n\n                return;\n            }\n\n            // Being added.\n            let time = eventData.timestart;\n            fetchTimestarts.push(time);\n\n            while (eventData.repeated > 1) {\n                time += CoreConstants.SECONDS_DAY * 7;\n                eventData.repeated--;\n                invalidateTimestarts.push(time);\n            }\n\n            return;\n\n        }));\n\n        try {\n            await CoreUtils.allPromisesIgnoringErrors(promises);\n        } finally {\n            const treatedMonths = {};\n            const treatedDays = {};\n            const finalPromises: Promise<unknown>[] =[AddonCalendar.invalidateAllUpcomingEvents()];\n\n            // Fetch months and days.\n            fetchTimestarts.forEach((fetchTime) => {\n                const day = moment(fetchTime * 1000);\n\n                const monthId = this.getMonthId(day);\n                if (!treatedMonths[monthId]) {\n                    // Month not refetch or invalidated already, do it now.\n                    treatedMonths[monthId] = true;\n\n                    finalPromises.push(AddonCalendar.getMonthlyEvents(\n                        day.year(),\n                        day.month() + 1,\n                        undefined,\n                        undefined,\n                        true,\n                        site.id,\n                    ));\n                }\n\n                const dayId = monthId + '#' + day.date();\n                if (!treatedDays[dayId]) {\n                    // Dat not refetch or invalidated already, do it now.\n                    treatedDays[dayId] = true;\n\n                    finalPromises.push(AddonCalendar.getDayEvents(\n                        day.year(),\n                        day.month() + 1,\n                        day.date(),\n                        undefined,\n                        undefined,\n                        true,\n                        site.id,\n                    ));\n                }\n            });\n\n            // Invalidate months and days.\n            invalidateTimestarts.forEach((fetchTime) => {\n                const day = moment(fetchTime * 1000);\n\n                const monthId = this.getMonthId(day);\n                if (!treatedMonths[monthId]) {\n                    // Month not refetch or invalidated already, do it now.\n                    treatedMonths[monthId] = true;\n\n                    finalPromises.push(AddonCalendar.invalidateMonthlyEvents(day.year(), day.month() + 1, site.id));\n                }\n\n                const dayId = monthId + '#' + day.date();\n                if (!treatedDays[dayId]) {\n                    // Dat not refetch or invalidated already, do it now.\n                    treatedDays[dayId] = true;\n\n                    finalPromises.push(AddonCalendar.invalidateDayEvents(\n                        day.year(),\n                        day.month() + 1,\n                        day.date(),\n                        site.id,\n                    ));\n                }\n            });\n\n            await CoreUtils.allPromisesIgnoringErrors(finalPromises);\n        }\n    }\n\n    /**\n     * Refresh the month & day for a created/edited/deleted event, and invalidate the months & days\n     * for their repeated events if needed.\n     *\n     * @param event Event that has been touched.\n     * @param repeated Number of times the event is repeated.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Resolved when done.\n     */\n    refreshAfterChangeEvent(\n        event: {\n            id: number;\n            repeatid?: number;\n            timestart: number;\n        },\n        repeated: number,\n        siteId?: string,\n    ): Promise<void> {\n        return this.refreshAfterChangeEvents(\n            [{\n                id: event.id,\n                repeatid: event.repeatid,\n                timestart: event.timestart,\n                repeated: repeated,\n            }],\n            siteId,\n        );\n    }\n\n    /**\n     * Sort events by timestart.\n     *\n     * @param events List to sort.\n     * @returns Events sorted.\n     */\n    sortEvents(events: (AddonCalendarEventToDisplay)[]): (AddonCalendarEventToDisplay)[] {\n        return events.sort((a, b) => {\n            if (a.timestart == b.timestart) {\n                return a.timeduration - b.timeduration;\n            }\n\n            return a.timestart - b.timestart;\n        });\n    }\n\n}\n\nexport const AddonCalendarHelper = makeSingleton(AddonCalendarHelperProvider);\n\n/**\n * Calculated data for Calendar filtering.\n */\nexport type AddonCalendarFilter = {\n    filtered: boolean; // If filter enabled (some filters applied).\n    courseId: number | undefined; // Course Id to filter.\n    categoryId?: number; // Category Id to filter.\n    course: boolean; // Filter to show course events.\n    group: boolean; // Filter to show group events.\n    site: boolean; // Filter to show show site events.\n    user: boolean; // Filter to show user events.\n    category: boolean; // Filter to show category events.\n};\n\nexport type AddonCalendarEventTypeOption = {\n    name: string;\n    value: AddonCalendarEventType;\n};\n\n/**\n * Formatted event reminder.\n */\nexport type AddonCalendarEventReminder = {\n    id: number;\n    timestamp?: number; // Timestamp (in seconds).\n    label?: string; // Label to represent the reminder.\n    sublabel?: string; // Sub label.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}