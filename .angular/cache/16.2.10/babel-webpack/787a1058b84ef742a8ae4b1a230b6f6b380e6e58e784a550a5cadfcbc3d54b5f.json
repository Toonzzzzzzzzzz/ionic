{"ast":null,"code":"import _objectSpread from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { NavigationEnd } from '@angular/router';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreMainMenu } from '@features/mainmenu/services/mainmenu';\nimport { CoreObject } from '@singletons/object';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton, NavController, Router } from '@singletons';\nimport { CoreScreen } from './screen';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreMainMenuDelegate } from '@features/mainmenu/services/mainmenu-delegate';\nimport { CorePlatform } from '@services/platform';\nimport { filter } from 'rxjs/operators';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport * as i0 from \"@angular/core\";\n/**\n * Service to provide some helper functions regarding navigation.\n */\nexport class CoreNavigatorService {\n  constructor() {\n    this.routesDepth = {};\n    this.storedParams = {};\n    this.lastParamId = 0;\n  }\n  /**\n   * Check whether the active route is using the given path.\n   *\n   * @param path Path, can be a glob pattern.\n   * @returns Whether the active route is using the given path.\n   */\n  isCurrent(path) {\n    return CoreTextUtils.matchesGlob(this.getCurrentPath(), path);\n  }\n  /**\n   * Get current main menu tab.\n   *\n   * @returns Current main menu tab or null if the current route is not using the main menu.\n   */\n  getCurrentMainMenuTab() {\n    return this.getMainMenuTabFromPath(this.getCurrentPath());\n  }\n  /**\n   * Get main menu tab from a path.\n   *\n   * @param path The path to check.\n   * @returns Path's main menu tab or null if the path is not using the main menu.\n   */\n  getMainMenuTabFromPath(path) {\n    var _matches$;\n    const matches = /^\\/main\\/([^/]+).*$/.exec(path);\n    return (_matches$ = matches === null || matches === void 0 ? void 0 : matches[1]) !== null && _matches$ !== void 0 ? _matches$ : null;\n  }\n  /**\n   * Returns if a section is loaded on the split view (tablet mode).\n   *\n   * @param path Path, can be a glob pattern.\n   * @returns Whether the active route is using the given path.\n   */\n  isCurrentPathInTablet(path) {\n    if (CoreScreen.isMobile) {\n      // Split view is off.\n      return false;\n    }\n    return this.isCurrent(path);\n  }\n  /**\n   * Navigate to a new path.\n   *\n   * @param path Path to navigate to.\n   * @param options Navigation options.\n   * @returns Whether navigation suceeded.\n   */\n  navigate(path, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _options$params, _options$params2, _options$reset, _options$nextNavigati;\n      const url = [/^[./]/.test(path) ? path : `./${path}`];\n      const navigationOptions = CoreObject.withoutEmpty({\n        animated: options.animated,\n        animation: options.animation,\n        animationDirection: options.animationDirection,\n        queryParams: CoreObject.isEmpty((_options$params = options.params) !== null && _options$params !== void 0 ? _options$params : {}) ? null : CoreObject.withoutEmpty((_options$params2 = options.params) !== null && _options$params2 !== void 0 ? _options$params2 : {}),\n        relativeTo: path.startsWith('/') ? null : _this.getCurrentRoute(),\n        replaceUrl: options.replace\n      });\n      // Remove objects from queryParams and replace them with an ID.\n      _this.replaceObjectParams(navigationOptions.queryParams);\n      const navigationResult = ((_options$reset = options.reset) !== null && _options$reset !== void 0 ? _options$reset : false) ? yield NavController.navigateRoot(url, navigationOptions) : yield NavController.navigateForward(url, navigationOptions);\n      if ((_options$nextNavigati = options.nextNavigation) !== null && _options$nextNavigati !== void 0 && _options$nextNavigati.path && navigationResult !== false) {\n        if (options.nextNavigation.isSitePath) {\n          return _this.navigateToSitePath(options.nextNavigation.path, options.nextNavigation.options);\n        }\n        return _this.navigate(options.nextNavigation.path, options.nextNavigation.options);\n      }\n      return navigationResult !== false;\n    })();\n  }\n  /**\n   * Navigate to the login credentials route.\n   *\n   * @param params Page params.\n   * @returns Whether navigation suceeded.\n   */\n  navigateToLoginCredentials(params = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // If necessary, open the previous path to keep the navigation history.\n      if (!_this2.isCurrent('/login/site') && !_this2.isCurrent('/login/sites')) {\n        const hasSites = yield CoreSites.hasSites();\n        yield _this2.navigate(hasSites ? '/login/sites' : '/login/site', {\n          reset: true\n        });\n      }\n      // Navigate to login credentials page.\n      return _this2.navigate('/login/credentials', {\n        params\n      });\n    })();\n  }\n  /**\n   * Navigate to the home route of the current site.\n   *\n   * @param options Navigation options.\n   * @returns Whether navigation suceeded.\n   */\n  navigateToSiteHome(options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _options$siteId;\n      const siteId = (_options$siteId = options.siteId) !== null && _options$siteId !== void 0 ? _options$siteId : CoreSites.getCurrentSiteId();\n      const landingPagePath = CoreSites.isLoggedIn() && CoreSites.getCurrentSiteId() === siteId ? _this3.getLandingTabPage() : 'main';\n      return _this3.navigateToSitePath(landingPagePath, _objectSpread(_objectSpread({}, options), {}, {\n        reset: true,\n        preferCurrentTab: false\n      }));\n    })();\n  }\n  /**\n   * Navigate to a site path, loading the site if necessary.\n   *\n   * @param path Site path to visit.\n   * @param options Navigation and site options.\n   * @returns Whether navigation suceeded.\n   */\n  navigateToSitePath(path, options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _options$siteId2;\n      const siteId = (_options$siteId2 = options.siteId) !== null && _options$siteId2 !== void 0 ? _options$siteId2 : CoreSites.getCurrentSiteId();\n      const navigationOptions = CoreObject.without(options, ['siteId']);\n      // If we are logged into a different site, log out first.\n      if (CoreSites.isLoggedIn() && CoreSites.getCurrentSiteId() !== siteId) {\n        const willReload = yield CoreSites.logoutForRedirect(siteId, {\n          redirectPath: path,\n          redirectOptions: options || {}\n        });\n        if (willReload) {\n          return true;\n        }\n      }\n      // If the path doesn't belong to a site, call standard navigation.\n      if (siteId === CoreConstants.NO_SITE_ID) {\n        return _this4.navigate(path, _objectSpread(_objectSpread({}, navigationOptions), {}, {\n          reset: true\n        }));\n      }\n      // If we are not logged into the site, load the site.\n      if (!CoreSites.isLoggedIn()) {\n        const modal = yield CoreDomUtils.showModalLoading();\n        try {\n          const loggedIn = yield CoreSites.loadSite(siteId, {\n            redirectPath: path,\n            redirectOptions: options\n          });\n          if (!loggedIn) {\n            // User has been redirected to the login page and will be redirected to the site path after login.\n            return true;\n          }\n        } catch (error) {\n          // Site doesn't exist.\n          return _this4.navigate('/login/sites', {\n            reset: true\n          });\n        } finally {\n          modal.dismiss();\n        }\n      }\n      // User is logged in, navigate to the site path.\n      return _this4.navigateToMainMenuPath(path, navigationOptions);\n    })();\n  }\n  /**\n   * Get the active route path.\n   *\n   * @returns Current path.\n   */\n  getCurrentPath() {\n    return CoreUrlUtils.removeUrlParams(Router.url);\n  }\n  /**\n   * Iterately get the params checking parent routes.\n   *\n   * @param name Name of the parameter.\n   * @param route Current route.\n   * @returns Value of the parameter, undefined if not found.\n   */\n  getRouteSnapshotParam(name, route) {\n    if (!route) {\n      return;\n    }\n    if (route.snapshot) {\n      var _route$snapshot$query;\n      const value = (_route$snapshot$query = route.snapshot.queryParams[name]) !== null && _route$snapshot$query !== void 0 ? _route$snapshot$query : route.snapshot.params[name];\n      if (value !== undefined) {\n        return value;\n      }\n    }\n    return this.getRouteSnapshotParam(name, route.parent || undefined);\n  }\n  /**\n   * Get a parameter for the current route.\n   * Please notice that objects can only be retrieved once. You must call this function only once per page and parameter,\n   * unless there's a new navigation to the page.\n   *\n   * @param name Name of the parameter.\n   * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n   * @returns Value of the parameter, undefined if not found.\n   */\n  getRouteParam(name, routeOptions = {}) {\n    var _storedParam;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let value;\n    if (!routeOptions.params) {\n      var _route;\n      let route = this.getCurrentRoute();\n      if (!((_route = route) !== null && _route !== void 0 && _route.snapshot) && routeOptions.route) {\n        route = routeOptions.route;\n      }\n      value = this.getRouteSnapshotParam(name, route);\n    } else {\n      value = routeOptions.params[name];\n    }\n    if (value === undefined) {\n      return;\n    }\n    let storedParam = this.storedParams[value];\n    // Remove the parameter from our map if it's in there.\n    delete this.storedParams[value];\n    if (!CorePlatform.isMobile() && !storedParam) {\n      // Try to retrieve the param from local storage in browser.\n      const storageParam = localStorage.getItem(value);\n      if (storageParam) {\n        storedParam = CoreTextUtils.parseJSON(storageParam);\n      }\n    }\n    return (_storedParam = storedParam) !== null && _storedParam !== void 0 ? _storedParam : value;\n  }\n  /**\n   * Get a number route param.\n   * Angular router automatically converts numbers to string, this function automatically converts it back to number.\n   *\n   * @param name Name of the parameter.\n   * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n   * @returns Value of the parameter, undefined if not found.\n   */\n  getRouteNumberParam(name, routeOptions = {}) {\n    const value = this.getRouteParam(name, routeOptions);\n    return value !== undefined ? Number(value) : value;\n  }\n  /**\n   * Get a boolean route param.\n   * Angular router automatically converts booleans to string, this function automatically converts it back to boolean.\n   *\n   * @param name Name of the parameter.\n   * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n   * @returns Value of the parameter, undefined if not found.\n   */\n  getRouteBooleanParam(name, routeOptions = {}) {\n    const value = this.getRouteParam(name, routeOptions);\n    if (value === undefined) {\n      return value;\n    }\n    if (CoreUtils.isTrueOrOne(value)) {\n      return true;\n    }\n    if (CoreUtils.isFalseOrZero(value)) {\n      return false;\n    }\n    return Boolean(value);\n  }\n  /**\n   * Get a parameter for the current route.\n   * Please notice that objects can only be retrieved once. You must call this function only once per page and parameter,\n   * unless there's a new navigation to the page.\n   *\n   * This function will fail if parameter is not found.\n   *\n   * @param name Name of the parameter.\n   * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n   * @returns Value of the parameter, undefined if not found.\n   */\n  getRequiredRouteParam(name, routeOptions = {}) {\n    const value = this.getRouteParam(name, routeOptions);\n    if (value === undefined) {\n      throw new CoreError(`Required param '${name}' not found.`);\n    }\n    return value;\n  }\n  /**\n   * Get a number route param.\n   * Angular router automatically converts numbers to string, this function automatically converts it back to number.\n   *\n   * This function will fail if parameter is not found.\n   *\n   * @param name Name of the parameter.\n   * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n   * @returns Value of the parameter, undefined if not found.\n   */\n  getRequiredRouteNumberParam(name, routeOptions = {}) {\n    const value = this.getRouteNumberParam(name, routeOptions);\n    if (value === undefined) {\n      throw new CoreError(`Required number param '${name}' not found.`);\n    }\n    return value;\n  }\n  /**\n   * Get a boolean route param.\n   * Angular router automatically converts booleans to string, this function automatically converts it back to boolean.\n   *\n   * This function will fail if parameter is not found.\n   *\n   * @param name Name of the parameter.\n   * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n   * @returns Value of the parameter, undefined if not found.\n   */\n  getRequiredRouteBooleanParam(name, routeOptions = {}) {\n    const value = this.getRouteBooleanParam(name, routeOptions);\n    if (value === undefined) {\n      throw new CoreError(`Required boolean param '${name}' not found.`);\n    }\n    return value;\n  }\n  /**\n   * Navigate back.\n   *\n   * @returns Promise resolved when done.\n   */\n  back() {\n    return _asyncToGenerator(function* () {\n      yield NavController.pop();\n    })();\n  }\n  getCurrentRoute({\n    route,\n    pageComponent,\n    routeData\n  } = {}) {\n    var _route2;\n    route = (_route2 = route) !== null && _route2 !== void 0 ? _route2 : Router.routerState.root;\n    if (pageComponent && route.component === pageComponent) {\n      return route;\n    }\n    if (routeData && CoreUtils.basicLeftCompare(routeData, route.snapshot.data, 3)) {\n      return route;\n    }\n    if (route.firstChild) {\n      return this.getCurrentRoute({\n        route: route.firstChild,\n        pageComponent,\n        routeData\n      });\n    }\n    return pageComponent || routeData ? null : route;\n  }\n  /**\n   * Check whether a route is active within the current stack.\n   *\n   * @param route Route to check.\n   * @returns Whether the route is active or not.\n   */\n  isRouteActive(route) {\n    const routePath = this.getRouteFullPath(route.snapshot);\n    let activeRoute = Router.routerState.root;\n    while (activeRoute) {\n      if (this.getRouteFullPath(activeRoute.snapshot) === routePath) {\n        return true;\n      }\n      activeRoute = activeRoute.firstChild;\n    }\n    return false;\n  }\n  /**\n   * Increase the number of times a route is repeated on the navigation stack.\n   *\n   * @param path Absolute route path.\n   */\n  increaseRouteDepth(path) {\n    this.routesDepth[path] = this.getRouteDepth(path) + 1;\n  }\n  /**\n   * Decrease the number of times a route is repeated on the navigation stack.\n   *\n   * @param path Absolute route path.\n   */\n  decreaseRouteDepth(path) {\n    if (this.getRouteDepth(path) <= 1) {\n      delete this.routesDepth[path];\n    } else {\n      this.routesDepth[path]--;\n    }\n  }\n  /**\n   * Get the number of times a route is repeated on the navigation stack.\n   *\n   * @param path Absolute route path.\n   * @returns Route depth.\n   */\n  getRouteDepth(path) {\n    var _this$routesDepth$pat;\n    return (_this$routesDepth$pat = this.routesDepth[path]) !== null && _this$routesDepth$pat !== void 0 ? _this$routesDepth$pat : 0;\n  }\n  /**\n   * Navigate to a path within the main menu.\n   * If the path belongs to a visible tab, that tab will be selected.\n   * If it doesn't, the current tab or the default tab will be used instead.\n   *\n   * @param path Main menu path.\n   * @param options Navigation options.\n   * @returns Whether navigation suceeded.\n   */\n  navigateToMainMenuPath(path, options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var _exec$, _exec;\n      options = _objectSpread({\n        preferCurrentTab: true\n      }, options);\n      path = path.replace(/^(\\.|\\/main)?\\//, '');\n      const pathRoot = (_exec$ = (_exec = /^[^/]+/.exec(path)) === null || _exec === void 0 ? void 0 : _exec[0]) !== null && _exec$ !== void 0 ? _exec$ : '';\n      if (!pathRoot) {\n        // No path root, going to the site home.\n        return _this5.navigate('/main', options);\n      }\n      const currentMainMenuTab = _this5.getCurrentMainMenuTab();\n      const isMainMenuTab = pathRoot === currentMainMenuTab || !currentMainMenuTab && path === _this5.getLandingTabPage() || (yield CoreUtils.ignoreErrors(CoreMainMenu.isMainMenuTab(pathRoot), false));\n      if (!options.preferCurrentTab && isMainMenuTab) {\n        return _this5.navigate(`/main/${path}`, options);\n      }\n      // Open the path within the current main tab.\n      if (currentMainMenuTab && (!isMainMenuTab || pathRoot !== currentMainMenuTab)) {\n        return _this5.navigate(`/main/${currentMainMenuTab}/${path}`, options);\n      }\n      // Open the path within the corresponding main tab.\n      if (isMainMenuTab) {\n        return _this5.navigate(`/main/${path}`, options);\n      }\n      if (_this5.isCurrent('/main')) {\n        // Main menu is loaded, but no tab selected yet. Wait for a tab to be loaded.\n        yield _this5.waitForMainMenuTab();\n        return _this5.navigate(`/main/${_this5.getCurrentMainMenuTab()}/${path}`, options);\n      }\n      // Open the path within in main menu.\n      return _this5.navigate('/main', _objectSpread(_objectSpread({}, options), {}, {\n        params: {\n          redirectPath: path,\n          redirectOptions: options.params || options.nextNavigation ? options : undefined\n        }\n      }));\n    })();\n  }\n  /**\n   * Get the first page path using priority.\n   *\n   * @returns Landing page path.\n   */\n  getLandingTabPage() {\n    var _handlers$;\n    if (!CoreMainMenuDelegate.areHandlersLoaded()) {\n      // Handlers not loaded yet, landing page is the root page.\n      return '';\n    }\n    const handlers = CoreMainMenuDelegate.getHandlers().filter(handler => !handler.onlyInMore);\n    return ((_handlers$ = handlers[0]) === null || _handlers$ === void 0 ? void 0 : _handlers$.page) || '';\n  }\n  /**\n   * Replace all objects in query params with an ID that can be used to retrieve the object later.\n   *\n   * @param queryParams Params.\n   */\n  replaceObjectParams(queryParams) {\n    for (const name in queryParams) {\n      const value = queryParams[name];\n      if (typeof value != 'object' || value === null) {\n        continue;\n      }\n      const id = this.getNewParamId();\n      this.storedParams[id] = value;\n      queryParams[name] = id;\n      if (!CorePlatform.isMobile()) {\n        // In browser, save the param in local storage to be able to retrieve it if the app is refreshed.\n        localStorage.setItem(id, JSON.stringify(value));\n      }\n    }\n  }\n  /**\n   * Get an ID for a new parameter.\n   *\n   * @returns New param Id.\n   */\n  getNewParamId() {\n    return 'param-' + ++this.lastParamId;\n  }\n  /**\n   * Replace the route params in a path with the params values.\n   *\n   * @param path Path.\n   * @param params Params.\n   * @returns Path with params replaced.\n   */\n  replaceRoutePathParams(path, params) {\n    for (const name in params) {\n      path = path.replace(`:${name}`, params[name]);\n    }\n    return path;\n  }\n  /**\n   * Get the full path of a certain route, including parent routes paths.\n   *\n   * @param route Route snapshot.\n   * @returns Path.\n   */\n  getRouteFullPath(route) {\n    if (!route) {\n      return '';\n    }\n    const parentPath = this.getRouteFullPath(route.parent);\n    const routePath = route.url.join('/');\n    if (!parentPath && !routePath) {\n      return '';\n    } else if (parentPath && !routePath) {\n      return parentPath;\n    } else if (!parentPath && routePath) {\n      return '/' + routePath;\n    } else {\n      return parentPath + '/' + routePath;\n    }\n  }\n  /**\n   * Check if the current route page can block leaving the route.\n   *\n   * @returns Whether the current route page can block leaving the route.\n   */\n  currentRouteCanBlockLeave() {\n    var _this$getCurrentRoute;\n    return !!((_this$getCurrentRoute = this.getCurrentRoute().snapshot.routeConfig) !== null && _this$getCurrentRoute !== void 0 && (_this$getCurrentRoute = _this$getCurrentRoute.canDeactivate) !== null && _this$getCurrentRoute !== void 0 && _this$getCurrentRoute.length);\n  }\n  /**\n   * Wait for a main menu tab route to be loaded.\n   *\n   * @returns Promise resolved when the route is loaded.\n   */\n  waitForMainMenuTab() {\n    if (this.getCurrentMainMenuTab()) {\n      return Promise.resolve();\n    }\n    const promise = new CorePromisedValue();\n    const navSubscription = Router.events.pipe(filter(event => event instanceof NavigationEnd)).subscribe(() => {\n      if (this.getCurrentMainMenuTab()) {\n        navSubscription === null || navSubscription === void 0 || navSubscription.unsubscribe();\n        promise.resolve();\n      }\n    });\n    return promise;\n  }\n  /**\n   * Get the relative path to a parent path.\n   * E.g. if parent path is '/foo' and current path is '/foo/bar/baz' it will return '../../'.\n   *\n   * @param parentPath Parent path.\n   * @returns Relative path to the parent, empty if same path or parent path not found.\n   * @todo If messaging is refactored to use list managers, this function might not be needed anymore.\n   */\n  getRelativePathToParent(parentPath) {\n    var _path$substring$match;\n    // Add an ending slash to avoid collisions with other routes (e.g. /foo and /foobar).\n    parentPath = CoreTextUtils.addEndingSlash(parentPath);\n    const path = this.getCurrentPath();\n    const parentRouteIndex = path.indexOf(parentPath);\n    if (parentRouteIndex === -1) {\n      return '';\n    }\n    const depth = ((_path$substring$match = path.substring(parentRouteIndex + parentPath.length - 1).match(/\\//g)) !== null && _path$substring$match !== void 0 ? _path$substring$match : []).length;\n    return '../'.repeat(depth);\n  }\n}\n_class = CoreNavigatorService;\n_class.ɵfac = function CoreNavigatorService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreNavigator = makeSingleton(CoreNavigatorService);","map":{"version":3,"names":["NavigationEnd","CoreConstants","CoreDomUtils","CoreMainMenu","CoreObject","CoreSites","CoreUtils","CoreUrlUtils","CoreTextUtils","makeSingleton","NavController","Router","CoreScreen","CoreError","CoreMainMenuDelegate","CorePlatform","filter","CorePromisedValue","CoreNavigatorService","constructor","routesDepth","storedParams","lastParamId","isCurrent","path","matchesGlob","getCurrentPath","getCurrentMainMenuTab","getMainMenuTabFromPath","_matches$","matches","exec","isCurrentPathInTablet","isMobile","navigate","options","_this","_asyncToGenerator","_options$params","_options$params2","_options$reset","_options$nextNavigati","url","test","navigationOptions","withoutEmpty","animated","animation","animationDirection","queryParams","isEmpty","params","relativeTo","startsWith","getCurrentRoute","replaceUrl","replace","replaceObjectParams","navigationResult","reset","navigateRoot","navigateForward","nextNavigation","isSitePath","navigateToSitePath","navigateToLoginCredentials","_this2","hasSites","navigateToSiteHome","_this3","_options$siteId","siteId","getCurrentSiteId","landingPagePath","isLoggedIn","getLandingTabPage","_objectSpread","preferCurrentTab","_this4","_options$siteId2","without","willReload","logoutForRedirect","redirectPath","redirectOptions","NO_SITE_ID","modal","showModalLoading","loggedIn","loadSite","error","dismiss","navigateToMainMenuPath","removeUrlParams","getRouteSnapshotParam","name","route","snapshot","_route$snapshot$query","value","undefined","parent","getRouteParam","routeOptions","_storedParam","_route","storedParam","storageParam","localStorage","getItem","parseJSON","getRouteNumberParam","Number","getRouteBooleanParam","isTrueOrOne","isFalseOrZero","Boolean","getRequiredRouteParam","getRequiredRouteNumberParam","getRequiredRouteBooleanParam","back","pop","pageComponent","routeData","_route2","routerState","root","component","basicLeftCompare","data","firstChild","isRouteActive","routePath","getRouteFullPath","activeRoute","increaseRouteDepth","getRouteDepth","decreaseRouteDepth","_this$routesDepth$pat","_this5","_exec$","_exec","pathRoot","currentMainMenuTab","isMainMenuTab","ignoreErrors","waitForMainMenuTab","_handlers$","areHandlersLoaded","handlers","getHandlers","handler","onlyInMore","page","id","getNewParamId","setItem","JSON","stringify","replaceRoutePathParams","parentPath","join","currentRouteCanBlockLeave","_this$getCurrentRoute","routeConfig","canDeactivate","length","Promise","resolve","promise","navSubscription","events","pipe","event","subscribe","unsubscribe","getRelativePathToParent","_path$substring$match","addEndingSlash","parentRouteIndex","indexOf","depth","substring","match","repeat","factory","ɵfac","providedIn","CoreNavigator"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/services/navigator.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable } from '@angular/core';\nimport { ActivatedRoute, ActivatedRouteSnapshot, NavigationEnd, Params } from '@angular/router';\n\nimport { NavigationOptions } from '@ionic/angular/common/providers/nav-controller';\n\nimport { CoreConstants } from '@/core/constants';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreMainMenu } from '@features/mainmenu/services/mainmenu';\nimport { CoreObject } from '@singletons/object';\nimport { CoreSites } from '@services/sites';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { makeSingleton, NavController, Router } from '@singletons';\nimport { CoreScreen } from './screen';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreMainMenuDelegate } from '@features/mainmenu/services/mainmenu-delegate';\nimport { CorePlatform } from '@services/platform';\nimport { filter } from 'rxjs/operators';\nimport { CorePromisedValue } from '@classes/promised-value';\n\n/**\n * Redirect payload.\n */\nexport type CoreRedirectPayload = {\n    redirectPath?: string; // Path of the page to redirect to.\n    redirectOptions?: CoreNavigationOptions; // Options of the navigation using redirectPath.\n    urlToOpen?: string; // URL to open instead of a page + options.\n};\n\n/**\n * Navigation options.\n */\nexport type CoreNavigationOptions = Pick<NavigationOptions, 'animated'|'animation'|'animationDirection'> & {\n    params?: Params;\n    reset?: boolean;\n    replace?: boolean;\n    preferCurrentTab?: boolean; // Default true.\n    nextNavigation?: {\n        path: string;\n        isSitePath?: boolean;\n        options?: CoreNavigationOptions;\n    };\n};\n\n/**\n * Route options to get route or params values.\n */\nexport type CoreNavigatorCurrentRouteOptions = Partial<{\n    params: Params; // Params to get the value from.\n    route: ActivatedRoute; // Current Route.\n    pageComponent: unknown;\n    routeData: Record<string, unknown>;\n}>;\n\n/**\n * Service to provide some helper functions regarding navigation.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreNavigatorService {\n\n    protected routesDepth: Record<string, number> = {};\n    protected storedParams: Record<number, unknown> = {};\n    protected lastParamId = 0;\n\n    /**\n     * Check whether the active route is using the given path.\n     *\n     * @param path Path, can be a glob pattern.\n     * @returns Whether the active route is using the given path.\n     */\n    isCurrent(path: string): boolean {\n        return CoreTextUtils.matchesGlob(this.getCurrentPath(), path);\n    }\n\n    /**\n     * Get current main menu tab.\n     *\n     * @returns Current main menu tab or null if the current route is not using the main menu.\n     */\n    getCurrentMainMenuTab(): string | null {\n        return this.getMainMenuTabFromPath(this.getCurrentPath());\n    }\n\n    /**\n     * Get main menu tab from a path.\n     *\n     * @param path The path to check.\n     * @returns Path's main menu tab or null if the path is not using the main menu.\n     */\n    getMainMenuTabFromPath(path: string): string | null {\n        const matches = /^\\/main\\/([^/]+).*$/.exec(path);\n\n        return matches?.[1] ?? null;\n    }\n\n    /**\n     * Returns if a section is loaded on the split view (tablet mode).\n     *\n     * @param path Path, can be a glob pattern.\n     * @returns Whether the active route is using the given path.\n     */\n    isCurrentPathInTablet(path: string): boolean {\n        if (CoreScreen.isMobile) {\n            // Split view is off.\n            return false;\n        }\n\n        return this.isCurrent(path);\n    }\n\n    /**\n     * Navigate to a new path.\n     *\n     * @param path Path to navigate to.\n     * @param options Navigation options.\n     * @returns Whether navigation suceeded.\n     */\n    async navigate(path: string, options: CoreNavigationOptions = {}): Promise<boolean> {\n        const url: string[] = [/^[./]/.test(path) ? path : `./${path}`];\n        const navigationOptions: NavigationOptions = CoreObject.withoutEmpty({\n            animated: options.animated,\n            animation: options.animation,\n            animationDirection: options.animationDirection,\n            queryParams: CoreObject.isEmpty(options.params ?? {}) ? null : CoreObject.withoutEmpty(options.params ?? {}),\n            relativeTo: path.startsWith('/') ? null : this.getCurrentRoute(),\n            replaceUrl: options.replace,\n        });\n\n        // Remove objects from queryParams and replace them with an ID.\n        this.replaceObjectParams(navigationOptions.queryParams);\n\n        const navigationResult = (options.reset ?? false)\n            ? await NavController.navigateRoot(url, navigationOptions)\n            : await NavController.navigateForward(url, navigationOptions);\n\n        if (options.nextNavigation?.path && navigationResult !== false) {\n            if (options.nextNavigation.isSitePath) {\n                return this.navigateToSitePath(options.nextNavigation.path, options.nextNavigation.options);\n            }\n\n            return this.navigate(options.nextNavigation.path, options.nextNavigation.options);\n        }\n\n        return navigationResult !== false;\n    }\n\n    /**\n     * Navigate to the login credentials route.\n     *\n     * @param params Page params.\n     * @returns Whether navigation suceeded.\n     */\n    async navigateToLoginCredentials(params: Params = {}): Promise<boolean> {\n        // If necessary, open the previous path to keep the navigation history.\n        if (!this.isCurrent('/login/site') && !this.isCurrent('/login/sites')) {\n            const hasSites = await CoreSites.hasSites();\n\n            await this.navigate(hasSites ? '/login/sites' : '/login/site', { reset: true });\n        }\n\n        // Navigate to login credentials page.\n        return this.navigate('/login/credentials', { params });\n    }\n\n    /**\n     * Navigate to the home route of the current site.\n     *\n     * @param options Navigation options.\n     * @returns Whether navigation suceeded.\n     */\n    async navigateToSiteHome(options: Omit<CoreNavigationOptions, 'reset'> & { siteId?: string } = {}): Promise<boolean> {\n        const siteId = options.siteId ?? CoreSites.getCurrentSiteId();\n        const landingPagePath = CoreSites.isLoggedIn() && CoreSites.getCurrentSiteId() === siteId ?\n            this.getLandingTabPage() : 'main';\n\n        return this.navigateToSitePath(landingPagePath, {\n            ...options,\n            reset: true,\n            preferCurrentTab: false,\n        });\n    }\n\n    /**\n     * Navigate to a site path, loading the site if necessary.\n     *\n     * @param path Site path to visit.\n     * @param options Navigation and site options.\n     * @returns Whether navigation suceeded.\n     */\n    async navigateToSitePath(\n        path: string,\n        options: CoreNavigationOptions & { siteId?: string } = {},\n    ): Promise<boolean> {\n        const siteId = options.siteId ?? CoreSites.getCurrentSiteId();\n        const navigationOptions: CoreNavigationOptions = CoreObject.without(options, ['siteId']);\n\n        // If we are logged into a different site, log out first.\n        if (CoreSites.isLoggedIn() && CoreSites.getCurrentSiteId() !== siteId) {\n            const willReload = await CoreSites.logoutForRedirect(siteId, {\n                redirectPath: path,\n                redirectOptions: options || {},\n            });\n\n            if (willReload) {\n                return true;\n            }\n        }\n\n        // If the path doesn't belong to a site, call standard navigation.\n        if (siteId === CoreConstants.NO_SITE_ID) {\n            return this.navigate(path, {\n                ...navigationOptions,\n                reset: true,\n            });\n        }\n\n        // If we are not logged into the site, load the site.\n        if (!CoreSites.isLoggedIn()) {\n            const modal = await CoreDomUtils.showModalLoading();\n\n            try {\n                const loggedIn = await CoreSites.loadSite(siteId, {\n                    redirectPath: path,\n                    redirectOptions: options,\n                });\n\n                if (!loggedIn) {\n                    // User has been redirected to the login page and will be redirected to the site path after login.\n                    return true;\n                }\n            } catch (error) {\n                // Site doesn't exist.\n                return this.navigate('/login/sites', { reset: true });\n            } finally {\n                modal.dismiss();\n            }\n        }\n\n        // User is logged in, navigate to the site path.\n        return this.navigateToMainMenuPath(path, navigationOptions);\n    }\n\n    /**\n     * Get the active route path.\n     *\n     * @returns Current path.\n     */\n    getCurrentPath(): string {\n        return CoreUrlUtils.removeUrlParams(Router.url);\n    }\n\n    /**\n     * Iterately get the params checking parent routes.\n     *\n     * @param name Name of the parameter.\n     * @param route Current route.\n     * @returns Value of the parameter, undefined if not found.\n     */\n    protected getRouteSnapshotParam<T = unknown>(name: string, route?: ActivatedRoute): T | undefined {\n        if (!route) {\n            return;\n        }\n\n        if (route.snapshot) {\n            const value = route.snapshot.queryParams[name] ?? route.snapshot.params[name];\n\n            if (value !== undefined) {\n                return value;\n            }\n        }\n\n        return this.getRouteSnapshotParam(name, route.parent || undefined);\n    }\n\n    /**\n     * Get a parameter for the current route.\n     * Please notice that objects can only be retrieved once. You must call this function only once per page and parameter,\n     * unless there's a new navigation to the page.\n     *\n     * @param name Name of the parameter.\n     * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n     * @returns Value of the parameter, undefined if not found.\n     */\n    getRouteParam<T = string>(name: string, routeOptions: CoreNavigatorCurrentRouteOptions = {}): T | undefined {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let value: any;\n\n        if (!routeOptions.params) {\n            let route = this.getCurrentRoute();\n            if (!route?.snapshot && routeOptions.route) {\n                route = routeOptions.route;\n            }\n\n            value = this.getRouteSnapshotParam(name, route);\n        } else {\n            value = routeOptions.params[name];\n        }\n\n        if (value === undefined) {\n            return;\n        }\n\n        let storedParam = this.storedParams[value];\n\n        // Remove the parameter from our map if it's in there.\n        delete this.storedParams[value];\n\n        if (!CorePlatform.isMobile() && !storedParam) {\n            // Try to retrieve the param from local storage in browser.\n            const storageParam = localStorage.getItem(value);\n            if (storageParam) {\n                storedParam = CoreTextUtils.parseJSON(storageParam);\n            }\n        }\n\n        return <T> storedParam ?? value;\n    }\n\n    /**\n     * Get a number route param.\n     * Angular router automatically converts numbers to string, this function automatically converts it back to number.\n     *\n     * @param name Name of the parameter.\n     * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n     * @returns Value of the parameter, undefined if not found.\n     */\n    getRouteNumberParam(name: string, routeOptions: CoreNavigatorCurrentRouteOptions = {}): number | undefined {\n        const value = this.getRouteParam<string>(name, routeOptions);\n\n        return value !== undefined ? Number(value) : value;\n    }\n\n    /**\n     * Get a boolean route param.\n     * Angular router automatically converts booleans to string, this function automatically converts it back to boolean.\n     *\n     * @param name Name of the parameter.\n     * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n     * @returns Value of the parameter, undefined if not found.\n     */\n    getRouteBooleanParam(name: string, routeOptions: CoreNavigatorCurrentRouteOptions = {}): boolean | undefined {\n        const value = this.getRouteParam<string>(name, routeOptions);\n\n        if (value === undefined) {\n            return value;\n        }\n\n        if (CoreUtils.isTrueOrOne(value)) {\n            return true;\n        }\n\n        if (CoreUtils.isFalseOrZero(value)) {\n            return false;\n        }\n\n        return Boolean(value);\n    }\n\n    /**\n     * Get a parameter for the current route.\n     * Please notice that objects can only be retrieved once. You must call this function only once per page and parameter,\n     * unless there's a new navigation to the page.\n     *\n     * This function will fail if parameter is not found.\n     *\n     * @param name Name of the parameter.\n     * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n     * @returns Value of the parameter, undefined if not found.\n     */\n    getRequiredRouteParam<T = unknown>(name: string, routeOptions: CoreNavigatorCurrentRouteOptions = {}): T {\n        const value = this.getRouteParam<T>(name, routeOptions);\n\n        if (value === undefined) {\n            throw new CoreError(`Required param '${name}' not found.`);\n        }\n\n        return value;\n    }\n\n    /**\n     * Get a number route param.\n     * Angular router automatically converts numbers to string, this function automatically converts it back to number.\n     *\n     * This function will fail if parameter is not found.\n     *\n     * @param name Name of the parameter.\n     * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n     * @returns Value of the parameter, undefined if not found.\n     */\n    getRequiredRouteNumberParam(name: string, routeOptions: CoreNavigatorCurrentRouteOptions = {}): number {\n        const value = this.getRouteNumberParam(name, routeOptions);\n\n        if (value === undefined) {\n            throw new CoreError(`Required number param '${name}' not found.`);\n        }\n\n        return value;\n    }\n\n    /**\n     * Get a boolean route param.\n     * Angular router automatically converts booleans to string, this function automatically converts it back to boolean.\n     *\n     * This function will fail if parameter is not found.\n     *\n     * @param name Name of the parameter.\n     * @param routeOptions Optional routeOptions to get the params or route value from. If missing, it will autodetect.\n     * @returns Value of the parameter, undefined if not found.\n     */\n    getRequiredRouteBooleanParam(name: string, routeOptions: CoreNavigatorCurrentRouteOptions = {}): boolean {\n        const value = this.getRouteBooleanParam(name, routeOptions);\n\n        if (value === undefined) {\n            throw new CoreError(`Required boolean param '${name}' not found.`);\n        }\n\n        return value;\n    }\n\n    /**\n     * Navigate back.\n     *\n     * @returns Promise resolved when done.\n     */\n    async back(): Promise<void> {\n        await NavController.pop();\n    }\n\n    /**\n     * Get current activated route.\n     *\n     * @param options\n     *     - route: Parent route, if this isn't provided the current active route will be used.\n     *     - pageComponent: Page component of the route to find, if this isn't provided the deepest route in the hierarchy\n     *                      will be returned.\n     * @returns Current activated route.\n     */\n    getCurrentRoute(): ActivatedRoute;\n    getCurrentRoute(options: CoreNavigatorCurrentRouteOptions): ActivatedRoute | null;\n    getCurrentRoute({ route, pageComponent, routeData }: CoreNavigatorCurrentRouteOptions = {}): ActivatedRoute | null {\n        route = route ?? Router.routerState.root;\n\n        if (pageComponent && route.component === pageComponent) {\n            return route;\n        }\n\n        if (routeData && CoreUtils.basicLeftCompare(routeData, route.snapshot.data, 3)) {\n            return route;\n        }\n\n        if (route.firstChild) {\n            return this.getCurrentRoute({ route: route.firstChild, pageComponent, routeData });\n        }\n\n        return pageComponent || routeData ? null : route;\n    }\n\n    /**\n     * Check whether a route is active within the current stack.\n     *\n     * @param route Route to check.\n     * @returns Whether the route is active or not.\n     */\n    isRouteActive(route: ActivatedRoute): boolean {\n        const routePath = this.getRouteFullPath(route.snapshot);\n        let activeRoute: ActivatedRoute | null = Router.routerState.root;\n\n        while (activeRoute) {\n            if (this.getRouteFullPath(activeRoute.snapshot) === routePath) {\n                return true;\n            }\n\n            activeRoute = activeRoute.firstChild;\n        }\n\n        return false;\n    }\n\n    /**\n     * Increase the number of times a route is repeated on the navigation stack.\n     *\n     * @param path Absolute route path.\n     */\n    increaseRouteDepth(path: string): void {\n        this.routesDepth[path] = this.getRouteDepth(path) + 1;\n    }\n\n    /**\n     * Decrease the number of times a route is repeated on the navigation stack.\n     *\n     * @param path Absolute route path.\n     */\n    decreaseRouteDepth(path: string): void {\n        if (this.getRouteDepth(path) <= 1) {\n            delete this.routesDepth[path];\n        } else {\n            this.routesDepth[path]--;\n        }\n    }\n\n    /**\n     * Get the number of times a route is repeated on the navigation stack.\n     *\n     * @param path Absolute route path.\n     * @returns Route depth.\n     */\n    getRouteDepth(path: string): number {\n        return this.routesDepth[path] ?? 0;\n    }\n\n    /**\n     * Navigate to a path within the main menu.\n     * If the path belongs to a visible tab, that tab will be selected.\n     * If it doesn't, the current tab or the default tab will be used instead.\n     *\n     * @param path Main menu path.\n     * @param options Navigation options.\n     * @returns Whether navigation suceeded.\n     */\n    protected async navigateToMainMenuPath(path: string, options: CoreNavigationOptions = {}): Promise<boolean> {\n        options = {\n            preferCurrentTab: true,\n            ...options,\n        };\n\n        path = path.replace(/^(\\.|\\/main)?\\//, '');\n\n        const pathRoot = /^[^/]+/.exec(path)?.[0] ?? '';\n        if (!pathRoot) {\n            // No path root, going to the site home.\n            return this.navigate('/main', options);\n        }\n\n        const currentMainMenuTab = this.getCurrentMainMenuTab();\n        const isMainMenuTab = pathRoot === currentMainMenuTab || (!currentMainMenuTab && path === this.getLandingTabPage()) ||\n            await CoreUtils.ignoreErrors(CoreMainMenu.isMainMenuTab(pathRoot), false);\n\n        if (!options.preferCurrentTab && isMainMenuTab) {\n            return this.navigate(`/main/${path}`, options);\n        }\n\n        // Open the path within the current main tab.\n        if (currentMainMenuTab && (!isMainMenuTab || pathRoot !== currentMainMenuTab)) {\n            return this.navigate(`/main/${currentMainMenuTab}/${path}`, options);\n        }\n\n        // Open the path within the corresponding main tab.\n        if (isMainMenuTab) {\n            return this.navigate(`/main/${path}`, options);\n        }\n\n        if (this.isCurrent('/main')) {\n            // Main menu is loaded, but no tab selected yet. Wait for a tab to be loaded.\n            await this.waitForMainMenuTab();\n\n            return this.navigate(`/main/${this.getCurrentMainMenuTab()}/${path}`, options);\n        }\n\n        // Open the path within in main menu.\n        return this.navigate('/main', {\n            ...options,\n            params: {\n                redirectPath: path,\n                redirectOptions: options.params || options.nextNavigation ? options : undefined,\n            } as CoreRedirectPayload,\n        });\n    }\n\n    /**\n     * Get the first page path using priority.\n     *\n     * @returns Landing page path.\n     */\n    protected getLandingTabPage(): string {\n        if (!CoreMainMenuDelegate.areHandlersLoaded()) {\n            // Handlers not loaded yet, landing page is the root page.\n            return '';\n        }\n\n        const handlers = CoreMainMenuDelegate.getHandlers().filter((handler) => !handler.onlyInMore);\n\n        return handlers[0]?.page || '';\n    }\n\n    /**\n     * Replace all objects in query params with an ID that can be used to retrieve the object later.\n     *\n     * @param queryParams Params.\n     */\n    protected replaceObjectParams(queryParams?: Params | null): void {\n        for (const name in queryParams) {\n            const value = queryParams[name];\n            if (typeof value != 'object' || value === null) {\n                continue;\n            }\n\n            const id = this.getNewParamId();\n            this.storedParams[id] = value;\n            queryParams[name] = id;\n\n            if (!CorePlatform.isMobile()) {\n                // In browser, save the param in local storage to be able to retrieve it if the app is refreshed.\n                localStorage.setItem(id, JSON.stringify(value));\n            }\n        }\n    }\n\n    /**\n     * Get an ID for a new parameter.\n     *\n     * @returns New param Id.\n     */\n    protected getNewParamId(): string {\n        return 'param-' + (++this.lastParamId);\n    }\n\n    /**\n     * Replace the route params in a path with the params values.\n     *\n     * @param path Path.\n     * @param params Params.\n     * @returns Path with params replaced.\n     */\n    replaceRoutePathParams(path: string, params?: Params): string {\n        for (const name in params) {\n            path = path.replace(`:${name}`, params[name]);\n        }\n\n        return path;\n    }\n\n    /**\n     * Get the full path of a certain route, including parent routes paths.\n     *\n     * @param route Route snapshot.\n     * @returns Path.\n     */\n    getRouteFullPath(route: ActivatedRouteSnapshot | null): string {\n        if (!route) {\n            return '';\n        }\n\n        const parentPath = this.getRouteFullPath(route.parent);\n        const routePath = route.url.join('/');\n\n        if (!parentPath && !routePath) {\n            return '';\n        } else if (parentPath && !routePath) {\n            return parentPath;\n        } else if (!parentPath && routePath) {\n            return '/' + routePath;\n        } else {\n            return parentPath + '/' + routePath;\n        }\n    }\n\n    /**\n     * Check if the current route page can block leaving the route.\n     *\n     * @returns Whether the current route page can block leaving the route.\n     */\n    currentRouteCanBlockLeave(): boolean {\n        return !!this.getCurrentRoute().snapshot.routeConfig?.canDeactivate?.length;\n    }\n\n    /**\n     * Wait for a main menu tab route to be loaded.\n     *\n     * @returns Promise resolved when the route is loaded.\n     */\n    protected waitForMainMenuTab(): Promise<void> {\n        if (this.getCurrentMainMenuTab()) {\n            return Promise.resolve();\n        }\n\n        const promise = new CorePromisedValue<void>();\n\n        const navSubscription = Router.events\n            .pipe(filter(event => event instanceof NavigationEnd))\n            .subscribe(() => {\n                if (this.getCurrentMainMenuTab()) {\n                    navSubscription?.unsubscribe();\n                    promise.resolve();\n                }\n            });\n\n        return promise;\n    }\n\n    /**\n     * Get the relative path to a parent path.\n     * E.g. if parent path is '/foo' and current path is '/foo/bar/baz' it will return '../../'.\n     *\n     * @param parentPath Parent path.\n     * @returns Relative path to the parent, empty if same path or parent path not found.\n     * @todo If messaging is refactored to use list managers, this function might not be needed anymore.\n     */\n    getRelativePathToParent(parentPath: string): string {\n        // Add an ending slash to avoid collisions with other routes (e.g. /foo and /foobar).\n        parentPath = CoreTextUtils.addEndingSlash(parentPath);\n\n        const path = this.getCurrentPath();\n        const parentRouteIndex = path.indexOf(parentPath);\n        if (parentRouteIndex === -1) {\n            return '';\n        }\n\n        const depth = (path.substring(parentRouteIndex + parentPath.length - 1).match(/\\//g) ?? []).length;\n\n        return '../'.repeat(depth);\n    }\n\n}\n\nexport const CoreNavigator = makeSingleton(CoreNavigatorService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}