{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Observable, of } from 'rxjs';\nimport { catchError, filter } from 'rxjs/operators';\n/**\n * Create an observable that emits the current form control value.\n *\n * @param control Form control.\n * @returns Form control value observable.\n */\nexport function formControlValue(control) {\n  return control.valueChanges.pipe(startWithOnSubscribed(() => control.value), filter(value => value !== null));\n}\n/**\n * Observable operator that waits for a promise to resolve before emitting the result.\n *\n * @returns Operator.\n */\nexport function resolved() {\n  return source => new Observable(subscriber => {\n    const subscription = source.subscribe( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (promise) {\n        const value = yield promise;\n        return subscriber.next(value);\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    return subscription;\n  });\n}\n/**\n * Same as the built-in startWith operator, but evaluates the starting value for each subscriber\n * on subscription.\n *\n * @param onSubscribed Callback to calculate the starting value.\n * @returns Operator.\n */\nexport function startWithOnSubscribed(onSubscribed) {\n  return source => new Observable(subscriber => {\n    subscriber.next(onSubscribed());\n    return source.subscribe(value => subscriber.next(value));\n  });\n}\n/**\n * Convert to an Observable a Promise that resolves to an Observable.\n *\n * @param createObservable A function returning a promise that resolves to an Observable.\n * @returns Observable.\n */\nexport function asyncObservable(createObservable) {\n  const promise = createObservable();\n  return new Observable(subscriber => {\n    promise.then(observable => observable.subscribe(subscriber)) // rxjs will automatically handle unsubscribes.\n    .catch(error => subscriber.error(error));\n  });\n}\n/**\n * Ignore errors from an observable, returning a certain value instead.\n *\n * @param observable Observable to ignore errors.\n * @param fallback Value to return if the observer errors.\n * @returns Observable with ignored errors, returning the fallback result if provided.\n */\nexport function ignoreErrors(observable, fallback) {\n  return observable.pipe(catchError(() => of(fallback)));\n}\n/**\n * Same as the built-in zip operator, but once an observable completes it'll continue to emit the last value as long\n * as the other observables continue to emit values.\n *\n * @param observables Observables to zip.\n * @returns Observable that emits the zipped values.\n */\nexport function zipIncludingComplete(...observables) {\n  return new Observable(subscriber => {\n    let nextIndex = 0;\n    let hasErrored = false;\n    let hasCompleted = false;\n    // Before subscribing, initialize the data for all observables.\n    const observablesData = observables.map(() => ({\n      values: [],\n      completed: false\n    }));\n    // Treat an emitted event.\n    const treatEmitted = (completed = false) => {\n      if (hasErrored || hasCompleted) {\n        return;\n      }\n      if (completed) {\n        // Check if all observables have completed.\n        const numCompleted = observablesData.reduce((total, data) => total + (data.completed ? 1 : 0), 0);\n        if (numCompleted === observablesData.length) {\n          hasCompleted = true;\n          // Emit all pending values.\n          const maxValues = observablesData.reduce((maxValues, data) => Math.max(maxValues, data.values.length), 0);\n          while (nextIndex < maxValues) {\n            emitNextValue();\n            nextIndex++;\n          }\n          subscriber.complete();\n          return;\n        }\n      }\n      // Check if any observable still doesn't have data for the index.\n      const notReady = observablesData.some(data => !data.completed && !(nextIndex in data.values));\n      if (notReady) {\n        return;\n      }\n      emitNextValue();\n      nextIndex++;\n      if (completed) {\n        // An observable was completed, there might be other values to emit.\n        treatEmitted(true);\n      }\n    };\n    const emitNextValue = () => {\n      // For each observable, get the value for the next index, or last value if not present (completed).\n      const valueToEmit = observablesData.map(observableData => {\n        var _observableData$value;\n        return (_observableData$value = observableData.values[nextIndex]) !== null && _observableData$value !== void 0 ? _observableData$value : observableData.values[observableData.values.length - 1];\n      });\n      subscriber.next(valueToEmit);\n    };\n    observables.forEach((observable, obsIndex) => {\n      const observableData = observablesData[obsIndex];\n      observableData.subscription = observable.subscribe({\n        next: value => {\n          observableData.values.push(value);\n          treatEmitted();\n        },\n        error: error => {\n          hasErrored = true;\n          subscriber.error(error);\n        },\n        complete: () => {\n          observableData.completed = true;\n          treatEmitted(true);\n        }\n      });\n    });\n    // When unsubscribing, unsubscribe from all observables.\n    return () => {\n      observablesData.forEach(observableData => {\n        var _observableData$subsc;\n        return (_observableData$subsc = observableData.subscription) === null || _observableData$subsc === void 0 ? void 0 : _observableData$subsc.unsubscribe();\n      });\n    };\n  });\n}","map":{"version":3,"names":["Observable","of","catchError","filter","formControlValue","control","valueChanges","pipe","startWithOnSubscribed","value","resolved","source","subscriber","subscription","subscribe","_ref","_asyncToGenerator","promise","next","_x","apply","arguments","onSubscribed","asyncObservable","createObservable","then","observable","catch","error","ignoreErrors","fallback","zipIncludingComplete","observables","nextIndex","hasErrored","hasCompleted","observablesData","map","values","completed","treatEmitted","numCompleted","reduce","total","data","length","maxValues","Math","max","emitNextValue","complete","notReady","some","valueToEmit","observableData","_observableData$value","forEach","obsIndex","push","_observableData$subsc","unsubscribe"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/utils/rxjs.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { FormControl } from '@angular/forms';\nimport { Observable, of, OperatorFunction, Subscription } from 'rxjs';\nimport { catchError, filter } from 'rxjs/operators';\n\n/**\n * Create an observable that emits the current form control value.\n *\n * @param control Form control.\n * @returns Form control value observable.\n */\nexport function formControlValue<T = unknown>(control: FormControl): Observable<T> {\n    return control.valueChanges.pipe(\n        startWithOnSubscribed(() => control.value),\n        filter(value => value !== null),\n    );\n}\n\n/**\n * Observable operator that waits for a promise to resolve before emitting the result.\n *\n * @returns Operator.\n */\nexport function resolved<T>(): OperatorFunction<Promise<T>, T> {\n    return source => new Observable(subscriber => {\n        const subscription = source.subscribe(async promise => {\n            const value = await promise;\n\n            return subscriber.next(value);\n        });\n\n        return subscription;\n    });\n}\n\n/**\n * Same as the built-in startWith operator, but evaluates the starting value for each subscriber\n * on subscription.\n *\n * @param onSubscribed Callback to calculate the starting value.\n * @returns Operator.\n */\nexport function startWithOnSubscribed<T>(onSubscribed: () => T): OperatorFunction<T, T> {\n    return source => new Observable(subscriber => {\n        subscriber.next(onSubscribed());\n\n        return source.subscribe(value => subscriber.next(value));\n    });\n}\n\n/**\n * Convert to an Observable a Promise that resolves to an Observable.\n *\n * @param createObservable A function returning a promise that resolves to an Observable.\n * @returns Observable.\n */\nexport function asyncObservable<T>(createObservable: () => Promise<Observable<T>>): Observable<T> {\n    const promise = createObservable();\n\n    return new Observable(subscriber => {\n        promise\n            .then(observable => observable.subscribe(subscriber)) // rxjs will automatically handle unsubscribes.\n            .catch(error => subscriber.error(error));\n    });\n}\n\nexport function ignoreErrors<Result>(observable: Observable<Result>): Observable<Result | undefined>;\nexport function ignoreErrors<Result, Fallback>(observable: Observable<Result>, fallback: Fallback): Observable<Result | Fallback>;\n/**\n * Ignore errors from an observable, returning a certain value instead.\n *\n * @param observable Observable to ignore errors.\n * @param fallback Value to return if the observer errors.\n * @returns Observable with ignored errors, returning the fallback result if provided.\n */\nexport function ignoreErrors<Result, Fallback>(\n    observable: Observable<Result>,\n    fallback?: Fallback,\n): Observable<Result | Fallback | undefined> {\n    return observable.pipe(catchError(() => of(fallback)));\n}\n\n/**\n * Get return types of a list of observables.\n */\ntype GetObservablesReturnTypes<T> = { [key in keyof T]: T[key] extends Observable<infer R> ? R : never };\n\n/**\n * Data for an observable when zipping.\n */\ntype ZipObservableData<T = unknown> = {\n    values: T[];\n    completed: boolean;\n    subscription?: Subscription;\n};\n\n/**\n * Same as the built-in zip operator, but once an observable completes it'll continue to emit the last value as long\n * as the other observables continue to emit values.\n *\n * @param observables Observables to zip.\n * @returns Observable that emits the zipped values.\n */\nexport function zipIncludingComplete<T extends Observable<unknown>[]>(\n    ...observables: T\n): Observable<GetObservablesReturnTypes<T>> {\n    return new Observable(subscriber => {\n        let nextIndex = 0;\n        let hasErrored = false;\n        let hasCompleted = false;\n\n        // Before subscribing, initialize the data for all observables.\n        const observablesData = observables.map(() => <ZipObservableData> {\n            values: [],\n            completed: false,\n        });\n\n        // Treat an emitted event.\n        const treatEmitted = (completed = false) => {\n            if (hasErrored || hasCompleted) {\n                return;\n            }\n\n            if (completed) {\n                // Check if all observables have completed.\n                const numCompleted = observablesData.reduce((total, data) => total + (data.completed ? 1 : 0), 0);\n                if (numCompleted === observablesData.length) {\n                    hasCompleted = true;\n\n                    // Emit all pending values.\n                    const maxValues = observablesData.reduce((maxValues, data) => Math.max(maxValues, data.values.length), 0);\n                    while (nextIndex < maxValues) {\n                        emitNextValue();\n                        nextIndex++;\n                    }\n\n                    subscriber.complete();\n\n                    return;\n                }\n            }\n\n            // Check if any observable still doesn't have data for the index.\n            const notReady = observablesData.some(data => !data.completed && !(nextIndex in data.values));\n            if (notReady) {\n                return;\n            }\n\n            emitNextValue();\n            nextIndex++;\n\n            if (completed) {\n                // An observable was completed, there might be other values to emit.\n                treatEmitted(true);\n            }\n        };\n        const emitNextValue = () => {\n            // For each observable, get the value for the next index, or last value if not present (completed).\n            const valueToEmit = observablesData.map(observableData =>\n                observableData.values[nextIndex] ?? observableData.values[observableData.values.length - 1]);\n\n            subscriber.next(<GetObservablesReturnTypes<T>> valueToEmit);\n        };\n\n        observables.forEach((observable, obsIndex) => {\n            const observableData = observablesData[obsIndex];\n\n            observableData.subscription = observable.subscribe({\n                next: (value) => {\n                    observableData.values.push(value);\n                    treatEmitted();\n                },\n                error: (error) => {\n                    hasErrored = true;\n                    subscriber.error(error);\n                },\n                complete: () => {\n                    observableData.completed = true;\n                    treatEmitted(true);\n                },\n            });\n        });\n\n        // When unsubscribing, unsubscribe from all observables.\n        return () => {\n            observablesData.forEach(observableData => observableData.subscription?.unsubscribe());\n        };\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}