{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { AddonQtypeMultichoiceComponent } from '../../component/multichoice';\nimport * as i0 from \"@angular/core\";\n/**\n * Handler to support multichoice question type.\n */\nexport class AddonQtypeMultichoiceHandlerService {\n  constructor() {\n    this.name = 'AddonQtypeMultichoice';\n    this.type = 'qtype_multichoice';\n  }\n  /**\n   * @inheritdoc\n   */\n  getComponent() {\n    return AddonQtypeMultichoiceComponent;\n  }\n  /**\n   * @inheritdoc\n   */\n  isCompleteResponse(question, answers) {\n    let isSingle = true;\n    let isMultiComplete = false;\n    // To know if it's single or multi answer we need to search for answers with \"choice\" in the name.\n    for (const name in answers) {\n      if (name.indexOf('choice') != -1) {\n        isSingle = false;\n        if (answers[name]) {\n          isMultiComplete = true;\n        }\n      }\n    }\n    if (isSingle) {\n      // Single.\n      return this.isCompleteResponseSingle(answers);\n    } else {\n      // Multi.\n      return isMultiComplete ? 1 : 0;\n    }\n  }\n  /**\n   * Check if a response is complete. Only for single answer.\n   *\n   * @param answers The question answers (without prefix).\n   * @returns 1 if complete, 0 if not complete, -1 if cannot determine.\n   */\n  isCompleteResponseSingle(answers) {\n    return answers.answer && answers.answer !== '' ? 1 : 0;\n  }\n  /**\n   * @inheritdoc\n   */\n  isEnabled() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  /**\n   * @inheritdoc\n   */\n  isGradableResponse(question, answers) {\n    return this.isCompleteResponse(question, answers);\n  }\n  /**\n   * Check if a student has provided enough of an answer for the question to be graded automatically,\n   * or whether it must be considered aborted. Only for single answer.\n   *\n   * @param answers Object with the question answers (without prefix).\n   * @returns 1 if gradable, 0 if not gradable, -1 if cannot determine.\n   */\n  isGradableResponseSingle(answers) {\n    return this.isCompleteResponseSingle(answers);\n  }\n  /**\n   * @inheritdoc\n   */\n  isSameResponse(question, prevAnswers, newAnswers) {\n    let isSingle = true;\n    let isMultiSame = true;\n    // To know if it's single or multi answer we need to search for answers with \"choice\" in the name.\n    for (const name in newAnswers) {\n      if (name.indexOf('choice') !== -1) {\n        isSingle = false;\n        if (!CoreUtils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, name)) {\n          isMultiSame = false;\n          break;\n        }\n      }\n    }\n    if (isSingle) {\n      return this.isSameResponseSingle(prevAnswers, newAnswers);\n    }\n    return isMultiSame;\n  }\n  /**\n   * Check if two responses are the same. Only for single answer.\n   *\n   * @param prevAnswers Object with the previous question answers.\n   * @param newAnswers Object with the new question answers.\n   * @returns Whether they're the same.\n   */\n  isSameResponseSingle(prevAnswers, newAnswers) {\n    return CoreUtils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer');\n  }\n  /**\n   * @inheritdoc\n   */\n  prepareAnswers(question, answers) {\n    if (question && !question.multi && question.optionsName && answers[question.optionsName] !== undefined && !answers[question.optionsName]) {\n      /* It's a single choice and the user hasn't answered. Delete the answer because\n         sending an empty string (default value) will mark the first option as selected. */\n      delete answers[question.optionsName];\n    }\n  }\n}\n_class = AddonQtypeMultichoiceHandlerService;\n_class.ɵfac = function AddonQtypeMultichoiceHandlerService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const AddonQtypeMultichoiceHandler = makeSingleton(AddonQtypeMultichoiceHandlerService);","map":{"version":3,"names":["CoreUtils","makeSingleton","AddonQtypeMultichoiceComponent","AddonQtypeMultichoiceHandlerService","constructor","name","type","getComponent","isCompleteResponse","question","answers","isSingle","isMultiComplete","indexOf","isCompleteResponseSingle","answer","isEnabled","_asyncToGenerator","isGradableResponse","isGradableResponseSingle","isSameResponse","prevAnswers","newAnswers","isMultiSame","sameAtKeyMissingIsBlank","isSameResponseSingle","prepareAnswers","multi","optionsName","undefined","factory","ɵfac","providedIn","AddonQtypeMultichoiceHandler"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/addons/qtype/multichoice/services/handlers/multichoice.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\n\nimport { AddonModQuizMultichoiceQuestion } from '@features/question/classes/base-question-component';\nimport { CoreQuestionQuestionParsed, CoreQuestionsAnswers } from '@features/question/services/question';\nimport { CoreQuestionHandler } from '@features/question/services/question-delegate';\nimport { CoreUtils } from '@services/utils/utils';\nimport { makeSingleton } from '@singletons';\nimport { AddonQtypeMultichoiceComponent } from '../../component/multichoice';\n\n/**\n * Handler to support multichoice question type.\n */\n@Injectable({ providedIn: 'root' })\nexport class AddonQtypeMultichoiceHandlerService implements CoreQuestionHandler {\n\n    name = 'AddonQtypeMultichoice';\n    type = 'qtype_multichoice';\n\n    /**\n     * @inheritdoc\n     */\n    getComponent(): Type<unknown> {\n        return AddonQtypeMultichoiceComponent;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isCompleteResponse(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n    ): number {\n        let isSingle = true;\n        let isMultiComplete = false;\n\n        // To know if it's single or multi answer we need to search for answers with \"choice\" in the name.\n        for (const name in answers) {\n            if (name.indexOf('choice') != -1) {\n                isSingle = false;\n                if (answers[name]) {\n                    isMultiComplete = true;\n                }\n            }\n        }\n\n        if (isSingle) {\n            // Single.\n            return this.isCompleteResponseSingle(answers);\n        } else {\n            // Multi.\n            return isMultiComplete ? 1 : 0;\n        }\n    }\n\n    /**\n     * Check if a response is complete. Only for single answer.\n     *\n     * @param answers The question answers (without prefix).\n     * @returns 1 if complete, 0 if not complete, -1 if cannot determine.\n     */\n    isCompleteResponseSingle(answers: CoreQuestionsAnswers): number {\n        return (answers.answer && answers.answer !== '') ? 1 : 0;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async isEnabled(): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isGradableResponse(\n        question: CoreQuestionQuestionParsed,\n        answers: CoreQuestionsAnswers,\n    ): number {\n        return this.isCompleteResponse(question, answers);\n    }\n\n    /**\n     * Check if a student has provided enough of an answer for the question to be graded automatically,\n     * or whether it must be considered aborted. Only for single answer.\n     *\n     * @param answers Object with the question answers (without prefix).\n     * @returns 1 if gradable, 0 if not gradable, -1 if cannot determine.\n     */\n    isGradableResponseSingle(answers: CoreQuestionsAnswers): number {\n        return this.isCompleteResponseSingle(answers);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    isSameResponse(\n        question: CoreQuestionQuestionParsed,\n        prevAnswers: CoreQuestionsAnswers,\n        newAnswers: CoreQuestionsAnswers,\n    ): boolean {\n        let isSingle = true;\n        let isMultiSame = true;\n\n        // To know if it's single or multi answer we need to search for answers with \"choice\" in the name.\n        for (const name in newAnswers) {\n            if (name.indexOf('choice') !== -1) {\n                isSingle = false;\n                if (!CoreUtils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, name)) {\n                    isMultiSame = false;\n                    break;\n                }\n            }\n        }\n\n        if (isSingle) {\n            return this.isSameResponseSingle(prevAnswers, newAnswers);\n        }\n\n        return isMultiSame;\n    }\n\n    /**\n     * Check if two responses are the same. Only for single answer.\n     *\n     * @param prevAnswers Object with the previous question answers.\n     * @param newAnswers Object with the new question answers.\n     * @returns Whether they're the same.\n     */\n    isSameResponseSingle(prevAnswers: CoreQuestionsAnswers, newAnswers: CoreQuestionsAnswers): boolean {\n        return CoreUtils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer');\n    }\n\n    /**\n     * @inheritdoc\n     */\n    prepareAnswers(\n        question: AddonModQuizMultichoiceQuestion,\n        answers: CoreQuestionsAnswers,\n    ): void {\n        if (question && !question.multi &&\n            question.optionsName && answers[question.optionsName] !== undefined && !answers[question.optionsName]) {\n            /* It's a single choice and the user hasn't answered. Delete the answer because\n               sending an empty string (default value) will mark the first option as selected. */\n            delete answers[question.optionsName];\n        }\n    }\n\n}\n\nexport const AddonQtypeMultichoiceHandler = makeSingleton(AddonQtypeMultichoiceHandlerService);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}