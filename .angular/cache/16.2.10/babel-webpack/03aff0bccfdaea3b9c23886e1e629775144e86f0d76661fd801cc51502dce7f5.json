{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreConstants } from '@/core/constants';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreFilterHelper } from '@features/filter/services/filter-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreCourse } from '../services/course';\nimport { CoreCourseModulePrefetchHandlerBase } from './module-prefetch-handler';\n/**\n * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. It is useful to minimize the amount of\n * functions that handlers need to implement. It also provides some helper features like preventing a module to be\n * downloaded twice at the same time.\n *\n * If your handler inherits from this service, you just need to override the functions that you want to change.\n *\n * This class should be used for ACTIVITIES. You must override the prefetch function, and it's recommended to call\n * prefetchPackage in there since it handles the package status.\n */\nexport class CoreCourseActivityPrefetchHandlerBase extends CoreCourseModulePrefetchHandlerBase {\n  /**\n   * Download the module.\n   *\n   * @param module The module object returned by WS.\n   * @param courseId Course ID.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @returns Promise resolved when all content is downloaded.\n   */\n  download(module, courseId, dirPath) {\n    // Same implementation for download and prefetch.\n    return this.prefetch(module, courseId, false, dirPath);\n  }\n  /**\n   * Prefetch a module.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param single True if we're downloading a single module, false if we're downloading a whole section.\n   * @param dirPath Path of the directory where to store all the content files.\n   * @returns Promise resolved when done.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  prefetch(module, courseId, single, dirPath) {\n    return _asyncToGenerator(function* () {\n      // To be overridden. It should call prefetchPackage\n      return;\n    })();\n  }\n  /**\n   * Prefetch the module, setting package status at start and finish.\n   *\n   * Example usage from a child instance:\n   *     return this.prefetchPackage(module, courseId, (siteId) => this.prefetchModule(module, otherParam, siteId), siteId);\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param downloadFunction Function to perform the prefetch. It can return a string to be stored as the package \"extra\" data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the module has been downloaded. Data returned is not reliable.\n   */\n  prefetchPackage(module, courseId, downloadFunction, siteId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      if (!CoreNetwork.isOnline()) {\n        // Cannot prefetch in offline.\n        throw new CoreNetworkError();\n      }\n      if (_this.isDownloading(module.id, siteId)) {\n        // There's already a download ongoing for this module, return the promise.\n        return _this.getOngoingDownload(module.id, siteId);\n      }\n      const prefetchPromise = _this.changeStatusAndPrefetch(module, courseId, downloadFunction, siteId);\n      return _this.addOngoingDownload(module.id, prefetchPromise, siteId);\n    })();\n  }\n  /**\n   * Change module status and call the prefetch function.\n   *\n   * @param module Module.\n   * @param courseId Course ID the module belongs to.\n   * @param downloadFunction Function to perform the prefetch. It can return a string to be stored as the package \"extra\" data.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when the module has been downloaded. Data returned is not reliable.\n   */\n  changeStatusAndPrefetch(module, courseId, downloadFunction, siteId) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this2.setDownloading(module.id, siteId);\n        // Package marked as downloading, get module info to be able to handle links. Get module filters too.\n        yield Promise.all([CoreCourse.getModuleBasicInfo(module.id, {\n          siteId\n        }), CoreCourse.getModule(module.id, courseId, undefined, false, true, siteId), CoreFilterHelper.getFilters('module', module.id, {\n          courseId\n        })]);\n        // Call the download function.\n        let extra = yield downloadFunction(siteId);\n        // Only accept string types.\n        if (typeof extra != 'string') {\n          extra = '';\n        }\n        // Prefetch finished, mark as downloaded.\n        yield _this2.setDownloaded(module.id, siteId, extra);\n      } catch (error) {\n        // Error prefetching, go back to previous status and reject the promise.\n        yield _this2.setPreviousStatus(module.id, siteId);\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Mark the module as downloaded.\n   *\n   * @param id Unique identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @param extra Extra data to store.\n   * @returns Promise resolved when done.\n   */\n  setDownloaded(id, siteId, extra) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    return CoreFilepool.storePackageStatus(siteId, CoreConstants.DOWNLOADED, this.component, id, extra);\n  }\n  /**\n   * Mark the module as downloading.\n   *\n   * @param id Unique identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Promise resolved when done.\n   */\n  setDownloading(id, siteId) {\n    siteId = siteId || CoreSites.getCurrentSiteId();\n    return CoreFilepool.storePackageStatus(siteId, CoreConstants.DOWNLOADING, this.component, id);\n  }\n  /**\n   * Set previous status and return a rejected promise.\n   *\n   * @param id Unique identifier per component.\n   * @param siteId Site ID. If not defined, current site.\n   * @returns Rejected promise.\n   */\n  setPreviousStatus(id, siteId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      siteId = siteId || CoreSites.getCurrentSiteId();\n      yield CoreFilepool.setPackagePreviousStatus(siteId, _this3.component, id);\n    })();\n  }\n}","map":{"version":3,"names":["CoreConstants","CoreNetworkError","CoreFilterHelper","CoreNetwork","CoreFilepool","CoreSites","CoreCourse","CoreCourseModulePrefetchHandlerBase","CoreCourseActivityPrefetchHandlerBase","download","module","courseId","dirPath","prefetch","single","_asyncToGenerator","prefetchPackage","downloadFunction","siteId","_this","getCurrentSiteId","isOnline","isDownloading","id","getOngoingDownload","prefetchPromise","changeStatusAndPrefetch","addOngoingDownload","_this2","setDownloading","Promise","all","getModuleBasicInfo","getModule","undefined","getFilters","extra","setDownloaded","error","setPreviousStatus","storePackageStatus","DOWNLOADED","component","DOWNLOADING","_this3","setPackagePreviousStatus"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/classes/activity-prefetch-handler.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreConstants } from '@/core/constants';\nimport { CoreNetworkError } from '@classes/errors/network-error';\nimport { CoreFilterHelper } from '@features/filter/services/filter-helper';\nimport { CoreNetwork } from '@services/network';\nimport { CoreFilepool } from '@services/filepool';\nimport { CoreSites } from '@services/sites';\nimport { CoreCourse, CoreCourseAnyModuleData } from '../services/course';\nimport { CoreCourseModulePrefetchHandlerBase } from './module-prefetch-handler';\n\n/**\n * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. It is useful to minimize the amount of\n * functions that handlers need to implement. It also provides some helper features like preventing a module to be\n * downloaded twice at the same time.\n *\n * If your handler inherits from this service, you just need to override the functions that you want to change.\n *\n * This class should be used for ACTIVITIES. You must override the prefetch function, and it's recommended to call\n * prefetchPackage in there since it handles the package status.\n */\nexport class CoreCourseActivityPrefetchHandlerBase extends CoreCourseModulePrefetchHandlerBase {\n\n    /**\n     * Download the module.\n     *\n     * @param module The module object returned by WS.\n     * @param courseId Course ID.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when all content is downloaded.\n     */\n    download(module: CoreCourseAnyModuleData, courseId: number, dirPath?: string): Promise<void> {\n        // Same implementation for download and prefetch.\n        return this.prefetch(module, courseId, false, dirPath);\n    }\n\n    /**\n     * Prefetch a module.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param single True if we're downloading a single module, false if we're downloading a whole section.\n     * @param dirPath Path of the directory where to store all the content files.\n     * @returns Promise resolved when done.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async prefetch(module: CoreCourseAnyModuleData, courseId?: number, single?: boolean, dirPath?: string): Promise<void> {\n        // To be overridden. It should call prefetchPackage\n        return;\n    }\n\n    /**\n     * Prefetch the module, setting package status at start and finish.\n     *\n     * Example usage from a child instance:\n     *     return this.prefetchPackage(module, courseId, (siteId) => this.prefetchModule(module, otherParam, siteId), siteId);\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param downloadFunction Function to perform the prefetch. It can return a string to be stored as the package \"extra\" data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the module has been downloaded. Data returned is not reliable.\n     */\n    async prefetchPackage(\n        module: CoreCourseAnyModuleData,\n        courseId: number,\n        downloadFunction: (siteId: string) => Promise<string | void>,\n        siteId?: string,\n    ): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        if (!CoreNetwork.isOnline()) {\n            // Cannot prefetch in offline.\n            throw new CoreNetworkError();\n        }\n\n        if (this.isDownloading(module.id, siteId)) {\n            // There's already a download ongoing for this module, return the promise.\n            return this.getOngoingDownload(module.id, siteId);\n        }\n\n        const prefetchPromise = this.changeStatusAndPrefetch(module, courseId, downloadFunction, siteId);\n\n        return this.addOngoingDownload(module.id, prefetchPromise, siteId);\n    }\n\n    /**\n     * Change module status and call the prefetch function.\n     *\n     * @param module Module.\n     * @param courseId Course ID the module belongs to.\n     * @param downloadFunction Function to perform the prefetch. It can return a string to be stored as the package \"extra\" data.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when the module has been downloaded. Data returned is not reliable.\n     */\n    protected async changeStatusAndPrefetch(\n        module: CoreCourseAnyModuleData,\n        courseId: number | undefined,\n        downloadFunction: (siteId: string) => Promise<string | void>,\n        siteId: string,\n    ): Promise<void> {\n        try {\n            await this.setDownloading(module.id, siteId);\n\n            // Package marked as downloading, get module info to be able to handle links. Get module filters too.\n            await Promise.all([\n                CoreCourse.getModuleBasicInfo(module.id, { siteId }),\n                CoreCourse.getModule(module.id, courseId, undefined, false, true, siteId),\n                CoreFilterHelper.getFilters('module', module.id, { courseId }),\n            ]);\n\n            // Call the download function.\n            let extra = await downloadFunction(siteId);\n\n            // Only accept string types.\n            if (typeof extra != 'string') {\n                extra = '';\n            }\n\n            // Prefetch finished, mark as downloaded.\n            await this.setDownloaded(module.id, siteId, extra);\n        } catch (error) {\n            // Error prefetching, go back to previous status and reject the promise.\n            await this.setPreviousStatus(module.id, siteId);\n\n            throw error;\n        }\n    }\n\n    /**\n     * Mark the module as downloaded.\n     *\n     * @param id Unique identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @param extra Extra data to store.\n     * @returns Promise resolved when done.\n     */\n    setDownloaded(id: number, siteId?: string, extra?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        return CoreFilepool.storePackageStatus(siteId, CoreConstants.DOWNLOADED, this.component, id, extra);\n    }\n\n    /**\n     * Mark the module as downloading.\n     *\n     * @param id Unique identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved when done.\n     */\n    setDownloading(id: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        return CoreFilepool.storePackageStatus(siteId, CoreConstants.DOWNLOADING, this.component, id);\n    }\n\n    /**\n     * Set previous status and return a rejected promise.\n     *\n     * @param id Unique identifier per component.\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Rejected promise.\n     */\n    async setPreviousStatus(id: number, siteId?: string): Promise<void> {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n\n        await CoreFilepool.setPackagePreviousStatus(siteId, this.component, id);\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}