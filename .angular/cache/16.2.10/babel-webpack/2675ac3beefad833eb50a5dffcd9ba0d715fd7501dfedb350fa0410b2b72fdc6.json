{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { SQLite } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreDB } from '@services/db';\nimport { CorePlatform } from '@services/platform';\n/**\n * Class to interact with the local database.\n *\n * @description\n * This class allows creating and interacting with a SQLite database.\n *\n * You need to supply some dependencies when creating the instance:\n * this.db = new SQLiteDB('MyDB');\n */\nexport class SQLiteDB {\n  /**\n   * Constructs 'IN()' or '=' sql fragment\n   *\n   * @param items A single value or array of values for the expression. It doesn't accept objects.\n   * @param equal True means we want to equate to the constructed expression.\n   * @param onEmptyItems This defines the behavior when the array of items provided is empty. Defaults to false,\n   *                     meaning return empty. Other values will become part of the returned SQL fragment.\n   * @returns A list containing the constructed sql fragment and an array of parameters.\n   */\n  static getInOrEqual(items, equal = true, onEmptyItems) {\n    let sql = '';\n    let params;\n    // Default behavior, return empty data on empty array.\n    if (Array.isArray(items) && !items.length && onEmptyItems === undefined) {\n      return {\n        sql: '',\n        params: []\n      };\n    }\n    // Handle onEmptyItems on empty array of items.\n    if (Array.isArray(items) && !items.length) {\n      if (onEmptyItems === null) {\n        // Special case, NULL value.\n        sql = equal ? ' IS NULL' : ' IS NOT NULL';\n        return {\n          sql,\n          params: []\n        };\n      } else {\n        items = [onEmptyItems]; // Rest of cases, prepare items for processing.\n      }\n    }\n\n    if (!Array.isArray(items) || items.length == 1) {\n      sql = equal ? '= ?' : '<> ?';\n      params = Array.isArray(items) ? items : [items];\n    } else {\n      const questionMarks = ',?'.repeat(items.length).substring(1);\n      sql = (equal ? '' : 'NOT ') + `IN (${questionMarks})`;\n      params = items;\n    }\n    return {\n      sql,\n      params\n    };\n  }\n  /**\n   * Create and open the database.\n   *\n   * @param name Database name.\n   */\n  constructor(name) {\n    this.name = name;\n    this.init();\n  }\n  /**\n   * Add a column to an existing table.\n   *\n   * @param table Table name.\n   * @param column Name of the column to add.\n   * @param type Type of the column to add.\n   * @param constraints Other constraints (e.g. NOT NULL).\n   * @returns Promise resolved when done.\n   */\n  addColumn(table, column, type, constraints) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      constraints = constraints || '';\n      try {\n        yield _this.execute(`ALTER TABLE ${table} ADD COLUMN ${column} ${type} ${constraints}`);\n      } catch (error) {\n        if (error && error.code == 5 && (error === null || error === void 0 ? void 0 : error.message.indexOf('duplicate column name')) != -1) {\n          // Column already exists.\n          return;\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Helper function to create a table if it doesn't exist.\n   *\n   * @param name The table name.\n   * @param columns The columns to create in the table.\n   * @param primaryKeys Names of columns that are primary key. Use it for compound primary keys.\n   * @param uniqueKeys List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].\n   * @param foreignKeys List of foreign keys.\n   * @param tableCheck Check constraint for the table.\n   * @returns SQL query.\n   */\n  buildCreateTableSql(name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck) {\n    const columnsSql = [];\n    let tableStructureSQL = '';\n    // First define all the columns.\n    for (const index in columns) {\n      const column = columns[index];\n      let columnSql = column.name || '';\n      if (column.type) {\n        columnSql += ` ${column.type}`;\n      }\n      if (column.primaryKey) {\n        columnSql += ' PRIMARY KEY';\n        if (column.autoIncrement) {\n          columnSql += ' AUTOINCREMENT';\n        }\n      }\n      if (column.notNull) {\n        columnSql += ' NOT NULL';\n      }\n      if (column.unique) {\n        columnSql += ' UNIQUE';\n      }\n      if (column.check) {\n        columnSql += ` CHECK (${column.check})`;\n      }\n      if (column.default !== undefined) {\n        columnSql += ` DEFAULT ${column.default}`;\n      }\n      columnsSql.push(columnSql);\n    }\n    tableStructureSQL += columnsSql.join(', ');\n    // Now add the table constraints.\n    if (primaryKeys && primaryKeys.length) {\n      tableStructureSQL += `, PRIMARY KEY (${primaryKeys.join(', ')})`;\n    }\n    if (uniqueKeys && uniqueKeys.length) {\n      for (const index in uniqueKeys) {\n        const setOfKeys = uniqueKeys[index];\n        if (setOfKeys && setOfKeys.length) {\n          tableStructureSQL += `, UNIQUE (${setOfKeys.join(', ')})`;\n        }\n      }\n    }\n    if (tableCheck) {\n      tableStructureSQL += `, CHECK (${tableCheck})`;\n    }\n    for (const index in foreignKeys) {\n      const foreignKey = foreignKeys[index];\n      if (!(foreignKey !== null && foreignKey !== void 0 && foreignKey.columns.length)) {\n        continue;\n      }\n      tableStructureSQL += `, FOREIGN KEY (${foreignKey.columns.join(', ')}) REFERENCES ${foreignKey.table} `;\n      if (foreignKey.foreignColumns && foreignKey.foreignColumns.length) {\n        tableStructureSQL += `(${foreignKey.foreignColumns.join(', ')})`;\n      }\n      if (foreignKey.actions) {\n        tableStructureSQL += ` ${foreignKey.actions}`;\n      }\n    }\n    return `CREATE TABLE IF NOT EXISTS ${name} (${tableStructureSQL})`;\n  }\n  /**\n   * Close the database.\n   *\n   * @returns Promise resolved when done.\n   */\n  close() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _this2$db;\n      yield _this2.ready();\n      yield (_this2$db = _this2.db) === null || _this2$db === void 0 ? void 0 : _this2$db.close();\n    })();\n  }\n  /**\n   * Count the records in a table where all the given conditions met.\n   *\n   * @param table The table to query.\n   * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n   * @returns Promise resolved with the count of records returned from the specified criteria.\n   */\n  countRecords(table, conditions) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const selectAndParams = _this3.whereClause(conditions);\n      return _this3.countRecordsSelect(table, selectAndParams.sql, selectAndParams.params);\n    })();\n  }\n  /**\n   * Count the records in a table which match a particular WHERE clause.\n   *\n   * @param table The table to query.\n   * @param select A fragment of SQL to be used in a where clause in the SQL call.\n   * @param params An array of sql parameters.\n   * @param countItem The count string to be used in the SQL call. Default is COUNT('x').\n   * @returns Promise resolved with the count of records returned from the specified criteria.\n   */\n  countRecordsSelect(table, select = '', params, countItem = 'COUNT(\\'x\\')') {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (select) {\n        select = `WHERE ${select}`;\n      }\n      return _this4.countRecordsSql(`SELECT ${countItem} FROM ${table} ${select}`, params);\n    })();\n  }\n  /**\n   * Get the result of a SQL SELECT COUNT(...) query.\n   *\n   * Given a query that counts rows, return that count.\n   *\n   * @param sql The SQL string you wish to be executed.\n   * @param params An array of sql parameters.\n   * @returns Promise resolved with the count.\n   */\n  countRecordsSql(sql, params) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const count = yield _this5.getFieldSql(sql, params);\n      if (typeof count != 'number' || count < 0) {\n        return 0;\n      }\n      return count;\n    })();\n  }\n  /**\n   * Create a table if it doesn't exist.\n   *\n   * @param name The table name.\n   * @param columns The columns to create in the table.\n   * @param primaryKeys Names of columns that are primary key. Use it for compound primary keys.\n   * @param uniqueKeys List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].\n   * @param foreignKeys List of foreign keys.\n   * @param tableCheck Check constraint for the table.\n   * @returns Promise resolved when success.\n   */\n  createTable(name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const sql = _this6.buildCreateTableSql(name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck);\n      yield _this6.execute(sql);\n    })();\n  }\n  /**\n   * Create a table if it doesn't exist from a schema.\n   *\n   * @param table Table schema.\n   * @returns Promise resolved when success.\n   */\n  createTableFromSchema(table) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield _this7.createTable(table.name, table.columns, table.primaryKeys, table.uniqueKeys, table.foreignKeys, table.tableCheck);\n    })();\n  }\n  /**\n   * Create several tables if they don't exist from a list of schemas.\n   *\n   * @param tables List of table schema.\n   * @returns Promise resolved when success.\n   */\n  createTablesFromSchema(tables) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const promises = tables.map(table => _this8.createTableFromSchema(table));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Delete the records from a table where all the given conditions met.\n   * If conditions not specified, table is truncated.\n   *\n   * @param table The table to delete from.\n   * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n   * @returns Promise resolved with the number of affected rows.\n   */\n  deleteRecords(table, conditions) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (conditions === null || conditions === undefined) {\n        // No conditions, delete the whole table.\n        const result = yield _this9.execute(`DELETE FROM ${table}`);\n        return result.rowsAffected;\n      }\n      const selectAndParams = _this9.whereClause(conditions);\n      return _this9.deleteRecordsSelect(table, selectAndParams.sql, selectAndParams.params);\n    })();\n  }\n  /**\n   * Delete the records from a table where one field match one list of values.\n   *\n   * @param table The table to delete from.\n   * @param field The name of a field.\n   * @param values The values field might take.\n   * @returns Promise resolved with the number of affected rows.\n   */\n  deleteRecordsList(table, field, values) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const selectAndParams = _this10.whereClauseList(field, values);\n      return _this10.deleteRecordsSelect(table, selectAndParams.sql, selectAndParams.params);\n    })();\n  }\n  /**\n   * Delete one or more records from a table which match a particular WHERE clause.\n   *\n   * @param table The table to delete from.\n   * @param select A fragment of SQL to be used in a where clause in the SQL call.\n   * @param params Array of sql parameters.\n   * @returns Promise resolved with the number of affected rows.\n   */\n  deleteRecordsSelect(table, select = '', params) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (select) {\n        select = `WHERE ${select}`;\n      }\n      const result = yield _this11.execute(`DELETE FROM ${table} ${select}`, params);\n      return result.rowsAffected;\n    })();\n  }\n  /**\n   * Drop a table if it exists.\n   *\n   * @param name The table name.\n   * @returns Promise resolved when success.\n   */\n  dropTable(name) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      yield _this12.execute(`DROP TABLE IF EXISTS ${name}`);\n    })();\n  }\n  /**\n   * Execute a SQL query.\n   * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that\n   * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.\n   *\n   * @param sql SQL query to execute.\n   * @param params Query parameters.\n   * @returns Promise resolved with the result.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  execute(sql, params) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      var _this13$db;\n      yield _this13.ready();\n      return (_this13$db = _this13.db) === null || _this13$db === void 0 ? void 0 : _this13$db.executeSql(sql, params);\n    })();\n  }\n  /**\n   * Execute a set of SQL queries. This operation is atomic.\n   * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that\n   * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.\n   *\n   * @param sqlStatements SQL statements to execute.\n   * @returns Promise resolved with the result.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  executeBatch(sqlStatements) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      var _this14$db;\n      yield _this14.ready();\n      yield (_this14$db = _this14.db) === null || _this14$db === void 0 ? void 0 : _this14$db.sqlBatch(sqlStatements);\n    })();\n  }\n  /**\n   * Format the data to insert in the database. Removes undefined entries so they are stored as null instead of 'undefined'.\n   *\n   * @param data Data to insert.\n   */\n  formatDataToInsert(data) {\n    if (!data) {\n      return;\n    }\n    // Remove undefined entries.\n    Object.keys(data).forEach(key => data[key] === undefined && delete data[key]);\n  }\n  /**\n   * Get all the records from a table.\n   *\n   * @param table The table to query.\n   * @returns Promise resolved with the records.\n   */\n  getAllRecords(table) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      return _this15.getRecords(table);\n    })();\n  }\n  /**\n   * Get a single field value from a table record where all the given conditions met.\n   *\n   * @param table The table to query.\n   * @param field The field to return the value of.\n   * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n   * @returns Promise resolved with the field's value.\n   */\n  getField(table, field, conditions) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const selectAndParams = _this16.whereClause(conditions);\n      return _this16.getFieldSelect(table, field, selectAndParams.sql, selectAndParams.params);\n    })();\n  }\n  /**\n   * Get a single field value from a table record which match a particular WHERE clause.\n   *\n   * @param table The table to query.\n   * @param field The field to return the value of.\n   * @param select A fragment of SQL to be used in a where clause returning one row with one column.\n   * @param params Array of sql parameters.\n   * @returns Promise resolved with the field's value.\n   */\n  getFieldSelect(table, field, select = '', params) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      if (select) {\n        select = `WHERE ${select}`;\n      }\n      return _this17.getFieldSql(`SELECT ${field} FROM ${table} ${select}`, params);\n    })();\n  }\n  /**\n   * Get a single field value (first field) using a SQL statement.\n   *\n   * @param sql The SQL query returning one row with one column.\n   * @param params An array of sql parameters.\n   * @returns Promise resolved with the field's value.\n   */\n  getFieldSql(sql, params) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const record = yield _this18.getRecordSql(sql, params);\n      if (!record) {\n        throw new CoreError('No record found.');\n      }\n      return record[Object.keys(record)[0]];\n    })();\n  }\n  /**\n   * Get the database name.\n   *\n   * @returns Database name.\n   */\n  getName() {\n    return this.name;\n  }\n  /**\n   * Get a single database record where all the given conditions met.\n   *\n   * @param table The table to query.\n   * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n   * @param fields A comma separated list of fields to return.\n   * @returns Promise resolved with the record, rejected if not found.\n   */\n  getRecord(table, conditions, fields = '*') {\n    const selectAndParams = this.whereClause(conditions);\n    return this.getRecordSelect(table, selectAndParams.sql, selectAndParams.params, fields);\n  }\n  /**\n   * Get a single database record as an object which match a particular WHERE clause.\n   *\n   * @param table The table to query.\n   * @param select A fragment of SQL to be used in a where clause in the SQL call.\n   * @param params An array of sql parameters.\n   * @param fields A comma separated list of fields to return.\n   * @returns Promise resolved with the record, rejected if not found.\n   */\n  getRecordSelect(table, select = '', params = [], fields = '*') {\n    if (select) {\n      select = ` WHERE ${select}`;\n    }\n    return this.getRecordSql(`SELECT ${fields} FROM ${table} ${select}`, params);\n  }\n  /**\n   * Get a single database record as an object using a SQL statement.\n   *\n   * The SQL statement should normally only return one record.\n   * It is recommended to use getRecordsSql() if more matches possible!\n   *\n   * @param sql The SQL string you wish to be executed, should normally only return one record.\n   * @param params List of sql parameters\n   * @returns Promise resolved with the records.\n   */\n  getRecordSql(sql, params) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this19.getRecordsSql(sql, params, 0, 1);\n      if (!result || !result.length) {\n        // Not found, reject.\n        throw new CoreError('No records found.');\n      }\n      return result[0];\n    })();\n  }\n  /**\n   * Get a number of records where all the given conditions met.\n   *\n   * @param table The table to query.\n   * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n   * @param sort An order to sort the results in.\n   * @param fields A comma separated list of fields to return.\n   * @param limitFrom Return a subset of records, starting at this point.\n   * @param limitNum Return a subset comprising this many records in total.\n   * @returns Promise resolved with the records.\n   */\n  getRecords(table, conditions, sort = '', fields = '*', limitFrom = 0, limitNum = 0) {\n    const selectAndParams = this.whereClause(conditions);\n    return this.getRecordsSelect(table, selectAndParams.sql, selectAndParams.params, sort, fields, limitFrom, limitNum);\n  }\n  /**\n   * Get a number of records where one field match one list of values.\n   *\n   * @param table The database table to be checked against.\n   * @param field The name of a field.\n   * @param values The values field might take.\n   * @param sort An order to sort the results in.\n   * @param fields A comma separated list of fields to return.\n   * @param limitFrom Return a subset of records, starting at this point.\n   * @param limitNum Return a subset comprising this many records in total.\n   * @returns Promise resolved with the records.\n   */\n  getRecordsList(table, field, values, sort = '', fields = '*', limitFrom = 0, limitNum = 0) {\n    const selectAndParams = this.whereClauseList(field, values);\n    return this.getRecordsSelect(table, selectAndParams.sql, selectAndParams.params, sort, fields, limitFrom, limitNum);\n  }\n  /**\n   * Get a number of records which match a particular WHERE clause.\n   *\n   * @param table The table to query.\n   * @param select A fragment of SQL to be used in a where clause in the SQL call.\n   * @param params An array of sql parameters.\n   * @param sort An order to sort the results in.\n   * @param fields A comma separated list of fields to return.\n   * @param limitFrom Return a subset of records, starting at this point.\n   * @param limitNum Return a subset comprising this many records in total.\n   * @returns Promise resolved with the records.\n   */\n  getRecordsSelect(table, select = '', params = [], sort = '', fields = '*', limitFrom = 0, limitNum = 0) {\n    if (select) {\n      select = ` WHERE ${select}`;\n    }\n    if (sort) {\n      sort = ` ORDER BY ${sort}`;\n    }\n    const sql = `SELECT ${fields} FROM ${table} ${select} ${sort}`;\n    return this.getRecordsSql(sql, params, limitFrom, limitNum);\n  }\n  /**\n   * Get a number of records using a SQL statement.\n   *\n   * @param sql The SQL select query to execute.\n   * @param params List of sql parameters\n   * @param limitFrom Return a subset of records, starting at this point.\n   * @param limitNum Return a subset comprising this many records.\n   * @returns Promise resolved with the records.\n   */\n  getRecordsSql(sql, params, limitFrom, limitNum) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const limits = _this20.normaliseLimitFromNum(limitFrom, limitNum);\n      if (limits[0] || limits[1]) {\n        if (limits[1] < 1) {\n          limits[1] = Number.MAX_VALUE;\n        }\n        sql += ` LIMIT ${limits[0]}, ${limits[1]}`;\n      }\n      const result = yield _this20.execute(sql, params);\n      // Retrieve the records.\n      const records = [];\n      for (let i = 0; i < result.rows.length; i++) {\n        records.push(result.rows.item(i));\n      }\n      return records;\n    })();\n  }\n  /**\n   * Given a data object, returns the SQL query and the params to insert that record.\n   *\n   * @param table The database table.\n   * @param data A data object with values for one or more fields in the record.\n   * @returns Array with the SQL query and the params.\n   */\n  getSqlInsertQuery(table, data) {\n    this.formatDataToInsert(data);\n    const keys = Object.keys(data);\n    const fields = keys.join(',');\n    const questionMarks = ',?'.repeat(keys.length).substring(1);\n    return {\n      sql: `INSERT OR REPLACE INTO ${table} (${fields}) VALUES (${questionMarks})`,\n      params: Object.values(data)\n    };\n  }\n  /**\n   * Initialize the database.\n   */\n  init() {\n    this.promise = this.createDatabase().then(db => {\n      if (CoreDB.loggingEnabled()) {\n        const spies = this.getDatabaseSpies(db);\n        db = new Proxy(db, {\n          get: (target, property, receiver) => {\n            var _spies$property;\n            return (_spies$property = spies[property]) !== null && _spies$property !== void 0 ? _spies$property : Reflect.get(target, property, receiver);\n          }\n        });\n      }\n      this.db = db;\n      return;\n    });\n  }\n  /**\n   * Insert a record into a table and return the \"rowId\" field.\n   *\n   * @param table The database table to be inserted into.\n   * @param data A data object with values for one or more fields in the record.\n   * @returns Promise resolved with new rowId. Please notice this rowId is internal from SQLite.\n   */\n  insertRecord(table, data) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const sqlAndParams = _this21.getSqlInsertQuery(table, data);\n      const result = yield _this21.execute(sqlAndParams.sql, sqlAndParams.params);\n      return result.insertId;\n    })();\n  }\n  /**\n   * Insert multiple records into database as fast as possible.\n   *\n   * @param table The database table to be inserted into.\n   * @param dataObjects List of objects to be inserted.\n   * @returns Promise resolved when done.\n   */\n  insertRecords(table, dataObjects) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      if (!Array.isArray(dataObjects)) {\n        throw new CoreError('Invalid parameter supplied to insertRecords, it should be an array.');\n      }\n      const statements = dataObjects.map(dataObject => {\n        const statement = _this22.getSqlInsertQuery(table, dataObject);\n        return [statement.sql, statement.params];\n      });\n      yield _this22.executeBatch(statements);\n    })();\n  }\n  /**\n   * Insert multiple records into database from another table.\n   *\n   * @param table The database table to be inserted into.\n   * @param source The database table to get the records from.\n   * @returns Promise resolved when done.\n   */\n  insertRecordsFrom(table, source) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const records = yield _this23.getAllRecords(source);\n      yield Promise.all(records.map(record => _this23.insertRecord(table, record)));\n    })();\n  }\n  /**\n   * Migrate all the data from a table to another table.\n   * It will check if old table exists and drop it when finished.\n   *\n   * @param oldTable Old table name.\n   * @param newTable New table name.\n   * @param mapCallback Mapping callback to migrate each record.\n   * @returns Resolved when done.\n   */\n  migrateTable(oldTable, newTable, mapCallback) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this24.tableExists(oldTable);\n      } catch (_unused) {\n        // Old table does not exist, ignore.\n        return;\n      }\n      // Move the records from the old table.\n      if (mapCallback) {\n        const records = yield _this24.getAllRecords(oldTable);\n        const promises = records.map(record => {\n          record = mapCallback(record);\n          return _this24.insertRecord(newTable, record);\n        });\n        yield Promise.all(promises);\n      } else {\n        // No changes needed.\n        yield _this24.insertRecordsFrom(newTable, oldTable);\n      }\n      try {\n        yield _this24.dropTable(oldTable);\n      } catch (_unused2) {\n        // Error deleting old table, ignore.\n      }\n    })();\n  }\n  /**\n   * Ensures that limit params are numeric and positive integers, to be passed to the database.\n   * We explicitly treat null, '' and -1 as 0 in order to provide compatibility with how limit\n   * values have been passed historically.\n   *\n   * @param limitFrom Where to start results from.\n   * @param limitNum How many results to return.\n   * @returns Normalised limit params in array: [limitFrom, limitNum].\n   */\n  normaliseLimitFromNum(limitFrom, limitNum) {\n    // We explicilty treat these cases as 0.\n    if (!limitFrom || limitFrom === -1) {\n      limitFrom = 0;\n    } else {\n      limitFrom = Math.max(0, limitFrom);\n    }\n    if (!limitNum || limitNum === -1) {\n      limitNum = 0;\n    } else {\n      limitNum = Math.max(0, limitNum);\n    }\n    return [limitFrom, limitNum];\n  }\n  /**\n   * Open the database. Only needed if it was closed before, a database is automatically opened when created.\n   *\n   * @returns Promise resolved when open.\n   */\n  open() {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      var _this25$db;\n      yield _this25.ready();\n      yield (_this25$db = _this25.db) === null || _this25$db === void 0 ? void 0 : _this25$db.open();\n    })();\n  }\n  /**\n   * Wait for the DB to be ready.\n   *\n   * @returns Promise resolved when ready.\n   */\n  ready() {\n    return this.promise;\n  }\n  /**\n   * Test whether a record exists in a table where all the given conditions met.\n   *\n   * @param table The table to check.\n   * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n   * @returns Promise resolved if exists, rejected otherwise.\n   */\n  recordExists(table, conditions) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const record = yield _this26.getRecord(table, conditions);\n      if (!record) {\n        throw new CoreError('Record does not exist.');\n      }\n    })();\n  }\n  /**\n   * Test whether any records exists in a table which match a particular WHERE clause.\n   *\n   * @param table The table to query.\n   * @param select A fragment of SQL to be used in a where clause in the SQL call.\n   * @param params An array of sql parameters.\n   * @returns Promise resolved if exists, rejected otherwise.\n   */\n  recordExistsSelect(table, select = '', params = []) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const record = yield _this27.getRecordSelect(table, select, params);\n      if (!record) {\n        throw new CoreError('Record does not exist.');\n      }\n    })();\n  }\n  /**\n   * Test whether a SQL SELECT statement returns any records.\n   *\n   * @param sql The SQL query returning one row with one column.\n   * @param params An array of sql parameters.\n   * @returns Promise resolved if exists, rejected otherwise.\n   */\n  recordExistsSql(sql, params) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      const record = yield _this28.getRecordSql(sql, params);\n      if (!record) {\n        throw new CoreError('Record does not exist.');\n      }\n    })();\n  }\n  /**\n   * Test whether a table exists..\n   *\n   * @param name The table name.\n   * @returns Promise resolved if exists, rejected otherwise.\n   */\n  tableExists(name) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      yield _this29.recordExists('sqlite_master', {\n        type: 'table',\n        tbl_name: name\n      });\n    })();\n  }\n  /**\n   * Update one or more records in a table.\n   *\n   * @param table The database table to update.\n   * @param data An object with the fields to update: fieldname=>fieldvalue.\n   * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n   * @returns Promise resolved with the number of affected rows.\n   */\n  updateRecords(table, data, conditions) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      const whereAndParams = _this30.whereClause(conditions);\n      return _this30.updateRecordsWhere(table, data, whereAndParams.sql, whereAndParams.params);\n    })();\n  }\n  /**\n   * Update one or more records in a table. It accepts a WHERE clause as a string.\n   *\n   * @param table The database table to update.\n   * @param data An object with the fields to update: fieldname=>fieldvalue.\n   * @param where Where clause. Must not include the \"WHERE\" word.\n   * @param whereParams Params for the where clause.\n   * @returns Promise resolved with the number of affected rows.\n   */\n  updateRecordsWhere(table, data, where, whereParams) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      _this31.formatDataToInsert(data);\n      if (!data || !Object.keys(data).length) {\n        // No fields to update, consider it's done.\n        return 0;\n      }\n      const sets = Object.keys(data).map(key => `${key} = ?`);\n      let sql = `UPDATE ${table} SET ${sets.join(', ')}`;\n      if (where) {\n        sql += ` WHERE ${where}`;\n      }\n      // Create the list of params using the \"data\" object and the params for the where clause.\n      let params = Object.values(data);\n      if (where && whereParams) {\n        params = params.concat(whereParams);\n      }\n      const result = yield _this31.execute(sql, params);\n      return result.rowsAffected;\n    })();\n  }\n  /**\n   * Returns the SQL WHERE conditions.\n   *\n   * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n   * @returns An array list containing sql 'where' part and 'params'.\n   */\n  whereClause(conditions = {}) {\n    if (!conditions || !Object.keys(conditions).length) {\n      return {\n        sql: '1 = 1',\n        params: []\n      };\n    }\n    const params = [];\n    const where = Object.keys(conditions).map(field => {\n      const value = conditions[field];\n      if (value === undefined || value === null) {\n        return `${field} IS NULL`;\n      }\n      params.push(value);\n      return `${field} = ?`;\n    });\n    return {\n      sql: where.join(' AND '),\n      params\n    };\n  }\n  /**\n   * Returns SQL WHERE conditions for the ..._list group of methods.\n   *\n   * @param field The name of a field.\n   * @param values The values field might take.\n   * @returns An array containing sql 'where' part and 'params'.\n   */\n  whereClauseList(field, values) {\n    if (!values || !values.length) {\n      return {\n        sql: '1 = 2',\n        params: []\n      };\n    }\n    const params = [];\n    let sql = '';\n    values.forEach(value => {\n      if (value === undefined || value === null) {\n        sql = `${field} IS NULL`;\n      } else {\n        params.push(value);\n      }\n    });\n    if (params && params.length) {\n      if (sql !== '') {\n        sql += ' OR ';\n      }\n      if (params.length == 1) {\n        sql += `${field} = ?`;\n      } else {\n        const questionMarks = ',?'.repeat(params.length).substring(1);\n        sql += ` ${field} IN (${questionMarks})`;\n      }\n    }\n    return {\n      sql,\n      params\n    };\n  }\n  /**\n   * Open a database connection.\n   *\n   * @returns Database.\n   */\n  createDatabase() {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      yield CorePlatform.ready();\n      return SQLite.create({\n        name: _this32.name,\n        location: 'default'\n      });\n    })();\n  }\n  /**\n   * Get database spy methods to intercept database calls and track logging information.\n   *\n   * @param db Database to spy.\n   * @returns Spy methods.\n   */\n  getDatabaseSpies(db) {\n    const dbName = this.name;\n    return {\n      executeSql(statement, params) {\n        return _asyncToGenerator(function* () {\n          const start = performance.now();\n          try {\n            const result = yield db.executeSql(statement, params);\n            CoreDB.logQuery({\n              params,\n              sql: statement,\n              duration: performance.now() - start,\n              dbName\n            });\n            return result;\n          } catch (error) {\n            CoreDB.logQuery({\n              params,\n              error,\n              sql: statement,\n              duration: performance.now() - start,\n              dbName\n            });\n            throw error;\n          }\n        })();\n      },\n      sqlBatch(statements) {\n        return _asyncToGenerator(function* () {\n          const start = performance.now();\n          const sql = Array.isArray(statements) ? statements.join(' | ') : String(statements);\n          try {\n            const result = yield db.sqlBatch(statements);\n            CoreDB.logQuery({\n              sql,\n              duration: performance.now() - start,\n              dbName\n            });\n            return result;\n          } catch (error) {\n            CoreDB.logQuery({\n              sql,\n              error,\n              duration: performance.now() - start,\n              dbName\n            });\n            throw error;\n          }\n        })();\n      }\n    };\n  }\n}","map":{"version":3,"names":["SQLite","CoreError","CoreDB","CorePlatform","SQLiteDB","getInOrEqual","items","equal","onEmptyItems","sql","params","Array","isArray","length","undefined","questionMarks","repeat","substring","constructor","name","init","addColumn","table","column","type","constraints","_this","_asyncToGenerator","execute","error","code","message","indexOf","buildCreateTableSql","columns","primaryKeys","uniqueKeys","foreignKeys","tableCheck","columnsSql","tableStructureSQL","index","columnSql","primaryKey","autoIncrement","notNull","unique","check","default","push","join","setOfKeys","foreignKey","foreignColumns","actions","close","_this2","_this2$db","ready","db","countRecords","conditions","_this3","selectAndParams","whereClause","countRecordsSelect","select","countItem","_this4","countRecordsSql","_this5","count","getFieldSql","createTable","_this6","createTableFromSchema","_this7","createTablesFromSchema","tables","_this8","promises","map","Promise","all","deleteRecords","_this9","result","rowsAffected","deleteRecordsSelect","deleteRecordsList","field","values","_this10","whereClauseList","_this11","dropTable","_this12","_this13","_this13$db","executeSql","executeBatch","sqlStatements","_this14","_this14$db","sqlBatch","formatDataToInsert","data","Object","keys","forEach","key","getAllRecords","_this15","getRecords","getField","_this16","getFieldSelect","_this17","_this18","record","getRecordSql","getName","getRecord","fields","getRecordSelect","_this19","getRecordsSql","sort","limitFrom","limitNum","getRecordsSelect","getRecordsList","_this20","limits","normaliseLimitFromNum","Number","MAX_VALUE","records","i","rows","item","getSqlInsertQuery","promise","createDatabase","then","loggingEnabled","spies","getDatabaseSpies","Proxy","get","target","property","receiver","_spies$property","Reflect","insertRecord","_this21","sqlAndParams","insertId","insertRecords","dataObjects","_this22","statements","dataObject","statement","insertRecordsFrom","source","_this23","migrateTable","oldTable","newTable","mapCallback","_this24","tableExists","_unused","_unused2","Math","max","open","_this25","_this25$db","recordExists","_this26","recordExistsSelect","_this27","recordExistsSql","_this28","_this29","tbl_name","updateRecords","_this30","whereAndParams","updateRecordsWhere","where","whereParams","_this31","sets","concat","value","_this32","create","location","dbName","start","performance","now","logQuery","duration","String"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/sqlitedb.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { SQLiteObject } from '@awesome-cordova-plugins/sqlite/ngx';\n\nimport { SQLite } from '@singletons';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreDB } from '@services/db';\nimport { CorePlatform } from '@services/platform';\n\ntype SQLiteDBColumnType = 'INTEGER' | 'REAL' | 'TEXT' | 'BLOB';\n\n/**\n * Schema of a table.\n */\nexport interface SQLiteDBTableSchema {\n    /**\n     * The table name.\n     */\n    name: string;\n\n    /**\n     * The columns to create in the table.\n     */\n    columns: SQLiteDBColumnSchema[];\n\n    /**\n     * Names of columns that are primary key. Use it for compound primary keys.\n     */\n    primaryKeys?: string[];\n\n    /**\n     * List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].\n     */\n    uniqueKeys?: string[][];\n\n    /**\n     * List of foreign keys.\n     */\n    foreignKeys?: SQLiteDBForeignKeySchema[];\n\n    /**\n     * Check constraint for the table.\n     */\n    tableCheck?: string;\n}\n\n/**\n * Schema of a column.\n */\nexport interface SQLiteDBColumnSchema {\n    /**\n     * Column's name.\n     */\n    name: string;\n\n    /**\n     * Column's type.\n     */\n    type?: SQLiteDBColumnType;\n\n    /**\n     * Whether the column is a primary key. Use it only if primary key is a single column.\n     */\n    primaryKey?: boolean;\n\n    /**\n     * Whether it should be autoincremented. Only if primaryKey is true.\n     */\n    autoIncrement?: boolean;\n\n    /**\n     * True if column shouldn't be null.\n     */\n    notNull?: boolean;\n\n    /**\n     * WWhether the column is unique.\n     */\n    unique?: boolean;\n\n    /**\n     * Check constraint for the column.\n     */\n    check?: string;\n\n    /**\n     * Default value for the column.\n     */\n    default?: string;\n}\n\n/**\n * Schema of a foreign key.\n */\nexport interface SQLiteDBForeignKeySchema {\n    /**\n     * Columns to include in this foreign key.\n     */\n    columns: string[];\n\n    /**\n     * The external table referenced by this key.\n     */\n    table: string;\n\n    /**\n     * List of referenced columns from the referenced table.\n     */\n    foreignColumns?: string[];\n\n    /**\n     * Text with the actions to apply to the foreign key.\n     */\n    actions?: string;\n}\n\n/**\n * Class to interact with the local database.\n *\n * @description\n * This class allows creating and interacting with a SQLite database.\n *\n * You need to supply some dependencies when creating the instance:\n * this.db = new SQLiteDB('MyDB');\n */\nexport class SQLiteDB {\n\n    /**\n     * Constructs 'IN()' or '=' sql fragment\n     *\n     * @param items A single value or array of values for the expression. It doesn't accept objects.\n     * @param equal True means we want to equate to the constructed expression.\n     * @param onEmptyItems This defines the behavior when the array of items provided is empty. Defaults to false,\n     *                     meaning return empty. Other values will become part of the returned SQL fragment.\n     * @returns A list containing the constructed sql fragment and an array of parameters.\n     */\n    static getInOrEqual(\n        items: SQLiteDBRecordValue | SQLiteDBRecordValue[],\n        equal: boolean = true,\n        onEmptyItems?: SQLiteDBRecordValue | null,\n    ): SQLiteDBQueryParams {\n        let sql = '';\n        let params: SQLiteDBRecordValue[];\n\n        // Default behavior, return empty data on empty array.\n        if (Array.isArray(items) && !items.length && onEmptyItems === undefined) {\n            return { sql: '', params: [] };\n        }\n\n        // Handle onEmptyItems on empty array of items.\n        if (Array.isArray(items) && !items.length) {\n            if (onEmptyItems === null) { // Special case, NULL value.\n                sql = equal ? ' IS NULL' : ' IS NOT NULL';\n\n                return { sql, params: [] };\n            } else {\n                items = [onEmptyItems as SQLiteDBRecordValue]; // Rest of cases, prepare items for processing.\n            }\n        }\n\n        if (!Array.isArray(items) || items.length == 1) {\n            sql = equal ? '= ?' : '<> ?';\n            params = Array.isArray(items) ? items : [items];\n        } else {\n            const questionMarks = ',?'.repeat(items.length).substring(1);\n            sql = (equal ? '' : 'NOT ') + `IN (${questionMarks})`;\n            params = items;\n        }\n\n        return { sql, params };\n    }\n\n    db?: SQLiteObject;\n    promise!: Promise<void>;\n\n    /**\n     * Create and open the database.\n     *\n     * @param name Database name.\n     */\n    constructor(public name: string) {\n        this.init();\n    }\n\n    /**\n     * Add a column to an existing table.\n     *\n     * @param table Table name.\n     * @param column Name of the column to add.\n     * @param type Type of the column to add.\n     * @param constraints Other constraints (e.g. NOT NULL).\n     * @returns Promise resolved when done.\n     */\n    async addColumn(table: string, column: string, type: SQLiteDBColumnType, constraints?: string): Promise<void> {\n        constraints = constraints || '';\n\n        try {\n            await this.execute(`ALTER TABLE ${table} ADD COLUMN ${column} ${type} ${constraints}`);\n        } catch (error) {\n            if (error && error.code == 5 && error?.message.indexOf('duplicate column name') != -1) {\n                // Column already exists.\n                return;\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Helper function to create a table if it doesn't exist.\n     *\n     * @param name The table name.\n     * @param columns The columns to create in the table.\n     * @param primaryKeys Names of columns that are primary key. Use it for compound primary keys.\n     * @param uniqueKeys List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].\n     * @param foreignKeys List of foreign keys.\n     * @param tableCheck Check constraint for the table.\n     * @returns SQL query.\n     */\n    buildCreateTableSql(\n        name: string,\n        columns: SQLiteDBColumnSchema[],\n        primaryKeys?: string[],\n        uniqueKeys?: string[][],\n        foreignKeys?: SQLiteDBForeignKeySchema[],\n        tableCheck?: string,\n    ): string {\n        const columnsSql: string[] = [];\n        let tableStructureSQL = '';\n\n        // First define all the columns.\n        for (const index in columns) {\n            const column = columns[index];\n            let columnSql: string = column.name || '';\n\n            if (column.type) {\n                columnSql += ` ${column.type}`;\n            }\n\n            if (column.primaryKey) {\n                columnSql += ' PRIMARY KEY';\n                if (column.autoIncrement) {\n                    columnSql += ' AUTOINCREMENT';\n                }\n            }\n\n            if (column.notNull) {\n                columnSql += ' NOT NULL';\n            }\n\n            if (column.unique) {\n                columnSql += ' UNIQUE';\n            }\n\n            if (column.check) {\n                columnSql += ` CHECK (${column.check})`;\n            }\n\n            if (column.default !== undefined) {\n                columnSql += ` DEFAULT ${column.default}`;\n            }\n\n            columnsSql.push(columnSql);\n        }\n        tableStructureSQL += columnsSql.join(', ');\n\n        // Now add the table constraints.\n\n        if (primaryKeys && primaryKeys.length) {\n            tableStructureSQL += `, PRIMARY KEY (${primaryKeys.join(', ')})`;\n        }\n\n        if (uniqueKeys && uniqueKeys.length) {\n            for (const index in uniqueKeys) {\n                const setOfKeys = uniqueKeys[index];\n                if (setOfKeys && setOfKeys.length) {\n                    tableStructureSQL += `, UNIQUE (${setOfKeys.join(', ')})`;\n                }\n            }\n        }\n\n        if (tableCheck) {\n            tableStructureSQL += `, CHECK (${tableCheck})`;\n        }\n\n        for (const index in foreignKeys) {\n            const foreignKey = foreignKeys[index];\n\n            if (!foreignKey?.columns.length) {\n                continue;\n            }\n\n            tableStructureSQL += `, FOREIGN KEY (${foreignKey.columns.join(', ')}) REFERENCES ${foreignKey.table} `;\n\n            if (foreignKey.foreignColumns && foreignKey.foreignColumns.length) {\n                tableStructureSQL += `(${foreignKey.foreignColumns.join(', ')})`;\n            }\n\n            if (foreignKey.actions) {\n                tableStructureSQL += ` ${foreignKey.actions}`;\n            }\n        }\n\n        return `CREATE TABLE IF NOT EXISTS ${name} (${tableStructureSQL})`;\n    }\n\n    /**\n     * Close the database.\n     *\n     * @returns Promise resolved when done.\n     */\n    async close(): Promise<void> {\n        await this.ready();\n\n        await this.db?.close();\n    }\n\n    /**\n     * Count the records in a table where all the given conditions met.\n     *\n     * @param table The table to query.\n     * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n     * @returns Promise resolved with the count of records returned from the specified criteria.\n     */\n    async countRecords(table: string, conditions?: SQLiteDBRecordValues): Promise<number> {\n        const selectAndParams = this.whereClause(conditions);\n\n        return this.countRecordsSelect(table, selectAndParams.sql, selectAndParams.params);\n    }\n\n    /**\n     * Count the records in a table which match a particular WHERE clause.\n     *\n     * @param table The table to query.\n     * @param select A fragment of SQL to be used in a where clause in the SQL call.\n     * @param params An array of sql parameters.\n     * @param countItem The count string to be used in the SQL call. Default is COUNT('x').\n     * @returns Promise resolved with the count of records returned from the specified criteria.\n     */\n    async countRecordsSelect(\n        table: string,\n        select: string = '',\n        params?: SQLiteDBRecordValue[],\n        countItem: string = 'COUNT(\\'x\\')',\n    ): Promise<number> {\n        if (select) {\n            select = `WHERE ${select}`;\n        }\n\n        return this.countRecordsSql(`SELECT ${countItem} FROM ${table} ${select}`, params);\n    }\n\n    /**\n     * Get the result of a SQL SELECT COUNT(...) query.\n     *\n     * Given a query that counts rows, return that count.\n     *\n     * @param sql The SQL string you wish to be executed.\n     * @param params An array of sql parameters.\n     * @returns Promise resolved with the count.\n     */\n    async countRecordsSql(sql: string, params?: SQLiteDBRecordValue[]): Promise<number> {\n        const count = await this.getFieldSql(sql, params);\n        if (typeof count != 'number' || count < 0) {\n            return 0;\n        }\n\n        return count;\n    }\n\n    /**\n     * Create a table if it doesn't exist.\n     *\n     * @param name The table name.\n     * @param columns The columns to create in the table.\n     * @param primaryKeys Names of columns that are primary key. Use it for compound primary keys.\n     * @param uniqueKeys List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].\n     * @param foreignKeys List of foreign keys.\n     * @param tableCheck Check constraint for the table.\n     * @returns Promise resolved when success.\n     */\n    async createTable(\n        name: string,\n        columns: SQLiteDBColumnSchema[],\n        primaryKeys?: string[],\n        uniqueKeys?: string[][],\n        foreignKeys?: SQLiteDBForeignKeySchema[],\n        tableCheck?: string,\n    ): Promise<void> {\n        const sql = this.buildCreateTableSql(name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck);\n\n        await this.execute(sql);\n    }\n\n    /**\n     * Create a table if it doesn't exist from a schema.\n     *\n     * @param table Table schema.\n     * @returns Promise resolved when success.\n     */\n    async createTableFromSchema(table: SQLiteDBTableSchema): Promise<void> {\n        await this.createTable(table.name, table.columns, table.primaryKeys, table.uniqueKeys, table.foreignKeys, table.tableCheck);\n    }\n\n    /**\n     * Create several tables if they don't exist from a list of schemas.\n     *\n     * @param tables List of table schema.\n     * @returns Promise resolved when success.\n     */\n    async createTablesFromSchema(tables: SQLiteDBTableSchema[]): Promise<void> {\n        const promises = tables.map(table => this.createTableFromSchema(table));\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Delete the records from a table where all the given conditions met.\n     * If conditions not specified, table is truncated.\n     *\n     * @param table The table to delete from.\n     * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n     * @returns Promise resolved with the number of affected rows.\n     */\n    async deleteRecords(table: string, conditions?: SQLiteDBRecordValues): Promise<number> {\n        if (conditions === null || conditions === undefined) {\n            // No conditions, delete the whole table.\n            const result = await this.execute(`DELETE FROM ${table}`);\n\n            return result.rowsAffected;\n        }\n\n        const selectAndParams = this.whereClause(conditions);\n\n        return this.deleteRecordsSelect(table, selectAndParams.sql, selectAndParams.params);\n    }\n\n    /**\n     * Delete the records from a table where one field match one list of values.\n     *\n     * @param table The table to delete from.\n     * @param field The name of a field.\n     * @param values The values field might take.\n     * @returns Promise resolved with the number of affected rows.\n     */\n    async deleteRecordsList(table: string, field: string, values: SQLiteDBRecordValue[]): Promise<number> {\n        const selectAndParams = this.whereClauseList(field, values);\n\n        return this.deleteRecordsSelect(table, selectAndParams.sql, selectAndParams.params);\n    }\n\n    /**\n     * Delete one or more records from a table which match a particular WHERE clause.\n     *\n     * @param table The table to delete from.\n     * @param select A fragment of SQL to be used in a where clause in the SQL call.\n     * @param params Array of sql parameters.\n     * @returns Promise resolved with the number of affected rows.\n     */\n    async deleteRecordsSelect(table: string, select: string = '', params?: SQLiteDBRecordValue[]): Promise<number> {\n        if (select) {\n            select = `WHERE ${select}`;\n        }\n\n        const result = await this.execute(`DELETE FROM ${table} ${select}`, params);\n\n        return result.rowsAffected;\n    }\n\n    /**\n     * Drop a table if it exists.\n     *\n     * @param name The table name.\n     * @returns Promise resolved when success.\n     */\n    async dropTable(name: string): Promise<void> {\n        await this.execute(`DROP TABLE IF EXISTS ${name}`);\n    }\n\n    /**\n     * Execute a SQL query.\n     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that\n     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.\n     *\n     * @param sql SQL query to execute.\n     * @param params Query parameters.\n     * @returns Promise resolved with the result.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async execute(sql: string, params?: SQLiteDBRecordValue[]): Promise<any> {\n        await this.ready();\n\n        return this.db?.executeSql(sql, params);\n    }\n\n    /**\n     * Execute a set of SQL queries. This operation is atomic.\n     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that\n     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.\n     *\n     * @param sqlStatements SQL statements to execute.\n     * @returns Promise resolved with the result.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async executeBatch(sqlStatements: (string | string[] | any)[]): Promise<void> {\n        await this.ready();\n\n        await this.db?.sqlBatch(sqlStatements);\n    }\n\n    /**\n     * Format the data to insert in the database. Removes undefined entries so they are stored as null instead of 'undefined'.\n     *\n     * @param data Data to insert.\n     */\n    protected formatDataToInsert(data: SQLiteDBRecordValues): void {\n        if (!data) {\n            return;\n        }\n\n        // Remove undefined entries.\n        Object.keys(data).forEach(key => data[key] === undefined && delete data[key]);\n    }\n\n    /**\n     * Get all the records from a table.\n     *\n     * @param table The table to query.\n     * @returns Promise resolved with the records.\n     */\n    async getAllRecords<T = unknown>(table: string): Promise<T[]> {\n        return this.getRecords(table);\n    }\n\n    /**\n     * Get a single field value from a table record where all the given conditions met.\n     *\n     * @param table The table to query.\n     * @param field The field to return the value of.\n     * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n     * @returns Promise resolved with the field's value.\n     */\n    async getField(table: string, field: string, conditions?: SQLiteDBRecordValues): Promise<SQLiteDBRecordValue> {\n        const selectAndParams = this.whereClause(conditions);\n\n        return this.getFieldSelect(table, field, selectAndParams.sql, selectAndParams.params);\n    }\n\n    /**\n     * Get a single field value from a table record which match a particular WHERE clause.\n     *\n     * @param table The table to query.\n     * @param field The field to return the value of.\n     * @param select A fragment of SQL to be used in a where clause returning one row with one column.\n     * @param params Array of sql parameters.\n     * @returns Promise resolved with the field's value.\n     */\n    async getFieldSelect(\n        table: string,\n        field: string,\n        select: string = '',\n        params?: SQLiteDBRecordValue[],\n    ): Promise<SQLiteDBRecordValue> {\n        if (select) {\n            select = `WHERE ${select}`;\n        }\n\n        return this.getFieldSql(`SELECT ${field} FROM ${table} ${select}`, params);\n    }\n\n    /**\n     * Get a single field value (first field) using a SQL statement.\n     *\n     * @param sql The SQL query returning one row with one column.\n     * @param params An array of sql parameters.\n     * @returns Promise resolved with the field's value.\n     */\n    async getFieldSql(sql: string, params?: SQLiteDBRecordValue[]): Promise<SQLiteDBRecordValue> {\n        const record = await this.getRecordSql<Record<string, SQLiteDBRecordValue>>(sql, params);\n        if (!record) {\n            throw new CoreError('No record found.');\n        }\n\n        return record[Object.keys(record)[0]];\n    }\n\n    /**\n     * Get the database name.\n     *\n     * @returns Database name.\n     */\n    getName(): string {\n        return this.name;\n    }\n\n    /**\n     * Get a single database record where all the given conditions met.\n     *\n     * @param table The table to query.\n     * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n     * @param fields A comma separated list of fields to return.\n     * @returns Promise resolved with the record, rejected if not found.\n     */\n    getRecord<T = unknown>(table: string, conditions?: SQLiteDBRecordValues, fields: string = '*'): Promise<T> {\n        const selectAndParams = this.whereClause(conditions);\n\n        return this.getRecordSelect<T>(table, selectAndParams.sql, selectAndParams.params, fields);\n    }\n\n    /**\n     * Get a single database record as an object which match a particular WHERE clause.\n     *\n     * @param table The table to query.\n     * @param select A fragment of SQL to be used in a where clause in the SQL call.\n     * @param params An array of sql parameters.\n     * @param fields A comma separated list of fields to return.\n     * @returns Promise resolved with the record, rejected if not found.\n     */\n    getRecordSelect<T = unknown>(\n        table: string,\n        select: string = '',\n        params: SQLiteDBRecordValue[] = [],\n        fields: string = '*',\n    ): Promise<T> {\n        if (select) {\n            select = ` WHERE ${select}`;\n        }\n\n        return this.getRecordSql<T>(`SELECT ${fields} FROM ${table} ${select}`, params);\n    }\n\n    /**\n     * Get a single database record as an object using a SQL statement.\n     *\n     * The SQL statement should normally only return one record.\n     * It is recommended to use getRecordsSql() if more matches possible!\n     *\n     * @param sql The SQL string you wish to be executed, should normally only return one record.\n     * @param params List of sql parameters\n     * @returns Promise resolved with the records.\n     */\n    async getRecordSql<T = unknown>(sql: string, params?: SQLiteDBRecordValue[]): Promise<T> {\n        const result = await this.getRecordsSql<T>(sql, params, 0, 1);\n        if (!result || !result.length) {\n            // Not found, reject.\n            throw new CoreError('No records found.');\n        }\n\n        return result[0];\n    }\n\n    /**\n     * Get a number of records where all the given conditions met.\n     *\n     * @param table The table to query.\n     * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n     * @param sort An order to sort the results in.\n     * @param fields A comma separated list of fields to return.\n     * @param limitFrom Return a subset of records, starting at this point.\n     * @param limitNum Return a subset comprising this many records in total.\n     * @returns Promise resolved with the records.\n     */\n    getRecords<T = unknown>(\n        table: string,\n        conditions?: SQLiteDBRecordValues,\n        sort: string = '',\n        fields: string = '*',\n        limitFrom: number = 0,\n        limitNum: number = 0,\n    ): Promise<T[]> {\n        const selectAndParams = this.whereClause(conditions);\n\n        return this.getRecordsSelect<T>(table, selectAndParams.sql, selectAndParams.params, sort, fields, limitFrom, limitNum);\n    }\n\n    /**\n     * Get a number of records where one field match one list of values.\n     *\n     * @param table The database table to be checked against.\n     * @param field The name of a field.\n     * @param values The values field might take.\n     * @param sort An order to sort the results in.\n     * @param fields A comma separated list of fields to return.\n     * @param limitFrom Return a subset of records, starting at this point.\n     * @param limitNum Return a subset comprising this many records in total.\n     * @returns Promise resolved with the records.\n     */\n    getRecordsList<T = unknown>(\n        table: string,\n        field: string,\n        values: SQLiteDBRecordValue[],\n        sort: string = '',\n        fields: string = '*',\n        limitFrom: number = 0,\n        limitNum: number = 0,\n    ): Promise<T[]> {\n        const selectAndParams = this.whereClauseList(field, values);\n\n        return this.getRecordsSelect<T>(table, selectAndParams.sql, selectAndParams.params, sort, fields, limitFrom, limitNum);\n    }\n\n    /**\n     * Get a number of records which match a particular WHERE clause.\n     *\n     * @param table The table to query.\n     * @param select A fragment of SQL to be used in a where clause in the SQL call.\n     * @param params An array of sql parameters.\n     * @param sort An order to sort the results in.\n     * @param fields A comma separated list of fields to return.\n     * @param limitFrom Return a subset of records, starting at this point.\n     * @param limitNum Return a subset comprising this many records in total.\n     * @returns Promise resolved with the records.\n     */\n    getRecordsSelect<T = unknown>(\n        table: string,\n        select: string = '',\n        params: SQLiteDBRecordValue[] = [],\n        sort: string = '',\n        fields: string = '*',\n        limitFrom: number = 0,\n        limitNum: number = 0,\n    ): Promise<T[]> {\n        if (select) {\n            select = ` WHERE ${select}`;\n        }\n        if (sort) {\n            sort = ` ORDER BY ${sort}`;\n        }\n\n        const sql = `SELECT ${fields} FROM ${table} ${select} ${sort}`;\n\n        return this.getRecordsSql<T>(sql, params, limitFrom, limitNum);\n    }\n\n    /**\n     * Get a number of records using a SQL statement.\n     *\n     * @param sql The SQL select query to execute.\n     * @param params List of sql parameters\n     * @param limitFrom Return a subset of records, starting at this point.\n     * @param limitNum Return a subset comprising this many records.\n     * @returns Promise resolved with the records.\n     */\n    async getRecordsSql<T = unknown>(\n        sql: string,\n        params?: SQLiteDBRecordValue[],\n        limitFrom?: number,\n        limitNum?: number,\n    ): Promise<T[]> {\n        const limits = this.normaliseLimitFromNum(limitFrom, limitNum);\n\n        if (limits[0] || limits[1]) {\n            if (limits[1] < 1) {\n                limits[1] = Number.MAX_VALUE;\n            }\n            sql += ` LIMIT ${limits[0]}, ${limits[1]}`;\n        }\n\n        const result = await this.execute(sql, params);\n        // Retrieve the records.\n        const records: T[] = [];\n        for (let i = 0; i < result.rows.length; i++) {\n            records.push(result.rows.item(i));\n        }\n\n        return records;\n    }\n\n    /**\n     * Given a data object, returns the SQL query and the params to insert that record.\n     *\n     * @param table The database table.\n     * @param data A data object with values for one or more fields in the record.\n     * @returns Array with the SQL query and the params.\n     */\n    protected getSqlInsertQuery(table: string, data: SQLiteDBRecordValues): SQLiteDBQueryParams {\n        this.formatDataToInsert(data);\n\n        const keys = Object.keys(data);\n        const fields = keys.join(',');\n        const questionMarks = ',?'.repeat(keys.length).substring(1);\n\n        return {\n            sql: `INSERT OR REPLACE INTO ${table} (${fields}) VALUES (${questionMarks})`,\n            params: Object.values(data),\n        };\n    }\n\n    /**\n     * Initialize the database.\n     */\n    init(): void {\n        this.promise = this.createDatabase().then(db => {\n            if (CoreDB.loggingEnabled()) {\n                const spies = this.getDatabaseSpies(db);\n\n                db = new Proxy(db, {\n                    get: (target, property, receiver) => spies[property] ?? Reflect.get(target, property, receiver),\n                });\n            }\n\n            this.db = db;\n\n            return;\n        });\n    }\n\n    /**\n     * Insert a record into a table and return the \"rowId\" field.\n     *\n     * @param table The database table to be inserted into.\n     * @param data A data object with values for one or more fields in the record.\n     * @returns Promise resolved with new rowId. Please notice this rowId is internal from SQLite.\n     */\n    async insertRecord(table: string, data: SQLiteDBRecordValues): Promise<number> {\n        const sqlAndParams = this.getSqlInsertQuery(table, data);\n        const result = await this.execute(sqlAndParams.sql, sqlAndParams.params);\n\n        return result.insertId;\n    }\n\n    /**\n     * Insert multiple records into database as fast as possible.\n     *\n     * @param table The database table to be inserted into.\n     * @param dataObjects List of objects to be inserted.\n     * @returns Promise resolved when done.\n     */\n    async insertRecords(table: string, dataObjects: SQLiteDBRecordValues[]): Promise<void> {\n        if (!Array.isArray(dataObjects)) {\n            throw new CoreError('Invalid parameter supplied to insertRecords, it should be an array.');\n        }\n\n        const statements = dataObjects.map((dataObject) => {\n            const statement = this.getSqlInsertQuery(table, dataObject);\n\n            return [statement.sql, statement.params];\n        });\n\n        await this.executeBatch(statements);\n    }\n\n    /**\n     * Insert multiple records into database from another table.\n     *\n     * @param table The database table to be inserted into.\n     * @param source The database table to get the records from.\n     * @returns Promise resolved when done.\n     */\n    async insertRecordsFrom(\n        table: string,\n        source: string,\n    ): Promise<void> {\n        const records = await this.getAllRecords<SQLiteDBRecordValues>(source);\n\n        await Promise.all(records.map((record) => this.insertRecord(table, record)));\n    }\n\n    /**\n     * Migrate all the data from a table to another table.\n     * It will check if old table exists and drop it when finished.\n     *\n     * @param oldTable Old table name.\n     * @param newTable New table name.\n     * @param mapCallback Mapping callback to migrate each record.\n     * @returns Resolved when done.\n     */\n    async migrateTable(\n        oldTable: string,\n        newTable: string,\n        mapCallback?: (record: SQLiteDBRecordValues) => SQLiteDBRecordValues,\n    ): Promise<void> {\n        try {\n            await this.tableExists(oldTable);\n        } catch {\n            // Old table does not exist, ignore.\n            return;\n        }\n\n        // Move the records from the old table.\n        if (mapCallback) {\n            const records = await this.getAllRecords<SQLiteDBRecordValues>(oldTable);\n            const promises = records.map((record) => {\n                record = mapCallback(record);\n\n                return this.insertRecord(newTable, record);\n            });\n\n            await Promise.all(promises);\n        } else {\n            // No changes needed.\n            await this.insertRecordsFrom(newTable, oldTable);\n        }\n\n        try {\n            await this.dropTable(oldTable);\n        } catch {\n            // Error deleting old table, ignore.\n        }\n    }\n\n    /**\n     * Ensures that limit params are numeric and positive integers, to be passed to the database.\n     * We explicitly treat null, '' and -1 as 0 in order to provide compatibility with how limit\n     * values have been passed historically.\n     *\n     * @param limitFrom Where to start results from.\n     * @param limitNum How many results to return.\n     * @returns Normalised limit params in array: [limitFrom, limitNum].\n     */\n    normaliseLimitFromNum(limitFrom?: number, limitNum?: number): number[] {\n        // We explicilty treat these cases as 0.\n        if (!limitFrom || limitFrom === -1) {\n            limitFrom = 0;\n        } else {\n            limitFrom = Math.max(0, limitFrom);\n        }\n\n        if (!limitNum || limitNum === -1) {\n            limitNum = 0;\n        } else {\n            limitNum = Math.max(0, limitNum);\n        }\n\n        return [limitFrom, limitNum];\n    }\n\n    /**\n     * Open the database. Only needed if it was closed before, a database is automatically opened when created.\n     *\n     * @returns Promise resolved when open.\n     */\n    async open(): Promise<void> {\n        await this.ready();\n\n        await this.db?.open();\n    }\n\n    /**\n     * Wait for the DB to be ready.\n     *\n     * @returns Promise resolved when ready.\n     */\n    ready(): Promise<void> {\n        return this.promise;\n    }\n\n    /**\n     * Test whether a record exists in a table where all the given conditions met.\n     *\n     * @param table The table to check.\n     * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n     * @returns Promise resolved if exists, rejected otherwise.\n     */\n    async recordExists(table: string, conditions?: SQLiteDBRecordValues): Promise<void> {\n        const record = await this.getRecord(table, conditions);\n        if (!record) {\n            throw new CoreError('Record does not exist.');\n        }\n    }\n\n    /**\n     * Test whether any records exists in a table which match a particular WHERE clause.\n     *\n     * @param table The table to query.\n     * @param select A fragment of SQL to be used in a where clause in the SQL call.\n     * @param params An array of sql parameters.\n     * @returns Promise resolved if exists, rejected otherwise.\n     */\n    async recordExistsSelect(table: string, select: string = '', params: SQLiteDBRecordValue[] = []): Promise<void> {\n        const record = await this.getRecordSelect(table, select, params);\n        if (!record) {\n            throw new CoreError('Record does not exist.');\n        }\n    }\n\n    /**\n     * Test whether a SQL SELECT statement returns any records.\n     *\n     * @param sql The SQL query returning one row with one column.\n     * @param params An array of sql parameters.\n     * @returns Promise resolved if exists, rejected otherwise.\n     */\n    async recordExistsSql(sql: string, params?: SQLiteDBRecordValue[]): Promise<void> {\n        const record = await this.getRecordSql(sql, params);\n        if (!record) {\n            throw new CoreError('Record does not exist.');\n        }\n    }\n\n    /**\n     * Test whether a table exists..\n     *\n     * @param name The table name.\n     * @returns Promise resolved if exists, rejected otherwise.\n     */\n    async tableExists(name: string): Promise<void> {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        await this.recordExists('sqlite_master', { type: 'table', tbl_name: name });\n    }\n\n    /**\n     * Update one or more records in a table.\n     *\n     * @param table The database table to update.\n     * @param data An object with the fields to update: fieldname=>fieldvalue.\n     * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n     * @returns Promise resolved with the number of affected rows.\n     */\n    async updateRecords(table: string, data: SQLiteDBRecordValues, conditions?: SQLiteDBRecordValues): Promise<number> {\n        const whereAndParams = this.whereClause(conditions);\n\n        return this.updateRecordsWhere(table, data, whereAndParams.sql, whereAndParams.params);\n    }\n\n    /**\n     * Update one or more records in a table. It accepts a WHERE clause as a string.\n     *\n     * @param table The database table to update.\n     * @param data An object with the fields to update: fieldname=>fieldvalue.\n     * @param where Where clause. Must not include the \"WHERE\" word.\n     * @param whereParams Params for the where clause.\n     * @returns Promise resolved with the number of affected rows.\n     */\n    async updateRecordsWhere(\n        table: string,\n        data: SQLiteDBRecordValues,\n        where?: string,\n        whereParams?: SQLiteDBRecordValue[],\n    ): Promise<number> {\n        this.formatDataToInsert(data);\n        if (!data || !Object.keys(data).length) {\n            // No fields to update, consider it's done.\n            return 0;\n        }\n\n        const sets = Object.keys(data).map(key => `${key} = ?`);\n        let sql = `UPDATE ${table} SET ${sets.join(', ')}`;\n        if (where) {\n            sql += ` WHERE ${where}`;\n        }\n\n        // Create the list of params using the \"data\" object and the params for the where clause.\n        let params = Object.values(data);\n        if (where && whereParams) {\n            params = params.concat(whereParams);\n        }\n\n        const result = await this.execute(sql, params);\n\n        return result.rowsAffected;\n    }\n\n    /**\n     * Returns the SQL WHERE conditions.\n     *\n     * @param conditions The conditions to build the where clause. Must not contain numeric indexes.\n     * @returns An array list containing sql 'where' part and 'params'.\n     */\n    whereClause(conditions: SQLiteDBRecordValues = {}): SQLiteDBQueryParams {\n        if (!conditions || !Object.keys(conditions).length) {\n            return {\n                sql: '1 = 1',\n                params: [],\n            };\n        }\n\n        const params: SQLiteDBRecordValue[] = [];\n\n        const where = Object.keys(conditions).map((field) => {\n            const value = conditions[field];\n\n            if (value === undefined || value === null) {\n                return `${field} IS NULL`;\n            }\n\n            params.push(value);\n\n            return `${field} = ?`;\n        });\n\n        return {\n            sql: where.join(' AND '),\n            params,\n        };\n    }\n\n    /**\n     * Returns SQL WHERE conditions for the ..._list group of methods.\n     *\n     * @param field The name of a field.\n     * @param values The values field might take.\n     * @returns An array containing sql 'where' part and 'params'.\n     */\n    whereClauseList(field: string, values: SQLiteDBRecordValue[]): SQLiteDBQueryParams {\n        if (!values || !values.length) {\n            return {\n                sql: '1 = 2', // Fake condition, won't return rows ever.\n                params: [],\n            };\n        }\n\n        const params: SQLiteDBRecordValue[] = [];\n        let sql = '';\n\n        values.forEach((value) => {\n            if (value === undefined || value === null) {\n                sql = `${field} IS NULL`;\n            } else {\n                params.push(value);\n            }\n        });\n\n        if (params && params.length) {\n            if (sql !== '') {\n                sql += ' OR ';\n            }\n\n            if (params.length == 1) {\n                sql += `${field} = ?`;\n            } else {\n                const questionMarks = ',?'.repeat(params.length).substring(1);\n                sql += ` ${field} IN (${questionMarks})`;\n            }\n        }\n\n        return { sql, params };\n    }\n\n    /**\n     * Open a database connection.\n     *\n     * @returns Database.\n     */\n    protected async createDatabase(): Promise<SQLiteObject> {\n        await CorePlatform.ready();\n\n        return SQLite.create({ name: this.name, location: 'default' });\n    }\n\n    /**\n     * Get database spy methods to intercept database calls and track logging information.\n     *\n     * @param db Database to spy.\n     * @returns Spy methods.\n     */\n    protected getDatabaseSpies(db: SQLiteObject): Partial<SQLiteObject> {\n        const dbName = this.name;\n\n        return {\n            async executeSql(statement, params) {\n                const start = performance.now();\n\n                try {\n                    const result = await db.executeSql(statement, params);\n\n                    CoreDB.logQuery({\n                        params,\n                        sql: statement,\n                        duration:  performance.now() - start,\n                        dbName,\n                    });\n\n                    return result;\n                } catch (error) {\n                    CoreDB.logQuery({\n                        params,\n                        error,\n                        sql: statement,\n                        duration:  performance.now() - start,\n                        dbName,\n                    });\n\n                    throw error;\n                }\n            },\n            async sqlBatch(statements) {\n                const start = performance.now();\n                const sql = Array.isArray(statements)\n                    ? statements.join(' | ')\n                    : String(statements);\n\n                try {\n                    const result = await db.sqlBatch(statements);\n\n                    CoreDB.logQuery({\n                        sql,\n                        duration: performance.now() - start,\n                        dbName,\n                    });\n\n                    return result;\n                } catch (error) {\n                    CoreDB.logQuery({\n                        sql,\n                        error,\n                        duration: performance.now() - start,\n                        dbName,\n                    });\n\n                    throw error;\n                }\n            },\n        };\n    }\n\n}\n\nexport type SQLiteDBRecordValues = {\n    [key: string]: SQLiteDBRecordValue;\n};\n\nexport type SQLiteDBQueryParams = {\n    sql: string;\n    params: SQLiteDBRecordValue[];\n};\n\nexport type SQLiteDBRecordValue = number | string  | undefined | null;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}