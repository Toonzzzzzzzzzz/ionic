{"ast":null,"code":"// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CorePromise } from '@classes/promise';\n/**\n * Promise whose execution can be cancelled.\n */\nexport class CoreCancellablePromise extends CorePromise {\n  static resolve(result) {\n    return new this(resolve => result ? resolve(result) : resolve(), () => {\n      // Nothing to do here.\n    });\n  }\n  constructor(executor, cancelPromise) {\n    super(new Promise(executor));\n    this.cancelPromise = cancelPromise;\n  }\n  /**\n   * Cancel promise.\n   *\n   * After this method is called, the promise will remain unresolved forever. Make sure that after calling\n   * this method there aren't any references to this object, or it could cause memory leaks.\n   */\n  cancel() {\n    this.cancelPromise();\n  }\n}","map":{"version":3,"names":["CorePromise","CoreCancellablePromise","resolve","result","constructor","executor","cancelPromise","Promise","cancel"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/classes/cancellable-promise.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CorePromise } from '@classes/promise';\n\n/**\n * Promise whose execution can be cancelled.\n */\nexport class CoreCancellablePromise<T = unknown> extends CorePromise<T> {\n\n    /**\n     * Create a new resolved promise.\n     *\n     * @returns Resolved promise.\n     */\n    static resolve(): CoreCancellablePromise<void>;\n    static resolve<T>(result: T): CoreCancellablePromise<T>;\n    static resolve<T>(result?: T): CoreCancellablePromise<T> {\n        return new this(resolve => result ? resolve(result) : (resolve as () => void)(), () => {\n            // Nothing to do here.\n        });\n    }\n\n    protected cancelPromise: () => void;\n\n    constructor(\n        executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: Error) => void) => void,\n        cancelPromise: () => void,\n    ) {\n        super(new Promise(executor));\n\n        this.cancelPromise = cancelPromise;\n    }\n\n    /**\n     * Cancel promise.\n     *\n     * After this method is called, the promise will remain unresolved forever. Make sure that after calling\n     * this method there aren't any references to this object, or it could cause memory leaks.\n     */\n    cancel(): void {\n        this.cancelPromise();\n    }\n\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,WAAW,QAAQ,kBAAkB;AAE9C;;;AAGA,OAAM,MAAOC,sBAAoC,SAAQD,WAAc;EASnE,OAAOE,OAAOA,CAAIC,MAAU;IACxB,OAAO,IAAI,IAAI,CAACD,OAAO,IAAIC,MAAM,GAAGD,OAAO,CAACC,MAAM,CAAC,GAAID,OAAsB,EAAE,EAAE,MAAK;MAClF;IAAA,CACH,CAAC;EACN;EAIAE,YACIC,QAAkG,EAClGC,aAAyB;IAEzB,KAAK,CAAC,IAAIC,OAAO,CAACF,QAAQ,CAAC,CAAC;IAE5B,IAAI,CAACC,aAAa,GAAGA,aAAa;EACtC;EAEA;;;;;;EAMAE,MAAMA,CAAA;IACF,IAAI,CAACF,aAAa,EAAE;EACxB"},"metadata":{},"sourceType":"module","externalDependencies":[]}