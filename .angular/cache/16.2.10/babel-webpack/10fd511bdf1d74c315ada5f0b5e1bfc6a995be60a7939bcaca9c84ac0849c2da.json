{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\n// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreLogger } from './logger';\n/**\n * Registry to keep track of directive instances.\n */\nexport class CoreDirectivesRegistry {\n  /**\n   * Register a directive instance.\n   *\n   * @param element Root element.\n   * @param instance Directive instance.\n   */\n  static register(element, instance) {\n    var _this$instances$get;\n    const list = (_this$instances$get = this.instances.get(element)) !== null && _this$instances$get !== void 0 ? _this$instances$get : [];\n    list.push(instance);\n    this.instances.set(element, list);\n  }\n  /**\n   * Resolve a directive instance.\n   *\n   * @param element Root element.\n   * @param directiveClass Directive class.\n   * @returns Directive instance.\n   */\n  static resolve(element, directiveClass) {\n    var _ref, _list$find;\n    const list = (_ref = element && this.instances.get(element)) !== null && _ref !== void 0 ? _ref : [];\n    return (_list$find = list.find(instance => !directiveClass || instance instanceof directiveClass)) !== null && _list$find !== void 0 ? _list$find : null;\n  }\n  /**\n   * Resolve all directive instances.\n   *\n   * @param element Root element.\n   * @param directiveClass Directive class.\n   * @returns Directive instances.\n   */\n  static resolveAll(element, directiveClass) {\n    var _ref2, _list$filter;\n    const list = (_ref2 = element && this.instances.get(element)) !== null && _ref2 !== void 0 ? _ref2 : [];\n    return (_list$filter = list.filter(instance => !directiveClass || instance instanceof directiveClass)) !== null && _list$filter !== void 0 ? _list$filter : [];\n  }\n  /**\n   * Get a directive instance and fail if it cannot be resolved.\n   *\n   * @param element Root element.\n   * @param directiveClass Directive class.\n   * @returns Directive instance.\n   */\n  static require(element, directiveClass) {\n    const instance = this.resolve(element, directiveClass);\n    if (!instance) {\n      throw new Error('Couldn\\'t resolve directive instance');\n    }\n    return instance;\n  }\n  /**\n   * Get a directive instance and wait to be ready.\n   *\n   * @param element Root element.\n   * @param directiveClass Directive class.\n   * @returns Promise resolved when done.\n   */\n  static waitDirectiveReady(element, directiveClass) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const instance = _this.resolve(element, directiveClass);\n      if (!instance) {\n        _this.logger.error('No instance registered for element ' + directiveClass, element);\n        return;\n      }\n      yield instance.ready();\n    })();\n  }\n  /**\n   * Get all directive instances and wait to be ready.\n   *\n   * @param element Root element.\n   * @param selector If defined, CSS Selector to wait for.\n   * @param directiveClass Directive class.\n   * @returns Promise resolved when done.\n   */\n  static waitDirectivesReady(element, selector, directiveClass) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const findElements = () => {\n        if (!selector || element.matches(selector)) {\n          // Element to wait is myself.\n          return [element];\n        } else {\n          return Array.from(element.querySelectorAll(selector));\n        }\n      };\n      const elements = findElements();\n      if (!elements.length) {\n        return;\n      }\n      yield Promise.all(elements.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (element) {\n          const instances = _this2.resolveAll(element, directiveClass);\n          yield Promise.all(instances.map(instance => instance.ready()));\n        });\n        return function (_x) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      // Wait for next tick to ensure directives are completely rendered.\n      yield CoreUtils.nextTick();\n      // Check if there are new elements now that the found elements are ready (there could be nested elements).\n      if (elements.length !== findElements().length) {\n        yield _this2.waitDirectivesReady(element, selector, directiveClass);\n      }\n    })();\n  }\n  /**\n   * Get all directive instances (with multiple types) and wait for them to be ready.\n   *\n   * @param element Root element.\n   * @param directives Directives to wait.\n   * @returns Promise resolved when done.\n   */\n  static waitMultipleDirectivesReady(element, directives) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const findElements = selector => {\n        if (!selector || element.matches(selector)) {\n          // Element to wait is myself.\n          return [element];\n        } else {\n          return Array.from(element.querySelectorAll(selector));\n        }\n      };\n      let allElements = [];\n      yield Promise.all(directives.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (directive) {\n          const elements = findElements(directive.selector);\n          if (!elements.length) {\n            return;\n          }\n          allElements = allElements.concat(elements);\n          yield Promise.all(elements.map( /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* (element) {\n              const instances = _this3.resolveAll(element, directive.class);\n              yield Promise.all(instances.map(instance => instance.ready()));\n            });\n            return function (_x3) {\n              return _ref5.apply(this, arguments);\n            };\n          }()));\n        });\n        return function (_x2) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n      // Wait for next tick to ensure directives are completely rendered.\n      yield CoreUtils.nextTick();\n      // Check if there are new elements now that the found elements are ready (there could be nested elements).\n      const elementsAfterReady = directives.reduce((elements, directive) => {\n        elements = elements.concat(findElements(directive.selector));\n        return elements;\n      }, []);\n      if (allElements.length !== elementsAfterReady.length) {\n        yield _this3.waitMultipleDirectivesReady(element, directives);\n      }\n    })();\n  }\n}\n_class = CoreDirectivesRegistry;\n_class.instances = new WeakMap();\n_class.logger = CoreLogger.getInstance('CoreDirectivesRegistry');","map":{"version":3,"names":["CoreUtils","CoreLogger","CoreDirectivesRegistry","register","element","instance","_this$instances$get","list","instances","get","push","set","resolve","directiveClass","_ref","_list$find","find","resolveAll","_ref2","_list$filter","filter","require","Error","waitDirectiveReady","_this","_asyncToGenerator","logger","error","ready","waitDirectivesReady","selector","_this2","findElements","matches","Array","from","querySelectorAll","elements","length","Promise","all","map","_ref3","_x","apply","arguments","nextTick","waitMultipleDirectivesReady","directives","_this3","allElements","_ref4","directive","concat","_ref5","class","_x3","_x2","elementsAfterReady","reduce","_class","WeakMap","getInstance"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/singletons/directives-registry.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Directive } from '@angular/core';\nimport { AsyncDirective } from '@classes/async-directive';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreLogger } from './logger';\n\n/**\n * Registry to keep track of directive instances.\n */\nexport class CoreDirectivesRegistry {\n\n    private static instances: WeakMap<Element, unknown[]> = new WeakMap();\n    protected static logger = CoreLogger.getInstance('CoreDirectivesRegistry');\n\n    /**\n     * Register a directive instance.\n     *\n     * @param element Root element.\n     * @param instance Directive instance.\n     */\n    static register(element: Element, instance: unknown): void {\n        const list = this.instances.get(element) ?? [];\n        list.push(instance);\n        this.instances.set(element, list);\n    }\n\n    /**\n     * Resolve a directive instance.\n     *\n     * @param element Root element.\n     * @param directiveClass Directive class.\n     * @returns Directive instance.\n     */\n    static resolve<T>(element?: Element | null, directiveClass?: DirectiveConstructor<T>): T | null {\n        const list = (element && this.instances.get(element) as T[]) ?? [];\n\n        return list.find(instance => !directiveClass || instance instanceof directiveClass) ?? null;\n    }\n\n    /**\n     * Resolve all directive instances.\n     *\n     * @param element Root element.\n     * @param directiveClass Directive class.\n     * @returns Directive instances.\n     */\n    static resolveAll<T>(element?: Element | null, directiveClass?: DirectiveConstructor<T>): T[] {\n        const list = (element && this.instances.get(element) as T[]) ?? [];\n\n        return list.filter(instance => !directiveClass || instance instanceof directiveClass) ?? [];\n    }\n\n    /**\n     * Get a directive instance and fail if it cannot be resolved.\n     *\n     * @param element Root element.\n     * @param directiveClass Directive class.\n     * @returns Directive instance.\n     */\n    static require<T>(element: Element, directiveClass?: DirectiveConstructor<T>): T {\n        const instance = this.resolve(element, directiveClass);\n\n        if (!instance) {\n            throw new Error('Couldn\\'t resolve directive instance');\n        }\n\n        return instance;\n    }\n\n    /**\n     * Get a directive instance and wait to be ready.\n     *\n     * @param element Root element.\n     * @param directiveClass Directive class.\n     * @returns Promise resolved when done.\n     */\n    static async waitDirectiveReady<T extends AsyncDirective>(\n        element: Element | null,\n        directiveClass?: DirectiveConstructor<T>,\n    ): Promise<void> {\n        const instance = this.resolve(element, directiveClass);\n        if (!instance) {\n            this.logger.error('No instance registered for element ' + directiveClass, element);\n\n            return;\n        }\n\n        await instance.ready();\n    }\n\n    /**\n     * Get all directive instances and wait to be ready.\n     *\n     * @param element Root element.\n     * @param selector If defined, CSS Selector to wait for.\n     * @param directiveClass Directive class.\n     * @returns Promise resolved when done.\n     */\n    static async waitDirectivesReady<T extends AsyncDirective>(\n        element: Element,\n        selector?: string,\n        directiveClass?: DirectiveConstructor<T>,\n    ): Promise<void> {\n        const findElements = (): Element[] => {\n            if (!selector || element.matches(selector)) {\n                // Element to wait is myself.\n                return [element];\n            } else {\n                return Array.from(element.querySelectorAll(selector));\n            }\n        };\n\n        const elements = findElements();\n        if (!elements.length) {\n            return;\n        }\n\n        await Promise.all(elements.map(async element => {\n            const instances = this.resolveAll<T>(element, directiveClass);\n\n            await Promise.all(instances.map(instance => instance.ready()));\n        }));\n\n        // Wait for next tick to ensure directives are completely rendered.\n        await CoreUtils.nextTick();\n\n        // Check if there are new elements now that the found elements are ready (there could be nested elements).\n        if (elements.length !== findElements().length) {\n            await this.waitDirectivesReady(element, selector, directiveClass);\n        }\n    }\n\n    /**\n     * Get all directive instances (with multiple types) and wait for them to be ready.\n     *\n     * @param element Root element.\n     * @param directives Directives to wait.\n     * @returns Promise resolved when done.\n     */\n    static async waitMultipleDirectivesReady(\n        element: Element,\n        directives: DirectiveData<AsyncDirective>[],\n    ): Promise<void> {\n        const findElements = (selector?: string): Element[] => {\n            if (!selector || element.matches(selector)) {\n                // Element to wait is myself.\n                return [element];\n            } else {\n                return Array.from(element.querySelectorAll(selector));\n            }\n        };\n\n        let allElements: Element[] = [];\n\n        await Promise.all(directives.map(async directive => {\n            const elements = findElements(directive.selector);\n            if (!elements.length) {\n                return;\n            }\n\n            allElements = allElements.concat(elements);\n\n            await Promise.all(elements.map(async element => {\n                const instances = this.resolveAll<AsyncDirective>(element, directive.class);\n\n                await Promise.all(instances.map(instance => instance.ready()));\n            }));\n        }));\n\n        // Wait for next tick to ensure directives are completely rendered.\n        await CoreUtils.nextTick();\n\n        // Check if there are new elements now that the found elements are ready (there could be nested elements).\n        const elementsAfterReady = directives.reduce((elements, directive) => {\n            elements = elements.concat(findElements(directive.selector));\n\n            return elements;\n        }, <Element[]> []);\n\n        if (allElements.length !== elementsAfterReady.length) {\n            await this.waitMultipleDirectivesReady(element, directives);\n        }\n    }\n\n}\n\n/**\n * Directive constructor.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type DirectiveConstructor<T = Directive> = { new(...args: any[]): T };\n\n/**\n * Data to identify a directive when waiting for ready.\n */\ntype DirectiveData<T extends AsyncDirective> = {\n    selector?: string; // If defined, CSS Selector to wait for.\n    class?: DirectiveConstructor<T>; // Directive class.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}