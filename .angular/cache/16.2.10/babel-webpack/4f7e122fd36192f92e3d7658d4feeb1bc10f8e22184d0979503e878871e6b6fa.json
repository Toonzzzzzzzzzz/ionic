{"ast":null,"code":"// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CoreText } from './text';\n/**\n * Singleton with helper functions for paths.\n */\nexport class CorePath {\n  // Avoid creating singleton instances.\n  constructor() {\n    // Nothing to do.\n  }\n  /**\n   * Calculate a relative path from a folder to another folder.\n   *\n   * E.g. if initial folder is foo/bar, and final folder is foo/baz/xyz, it will return ../bar/xyz.\n   *\n   * @param initialFolder The initial folder path.\n   * @param finalFolder The final folder. The \"root\" should be the same as initialFolder.\n   * @returns Relative path.\n   */\n  static calculateRelativePath(initialFolder, finalFolder) {\n    initialFolder = CoreText.removeStartingSlash(CoreText.removeEndingSlash(initialFolder));\n    finalFolder = CoreText.removeStartingSlash(CoreText.removeEndingSlash(finalFolder));\n    if (initialFolder === finalFolder) {\n      return '';\n    }\n    const initialFolderSplit = initialFolder === '' ? [] : initialFolder.split('/');\n    const finalFolderSplit = finalFolder === '' ? [] : finalFolder.split('/');\n    let firstDiffIndex = initialFolderSplit.length > 0 && finalFolderSplit.length > 0 ? initialFolderSplit.findIndex((value, index) => value !== finalFolderSplit[index]) : 0;\n    if (firstDiffIndex === -1) {\n      // All elements in initial folder are equal. The first diff is the first element in the final folder.\n      firstDiffIndex = initialFolderSplit.length;\n    }\n    const newPathToFinalFolder = finalFolderSplit.slice(firstDiffIndex).join('/');\n    return '../'.repeat(initialFolderSplit.length - firstDiffIndex) + newPathToFinalFolder;\n  }\n  /**\n   * Convert a relative path (based on a certain folder) to a relative path based on a different folder.\n   *\n   * E.g. if current folder is foo/bar, relative URL is test.jpg and new folder is foo/baz,\n   * it will return ../bar/test.jpg.\n   *\n   * @param currentFolder The current folder path.\n   * @param path The relative path.\n   * @param newFolder The folder to use to calculate the new relative path. The \"root\" should be the same as currentFolder.\n   * @returns Relative path.\n   */\n  static changeRelativePath(currentFolder, path, newFolder) {\n    return CorePath.concatenatePaths(CorePath.calculateRelativePath(newFolder, currentFolder), path);\n  }\n  /**\n   * Concatenate two paths, adding a slash between them if needed.\n   *\n   * @param leftPath Left path.\n   * @param rightPath Right path.\n   * @returns Concatenated path.\n   */\n  static concatenatePaths(leftPath, rightPath) {\n    if (!leftPath) {\n      return rightPath;\n    } else if (!rightPath) {\n      return leftPath;\n    }\n    const lastCharLeft = leftPath.slice(-1);\n    const firstCharRight = rightPath.charAt(0);\n    if (lastCharLeft === '/' && firstCharRight === '/') {\n      return leftPath + rightPath.substring(1);\n    } else if (lastCharLeft !== '/' && firstCharRight !== '/') {\n      return leftPath + '/' + rightPath;\n    } else {\n      return leftPath + rightPath;\n    }\n  }\n}","map":{"version":3,"names":["CoreText","CorePath","constructor","calculateRelativePath","initialFolder","finalFolder","removeStartingSlash","removeEndingSlash","initialFolderSplit","split","finalFolderSplit","firstDiffIndex","length","findIndex","value","index","newPathToFinalFolder","slice","join","repeat","changeRelativePath","currentFolder","path","newFolder","concatenatePaths","leftPath","rightPath","lastCharLeft","firstCharRight","charAt","substring"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/singletons/path.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreText } from './text';\n\n/**\n * Singleton with helper functions for paths.\n */\nexport class CorePath {\n\n    // Avoid creating singleton instances.\n    private constructor() {\n        // Nothing to do.\n    }\n\n    /**\n     * Calculate a relative path from a folder to another folder.\n     *\n     * E.g. if initial folder is foo/bar, and final folder is foo/baz/xyz, it will return ../bar/xyz.\n     *\n     * @param initialFolder The initial folder path.\n     * @param finalFolder The final folder. The \"root\" should be the same as initialFolder.\n     * @returns Relative path.\n     */\n    static calculateRelativePath(initialFolder: string, finalFolder: string): string {\n        initialFolder = CoreText.removeStartingSlash(CoreText.removeEndingSlash(initialFolder));\n        finalFolder = CoreText.removeStartingSlash(CoreText.removeEndingSlash(finalFolder));\n\n        if (initialFolder === finalFolder) {\n            return '';\n        }\n\n        const initialFolderSplit = initialFolder === '' ? [] : initialFolder.split('/');\n        const finalFolderSplit = finalFolder === '' ? [] : finalFolder.split('/');\n\n        let firstDiffIndex = initialFolderSplit.length > 0 && finalFolderSplit.length > 0 ?\n            initialFolderSplit.findIndex((value, index) => value !== finalFolderSplit[index]) :\n            0;\n\n        if (firstDiffIndex === -1) {\n            // All elements in initial folder are equal. The first diff is the first element in the final folder.\n            firstDiffIndex = initialFolderSplit.length;\n        }\n\n        const newPathToFinalFolder = finalFolderSplit.slice(firstDiffIndex).join('/');\n\n        return '../'.repeat(initialFolderSplit.length - firstDiffIndex) + newPathToFinalFolder;\n    }\n\n    /**\n     * Convert a relative path (based on a certain folder) to a relative path based on a different folder.\n     *\n     * E.g. if current folder is foo/bar, relative URL is test.jpg and new folder is foo/baz,\n     * it will return ../bar/test.jpg.\n     *\n     * @param currentFolder The current folder path.\n     * @param path The relative path.\n     * @param newFolder The folder to use to calculate the new relative path. The \"root\" should be the same as currentFolder.\n     * @returns Relative path.\n     */\n    static changeRelativePath(currentFolder: string, path: string, newFolder: string): string {\n        return CorePath.concatenatePaths(CorePath.calculateRelativePath(newFolder, currentFolder), path);\n    }\n\n    /**\n     * Concatenate two paths, adding a slash between them if needed.\n     *\n     * @param leftPath Left path.\n     * @param rightPath Right path.\n     * @returns Concatenated path.\n     */\n    static concatenatePaths(leftPath: string, rightPath: string): string {\n        if (!leftPath) {\n            return rightPath;\n        } else if (!rightPath) {\n            return leftPath;\n        }\n\n        const lastCharLeft = leftPath.slice(-1);\n        const firstCharRight = rightPath.charAt(0);\n\n        if (lastCharLeft === '/' && firstCharRight === '/') {\n            return leftPath + rightPath.substring(1);\n        } else if (lastCharLeft !== '/' && firstCharRight !== '/') {\n            return leftPath + '/' + rightPath;\n        } else {\n            return leftPath + rightPath;\n        }\n    }\n\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,QAAQ,QAAQ,QAAQ;AAEjC;;;AAGA,OAAM,MAAOC,QAAQ;EAEjB;EACAC,YAAA;IACI;EAAA;EAGJ;;;;;;;;;EASA,OAAOC,qBAAqBA,CAACC,aAAqB,EAAEC,WAAmB;IACnED,aAAa,GAAGJ,QAAQ,CAACM,mBAAmB,CAACN,QAAQ,CAACO,iBAAiB,CAACH,aAAa,CAAC,CAAC;IACvFC,WAAW,GAAGL,QAAQ,CAACM,mBAAmB,CAACN,QAAQ,CAACO,iBAAiB,CAACF,WAAW,CAAC,CAAC;IAEnF,IAAID,aAAa,KAAKC,WAAW,EAAE;MAC/B,OAAO,EAAE;;IAGb,MAAMG,kBAAkB,GAAGJ,aAAa,KAAK,EAAE,GAAG,EAAE,GAAGA,aAAa,CAACK,KAAK,CAAC,GAAG,CAAC;IAC/E,MAAMC,gBAAgB,GAAGL,WAAW,KAAK,EAAE,GAAG,EAAE,GAAGA,WAAW,CAACI,KAAK,CAAC,GAAG,CAAC;IAEzE,IAAIE,cAAc,GAAGH,kBAAkB,CAACI,MAAM,GAAG,CAAC,IAAIF,gBAAgB,CAACE,MAAM,GAAG,CAAC,GAC7EJ,kBAAkB,CAACK,SAAS,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAKD,KAAK,KAAKJ,gBAAgB,CAACK,KAAK,CAAC,CAAC,GACjF,CAAC;IAEL,IAAIJ,cAAc,KAAK,CAAC,CAAC,EAAE;MACvB;MACAA,cAAc,GAAGH,kBAAkB,CAACI,MAAM;;IAG9C,MAAMI,oBAAoB,GAAGN,gBAAgB,CAACO,KAAK,CAACN,cAAc,CAAC,CAACO,IAAI,CAAC,GAAG,CAAC;IAE7E,OAAO,KAAK,CAACC,MAAM,CAACX,kBAAkB,CAACI,MAAM,GAAGD,cAAc,CAAC,GAAGK,oBAAoB;EAC1F;EAEA;;;;;;;;;;;EAWA,OAAOI,kBAAkBA,CAACC,aAAqB,EAAEC,IAAY,EAAEC,SAAiB;IAC5E,OAAOtB,QAAQ,CAACuB,gBAAgB,CAACvB,QAAQ,CAACE,qBAAqB,CAACoB,SAAS,EAAEF,aAAa,CAAC,EAAEC,IAAI,CAAC;EACpG;EAEA;;;;;;;EAOA,OAAOE,gBAAgBA,CAACC,QAAgB,EAAEC,SAAiB;IACvD,IAAI,CAACD,QAAQ,EAAE;MACX,OAAOC,SAAS;KACnB,MAAM,IAAI,CAACA,SAAS,EAAE;MACnB,OAAOD,QAAQ;;IAGnB,MAAME,YAAY,GAAGF,QAAQ,CAACR,KAAK,CAAC,CAAC,CAAC,CAAC;IACvC,MAAMW,cAAc,GAAGF,SAAS,CAACG,MAAM,CAAC,CAAC,CAAC;IAE1C,IAAIF,YAAY,KAAK,GAAG,IAAIC,cAAc,KAAK,GAAG,EAAE;MAChD,OAAOH,QAAQ,GAAGC,SAAS,CAACI,SAAS,CAAC,CAAC,CAAC;KAC3C,MAAM,IAAIH,YAAY,KAAK,GAAG,IAAIC,cAAc,KAAK,GAAG,EAAE;MACvD,OAAOH,QAAQ,GAAG,GAAG,GAAGC,SAAS;KACpC,MAAM;MACH,OAAOD,QAAQ,GAAGC,SAAS;;EAEnC"},"metadata":{},"sourceType":"module","externalDependencies":[]}