{"ast":null,"code":"import _asyncToGenerator from \"/home/toon/works/gitionic7/ionic-github/ionic/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _class;\nimport { CoreDelegate } from '@classes/delegate';\nimport { makeSingleton } from '@singletons';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./handlers/default-format\";\n/**\n * Service to interact with course formats.\n */\nexport class CoreCourseFormatDelegateService extends CoreDelegate {\n  constructor(defaultHandler) {\n    super('CoreCoursesCourseFormatDelegate', true);\n    this.defaultHandler = defaultHandler;\n    this.featurePrefix = 'CoreCourseFormatDelegate_';\n    this.handlerNameProperty = 'format';\n  }\n  /**\n   * Whether it allows seeing all sections at the same time. Defaults to true.\n   *\n   * @param course The course to check.\n   * @returns Whether it allows seeing all sections at the same time.\n   */\n  canViewAllSections(course) {\n    return !!this.executeFunctionOnEnabled(course.format || '', 'canViewAllSections', [course]);\n  }\n  /**\n   * Whether the option blocks should be displayed. Defaults to true.\n   *\n   * @param course The course to check.\n   * @returns Whether it can display blocks.\n   */\n  displayBlocks(course) {\n    return !!this.executeFunctionOnEnabled(course.format || '', 'displayBlocks', [course]);\n  }\n  /**\n   * Whether the course refresher should be displayed. If it returns false, a refresher must be included in the course format,\n   * and the doRefresh method of CoreCourseSectionPage must be called on refresh. Defaults to true.\n   *\n   * @param course The course to check.\n   * @param sections List of course sections.\n   * @returns Whether the refresher should be displayed.\n   */\n  displayRefresher(course, sections) {\n    return !!this.executeFunctionOnEnabled(course.format || '', 'displayRefresher', [course, sections]);\n  }\n  /**\n   * Whether the default course index should be displayed. Defaults to true.\n   *\n   * @param course The course to check.\n   * @returns Whether the course index should be displayed.\n   */\n  displayCourseIndex(course) {\n    const display = this.executeFunctionOnEnabled(course.format || '', 'displayCourseIndex', [course]);\n    if (display !== undefined) {\n      return display;\n    }\n    // Use displaySectionSelector while is not completely deprecated.\n    return !!this.executeFunctionOnEnabled(course.format || '', 'displaySectionSelector', [course]);\n  }\n  /**\n   * Get the component to use to display all sections in a course.\n   *\n   * @param course The course to render.\n   * @returns Promise resolved with component to use, undefined if not found.\n   */\n  getAllSectionsComponent(course) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this.executeFunctionOnEnabled(course.format || '', 'getAllSectionsComponent', [course]);\n      } catch (error) {\n        _this.logger.error('Error getting all sections component', error);\n      }\n    })();\n  }\n  /**\n   * Get the component to use to display a course format.\n   *\n   * @param course The course to render.\n   * @returns Promise resolved with component to use, undefined if not found.\n   */\n  getCourseFormatComponent(course) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this2.executeFunctionOnEnabled(course.format || '', 'getCourseFormatComponent', [course]);\n      } catch (error) {\n        _this2.logger.error('Error getting course format component', error);\n      }\n    })();\n  }\n  /**\n   * Given a course, return the title to use in the course page.\n   *\n   * @param course The course to get the title.\n   * @param sections List of sections.\n   * @returns Course title.\n   */\n  getCourseTitle(course, sections) {\n    return this.executeFunctionOnEnabled(course.format || '', 'getCourseTitle', [course, sections]) || '';\n  }\n  /**\n   * Given a course and a list of sections, return the current section that should be displayed first.\n   *\n   * @param course The course to get the title.\n   * @param sections List of sections.\n   * @returns Promise.\n   */\n  getCurrentSection(course, sections) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const sectionData = yield _this3.executeFunctionOnEnabled(course.format || '', 'getCurrentSection', [course, sections]);\n        if (sectionData && typeof sectionData === 'object' && 'forceSelected' in sectionData) {\n          return sectionData;\n        } else if (sectionData) {\n          // Function just returned the section, don't force selecting it.\n          return {\n            section: sectionData,\n            forceSelected: false\n          };\n        }\n      } catch (_unused) {\n        // This function should never fail.\n      }\n      // Return the first section (usually, \"All sections\").\n      return {\n        section: sections[0],\n        forceSelected: false\n      };\n    })();\n  }\n  /**\n   * Returns the name for the highlighted section.\n   *\n   * @param course The course to get the text.\n   * @returns The name for the highlighted section based on the given course format.\n   */\n  getSectionHightlightedName(course) {\n    return this.executeFunctionOnEnabled(course.format || '', 'getSectionHightlightedName');\n  }\n  /**\n   * Get the component to use to display a single section. This component will only be used if the user is viewing\n   * a single section. If all the sections are displayed at once then it won't be used.\n   *\n   * @param course The course to render.\n   * @returns Promise resolved with component to use, undefined if not found.\n   */\n  getSingleSectionComponent(course) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this4.executeFunctionOnEnabled(course.format || '', 'getSingleSectionComponent', [course]);\n      } catch (error) {\n        _this4.logger.error('Error getting single section component', error);\n      }\n    })();\n  }\n  /**\n   * Invalidate the data required to load the course format.\n   *\n   * @param course The course to get the title.\n   * @param sections List of sections.\n   * @returns Promise resolved when the data is invalidated.\n   */\n  invalidateData(course, sections) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.executeFunctionOnEnabled(course.format || '', 'invalidateData', [course, sections]);\n    })();\n  }\n  /**\n   * Open a course. Should not be called directly. Call CoreCourseHelper.openCourse instead.\n   *\n   * @param course The course to open. It should contain a \"format\" attribute.\n   * @param navOptions Navigation options that includes params to pass to the page.\n   * @returns Promise resolved when done.\n   */\n  openCourse(course, navOptions) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.executeFunctionOnEnabled(course.format || '', 'openCourse', [course, navOptions]);\n    })();\n  }\n  /**\n   * Whether the view should be refreshed when completion changes. If your course format doesn't display\n   * activity completion then you should return false.\n   *\n   * @param course The course.\n   * @returns Whether course view should be refreshed when an activity completion changes.\n   */\n  shouldRefreshWhenCompletionChanges(course) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.executeFunctionOnEnabled(course.format || '', 'shouldRefreshWhenCompletionChanges', [course]);\n    })();\n  }\n}\n_class = CoreCourseFormatDelegateService;\n_class.ɵfac = function CoreCourseFormatDelegateService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.CoreCourseFormatDefaultHandler));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});\nexport const CoreCourseFormatDelegate = makeSingleton(CoreCourseFormatDelegateService);","map":{"version":3,"names":["CoreDelegate","makeSingleton","CoreCourseFormatDelegateService","constructor","defaultHandler","featurePrefix","handlerNameProperty","canViewAllSections","course","executeFunctionOnEnabled","format","displayBlocks","displayRefresher","sections","displayCourseIndex","display","undefined","getAllSectionsComponent","_this","_asyncToGenerator","error","logger","getCourseFormatComponent","_this2","getCourseTitle","getCurrentSection","_this3","sectionData","section","forceSelected","_unused","getSectionHightlightedName","getSingleSectionComponent","_this4","invalidateData","_this5","openCourse","navOptions","_this6","shouldRefreshWhenCompletionChanges","_this7","i0","ɵɵinject","i1","CoreCourseFormatDefaultHandler","factory","ɵfac","providedIn","CoreCourseFormatDelegate"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/features/course/services/format-delegate.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, Type } from '@angular/core';\n\nimport { CoreDelegate, CoreDelegateHandler } from '@classes/delegate';\nimport { CoreCourseAnyCourseData } from '@features/courses/services/courses';\nimport { CoreNavigationOptions } from '@services/navigator';\nimport { makeSingleton } from '@singletons';\nimport { CoreCourseWSSection } from './course';\nimport { CoreCourseSection } from './course-helper';\nimport { CoreCourseFormatDefaultHandler } from './handlers/default-format';\n\n/**\n * Interface that all course format handlers must implement.\n */\nexport interface CoreCourseFormatHandler extends CoreDelegateHandler {\n    /**\n     * Name of the format the handler supports. E.g. 'singleactivity'.\n     */\n    format: string;\n\n    /**\n     * Get the title to use in course page. If not defined, course fullname.\n     * This function will be called without sections first, and then call it again when the sections are retrieved.\n     *\n     * @param course The course.\n     * @param sections List of sections.\n     * @returns Title.\n     */\n    getCourseTitle?(course: CoreCourseAnyCourseData, sections?: CoreCourseWSSection[]): string;\n\n    /**\n     * Whether it allows seeing all sections at the same time. Defaults to true.\n     *\n     * @param course The course to check.\n     * @returns Whether it can view all sections.\n     */\n    canViewAllSections?(course: CoreCourseAnyCourseData): boolean;\n\n    /**\n     * Whether the option blocks should be displayed. Defaults to true.\n     *\n     * @param course The course to check.\n     * @returns Whether it can display blocks.\n     */\n    displayBlocks?(course: CoreCourseAnyCourseData): boolean;\n\n    /**\n     * Whether the default section selector should be displayed. Defaults to true.\n     *\n     * @param course The course to check.\n     * @returns Whether the default section selector should be displayed.\n     */\n    displayCourseIndex?(course: CoreCourseAnyCourseData): boolean;\n\n    /**\n     * Whether the course refresher should be displayed. If it returns false, a refresher must be included in the course format,\n     * and the doRefresh method of CoreCourseSectionPage must be called on refresh. Defaults to true.\n     *\n     * @param course The course to check.\n     * @param sections List of course sections.\n     * @returns Whether the refresher should be displayed.\n     */\n    displayRefresher?(course: CoreCourseAnyCourseData, sections: CoreCourseWSSection[]): boolean;\n\n    /**\n     * Given a list of sections, get the \"current\" section that should be displayed first. Defaults to first section.\n     *\n     * @param course The course to get the title.\n     * @param sections List of sections.\n     * @returns Promise resolved with current section and whether the section should be selected. If only the section is returned,\n     *         forceSelected will default to false.\n     */\n    getCurrentSection?(\n        course: CoreCourseAnyCourseData,\n        sections: CoreCourseSection[],\n    ): Promise<CoreCourseFormatCurrentSectionData<CoreCourseSection> | CoreCourseSection>;\n\n    /**\n     * Returns the name for the highlighted section.\n     *\n     * @returns The name for the highlighted section based on the given course format.\n     */\n    getSectionHightlightedName?(): string;\n\n    /**\n     * Open the page to display a course. If not defined, the page CoreCourseSectionPage will be opened.\n     * Implement it only if you want to create your own page to display the course. In general it's better to use the method\n     * getCourseFormatComponent because it will display the course handlers at the top.\n     * Your page should include the course handlers using CoreCoursesDelegate.\n     *\n     * @param course The course to open. It should contain a \"format\" attribute.\n     * @param navOptions Navigation options that includes params to pass to the page.\n     * @returns Promise resolved when done.\n     */\n    openCourse?(course: CoreCourseAnyCourseData, navOptions?: CoreNavigationOptions): Promise<void>;\n\n    /**\n     * Return the Component to use to display the course format instead of using the default one.\n     * Use it if you want to display a format completely different from the default one.\n     * If you want to customize the default format there are several methods to customize parts of it.\n     * It's recommended to return the class of the component, but you can also return an instance of the component.\n     *\n     * @param course The course to render.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    getCourseFormatComponent?(course: CoreCourseAnyCourseData): Promise<Type<unknown> | undefined>;\n\n    /**\n     * Return the Component to use to display a single section. This component will only be used if the user is viewing a\n     * single section. If all the sections are displayed at once then it won't be used.\n     * It's recommended to return the class of the component, but you can also return an instance of the component.\n     *\n     * @param course The course to render.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    getSingleSectionComponent?(course: CoreCourseAnyCourseData): Promise<Type<unknown> | undefined>;\n\n    /**\n     * Return the Component to use to display all sections in a course.\n     * It's recommended to return the class of the component, but you can also return an instance of the component.\n     *\n     * @param course The course to render.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    getAllSectionsComponent?(course: CoreCourseAnyCourseData): Promise<Type<unknown> | undefined>;\n\n    /**\n     * Invalidate the data required to load the course format.\n     *\n     * @param course The course to get the title.\n     * @param sections List of sections.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    invalidateData?(course: CoreCourseAnyCourseData, sections: CoreCourseWSSection[]): Promise<void>;\n\n    /**\n     * Whether the view should be refreshed when completion changes. If your course format doesn't display\n     * activity completion then you should return false.\n     *\n     * @param course The course.\n     * @returns Whether course view should be refreshed when an activity completion changes.\n     */\n    shouldRefreshWhenCompletionChanges?(course: CoreCourseAnyCourseData): Promise<boolean>;\n}\n\n/**\n * Service to interact with course formats.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreCourseFormatDelegateService extends CoreDelegate<CoreCourseFormatHandler> {\n\n    protected featurePrefix = 'CoreCourseFormatDelegate_';\n    protected handlerNameProperty = 'format';\n\n    constructor(protected defaultHandler: CoreCourseFormatDefaultHandler) {\n        super('CoreCoursesCourseFormatDelegate', true);\n    }\n\n    /**\n     * Whether it allows seeing all sections at the same time. Defaults to true.\n     *\n     * @param course The course to check.\n     * @returns Whether it allows seeing all sections at the same time.\n     */\n    canViewAllSections(course: CoreCourseAnyCourseData): boolean {\n        return !!this.executeFunctionOnEnabled<boolean>(course.format || '', 'canViewAllSections', [course]);\n    }\n\n    /**\n     * Whether the option blocks should be displayed. Defaults to true.\n     *\n     * @param course The course to check.\n     * @returns Whether it can display blocks.\n     */\n    displayBlocks(course: CoreCourseAnyCourseData): boolean {\n        return !!this.executeFunctionOnEnabled<boolean>(course.format || '', 'displayBlocks', [course]);\n    }\n\n    /**\n     * Whether the course refresher should be displayed. If it returns false, a refresher must be included in the course format,\n     * and the doRefresh method of CoreCourseSectionPage must be called on refresh. Defaults to true.\n     *\n     * @param course The course to check.\n     * @param sections List of course sections.\n     * @returns Whether the refresher should be displayed.\n     */\n    displayRefresher(course: CoreCourseAnyCourseData, sections: CoreCourseWSSection[]): boolean {\n        return !!this.executeFunctionOnEnabled<boolean>(course.format || '', 'displayRefresher', [course, sections]);\n    }\n\n    /**\n     * Whether the default course index should be displayed. Defaults to true.\n     *\n     * @param course The course to check.\n     * @returns Whether the course index should be displayed.\n     */\n    displayCourseIndex(course: CoreCourseAnyCourseData): boolean {\n        const display = this.executeFunctionOnEnabled<boolean>(course.format || '', 'displayCourseIndex', [course]);\n\n        if (display !== undefined) {\n            return display;\n        }\n\n        // Use displaySectionSelector while is not completely deprecated.\n        return !!this.executeFunctionOnEnabled<boolean>(course.format || '', 'displaySectionSelector', [course]);\n    }\n\n    /**\n     * Get the component to use to display all sections in a course.\n     *\n     * @param course The course to render.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    async getAllSectionsComponent(course: CoreCourseAnyCourseData): Promise<Type<unknown> | undefined> {\n        try {\n            return await this.executeFunctionOnEnabled<Type<unknown>>(course.format || '', 'getAllSectionsComponent', [course]);\n        } catch (error) {\n            this.logger.error('Error getting all sections component', error);\n        }\n    }\n\n    /**\n     * Get the component to use to display a course format.\n     *\n     * @param course The course to render.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    async getCourseFormatComponent(course: CoreCourseAnyCourseData): Promise<Type<unknown> | undefined> {\n        try {\n            return await this.executeFunctionOnEnabled<Type<unknown>>(course.format || '', 'getCourseFormatComponent', [course]);\n        } catch (error) {\n            this.logger.error('Error getting course format component', error);\n        }\n    }\n\n    /**\n     * Given a course, return the title to use in the course page.\n     *\n     * @param course The course to get the title.\n     * @param sections List of sections.\n     * @returns Course title.\n     */\n    getCourseTitle(course: CoreCourseAnyCourseData, sections?: CoreCourseWSSection[]): string {\n        return this.executeFunctionOnEnabled(course.format || '', 'getCourseTitle', [course, sections]) || '';\n    }\n\n    /**\n     * Given a course and a list of sections, return the current section that should be displayed first.\n     *\n     * @param course The course to get the title.\n     * @param sections List of sections.\n     * @returns Promise.\n     */\n    async getCurrentSection<T = CoreCourseSection>(\n        course: CoreCourseAnyCourseData,\n        sections: T[],\n    ): Promise<CoreCourseFormatCurrentSectionData<T>> {\n        try {\n            const sectionData = await this.executeFunctionOnEnabled<CoreCourseFormatCurrentSectionData<T> | T>(\n                course.format || '',\n                'getCurrentSection',\n                [course, sections],\n            );\n\n            if (sectionData && typeof sectionData === 'object' && 'forceSelected' in sectionData) {\n                return sectionData;\n            } else if (sectionData) {\n                // Function just returned the section, don't force selecting it.\n                return {\n                    section: sectionData,\n                    forceSelected: false,\n                };\n            }\n        } catch {\n            // This function should never fail.\n        }\n\n        // Return the first section (usually, \"All sections\").\n        return {\n            section: sections[0],\n            forceSelected: false,\n        };\n    }\n\n    /**\n     * Returns the name for the highlighted section.\n     *\n     * @param course The course to get the text.\n     * @returns The name for the highlighted section based on the given course format.\n     */\n    getSectionHightlightedName(course: CoreCourseAnyCourseData): string | undefined {\n        return this.executeFunctionOnEnabled<string>(\n            course.format || '',\n            'getSectionHightlightedName',\n        );\n    }\n\n    /**\n     * Get the component to use to display a single section. This component will only be used if the user is viewing\n     * a single section. If all the sections are displayed at once then it won't be used.\n     *\n     * @param course The course to render.\n     * @returns Promise resolved with component to use, undefined if not found.\n     */\n    async getSingleSectionComponent(course: CoreCourseAnyCourseData): Promise<Type<unknown> | undefined> {\n        try {\n            return await this.executeFunctionOnEnabled<Type<unknown>>(course.format || '', 'getSingleSectionComponent', [course]);\n        } catch (error) {\n            this.logger.error('Error getting single section component', error);\n        }\n    }\n\n    /**\n     * Invalidate the data required to load the course format.\n     *\n     * @param course The course to get the title.\n     * @param sections List of sections.\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateData(course: CoreCourseAnyCourseData, sections: CoreCourseWSSection[]): Promise<void> {\n        await this.executeFunctionOnEnabled(course.format || '', 'invalidateData', [course, sections]);\n    }\n\n    /**\n     * Open a course. Should not be called directly. Call CoreCourseHelper.openCourse instead.\n     *\n     * @param course The course to open. It should contain a \"format\" attribute.\n     * @param navOptions Navigation options that includes params to pass to the page.\n     * @returns Promise resolved when done.\n     */\n    async openCourse(course: CoreCourseAnyCourseData, navOptions?: CoreNavigationOptions): Promise<void> {\n        await this.executeFunctionOnEnabled(course.format || '', 'openCourse', [course, navOptions]);\n    }\n\n    /**\n     * Whether the view should be refreshed when completion changes. If your course format doesn't display\n     * activity completion then you should return false.\n     *\n     * @param course The course.\n     * @returns Whether course view should be refreshed when an activity completion changes.\n     */\n    async shouldRefreshWhenCompletionChanges(course: CoreCourseAnyCourseData): Promise<boolean | undefined> {\n        return this.executeFunctionOnEnabled(course.format || '', 'shouldRefreshWhenCompletionChanges', [course]);\n    }\n\n}\n\nexport const CoreCourseFormatDelegate = makeSingleton(CoreCourseFormatDelegateService);\n\nexport type CoreCourseFormatCurrentSectionData<T = CoreCourseSection> = {\n    section: T; // Current section.\n    forceSelected: boolean; // If true, the app will force selecting the section when opening the course.\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}