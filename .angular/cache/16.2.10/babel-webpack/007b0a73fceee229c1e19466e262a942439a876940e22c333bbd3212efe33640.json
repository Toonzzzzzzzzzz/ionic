{"ast":null,"code":"// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CorePath } from './path';\nimport { CoreText } from './text';\n/**\n * Singleton with helper functions for urls.\n */\nexport class CoreUrl {\n  // Avoid creating singleton instances.\n  constructor() {\n    // Nothing to do.\n  }\n  /**\n   * Parse parts of a url, using an implicit protocol if it is missing from the url.\n   *\n   * @param url Url.\n   * @returns Url parts.\n   */\n  static parse(url) {\n    // Parse url with regular expression taken from RFC 3986: https://tools.ietf.org/html/rfc3986#appendix-B.\n    const match = url.trim().match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/);\n    if (!match) {\n      return null;\n    }\n    const host = match[4] || '';\n    // Get the credentials and the port from the host.\n    const [domainAndPort, credentials] = host.split('@').reverse();\n    const [domain, port] = domainAndPort.split(':');\n    const [username, password] = credentials ? credentials.split(':') : [];\n    // Prepare parts replacing empty strings with undefined.\n    return {\n      protocol: match[2] || undefined,\n      domain: domain || undefined,\n      port: port || undefined,\n      credentials: credentials || undefined,\n      username: username || undefined,\n      password: password || undefined,\n      path: match[5] || undefined,\n      query: match[7] || undefined,\n      fragment: match[9] || undefined\n    };\n  }\n  /**\n   * Given some parts of a URL, returns the URL as a string.\n   *\n   * @param parts Parts.\n   * @returns Assembled URL.\n   */\n  static assemble(parts) {\n    var _parts$domain, _parts$path;\n    return (parts.protocol ? `${parts.protocol}://` : '') + (parts.credentials ? `${parts.credentials}@` : '') + ((_parts$domain = parts.domain) !== null && _parts$domain !== void 0 ? _parts$domain : '') + (parts.port ? `:${parts.port}` : '') + ((_parts$path = parts.path) !== null && _parts$path !== void 0 ? _parts$path : '') + (parts.query ? `?${parts.query}` : '') + (parts.fragment ? `#${parts.fragment}` : '');\n  }\n  /**\n   * Guess the Moodle domain from a site url.\n   *\n   * @param url Site url.\n   * @returns Guessed Moodle domain.\n   */\n  static guessMoodleDomain(url) {\n    // Add protocol if it was missing. Moodle can only be served through http or https, so this is a fair assumption to make.\n    if (!url.match(/^https?:\\/\\//)) {\n      url = `https://${url}`;\n    }\n    // Match using common suffixes.\n    const knownSuffixes = ['/my/?', '/\\\\?redirect=0', '/index\\\\.php', '/course/view\\\\.php', '\\\\/login/index\\\\.php', '/mod/page/view\\\\.php'];\n    const match = url.match(new RegExp(`^https?://(.*?)(${knownSuffixes.join('|')})`));\n    if (match) {\n      return match[1];\n    }\n    // If nothing else worked, parse the domain.\n    const urlParts = CoreUrl.parse(url);\n    return urlParts !== null && urlParts !== void 0 && urlParts.domain ? urlParts.domain : null;\n  }\n  /**\n   * Returns the pattern to check if the URL is a valid Moodle Url.\n   *\n   * @returns Desired RegExp.\n   */\n  static getValidMoodleUrlPattern() {\n    // Regular expression based on RFC 3986: https://tools.ietf.org/html/rfc3986#appendix-B.\n    // Improved to not admit spaces.\n    return new RegExp(/^(([^:/?# ]+):)?(\\/\\/([^/?# ]*))?([^?# ]*)(\\?([^#]*))?(#(.*))?$/);\n  }\n  /**\n   * Check if the given url is valid for the app to connect.\n   *\n   * @param url Url to check.\n   * @returns True if valid, false otherwise.\n   */\n  static isValidMoodleUrl(url) {\n    const patt = CoreUrl.getValidMoodleUrlPattern();\n    return patt.test(url.trim());\n  }\n  /**\n   * Removes protocol from the url.\n   *\n   * @param url Site url.\n   * @returns Url without protocol.\n   */\n  static removeProtocol(url) {\n    return url.replace(/^[a-zA-Z]+:\\/\\//i, '');\n  }\n  /**\n   * Check if two URLs have the same domain and path.\n   *\n   * @param urlA First URL.\n   * @param urlB Second URL.\n   * @returns Whether they have same domain and path.\n   */\n  static sameDomainAndPath(urlA, urlB) {\n    // Add protocol if missing, the parse function requires it.\n    if (!urlA.match(/^[^/:.?]*:\\/\\//)) {\n      urlA = `https://${urlA}`;\n    }\n    if (!urlB.match(/^[^/:.?]*:\\/\\//)) {\n      urlB = `https://${urlB}`;\n    }\n    const partsA = CoreUrl.parse(urlA);\n    const partsB = CoreUrl.parse(urlB);\n    partsA && Object.entries(partsA).forEach(([part, value]) => partsA[part] = value === null || value === void 0 ? void 0 : value.toLowerCase());\n    partsB && Object.entries(partsB).forEach(([part, value]) => partsB[part] = value === null || value === void 0 ? void 0 : value.toLowerCase());\n    return (partsA === null || partsA === void 0 ? void 0 : partsA.domain) === (partsB === null || partsB === void 0 ? void 0 : partsB.domain) && CoreText.removeEndingSlash(partsA === null || partsA === void 0 ? void 0 : partsA.path) === CoreText.removeEndingSlash(partsB === null || partsB === void 0 ? void 0 : partsB.path);\n  }\n  /**\n   * Get the anchor of a URL. If there's more than one they'll all be returned, separated by #.\n   * E.g. myurl.com#foo=1#bar=2 will return #foo=1#bar=2.\n   *\n   * @param url URL.\n   * @returns Anchor, undefined if no anchor.\n   */\n  static getUrlAnchor(url) {\n    const firstAnchorIndex = url.indexOf('#');\n    if (firstAnchorIndex === -1) {\n      return;\n    }\n    return url.substring(firstAnchorIndex);\n  }\n  /**\n   * Remove the anchor from a URL.\n   *\n   * @param url URL.\n   * @returns URL without anchor if any.\n   */\n  static removeUrlAnchor(url) {\n    const urlAndAnchor = url.split('#');\n    return urlAndAnchor[0];\n  }\n  /**\n   * Convert a URL to an absolute URL (if it isn't already).\n   *\n   * @param parentUrl The parent URL.\n   * @param url The url to convert.\n   * @returns Absolute URL.\n   */\n  static toAbsoluteURL(parentUrl, url) {\n    const parsedUrl = CoreUrl.parse(url);\n    if (parsedUrl !== null && parsedUrl !== void 0 && parsedUrl.protocol) {\n      return url; // Already absolute URL.\n    }\n\n    const parsedParentUrl = CoreUrl.parse(parentUrl);\n    if (url.startsWith('//')) {\n      // It only lacks the protocol, add it.\n      return ((parsedParentUrl === null || parsedParentUrl === void 0 ? void 0 : parsedParentUrl.protocol) || 'https') + ':' + url;\n    }\n    // The URL should be added after the domain (if starts with /) or after the parent path.\n    const treatedParentUrl = CoreUrl.assemble({\n      protocol: (parsedParentUrl === null || parsedParentUrl === void 0 ? void 0 : parsedParentUrl.protocol) || 'https',\n      domain: parsedParentUrl === null || parsedParentUrl === void 0 ? void 0 : parsedParentUrl.domain,\n      port: parsedParentUrl === null || parsedParentUrl === void 0 ? void 0 : parsedParentUrl.port,\n      credentials: parsedParentUrl === null || parsedParentUrl === void 0 ? void 0 : parsedParentUrl.credentials,\n      path: url.startsWith('/') ? undefined : parsedParentUrl === null || parsedParentUrl === void 0 ? void 0 : parsedParentUrl.path\n    });\n    return CorePath.concatenatePaths(treatedParentUrl, url);\n  }\n  /**\n   * Convert a URL to a relative URL (if it isn't already).\n   *\n   * @param parentUrl The parent URL.\n   * @param url The url to convert.\n   * @returns Relative URL.\n   */\n  static toRelativeURL(parentUrl, url) {\n    parentUrl = CoreUrl.removeProtocol(parentUrl);\n    if (!url.includes(parentUrl)) {\n      return url; // Already relative URL.\n    }\n\n    return CoreText.removeStartingSlash(CoreUrl.removeProtocol(url).replace(parentUrl, ''));\n  }\n  /**\n   * Returns if URL is a Vimeo video URL.\n   *\n   * @param url URL.\n   * @returns Whether is a Vimeo video URL.\n   */\n  static isVimeoVideoUrl(url) {\n    return !!url.match(/https?:\\/\\/player\\.vimeo\\.com\\/video\\/[0-9]+/);\n  }\n  /**\n   * Get the URL to use to play a Vimeo video if the URL supplied is a Vimeo video URL.\n   * If it's a Vimeo video, the app will use the site's wsplayer script instead to make restricted videos work.\n   *\n   * @param url URL to treat.\n   * @param site Site that contains the URL.\n   * @returns URL, undefined if not a Vimeo video.\n   */\n  static getVimeoPlayerUrl(url, site) {\n    const matches = url.match(/https?:\\/\\/player\\.vimeo\\.com\\/video\\/([0-9]+)([?&]+h=([a-zA-Z0-9]*))?/);\n    if (!matches || !matches[1]) {\n      // Not a Vimeo video.\n      return;\n    }\n    let newUrl = CorePath.concatenatePaths(site.getURL(), '/media/player/vimeo/wsplayer.php?video=') + matches[1] + '&token=' + site.getToken();\n    let privacyHash = matches[3];\n    if (!privacyHash) {\n      // No privacy hash using the new format. Check the legacy format.\n      const matches = url.match(/https?:\\/\\/player\\.vimeo\\.com\\/video\\/([0-9]+)(\\/([a-zA-Z0-9]+))?/);\n      privacyHash = matches && matches[3];\n    }\n    if (privacyHash) {\n      newUrl += `&h=${privacyHash}`;\n    }\n    return newUrl;\n  }\n}","map":{"version":3,"names":["CorePath","CoreText","CoreUrl","constructor","parse","url","match","trim","host","domainAndPort","credentials","split","reverse","domain","port","username","password","protocol","undefined","path","query","fragment","assemble","parts","_parts$domain","_parts$path","guessMoodleDomain","knownSuffixes","RegExp","join","urlParts","getValidMoodleUrlPattern","isValidMoodleUrl","patt","test","removeProtocol","replace","sameDomainAndPath","urlA","urlB","partsA","partsB","Object","entries","forEach","part","value","toLowerCase","removeEndingSlash","getUrlAnchor","firstAnchorIndex","indexOf","substring","removeUrlAnchor","urlAndAnchor","toAbsoluteURL","parentUrl","parsedUrl","parsedParentUrl","startsWith","treatedParentUrl","concatenatePaths","toRelativeURL","includes","removeStartingSlash","isVimeoVideoUrl","getVimeoPlayerUrl","site","matches","newUrl","getURL","getToken","privacyHash"],"sources":["/home/toon/works/gitionic7/ionic-github/ionic/src/core/singletons/url.ts"],"sourcesContent":["// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { CoreSite } from '@classes/sites/site';\nimport { CorePath } from './path';\nimport { CoreText } from './text';\n\n/**\n * Parts contained within a url.\n */\ninterface UrlParts {\n\n    /**\n     * Url protocol.\n     */\n    protocol?: string;\n\n    /**\n     * Url domain.\n     */\n    domain?: string;\n\n    /**\n     * Url port.\n     */\n    port?: string;\n\n    /**\n     * Url credentials: username and password (if any).\n     */\n    credentials?: string;\n\n    /**\n     * Url's username.\n     */\n    username?: string;\n\n    /**\n     * Url's password.\n     */\n    password?: string;\n\n    /**\n     * Url path.\n     */\n    path?: string;\n\n    /**\n     * Url query.\n     */\n    query?: string;\n\n    /**\n     * Url fragment.\n     */\n    fragment?: string;\n\n}\n\n/**\n * Singleton with helper functions for urls.\n */\nexport class CoreUrl {\n\n    // Avoid creating singleton instances.\n    private constructor() {\n        // Nothing to do.\n    }\n\n    /**\n     * Parse parts of a url, using an implicit protocol if it is missing from the url.\n     *\n     * @param url Url.\n     * @returns Url parts.\n     */\n    static parse(url: string): UrlParts | null {\n        // Parse url with regular expression taken from RFC 3986: https://tools.ietf.org/html/rfc3986#appendix-B.\n        const match = url.trim().match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/);\n\n        if (!match) {\n            return null;\n        }\n\n        const host = match[4] || '';\n\n        // Get the credentials and the port from the host.\n        const [domainAndPort, credentials]: string[] = host.split('@').reverse();\n        const [domain, port]: string[] = domainAndPort.split(':');\n        const [username, password]: string[] = credentials ? credentials.split(':') : [];\n\n        // Prepare parts replacing empty strings with undefined.\n        return {\n            protocol: match[2] || undefined,\n            domain: domain || undefined,\n            port: port || undefined,\n            credentials: credentials || undefined,\n            username: username || undefined,\n            password: password || undefined,\n            path: match[5] || undefined,\n            query: match[7] || undefined,\n            fragment: match[9] || undefined,\n        };\n    }\n\n    /**\n     * Given some parts of a URL, returns the URL as a string.\n     *\n     * @param parts Parts.\n     * @returns Assembled URL.\n     */\n    static assemble(parts: UrlParts): string {\n        return (parts.protocol ? `${parts.protocol}://` : '') +\n            (parts.credentials ? `${parts.credentials}@` : '') +\n            (parts.domain ?? '') +\n            (parts.port ? `:${parts.port}` : '') +\n            (parts.path ?? '') +\n            (parts.query ? `?${parts.query}` : '') +\n            (parts.fragment ? `#${parts.fragment}` : '');\n    }\n\n    /**\n     * Guess the Moodle domain from a site url.\n     *\n     * @param url Site url.\n     * @returns Guessed Moodle domain.\n     */\n    static guessMoodleDomain(url: string): string | null {\n        // Add protocol if it was missing. Moodle can only be served through http or https, so this is a fair assumption to make.\n        if (!url.match(/^https?:\\/\\//)) {\n            url = `https://${url}`;\n        }\n\n        // Match using common suffixes.\n        const knownSuffixes = [\n            '/my/?',\n            '/\\\\?redirect=0',\n            '/index\\\\.php',\n            '/course/view\\\\.php',\n            '\\\\/login/index\\\\.php',\n            '/mod/page/view\\\\.php',\n        ];\n        const match = url.match(new RegExp(`^https?://(.*?)(${knownSuffixes.join('|')})`));\n\n        if (match) {\n            return match[1];\n        }\n\n        // If nothing else worked, parse the domain.\n        const urlParts = CoreUrl.parse(url);\n\n        return urlParts?.domain ? urlParts.domain : null;\n    }\n\n    /**\n     * Returns the pattern to check if the URL is a valid Moodle Url.\n     *\n     * @returns Desired RegExp.\n     */\n    static getValidMoodleUrlPattern(): RegExp {\n        // Regular expression based on RFC 3986: https://tools.ietf.org/html/rfc3986#appendix-B.\n        // Improved to not admit spaces.\n        return new RegExp(/^(([^:/?# ]+):)?(\\/\\/([^/?# ]*))?([^?# ]*)(\\?([^#]*))?(#(.*))?$/);\n    }\n\n    /**\n     * Check if the given url is valid for the app to connect.\n     *\n     * @param url Url to check.\n     * @returns True if valid, false otherwise.\n     */\n    static isValidMoodleUrl(url: string): boolean {\n        const patt = CoreUrl.getValidMoodleUrlPattern();\n\n        return patt.test(url.trim());\n    }\n\n    /**\n     * Removes protocol from the url.\n     *\n     * @param url Site url.\n     * @returns Url without protocol.\n     */\n    static removeProtocol(url: string): string {\n        return url.replace(/^[a-zA-Z]+:\\/\\//i, '');\n    }\n\n    /**\n     * Check if two URLs have the same domain and path.\n     *\n     * @param urlA First URL.\n     * @param urlB Second URL.\n     * @returns Whether they have same domain and path.\n     */\n    static sameDomainAndPath(urlA: string, urlB: string): boolean {\n        // Add protocol if missing, the parse function requires it.\n        if (!urlA.match(/^[^/:.?]*:\\/\\//)) {\n            urlA = `https://${urlA}`;\n        }\n        if (!urlB.match(/^[^/:.?]*:\\/\\//)) {\n            urlB = `https://${urlB}`;\n        }\n\n        const partsA = CoreUrl.parse(urlA);\n        const partsB = CoreUrl.parse(urlB);\n\n        partsA && Object.entries(partsA).forEach(([part, value]) => partsA[part] = value?.toLowerCase());\n        partsB && Object.entries(partsB).forEach(([part, value]) => partsB[part] = value?.toLowerCase());\n\n        return partsA?.domain === partsB?.domain\n            && CoreText.removeEndingSlash(partsA?.path) === CoreText.removeEndingSlash(partsB?.path);\n    }\n\n    /**\n     * Get the anchor of a URL. If there's more than one they'll all be returned, separated by #.\n     * E.g. myurl.com#foo=1#bar=2 will return #foo=1#bar=2.\n     *\n     * @param url URL.\n     * @returns Anchor, undefined if no anchor.\n     */\n    static getUrlAnchor(url: string): string | undefined {\n        const firstAnchorIndex = url.indexOf('#');\n        if (firstAnchorIndex === -1) {\n            return;\n        }\n\n        return url.substring(firstAnchorIndex);\n    }\n\n    /**\n     * Remove the anchor from a URL.\n     *\n     * @param url URL.\n     * @returns URL without anchor if any.\n     */\n    static removeUrlAnchor(url: string): string {\n        const urlAndAnchor = url.split('#');\n\n        return urlAndAnchor[0];\n    }\n\n    /**\n     * Convert a URL to an absolute URL (if it isn't already).\n     *\n     * @param parentUrl The parent URL.\n     * @param url The url to convert.\n     * @returns Absolute URL.\n     */\n    static toAbsoluteURL(parentUrl: string, url: string): string {\n        const parsedUrl = CoreUrl.parse(url);\n\n        if (parsedUrl?.protocol) {\n            return url; // Already absolute URL.\n        }\n\n        const parsedParentUrl = CoreUrl.parse(parentUrl);\n\n        if (url.startsWith('//')) {\n            // It only lacks the protocol, add it.\n            return (parsedParentUrl?.protocol || 'https') + ':' + url;\n        }\n\n        // The URL should be added after the domain (if starts with /) or after the parent path.\n        const treatedParentUrl = CoreUrl.assemble({\n            protocol: parsedParentUrl?.protocol || 'https',\n            domain: parsedParentUrl?.domain,\n            port: parsedParentUrl?.port,\n            credentials: parsedParentUrl?.credentials,\n            path: url.startsWith('/') ? undefined : parsedParentUrl?.path,\n        });\n\n        return CorePath.concatenatePaths(treatedParentUrl, url);\n    }\n\n    /**\n     * Convert a URL to a relative URL (if it isn't already).\n     *\n     * @param parentUrl The parent URL.\n     * @param url The url to convert.\n     * @returns Relative URL.\n     */\n    static toRelativeURL(parentUrl: string, url: string): string {\n        parentUrl = CoreUrl.removeProtocol(parentUrl);\n\n        if (!url.includes(parentUrl)) {\n            return url; // Already relative URL.\n        }\n\n        return CoreText.removeStartingSlash(CoreUrl.removeProtocol(url).replace(parentUrl, ''));\n    }\n\n    /**\n     * Returns if URL is a Vimeo video URL.\n     *\n     * @param url URL.\n     * @returns Whether is a Vimeo video URL.\n     */\n    static isVimeoVideoUrl(url: string): boolean {\n        return !!url.match(/https?:\\/\\/player\\.vimeo\\.com\\/video\\/[0-9]+/);\n    }\n\n    /**\n     * Get the URL to use to play a Vimeo video if the URL supplied is a Vimeo video URL.\n     * If it's a Vimeo video, the app will use the site's wsplayer script instead to make restricted videos work.\n     *\n     * @param url URL to treat.\n     * @param site Site that contains the URL.\n     * @returns URL, undefined if not a Vimeo video.\n     */\n    static getVimeoPlayerUrl(\n        url: string,\n        site: CoreSite,\n    ): string | undefined {\n        const matches = url.match(/https?:\\/\\/player\\.vimeo\\.com\\/video\\/([0-9]+)([?&]+h=([a-zA-Z0-9]*))?/);\n        if (!matches || !matches[1]) {\n            // Not a Vimeo video.\n            return;\n        }\n\n        let newUrl = CorePath.concatenatePaths(site.getURL(), '/media/player/vimeo/wsplayer.php?video=') +\n            matches[1] + '&token=' + site.getToken();\n\n        let privacyHash: string | undefined | null = matches[3];\n        if (!privacyHash) {\n            // No privacy hash using the new format. Check the legacy format.\n            const matches = url.match(/https?:\\/\\/player\\.vimeo\\.com\\/video\\/([0-9]+)(\\/([a-zA-Z0-9]+))?/);\n            privacyHash = matches && matches[3];\n        }\n\n        if (privacyHash) {\n            newUrl += `&h=${privacyHash}`;\n        }\n\n        return newUrl;\n    }\n\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,SAASA,QAAQ,QAAQ,QAAQ;AACjC,SAASC,QAAQ,QAAQ,QAAQ;AAsDjC;;;AAGA,OAAM,MAAOC,OAAO;EAEhB;EACAC,YAAA;IACI;EAAA;EAGJ;;;;;;EAMA,OAAOC,KAAKA,CAACC,GAAW;IACpB;IACA,MAAMC,KAAK,GAAGD,GAAG,CAACE,IAAI,EAAE,CAACD,KAAK,CAAC,6DAA6D,CAAC;IAE7F,IAAI,CAACA,KAAK,EAAE;MACR,OAAO,IAAI;;IAGf,MAAME,IAAI,GAAGF,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;IAE3B;IACA,MAAM,CAACG,aAAa,EAAEC,WAAW,CAAC,GAAaF,IAAI,CAACG,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,EAAE;IACxE,MAAM,CAACC,MAAM,EAAEC,IAAI,CAAC,GAAaL,aAAa,CAACE,KAAK,CAAC,GAAG,CAAC;IACzD,MAAM,CAACI,QAAQ,EAAEC,QAAQ,CAAC,GAAaN,WAAW,GAAGA,WAAW,CAACC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;IAEhF;IACA,OAAO;MACHM,QAAQ,EAAEX,KAAK,CAAC,CAAC,CAAC,IAAIY,SAAS;MAC/BL,MAAM,EAAEA,MAAM,IAAIK,SAAS;MAC3BJ,IAAI,EAAEA,IAAI,IAAII,SAAS;MACvBR,WAAW,EAAEA,WAAW,IAAIQ,SAAS;MACrCH,QAAQ,EAAEA,QAAQ,IAAIG,SAAS;MAC/BF,QAAQ,EAAEA,QAAQ,IAAIE,SAAS;MAC/BC,IAAI,EAAEb,KAAK,CAAC,CAAC,CAAC,IAAIY,SAAS;MAC3BE,KAAK,EAAEd,KAAK,CAAC,CAAC,CAAC,IAAIY,SAAS;MAC5BG,QAAQ,EAAEf,KAAK,CAAC,CAAC,CAAC,IAAIY;KACzB;EACL;EAEA;;;;;;EAMA,OAAOI,QAAQA,CAACC,KAAe;IAAA,IAAAC,aAAA,EAAAC,WAAA;IAC3B,OAAO,CAACF,KAAK,CAACN,QAAQ,GAAG,GAAGM,KAAK,CAACN,QAAQ,KAAK,GAAG,EAAE,KAC/CM,KAAK,CAACb,WAAW,GAAG,GAAGa,KAAK,CAACb,WAAW,GAAG,GAAG,EAAE,CAAC,KAAAc,aAAA,GACjDD,KAAK,CAACV,MAAM,cAAAW,aAAA,cAAAA,aAAA,GAAI,EAAE,CAAC,IACnBD,KAAK,CAACT,IAAI,GAAG,IAAIS,KAAK,CAACT,IAAI,EAAE,GAAG,EAAE,CAAC,KAAAW,WAAA,GACnCF,KAAK,CAACJ,IAAI,cAAAM,WAAA,cAAAA,WAAA,GAAI,EAAE,CAAC,IACjBF,KAAK,CAACH,KAAK,GAAG,IAAIG,KAAK,CAACH,KAAK,EAAE,GAAG,EAAE,CAAC,IACrCG,KAAK,CAACF,QAAQ,GAAG,IAAIE,KAAK,CAACF,QAAQ,EAAE,GAAG,EAAE,CAAC;EACpD;EAEA;;;;;;EAMA,OAAOK,iBAAiBA,CAACrB,GAAW;IAChC;IACA,IAAI,CAACA,GAAG,CAACC,KAAK,CAAC,cAAc,CAAC,EAAE;MAC5BD,GAAG,GAAG,WAAWA,GAAG,EAAE;;IAG1B;IACA,MAAMsB,aAAa,GAAG,CAClB,OAAO,EACP,gBAAgB,EAChB,cAAc,EACd,oBAAoB,EACpB,sBAAsB,EACtB,sBAAsB,CACzB;IACD,MAAMrB,KAAK,GAAGD,GAAG,CAACC,KAAK,CAAC,IAAIsB,MAAM,CAAC,mBAAmBD,aAAa,CAACE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAElF,IAAIvB,KAAK,EAAE;MACP,OAAOA,KAAK,CAAC,CAAC,CAAC;;IAGnB;IACA,MAAMwB,QAAQ,GAAG5B,OAAO,CAACE,KAAK,CAACC,GAAG,CAAC;IAEnC,OAAOyB,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAEjB,MAAM,GAAGiB,QAAQ,CAACjB,MAAM,GAAG,IAAI;EACpD;EAEA;;;;;EAKA,OAAOkB,wBAAwBA,CAAA;IAC3B;IACA;IACA,OAAO,IAAIH,MAAM,CAAC,iEAAiE,CAAC;EACxF;EAEA;;;;;;EAMA,OAAOI,gBAAgBA,CAAC3B,GAAW;IAC/B,MAAM4B,IAAI,GAAG/B,OAAO,CAAC6B,wBAAwB,EAAE;IAE/C,OAAOE,IAAI,CAACC,IAAI,CAAC7B,GAAG,CAACE,IAAI,EAAE,CAAC;EAChC;EAEA;;;;;;EAMA,OAAO4B,cAAcA,CAAC9B,GAAW;IAC7B,OAAOA,GAAG,CAAC+B,OAAO,CAAC,kBAAkB,EAAE,EAAE,CAAC;EAC9C;EAEA;;;;;;;EAOA,OAAOC,iBAAiBA,CAACC,IAAY,EAAEC,IAAY;IAC/C;IACA,IAAI,CAACD,IAAI,CAAChC,KAAK,CAAC,gBAAgB,CAAC,EAAE;MAC/BgC,IAAI,GAAG,WAAWA,IAAI,EAAE;;IAE5B,IAAI,CAACC,IAAI,CAACjC,KAAK,CAAC,gBAAgB,CAAC,EAAE;MAC/BiC,IAAI,GAAG,WAAWA,IAAI,EAAE;;IAG5B,MAAMC,MAAM,GAAGtC,OAAO,CAACE,KAAK,CAACkC,IAAI,CAAC;IAClC,MAAMG,MAAM,GAAGvC,OAAO,CAACE,KAAK,CAACmC,IAAI,CAAC;IAElCC,MAAM,IAAIE,MAAM,CAACC,OAAO,CAACH,MAAM,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,IAAI,EAAEC,KAAK,CAAC,KAAKN,MAAM,CAACK,IAAI,CAAC,GAAGC,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,WAAW,EAAE,CAAC;IAChGN,MAAM,IAAIC,MAAM,CAACC,OAAO,CAACF,MAAM,CAAC,CAACG,OAAO,CAAC,CAAC,CAACC,IAAI,EAAEC,KAAK,CAAC,KAAKL,MAAM,CAACI,IAAI,CAAC,GAAGC,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,WAAW,EAAE,CAAC;IAEhG,OAAO,CAAAP,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE3B,MAAM,OAAK4B,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE5B,MAAM,KACjCZ,QAAQ,CAAC+C,iBAAiB,CAACR,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAErB,IAAI,CAAC,KAAKlB,QAAQ,CAAC+C,iBAAiB,CAACP,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEtB,IAAI,CAAC;EAChG;EAEA;;;;;;;EAOA,OAAO8B,YAAYA,CAAC5C,GAAW;IAC3B,MAAM6C,gBAAgB,GAAG7C,GAAG,CAAC8C,OAAO,CAAC,GAAG,CAAC;IACzC,IAAID,gBAAgB,KAAK,CAAC,CAAC,EAAE;MACzB;;IAGJ,OAAO7C,GAAG,CAAC+C,SAAS,CAACF,gBAAgB,CAAC;EAC1C;EAEA;;;;;;EAMA,OAAOG,eAAeA,CAAChD,GAAW;IAC9B,MAAMiD,YAAY,GAAGjD,GAAG,CAACM,KAAK,CAAC,GAAG,CAAC;IAEnC,OAAO2C,YAAY,CAAC,CAAC,CAAC;EAC1B;EAEA;;;;;;;EAOA,OAAOC,aAAaA,CAACC,SAAiB,EAAEnD,GAAW;IAC/C,MAAMoD,SAAS,GAAGvD,OAAO,CAACE,KAAK,CAACC,GAAG,CAAC;IAEpC,IAAIoD,SAAS,aAATA,SAAS,eAATA,SAAS,CAAExC,QAAQ,EAAE;MACrB,OAAOZ,GAAG,CAAC,CAAC;;;IAGhB,MAAMqD,eAAe,GAAGxD,OAAO,CAACE,KAAK,CAACoD,SAAS,CAAC;IAEhD,IAAInD,GAAG,CAACsD,UAAU,CAAC,IAAI,CAAC,EAAE;MACtB;MACA,OAAO,CAAC,CAAAD,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEzC,QAAQ,KAAI,OAAO,IAAI,GAAG,GAAGZ,GAAG;;IAG7D;IACA,MAAMuD,gBAAgB,GAAG1D,OAAO,CAACoB,QAAQ,CAAC;MACtCL,QAAQ,EAAE,CAAAyC,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEzC,QAAQ,KAAI,OAAO;MAC9CJ,MAAM,EAAE6C,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE7C,MAAM;MAC/BC,IAAI,EAAE4C,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE5C,IAAI;MAC3BJ,WAAW,EAAEgD,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEhD,WAAW;MACzCS,IAAI,EAAEd,GAAG,CAACsD,UAAU,CAAC,GAAG,CAAC,GAAGzC,SAAS,GAAGwC,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEvC;KAC5D,CAAC;IAEF,OAAOnB,QAAQ,CAAC6D,gBAAgB,CAACD,gBAAgB,EAAEvD,GAAG,CAAC;EAC3D;EAEA;;;;;;;EAOA,OAAOyD,aAAaA,CAACN,SAAiB,EAAEnD,GAAW;IAC/CmD,SAAS,GAAGtD,OAAO,CAACiC,cAAc,CAACqB,SAAS,CAAC;IAE7C,IAAI,CAACnD,GAAG,CAAC0D,QAAQ,CAACP,SAAS,CAAC,EAAE;MAC1B,OAAOnD,GAAG,CAAC,CAAC;;;IAGhB,OAAOJ,QAAQ,CAAC+D,mBAAmB,CAAC9D,OAAO,CAACiC,cAAc,CAAC9B,GAAG,CAAC,CAAC+B,OAAO,CAACoB,SAAS,EAAE,EAAE,CAAC,CAAC;EAC3F;EAEA;;;;;;EAMA,OAAOS,eAAeA,CAAC5D,GAAW;IAC9B,OAAO,CAAC,CAACA,GAAG,CAACC,KAAK,CAAC,8CAA8C,CAAC;EACtE;EAEA;;;;;;;;EAQA,OAAO4D,iBAAiBA,CACpB7D,GAAW,EACX8D,IAAc;IAEd,MAAMC,OAAO,GAAG/D,GAAG,CAACC,KAAK,CAAC,wEAAwE,CAAC;IACnG,IAAI,CAAC8D,OAAO,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,EAAE;MACzB;MACA;;IAGJ,IAAIC,MAAM,GAAGrE,QAAQ,CAAC6D,gBAAgB,CAACM,IAAI,CAACG,MAAM,EAAE,EAAE,yCAAyC,CAAC,GAC5FF,OAAO,CAAC,CAAC,CAAC,GAAG,SAAS,GAAGD,IAAI,CAACI,QAAQ,EAAE;IAE5C,IAAIC,WAAW,GAA8BJ,OAAO,CAAC,CAAC,CAAC;IACvD,IAAI,CAACI,WAAW,EAAE;MACd;MACA,MAAMJ,OAAO,GAAG/D,GAAG,CAACC,KAAK,CAAC,mEAAmE,CAAC;MAC9FkE,WAAW,GAAGJ,OAAO,IAAIA,OAAO,CAAC,CAAC,CAAC;;IAGvC,IAAII,WAAW,EAAE;MACbH,MAAM,IAAI,MAAMG,WAAW,EAAE;;IAGjC,OAAOH,MAAM;EACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}